------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}	; constant
    273  28000 ????			    .Palette   SET	{2}	; constant/variable MACARG2CONST
    274  28000 ????			    .SpriteX   SET	{3}	; constant/variable MACARG3CONST
    275  28000 ????			    .SpriteY   SET	{4}	; constant/variable MACARG4CONST
    276  28000 ????			    .ByteOffset SET	{5}	; constant/variable MACARG5CONST
    277  28000 ????
    278  28000 ????				       if	MACARG4CONST = 0
    279  28000 ????				       lda	.SpriteY
    280  28000 ????				       else
    281  28000 ????				       lda	#.SpriteY
    282  28000 ????				       endif
    283  28000 ????
    284  28000 ????				       lsr
    285  28000 ????				       lsr
    286  28000 ????				       asr	#%11111110	; ensure carry is clear
    287  28000 ????				       if	WZONEHEIGHT = 16
    288  28000 ????				       asr	#%11111110	; ensure carry is clear
    289  28000 ????				       endif
    290  28000 ????
    291  28000 ????				       tax
    292  28000 ????
    293  28000 ????				       cpx	#WZONECOUNT
    294  28000 ????				       bcs	.PLOTSPRITEnext
    295  28000 ????						; carry is clear
    296  28000 ????
    297  28000 ????				       ifconst	VSCROLL
    298  28000 ????				       ldy	Xx3,x
    299  28000 ????				       lda	DLLMEM+11,y
    300  28000 ????				       else		; !VSCROLL
    301  28000 ????				       lda	DLPOINTL,x	; Get pointer to DL that this sprite starts in
    302  28000 ????				       endif
    303  28000 ????				       ifconst	DOUBLEBUFFER
    304  28000 ????				       adc	doublebufferdloffset
    305  28000 ????				       endif		; DOUBLEBUFFER
    306  28000 ????				       sta	dlpnt
    307  28000 ????				       ifconst	VSCROLL
    308  28000 ????				       lda	DLLMEM+10,y
    309  28000 ????				       else		; !VSCROLL
    310  28000 ????				       lda	DLPOINTH,x
    311  28000 ????				       endif		; !VSCROLL
    312  28000 ????				       ifconst	DOUBLEBUFFER
    313  28000 ????				       adc	#0
    314  28000 ????				       endif		; DOUBLEBUFFER
    315  28000 ????				       sta	dlpnt+1
    316  28000 ????
    317  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    318  28000 ????
    319  28000 ????				       ifconst	.ByteOffset
    320  28000 ????
    321  28000 ????				       if	MACARG5CONST = 1
    322  28000 ????				       lda	#.ByteOffset
    323  28000 ????				       else
    324  28000 ????				       lda	.ByteOffset
    325  28000 ????				       endif
    326  28000 ????				       ifconst	DOUBLEBUFFER
    327  28000 ????				       if	{1}_width = 1
    328  28000 ????				       clc
    329  28000 ????				       endif
    330  28000 ????				       endif
    331  28000 ????				       if	{1}_width = 2
    332  28000 ????				       asl
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 3
    335  28000 ????				       asl
    336  28000 ????				       if	MACARG5CONST = 1
    337  28000 ????				       adc	#.ByteOffset
    338  28000 ????				       else
    339  28000 ????				       adc	.ByteOffset
    340  28000 ????				       endif
    341  28000 ????				       endif
    342  28000 ????				       if	{1}_width = 4
    343  28000 ????				       asl
    344  28000 ????				       asl
    345  28000 ????				       endif
    346  28000 ????				       if	{1}_width = 5
    347  28000 ????				       asl
    348  28000 ????				       asl
    349  28000 ????				       if	MACARG5CONST = 1
    350  28000 ????				       adc	#.ByteOffset
    351  28000 ????				       else
    352  28000 ????				       adc	.ByteOffset
    353  28000 ????				       endif
    354  28000 ????				       endif
    355  28000 ????				       if	{1}_width = 6
    356  28000 ????				       asl
    357  28000 ????				       if	MACARG5CONST = 1
    358  28000 ????				       adc	#.ByteOffset
    359  28000 ????				       else
    360  28000 ????				       adc	.ByteOffset
    361  28000 ????				       endif
    362  28000 ????				       asl
    363  28000 ????				       endif
    364  28000 ????				       if	{1}_width = 7
    365  28000 ????				       asl
    366  28000 ????				       if	MACARG5CONST = 1
    367  28000 ????				       adc	#.ByteOffset
    368  28000 ????				       else
    369  28000 ????				       adc	.ByteOffset
    370  28000 ????				       endif
    371  28000 ????				       asl
    372  28000 ????				       if	MACARG5CONST = 1
    373  28000 ????				       adc	#.ByteOffset
    374  28000 ????				       else
    375  28000 ????				       adc	.ByteOffset
    376  28000 ????				       endif
    377  28000 ????				       endif
    378  28000 ????				       if	{1}_width = 8
    379  28000 ????				       asl
    380  28000 ????				       asl
    381  28000 ????				       asl
    382  28000 ????				       endif
    383  28000 ????				       if	{1}_width = 9
    384  28000 ????				       asl
    385  28000 ????				       asl
    386  28000 ????				       asl
    387  28000 ????				       if	MACARG5CONST = 1
    388  28000 ????				       adc	#.ByteOffset
    389  28000 ????				       else
    390  28000 ????				       adc	.ByteOffset
    391  28000 ????				       endif
    392  28000 ????				       endif
    393  28000 ????				       if	{1}_width = 10
    394  28000 ????				       asl
    395  28000 ????				       asl
    396  28000 ????				       if	MACARG5CONST = 1
    397  28000 ????				       adc	#.ByteOffset
    398  28000 ????				       else
    399  28000 ????				       adc	.ByteOffset
    400  28000 ????				       endif
    401  28000 ????				       asl
    402  28000 ????				       endif
    403  28000 ????				       if	{1}_width = 11
    404  28000 ????				       asl
    405  28000 ????				       asl
    406  28000 ????				       if	MACARG5CONST = 1
    407  28000 ????				       adc	#.ByteOffset
    408  28000 ????				       else
    409  28000 ????				       adc	.ByteOffset
    410  28000 ????				       endif
    411  28000 ????				       asl
    412  28000 ????				       if	MACARG5CONST = 1
    413  28000 ????				       adc	#.ByteOffset
    414  28000 ????				       else
    415  28000 ????				       adc	.ByteOffset
    416  28000 ????				       endif
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 12
    419  28000 ????				       asl
    420  28000 ????				       if	MACARG5CONST = 1
    421  28000 ????				       adc	#.ByteOffset
    422  28000 ????				       else
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       asl
    426  28000 ????				       asl
    427  28000 ????				       endif
    428  28000 ????				       if	{1}_width = 13
    429  28000 ????				       asl
    430  28000 ????				       if	MACARG5CONST = 1
    431  28000 ????				       adc	#.ByteOffset
    432  28000 ????				       else
    433  28000 ????				       adc	.ByteOffset
    434  28000 ????				       endif
    435  28000 ????				       asl
    436  28000 ????				       asl
    437  28000 ????				       if	MACARG5CONST = 1
    438  28000 ????				       adc	#.ByteOffset
    439  28000 ????				       else
    440  28000 ????				       adc	.ByteOffset
    441  28000 ????				       endif
    442  28000 ????
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 14
    445  28000 ????				       asl
    446  28000 ????				       if	MACARG5CONST = 1
    447  28000 ????				       adc	#.ByteOffset
    448  28000 ????				       else
    449  28000 ????				       adc	.ByteOffset
    450  28000 ????				       endif
    451  28000 ????				       asl
    452  28000 ????				       if	MACARG5CONST = 1
    453  28000 ????				       adc	#.ByteOffset
    454  28000 ????				       else
    455  28000 ????				       adc	.ByteOffset
    456  28000 ????				       endif
    457  28000 ????				       asl
    458  28000 ????				       endif
    459  28000 ????				       if	{1}_width = 15
    460  28000 ????				       asl
    461  28000 ????				       if	MACARG5CONST = 1
    462  28000 ????				       adc	#.ByteOffset
    463  28000 ????				       else
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       endif
    466  28000 ????				       asl
    467  28000 ????				       if	MACARG5CONST = 1
    468  28000 ????				       adc	#.ByteOffset
    469  28000 ????				       else
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       endif
    472  28000 ????				       asl
    473  28000 ????				       if	MACARG5CONST = 1
    474  28000 ????				       adc	#.ByteOffset
    475  28000 ????				       else
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       endif
    478  28000 ????				       endif
    479  28000 ????				       if	{1}_width = 16
    480  28000 ????				       asl
    481  28000 ????				       asl
    482  28000 ????				       asl
    483  28000 ????				       asl
    484  28000 ????				       endif
    485  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    486  28000 ????				       else
    487  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
    488  28000 ????				       endif		; .ByteOffset
    489  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    490  28000 ????
    491  28000 ????				       iny
    492  28000 ????
    493  28000 ????				       lda	#({1}_mode | %01000000)
    494  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    495  28000 ????
    496  28000 ????				       iny
    497  28000 ????
    498  28000 ????				       if	MACARG4CONST = 0
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       else
    501  28000 ????				       lda	#.SpriteY
    502  28000 ????				       endif
    503  28000 ????				       and	#(WZONEHEIGHT - 1)
    504  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    505  28000 ????				       ora	#>.GFXLabel
    506  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    507  28000 ????
    508  28000 ????				       iny
    509  28000 ????
    510  28000 ????				       if	MACARG2CONST = 1
    511  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    512  28000 ????				       else
    513  28000 ????				       lda	#({1}_width_twoscompliment)
    514  28000 ????				       ora	.Palette
    515  28000 ????				       endif
    516  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    517  28000 ????
    518  28000 ????				       iny
    519  28000 ????
    520  28000 ????				       if	MACARG3CONST = 1
    521  28000 ????				       lda	#.SpriteX
    522  28000 ????				       else
    523  28000 ????				       lda	.SpriteX
    524  28000 ????				       endif
    525  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    526  28000 ????
    527  28000 ????				       iny
    528  28000 ????				       sty	dlend,x
    529  28000 ????
    530  28000 ????				       ifconst	ALWAYSTERMINATE
    531  28000 ????				       iny
    532  28000 ????				       lda	#0
    533  28000 ????				       sta	(dlpnt),y
    534  28000 ????				       endif
    535  28000 ????
    536  28000 ????				       bcc	.PLOTSPRITEend
    537  28000 ????
    538  28000 ????			    .PLOTSPRITEnext
    539  28000 ????				       inx		; next zone
    540  28000 ????
    541  28000 ????				       cpx	#WZONECOUNT
    542  28000 ????				       bcs	.PLOTSPRITEend
    543  28000 ????						; carry is clear
    544  28000 ????
    545  28000 ????				       ifconst	VSCROLL
    546  28000 ????				       ldy	Xx3,x
    547  28000 ????				       lda	DLLMEM+11,y
    548  28000 ????				       else		; !VSCROLL
    549  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    550  28000 ????				       endif		; !VSCROLL
    551  28000 ????				       ifconst	DOUBLEBUFFER
    552  28000 ????				       adc	doublebufferdloffset
    553  28000 ????				       endif		; DOUBLEBUFFER
    554  28000 ????				       sta	dlpnt
    555  28000 ????				       ifconst	VSCROLL
    556  28000 ????				       lda	DLLMEM+10,y
    557  28000 ????				       else		; !VSCROLL
    558  28000 ????				       lda	DLPOINTH,x
    559  28000 ????				       endif		; !VSCROLL
    560  28000 ????				       ifconst	DOUBLEBUFFER
    561  28000 ????				       adc	#0
    562  28000 ????				       endif		; DOUBLEBUFFER
    563  28000 ????				       sta	dlpnt+1
    564  28000 ????
    565  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    566  28000 ????
    567  28000 ????				       ifconst	.ByteOffset
    568  28000 ????
    569  28000 ????				       if	MACARG5CONST = 1
    570  28000 ????				       lda	#.ByteOffset
    571  28000 ????				       else
    572  28000 ????				       lda	.ByteOffset
    573  28000 ????				       endif
    574  28000 ????				       if	{1}_width = 1
    575  28000 ????				       clc
    576  28000 ????				       endif
    577  28000 ????				       if	{1}_width = 2
    578  28000 ????				       asl		; carry clear
    579  28000 ????				       endif
    580  28000 ????				       if	{1}_width = 3
    581  28000 ????				       asl		; carry clear
    582  28000 ????				       if	MACARG5CONST = 1
    583  28000 ????				       adc	#.ByteOffset
    584  28000 ????				       else
    585  28000 ????				       adc	.ByteOffset
    586  28000 ????				       endif
    587  28000 ????				       endif
    588  28000 ????				       if	{1}_width = 4
    589  28000 ????				       asl		; carry clear
    590  28000 ????				       asl
    591  28000 ????				       endif
    592  28000 ????				       if	{1}_width = 5
    593  28000 ????				       asl		; carry clear
    594  28000 ????				       asl
    595  28000 ????				       if	MACARG5CONST = 1
    596  28000 ????				       adc	#.ByteOffset
    597  28000 ????				       else
    598  28000 ????				       adc	.ByteOffset
    599  28000 ????				       endif
    600  28000 ????				       endif
    601  28000 ????				       if	{1}_width = 6
    602  28000 ????				       asl		; carry clear
    603  28000 ????				       if	MACARG5CONST = 1
    604  28000 ????				       adc	#.ByteOffset
    605  28000 ????				       else
    606  28000 ????				       adc	.ByteOffset
    607  28000 ????				       endif
    608  28000 ????				       asl
    609  28000 ????				       endif
    610  28000 ????				       if	{1}_width = 7
    611  28000 ????				       asl		; carry clear
    612  28000 ????				       if	MACARG5CONST = 1
    613  28000 ????				       adc	#.ByteOffset
    614  28000 ????				       else
    615  28000 ????				       adc	.ByteOffset
    616  28000 ????				       endif
    617  28000 ????				       asl
    618  28000 ????				       endif
    619  28000 ????				       if	{1}_width = 8
    620  28000 ????				       asl		; carry clear
    621  28000 ????				       asl
    622  28000 ????				       asl
    623  28000 ????				       endif
    624  28000 ????				       if	{1}_width = 9
    625  28000 ????				       asl		; carry clear
    626  28000 ????				       asl
    627  28000 ????				       asl
    628  28000 ????				       if	MACARG5CONST = 1
    629  28000 ????				       adc	#.ByteOffset
    630  28000 ????				       else
    631  28000 ????				       adc	.ByteOffset
    632  28000 ????				       endif
    633  28000 ????				       endif
    634  28000 ????				       if	{1}_width = 10
    635  28000 ????				       asl		; carry clear
    636  28000 ????				       asl
    637  28000 ????				       if	MACARG5CONST = 1
    638  28000 ????				       adc	#.ByteOffset
    639  28000 ????				       else
    640  28000 ????				       adc	.ByteOffset
    641  28000 ????				       endif
    642  28000 ????				       asl
    643  28000 ????				       endif
    644  28000 ????				       if	{1}_width = 11
    645  28000 ????				       asl		; carry clear
    646  28000 ????				       asl
    647  28000 ????				       if	MACARG5CONST = 1
    648  28000 ????				       adc	#.ByteOffset
    649  28000 ????				       else
    650  28000 ????				       adc	.ByteOffset
    651  28000 ????				       endif
    652  28000 ????				       asl
    653  28000 ????				       if	MACARG5CONST = 1
    654  28000 ????				       adc	#.ByteOffset
    655  28000 ????				       else
    656  28000 ????				       adc	.ByteOffset
    657  28000 ????				       endif
    658  28000 ????				       endif
    659  28000 ????				       if	{1}_width = 12
    660  28000 ????				       asl		; carry clear
    661  28000 ????				       if	MACARG5CONST = 1
    662  28000 ????				       adc	#.ByteOffset
    663  28000 ????				       else
    664  28000 ????				       adc	.ByteOffset
    665  28000 ????				       endif
    666  28000 ????				       asl
    667  28000 ????				       asl
    668  28000 ????				       endif
    669  28000 ????				       if	{1}_width = 13
    670  28000 ????				       asl		; carry clear
    671  28000 ????				       if	MACARG5CONST = 1
    672  28000 ????				       adc	#.ByteOffset
    673  28000 ????				       else
    674  28000 ????				       adc	.ByteOffset
    675  28000 ????				       endif
    676  28000 ????				       asl
    677  28000 ????				       asl
    678  28000 ????				       if	MACARG5CONST = 1
    679  28000 ????				       adc	#.ByteOffset
    680  28000 ????				       else
    681  28000 ????				       adc	.ByteOffset
    682  28000 ????				       endif
    683  28000 ????				       endif
    684  28000 ????				       if	{1}_width = 14
    685  28000 ????				       asl		; carry clear
    686  28000 ????				       if	MACARG5CONST = 1
    687  28000 ????				       adc	#.ByteOffset
    688  28000 ????				       else
    689  28000 ????				       adc	.ByteOffset
    690  28000 ????				       endif
    691  28000 ????				       asl
    692  28000 ????				       if	MACARG5CONST = 1
    693  28000 ????				       adc	#.ByteOffset
    694  28000 ????				       else
    695  28000 ????				       adc	.ByteOffset
    696  28000 ????				       endif
    697  28000 ????				       asl
    698  28000 ????				       endif
    699  28000 ????				       if	{1}_width = 15
    700  28000 ????				       asl
    701  28000 ????				       if	MACARG5CONST = 1
    702  28000 ????				       adc	#.ByteOffset
    703  28000 ????				       else
    704  28000 ????				       adc	.ByteOffset
    705  28000 ????				       endif
    706  28000 ????				       asl
    707  28000 ????				       if	MACARG5CONST = 1
    708  28000 ????				       adc	#.ByteOffset
    709  28000 ????				       else
    710  28000 ????				       adc	.ByteOffset
    711  28000 ????				       endif
    712  28000 ????				       asl
    713  28000 ????				       if	MACARG5CONST = 1
    714  28000 ????				       adc	#.ByteOffset
    715  28000 ????				       else
    716  28000 ????				       adc	.ByteOffset
    717  28000 ????				       endif
    718  28000 ????				       endif
    719  28000 ????				       if	{1}_width = 16
    720  28000 ????				       asl
    721  28000 ????				       asl
    722  28000 ????				       asl
    723  28000 ????				       asl
    724  28000 ????				       endif
    725  28000 ????				       adc	#<.GFXLabel
    726  28000 ????				       else
    727  28000 ????				       lda	#<.GFXLabel
    728  28000 ????				       endif		; .ByteOffset
    729  28000 ????
    730  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    731  28000 ????
    732  28000 ????				       iny
    733  28000 ????
    734  28000 ????				       lda	#({1}_mode | %01000000)
    735  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    736  28000 ????
    737  28000 ????				       iny
    738  28000 ????
    739  28000 ????				       if	MACARG4CONST = 0
    740  28000 ????				       lda	.SpriteY
    741  28000 ????				       else
    742  28000 ????				       lda	#.SpriteY
    743  28000 ????				       endif
    744  28000 ????				       and	#(WZONEHEIGHT - 1)
    745  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    746  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    747  28000 ????
    748  28000 ????				       iny
    749  28000 ????
    750  28000 ????				       if	MACARG2CONST = 1
    751  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    752  28000 ????				       else
    753  28000 ????				       lda	#({1}_width_twoscompliment)
    754  28000 ????				       ora	.Palette
    755  28000 ????				       endif
    756  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    757  28000 ????
    758  28000 ????				       iny
    759  28000 ????
    760  28000 ????				       if	MACARG3CONST = 1
    761  28000 ????				       lda	#.SpriteX
    762  28000 ????				       else
    763  28000 ????				       lda	.SpriteX
    764  28000 ????				       endif
    765  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    766  28000 ????
    767  28000 ????				       iny
    768  28000 ????				       sty	dlend,x
    769  28000 ????
    770  28000 ????				       ifconst	ALWAYSTERMINATE
    771  28000 ????				       iny
    772  28000 ????				       lda	#0
    773  28000 ????				       sta	(dlpnt),y
    774  28000 ????				       endif
    775  28000 ????
    776  28000 ????			    .PLOTSPRITEend
    777  28000 ????				       ENDM
    778  28000 ????
    779  28000 ????				       MAC	plotsprite4
    780  28000 ????
    781  28000 ????						; A macro version of plotsprite. (with 4 byte objects)
    782  28000 ????						; This trades off rom space for speed.
    783  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    784  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    785  28000 ????
    786  28000 ????			    .GFXLabel  SET	{1}
    787  28000 ????			    .Palette   SET	{2}	; constant
    788  28000 ????			    .SpriteX   SET	{3}	; variable
    789  28000 ????			    .SpriteY   SET	{4}	; variable
    790  28000 ????			    .ByteOffset SET	{5}	; variable 
    791  28000 ????
    792  28000 ????				       if	MACARG4CONST = 0
    793  28000 ????				       lda	.SpriteY
    794  28000 ????				       else
    795  28000 ????				       lda	#.SpriteY
    796  28000 ????				       endif
    797  28000 ????				       lsr
    798  28000 ????				       lsr
    799  28000 ????				       asr	#%11111110	; ensure carry is clear
    800  28000 ????				       if	WZONEHEIGHT = 16
    801  28000 ????				       asr	#%11111110	; ensure carry is clear
    802  28000 ????				       endif
    803  28000 ????
    804  28000 ????				       tax
    805  28000 ????
    806  28000 ????				       cpx	#WZONECOUNT
    807  28000 ????				       bcs	.PLOTSPRITEnext
    808  28000 ????						; carry is clear
    809  28000 ????				       ifconst	VSCROLL
    810  28000 ????				       ldy	Xx3,x
    811  28000 ????				       lda	DLLMEM+11,y
    812  28000 ????				       else		; !VSCROLL
    813  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    814  28000 ????				       endif		; !VSCROLL
    815  28000 ????				       ifconst	DOUBLEBUFFER
    816  28000 ????				       adc	doublebufferdloffset
    817  28000 ????				       endif		; DOUBLEBUFFER
    818  28000 ????				       sta	dlpnt
    819  28000 ????				       ifconst	VSCROLL
    820  28000 ????				       lda	DLLMEM+10,y
    821  28000 ????				       else		; !VSCROLL
    822  28000 ????				       lda	DLPOINTH,x
    823  28000 ????				       endif		; !VSCROLL
    824  28000 ????				       ifconst	DOUBLEBUFFER
    825  28000 ????				       adc	#0
    826  28000 ????				       endif		; DOUBLEBUFFER
    827  28000 ????				       sta	dlpnt+1
    828  28000 ????
    829  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    830  28000 ????
    831  28000 ????				       ifconst	.ByteOffset
    832  28000 ????
    833  28000 ????				       if	MACARG5CONST = 1
    834  28000 ????				       lda	#.ByteOffset
    835  28000 ????				       else
    836  28000 ????				       lda	.ByteOffset
    837  28000 ????				       endif
    838  28000 ????				       ifconst	DOUBLEBUFFER
    839  28000 ????				       if	{1}_width = 1
    840  28000 ????				       clc
    841  28000 ????				       endif
    842  28000 ????				       endif
    843  28000 ????				       if	{1}_width = 2
    844  28000 ????				       asl
    845  28000 ????				       endif
    846  28000 ????				       if	{1}_width = 3
    847  28000 ????				       asl
    848  28000 ????				       if	MACARG5CONST = 1
    849  28000 ????				       adc	#.ByteOffset
    850  28000 ????				       else
    851  28000 ????				       adc	.ByteOffset
    852  28000 ????				       endif
    853  28000 ????				       endif
    854  28000 ????				       if	{1}_width = 4
    855  28000 ????				       asl
    856  28000 ????				       asl
    857  28000 ????				       endif
    858  28000 ????				       if	{1}_width = 5
    859  28000 ????				       asl
    860  28000 ????				       asl
    861  28000 ????				       if	MACARG5CONST = 1
    862  28000 ????				       adc	#.ByteOffset
    863  28000 ????				       else
    864  28000 ????				       adc	.ByteOffset
    865  28000 ????				       endif
    866  28000 ????				       endif
    867  28000 ????				       if	{1}_width = 6
    868  28000 ????				       asl
    869  28000 ????				       if	MACARG5CONST = 1
    870  28000 ????				       adc	#.ByteOffset
    871  28000 ????				       else
    872  28000 ????				       adc	.ByteOffset
    873  28000 ????				       endif
    874  28000 ????
    875  28000 ????				       asl
    876  28000 ????				       endif
    877  28000 ????				       if	{1}_width = 7
    878  28000 ????				       asl
    879  28000 ????				       if	MACARG5CONST = 1
    880  28000 ????				       adc	#.ByteOffset
    881  28000 ????				       else
    882  28000 ????				       adc	.ByteOffset
    883  28000 ????				       endif
    884  28000 ????				       asl
    885  28000 ????				       if	MACARG5CONST = 1
    886  28000 ????				       adc	#.ByteOffset
    887  28000 ????				       else
    888  28000 ????				       adc	.ByteOffset
    889  28000 ????				       endif
    890  28000 ????				       endif
    891  28000 ????				       if	{1}_width = 8
    892  28000 ????				       asl
    893  28000 ????				       asl
    894  28000 ????				       asl
    895  28000 ????				       endif
    896  28000 ????				       if	{1}_width = 9
    897  28000 ????				       asl
    898  28000 ????				       asl
    899  28000 ????				       asl
    900  28000 ????				       if	MACARG5CONST = 1
    901  28000 ????				       adc	#.ByteOffset
    902  28000 ????				       else
    903  28000 ????				       adc	.ByteOffset
    904  28000 ????				       endif
    905  28000 ????				       endif
    906  28000 ????				       if	{1}_width = 10
    907  28000 ????				       asl
    908  28000 ????				       asl
    909  28000 ????				       if	MACARG5CONST = 1
    910  28000 ????				       adc	#.ByteOffset
    911  28000 ????				       else
    912  28000 ????				       adc	.ByteOffset
    913  28000 ????				       endif
    914  28000 ????				       asl
    915  28000 ????				       endif
    916  28000 ????				       if	{1}_width = 11
    917  28000 ????				       asl
    918  28000 ????				       asl
    919  28000 ????				       if	MACARG5CONST = 1
    920  28000 ????				       adc	#.ByteOffset
    921  28000 ????				       else
    922  28000 ????				       adc	.ByteOffset
    923  28000 ????				       endif
    924  28000 ????				       asl
    925  28000 ????				       if	MACARG5CONST = 1
    926  28000 ????				       adc	#.ByteOffset
    927  28000 ????				       else
    928  28000 ????				       adc	.ByteOffset
    929  28000 ????				       endif
    930  28000 ????				       endif
    931  28000 ????				       if	{1}_width = 12
    932  28000 ????				       asl
    933  28000 ????				       if	MACARG5CONST = 1
    934  28000 ????				       adc	#.ByteOffset
    935  28000 ????				       else
    936  28000 ????				       adc	.ByteOffset
    937  28000 ????				       endif
    938  28000 ????				       asl
    939  28000 ????				       asl
    940  28000 ????				       endif
    941  28000 ????				       if	{1}_width = 13
    942  28000 ????				       asl
    943  28000 ????				       if	MACARG5CONST = 1
    944  28000 ????				       adc	#.ByteOffset
    945  28000 ????				       else
    946  28000 ????				       adc	.ByteOffset
    947  28000 ????				       endif
    948  28000 ????				       asl
    949  28000 ????				       asl
    950  28000 ????				       if	MACARG5CONST = 1
    951  28000 ????				       adc	#.ByteOffset
    952  28000 ????				       else
    953  28000 ????				       adc	.ByteOffset
    954  28000 ????				       endif
    955  28000 ????				       endif
    956  28000 ????				       if	{1}_width = 14
    957  28000 ????				       asl
    958  28000 ????				       if	MACARG5CONST = 1
    959  28000 ????				       adc	#.ByteOffset
    960  28000 ????				       else
    961  28000 ????				       adc	.ByteOffset
    962  28000 ????				       endif
    963  28000 ????				       asl
    964  28000 ????				       if	MACARG5CONST = 1
    965  28000 ????				       adc	#.ByteOffset
    966  28000 ????				       else
    967  28000 ????				       adc	.ByteOffset
    968  28000 ????				       endif
    969  28000 ????				       asl
    970  28000 ????				       endif
    971  28000 ????				       if	{1}_width = 15
    972  28000 ????				       asl
    973  28000 ????				       if	MACARG5CONST = 1
    974  28000 ????				       adc	#.ByteOffset
    975  28000 ????				       else
    976  28000 ????				       adc	.ByteOffset
    977  28000 ????				       endif
    978  28000 ????				       asl
    979  28000 ????				       if	MACARG5CONST = 1
    980  28000 ????				       adc	#.ByteOffset
    981  28000 ????				       else
    982  28000 ????				       adc	.ByteOffset
    983  28000 ????				       endif
    984  28000 ????				       asl
    985  28000 ????				       if	MACARG5CONST = 1
    986  28000 ????				       adc	#.ByteOffset
    987  28000 ????				       else
    988  28000 ????				       adc	.ByteOffset
    989  28000 ????				       endif
    990  28000 ????				       endif
    991  28000 ????				       if	{1}_width = 16
    992  28000 ????				       asl
    993  28000 ????				       asl
    994  28000 ????				       asl
    995  28000 ????				       asl
    996  28000 ????				       endif
    997  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    998  28000 ????				       else
    999  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
   1000  28000 ????				       endif		; .ByteOffset
   1001  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1002  28000 ????
   1003  28000 ????				       iny
   1004  28000 ????
   1005  28000 ????				       if	MACARG2CONST = 1
   1006  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1007  28000 ????				       else
   1008  28000 ????				       lda	#({1}_width_twoscompliment)
   1009  28000 ????				       ora	.Palette
   1010  28000 ????				       endif
   1011  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1012  28000 ????
   1013  28000 ????				       iny
   1014  28000 ????				       if	MACARG4CONST = 0
   1015  28000 ????				       lda	.SpriteY
   1016  28000 ????				       else
   1017  28000 ????				       lda	#.SpriteY
   1018  28000 ????				       endif
   1019  28000 ????				       and	#(WZONEHEIGHT - 1)
   1020  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
   1021  28000 ????				       ora	#>.GFXLabel
   1022  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1023  28000 ????
   1024  28000 ????				       iny
   1025  28000 ????				       if	MACARG3CONST = 1
   1026  28000 ????				       lda	#.SpriteX
   1027  28000 ????				       else
   1028  28000 ????				       lda	.SpriteX
   1029  28000 ????				       endif
   1030  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1031  28000 ????
   1032  28000 ????				       iny
   1033  28000 ????				       sty	dlend,x
   1034  28000 ????
   1035  28000 ????				       ifconst	ALWAYSTERMINATE
   1036  28000 ????				       iny
   1037  28000 ????				       lda	#0
   1038  28000 ????				       sta	(dlpnt),y
   1039  28000 ????				       endif
   1040  28000 ????
   1041  28000 ????				       bcc	.PLOTSPRITEend
   1042  28000 ????
   1043  28000 ????			    .PLOTSPRITEnext
   1044  28000 ????				       inx		; next zone
   1045  28000 ????
   1046  28000 ????				       cpx	#WZONECOUNT
   1047  28000 ????				       bcs	.PLOTSPRITEend
   1048  28000 ????						; carry is clear
   1049  28000 ????				       ifconst	VSCROLL
   1050  28000 ????				       ldy	Xx3,x
   1051  28000 ????				       lda	DLLMEM+11,y
   1052  28000 ????				       else		; !VSCROLL
   1053  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   1054  28000 ????				       endif		; !VSCROLL
   1055  28000 ????				       ifconst	DOUBLEBUFFER
   1056  28000 ????				       adc	doublebufferdloffset
   1057  28000 ????				       endif		; DOUBLEBUFFER
   1058  28000 ????				       sta	dlpnt
   1059  28000 ????				       ifconst	VSCROLL
   1060  28000 ????				       lda	DLLMEM+10,y
   1061  28000 ????				       else		; !VSCROLL
   1062  28000 ????				       lda	DLPOINTH,x
   1063  28000 ????				       endif		; !VSCROLL
   1064  28000 ????				       ifconst	DOUBLEBUFFER
   1065  28000 ????				       adc	#0
   1066  28000 ????				       endif		; DOUBLEBUFFER
   1067  28000 ????				       sta	dlpnt+1
   1068  28000 ????
   1069  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
   1070  28000 ????
   1071  28000 ????				       ifconst	.ByteOffset
   1072  28000 ????
   1073  28000 ????				       if	MACARG5CONST = 1
   1074  28000 ????				       lda	#.ByteOffset
   1075  28000 ????				       else
   1076  28000 ????				       lda	.ByteOffset
   1077  28000 ????				       endif
   1078  28000 ????				       if	{1}_width = 1
   1079  28000 ????				       clc
   1080  28000 ????				       endif
   1081  28000 ????				       if	{1}_width = 2
   1082  28000 ????				       asl		; carry clear
   1083  28000 ????				       endif
   1084  28000 ????				       if	{1}_width = 3
   1085  28000 ????				       asl		; carry clear
   1086  28000 ????				       if	MACARG5CONST = 1
   1087  28000 ????				       adc	#.ByteOffset
   1088  28000 ????				       else
   1089  28000 ????				       adc	.ByteOffset
   1090  28000 ????				       endif
   1091  28000 ????				       endif
   1092  28000 ????				       if	{1}_width = 4
   1093  28000 ????				       asl		; carry clear
   1094  28000 ????				       asl
   1095  28000 ????				       endif
   1096  28000 ????				       if	{1}_width = 5
   1097  28000 ????				       asl		; carry clear
   1098  28000 ????				       asl
   1099  28000 ????				       if	MACARG5CONST = 1
   1100  28000 ????				       adc	#.ByteOffset
   1101  28000 ????				       else
   1102  28000 ????				       adc	.ByteOffset
   1103  28000 ????				       endif
   1104  28000 ????				       endif
   1105  28000 ????				       if	{1}_width = 6
   1106  28000 ????				       asl		; carry clear
   1107  28000 ????				       if	MACARG5CONST = 1
   1108  28000 ????				       adc	#.ByteOffset
   1109  28000 ????				       else
   1110  28000 ????				       adc	.ByteOffset
   1111  28000 ????				       endif
   1112  28000 ????
   1113  28000 ????				       asl
   1114  28000 ????				       endif
   1115  28000 ????				       if	{1}_width = 7
   1116  28000 ????				       asl		; carry clear
   1117  28000 ????				       if	MACARG5CONST = 1
   1118  28000 ????				       adc	#.ByteOffset
   1119  28000 ????				       else
   1120  28000 ????				       adc	.ByteOffset
   1121  28000 ????				       endif
   1122  28000 ????				       asl
   1123  28000 ????				       endif
   1124  28000 ????				       if	{1}_width = 8
   1125  28000 ????				       asl		; carry clear
   1126  28000 ????				       asl
   1127  28000 ????				       asl
   1128  28000 ????				       endif
   1129  28000 ????				       if	{1}_width = 9
   1130  28000 ????				       asl		; carry clear
   1131  28000 ????				       asl
   1132  28000 ????				       asl
   1133  28000 ????				       if	MACARG5CONST = 1
   1134  28000 ????				       adc	#.ByteOffset
   1135  28000 ????				       else
   1136  28000 ????				       adc	.ByteOffset
   1137  28000 ????				       endif
   1138  28000 ????				       endif
   1139  28000 ????				       if	{1}_width = 10
   1140  28000 ????				       asl		; carry clear
   1141  28000 ????				       asl
   1142  28000 ????				       if	MACARG5CONST = 1
   1143  28000 ????				       adc	#.ByteOffset
   1144  28000 ????				       else
   1145  28000 ????				       adc	.ByteOffset
   1146  28000 ????				       endif
   1147  28000 ????				       asl
   1148  28000 ????				       endif
   1149  28000 ????				       if	{1}_width = 11
   1150  28000 ????				       asl		; carry clear
   1151  28000 ????				       asl
   1152  28000 ????				       if	MACARG5CONST = 1
   1153  28000 ????				       adc	#.ByteOffset
   1154  28000 ????				       else
   1155  28000 ????				       adc	.ByteOffset
   1156  28000 ????				       endif
   1157  28000 ????				       asl
   1158  28000 ????				       if	MACARG5CONST = 1
   1159  28000 ????				       adc	#.ByteOffset
   1160  28000 ????				       else
   1161  28000 ????				       adc	.ByteOffset
   1162  28000 ????				       endif
   1163  28000 ????				       endif
   1164  28000 ????				       if	{1}_width = 12
   1165  28000 ????				       asl		; carry clear
   1166  28000 ????				       if	MACARG5CONST = 1
   1167  28000 ????				       adc	#.ByteOffset
   1168  28000 ????				       else
   1169  28000 ????				       adc	.ByteOffset
   1170  28000 ????				       endif
   1171  28000 ????				       asl
   1172  28000 ????				       asl
   1173  28000 ????				       endif
   1174  28000 ????				       if	{1}_width = 13
   1175  28000 ????				       asl		; carry clear
   1176  28000 ????				       if	MACARG5CONST = 1
   1177  28000 ????				       adc	#.ByteOffset
   1178  28000 ????				       else
   1179  28000 ????				       adc	.ByteOffset
   1180  28000 ????				       endif
   1181  28000 ????				       asl
   1182  28000 ????				       asl
   1183  28000 ????				       if	MACARG5CONST = 1
   1184  28000 ????				       adc	#.ByteOffset
   1185  28000 ????				       else
   1186  28000 ????				       adc	.ByteOffset
   1187  28000 ????				       endif
   1188  28000 ????				       endif
   1189  28000 ????				       if	{1}_width = 14
   1190  28000 ????				       asl		; carry clear
   1191  28000 ????				       if	MACARG5CONST = 1
   1192  28000 ????				       adc	#.ByteOffset
   1193  28000 ????				       else
   1194  28000 ????				       adc	.ByteOffset
   1195  28000 ????				       endif
   1196  28000 ????				       asl
   1197  28000 ????				       if	MACARG5CONST = 1
   1198  28000 ????				       adc	#.ByteOffset
   1199  28000 ????				       else
   1200  28000 ????				       adc	.ByteOffset
   1201  28000 ????				       endif
   1202  28000 ????				       asl
   1203  28000 ????				       endif
   1204  28000 ????				       if	{1}_width = 15
   1205  28000 ????				       asl
   1206  28000 ????				       if	MACARG5CONST = 1
   1207  28000 ????				       adc	#.ByteOffset
   1208  28000 ????				       else
   1209  28000 ????				       adc	.ByteOffset
   1210  28000 ????				       endif
   1211  28000 ????				       asl
   1212  28000 ????				       if	MACARG5CONST = 1
   1213  28000 ????				       adc	#.ByteOffset
   1214  28000 ????				       else
   1215  28000 ????				       adc	.ByteOffset
   1216  28000 ????				       endif
   1217  28000 ????				       asl
   1218  28000 ????				       if	MACARG5CONST = 1
   1219  28000 ????				       adc	#.ByteOffset
   1220  28000 ????				       else
   1221  28000 ????				       adc	.ByteOffset
   1222  28000 ????				       endif
   1223  28000 ????				       endif
   1224  28000 ????				       if	{1}_width = 16
   1225  28000 ????				       asl
   1226  28000 ????				       asl
   1227  28000 ????				       asl
   1228  28000 ????				       asl
   1229  28000 ????				       endif
   1230  28000 ????				       adc	#<.GFXLabel
   1231  28000 ????				       else
   1232  28000 ????				       lda	#<.GFXLabel
   1233  28000 ????				       endif		; .ByteOffset
   1234  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1235  28000 ????
   1236  28000 ????				       iny
   1237  28000 ????				       if	MACARG2CONST = 1
   1238  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1239  28000 ????				       else
   1240  28000 ????				       lda	#({1}_width_twoscompliment)
   1241  28000 ????				       ora	.Palette
   1242  28000 ????				       endif
   1243  28000 ????
   1244  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1245  28000 ????
   1246  28000 ????				       iny
   1247  28000 ????				       if	MACARG4CONST = 0
   1248  28000 ????				       lda	.SpriteY
   1249  28000 ????				       else
   1250  28000 ????				       lda	#.SpriteY
   1251  28000 ????				       endif
   1252  28000 ????				       and	#(WZONEHEIGHT - 1)
   1253  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
   1254  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1255  28000 ????
   1256  28000 ????				       iny
   1257  28000 ????				       if	MACARG3CONST = 1
   1258  28000 ????				       lda	#.SpriteX
   1259  28000 ????				       else
   1260  28000 ????				       lda	.SpriteX
   1261  28000 ????				       endif
   1262  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1263  28000 ????
   1264  28000 ????				       iny
   1265  28000 ????				       sty	dlend,x
   1266  28000 ????
   1267  28000 ????				       ifconst	ALWAYSTERMINATE
   1268  28000 ????				       iny
   1269  28000 ????				       lda	#0
   1270  28000 ????				       sta	(dlpnt),y
   1271  28000 ????				       endif
   1272  28000 ????
   1273  28000 ????			    .PLOTSPRITEend
   1274  28000 ????				       ENDM
   1275  28000 ????
   1276  28000 ????				       MAC	scrollsetup
   1277  28000 ????
   1278  28000 ????						; If vertical scrolling is enabled...
   1279  28000 ????						;   * Fills the DLs with hidden masking sprites.
   1280  28000 ????						; Adds blank sprites to the DLs to fill the screen.
   1281  28000 ????						; If horizontal scrolling is enabled...
   1282  28000 ????						;   * Adds another blank DL off-screen
   1283  28000 ????
   1284  28000 ????						; {1} - constant - the first dl of the scrolling area
   1285  28000 ????						; {2} - symbol   - blank tile label
   1286  28000 ????
   1287  28000 ????						; *** clear the saved dl ending for scrolling zones...
   1288  28000 ????				       ldx	#{1}
   1289  28000 ????				       lda	#0
   1290  28000 ????			    .scrollcleardls
   1291  28000 ????				       sta	dlend,x
   1292  28000 ????				       inx
   1293  28000 ????				       cpx	#WZONECOUNT
   1294  28000 ????				       bne	.scrollcleardls
   1295  28000 ????
   1296  28000 ????				       ifconst	VSCROLL
   1297  28000 ????						; *** adjust the ending for our mask dl to allow for mask objects...
   1298  28000 ????				       dex
   1299  28000 ????				       lda	#(maskscrollspriteend-maskscrollsprite)
   1300  28000 ????				       sta	dlend,x
   1301  28000 ????
   1302  28000 ????						; *** Add 4x dma masking objects to last zone...
   1303  28000 ????				       ldx	#(maskscrollspriteend-maskscrollsprite-1)
   1304  28000 ????			    .scrollpopulateloop1
   1305  28000 ????				       lda	maskscrollsprite,x
   1306  28000 ????				       sta	LASTZONEADDRESS+0,x
   1307  28000 ????				       ifconst	DOUBLEBUFFER
   1308  28000 ????				       sta	LASTZONEADDRESS+0+DOUBLEBUFFEROFFSET,x
   1309  28000 ????				       endif		; DOUBLEBUFFER
   1310  28000 ????				       dex
   1311  28000 ????				       bpl	.scrollpopulateloop1
   1312  28000 ????				       inx		; x=0
   1313  28000 ????				       stx	finescrolly
   1314  28000 ????				       endif		; VSCROLL
   1315  28000 ????
   1316  28000 ????						; *** Add blank sprite-tile objects to the scrolling zones...
   1317  28000 ????			    PLOTSP4    =	1	; ensure we use 4 byte sprites
   1318  28000 ????
   1319  28000 ????						; convert byte width of the sprit to coordinate width...
   1320  28000 ????				       if	{2}_mode = 0	; ### 160A, 320A, 320D
   1321  28000 ????			    .scrollXWIDTH SET	({2}_width * 4)	; 4x 160-mode pixels per byte
   1322  28000 ????				       else		; ### 160B, 320B, 320C
   1323  28000 ????			    .scrollXWIDTH SET	({2}_width * 2)	; 2x 160-mode pixels per byte
   1324  28000 ????				       endif
   1325  28000 ????
   1326  28000 ????						; figure out how many sprites we need to fill a screen width...
   1327  28000 ????			    .scrollSPRITECOuNT SET	((160+.scrollXWIDTH-1)/.scrollXWIDTH)
   1328  28000 ????				       ifconst	HSCROLL
   1329  28000 ????			    .scrollSPRITECOuNT SET	(.scrollSPRITECOuNT+1)
   1330  28000 ????				       endif		; HSCROLL
   1331  28000 ????
   1332  28000 ????						; setup plotsprite4 parameters...
   1333  28000 ????				       lda	#<{2}
   1334  28000 ????				       sta	temp1
   1335  28000 ????				       lda	#>{2}
   1336  28000 ????				       sta	temp2
   1337  28000 ????				       lda	#{2}_width_twoscompliment
   1338  28000 ????				       sta	temp3	; width
   1339  28000 ????
   1340  28000 ????				       lda	#{1}
   1341  28000 ????				       asl
   1342  28000 ????				       asl
   1343  28000 ????				       asl
   1344  28000 ????				       if	WZONEHEIGHT
   1345  28000 ????				       asl
   1346  28000 ????				       endif
   1347  28000 ????				       sta	temp5	; Y
   1348  28000 ????			    .scrollpopulateloop2
   1349  28000 ????				       lda	#0
   1350  28000 ????				       sta	temp4	; X
   1351  28000 ????			    .scrollpopulateloop3
   1352  28000 ????				       jsr	skipplotsprite4wait
   1353  28000 ????				       lda	temp4	; X
   1354  28000 ????				       clc
   1355  28000 ????				       adc	#.scrollXWIDTH
   1356  28000 ????				       sta	temp4	; X
   1357  28000 ????				       cmp	#(.scrollSPRITECOuNT*.scrollXWIDTH)
   1358  28000 ????				       bne	.scrollpopulateloop3
   1359  28000 ????				       lda	temp5	; Y
   1360  28000 ????				       clc
   1361  28000 ????				       adc	#WZONEHEIGHT
   1362  28000 ????				       sta	temp5	; Y
   1363  28000 ????				       cmp	#((WZONECOUNT*WZONEHEIGHT)+WZONEHEIGHT)
   1364  28000 ????				       bne	.scrollpopulateloop2
   1365  28000 ????				       ENDM
   1366  28000 ????
   1367  28000 ????				       MAC	sizeof
   1368  28000 ????
   1369  28000 ????						; echoes the size difference between the current address and the
   1370  28000 ????						; a label that was passed as an argument. This is a quick way to
   1371  28000 ????						; determine the size of a structure.
   1372  28000 ????
   1373  28000 ????			    .NAME      SETSTR	{1}
   1374  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
   1375  28000 ????				       ENDM
   1376  28000 ????
   1377  28000 ????						;
   1378  28000 ????						; speakjet.inc
   1379  28000 ????						;
   1380  28000 ????						;
   1381  28000 ????						; AtariVox Speech Synth Driver
   1382  28000 ????						;
   1383  28000 ????						; By Alex Herbert, 2004
   1384  28000 ????						;
   1385  28000 ????
   1386  28000 ????
   1387  28000 ????
   1388  28000 ????
   1389  28000 ????						; Constants
   1390  28000 ????
   1391  28000 ????
   1392  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
   1393  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
   1394  28000 ????
   1395  28000 ????
   1396  28000 ????
   1397  28000 ????						; Macros
   1398  28000 ????
   1399  28000 ????				       mac	spkout
   1400  28000 ????
   1401  28000 ????						; check buffer-full status
   1402  28000 ????				       lda	SWCHA
   1403  28000 ????				       and	#SERIAL_RDYMASK
   1404  28000 ????				       beq	.speech_done
   1405  28000 ????
   1406  28000 ????						; get next speech byte
   1407  28000 ????				       ldy	#$00
   1408  28000 ????				       lda	(speech_addr),y
   1409  28000 ????
   1410  28000 ????						; invert data and check for end of string
   1411  28000 ????				       eor	#$ff
   1412  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
   1413  28000 ????				       beq	.speech_done
   1414  28000 ????				       sta	{1}
   1415  28000 ????
   1416  28000 ????						; increment speech pointer
   1417  28000 ????				       inc	speech_addr
   1418  28000 ????				       bne	.incaddr_skip
   1419  28000 ????				       inc	speech_addr+1
   1420  28000 ????			    .incaddr_skip
   1421  28000 ????
   1422  28000 ????						; output byte as serial data
   1423  28000 ????
   1424  28000 ????				       sec		; start bit
   1425  28000 ????			    .byteout_loop
   1426  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
   1427  28000 ????				       lda	SWACNT	; 4
   1428  28000 ????				       and	#$fe	; 2 6
   1429  28000 ????				       adc	#$00	; 2 8
   1430  28000 ????				       sta	SWACNT	; 4 12
   1431  28000 ????
   1432  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
   1433  28000 ????				       cpy	#$09	; 2 14
   1434  28000 ????				       beq	.speech_done	; 2 16
   1435  28000 ????				       iny		; 2 18
   1436  28000 ????
   1437  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
   1438  28000 ????						; to match the original baud rate...
   1439  28000 ????						;ldx	  #$07 ; 2600
   1440  28000 ????				       ldx	#$0D
   1441  28000 ????
   1442  28000 ????			    .delay_loop
   1443  28000 ????				       dex		; 
   1444  28000 ????				       bne	.delay_loop	; 36 54
   1445  28000 ????
   1446  28000 ????						; shift next data bit into carry
   1447  28000 ????				       lsr	{1}	; 5 59
   1448  28000 ????
   1449  28000 ????						; and loop (branch always taken)
   1450  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
   1451  28000 ????
   1452  28000 ????			    .speech_done
   1453  28000 ????
   1454  28000 ????				       endm
   1455  28000 ????
   1456  28000 ????
   1457  28000 ????				       mac	speak
   1458  28000 ????
   1459  28000 ????				       lda	#<{1}
   1460  28000 ????				       sta	speech_addr
   1461  28000 ????				       lda	#>{1}
   1462  28000 ????				       sta	speech_addr+1
   1463  28000 ????
   1464  28000 ????				       endm
   1465  28000 ????
   1466  28000 ????
   1467  28000 ????
   1468  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
   1469  28000 ????
   1470  28000 ????				       processor	6502
   1471  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    123  28000 ????		02 85	    TIMINT     =	$285	;Interval Timer Interrupt		       read-only
    124  28000 ????
    125  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 80	    title01_mode =	$80
      4  28000 ????		00 10	    title01_width_twoscompliment =	$10
      5  28000 ????		00 30	    title01_width =	$30
      6  28000 ????		00 80	    title00_mode =	$80
      7  28000 ????		00 10	    title00_width_twoscompliment =	$10
      8  28000 ????		00 30	    title00_width =	$30
      9  28000 ????		00 00	    drone4_mode =	$00
     10  28000 ????		00 1c	    drone4_width_twoscompliment =	$1c
     11  28000 ????		00 04	    drone4_width =	$04
     12  28000 ????		00 00	    drone3_mode =	$00
     13  28000 ????		00 1c	    drone3_width_twoscompliment =	$1c
     14  28000 ????		00 04	    drone3_width =	$04
     15  28000 ????		00 00	    drone2_mode =	$00
     16  28000 ????		00 1c	    drone2_width_twoscompliment =	$1c
     17  28000 ????		00 04	    drone2_width =	$04
     18  28000 ????		00 00	    drone1_mode =	$00
     19  28000 ????		00 1c	    drone1_width_twoscompliment =	$1c
     20  28000 ????		00 04	    drone1_width =	$04
     21  28000 ????		00 00	    portal2_bottom_mode =	$00
     22  28000 ????		00 18	    portal2_bottom_width_twoscompliment =	$18
     23  28000 ????		00 08	    portal2_bottom_width =	$08
     24  28000 ????		00 00	    portal1_bottom_mode =	$00
     25  28000 ????		00 18	    portal1_bottom_width_twoscompliment =	$18
     26  28000 ????		00 08	    portal1_bottom_width =	$08
     27  28000 ????		00 00	    portal2_top_mode =	$00
     28  28000 ????		00 18	    portal2_top_width_twoscompliment =	$18
     29  28000 ????		00 08	    portal2_top_width =	$08
     30  28000 ????		00 00	    portal1_top_mode =	$00
     31  28000 ????		00 18	    portal1_top_width_twoscompliment =	$18
     32  28000 ????		00 08	    portal1_top_width =	$08
     33  28000 ????		00 00	    orb6_mode  =	$00
     34  28000 ????		00 1e	    orb6_width_twoscompliment =	$1e
     35  28000 ????		00 02	    orb6_width =	$02
     36  28000 ????		00 00	    orb5_mode  =	$00
     37  28000 ????		00 1e	    orb5_width_twoscompliment =	$1e
     38  28000 ????		00 02	    orb5_width =	$02
     39  28000 ????		00 00	    orb4_mode  =	$00
     40  28000 ????		00 1e	    orb4_width_twoscompliment =	$1e
     41  28000 ????		00 02	    orb4_width =	$02
     42  28000 ????		00 00	    orb3_mode  =	$00
     43  28000 ????		00 1e	    orb3_width_twoscompliment =	$1e
     44  28000 ????		00 02	    orb3_width =	$02
     45  28000 ????		00 00	    orb2_mode  =	$00
     46  28000 ????		00 1e	    orb2_width_twoscompliment =	$1e
     47  28000 ????		00 02	    orb2_width =	$02
     48  28000 ????		00 00	    orb1_mode  =	$00
     49  28000 ????		00 1e	    orb1_width_twoscompliment =	$1e
     50  28000 ????		00 02	    orb1_width =	$02
     51  28000 ????		00 00	    player4_mode =	$00
     52  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
     53  28000 ????		00 04	    player4_width =	$04
     54  28000 ????		00 00	    player3_mode =	$00
     55  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
     56  28000 ????		00 04	    player3_width =	$04
     57  28000 ????		00 00	    player2_mode =	$00
     58  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     59  28000 ????		00 04	    player2_width =	$04
     60  28000 ????		00 00	    player1_mode =	$00
     61  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     62  28000 ????		00 04	    player1_width =	$04
     63  28000 ????		00 00	    font_mode  =	$00
     64  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     65  28000 ????		00 35	    font_width =	$35
     66  28000 ????		22 c0	    orbCaptured =	$22C0
     67  28000 ????
     68  28000 ????		22 a0	    orbAnimWait =	$22A0
     69  28000 ????
     70  28000 ????		22 80	    orbAnimFrame =	$2280
     71  28000 ????
     72  28000 ????		22 60	    orbYVelocity =	$2260
     73  28000 ????
     74  28000 ????		22 40	    orbXVelocity =	$2240
     75  28000 ????
     76  28000 ????		22 20	    orbY       =	$2220
     77  28000 ????
     78  28000 ????		22 00	    orbX       =	$2200
     79  28000 ????
     80  28000 ????		01 59	    maxDrones  =	var25
     81  28000 ????
     82  28000 ????		01 58	    orbsLeft   =	var24
     83  28000 ????
     84  28000 ????		01 57	    portalAnimWait =	var23
     85  28000 ????
     86  28000 ????		01 56	    portalAnimFrame =	var22
     87  28000 ????
     88  28000 ????		01 55	    portalY    =	var21
     89  28000 ????
     90  28000 ????		01 54	    portalX    =	var20
     91  28000 ????
     92  28000 ????		01 53	    level      =	var19
     93  28000 ????
     94  28000 ????		01 52	    playerSpeed =	var18
     95  28000 ????
     96  28000 ????		01 51	    maxOrbs    =	var17
     97  28000 ????
     98  28000 ????		01 50	    randomSeed =	var16
     99  28000 ????
    100  28000 ????		01 4f	    tempCaptured =	var15
    101  28000 ????
    102  28000 ????		01 4e	    tempYVelocity =	var14
    103  28000 ????
    104  28000 ????		01 4d	    tempXVelocity =	var13
    105  28000 ????
    106  28000 ????		01 4c	    tempAnimWait =	var12
    107  28000 ????
    108  28000 ????		01 4b	    tempAnimFrame =	var11
    109  28000 ????
    110  28000 ????		01 4a	    tempY      =	var10
    111  28000 ????
    112  28000 ????		01 49	    tempX      =	var9
    113  28000 ????
    114  28000 ????		01 48	    playerAnimWait =	var8
    115  28000 ????
    116  28000 ????		01 47	    playerAnimFrame =	var7
    117  28000 ????
    118  28000 ????		01 46	    playerY    =	var6
    119  28000 ????
    120  28000 ????		01 45	    playerX    =	var5
    121  28000 ????
    122  28000 ????		01 43	    lives      =	var3
    123  28000 ????
    124  28000 ????		01 42	    wait       =	var2
    125  28000 ????
    126  28000 ????		01 41	    bgColor    =	var1
    127  28000 ????
    128  28000 ????		00 a8	    title_color12 =	title00_color12
    129  28000 ????		00 a9	    title_color11 =	title00_color11
    130  28000 ????		00 a7	    title_color10 =	title00_color10
    131  28000 ????		00 a4	    title_color9 =	title00_color9
    132  28000 ????		00 93	    title_color8 =	title00_color8
    133  28000 ????		00 ab	    title_color7 =	title00_color7
    134  28000 ????		00 92	    title_color6 =	title00_color6
    135  28000 ????		00 aa	    title_color5 =	title00_color5
    136  28000 ????		00 91	    title_color4 =	title00_color4
    137  28000 ????		00 a6	    title_color3 =	title00_color3
    138  28000 ????		00 a5	    title_color2 =	title00_color2
    139  28000 ????		00 91	    title_color1 =	title00_color1
    140  28000 ????		00 00	    title01_color15 =	0
    141  28000 ????		00 00	    title01_color14 =	0
    142  28000 ????		00 00	    title01_color13 =	0
    143  28000 ????		00 a8	    title01_color12 =	$a8
    144  28000 ????		00 a9	    title01_color11 =	$a9
    145  28000 ????		00 a7	    title01_color10 =	$a7
    146  28000 ????		00 a4	    title01_color9 =	$a4
    147  28000 ????		00 93	    title01_color8 =	$93
    148  28000 ????		00 ab	    title01_color7 =	$ab
    149  28000 ????		00 92	    title01_color6 =	$92
    150  28000 ????		00 aa	    title01_color5 =	$aa
    151  28000 ????		00 91	    title01_color4 =	$91
    152  28000 ????		00 a6	    title01_color3 =	$a6
    153  28000 ????		00 a5	    title01_color2 =	$a5
    154  28000 ????		00 91	    title01_color1 =	$91
    155  28000 ????		00 00	    title01_color0 =	$00
    156  28000 ????		00 00	    title00_color15 =	0
    157  28000 ????		00 00	    title00_color14 =	0
    158  28000 ????		00 00	    title00_color13 =	0
    159  28000 ????		00 a8	    title00_color12 =	$a8
    160  28000 ????		00 a9	    title00_color11 =	$a9
    161  28000 ????		00 a7	    title00_color10 =	$a7
    162  28000 ????		00 a4	    title00_color9 =	$a4
    163  28000 ????		00 93	    title00_color8 =	$93
    164  28000 ????		00 ab	    title00_color7 =	$ab
    165  28000 ????		00 92	    title00_color6 =	$92
    166  28000 ????		00 aa	    title00_color5 =	$aa
    167  28000 ????		00 91	    title00_color4 =	$91
    168  28000 ????		00 a6	    title00_color3 =	$a6
    169  28000 ????		00 a5	    title00_color2 =	$a5
    170  28000 ????		00 91	    title00_color1 =	$91
    171  28000 ????		00 00	    title00_color0 =	$00
    172  28000 ????		00 07	    drone4_color3 =	$07
    173  28000 ????		00 0b	    drone4_color2 =	$0b
    174  28000 ????		00 42	    drone4_color1 =	$42
    175  28000 ????		00 00	    drone4_color0 =	$00
    176  28000 ????		00 0b	    drone3_color3 =	$0b
    177  28000 ????		00 07	    drone3_color2 =	$07
    178  28000 ????		00 a5	    drone3_color1 =	$a5
    179  28000 ????		00 00	    drone3_color0 =	$00
    180  28000 ????		00 07	    drone2_color3 =	$07
    181  28000 ????		00 0b	    drone2_color2 =	$0b
    182  28000 ????		00 42	    drone2_color1 =	$42
    183  28000 ????		00 00	    drone2_color0 =	$00
    184  28000 ????		00 07	    drone1_color3 =	$07
    185  28000 ????		00 a5	    drone1_color2 =	$a5
    186  28000 ????		00 0b	    drone1_color1 =	$0b
    187  28000 ????		00 00	    drone1_color0 =	$00
    188  28000 ????		00 66	    portal2_bottom_color3 =	$66
    189  28000 ????		00 74	    portal2_bottom_color2 =	$74
    190  28000 ????		00 82	    portal2_bottom_color1 =	$82
    191  28000 ????		00 00	    portal2_bottom_color0 =	$00
    192  28000 ????		00 66	    portal1_bottom_color3 =	$66
    193  28000 ????		00 74	    portal1_bottom_color2 =	$74
    194  28000 ????		00 82	    portal1_bottom_color1 =	$82
    195  28000 ????		00 00	    portal1_bottom_color0 =	$00
    196  28000 ????		00 66	    portal2_top_color3 =	$66
    197  28000 ????		00 74	    portal2_top_color2 =	$74
    198  28000 ????		00 82	    portal2_top_color1 =	$82
    199  28000 ????		00 00	    portal2_top_color0 =	$00
    200  28000 ????		00 66	    portal1_top_color3 =	$66
    201  28000 ????		00 74	    portal1_top_color2 =	$74
    202  28000 ????		00 82	    portal1_top_color1 =	$82
    203  28000 ????		00 00	    portal1_top_color0 =	$00
    204  28000 ????		00 a3	    orb6_color3 =	$a3
    205  28000 ????		00 b8	    orb6_color2 =	$b8
    206  28000 ????		00 a4	    orb6_color1 =	$a4
    207  28000 ????		00 00	    orb6_color0 =	$00
    208  28000 ????		00 b8	    orb5_color3 =	$b8
    209  28000 ????		00 a3	    orb5_color2 =	$a3
    210  28000 ????		00 a4	    orb5_color1 =	$a4
    211  28000 ????		00 00	    orb5_color0 =	$00
    212  28000 ????		00 00	    orb4_color3 =	0
    213  28000 ????		00 a3	    orb4_color2 =	$a3
    214  28000 ????		00 a4	    orb4_color1 =	$a4
    215  28000 ????		00 00	    orb4_color0 =	$00
    216  28000 ????		00 b8	    orb3_color3 =	$b8
    217  28000 ????		00 a3	    orb3_color2 =	$a3
    218  28000 ????		00 a4	    orb3_color1 =	$a4
    219  28000 ????		00 00	    orb3_color0 =	$00
    220  28000 ????		00 a3	    orb2_color3 =	$a3
    221  28000 ????		00 b8	    orb2_color2 =	$b8
    222  28000 ????		00 a4	    orb2_color1 =	$a4
    223  28000 ????		00 00	    orb2_color0 =	$00
    224  28000 ????		00 b8	    orb1_color3 =	$b8
    225  28000 ????		00 a3	    orb1_color2 =	$a3
    226  28000 ????		00 a4	    orb1_color1 =	$a4
    227  28000 ????		00 00	    orb1_color0 =	$00
    228  28000 ????		00 00	    player4_color3 =	0
    229  28000 ????		00 44	    player4_color2 =	$44
    230  28000 ????		00 0d	    player4_color1 =	$0d
    231  28000 ????		00 00	    player4_color0 =	$00
    232  28000 ????		00 07	    player3_color3 =	$07
    233  28000 ????		00 44	    player3_color2 =	$44
    234  28000 ????		00 0d	    player3_color1 =	$0d
    235  28000 ????		00 00	    player3_color0 =	$00
    236  28000 ????		00 07	    player2_color3 =	$07
    237  28000 ????		00 44	    player2_color2 =	$44
    238  28000 ????		00 0d	    player2_color1 =	$0d
    239  28000 ????		00 00	    player2_color0 =	$00
    240  28000 ????		00 07	    player1_color3 =	$07
    241  28000 ????		00 44	    player1_color2 =	$44
    242  28000 ????		00 0d	    player1_color1 =	$0d
    243  28000 ????		00 00	    player1_color0 =	$00
    244  28000 ????		00 0f	    font_color1 =	$0f
    245  28000 ????		00 00	    font_color0 =	$00
    246  28000 ????		00 01	    DOUBLEBUFFER =	1
    247  28000 ????		00 01	    SGRAM      =	1
    248  28000 ????		00 08	    bankswitchmode =	8
    249  28000 ????		00 01	    ROM128K    =	1
    250  28000 ????		00 01	    plotvalueonscreen =	1
    251  28000 ????		00 10	    ZONEHEIGHT =	16
    252  28000 ????		00 01	    collisionwrap =	1
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    sSWCHA     =	$2131
     63  28000 ????						; reserved	 = $2132
     64  28000 ????
     65  28000 ????		21 33	    hsdisplaymode =	$2133
     66  28000 ????		21 34	    gamedifficulty =	$2134
     67  28000 ????		21 35	    hsinitialpos =	$2135
     68  28000 ????		21 36	    hsinitialhold =	$2136
     69  28000 ????		21 37	    hscursorx  =	$2137
     70  28000 ????		21 38	    hsjoydebounce =	$2138
     71  28000 ????		21 39	    hsswcha    =	$2139
     72  28000 ????		21 3a	    hsinpt1    =	$213A
     73  28000 ????		21 3b	    hscolorchaseindex =	$213B
     74  28000 ????		21 3c	    visibleDLLstart =	$213C
     75  28000 ????		21 3d	    overscanDLLstart =	$213D
     76  28000 ????		21 3e	    frameslost =	$213E
     77  28000 ????		21 3f	    hsreturn   =	$213F
     78  28000 ????
     79  28000 ????
     80  28000 ????		00 40	    rand       =	$40
     81  28000 ????		00 41	    rand16     =	$41
     82  28000 ????		00 42	    temp1      =	$42
     83  28000 ????		00 43	    temp2      =	$43
     84  28000 ????		00 44	    temp3      =	$44
     85  28000 ????		00 45	    temp4      =	$45
     86  28000 ????		00 46	    temp5      =	$46
     87  28000 ????		00 47	    temp6      =	$47
     88  28000 ????		00 48	    temp7      =	$48
     89  28000 ????		00 49	    temp8      =	$49
     90  28000 ????		00 4a	    temp9      =	$4a
     91  28000 ????
     92  28000 ????		00 4b	    pokeybase  =	$4b
     93  28000 ????		00 4b	    pokeybaselo =	$4b
     94  28000 ????		00 4c	    pokeybasehi =	$4c
     95  28000 ????
     96  28000 ????		00 4d	    visibleover =	$4d
     97  28000 ????
     98  28000 ????		00 4e	    sfx1pointlo =	$4e
     99  28000 ????		00 4f	    sfx2pointlo =	$4f
    100  28000 ????		00 50	    sfx1pointhi =	$50
    101  28000 ????		00 51	    sfx2pointhi =	$51
    102  28000 ????
    103  28000 ????		00 52	    sfx1priority =	$52
    104  28000 ????		00 53	    sfx2priority =	$53
    105  28000 ????		00 54	    sfx1poffset =	$54
    106  28000 ????		00 55	    sfx2poffset =	$55
    107  28000 ????
    108  28000 ????		00 56	    sfx1frames =	$56
    109  28000 ????		00 57	    sfx2frames =	$57
    110  28000 ????		00 58	    sfx1tick   =	$58
    111  28000 ????		00 59	    sfx2tick   =	$59
    112  28000 ????
    113  28000 ????		00 5a	    tempmath   =	$5a
    114  28000 ????
    115  28000 ????		00 5b	    pokey1pointlo =	$5b
    116  28000 ????		00 5c	    pokey1pointhi =	$5c
    117  28000 ????		00 5d	    pokey2pointlo =	$5d
    118  28000 ????		00 5e	    pokey2pointhi =	$5e
    119  28000 ????		00 5f	    pokey3pointlo =	$5f
    120  28000 ????		00 60	    pokey3pointhi =	$60
    121  28000 ????		00 61	    pokey4pointlo =	$61
    122  28000 ????		00 62	    pokey4pointhi =	$62
    123  28000 ????
    124  28000 ????		00 63	    dlpnt      =	$63	; to $64
    125  28000 ????		00 65	    dlend      =	$65	; to $81 - for 29 possible visible dll entries
    126  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 29 possible visible dll entries
    127  28000 ????
    128  28000 ????		00 9f	    speech_addr =	$9f
    129  28000 ????		00 a0	    speech_addr_hi =	$a0
    130  28000 ????
    131  28000 ????		00 a1	    HSGameTableLo =	$a1
    132  28000 ????		00 a2	    HSGameTableHi =	$a2
    133  28000 ????		00 a3	    HSVoxHi    =	$a3
    134  28000 ????		00 a4	    HSVoxLo    =	$a4
    135  28000 ????
    136  28000 ????						;channel pointers
    137  28000 ????
    138  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    139  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    140  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    141  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    142  28000 ????
    143  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    144  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    145  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    146  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    147  28000 ????
    148  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    149  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    150  28000 ????		00 af	    songchannel3layer3lo =	$aF
    151  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    152  28000 ????
    153  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    154  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    155  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    156  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    157  28000 ????
    158  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    159  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    160  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    161  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    162  28000 ????
    163  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    164  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    165  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    166  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    167  28000 ????
    168  28000 ????		00 bd	    songdatalo =	$bd
    169  28000 ????		00 be	    songdatahi =	$be
    170  28000 ????
    171  28000 ????		00 bf	    inactivechannelcount =	$bf
    172  28000 ????
    173  28000 ????		00 c0	    songchannel1transpose =	$c0
    174  28000 ????		00 c1	    songchannel2transpose =	$c1
    175  28000 ????		00 c2	    songchannel3transpose =	$c2
    176  28000 ????		00 c3	    songchannel4transpose =	$c3
    177  28000 ????
    178  28000 ????		00 c4	    songstackindex =	$c4
    179  28000 ????
    180  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    181  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    182  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    183  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    184  28000 ????
    185  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    186  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    187  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    188  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    189  28000 ????
    190  28000 ????		00 cd	    sfx1notedata =	$cd
    191  28000 ????		00 ce	    sfx2notedata =	$ce
    192  28000 ????
    193  28000 ????		00 cf	    songloops  =	$cf
    194  28000 ????
    195  28000 ????		00 d0	    songpointerlo =	$D0
    196  28000 ????		00 d1	    songpointerhi =	$D1
    197  28000 ????
    198  28000 ????		00 d2	    voxlock    =	$D2
    199  28000 ????		00 d3	    voxqueuesize =	$D3
    200  28000 ????
    201  28000 ????		00 d4	    vblankroutines =	$D4
    202  28000 ????
    203  28000 ????		00 d5	    doublebufferstate =	$D5
    204  28000 ????		00 d6	    doublebufferdloffset =	$D6
    205  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    206  28000 ????
    207  28000 ????		00 d8	    inttemp1   =	$D8
    208  28000 ????		00 d9	    inttemp2   =	$D9
    209  28000 ????		00 da	    inttemp3   =	$DA
    210  28000 ????		00 db	    inttemp4   =	$DB
    211  28000 ????		00 dc	    inttemp5   =	$DC
    212  28000 ????		00 dd	    inttemp6   =	$DD
    213  28000 ????
    214  28000 ????		00 de	    sfxschedulelock =	$DE
    215  28000 ????		00 df	    sfxschedulemissed =	$DF
    216  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    217  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    218  28000 ????		00 e2	    sfxpitchoffset =	$E2
    219  28000 ????		00 e3	    sfxnoteindex =	$E3
    220  28000 ????
    221  28000 ????						; reserved = $E4
    222  28000 ????						; reserved = $E5
    223  28000 ????
    224  28000 ????		00 e6	    A	       =	$e6
    225  28000 ????		00 e6	    a	       =	$e6
    226  28000 ????		00 e7	    B	       =	$e7
    227  28000 ????		00 e7	    b	       =	$e7
    228  28000 ????		00 e8	    C	       =	$e8
    229  28000 ????		00 e8	    c	       =	$e8
    230  28000 ????		00 e9	    D	       =	$e9
    231  28000 ????		00 e9	    d	       =	$e9
    232  28000 ????		00 ea	    E	       =	$ea
    233  28000 ????		00 ea	    e	       =	$ea
    234  28000 ????		00 eb	    F	       =	$eb
    235  28000 ????		00 eb	    f	       =	$eb
    236  28000 ????		00 ec	    G	       =	$ec
    237  28000 ????		00 ec	    g	       =	$ec
    238  28000 ????		00 ed	    H	       =	$ed
    239  28000 ????		00 ed	    h	       =	$ed
    240  28000 ????		00 ee	    I	       =	$ee
    241  28000 ????		00 ee	    i	       =	$ee
    242  28000 ????		00 ef	    J	       =	$ef
    243  28000 ????		00 ef	    j	       =	$ef
    244  28000 ????		00 f0	    K	       =	$f0
    245  28000 ????		00 f0	    k	       =	$f0
    246  28000 ????		00 f1	    L	       =	$f1
    247  28000 ????		00 f1	    l	       =	$f1
    248  28000 ????		00 f2	    M	       =	$f2
    249  28000 ????		00 f2	    m	       =	$f2
    250  28000 ????		00 f3	    N	       =	$f3
    251  28000 ????		00 f3	    n	       =	$f3
    252  28000 ????		00 f4	    O	       =	$f4
    253  28000 ????		00 f4	    o	       =	$f4
    254  28000 ????		00 f5	    P	       =	$f5
    255  28000 ????		00 f5	    p	       =	$f5
    256  28000 ????		00 f6	    Q	       =	$f6
    257  28000 ????		00 f6	    q	       =	$f6
    258  28000 ????		00 f7	    R	       =	$f7
    259  28000 ????		00 f7	    r	       =	$f7
    260  28000 ????		00 f8	    S	       =	$f8
    261  28000 ????		00 f8	    s	       =	$f8
    262  28000 ????		00 f9	    T	       =	$f9
    263  28000 ????		00 f9	    t	       =	$f9
    264  28000 ????		00 fa	    U	       =	$fa
    265  28000 ????		00 fa	    u	       =	$fa
    266  28000 ????		00 fb	    V	       =	$fb
    267  28000 ????		00 fb	    v	       =	$fb
    268  28000 ????		00 fc	    W	       =	$fc
    269  28000 ????		00 fc	    w	       =	$fc
    270  28000 ????		00 fd	    X	       =	$fd
    271  28000 ????		00 fd	    x	       =	$fd
    272  28000 ????		00 fe	    Y	       =	$fe
    273  28000 ????		00 fe	    y	       =	$fe
    274  28000 ????		00 ff	    Z	       =	$ff
    275  28000 ????		00 ff	    z	       =	$ff
    276  28000 ????
    277  28000 ????						; var0-var99 variables use the top of the stack
    278  28000 ????		01 40	    var0       =	$140
    279  28000 ????		01 41	    var1       =	$141
    280  28000 ????		01 42	    var2       =	$142
    281  28000 ????		01 43	    var3       =	$143
    282  28000 ????		01 44	    var4       =	$144
    283  28000 ????		01 45	    var5       =	$145
    284  28000 ????		01 46	    var6       =	$146
    285  28000 ????		01 47	    var7       =	$147
    286  28000 ????		01 48	    var8       =	$148
    287  28000 ????		01 49	    var9       =	$149
    288  28000 ????		01 4a	    var10      =	$14a
    289  28000 ????		01 4b	    var11      =	$14b
    290  28000 ????		01 4c	    var12      =	$14c
    291  28000 ????		01 4d	    var13      =	$14d
    292  28000 ????		01 4e	    var14      =	$14e
    293  28000 ????		01 4f	    var15      =	$14f
    294  28000 ????		01 50	    var16      =	$150
    295  28000 ????		01 51	    var17      =	$151
    296  28000 ????		01 52	    var18      =	$152
    297  28000 ????		01 53	    var19      =	$153
    298  28000 ????		01 54	    var20      =	$154
    299  28000 ????		01 55	    var21      =	$155
    300  28000 ????		01 56	    var22      =	$156
    301  28000 ????		01 57	    var23      =	$157
    302  28000 ????		01 58	    var24      =	$158
    303  28000 ????		01 59	    var25      =	$159
    304  28000 ????		01 5a	    var26      =	$15a
    305  28000 ????		01 5b	    var27      =	$15b
    306  28000 ????		01 5c	    var28      =	$15c
    307  28000 ????		01 5d	    var29      =	$15d
    308  28000 ????		01 5e	    var30      =	$15e
    309  28000 ????		01 5f	    var31      =	$15f
    310  28000 ????		01 60	    var32      =	$160
    311  28000 ????		01 61	    var33      =	$161
    312  28000 ????		01 62	    var34      =	$162
    313  28000 ????		01 63	    var35      =	$163
    314  28000 ????		01 64	    var36      =	$164
    315  28000 ????		01 65	    var37      =	$165
    316  28000 ????		01 66	    var38      =	$166
    317  28000 ????		01 67	    var39      =	$167
    318  28000 ????		01 68	    var40      =	$168
    319  28000 ????		01 69	    var41      =	$169
    320  28000 ????		01 6a	    var42      =	$16a
    321  28000 ????		01 6b	    var43      =	$16b
    322  28000 ????		01 6c	    var44      =	$16c
    323  28000 ????		01 6d	    var45      =	$16d
    324  28000 ????		01 6e	    var46      =	$16e
    325  28000 ????		01 6f	    var47      =	$16f
    326  28000 ????		01 70	    var48      =	$170
    327  28000 ????		01 71	    var49      =	$171
    328  28000 ????		01 72	    var50      =	$172
    329  28000 ????		01 73	    var51      =	$173
    330  28000 ????		01 74	    var52      =	$174
    331  28000 ????		01 75	    var53      =	$175
    332  28000 ????		01 76	    var54      =	$176
    333  28000 ????		01 77	    var55      =	$177
    334  28000 ????		01 78	    var56      =	$178
    335  28000 ????		01 79	    var57      =	$179
    336  28000 ????		01 7a	    var58      =	$17a
    337  28000 ????		01 7b	    var59      =	$17b
    338  28000 ????		01 7c	    var60      =	$17c
    339  28000 ????		01 7d	    var61      =	$17d
    340  28000 ????		01 7e	    var62      =	$17e
    341  28000 ????		01 7f	    var63      =	$17f
    342  28000 ????		01 80	    var64      =	$180
    343  28000 ????		01 81	    var65      =	$181
    344  28000 ????		01 82	    var66      =	$182
    345  28000 ????		01 83	    var67      =	$183
    346  28000 ????		01 84	    var68      =	$184
    347  28000 ????		01 85	    var69      =	$185
    348  28000 ????		01 86	    var70      =	$186
    349  28000 ????		01 87	    var71      =	$187
    350  28000 ????		01 88	    var72      =	$188
    351  28000 ????		01 89	    var73      =	$189
    352  28000 ????		01 8a	    var74      =	$18a
    353  28000 ????		01 8b	    var75      =	$18b
    354  28000 ????		01 8c	    var76      =	$18c
    355  28000 ????		01 8d	    var77      =	$18d
    356  28000 ????		01 8e	    var78      =	$18e
    357  28000 ????		01 8f	    var79      =	$18f
    358  28000 ????		01 90	    var80      =	$190
    359  28000 ????		01 91	    var81      =	$191
    360  28000 ????		01 92	    var82      =	$192
    361  28000 ????		01 93	    var83      =	$193
    362  28000 ????		01 94	    var84      =	$194
    363  28000 ????		01 95	    var85      =	$195
    364  28000 ????		01 96	    var86      =	$196
    365  28000 ????		01 97	    var87      =	$197
    366  28000 ????		01 98	    var88      =	$198
    367  28000 ????		01 99	    var89      =	$199
    368  28000 ????		01 9a	    var90      =	$19a
    369  28000 ????		01 9b	    var91      =	$19b
    370  28000 ????		01 9c	    var92      =	$19c
    371  28000 ????		01 9d	    var93      =	$19d
    372  28000 ????		01 9e	    var94      =	$19e
    373  28000 ????		01 9f	    var95      =	$19f
    374  28000 ????		01 a0	    var96      =	$1a0
    375  28000 ????		01 a1	    var97      =	$1a1
    376  28000 ????		01 a2	    var98      =	$1a2
    377  28000 ????		01 a3	    var99      =	$1a3
    378  28000 ????
    379 U01c5 ????				      SEG.U	"7800basicRAM"
    380 U01a4					      ORG	$1A4
    381 U01a4
    382 U01a4							; MAX allocation locations are in comments...
    383 U01a4		       00	   framecounter DS	1	; $1A4
    384 U01a5		       00	   countdownseconds DS	1	; $1A5
    385 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    386 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    387 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    388 U01ad		       00	   valbufend  DS	1	; $1AD
    389 U01ae		       00	   valbufendsave DS	1	; $1AE
    390 U01af		       00	   finescrollx DS	1	; $1AF
    391 U01b0		       00	   finescrolly DS	1	; $1B0
    392 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    393 U01b2		       00	   interruptindex DS	1	; $1B2
    394 U01b3
    395 U01b3					      ifconst	DOUBLEBUFFER
    396 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    397 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    398 U01b5					      endif
    399 U01b5
    400 U01b5		       00	   pausedisable DS	1	; $1B5
    401 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    402 U01b7
    403 U01b7				  -	      ifconst	AVOXVOICE
    404 U01b7				  -avoxenable DS	1	; $1B7
    405 U01b7				  -tempavox   DS	1	; $1B8
    406 U01b7					      endif
    407 U01b7
    408 U01b7				  -	      ifconst	MUSICTRACKER
    409 U01b7				  -songtempo  DS	1	; $1B9
    410 U01b7				  -songtick   DS	1	; $1BA
    411 U01b7				  -
    412 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    413 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    414 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    415 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    416 U01b7				  -
    417 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    418 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    419 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    420 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    421 U01b7				  -
    422 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    423 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    424 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    425 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    426 U01b7				  -
    427 U01b7				  -songchannel1busywait DS	1	; $1C7
    428 U01b7				  -songchannel2busywait DS	1	; $1C8
    429 U01b7				  -songchannel3busywait DS	1	; $1C9
    430 U01b7				  -songchannel4busywait DS	1	; $1CA
    431 U01b7				  -
    432 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    433 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    434 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    435 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    436 U01b7					      endif
    437 U01b7
    438 U01b7		       00	   palframes  DS	1
    439 U01b8		       00	   ntscslowframe DS	1
    440 U01b9		       00	   palfastframe DS	1
    441 U01ba
    442 U01ba				  -	      ifconst	MOUSESUPPORT
    443 U01ba				  -port0resolution DS	1
    444 U01ba				  -port1resolution DS	1
    445 U01ba					      else
    446 U01ba				  -	      ifconst	TRAKBALLSUPPORT
    447 U01ba				  -port0resolution DS	1
    448 U01ba				  -port1resolution DS	1
    449 U01ba					      endif
    450 U01ba					      endif
    451 U01ba
    452 U01ba		       00	   port0control DS	1
    453 U01bb		       00	   port1control DS	1
    454 U01bc
    455 U01bc							; port#control values...
    456 U01bc							;	1 = proline
    457 U01bc							;	2 = lightgun
    458 U01bc							;	3 = paddle
    459 U01bc							;	4 = trakball
    460 U01bc							;	5 = vcs joystick
    461 U01bc							;	6 = driving
    462 U01bc							;	7 = keypad
    463 U01bc							;	8 = st mouse/cx80
    464 U01bc							;	9 = amiga mouse
    465 U01bc							;     10 = atarivox
    466 U01bc
    467 U01bc							; controller 0 data...
    468 U01bc		       00	   paddleposition0 DS	1
    469 U01bc		       01 bc	   keypadmatrix0a =	paddleposition0
    470 U01bc		       01 bc	   drivingposition0 =	paddleposition0
    471 U01bc		       01 bc	   trakballx0 =	paddleposition0
    472 U01bc		       01 bc	   mousex0    =	paddleposition0
    473 U01bc		       01 bc	   lighttgunx0 =	paddleposition0
    474 U01bc		       01 bc	   snes2atari0lo =	paddleposition0
    475 U01bc		       01 bc	   mega7800data0 =	paddleposition0
    476 U01bd
    477 U01bd							; controller 1 data...
    478 U01bd		       00	   paddleposition2 DS	1
    479 U01bd		       01 bd	   keypadmatrix1a =	paddleposition2
    480 U01bd		       01 bd	   drivingposition1 =	paddleposition2
    481 U01bd		       01 bd	   trakballx1 =	paddleposition2
    482 U01bd		       01 bd	   mousex1    =	paddleposition2
    483 U01bd		       01 bd	   lightgunx1 =	paddleposition2
    484 U01bd		       01 bd	   snes2atari1lo =	paddleposition2
    485 U01bd		       01 bd	   mega7800data1 =	paddleposition2
    486 U01be
    487 U01be							; controller 0 altdata...
    488 U01be		       00	   paddleposition1 DS	1
    489 U01be		       01 be	   keypadmatrix0b =	paddleposition1
    490 U01be		       01 be	   trakbally0 =	paddleposition1
    491 U01be		       01 be	   mousey0    =	paddleposition1
    492 U01be		       01 be	   lightguny0 =	paddleposition1
    493 U01be		       01 be	   snes2atari0hi =	paddleposition1
    494 U01be		       01 be	   mega7800state0 =	paddleposition1
    495 U01bf
    496 U01bf							; controller 1 altdata...
    497 U01bf		       00	   paddleposition3 DS	1
    498 U01bf		       01 bf	   keypadmatrix1b =	paddleposition3
    499 U01bf		       01 bf	   trakbally1 =	paddleposition3
    500 U01bf		       01 bf	   mousey1    =	paddleposition3
    501 U01bf		       01 bf	   lightguny1 =	paddleposition3
    502 U01bf		       01 bf	   snes2atari1hi =	paddleposition3
    503 U01bf		       01 bf	   mega7800state1 =	paddleposition3
    504 U01c0
    505 U01c0							; controller state save. for trakball state+dir codes, rotary position codes
    506 U01c0		       00	   controller0statesave DS	1
    507 U01c0		       01 c0	   paddleprevious0 =	controller0statesave
    508 U01c0		       01 c0	   mousecodex0 =	controller0statesave
    509 U01c0		       01 c0	   trakballcodex0 =	controller0statesave
    510 U01c0		       01 c0	   keypadmatrix0c =	controller0statesave
    511 U01c0		       01 c0	   snesdetected0 =	controller0statesave
    512 U01c1
    513 U01c1		       00	   controller1statesave DS	1
    514 U01c1		       01 c1	   paddleprevious2 =	controller1statesave
    515 U01c1		       01 c1	   mousecodex1 =	controller1statesave
    516 U01c1		       01 c1	   trakballcodex1 =	controller1statesave
    517 U01c1		       01 c1	   keypadmatrix1c =	controller1statesave
    518 U01c1		       01 c1	   snesdetected1 =	controller1statesave
    519 U01c2
    520 U01c2		       00	   paddleprevious1 DS	1
    521 U01c2		       01 c2	   keypadmatrix0d =	paddleprevious1
    522 U01c2		       01 c2	   mousecodey0 =	paddleprevious1
    523 U01c2		       01 c2	   trakballcodey0 =	paddleprevious1
    524 U01c3
    525 U01c3		       00	   paddleprevious3 DS	1
    526 U01c3		       01 c3	   keypadmatrix1d =	paddleprevious3
    527 U01c3		       01 c3	   mousecodey1 =	paddleprevious3
    528 U01c3		       01 c3	   trakballcodey1 =	paddleprevious3
    529 U01c4
    530 U01c4				  -	      ifconst	pokeysupport
    531 U01c4				  -pokey1frames DS	1
    532 U01c4				  -pokey1tick DS	1
    533 U01c4				  -pokey2frames DS	1
    534 U01c4				  -pokey2tick DS	1
    535 U01c4				  -pokey3frames DS	1
    536 U01c4				  -pokey3tick DS	1
    537 U01c4				  -pokey4frames DS	1
    538 U01c4				  -pokey4tick DS	1
    539 U01c4				  -pokey1priority DS	1
    540 U01c4				  -pokey1offset DS	1
    541 U01c4				  -pokey2priority DS	1
    542 U01c4				  -pokey2offset DS	1
    543 U01c4				  -pokey3priority DS	1
    544 U01c4				  -pokey3offset DS	1
    545 U01c4				  -pokey4priority DS	1
    546 U01c4				  -pokey4offset DS	1
    547 U01c4					      endif
    548 U01c4
    549 U01c4				  -	      ifconst	pokeykeysupport
    550 U01c4				  -pokeylastkeycode DS	1
    551 U01c4				  -pokeykeycode DS	1
    552 U01c4				  -pokeykeydebounce DS	1
    553 U01c4					      endif
    554 U01c4
    555 U01c4				  -	      ifconst	RMT
    556 U01c4				  -rasterpause DS	1
    557 U01c4					      endif		; RMT
    558 U01c4				  -	      ifconst	RMTVOLUME
    559 U01c4				  -rmtvolume  DS	1
    560 U01c4					      endif		; RMTVOLUME
    561 U01c4				  -	      ifconst	TIAVOLUME
    562 U01c4				  -tiavolume  DS	1
    563 U01c4					      endif		; TIAVOLUME
    564 U01c4
    565 U01c4				  -	      ifconst	FOURBITFADE
    566 U01c4				  -fourbittemp1 DS	1
    567 U01c4				  -fourbitfadevalue DS	1
    568 U01c4				  -fourbittemp1int DS	1
    569 U01c4				  -fourbitfadevalueint DS	1
    570 U01c4					      endif		; FOURBITFADE
    571 U01c4
    572 U01c4				  -	      ifconst	SNES2ATARISUPPORT
    573 U01c4				  -snesport   DS	1
    574 U01c4					      endif		; SNES2ATARISUPPORT
    575 U01c4
    576 U01c4				  -	      ifconst	KEYPADSUPPORT
    577 U01c4				  -keypadcounter DS	1
    578 U01c4					      endif
    579 U01c4
    580 U01c4				  -	      ifconst	MULTIBUTTON
    581 U01c4				  -multibuttoncount0 DS	1
    582 U01c4				  -multibuttoncount1 DS	1
    583 U01c4					      endif
    584 U01c4
    585 U01c4							; see if we need an interrupthold byte...
    586 U01c4				   INTERRUPTNEEDED SET	0
    587 U01c4				  -	      ifconst	.topscreenroutine
    588 U01c4				  -INTERRUPTNEEDED SET	1
    589 U01c4					      endif
    590 U01c4				  -	      ifconst	.bottomscreenroutine
    591 U01c4				  -INTERRUPTNEEDED SET	1
    592 U01c4					      endif
    593 U01c4				  -	      ifconst	.userinterrupt
    594 U01c4				  -INTERRUPTNEEDED SET	1
    595 U01c4					      endif
    596 U01c4				  -	      if	INTERRUPTNEEDED = 1
    597 U01c4				  -interrupthold DS	1
    598 U01c4					      endif
    599 U01c4
    600 U01c4					      ifnconst	CANARYOFF
    601 U01c4		       00	   canary     DS	1
    602 U01c5					      endif
    603 U01c5
    604 U01c5				  -	      ifnconst	bankswitchmode
    605 U01c5				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    606 U01c5					      else
   stack allowance: 19 nested subroutines.
    607 U01c5					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    608 U01c5					      endif
    609 U01c5					      ifnconst	CANARYOFF
   the canary is situated at: $1c4
    610 U01c5					      echo	"  the canary is situated at:",[canary]
    611 U01c5				  -	      else
    612 U01c5				  -	      echo	"  the canary is disabled."
    613 U01c5					      endif
    614 U01c5
    615 U01c5							; $1EE - $1FF reserved for stack
    616 U01c5
    617  28000 ????				       SEG	"GAME"
    618  28000 ????
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
------- FILE 7800_extravars.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800_extravars.h"
      1  28000 ????		22 00	    var100     =	$2200
      2  28000 ????		22 01	    var101     =	$2201
      3  28000 ????		22 02	    var102     =	$2202
      4  28000 ????		22 03	    var103     =	$2203
      5  28000 ????		22 04	    var104     =	$2204
      6  28000 ????		22 05	    var105     =	$2205
      7  28000 ????		22 06	    var106     =	$2206
      8  28000 ????		22 07	    var107     =	$2207
      9  28000 ????		22 08	    var108     =	$2208
     10  28000 ????		22 09	    var109     =	$2209
     11  28000 ????		22 0a	    var110     =	$220A
     12  28000 ????		22 0b	    var111     =	$220B
     13  28000 ????		22 0c	    var112     =	$220C
     14  28000 ????		22 0d	    var113     =	$220D
     15  28000 ????		22 0e	    var114     =	$220E
     16  28000 ????		22 0f	    var115     =	$220F
     17  28000 ????		22 10	    var116     =	$2210
     18  28000 ????		22 11	    var117     =	$2211
     19  28000 ????		22 12	    var118     =	$2212
     20  28000 ????		22 13	    var119     =	$2213
     21  28000 ????		22 14	    var120     =	$2214
     22  28000 ????		22 15	    var121     =	$2215
     23  28000 ????		22 16	    var122     =	$2216
     24  28000 ????		22 17	    var123     =	$2217
     25  28000 ????		22 18	    var124     =	$2218
     26  28000 ????		22 19	    var125     =	$2219
     27  28000 ????		22 1a	    var126     =	$221A
     28  28000 ????		22 1b	    var127     =	$221B
     29  28000 ????		22 1c	    var128     =	$221C
     30  28000 ????		22 1d	    var129     =	$221D
     31  28000 ????		22 1e	    var130     =	$221E
     32  28000 ????		22 1f	    var131     =	$221F
     33  28000 ????		22 20	    var132     =	$2220
     34  28000 ????		22 21	    var133     =	$2221
     35  28000 ????		22 22	    var134     =	$2222
     36  28000 ????		22 23	    var135     =	$2223
     37  28000 ????		22 24	    var136     =	$2224
     38  28000 ????		22 25	    var137     =	$2225
     39  28000 ????		22 26	    var138     =	$2226
     40  28000 ????		22 27	    var139     =	$2227
     41  28000 ????		22 28	    var140     =	$2228
     42  28000 ????		22 29	    var141     =	$2229
     43  28000 ????		22 2a	    var142     =	$222A
     44  28000 ????		22 2b	    var143     =	$222B
     45  28000 ????		22 2c	    var144     =	$222C
     46  28000 ????		22 2d	    var145     =	$222D
     47  28000 ????		22 2e	    var146     =	$222E
     48  28000 ????		22 2f	    var147     =	$222F
     49  28000 ????		22 30	    var148     =	$2230
     50  28000 ????		22 31	    var149     =	$2231
     51  28000 ????		22 32	    var150     =	$2232
     52  28000 ????		22 33	    var151     =	$2233
     53  28000 ????		22 34	    var152     =	$2234
     54  28000 ????		22 35	    var153     =	$2235
     55  28000 ????		22 36	    var154     =	$2236
     56  28000 ????		22 37	    var155     =	$2237
     57  28000 ????		22 38	    var156     =	$2238
     58  28000 ????		22 39	    var157     =	$2239
     59  28000 ????		22 3a	    var158     =	$223A
     60  28000 ????		22 3b	    var159     =	$223B
     61  28000 ????		22 3c	    var160     =	$223C
     62  28000 ????		22 3d	    var161     =	$223D
     63  28000 ????		22 3e	    var162     =	$223E
     64  28000 ????		22 3f	    var163     =	$223F
     65  28000 ????		22 40	    var164     =	$2240
     66  28000 ????		22 41	    var165     =	$2241
     67  28000 ????		22 42	    var166     =	$2242
     68  28000 ????		22 43	    var167     =	$2243
     69  28000 ????		22 44	    var168     =	$2244
     70  28000 ????		22 45	    var169     =	$2245
     71  28000 ????		22 46	    var170     =	$2246
     72  28000 ????		22 47	    var171     =	$2247
     73  28000 ????		22 48	    var172     =	$2248
     74  28000 ????		22 49	    var173     =	$2249
     75  28000 ????		22 4a	    var174     =	$224A
     76  28000 ????		22 4b	    var175     =	$224B
     77  28000 ????		22 4c	    var176     =	$224C
     78  28000 ????		22 4d	    var177     =	$224D
     79  28000 ????		22 4e	    var178     =	$224E
     80  28000 ????		22 4f	    var179     =	$224F
     81  28000 ????		22 50	    var180     =	$2250
     82  28000 ????		22 51	    var181     =	$2251
     83  28000 ????		22 52	    var182     =	$2252
     84  28000 ????		22 53	    var183     =	$2253
     85  28000 ????		22 54	    var184     =	$2254
     86  28000 ????		22 55	    var185     =	$2255
     87  28000 ????		22 56	    var186     =	$2256
     88  28000 ????		22 57	    var187     =	$2257
     89  28000 ????		22 58	    var188     =	$2258
     90  28000 ????		22 59	    var189     =	$2259
     91  28000 ????		22 5a	    var190     =	$225A
     92  28000 ????		22 5b	    var191     =	$225B
     93  28000 ????		22 5c	    var192     =	$225C
     94  28000 ????		22 5d	    var193     =	$225D
     95  28000 ????		22 5e	    var194     =	$225E
     96  28000 ????		22 5f	    var195     =	$225F
     97  28000 ????		22 60	    var196     =	$2260
     98  28000 ????		22 61	    var197     =	$2261
     99  28000 ????		22 62	    var198     =	$2262
    100  28000 ????		22 63	    var199     =	$2263
    101  28000 ????		22 64	    var200     =	$2264
    102  28000 ????		22 65	    var201     =	$2265
    103  28000 ????		22 66	    var202     =	$2266
    104  28000 ????		22 67	    var203     =	$2267
    105  28000 ????		22 68	    var204     =	$2268
    106  28000 ????		22 69	    var205     =	$2269
    107  28000 ????		22 6a	    var206     =	$226A
    108  28000 ????		22 6b	    var207     =	$226B
    109  28000 ????		22 6c	    var208     =	$226C
    110  28000 ????		22 6d	    var209     =	$226D
    111  28000 ????		22 6e	    var210     =	$226E
    112  28000 ????		22 6f	    var211     =	$226F
    113  28000 ????		22 70	    var212     =	$2270
    114  28000 ????		22 71	    var213     =	$2271
    115  28000 ????		22 72	    var214     =	$2272
    116  28000 ????		22 73	    var215     =	$2273
    117  28000 ????		22 74	    var216     =	$2274
    118  28000 ????		22 75	    var217     =	$2275
    119  28000 ????		22 76	    var218     =	$2276
    120  28000 ????		22 77	    var219     =	$2277
    121  28000 ????		22 78	    var220     =	$2278
    122  28000 ????		22 79	    var221     =	$2279
    123  28000 ????		22 7a	    var222     =	$227A
    124  28000 ????		22 7b	    var223     =	$227B
    125  28000 ????		22 7c	    var224     =	$227C
    126  28000 ????		22 7d	    var225     =	$227D
    127  28000 ????		22 7e	    var226     =	$227E
    128  28000 ????		22 7f	    var227     =	$227F
    129  28000 ????		22 80	    var228     =	$2280
    130  28000 ????		22 81	    var229     =	$2281
    131  28000 ????		22 82	    var230     =	$2282
    132  28000 ????		22 83	    var231     =	$2283
    133  28000 ????		22 84	    var232     =	$2284
    134  28000 ????		22 85	    var233     =	$2285
    135  28000 ????		22 86	    var234     =	$2286
    136  28000 ????		22 87	    var235     =	$2287
    137  28000 ????		22 88	    var236     =	$2288
    138  28000 ????		22 89	    var237     =	$2289
    139  28000 ????		22 8a	    var238     =	$228A
    140  28000 ????		22 8b	    var239     =	$228B
    141  28000 ????		22 8c	    var240     =	$228C
    142  28000 ????		22 8d	    var241     =	$228D
    143  28000 ????		22 8e	    var242     =	$228E
    144  28000 ????		22 8f	    var243     =	$228F
    145  28000 ????		22 90	    var244     =	$2290
    146  28000 ????		22 91	    var245     =	$2291
    147  28000 ????		22 92	    var246     =	$2292
    148  28000 ????		22 93	    var247     =	$2293
    149  28000 ????		22 94	    var248     =	$2294
    150  28000 ????		22 95	    var249     =	$2295
    151  28000 ????		22 96	    var250     =	$2296
    152  28000 ????		22 97	    var251     =	$2297
    153  28000 ????		22 98	    var252     =	$2298
    154  28000 ????		22 99	    var253     =	$2299
    155  28000 ????		22 9a	    var254     =	$229A
    156  28000 ????		22 9b	    var255     =	$229B
    157  28000 ????		22 9c	    var256     =	$229C
    158  28000 ????		22 9d	    var257     =	$229D
    159  28000 ????		22 9e	    var258     =	$229E
    160  28000 ????		22 9f	    var259     =	$229F
    161  28000 ????		22 a0	    var260     =	$22A0
    162  28000 ????		22 a1	    var261     =	$22A1
    163  28000 ????		22 a2	    var262     =	$22A2
    164  28000 ????		22 a3	    var263     =	$22A3
    165  28000 ????		22 a4	    var264     =	$22A4
    166  28000 ????		22 a5	    var265     =	$22A5
    167  28000 ????		22 a6	    var266     =	$22A6
    168  28000 ????		22 a7	    var267     =	$22A7
    169  28000 ????		22 a8	    var268     =	$22A8
    170  28000 ????		22 a9	    var269     =	$22A9
    171  28000 ????		22 aa	    var270     =	$22AA
    172  28000 ????		22 ab	    var271     =	$22AB
    173  28000 ????		22 ac	    var272     =	$22AC
    174  28000 ????		22 ad	    var273     =	$22AD
    175  28000 ????		22 ae	    var274     =	$22AE
    176  28000 ????		22 af	    var275     =	$22AF
    177  28000 ????		22 b0	    var276     =	$22B0
    178  28000 ????		22 b1	    var277     =	$22B1
    179  28000 ????		22 b2	    var278     =	$22B2
    180  28000 ????		22 b3	    var279     =	$22B3
    181  28000 ????		22 b4	    var280     =	$22B4
    182  28000 ????		22 b5	    var281     =	$22B5
    183  28000 ????		22 b6	    var282     =	$22B6
    184  28000 ????		22 b7	    var283     =	$22B7
    185  28000 ????		22 b8	    var284     =	$22B8
    186  28000 ????		22 b9	    var285     =	$22B9
    187  28000 ????		22 ba	    var286     =	$22BA
    188  28000 ????		22 bb	    var287     =	$22BB
    189  28000 ????		22 bc	    var288     =	$22BC
    190  28000 ????		22 bd	    var289     =	$22BD
    191  28000 ????		22 be	    var290     =	$22BE
    192  28000 ????		22 bf	    var291     =	$22BF
    193  28000 ????		22 c0	    var292     =	$22C0
    194  28000 ????		22 c1	    var293     =	$22C1
    195  28000 ????		22 c2	    var294     =	$22C2
    196  28000 ????		22 c3	    var295     =	$22C3
    197  28000 ????		22 c4	    var296     =	$22C4
    198  28000 ????		22 c5	    var297     =	$22C5
    199  28000 ????		22 c6	    var298     =	$22C6
    200  28000 ????		22 c7	    var299     =	$22C7
    201  28000 ????		22 c8	    var300     =	$22C8
    202  28000 ????		22 c9	    var301     =	$22C9
    203  28000 ????		22 ca	    var302     =	$22CA
    204  28000 ????		22 cb	    var303     =	$22CB
    205  28000 ????		22 cc	    var304     =	$22CC
    206  28000 ????		22 cd	    var305     =	$22CD
    207  28000 ????		22 ce	    var306     =	$22CE
    208  28000 ????		22 cf	    var307     =	$22CF
    209  28000 ????		22 d0	    var308     =	$22D0
    210  28000 ????		22 d1	    var309     =	$22D1
    211  28000 ????		22 d2	    var310     =	$22D2
    212  28000 ????		22 d3	    var311     =	$22D3
    213  28000 ????		22 d4	    var312     =	$22D4
    214  28000 ????		22 d5	    var313     =	$22D5
    215  28000 ????		22 d6	    var314     =	$22D6
    216  28000 ????		22 d7	    var315     =	$22D7
    217  28000 ????		22 d8	    var316     =	$22D8
    218  28000 ????		22 d9	    var317     =	$22D9
    219  28000 ????		22 da	    var318     =	$22DA
    220  28000 ????		22 db	    var319     =	$22DB
    221  28000 ????		22 dc	    var320     =	$22DC
    222  28000 ????		22 dd	    var321     =	$22DD
    223  28000 ????		22 de	    var322     =	$22DE
    224  28000 ????		22 df	    var323     =	$22DF
    225  28000 ????		22 e0	    var324     =	$22E0
    226  28000 ????		22 e1	    var325     =	$22E1
    227  28000 ????		22 e2	    var326     =	$22E2
    228  28000 ????		22 e3	    var327     =	$22E3
    229  28000 ????		22 e4	    var328     =	$22E4
    230  28000 ????		22 e5	    var329     =	$22E5
    231  28000 ????		22 e6	    var330     =	$22E6
    232  28000 ????		22 e7	    var331     =	$22E7
    233  28000 ????		22 e8	    var332     =	$22E8
    234  28000 ????		22 e9	    var333     =	$22E9
    235  28000 ????		22 ea	    var334     =	$22EA
    236  28000 ????		22 eb	    var335     =	$22EB
    237  28000 ????		22 ec	    var336     =	$22EC
    238  28000 ????		22 ed	    var337     =	$22ED
    239  28000 ????		22 ee	    var338     =	$22EE
    240  28000 ????		22 ef	    var339     =	$22EF
    241  28000 ????		22 f0	    var340     =	$22F0
    242  28000 ????		22 f1	    var341     =	$22F1
    243  28000 ????		22 f2	    var342     =	$22F2
    244  28000 ????		22 f3	    var343     =	$22F3
    245  28000 ????		22 f4	    var344     =	$22F4
    246  28000 ????		22 f5	    var345     =	$22F5
    247  28000 ????		22 f6	    var346     =	$22F6
    248  28000 ????		22 f7	    var347     =	$22F7
    249  28000 ????		22 f8	    var348     =	$22F8
    250  28000 ????		22 f9	    var349     =	$22F9
    251  28000 ????		22 fa	    var350     =	$22FA
    252  28000 ????		22 fb	    var351     =	$22FB
    253  28000 ????		22 fc	    var352     =	$22FC
    254  28000 ????		22 fd	    var353     =	$22FD
    255  28000 ????		22 fe	    var354     =	$22FE
    256  28000 ????		22 ff	    var355     =	$22FF
    257  28000 ????		23 00	    var356     =	$2300
    258  28000 ????		23 01	    var357     =	$2301
    259  28000 ????		23 02	    var358     =	$2302
    260  28000 ????		23 03	    var359     =	$2303
    261  28000 ????		23 04	    var360     =	$2304
    262  28000 ????		23 05	    var361     =	$2305
    263  28000 ????		23 06	    var362     =	$2306
    264  28000 ????		23 07	    var363     =	$2307
    265  28000 ????		23 08	    var364     =	$2308
    266  28000 ????		23 09	    var365     =	$2309
    267  28000 ????		23 0a	    var366     =	$230A
    268  28000 ????		23 0b	    var367     =	$230B
    269  28000 ????		23 0c	    var368     =	$230C
    270  28000 ????		23 0d	    var369     =	$230D
    271  28000 ????		23 0e	    var370     =	$230E
    272  28000 ????		23 0f	    var371     =	$230F
    273  28000 ????		23 10	    var372     =	$2310
    274  28000 ????		23 11	    var373     =	$2311
    275  28000 ????		23 12	    var374     =	$2312
    276  28000 ????		23 13	    var375     =	$2313
    277  28000 ????		23 14	    var376     =	$2314
    278  28000 ????		23 15	    var377     =	$2315
    279  28000 ????		23 16	    var378     =	$2316
    280  28000 ????		23 17	    var379     =	$2317
    281  28000 ????		23 18	    var380     =	$2318
    282  28000 ????		23 19	    var381     =	$2319
    283  28000 ????		23 1a	    var382     =	$231A
    284  28000 ????		23 1b	    var383     =	$231B
    285  28000 ????		23 1c	    var384     =	$231C
    286  28000 ????		23 1d	    var385     =	$231D
    287  28000 ????		23 1e	    var386     =	$231E
    288  28000 ????		23 1f	    var387     =	$231F
    289  28000 ????		23 20	    var388     =	$2320
    290  28000 ????		23 21	    var389     =	$2321
    291  28000 ????		23 22	    var390     =	$2322
    292  28000 ????		23 23	    var391     =	$2323
    293  28000 ????		23 24	    var392     =	$2324
    294  28000 ????		23 25	    var393     =	$2325
    295  28000 ????		23 26	    var394     =	$2326
    296  28000 ????		23 27	    var395     =	$2327
    297  28000 ????		23 28	    var396     =	$2328
    298  28000 ????		23 29	    var397     =	$2329
    299  28000 ????		23 2a	    var398     =	$232A
    300  28000 ????		23 2b	    var399     =	$232B
    301  28000 ????		23 2c	    var400     =	$232C
    302  28000 ????		23 2d	    var401     =	$232D
    303  28000 ????		23 2e	    var402     =	$232E
    304  28000 ????		23 2f	    var403     =	$232F
    305  28000 ????		23 30	    var404     =	$2330
    306  28000 ????		23 31	    var405     =	$2331
    307  28000 ????		23 32	    var406     =	$2332
    308  28000 ????		23 33	    var407     =	$2333
    309  28000 ????		23 34	    var408     =	$2334
    310  28000 ????		23 35	    var409     =	$2335
    311  28000 ????		23 36	    var410     =	$2336
    312  28000 ????		23 37	    var411     =	$2337
    313  28000 ????		23 38	    var412     =	$2338
    314  28000 ????		23 39	    var413     =	$2339
    315  28000 ????		23 3a	    var414     =	$233A
    316  28000 ????		23 3b	    var415     =	$233B
    317  28000 ????		23 3c	    var416     =	$233C
    318  28000 ????		23 3d	    var417     =	$233D
    319  28000 ????		23 3e	    var418     =	$233E
    320  28000 ????		23 3f	    var419     =	$233F
    321  28000 ????		23 40	    var420     =	$2340
    322  28000 ????		23 41	    var421     =	$2341
    323  28000 ????		23 42	    var422     =	$2342
    324  28000 ????		23 43	    var423     =	$2343
    325  28000 ????		23 44	    var424     =	$2344
    326  28000 ????		23 45	    var425     =	$2345
    327  28000 ????		23 46	    var426     =	$2346
    328  28000 ????		23 47	    var427     =	$2347
    329  28000 ????		23 48	    var428     =	$2348
    330  28000 ????		23 49	    var429     =	$2349
    331  28000 ????		23 4a	    var430     =	$234A
    332  28000 ????		23 4b	    var431     =	$234B
    333  28000 ????		23 4c	    var432     =	$234C
    334  28000 ????		23 4d	    var433     =	$234D
    335  28000 ????		23 4e	    var434     =	$234E
    336  28000 ????		23 4f	    var435     =	$234F
    337  28000 ????		23 50	    var436     =	$2350
    338  28000 ????		23 51	    var437     =	$2351
    339  28000 ????		23 52	    var438     =	$2352
    340  28000 ????		23 53	    var439     =	$2353
    341  28000 ????		23 54	    var440     =	$2354
    342  28000 ????		23 55	    var441     =	$2355
    343  28000 ????		23 56	    var442     =	$2356
    344  28000 ????		23 57	    var443     =	$2357
    345  28000 ????		23 58	    var444     =	$2358
    346  28000 ????		23 59	    var445     =	$2359
    347  28000 ????		23 5a	    var446     =	$235A
    348  28000 ????		23 5b	    var447     =	$235B
    349  28000 ????		23 5c	    var448     =	$235C
    350  28000 ????		23 5d	    var449     =	$235D
    351  28000 ????		23 5e	    var450     =	$235E
    352  28000 ????		23 5f	    var451     =	$235F
    353  28000 ????		23 60	    var452     =	$2360
    354  28000 ????		23 61	    var453     =	$2361
    355  28000 ????		23 62	    var454     =	$2362
    356  28000 ????		23 63	    var455     =	$2363
    357  28000 ????		23 64	    var456     =	$2364
    358  28000 ????		23 65	    var457     =	$2365
    359  28000 ????		23 66	    var458     =	$2366
    360  28000 ????		23 67	    var459     =	$2367
    361  28000 ????		23 68	    var460     =	$2368
    362  28000 ????		23 69	    var461     =	$2369
    363  28000 ????		23 6a	    var462     =	$236A
    364  28000 ????		23 6b	    var463     =	$236B
    365  28000 ????		23 6c	    var464     =	$236C
    366  28000 ????		23 6d	    var465     =	$236D
    367  28000 ????		23 6e	    var466     =	$236E
    368  28000 ????		23 6f	    var467     =	$236F
    369  28000 ????		23 70	    var468     =	$2370
    370  28000 ????		23 71	    var469     =	$2371
    371  28000 ????		23 72	    var470     =	$2372
    372  28000 ????		23 73	    var471     =	$2373
    373  28000 ????		23 74	    var472     =	$2374
    374  28000 ????		23 75	    var473     =	$2375
    375  28000 ????		23 76	    var474     =	$2376
    376  28000 ????		23 77	    var475     =	$2377
    377  28000 ????		23 78	    var476     =	$2378
    378  28000 ????		23 79	    var477     =	$2379
    379  28000 ????		23 7a	    var478     =	$237A
    380  28000 ????		23 7b	    var479     =	$237B
    381  28000 ????		23 7c	    var480     =	$237C
    382  28000 ????		23 7d	    var481     =	$237D
    383  28000 ????		23 7e	    var482     =	$237E
    384  28000 ????		23 7f	    var483     =	$237F
    385  28000 ????		23 80	    var484     =	$2380
    386  28000 ????		23 81	    var485     =	$2381
    387  28000 ????		23 82	    var486     =	$2382
    388  28000 ????		23 83	    var487     =	$2383
    389  28000 ????		23 84	    var488     =	$2384
    390  28000 ????		23 85	    var489     =	$2385
    391  28000 ????		23 86	    var490     =	$2386
    392  28000 ????		23 87	    var491     =	$2387
    393  28000 ????		23 88	    var492     =	$2388
    394  28000 ????		23 89	    var493     =	$2389
    395  28000 ????		23 8a	    var494     =	$238A
    396  28000 ????		23 8b	    var495     =	$238B
    397  28000 ????		23 8c	    var496     =	$238C
    398  28000 ????		23 8d	    var497     =	$238D
    399  28000 ????		23 8e	    var498     =	$238E
    400  28000 ????		23 8f	    var499     =	$238F
    401  28000 ????		23 90	    var500     =	$2390
    402  28000 ????		23 91	    var501     =	$2391
    403  28000 ????		23 92	    var502     =	$2392
    404  28000 ????		23 93	    var503     =	$2393
    405  28000 ????		23 94	    var504     =	$2394
    406  28000 ????		23 95	    var505     =	$2395
    407  28000 ????		23 96	    var506     =	$2396
    408  28000 ????		23 97	    var507     =	$2397
    409  28000 ????		23 98	    var508     =	$2398
    410  28000 ????		23 99	    var509     =	$2399
    411  28000 ????		23 9a	    var510     =	$239A
    412  28000 ????		23 9b	    var511     =	$239B
    413  28000 ????		23 9c	    var512     =	$239C
    414  28000 ????		23 9d	    var513     =	$239D
    415  28000 ????		23 9e	    var514     =	$239E
    416  28000 ????		23 9f	    var515     =	$239F
    417  28000 ????		23 a0	    var516     =	$23A0
    418  28000 ????		23 a1	    var517     =	$23A1
    419  28000 ????		23 a2	    var518     =	$23A2
    420  28000 ????		23 a3	    var519     =	$23A3
    421  28000 ????		23 a4	    var520     =	$23A4
    422  28000 ????		23 a5	    var521     =	$23A5
    423  28000 ????		23 a6	    var522     =	$23A6
    424  28000 ????		23 a7	    var523     =	$23A7
    425  28000 ????		23 a8	    var524     =	$23A8
    426  28000 ????		23 a9	    var525     =	$23A9
    427  28000 ????		23 aa	    var526     =	$23AA
    428  28000 ????		23 ab	    var527     =	$23AB
    429  28000 ????		23 ac	    var528     =	$23AC
    430  28000 ????		23 ad	    var529     =	$23AD
    431  28000 ????		23 ae	    var530     =	$23AE
    432  28000 ????		23 af	    var531     =	$23AF
    433  28000 ????		23 b0	    var532     =	$23B0
    434  28000 ????		23 b1	    var533     =	$23B1
    435  28000 ????		23 b2	    var534     =	$23B2
    436  28000 ????		23 b3	    var535     =	$23B3
    437  28000 ????		23 b4	    var536     =	$23B4
    438  28000 ????		23 b5	    var537     =	$23B5
    439  28000 ????		23 b6	    var538     =	$23B6
    440  28000 ????		23 b7	    var539     =	$23B7
    441  28000 ????		23 b8	    var540     =	$23B8
    442  28000 ????		23 b9	    var541     =	$23B9
    443  28000 ????		23 ba	    var542     =	$23BA
    444  28000 ????		23 bb	    var543     =	$23BB
    445  28000 ????		23 bc	    var544     =	$23BC
    446  28000 ????		23 bd	    var545     =	$23BD
    447  28000 ????		23 be	    var546     =	$23BE
    448  28000 ????		23 bf	    var547     =	$23BF
    449  28000 ????		23 c0	    var548     =	$23C0
    450  28000 ????		23 c1	    var549     =	$23C1
    451  28000 ????		23 c2	    var550     =	$23C2
    452  28000 ????		23 c3	    var551     =	$23C3
    453  28000 ????		23 c4	    var552     =	$23C4
    454  28000 ????		23 c5	    var553     =	$23C5
    455  28000 ????		23 c6	    var554     =	$23C6
    456  28000 ????		23 c7	    var555     =	$23C7
    457  28000 ????		23 c8	    var556     =	$23C8
    458  28000 ????		23 c9	    var557     =	$23C9
    459  28000 ????		23 ca	    var558     =	$23CA
    460  28000 ????		23 cb	    var559     =	$23CB
    461  28000 ????		23 cc	    var560     =	$23CC
    462  28000 ????		23 cd	    var561     =	$23CD
    463  28000 ????		23 ce	    var562     =	$23CE
    464  28000 ????		23 cf	    var563     =	$23CF
    465  28000 ????		23 d0	    var564     =	$23D0
    466  28000 ????		23 d1	    var565     =	$23D1
    467  28000 ????		23 d2	    var566     =	$23D2
    468  28000 ????		23 d3	    var567     =	$23D3
    469  28000 ????		23 d4	    var568     =	$23D4
    470  28000 ????		23 d5	    var569     =	$23D5
    471  28000 ????		23 d6	    var570     =	$23D6
    472  28000 ????		23 d7	    var571     =	$23D7
    473  28000 ????		23 d8	    var572     =	$23D8
    474  28000 ????		23 d9	    var573     =	$23D9
    475  28000 ????		23 da	    var574     =	$23DA
    476  28000 ????		23 db	    var575     =	$23DB
    477  28000 ????		23 dc	    var576     =	$23DC
    478  28000 ????		23 dd	    var577     =	$23DD
    479  28000 ????		23 de	    var578     =	$23DE
    480  28000 ????		23 df	    var579     =	$23DF
    481  28000 ????		23 e0	    var580     =	$23E0
    482  28000 ????		23 e1	    var581     =	$23E1
    483  28000 ????		23 e2	    var582     =	$23E2
    484  28000 ????		23 e3	    var583     =	$23E3
    485  28000 ????		23 e4	    var584     =	$23E4
    486  28000 ????		23 e5	    var585     =	$23E5
    487  28000 ????		23 e6	    var586     =	$23E6
    488  28000 ????		23 e7	    var587     =	$23E7
    489  28000 ????		23 e8	    var588     =	$23E8
    490  28000 ????		23 e9	    var589     =	$23E9
    491  28000 ????		23 ea	    var590     =	$23EA
    492  28000 ????		23 eb	    var591     =	$23EB
    493  28000 ????		23 ec	    var592     =	$23EC
    494  28000 ????		23 ed	    var593     =	$23ED
    495  28000 ????		23 ee	    var594     =	$23EE
    496  28000 ????		23 ef	    var595     =	$23EF
    497  28000 ????		23 f0	    var596     =	$23F0
    498  28000 ????		23 f1	    var597     =	$23F1
    499  28000 ????		23 f2	    var598     =	$23F2
    500  28000 ????		23 f3	    var599     =	$23F3
    501  28000 ????		23 f4	    var600     =	$23F4
    502  28000 ????		23 f5	    var601     =	$23F5
    503  28000 ????		23 f6	    var602     =	$23F6
    504  28000 ????		23 f7	    var603     =	$23F7
    505  28000 ????		23 f8	    var604     =	$23F8
    506  28000 ????		23 f9	    var605     =	$23F9
    507  28000 ????		23 fa	    var606     =	$23FA
    508  28000 ????		23 fb	    var607     =	$23FB
    509  28000 ????		23 fc	    var608     =	$23FC
    510  28000 ????		23 fd	    var609     =	$23FD
    511  28000 ????		23 fe	    var610     =	$23FE
    512  28000 ????		23 ff	    var611     =	$23FF
    513  28000 ????		24 00	    var612     =	$2400
    514  28000 ????		24 01	    var613     =	$2401
    515  28000 ????		24 02	    var614     =	$2402
    516  28000 ????		24 03	    var615     =	$2403
    517  28000 ????		24 04	    var616     =	$2404
    518  28000 ????		24 05	    var617     =	$2405
    519  28000 ????		24 06	    var618     =	$2406
    520  28000 ????		24 07	    var619     =	$2407
    521  28000 ????		24 08	    var620     =	$2408
    522  28000 ????		24 09	    var621     =	$2409
    523  28000 ????		24 0a	    var622     =	$240A
    524  28000 ????		24 0b	    var623     =	$240B
    525  28000 ????		24 0c	    var624     =	$240C
    526  28000 ????		24 0d	    var625     =	$240D
    527  28000 ????		24 0e	    var626     =	$240E
    528  28000 ????		24 0f	    var627     =	$240F
    529  28000 ????		24 10	    var628     =	$2410
    530  28000 ????		24 11	    var629     =	$2411
    531  28000 ????		24 12	    var630     =	$2412
    532  28000 ????		24 13	    var631     =	$2413
    533  28000 ????		24 14	    var632     =	$2414
    534  28000 ????		24 15	    var633     =	$2415
    535  28000 ????		24 16	    var634     =	$2416
    536  28000 ????		24 17	    var635     =	$2417
    537  28000 ????		24 18	    var636     =	$2418
    538  28000 ????		24 19	    var637     =	$2419
    539  28000 ????		24 1a	    var638     =	$241A
    540  28000 ????		24 1b	    var639     =	$241B
    541  28000 ????		24 1c	    var640     =	$241C
    542  28000 ????		24 1d	    var641     =	$241D
    543  28000 ????		24 1e	    var642     =	$241E
    544  28000 ????		24 1f	    var643     =	$241F
    545  28000 ????		24 20	    var644     =	$2420
    546  28000 ????		24 21	    var645     =	$2421
    547  28000 ????		24 22	    var646     =	$2422
    548  28000 ????		24 23	    var647     =	$2423
    549  28000 ????		24 24	    var648     =	$2424
    550  28000 ????		24 25	    var649     =	$2425
    551  28000 ????		24 26	    var650     =	$2426
    552  28000 ????		24 27	    var651     =	$2427
    553  28000 ????		24 28	    var652     =	$2428
    554  28000 ????		24 29	    var653     =	$2429
    555  28000 ????		24 2a	    var654     =	$242A
    556  28000 ????		24 2b	    var655     =	$242B
    557  28000 ????		24 2c	    var656     =	$242C
    558  28000 ????		24 2d	    var657     =	$242D
    559  28000 ????		24 2e	    var658     =	$242E
    560  28000 ????		24 2f	    var659     =	$242F
    561  28000 ????		24 30	    var660     =	$2430
    562  28000 ????		24 31	    var661     =	$2431
    563  28000 ????		24 32	    var662     =	$2432
    564  28000 ????		24 33	    var663     =	$2433
    565  28000 ????		24 34	    var664     =	$2434
    566  28000 ????		24 35	    var665     =	$2435
    567  28000 ????		24 36	    var666     =	$2436
    568  28000 ????		24 37	    var667     =	$2437
    569  28000 ????		24 38	    var668     =	$2438
    570  28000 ????		24 39	    var669     =	$2439
    571  28000 ????		24 3a	    var670     =	$243A
    572  28000 ????		24 3b	    var671     =	$243B
    573  28000 ????		24 3c	    var672     =	$243C
    574  28000 ????		24 3d	    var673     =	$243D
    575  28000 ????		24 3e	    var674     =	$243E
    576  28000 ????		24 3f	    var675     =	$243F
    577  28000 ????		24 40	    var676     =	$2440
    578  28000 ????		24 41	    var677     =	$2441
    579  28000 ????		24 42	    var678     =	$2442
    580  28000 ????		24 43	    var679     =	$2443
    581  28000 ????		24 44	    var680     =	$2444
    582  28000 ????		24 45	    var681     =	$2445
    583  28000 ????		24 46	    var682     =	$2446
    584  28000 ????		24 47	    var683     =	$2447
    585  28000 ????		24 48	    var684     =	$2448
    586  28000 ????		24 49	    var685     =	$2449
    587  28000 ????		24 4a	    var686     =	$244A
    588  28000 ????		24 4b	    var687     =	$244B
    589  28000 ????		24 4c	    var688     =	$244C
    590  28000 ????		24 4d	    var689     =	$244D
    591  28000 ????		24 4e	    var690     =	$244E
    592  28000 ????		24 4f	    var691     =	$244F
    593  28000 ????		24 50	    var692     =	$2450
    594  28000 ????		24 51	    var693     =	$2451
    595  28000 ????		24 52	    var694     =	$2452
    596  28000 ????		24 53	    var695     =	$2453
    597  28000 ????		24 54	    var696     =	$2454
    598  28000 ????		24 55	    var697     =	$2455
    599  28000 ????		24 56	    var698     =	$2456
    600  28000 ????		24 57	    var699     =	$2457
    601  28000 ????		24 58	    var700     =	$2458
    602  28000 ????		24 59	    var701     =	$2459
    603  28000 ????		24 5a	    var702     =	$245A
    604  28000 ????		24 5b	    var703     =	$245B
    605  28000 ????		24 5c	    var704     =	$245C
    606  28000 ????		24 5d	    var705     =	$245D
    607  28000 ????		24 5e	    var706     =	$245E
    608  28000 ????		24 5f	    var707     =	$245F
    609  28000 ????		24 60	    var708     =	$2460
    610  28000 ????		24 61	    var709     =	$2461
    611  28000 ????		24 62	    var710     =	$2462
    612  28000 ????		24 63	    var711     =	$2463
    613  28000 ????		24 64	    var712     =	$2464
    614  28000 ????		24 65	    var713     =	$2465
    615  28000 ????		24 66	    var714     =	$2466
    616  28000 ????		24 67	    var715     =	$2467
    617  28000 ????		24 68	    var716     =	$2468
    618  28000 ????		24 69	    var717     =	$2469
    619  28000 ????		24 6a	    var718     =	$246A
    620  28000 ????		24 6b	    var719     =	$246B
    621  28000 ????		24 6c	    var720     =	$246C
    622  28000 ????		24 6d	    var721     =	$246D
    623  28000 ????		24 6e	    var722     =	$246E
    624  28000 ????		24 6f	    var723     =	$246F
    625  28000 ????		24 70	    var724     =	$2470
    626  28000 ????		24 71	    var725     =	$2471
    627  28000 ????		24 72	    var726     =	$2472
    628  28000 ????		24 73	    var727     =	$2473
    629  28000 ????		24 74	    var728     =	$2474
    630  28000 ????		24 75	    var729     =	$2475
    631  28000 ????		24 76	    var730     =	$2476
    632  28000 ????		24 77	    var731     =	$2477
    633  28000 ????		24 78	    var732     =	$2478
    634  28000 ????		24 79	    var733     =	$2479
    635  28000 ????		24 7a	    var734     =	$247A
    636  28000 ????		24 7b	    var735     =	$247B
    637  28000 ????		24 7c	    var736     =	$247C
    638  28000 ????		24 7d	    var737     =	$247D
    639  28000 ????		24 7e	    var738     =	$247E
    640  28000 ????		24 7f	    var739     =	$247F
    641  28000 ????		24 80	    var740     =	$2480
    642  28000 ????		24 81	    var741     =	$2481
    643  28000 ????		24 82	    var742     =	$2482
    644  28000 ????		24 83	    var743     =	$2483
    645  28000 ????		24 84	    var744     =	$2484
    646  28000 ????		24 85	    var745     =	$2485
    647  28000 ????		24 86	    var746     =	$2486
    648  28000 ????		24 87	    var747     =	$2487
    649  28000 ????		24 88	    var748     =	$2488
    650  28000 ????		24 89	    var749     =	$2489
    651  28000 ????		24 8a	    var750     =	$248A
    652  28000 ????		24 8b	    var751     =	$248B
    653  28000 ????		24 8c	    var752     =	$248C
    654  28000 ????		24 8d	    var753     =	$248D
    655  28000 ????		24 8e	    var754     =	$248E
    656  28000 ????		24 8f	    var755     =	$248F
    657  28000 ????		24 90	    var756     =	$2490
    658  28000 ????		24 91	    var757     =	$2491
    659  28000 ????		24 92	    var758     =	$2492
    660  28000 ????		24 93	    var759     =	$2493
    661  28000 ????		24 94	    var760     =	$2494
    662  28000 ????		24 95	    var761     =	$2495
    663  28000 ????		24 96	    var762     =	$2496
    664  28000 ????		24 97	    var763     =	$2497
    665  28000 ????		24 98	    var764     =	$2498
    666  28000 ????		24 99	    var765     =	$2499
    667  28000 ????		24 9a	    var766     =	$249A
    668  28000 ????		24 9b	    var767     =	$249B
    669  28000 ????		24 9c	    var768     =	$249C
    670  28000 ????		24 9d	    var769     =	$249D
    671  28000 ????		24 9e	    var770     =	$249E
    672  28000 ????		24 9f	    var771     =	$249F
    673  28000 ????		24 a0	    var772     =	$24A0
    674  28000 ????		24 a1	    var773     =	$24A1
    675  28000 ????		24 a2	    var774     =	$24A2
    676  28000 ????		24 a3	    var775     =	$24A3
    677  28000 ????		24 a4	    var776     =	$24A4
    678  28000 ????		24 a5	    var777     =	$24A5
    679  28000 ????		24 a6	    var778     =	$24A6
    680  28000 ????		24 a7	    var779     =	$24A7
    681  28000 ????		24 a8	    var780     =	$24A8
    682  28000 ????		24 a9	    var781     =	$24A9
    683  28000 ????		24 aa	    var782     =	$24AA
    684  28000 ????		24 ab	    var783     =	$24AB
    685  28000 ????		24 ac	    var784     =	$24AC
    686  28000 ????		24 ad	    var785     =	$24AD
    687  28000 ????		24 ae	    var786     =	$24AE
    688  28000 ????		24 af	    var787     =	$24AF
    689  28000 ????		24 b0	    var788     =	$24B0
    690  28000 ????		24 b1	    var789     =	$24B1
    691  28000 ????		24 b2	    var790     =	$24B2
    692  28000 ????		24 b3	    var791     =	$24B3
    693  28000 ????		24 b4	    var792     =	$24B4
    694  28000 ????		24 b5	    var793     =	$24B5
    695  28000 ????		24 b6	    var794     =	$24B6
    696  28000 ????		24 b7	    var795     =	$24B7
    697  28000 ????		24 b8	    var796     =	$24B8
    698  28000 ????		24 b9	    var797     =	$24B9
    699  28000 ????		24 ba	    var798     =	$24BA
    700  28000 ????		24 bb	    var799     =	$24BB
    701  28000 ????		24 bc	    var800     =	$24BC
    702  28000 ????		24 bd	    var801     =	$24BD
    703  28000 ????		24 be	    var802     =	$24BE
    704  28000 ????		24 bf	    var803     =	$24BF
    705  28000 ????		24 c0	    var804     =	$24C0
    706  28000 ????		24 c1	    var805     =	$24C1
    707  28000 ????		24 c2	    var806     =	$24C2
    708  28000 ????		24 c3	    var807     =	$24C3
    709  28000 ????		24 c4	    var808     =	$24C4
    710  28000 ????		24 c5	    var809     =	$24C5
    711  28000 ????		24 c6	    var810     =	$24C6
    712  28000 ????		24 c7	    var811     =	$24C7
    713  28000 ????		24 c8	    var812     =	$24C8
    714  28000 ????		24 c9	    var813     =	$24C9
    715  28000 ????		24 ca	    var814     =	$24CA
    716  28000 ????		24 cb	    var815     =	$24CB
    717  28000 ????		24 cc	    var816     =	$24CC
    718  28000 ????		24 cd	    var817     =	$24CD
    719  28000 ????		24 ce	    var818     =	$24CE
    720  28000 ????		24 cf	    var819     =	$24CF
    721  28000 ????		24 d0	    var820     =	$24D0
    722  28000 ????		24 d1	    var821     =	$24D1
    723  28000 ????		24 d2	    var822     =	$24D2
    724  28000 ????		24 d3	    var823     =	$24D3
    725  28000 ????		24 d4	    var824     =	$24D4
    726  28000 ????		24 d5	    var825     =	$24D5
    727  28000 ????		24 d6	    var826     =	$24D6
    728  28000 ????		24 d7	    var827     =	$24D7
    729  28000 ????		24 d8	    var828     =	$24D8
    730  28000 ????		24 d9	    var829     =	$24D9
    731  28000 ????		24 da	    var830     =	$24DA
    732  28000 ????		24 db	    var831     =	$24DB
    733  28000 ????		24 dc	    var832     =	$24DC
    734  28000 ????		24 dd	    var833     =	$24DD
    735  28000 ????		24 de	    var834     =	$24DE
    736  28000 ????		24 df	    var835     =	$24DF
    737  28000 ????		24 e0	    var836     =	$24E0
    738  28000 ????		24 e1	    var837     =	$24E1
    739  28000 ????		24 e2	    var838     =	$24E2
    740  28000 ????		24 e3	    var839     =	$24E3
    741  28000 ????		24 e4	    var840     =	$24E4
    742  28000 ????		24 e5	    var841     =	$24E5
    743  28000 ????		24 e6	    var842     =	$24E6
    744  28000 ????		24 e7	    var843     =	$24E7
    745  28000 ????		24 e8	    var844     =	$24E8
    746  28000 ????		24 e9	    var845     =	$24E9
    747  28000 ????		24 ea	    var846     =	$24EA
    748  28000 ????		24 eb	    var847     =	$24EB
    749  28000 ????		24 ec	    var848     =	$24EC
    750  28000 ????		24 ed	    var849     =	$24ED
    751  28000 ????		24 ee	    var850     =	$24EE
    752  28000 ????		24 ef	    var851     =	$24EF
    753  28000 ????		24 f0	    var852     =	$24F0
    754  28000 ????		24 f1	    var853     =	$24F1
    755  28000 ????		24 f2	    var854     =	$24F2
    756  28000 ????		24 f3	    var855     =	$24F3
    757  28000 ????		24 f4	    var856     =	$24F4
    758  28000 ????		24 f5	    var857     =	$24F5
    759  28000 ????		24 f6	    var858     =	$24F6
    760  28000 ????		24 f7	    var859     =	$24F7
    761  28000 ????		24 f8	    var860     =	$24F8
    762  28000 ????		24 f9	    var861     =	$24F9
    763  28000 ????		24 fa	    var862     =	$24FA
    764  28000 ????		24 fb	    var863     =	$24FB
    765  28000 ????		24 fc	    var864     =	$24FC
    766  28000 ????		24 fd	    var865     =	$24FD
    767  28000 ????		24 fe	    var866     =	$24FE
    768  28000 ????		24 ff	    var867     =	$24FF
    769  28000 ????		25 00	    var868     =	$2500
    770  28000 ????		25 01	    var869     =	$2501
    771  28000 ????		25 02	    var870     =	$2502
    772  28000 ????		25 03	    var871     =	$2503
    773  28000 ????		25 04	    var872     =	$2504
    774  28000 ????		25 05	    var873     =	$2505
    775  28000 ????		25 06	    var874     =	$2506
    776  28000 ????		25 07	    var875     =	$2507
    777  28000 ????		25 08	    var876     =	$2508
    778  28000 ????		25 09	    var877     =	$2509
    779  28000 ????		25 0a	    var878     =	$250A
    780  28000 ????		25 0b	    var879     =	$250B
    781  28000 ????		25 0c	    var880     =	$250C
    782  28000 ????		25 0d	    var881     =	$250D
    783  28000 ????		25 0e	    var882     =	$250E
    784  28000 ????		25 0f	    var883     =	$250F
    785  28000 ????		25 10	    var884     =	$2510
    786  28000 ????		25 11	    var885     =	$2511
    787  28000 ????		25 12	    var886     =	$2512
    788  28000 ????		25 13	    var887     =	$2513
    789  28000 ????		25 14	    var888     =	$2514
    790  28000 ????		25 15	    var889     =	$2515
    791  28000 ????		25 16	    var890     =	$2516
    792  28000 ????		25 17	    var891     =	$2517
    793  28000 ????		25 18	    var892     =	$2518
    794  28000 ????		25 19	    var893     =	$2519
    795  28000 ????		25 1a	    var894     =	$251A
    796  28000 ????		25 1b	    var895     =	$251B
    797  28000 ????		25 1c	    var896     =	$251C
    798  28000 ????		25 1d	    var897     =	$251D
    799  28000 ????		25 1e	    var898     =	$251E
    800  28000 ????		25 1f	    var899     =	$251F
    801  28000 ????		25 20	    var900     =	$2520
    802  28000 ????		25 21	    var901     =	$2521
    803  28000 ????		25 22	    var902     =	$2522
    804  28000 ????		25 23	    var903     =	$2523
    805  28000 ????		25 24	    var904     =	$2524
    806  28000 ????		25 25	    var905     =	$2525
    807  28000 ????		25 26	    var906     =	$2526
    808  28000 ????		25 27	    var907     =	$2527
    809  28000 ????		25 28	    var908     =	$2528
    810  28000 ????		25 29	    var909     =	$2529
    811  28000 ????		25 2a	    var910     =	$252A
    812  28000 ????		25 2b	    var911     =	$252B
    813  28000 ????		25 2c	    var912     =	$252C
    814  28000 ????		25 2d	    var913     =	$252D
    815  28000 ????		25 2e	    var914     =	$252E
    816  28000 ????		25 2f	    var915     =	$252F
    817  28000 ????		25 30	    var916     =	$2530
    818  28000 ????		25 31	    var917     =	$2531
    819  28000 ????		25 32	    var918     =	$2532
    820  28000 ????		25 33	    var919     =	$2533
    821  28000 ????		25 34	    var920     =	$2534
    822  28000 ????		25 35	    var921     =	$2535
    823  28000 ????		25 36	    var922     =	$2536
    824  28000 ????		25 37	    var923     =	$2537
    825  28000 ????		25 38	    var924     =	$2538
    826  28000 ????		25 39	    var925     =	$2539
    827  28000 ????		25 3a	    var926     =	$253A
    828  28000 ????		25 3b	    var927     =	$253B
    829  28000 ????		25 3c	    var928     =	$253C
    830  28000 ????		25 3d	    var929     =	$253D
    831  28000 ????		25 3e	    var930     =	$253E
    832  28000 ????		25 3f	    var931     =	$253F
    833  28000 ????		25 40	    var932     =	$2540
    834  28000 ????		25 41	    var933     =	$2541
    835  28000 ????		25 42	    var934     =	$2542
    836  28000 ????		25 43	    var935     =	$2543
    837  28000 ????		25 44	    var936     =	$2544
    838  28000 ????		25 45	    var937     =	$2545
    839  28000 ????		25 46	    var938     =	$2546
    840  28000 ????		25 47	    var939     =	$2547
    841  28000 ????		25 48	    var940     =	$2548
    842  28000 ????		25 49	    var941     =	$2549
    843  28000 ????		25 4a	    var942     =	$254A
    844  28000 ????		25 4b	    var943     =	$254B
    845  28000 ????		25 4c	    var944     =	$254C
    846  28000 ????		25 4d	    var945     =	$254D
    847  28000 ????		25 4e	    var946     =	$254E
    848  28000 ????		25 4f	    var947     =	$254F
    849  28000 ????		25 50	    var948     =	$2550
    850  28000 ????		25 51	    var949     =	$2551
    851  28000 ????		25 52	    var950     =	$2552
    852  28000 ????		25 53	    var951     =	$2553
    853  28000 ????		25 54	    var952     =	$2554
    854  28000 ????		25 55	    var953     =	$2555
    855  28000 ????		25 56	    var954     =	$2556
    856  28000 ????		25 57	    var955     =	$2557
    857  28000 ????		25 58	    var956     =	$2558
    858  28000 ????		25 59	    var957     =	$2559
    859  28000 ????		25 5a	    var958     =	$255A
    860  28000 ????		25 5b	    var959     =	$255B
    861  28000 ????		25 5c	    var960     =	$255C
    862  28000 ????		25 5d	    var961     =	$255D
    863  28000 ????		25 5e	    var962     =	$255E
    864  28000 ????		25 5f	    var963     =	$255F
    865  28000 ????		25 60	    var964     =	$2560
    866  28000 ????		25 61	    var965     =	$2561
    867  28000 ????		25 62	    var966     =	$2562
    868  28000 ????		25 63	    var967     =	$2563
    869  28000 ????		25 64	    var968     =	$2564
    870  28000 ????		25 65	    var969     =	$2565
    871  28000 ????		25 66	    var970     =	$2566
    872  28000 ????		25 67	    var971     =	$2567
    873  28000 ????		25 68	    var972     =	$2568
    874  28000 ????		25 69	    var973     =	$2569
    875  28000 ????		25 6a	    var974     =	$256A
    876  28000 ????		25 6b	    var975     =	$256B
    877  28000 ????		25 6c	    var976     =	$256C
    878  28000 ????		25 6d	    var977     =	$256D
    879  28000 ????		25 6e	    var978     =	$256E
    880  28000 ????		25 6f	    var979     =	$256F
    881  28000 ????		25 70	    var980     =	$2570
    882  28000 ????		25 71	    var981     =	$2571
    883  28000 ????		25 72	    var982     =	$2572
    884  28000 ????		25 73	    var983     =	$2573
    885  28000 ????		25 74	    var984     =	$2574
    886  28000 ????		25 75	    var985     =	$2575
    887  28000 ????		25 76	    var986     =	$2576
    888  28000 ????		25 77	    var987     =	$2577
    889  28000 ????		25 78	    var988     =	$2578
    890  28000 ????		25 79	    var989     =	$2579
    891  28000 ????		25 7a	    var990     =	$257A
    892  28000 ????		25 7b	    var991     =	$257B
    893  28000 ????		25 7c	    var992     =	$257C
    894  28000 ????		25 7d	    var993     =	$257D
    895  28000 ????		25 7e	    var994     =	$257E
    896  28000 ????		25 7f	    var995     =	$257F
    897  28000 ????		25 80	    var996     =	$2580
    898  28000 ????		25 81	    var997     =	$2581
    899  28000 ????		25 82	    var998     =	$2582
    900  28000 ????		25 83	    var999     =	$2583
    901  28000 ????		25 84	    var1000    =	$2584
    902  28000 ????		25 85	    var1001    =	$2585
    903  28000 ????		25 86	    var1002    =	$2586
    904  28000 ????		25 87	    var1003    =	$2587
    905  28000 ????		25 88	    var1004    =	$2588
    906  28000 ????		25 89	    var1005    =	$2589
    907  28000 ????		25 8a	    var1006    =	$258A
    908  28000 ????		25 8b	    var1007    =	$258B
    909  28000 ????		25 8c	    var1008    =	$258C
    910  28000 ????		25 8d	    var1009    =	$258D
    911  28000 ????		25 8e	    var1010    =	$258E
    912  28000 ????		25 8f	    var1011    =	$258F
    913  28000 ????		25 90	    var1012    =	$2590
    914  28000 ????		25 91	    var1013    =	$2591
    915  28000 ????		25 92	    var1014    =	$2592
    916  28000 ????		25 93	    var1015    =	$2593
    917  28000 ????		25 94	    var1016    =	$2594
    918  28000 ????		25 95	    var1017    =	$2595
    919  28000 ????		25 96	    var1018    =	$2596
    920  28000 ????		25 97	    var1019    =	$2597
    921  28000 ????		25 98	    var1020    =	$2598
    922  28000 ????		25 99	    var1021    =	$2599
    923  28000 ????		25 9a	    var1022    =	$259A
    924  28000 ????		25 9b	    var1023    =	$259B
    925  28000 ????		25 9c	    var1024    =	$259C
    926  28000 ????		25 9d	    var1025    =	$259D
    927  28000 ????		25 9e	    var1026    =	$259E
    928  28000 ????		25 9f	    var1027    =	$259F
    929  28000 ????		25 a0	    var1028    =	$25A0
    930  28000 ????		25 a1	    var1029    =	$25A1
    931  28000 ????		25 a2	    var1030    =	$25A2
    932  28000 ????		25 a3	    var1031    =	$25A3
    933  28000 ????		25 a4	    var1032    =	$25A4
    934  28000 ????		25 a5	    var1033    =	$25A5
    935  28000 ????		25 a6	    var1034    =	$25A6
    936  28000 ????		25 a7	    var1035    =	$25A7
    937  28000 ????		25 a8	    var1036    =	$25A8
    938  28000 ????		25 a9	    var1037    =	$25A9
    939  28000 ????		25 aa	    var1038    =	$25AA
    940  28000 ????		25 ab	    var1039    =	$25AB
    941  28000 ????		25 ac	    var1040    =	$25AC
    942  28000 ????		25 ad	    var1041    =	$25AD
    943  28000 ????		25 ae	    var1042    =	$25AE
    944  28000 ????		25 af	    var1043    =	$25AF
    945  28000 ????		25 b0	    var1044    =	$25B0
    946  28000 ????		25 b1	    var1045    =	$25B1
    947  28000 ????		25 b2	    var1046    =	$25B2
    948  28000 ????		25 b3	    var1047    =	$25B3
    949  28000 ????		25 b4	    var1048    =	$25B4
    950  28000 ????		25 b5	    var1049    =	$25B5
    951  28000 ????		25 b6	    var1050    =	$25B6
    952  28000 ????		25 b7	    var1051    =	$25B7
    953  28000 ????		25 b8	    var1052    =	$25B8
    954  28000 ????		25 b9	    var1053    =	$25B9
    955  28000 ????		25 ba	    var1054    =	$25BA
    956  28000 ????		25 bb	    var1055    =	$25BB
    957  28000 ????		25 bc	    var1056    =	$25BC
    958  28000 ????		25 bd	    var1057    =	$25BD
    959  28000 ????		25 be	    var1058    =	$25BE
    960  28000 ????		25 bf	    var1059    =	$25BF
    961  28000 ????		25 c0	    var1060    =	$25C0
    962  28000 ????		25 c1	    var1061    =	$25C1
    963  28000 ????		25 c2	    var1062    =	$25C2
    964  28000 ????		25 c3	    var1063    =	$25C3
    965  28000 ????		25 c4	    var1064    =	$25C4
    966  28000 ????		25 c5	    var1065    =	$25C5
    967  28000 ????		25 c6	    var1066    =	$25C6
    968  28000 ????		25 c7	    var1067    =	$25C7
    969  28000 ????		25 c8	    var1068    =	$25C8
    970  28000 ????		25 c9	    var1069    =	$25C9
    971  28000 ????		25 ca	    var1070    =	$25CA
    972  28000 ????		25 cb	    var1071    =	$25CB
    973  28000 ????		25 cc	    var1072    =	$25CC
    974  28000 ????		25 cd	    var1073    =	$25CD
    975  28000 ????		25 ce	    var1074    =	$25CE
    976  28000 ????		25 cf	    var1075    =	$25CF
    977  28000 ????		25 d0	    var1076    =	$25D0
    978  28000 ????		25 d1	    var1077    =	$25D1
    979  28000 ????		25 d2	    var1078    =	$25D2
    980  28000 ????		25 d3	    var1079    =	$25D3
    981  28000 ????		25 d4	    var1080    =	$25D4
    982  28000 ????		25 d5	    var1081    =	$25D5
    983  28000 ????		25 d6	    var1082    =	$25D6
    984  28000 ????		25 d7	    var1083    =	$25D7
    985  28000 ????		25 d8	    var1084    =	$25D8
    986  28000 ????		25 d9	    var1085    =	$25D9
    987  28000 ????		25 da	    var1086    =	$25DA
    988  28000 ????		25 db	    var1087    =	$25DB
    989  28000 ????		25 dc	    var1088    =	$25DC
    990  28000 ????		25 dd	    var1089    =	$25DD
    991  28000 ????		25 de	    var1090    =	$25DE
    992  28000 ????		25 df	    var1091    =	$25DF
    993  28000 ????		25 e0	    var1092    =	$25E0
    994  28000 ????		25 e1	    var1093    =	$25E1
    995  28000 ????		25 e2	    var1094    =	$25E2
    996  28000 ????		25 e3	    var1095    =	$25E3
    997  28000 ????		25 e4	    var1096    =	$25E4
    998  28000 ????		25 e5	    var1097    =	$25E5
    999  28000 ????		25 e6	    var1098    =	$25E6
   1000  28000 ????		25 e7	    var1099    =	$25E7
   1001  28000 ????		25 e8	    var1100    =	$25E8
   1002  28000 ????		25 e9	    var1101    =	$25E9
   1003  28000 ????		25 ea	    var1102    =	$25EA
   1004  28000 ????		25 eb	    var1103    =	$25EB
   1005  28000 ????		25 ec	    var1104    =	$25EC
   1006  28000 ????		25 ed	    var1105    =	$25ED
   1007  28000 ????		25 ee	    var1106    =	$25EE
   1008  28000 ????		25 ef	    var1107    =	$25EF
   1009  28000 ????		25 f0	    var1108    =	$25F0
   1010  28000 ????		25 f1	    var1109    =	$25F1
   1011  28000 ????		25 f2	    var1110    =	$25F2
   1012  28000 ????		25 f3	    var1111    =	$25F3
   1013  28000 ????		25 f4	    var1112    =	$25F4
   1014  28000 ????		25 f5	    var1113    =	$25F5
   1015  28000 ????		25 f6	    var1114    =	$25F6
   1016  28000 ????		25 f7	    var1115    =	$25F7
   1017  28000 ????		25 f8	    var1116    =	$25F8
   1018  28000 ????		25 f9	    var1117    =	$25F9
   1019  28000 ????		25 fa	    var1118    =	$25FA
   1020  28000 ????		25 fb	    var1119    =	$25FB
   1021  28000 ????		25 fc	    var1120    =	$25FC
   1022  28000 ????		25 fd	    var1121    =	$25FD
   1023  28000 ????		25 fe	    var1122    =	$25FE
   1024  28000 ????		25 ff	    var1123    =	$25FF
   1025  28000 ????		26 00	    var1124    =	$2600
   1026  28000 ????		26 01	    var1125    =	$2601
   1027  28000 ????		26 02	    var1126    =	$2602
   1028  28000 ????		26 03	    var1127    =	$2603
   1029  28000 ????		26 04	    var1128    =	$2604
   1030  28000 ????		26 05	    var1129    =	$2605
   1031  28000 ????		26 06	    var1130    =	$2606
   1032  28000 ????		26 07	    var1131    =	$2607
   1033  28000 ????		26 08	    var1132    =	$2608
   1034  28000 ????		26 09	    var1133    =	$2609
   1035  28000 ????		26 0a	    var1134    =	$260A
   1036  28000 ????		26 0b	    var1135    =	$260B
   1037  28000 ????		26 0c	    var1136    =	$260C
   1038  28000 ????		26 0d	    var1137    =	$260D
   1039  28000 ????		26 0e	    var1138    =	$260E
   1040  28000 ????		26 0f	    var1139    =	$260F
   1041  28000 ????		26 10	    var1140    =	$2610
   1042  28000 ????		26 11	    var1141    =	$2611
   1043  28000 ????		26 12	    var1142    =	$2612
   1044  28000 ????		26 13	    var1143    =	$2613
   1045  28000 ????		26 14	    var1144    =	$2614
   1046  28000 ????		26 15	    var1145    =	$2615
   1047  28000 ????		26 16	    var1146    =	$2616
   1048  28000 ????		26 17	    var1147    =	$2617
   1049  28000 ????		26 18	    var1148    =	$2618
   1050  28000 ????		26 19	    var1149    =	$2619
   1051  28000 ????		26 1a	    var1150    =	$261A
   1052  28000 ????		26 1b	    var1151    =	$261B
   1053  28000 ????		26 1c	    var1152    =	$261C
   1054  28000 ????		26 1d	    var1153    =	$261D
   1055  28000 ????		26 1e	    var1154    =	$261E
   1056  28000 ????		26 1f	    var1155    =	$261F
   1057  28000 ????		26 20	    var1156    =	$2620
   1058  28000 ????		26 21	    var1157    =	$2621
   1059  28000 ????		26 22	    var1158    =	$2622
   1060  28000 ????		26 23	    var1159    =	$2623
   1061  28000 ????		26 24	    var1160    =	$2624
   1062  28000 ????		26 25	    var1161    =	$2625
   1063  28000 ????		26 26	    var1162    =	$2626
   1064  28000 ????		26 27	    var1163    =	$2627
   1065  28000 ????		26 28	    var1164    =	$2628
   1066  28000 ????		26 29	    var1165    =	$2629
   1067  28000 ????		26 2a	    var1166    =	$262A
   1068  28000 ????		26 2b	    var1167    =	$262B
   1069  28000 ????		26 2c	    var1168    =	$262C
   1070  28000 ????		26 2d	    var1169    =	$262D
   1071  28000 ????		26 2e	    var1170    =	$262E
   1072  28000 ????		26 2f	    var1171    =	$262F
   1073  28000 ????		26 30	    var1172    =	$2630
   1074  28000 ????		26 31	    var1173    =	$2631
   1075  28000 ????		26 32	    var1174    =	$2632
   1076  28000 ????		26 33	    var1175    =	$2633
   1077  28000 ????		26 34	    var1176    =	$2634
   1078  28000 ????		26 35	    var1177    =	$2635
   1079  28000 ????		26 36	    var1178    =	$2636
   1080  28000 ????		26 37	    var1179    =	$2637
   1081  28000 ????		26 38	    var1180    =	$2638
   1082  28000 ????		26 39	    var1181    =	$2639
   1083  28000 ????		26 3a	    var1182    =	$263A
   1084  28000 ????		26 3b	    var1183    =	$263B
   1085  28000 ????		26 3c	    var1184    =	$263C
   1086  28000 ????		26 3d	    var1185    =	$263D
   1087  28000 ????		26 3e	    var1186    =	$263E
   1088  28000 ????		26 3f	    var1187    =	$263F
   1089  28000 ????		26 40	    var1188    =	$2640
   1090  28000 ????		26 41	    var1189    =	$2641
   1091  28000 ????		26 42	    var1190    =	$2642
   1092  28000 ????		26 43	    var1191    =	$2643
   1093  28000 ????		26 44	    var1192    =	$2644
   1094  28000 ????		26 45	    var1193    =	$2645
   1095  28000 ????		26 46	    var1194    =	$2646
   1096  28000 ????		26 47	    var1195    =	$2647
   1097  28000 ????		26 48	    var1196    =	$2648
   1098  28000 ????		26 49	    var1197    =	$2649
   1099  28000 ????		26 4a	    var1198    =	$264A
   1100  28000 ????		26 4b	    var1199    =	$264B
   1101  28000 ????		26 4c	    var1200    =	$264C
   1102  28000 ????		26 4d	    var1201    =	$264D
   1103  28000 ????		26 4e	    var1202    =	$264E
   1104  28000 ????		26 4f	    var1203    =	$264F
   1105  28000 ????		26 50	    var1204    =	$2650
   1106  28000 ????		26 51	    var1205    =	$2651
   1107  28000 ????		26 52	    var1206    =	$2652
   1108  28000 ????		26 53	    var1207    =	$2653
   1109  28000 ????		26 54	    var1208    =	$2654
   1110  28000 ????		26 55	    var1209    =	$2655
   1111  28000 ????		26 56	    var1210    =	$2656
   1112  28000 ????		26 57	    var1211    =	$2657
   1113  28000 ????		26 58	    var1212    =	$2658
   1114  28000 ????		26 59	    var1213    =	$2659
   1115  28000 ????		26 5a	    var1214    =	$265A
   1116  28000 ????		26 5b	    var1215    =	$265B
   1117  28000 ????		26 5c	    var1216    =	$265C
   1118  28000 ????		26 5d	    var1217    =	$265D
   1119  28000 ????		26 5e	    var1218    =	$265E
   1120  28000 ????		26 5f	    var1219    =	$265F
   1121  28000 ????		26 60	    var1220    =	$2660
   1122  28000 ????		26 61	    var1221    =	$2661
   1123  28000 ????		26 62	    var1222    =	$2662
   1124  28000 ????		26 63	    var1223    =	$2663
   1125  28000 ????		26 64	    var1224    =	$2664
   1126  28000 ????		26 65	    var1225    =	$2665
   1127  28000 ????		26 66	    var1226    =	$2666
   1128  28000 ????		26 67	    var1227    =	$2667
   1129  28000 ????		26 68	    var1228    =	$2668
   1130  28000 ????		26 69	    var1229    =	$2669
   1131  28000 ????		26 6a	    var1230    =	$266A
   1132  28000 ????		26 6b	    var1231    =	$266B
   1133  28000 ????		26 6c	    var1232    =	$266C
   1134  28000 ????		26 6d	    var1233    =	$266D
   1135  28000 ????		26 6e	    var1234    =	$266E
   1136  28000 ????		26 6f	    var1235    =	$266F
   1137  28000 ????		26 70	    var1236    =	$2670
   1138  28000 ????		26 71	    var1237    =	$2671
   1139  28000 ????		26 72	    var1238    =	$2672
   1140  28000 ????		26 73	    var1239    =	$2673
   1141  28000 ????		26 74	    var1240    =	$2674
   1142  28000 ????		26 75	    var1241    =	$2675
   1143  28000 ????		26 76	    var1242    =	$2676
   1144  28000 ????		26 77	    var1243    =	$2677
   1145  28000 ????		26 78	    var1244    =	$2678
   1146  28000 ????		26 79	    var1245    =	$2679
   1147  28000 ????		26 7a	    var1246    =	$267A
   1148  28000 ????		26 7b	    var1247    =	$267B
   1149  28000 ????		26 7c	    var1248    =	$267C
   1150  28000 ????		26 7d	    var1249    =	$267D
   1151  28000 ????		26 7e	    var1250    =	$267E
   1152  28000 ????		26 7f	    var1251    =	$267F
   1153  28000 ????		26 80	    var1252    =	$2680
   1154  28000 ????		26 81	    var1253    =	$2681
   1155  28000 ????		26 82	    var1254    =	$2682
   1156  28000 ????		26 83	    var1255    =	$2683
   1157  28000 ????		26 84	    var1256    =	$2684
   1158  28000 ????		26 85	    var1257    =	$2685
   1159  28000 ????		26 86	    var1258    =	$2686
   1160  28000 ????		26 87	    var1259    =	$2687
   1161  28000 ????		26 88	    var1260    =	$2688
   1162  28000 ????		26 89	    var1261    =	$2689
   1163  28000 ????		26 8a	    var1262    =	$268A
   1164  28000 ????		26 8b	    var1263    =	$268B
   1165  28000 ????		26 8c	    var1264    =	$268C
   1166  28000 ????		26 8d	    var1265    =	$268D
   1167  28000 ????		26 8e	    var1266    =	$268E
   1168  28000 ????		26 8f	    var1267    =	$268F
   1169  28000 ????		26 90	    var1268    =	$2690
   1170  28000 ????		26 91	    var1269    =	$2691
   1171  28000 ????		26 92	    var1270    =	$2692
   1172  28000 ????		26 93	    var1271    =	$2693
   1173  28000 ????		26 94	    var1272    =	$2694
   1174  28000 ????		26 95	    var1273    =	$2695
   1175  28000 ????		26 96	    var1274    =	$2696
   1176  28000 ????		26 97	    var1275    =	$2697
   1177  28000 ????		26 98	    var1276    =	$2698
   1178  28000 ????		26 99	    var1277    =	$2699
   1179  28000 ????		26 9a	    var1278    =	$269A
   1180  28000 ????		26 9b	    var1279    =	$269B
   1181  28000 ????		26 9c	    var1280    =	$269C
   1182  28000 ????		26 9d	    var1281    =	$269D
   1183  28000 ????		26 9e	    var1282    =	$269E
   1184  28000 ????		26 9f	    var1283    =	$269F
   1185  28000 ????		26 a0	    var1284    =	$26A0
   1186  28000 ????		26 a1	    var1285    =	$26A1
   1187  28000 ????		26 a2	    var1286    =	$26A2
   1188  28000 ????		26 a3	    var1287    =	$26A3
   1189  28000 ????		26 a4	    var1288    =	$26A4
   1190  28000 ????		26 a5	    var1289    =	$26A5
   1191  28000 ????		26 a6	    var1290    =	$26A6
   1192  28000 ????		26 a7	    var1291    =	$26A7
   1193  28000 ????		26 a8	    var1292    =	$26A8
   1194  28000 ????		26 a9	    var1293    =	$26A9
   1195  28000 ????		26 aa	    var1294    =	$26AA
   1196  28000 ????		26 ab	    var1295    =	$26AB
   1197  28000 ????		26 ac	    var1296    =	$26AC
   1198  28000 ????		26 ad	    var1297    =	$26AD
   1199  28000 ????		26 ae	    var1298    =	$26AE
   1200  28000 ????		26 af	    var1299    =	$26AF
   1201  28000 ????		26 b0	    var1300    =	$26B0
   1202  28000 ????		26 b1	    var1301    =	$26B1
   1203  28000 ????		26 b2	    var1302    =	$26B2
   1204  28000 ????		26 b3	    var1303    =	$26B3
   1205  28000 ????		26 b4	    var1304    =	$26B4
   1206  28000 ????		26 b5	    var1305    =	$26B5
   1207  28000 ????		26 b6	    var1306    =	$26B6
   1208  28000 ????		26 b7	    var1307    =	$26B7
   1209  28000 ????		26 b8	    var1308    =	$26B8
   1210  28000 ????		26 b9	    var1309    =	$26B9
   1211  28000 ????		26 ba	    var1310    =	$26BA
   1212  28000 ????		26 bb	    var1311    =	$26BB
   1213  28000 ????		26 bc	    var1312    =	$26BC
   1214  28000 ????		26 bd	    var1313    =	$26BD
   1215  28000 ????		26 be	    var1314    =	$26BE
   1216  28000 ????		26 bf	    var1315    =	$26BF
   1217  28000 ????		26 c0	    var1316    =	$26C0
   1218  28000 ????		26 c1	    var1317    =	$26C1
   1219  28000 ????		26 c2	    var1318    =	$26C2
   1220  28000 ????		26 c3	    var1319    =	$26C3
   1221  28000 ????		26 c4	    var1320    =	$26C4
   1222  28000 ????		26 c5	    var1321    =	$26C5
   1223  28000 ????		26 c6	    var1322    =	$26C6
   1224  28000 ????		26 c7	    var1323    =	$26C7
   1225  28000 ????		26 c8	    var1324    =	$26C8
   1226  28000 ????		26 c9	    var1325    =	$26C9
   1227  28000 ????		26 ca	    var1326    =	$26CA
   1228  28000 ????		26 cb	    var1327    =	$26CB
   1229  28000 ????		26 cc	    var1328    =	$26CC
   1230  28000 ????		26 cd	    var1329    =	$26CD
   1231  28000 ????		26 ce	    var1330    =	$26CE
   1232  28000 ????		26 cf	    var1331    =	$26CF
   1233  28000 ????		26 d0	    var1332    =	$26D0
   1234  28000 ????		26 d1	    var1333    =	$26D1
   1235  28000 ????		26 d2	    var1334    =	$26D2
   1236  28000 ????		26 d3	    var1335    =	$26D3
   1237  28000 ????		26 d4	    var1336    =	$26D4
   1238  28000 ????		26 d5	    var1337    =	$26D5
   1239  28000 ????		26 d6	    var1338    =	$26D6
   1240  28000 ????		26 d7	    var1339    =	$26D7
   1241  28000 ????		26 d8	    var1340    =	$26D8
   1242  28000 ????		26 d9	    var1341    =	$26D9
   1243  28000 ????		26 da	    var1342    =	$26DA
   1244  28000 ????		26 db	    var1343    =	$26DB
   1245  28000 ????		26 dc	    var1344    =	$26DC
   1246  28000 ????		26 dd	    var1345    =	$26DD
   1247  28000 ????		26 de	    var1346    =	$26DE
   1248  28000 ????		26 df	    var1347    =	$26DF
   1249  28000 ????		26 e0	    var1348    =	$26E0
   1250  28000 ????		26 e1	    var1349    =	$26E1
   1251  28000 ????		26 e2	    var1350    =	$26E2
   1252  28000 ????		26 e3	    var1351    =	$26E3
   1253  28000 ????		26 e4	    var1352    =	$26E4
   1254  28000 ????		26 e5	    var1353    =	$26E5
   1255  28000 ????		26 e6	    var1354    =	$26E6
   1256  28000 ????		26 e7	    var1355    =	$26E7
   1257  28000 ????		26 e8	    var1356    =	$26E8
   1258  28000 ????		26 e9	    var1357    =	$26E9
   1259  28000 ????		26 ea	    var1358    =	$26EA
   1260  28000 ????		26 eb	    var1359    =	$26EB
   1261  28000 ????		26 ec	    var1360    =	$26EC
   1262  28000 ????		26 ed	    var1361    =	$26ED
   1263  28000 ????		26 ee	    var1362    =	$26EE
   1264  28000 ????		26 ef	    var1363    =	$26EF
   1265  28000 ????		26 f0	    var1364    =	$26F0
   1266  28000 ????		26 f1	    var1365    =	$26F1
   1267  28000 ????		26 f2	    var1366    =	$26F2
   1268  28000 ????		26 f3	    var1367    =	$26F3
   1269  28000 ????		26 f4	    var1368    =	$26F4
   1270  28000 ????		26 f5	    var1369    =	$26F5
   1271  28000 ????		26 f6	    var1370    =	$26F6
   1272  28000 ????		26 f7	    var1371    =	$26F7
   1273  28000 ????		26 f8	    var1372    =	$26F8
   1274  28000 ????		26 f9	    var1373    =	$26F9
   1275  28000 ????		26 fa	    var1374    =	$26FA
   1276  28000 ????		26 fb	    var1375    =	$26FB
   1277  28000 ????		26 fc	    var1376    =	$26FC
   1278  28000 ????		26 fd	    var1377    =	$26FD
   1279  28000 ????		26 fe	    var1378    =	$26FE
   1280  28000 ????		26 ff	    var1379    =	$26FF
   1281  28000 ????		27 00	    var1380    =	$2700
   1282  28000 ????		27 01	    var1381    =	$2701
   1283  28000 ????		27 02	    var1382    =	$2702
   1284  28000 ????		27 03	    var1383    =	$2703
   1285  28000 ????		27 04	    var1384    =	$2704
   1286  28000 ????		27 05	    var1385    =	$2705
   1287  28000 ????		27 06	    var1386    =	$2706
   1288  28000 ????		27 07	    var1387    =	$2707
   1289  28000 ????		27 08	    var1388    =	$2708
   1290  28000 ????		27 09	    var1389    =	$2709
   1291  28000 ????		27 0a	    var1390    =	$270A
   1292  28000 ????		27 0b	    var1391    =	$270B
   1293  28000 ????		27 0c	    var1392    =	$270C
   1294  28000 ????		27 0d	    var1393    =	$270D
   1295  28000 ????		27 0e	    var1394    =	$270E
   1296  28000 ????		27 0f	    var1395    =	$270F
   1297  28000 ????		27 10	    var1396    =	$2710
   1298  28000 ????		27 11	    var1397    =	$2711
   1299  28000 ????		27 12	    var1398    =	$2712
   1300  28000 ????		27 13	    var1399    =	$2713
   1301  28000 ????		27 14	    var1400    =	$2714
   1302  28000 ????		27 15	    var1401    =	$2715
   1303  28000 ????		27 16	    var1402    =	$2716
   1304  28000 ????		27 17	    var1403    =	$2717
   1305  28000 ????		27 18	    var1404    =	$2718
   1306  28000 ????		27 19	    var1405    =	$2719
   1307  28000 ????		27 1a	    var1406    =	$271A
   1308  28000 ????		27 1b	    var1407    =	$271B
   1309  28000 ????		27 1c	    var1408    =	$271C
   1310  28000 ????		27 1d	    var1409    =	$271D
   1311  28000 ????		27 1e	    var1410    =	$271E
   1312  28000 ????		27 1f	    var1411    =	$271F
   1313  28000 ????		27 20	    var1412    =	$2720
   1314  28000 ????		27 21	    var1413    =	$2721
   1315  28000 ????		27 22	    var1414    =	$2722
   1316  28000 ????		27 23	    var1415    =	$2723
   1317  28000 ????		27 24	    var1416    =	$2724
   1318  28000 ????		27 25	    var1417    =	$2725
   1319  28000 ????		27 26	    var1418    =	$2726
   1320  28000 ????		27 27	    var1419    =	$2727
   1321  28000 ????		27 28	    var1420    =	$2728
   1322  28000 ????		27 29	    var1421    =	$2729
   1323  28000 ????		27 2a	    var1422    =	$272A
   1324  28000 ????		27 2b	    var1423    =	$272B
   1325  28000 ????		27 2c	    var1424    =	$272C
   1326  28000 ????		27 2d	    var1425    =	$272D
   1327  28000 ????		27 2e	    var1426    =	$272E
   1328  28000 ????		27 2f	    var1427    =	$272F
   1329  28000 ????		27 30	    var1428    =	$2730
   1330  28000 ????		27 31	    var1429    =	$2731
   1331  28000 ????		27 32	    var1430    =	$2732
   1332  28000 ????		27 33	    var1431    =	$2733
   1333  28000 ????		27 34	    var1432    =	$2734
   1334  28000 ????		27 35	    var1433    =	$2735
   1335  28000 ????		27 36	    var1434    =	$2736
   1336  28000 ????		27 37	    var1435    =	$2737
   1337  28000 ????		27 38	    var1436    =	$2738
   1338  28000 ????		27 39	    var1437    =	$2739
   1339  28000 ????		27 3a	    var1438    =	$273A
   1340  28000 ????		27 3b	    var1439    =	$273B
   1341  28000 ????		27 3c	    var1440    =	$273C
   1342  28000 ????		27 3d	    var1441    =	$273D
   1343  28000 ????		27 3e	    var1442    =	$273E
   1344  28000 ????		27 3f	    var1443    =	$273F
   1345  28000 ????		27 40	    var1444    =	$2740
   1346  28000 ????		27 41	    var1445    =	$2741
   1347  28000 ????		27 42	    var1446    =	$2742
   1348  28000 ????		27 43	    var1447    =	$2743
   1349  28000 ????		27 44	    var1448    =	$2744
   1350  28000 ????		27 45	    var1449    =	$2745
   1351  28000 ????		27 46	    var1450    =	$2746
   1352  28000 ????		27 47	    var1451    =	$2747
   1353  28000 ????		27 48	    var1452    =	$2748
   1354  28000 ????		27 49	    var1453    =	$2749
   1355  28000 ????		27 4a	    var1454    =	$274A
   1356  28000 ????		27 4b	    var1455    =	$274B
   1357  28000 ????		27 4c	    var1456    =	$274C
   1358  28000 ????		27 4d	    var1457    =	$274D
   1359  28000 ????		27 4e	    var1458    =	$274E
   1360  28000 ????		27 4f	    var1459    =	$274F
   1361  28000 ????		27 50	    var1460    =	$2750
   1362  28000 ????		27 51	    var1461    =	$2751
   1363  28000 ????		27 52	    var1462    =	$2752
   1364  28000 ????		27 53	    var1463    =	$2753
   1365  28000 ????		27 54	    var1464    =	$2754
   1366  28000 ????		27 55	    var1465    =	$2755
   1367  28000 ????		27 56	    var1466    =	$2756
   1368  28000 ????		27 57	    var1467    =	$2757
   1369  28000 ????		27 58	    var1468    =	$2758
   1370  28000 ????		27 59	    var1469    =	$2759
   1371  28000 ????		27 5a	    var1470    =	$275A
   1372  28000 ????		27 5b	    var1471    =	$275B
   1373  28000 ????		27 5c	    var1472    =	$275C
   1374  28000 ????		27 5d	    var1473    =	$275D
   1375  28000 ????		27 5e	    var1474    =	$275E
   1376  28000 ????		27 5f	    var1475    =	$275F
   1377  28000 ????		27 60	    var1476    =	$2760
   1378  28000 ????		27 61	    var1477    =	$2761
   1379  28000 ????		27 62	    var1478    =	$2762
   1380  28000 ????		27 63	    var1479    =	$2763
   1381  28000 ????		27 64	    var1480    =	$2764
   1382  28000 ????		27 65	    var1481    =	$2765
   1383  28000 ????		27 66	    var1482    =	$2766
   1384  28000 ????		27 67	    var1483    =	$2767
   1385  28000 ????		27 68	    var1484    =	$2768
   1386  28000 ????		27 69	    var1485    =	$2769
   1387  28000 ????		27 6a	    var1486    =	$276A
   1388  28000 ????		27 6b	    var1487    =	$276B
   1389  28000 ????		27 6c	    var1488    =	$276C
   1390  28000 ????		27 6d	    var1489    =	$276D
   1391  28000 ????		27 6e	    var1490    =	$276E
   1392  28000 ????		27 6f	    var1491    =	$276F
   1393  28000 ????		27 70	    var1492    =	$2770
   1394  28000 ????		27 71	    var1493    =	$2771
   1395  28000 ????		27 72	    var1494    =	$2772
   1396  28000 ????		27 73	    var1495    =	$2773
   1397  28000 ????		27 74	    var1496    =	$2774
   1398  28000 ????		27 75	    var1497    =	$2775
   1399  28000 ????		27 76	    var1498    =	$2776
   1400  28000 ????		27 77	    var1499    =	$2777
   1401  28000 ????		27 78	    var1500    =	$2778
   1402  28000 ????		27 79	    var1501    =	$2779
   1403  28000 ????		27 7a	    var1502    =	$277A
   1404  28000 ????		27 7b	    var1503    =	$277B
   1405  28000 ????		27 7c	    var1504    =	$277C
   1406  28000 ????		27 7d	    var1505    =	$277D
   1407  28000 ????		27 7e	    var1506    =	$277E
   1408  28000 ????		27 7f	    var1507    =	$277F
   1409  28000 ????		27 80	    var1508    =	$2780
   1410  28000 ????		27 81	    var1509    =	$2781
   1411  28000 ????		27 82	    var1510    =	$2782
   1412  28000 ????		27 83	    var1511    =	$2783
   1413  28000 ????		27 84	    var1512    =	$2784
   1414  28000 ????		27 85	    var1513    =	$2785
   1415  28000 ????		27 86	    var1514    =	$2786
   1416  28000 ????		27 87	    var1515    =	$2787
   1417  28000 ????		27 88	    var1516    =	$2788
   1418  28000 ????		27 89	    var1517    =	$2789
   1419  28000 ????		27 8a	    var1518    =	$278A
   1420  28000 ????		27 8b	    var1519    =	$278B
   1421  28000 ????		27 8c	    var1520    =	$278C
   1422  28000 ????		27 8d	    var1521    =	$278D
   1423  28000 ????		27 8e	    var1522    =	$278E
   1424  28000 ????		27 8f	    var1523    =	$278F
   1425  28000 ????		27 90	    var1524    =	$2790
   1426  28000 ????		27 91	    var1525    =	$2791
   1427  28000 ????		27 92	    var1526    =	$2792
   1428  28000 ????		27 93	    var1527    =	$2793
   1429  28000 ????		27 94	    var1528    =	$2794
   1430  28000 ????		27 95	    var1529    =	$2795
   1431  28000 ????		27 96	    var1530    =	$2796
   1432  28000 ????		27 97	    var1531    =	$2797
   1433  28000 ????		27 98	    var1532    =	$2798
   1434  28000 ????		27 99	    var1533    =	$2799
   1435  28000 ????		27 9a	    var1534    =	$279A
   1436  28000 ????		27 9b	    var1535    =	$279B
   1437  28000 ????		27 9c	    var1536    =	$279C
   1438  28000 ????		27 9d	    var1537    =	$279D
   1439  28000 ????		27 9e	    var1538    =	$279E
   1440  28000 ????		27 9f	    var1539    =	$279F
   1441  28000 ????		27 a0	    var1540    =	$27A0
   1442  28000 ????		27 a1	    var1541    =	$27A1
   1443  28000 ????		27 a2	    var1542    =	$27A2
   1444  28000 ????		27 a3	    var1543    =	$27A3
   1445  28000 ????		27 a4	    var1544    =	$27A4
   1446  28000 ????		27 a5	    var1545    =	$27A5
   1447  28000 ????		27 a6	    var1546    =	$27A6
   1448  28000 ????		27 a7	    var1547    =	$27A7
   1449  28000 ????		27 a8	    var1548    =	$27A8
   1450  28000 ????		27 a9	    var1549    =	$27A9
   1451  28000 ????		27 aa	    var1550    =	$27AA
   1452  28000 ????		27 ab	    var1551    =	$27AB
   1453  28000 ????		27 ac	    var1552    =	$27AC
   1454  28000 ????		27 ad	    var1553    =	$27AD
   1455  28000 ????		27 ae	    var1554    =	$27AE
   1456  28000 ????		27 af	    var1555    =	$27AF
   1457  28000 ????		27 b0	    var1556    =	$27B0
   1458  28000 ????		27 b1	    var1557    =	$27B1
   1459  28000 ????		27 b2	    var1558    =	$27B2
   1460  28000 ????		27 b3	    var1559    =	$27B3
   1461  28000 ????		27 b4	    var1560    =	$27B4
   1462  28000 ????		27 b5	    var1561    =	$27B5
   1463  28000 ????		27 b6	    var1562    =	$27B6
   1464  28000 ????		27 b7	    var1563    =	$27B7
   1465  28000 ????		27 b8	    var1564    =	$27B8
   1466  28000 ????		27 b9	    var1565    =	$27B9
   1467  28000 ????		27 ba	    var1566    =	$27BA
   1468  28000 ????		27 bb	    var1567    =	$27BB
   1469  28000 ????		27 bc	    var1568    =	$27BC
   1470  28000 ????		27 bd	    var1569    =	$27BD
   1471  28000 ????		27 be	    var1570    =	$27BE
   1472  28000 ????		27 bf	    var1571    =	$27BF
   1473  28000 ????		27 c0	    var1572    =	$27C0
   1474  28000 ????		27 c1	    var1573    =	$27C1
   1475  28000 ????		27 c2	    var1574    =	$27C2
   1476  28000 ????		27 c3	    var1575    =	$27C3
   1477  28000 ????		27 c4	    var1576    =	$27C4
   1478  28000 ????		27 c5	    var1577    =	$27C5
   1479  28000 ????		27 c6	    var1578    =	$27C6
   1480  28000 ????		27 c7	    var1579    =	$27C7
   1481  28000 ????		27 c8	    var1580    =	$27C8
   1482  28000 ????		27 c9	    var1581    =	$27C9
   1483  28000 ????		27 ca	    var1582    =	$27CA
   1484  28000 ????		27 cb	    var1583    =	$27CB
   1485  28000 ????		27 cc	    var1584    =	$27CC
   1486  28000 ????		27 cd	    var1585    =	$27CD
   1487  28000 ????		27 ce	    var1586    =	$27CE
   1488  28000 ????		27 cf	    var1587    =	$27CF
   1489  28000 ????		27 d0	    var1588    =	$27D0
   1490  28000 ????		27 d1	    var1589    =	$27D1
   1491  28000 ????		27 d2	    var1590    =	$27D2
   1492  28000 ????		27 d3	    var1591    =	$27D3
   1493  28000 ????		27 d4	    var1592    =	$27D4
   1494  28000 ????		27 d5	    var1593    =	$27D5
   1495  28000 ????		27 d6	    var1594    =	$27D6
   1496  28000 ????		27 d7	    var1595    =	$27D7
   1497  28000 ????		27 d8	    var1596    =	$27D8
   1498  28000 ????		27 d9	    var1597    =	$27D9
   1499  28000 ????		27 da	    var1598    =	$27DA
   1500  28000 ????		27 db	    var1599    =	$27DB
   1501  28000 ????		27 dc	    var1600    =	$27DC
   1502  28000 ????		27 dd	    var1601    =	$27DD
   1503  28000 ????		27 de	    var1602    =	$27DE
   1504  28000 ????		27 df	    var1603    =	$27DF
   1505  28000 ????		27 e0	    var1604    =	$27E0
   1506  28000 ????		27 e1	    var1605    =	$27E1
   1507  28000 ????		27 e2	    var1606    =	$27E2
   1508  28000 ????		27 e3	    var1607    =	$27E3
   1509  28000 ????		27 e4	    var1608    =	$27E4
   1510  28000 ????		27 e5	    var1609    =	$27E5
   1511  28000 ????		27 e6	    var1610    =	$27E6
   1512  28000 ????		27 e7	    var1611    =	$27E7
   1513  28000 ????		27 e8	    var1612    =	$27E8
   1514  28000 ????		27 e9	    var1613    =	$27E9
   1515  28000 ????		27 ea	    var1614    =	$27EA
   1516  28000 ????		27 eb	    var1615    =	$27EB
   1517  28000 ????		27 ec	    var1616    =	$27EC
   1518  28000 ????		27 ed	    var1617    =	$27ED
   1519  28000 ????		27 ee	    var1618    =	$27EE
   1520  28000 ????		27 ef	    var1619    =	$27EF
   1521  28000 ????		27 f0	    var1620    =	$27F0
   1522  28000 ????		27 f1	    var1621    =	$27F1
   1523  28000 ????		27 f2	    var1622    =	$27F2
   1524  28000 ????		27 f3	    var1623    =	$27F3
   1525  28000 ????		27 f4	    var1624    =	$27F4
   1526  28000 ????		27 f5	    var1625    =	$27F5
   1527  28000 ????		27 f6	    var1626    =	$27F6
   1528  28000 ????		27 f7	    var1627    =	$27F7
   1529  28000 ????		27 f8	    var1628    =	$27F8
   1530  28000 ????		27 f9	    var1629    =	$27F9
   1531  28000 ????		27 fa	    var1630    =	$27FA
   1532  28000 ????		27 fb	    var1631    =	$27FB
   1533  28000 ????		27 fc	    var1632    =	$27FC
   1534  28000 ????		27 fd	    var1633    =	$27FD
   1535  28000 ????		27 fe	    var1634    =	$27FE
   1536  28000 ????		27 ff	    var1635    =	$27FF
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   1474  28000 ????
   1475  28000 ????						; BEADHEADER... disabled for now
   1476  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
   1477  28000 ????						; For more BEAD executable info, check out the spec...
   1478  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
   1479  28000 ????
   1480  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
   1481  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
   1482  28000 ????
   1483  28000 ????
   1484  28000 ????		00 40	    BDHSC      =	%01000000
   1485  28000 ????		00 20	    BDYM       =	%00100000
   1486  28000 ????		00 10	    BDPOKEY    =	%00010000
   1487  28000 ????		00 08	    BDROF      =	%00001000
   1488  28000 ????		00 00	    BD16K      =	%00000000
   1489  28000 ????		00 01	    BD32K      =	%00000001
   1490  28000 ????		00 02	    BD48K      =	%00000010
   1491  28000 ????		00 05	    BD1800     =	%00000101
   1492  28000 ????		00 06	    BD4000     =	%00000110
   1493  28000 ????
   1494  28000 ????			   -	       ifconst	BEADHEADER
   1495  28000 ????			   -BEADHARDWARE SET	0
   1496  28000 ????			   -	       ifconst	ROM16K
   1497  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
   1498  28000 ????			   -	       endif
   1499  28000 ????			   -	       ifconst	ROM32K
   1500  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
   1501  28000 ????			   -	       endif
   1502  28000 ????			   -	       ifconst	ROM48K
   1503  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
   1504  28000 ????			   -	       endif
   1505  28000 ????			   -	       ifconst	pokeysupport
   1506  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
   1507  28000 ????			   -	       endif
   1508  28000 ????			   -	       ifconst	HSSUPPORT
   1509  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
   1510  28000 ????			   -	       endif
   1511  28000 ????				       endif
   1512  28000 ????
   1513  28000 ????						;start address of cart...
   1514  28000 ????
   1515  28000 ????			    BANK_WAS_SET SET	0
   1516  28000 ????
   1517  28000 ????			   -	       ifconst	ROM8K
   1518  28000 ????			   -	       ORG	$E000,0
   1519  28000 ????			   -BANK_WAS_SET SET	1
   1520  28000 ????				       endif		; ROM8K
   1521  28000 ????
   1522  28000 ????			   -	       ifconst	ROM16K
   1523  28000 ????			   -	       ORG	$C000,0
   1524  28000 ????			   -BANK_WAS_SET SET	1
   1525  28000 ????			   -	       ifconst	BEADHEADER
   1526  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1527  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1528  28000 ????			   -	       CLC
   1529  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1530  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1531  28000 ????			   -_SKIPDESCRIPTION
   1532  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1533  28000 ????			   -	       jmp	($FFFC)
   1534  28000 ????			   -	       endif		; BEADHEADER
   1535  28000 ????				       endif		; ROM16K
   1536  28000 ????
   1537  28000 ????			   -	       ifconst	ROM32K
   1538  28000 ????			   -	       ORG	$8000,0
   1539  28000 ????			   -BANK_WAS_SET SET	1
   1540  28000 ????			   -	       ifconst	BEADHEADER
   1541  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1542  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1543  28000 ????			   -	       CLC
   1544  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1545  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1546  28000 ????			   -_SKIPDESCRIPTION
   1547  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1548  28000 ????			   -	       jmp	($FFFC)
   1549  28000 ????			   -	       endif		; BEADHEADER
   1550  28000 ????				       endif		; ROM32K
   1551  28000 ????
   1552  28000 ????			   -	       ifconst	ROM48K
   1553  28000 ????			   -	       ORG	$4000,0
   1554  28000 ????			   -BANK_WAS_SET SET	1
   1555  28000 ????			   -	       ifconst	BEADHEADER
   1556  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1557  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
   1558  28000 ????			   -	       CLC
   1559  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1560  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1561  28000 ????			   -_SKIPDESCRIPTION
   1562  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
   1563  28000 ????			   -	       jmp	($FFFC)
   1564  28000 ????			   -	       endif		; BEADHEADER
   1565  28000 ????				       endif		; ROM48K
   1566  28000 ????
   1567  28000 ????			   -	       ifconst	ROM52K
   1568  28000 ????			   -BANK_WAS_SET SET	1
   1569  28000 ????			   -	       ORG	$3000,0
   1570  28000 ????				       endif		; ROM52K
   1571  28000 ????
   1572  28000 ????				       ifconst	bankswitchmode
   1573  28000 ????			   -	       ifconst	ROMAT4K
   1574  28000 ????			   -BANK_WAS_SET SET	1
   1575  28000 ????			   -	       ORG	$4000,0
   1576  28000 ????			   -	       RORG	$4000
   1577  28000 ????				       else		; ROMAT4K
   1578  28000 ????			    BANK_WAS_SET SET	1
   1579  8000					      ORG	$8000,0
   1580  8000					      RORG	$8000
   1581  8000					      endif
   1582  8000					      endif
   1583  8000
   1584  8000				  -	      if	BANK_WAS_SET = 0
   1585  8000				  -	      ORG	$8000,0	; default is 32K
   1586  8000					      endif
   1587  8000
   1588  8000				   START_OF_ROM SET	.
   1589  8000				   SPACEOVERFLOW SET	0
   1590  8000				  -	      ifnconst	SPACEOVERFLOWPASS
   1591  8000				  -SPACEOVERFLOWPASS SET	0
   1592  8000					      endif	SPACEOVERFLOWPASS
   1593  8000				   game
   1594  8000				   .L00 		;;  set zoneheight 16
   1595  8000
   1596  8000				   .L01 		;;  displaymode 160A
   1597  8000
   1598  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   1599  8002		       85 3c		      sta	CTRL
   1600  8004
   1601  8004		       8d 07 21 	      sta	sCTRL
   1602  8007
   1603  8007				   .L02 		;;  set plotvalueonscreen on
   1604  8007
   1605  8007				   .L03 		;;  set romsize 128kRAM
   1606  8007
   1607  8007				   .L04 		;;  set dlmemory $4000 $7FFF
   1608  8007
   1609  8007		       40 00	   DLMEMSTART =	$4000
   1610  8007		       7f ff	   DLMEMEND   =	$7FFF
   1611  8007				   .L05 		;;  doublebuffer on
   1612  8007
   1613  8007		       a9 01		      lda	#1
   1614  8009		       85 d5		      sta	doublebufferstate
   1615  800b				   .
   1616  800b							;; 
   1617  800b
   1618  800b				   .L06 		;;  incgraphic font.png 160A 
   1619  800b
   1620  800b				   .L07 		;;  characterset font
   1621  800b
   1622  800b		       a9 a0		      lda	#>font
   1623  800d		       8d 0b 21 	      sta	sCHARBASE
   1624  8010
   1625  8010		       85 34		      sta	CHARBASE
   1626  8012		       a9 60		      lda	#(font_mode | %01100000)
   1627  8014		       8d 06 21 	      sta	charactermode
   1628  8017
   1629  8017				   .L08 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
   1630  8017
   1631  8017				   .
   1632  8017							;; 
   1633  8017
   1634  8017				   .L09 		;;  rem sprites
   1635  8017
   1636  8017				   .L010		;;  incgraphic images/player1.png 160A 0 1 3 2
   1637  8017
   1638  8017				   .L011		;;  incgraphic images/player2.png 160A 0 1 3 2
   1639  8017
   1640  8017				   .L012		;;  incgraphic images/player3.png 160A 0 1 3 2
   1641  8017
   1642  8017				   .L013		;;  incgraphic images/player4.png 160A 0 1 3 2
   1643  8017
   1644  8017				   .
   1645  8017							;; 
   1646  8017
   1647  8017				   .L014		;;  incgraphic images/orb1.png 160A 0 3 2 1
   1648  8017
   1649  8017				   .L015		;;  incgraphic images/orb2.png 160A 0 3 2 1
   1650  8017
   1651  8017				   .L016		;;  incgraphic images/orb3.png 160A 0 3 2 1 
   1652  8017
   1653  8017				   .L017		;;  incgraphic images/orb4.png 160A 0 3 2 1
   1654  8017
   1655  8017				   .L018		;;  incgraphic images/orb5.png 160A 0 3 2 1 
   1656  8017
   1657  8017				   .L019		;;  incgraphic images/orb6.png 160A 0 3 2 1 
   1658  8017
   1659  8017				   .
   1660  8017							;; 
   1661  8017
   1662  8017				   .L020		;;  incgraphic images/portal1_top.png 160A 0 1 2 3 
   1663  8017
   1664  8017				   .L021		;;  incgraphic images/portal2_top.png 160A 0 1 2 3 
   1665  8017
   1666  8017				   .L022		;;  incgraphic images/portal1_bottom.png 160A 0 1 2 3 
   1667  8017
   1668  8017				   .L023		;;  incgraphic images/portal2_bottom.png 160A 0 1 2 3 
   1669  8017
   1670  8017				   .
   1671  8017							;; 
   1672  8017
   1673  8017				   .L024		;;  incgraphic images/drone1.png 160A 0 2 3 1 
   1674  8017
   1675  8017				   .L025		;;  incgraphic images/drone2.png 160A 0 3 2 1	
   1676  8017
   1677  8017				   .L026		;;  incgraphic images/drone3.png 160A 0 3 1 2	
   1678  8017
   1679  8017				   .L027		;;  incgraphic images/drone4.png 160A 0 3 2 1	   
   1680  8017
   1681  8017				   .
   1682  8017							;; 
   1683  8017
   1684  8017				   .L028		;;  incbanner	images/title.png 160B 
   1685  8017
   1686  8017				   .
   1687  8017							;; 
   1688  8017
   1689  8017				   .L029		;;  BACKGRND = $00
   1690  8017
   1691  8017		       a9 00		      lda	#$00
   1692  8019		       85 20		      sta	BACKGRND
   1693  801b				   .
   1694  801b							;; 
   1695  801b
   1696  801b				   .L030		;;  dim bgColor  =  var1
   1697  801b
   1698  801b				   .L031		;;  dim wait  =  var2
   1699  801b
   1700  801b				   .L032		;;  dim lives	=  var3
   1701  801b
   1702  801b				   .L033		;;  rem dim score = var4
   1703  801b
   1704  801b				   .L034		;;  dim playerX  = var5
   1705  801b
   1706  801b				   .L035		;;  dim playerY  =  var6
   1707  801b
   1708  801b				   .L036		;;  dim playerAnimFrame  =  var7
   1709  801b
   1710  801b				   .L037		;;  dim playerAnimWait  =  var8
   1711  801b
   1712  801b				   .
   1713  801b							;; 
   1714  801b
   1715  801b				   .L038		;;  dim tempX	= var9
   1716  801b
   1717  801b				   .L039		;;  dim tempY	=  var10
   1718  801b
   1719  801b				   .L040		;;  dim tempAnimFrame	=  var11
   1720  801b
   1721  801b				   .L041		;;  dim tempAnimWait  =  var12
   1722  801b
   1723  801b				   .L042		;;  dim tempXVelocity	=  var13
   1724  801b
   1725  801b				   .L043		;;  dim tempYVelocity	=  var14
   1726  801b
   1727  801b				   .L044		;;  dim tempCaptured  =  var15
   1728  801b
   1729  801b				   .
   1730  801b							;; 
   1731  801b
   1732  801b				   .
   1733  801b							;; 
   1734  801b
   1735  801b				   .L045		;;  dim randomSeed  =	var16
   1736  801b
   1737  801b				   .L046		;;  dim maxOrbs  =  var17
   1738  801b
   1739  801b				   .
   1740  801b							;; 
   1741  801b
   1742  801b				   .L047		;;  dim playerSpeed  = var18
   1743  801b
   1744  801b				   .L048		;;  dim level	=  var19
   1745  801b
   1746  801b				   .
   1747  801b							;; 
   1748  801b
   1749  801b				   .L049		;;  dim portalX  = var20
   1750  801b
   1751  801b				   .L050		;;  dim portalY  =  var21
   1752  801b
   1753  801b				   .L051		;;  dim portalAnimFrame  =  var22
   1754  801b
   1755  801b				   .L052		;;  dim portalAnimWait  =  var23
   1756  801b
   1757  801b				   .L053		;;  dim orbsLeft  =  var24
   1758  801b
   1759  801b				   .L054		;;  dim maxDrones  = var25
   1760  801b
   1761  801b				   .
   1762  801b							;; 
   1763  801b
   1764  801b				   .L055		;;  rem dim droneX =var26
   1765  801b
   1766  801b				   .L056		;;  rem dim droneY = var27
   1767  801b
   1768  801b				   .L057		;;  rem dim droneAnimFrame = var28
   1769  801b
   1770  801b				   .L058		;;  rem dim droneAnimWait = var29
   1771  801b
   1772  801b				   .
   1773  801b							;; 
   1774  801b
   1775  801b				   .
   1776  801b							;; 
   1777  801b
   1778  801b				   .L059		;;  bgColor  =  $00
   1779  801b
   1780  801b		       a9 00		      lda	#$00
   1781  801d		       8d 41 01 	      sta	bgColor
   1782  8020				   .L060		;;  wait  =  0
   1783  8020
   1784  8020		       a9 00		      lda	#0
   1785  8022		       8d 42 01 	      sta	wait
   1786  8025				   .L061		;;  lives  =  0
   1787  8025
   1788  8025		       a9 00		      lda	#0
   1789  8027		       8d 43 01 	      sta	lives
   1790  802a				   .L062		;;  score0  =	0
   1791  802a
   1792  802a		       a9 00		      lda	#$00
   1793  802c		       8d a8 01 	      sta	score0+2
   1794  802f		       a9 00		      lda	#$00
   1795  8031		       8d a7 01 	      sta	score0+1
   1796  8034		       a9 00		      lda	#$00
   1797  8036		       8d a6 01 	      sta	score0
   1798  8039				   .L063		;;  playerY  =  0
   1799  8039
   1800  8039		       a9 00		      lda	#0
   1801  803b		       8d 46 01 	      sta	playerY
   1802  803e				   .L064		;;  playerX  =  0
   1803  803e
   1804  803e		       a9 00		      lda	#0
   1805  8040		       8d 45 01 	      sta	playerX
   1806  8043				   .L065		;;  playerAnimFrame  =  0
   1807  8043
   1808  8043		       a9 00		      lda	#0
   1809  8045		       8d 47 01 	      sta	playerAnimFrame
   1810  8048				   .L066		;;  playerAnimWait  =	0
   1811  8048
   1812  8048		       a9 00		      lda	#0
   1813  804a		       8d 48 01 	      sta	playerAnimWait
   1814  804d				   .
   1815  804d							;; 
   1816  804d
   1817  804d				   .L067		;;  tempX  =  0
   1818  804d
   1819  804d		       a9 00		      lda	#0
   1820  804f		       8d 49 01 	      sta	tempX
   1821  8052				   .L068		;;  tempY  =  0
   1822  8052
   1823  8052		       a9 00		      lda	#0
   1824  8054		       8d 4a 01 	      sta	tempY
   1825  8057				   .L069		;;  tempAnimFrame  =  0
   1826  8057
   1827  8057		       a9 00		      lda	#0
   1828  8059		       8d 4b 01 	      sta	tempAnimFrame
   1829  805c				   .L070		;;  tempAnimWait  =  0
   1830  805c
   1831  805c		       a9 00		      lda	#0
   1832  805e		       8d 4c 01 	      sta	tempAnimWait
   1833  8061				   .L071		;;  tempXVelocity  =  0
   1834  8061
   1835  8061		       a9 00		      lda	#0
   1836  8063		       8d 4d 01 	      sta	tempXVelocity
   1837  8066				   .L072		;;  tempYVelocity  =  0
   1838  8066
   1839  8066		       a9 00		      lda	#0
   1840  8068		       8d 4e 01 	      sta	tempYVelocity
   1841  806b				   .
   1842  806b							;; 
   1843  806b
   1844  806b				   .L073		;;  randomSeed  =  1
   1845  806b
   1846  806b		       a9 01		      lda	#1
   1847  806d		       8d 50 01 	      sta	randomSeed
   1848  8070				   .L074		;;  level  =  0
   1849  8070
   1850  8070		       a9 00		      lda	#0
   1851  8072		       8d 53 01 	      sta	level
   1852  8075				   .
   1853  8075							;; 
   1854  8075
   1855  8075				   .L075		;;  rem orbs space for 32
   1856  8075
   1857  8075				   .L076		;;  dim orbX  =  $2200
   1858  8075
   1859  8075				   .L077		;;  dim orbY  =  $2220
   1860  8075
   1861  8075				   .L078		;;  dim orbXVelocity  =  $2240
   1862  8075
   1863  8075				   .L079		;;  dim orbYVelocity  =  $2260
   1864  8075
   1865  8075				   .L080		;;  dim orbAnimFrame  =  $2280
   1866  8075
   1867  8075				   .L081		;;  dim orbAnimWait  =  $22A0
   1868  8075
   1869  8075				   .L082		;;  dim orbCaptured  =  $22C0
   1870  8075
   1871  8075				   .
   1872  8075							;; 
   1873  8075
   1874  8075				   .
   1875  8075							;; 
   1876  8075
   1877  8075				   .
   1878  8075							;; 
   1879  8075
   1880  8075				   .
   1881  8075							;; 
   1882  8075
   1883  8075				   .L083		;;  BACKGRND  =  $00
   1884  8075
   1885  8075		       a9 00		      lda	#$00
   1886  8077		       85 20		      sta	BACKGRND
   1887  8079				   .
   1888  8079							;; 
   1889  8079
   1890  8079				   .setTitleColors
   1891  8079							;; setTitleColors
   1892  8079
   1893  8079				   .L084		;;  P0C1  =  title_color1
   1894  8079
   1895  8079		       a9 91		      lda	#title_color1
   1896  807b		       85 21		      sta	P0C1
   1897  807d				   .L085		;;  P0C2  =  title_color2
   1898  807d
   1899  807d		       a9 a5		      lda	#title_color2
   1900  807f		       85 22		      sta	P0C2
   1901  8081				   .L086		;;  P0C3  =  title_color3
   1902  8081
   1903  8081		       a9 a6		      lda	#title_color3
   1904  8083		       85 23		      sta	P0C3
   1905  8085				   .L087		;;  P1C1  =  title_color4
   1906  8085
   1907  8085		       a9 91		      lda	#title_color4
   1908  8087		       85 25		      sta	P1C1
   1909  8089				   .L088		;;  P1C2  =  title_color5
   1910  8089
   1911  8089		       a9 aa		      lda	#title_color5
   1912  808b		       85 26		      sta	P1C2
   1913  808d				   .L089		;;  P1C3  =  title_color6
   1914  808d
   1915  808d		       a9 92		      lda	#title_color6
   1916  808f		       85 27		      sta	P1C3
   1917  8091				   .L090		;;  P2C1  =  title_color7
   1918  8091
   1919  8091		       a9 ab		      lda	#title_color7
   1920  8093		       85 29		      sta	P2C1
   1921  8095				   .L091		;;  P2C2  =  title_color8
   1922  8095
   1923  8095		       a9 93		      lda	#title_color8
   1924  8097		       85 2a		      sta	P2C2
   1925  8099				   .L092		;;  P2C3  =  title_color9
   1926  8099
   1927  8099		       a9 a4		      lda	#title_color9
   1928  809b		       85 2b		      sta	P2C3
   1929  809d				   .L093		;;  P3C1  =  title_color10
   1930  809d
   1931  809d		       a9 a7		      lda	#title_color10
   1932  809f		       85 2d		      sta	P3C1
   1933  80a1				   .L094		;;  P3C2  =  title_color11
   1934  80a1
   1935  80a1		       a9 a9		      lda	#title_color11
   1936  80a3		       85 2e		      sta	P3C2
   1937  80a5				   .L095		;;  P3C3  =  title_color12
   1938  80a5
   1939  80a5		       a9 a8		      lda	#title_color12
   1940  80a7		       85 2f		      sta	P3C3
   1941  80a9				   .
   1942  80a9							;; 
   1943  80a9
   1944  80a9				   .
   1945  80a9							;; 
   1946  80a9
   1947  80a9				   .titleLoop
   1948  80a9							;; titleLoop
   1949  80a9
   1950  80a9				   .L096		;;  clearscreen
   1951  80a9
   1952  80a9		       20 87 f0 	      jsr	clearscreen
   1953  80ac				   .L097		;;  plotbanner title 0 32 50
   1954  80ac
   1955  80ac		       a9 00		      lda	#(0)
   1956  80ae		       85 44		      sta	temp3
   1957  80b0
   1958  80b0		       a9 20		      lda	#32
   1959  80b2		       85 45		      sta	temp4
   1960  80b4
   1961  80b4		       a9 32		      lda	#50
   1962  80b6
   1963  80b6		       85 46		      sta	temp5
   1964  80b8
   1965  80b8		       a9 c0		      lda	#(title00_mode|%01000000)
   1966  80ba		       85 47		      sta	temp6
   1967  80bc
   1968  80bc		       a9 81		      lda	#<(title00 + 0)
   1969  80be		       85 42		      sta	temp1
   1970  80c0
   1971  80c0		       a9 a0		      lda	#>(title00 + 0)
   1972  80c2		       85 43		      sta	temp2
   1973  80c4
   1974  80c4		       20 f8 f2 	      jsr	plotsprite
   1975  80c7		       18		      clc
   1976  80c8		       a9 10		      lda	#16
   1977  80ca		       65 46		      adc	temp5
   1978  80cc		       85 46		      sta	temp5
   1979  80ce		       a9 b1		      lda	#<(title01 + 0)
   1980  80d0		       85 42		      sta	temp1
   1981  80d2
   1982  80d2		       a9 a0		      lda	#>(title01 + 0)
   1983  80d4		       85 43		      sta	temp2
   1984  80d6
   1985  80d6		       20 f8 f2 	      jsr	plotsprite
   1986  80d9		       a9 10		      lda	#(0|title00_width_twoscompliment)
   1987  80db		       85 44		      sta	temp3
   1988  80dd
   1989  80dd		       a9 20		      lda	#32
   1990  80df		       18		      clc
   1991  80e0		       69 40		      adc	#64
   1992  80e2		       85 45		      sta	temp4
   1993  80e4
   1994  80e4		       a9 32		      lda	#50
   1995  80e6
   1996  80e6		       85 46		      sta	temp5
   1997  80e8
   1998  80e8		       a9 c0		      lda	#(title00_mode|%01000000)
   1999  80ea		       85 47		      sta	temp6
   2000  80ec
   2001  80ec		       a9 a1		      lda	#<(title00 + 32)
   2002  80ee		       85 42		      sta	temp1
   2003  80f0
   2004  80f0		       a9 a0		      lda	#>(title00 + 32)
   2005  80f2		       85 43		      sta	temp2
   2006  80f4
   2007  80f4		       20 f8 f2 	      jsr	plotsprite
   2008  80f7		       18		      clc
   2009  80f8		       a9 10		      lda	#16
   2010  80fa		       65 46		      adc	temp5
   2011  80fc		       85 46		      sta	temp5
   2012  80fe		       a9 d1		      lda	#<(title01 + 32)
   2013  8100		       85 42		      sta	temp1
   2014  8102
   2015  8102		       a9 a0		      lda	#>(title01 + 32)
   2016  8104		       85 43		      sta	temp2
   2017  8106
   2018  8106		       20 f8 f2 	      jsr	plotsprite
   2019  8109				   .
   2020  8109							;; 
   2021  8109
   2022  8109				   .L098		;;  plotchars 'quantum^lay^over' 3 47 6
   2023  8109
   2024  8109		       4c 1c 81 	      JMP	skipalphadata0
   2025  810c				   alphadata0
   2026  810c		       1a		      .byte.b	(<font + $1a)
   2027  810d		       1e		      .byte.b	(<font + $1e)
   2028  810e		       0a		      .byte.b	(<font + $0a)
   2029  810f		       17		      .byte.b	(<font + $17)
   2030  8110		       1d		      .byte.b	(<font + $1d)
   2031  8111		       1e		      .byte.b	(<font + $1e)
   2032  8112		       16		      .byte.b	(<font + $16)
   2033  8113		       34		      .byte.b	(<font + $34)
   2034  8114		       15		      .byte.b	(<font + $15)
   2035  8115		       0a		      .byte.b	(<font + $0a)
   2036  8116		       22		      .byte.b	(<font + $22)
   2037  8117		       34		      .byte.b	(<font + $34)
   2038  8118		       18		      .byte.b	(<font + $18)
   2039  8119		       1f		      .byte.b	(<font + $1f)
   2040  811a		       0e		      .byte.b	(<font + $0e)
   2041  811b		       1b		      .byte.b	(<font + $1b)
   2042  811c				   skipalphadata0
   2043  811c		       a9 10		      lda	#16	; width in two's complement
   2044  811e		       09 60		      ora	#96	; palette left shifted 5 bits
   2045  8120		       85 44		      sta	temp3
   2046  8122		       a9 0c		      lda	#<alphadata0
   2047  8124		       85 42		      sta	temp1
   2048  8126
   2049  8126		       a9 81		      lda	#>alphadata0
   2050  8128		       85 43		      sta	temp2
   2051  812a
   2052  812a		       a9 2f		      lda	#47
   2053  812c		       85 45		      sta	temp4
   2054  812e
   2055  812e		       a9 06		      lda	#6
   2056  8130
   2057  8130		       85 46		      sta	temp5
   2058  8132
   2059  8132		       20 bb f3 	      jsr	plotcharacters
   2060  8135				   .L099		;;  plotchars 'fire^to^start' 2 54 10
   2061  8135
   2062  8135		       4c 45 81 	      JMP	skipalphadata1
   2063  8138				   alphadata1
   2064  8138		       0f		      .byte.b	(<font + $0f)
   2065  8139		       12		      .byte.b	(<font + $12)
   2066  813a		       1b		      .byte.b	(<font + $1b)
   2067  813b		       0e		      .byte.b	(<font + $0e)
   2068  813c		       34		      .byte.b	(<font + $34)
   2069  813d		       1d		      .byte.b	(<font + $1d)
   2070  813e		       18		      .byte.b	(<font + $18)
   2071  813f		       34		      .byte.b	(<font + $34)
   2072  8140		       1c		      .byte.b	(<font + $1c)
   2073  8141		       1d		      .byte.b	(<font + $1d)
   2074  8142		       0a		      .byte.b	(<font + $0a)
   2075  8143		       1b		      .byte.b	(<font + $1b)
   2076  8144		       1d		      .byte.b	(<font + $1d)
   2077  8145				   skipalphadata1
   2078  8145		       a9 13		      lda	#19	; width in two's complement
   2079  8147		       09 40		      ora	#64	; palette left shifted 5 bits
   2080  8149		       85 44		      sta	temp3
   2081  814b		       a9 38		      lda	#<alphadata1
   2082  814d		       85 42		      sta	temp1
   2083  814f
   2084  814f		       a9 81		      lda	#>alphadata1
   2085  8151		       85 43		      sta	temp2
   2086  8153
   2087  8153		       a9 36		      lda	#54
   2088  8155		       85 45		      sta	temp4
   2089  8157
   2090  8157		       a9 0a		      lda	#10
   2091  8159
   2092  8159		       85 46		      sta	temp5
   2093  815b
   2094  815b		       20 bb f3 	      jsr	plotcharacters
   2095  815e				   .L0100		;;  if joy0fire0  ||  joy0fire1 then goto initGame
   2096  815e
   2097  815e		       2c 02 21 	      bit	sINPT1
   2098  8161		       50 03		      bvc	.skipL0100
   2099  8163				   .condpart0
   2100  8163		       4c 6b 81 	      jmp	.condpart1
   2101  8166				   .skipL0100
   2102  8166		       2c 02 21 	      bit	sINPT1
   2103  8169		       10 03		      bpl	.skip0OR
   2104  816b				   .condpart1
   2105  816b		       4c 89 81 	      jmp	.initGame
   2106  816e
   2107  816e				   .skip0OR
   2108  816e				   .
   2109  816e							;; 
   2110  816e
   2111  816e				   .L0101		;;  randomSeed  =  randomSeed	+  1
   2112  816e
   2113  816e		       20 6d f4 	      jsr	randomize
   2114  8171		       18		      CLC
   2115  8172		       69 01		      ADC	#1
   2116  8174		       8d 50 01 	      sta	randomSeed
   2117  8177				   .L0102		;;  if randomSeed  >  254 then randomSeed  =  1
   2118  8177
   2119  8177		       a9 fe		      lda	#254
   2120  8179		       cd 50 01 	      cmp	randomSeed
   2121  817c		       b0 05		      bcs	.skipL0102
   2122  817e				   .condpart2
   2123  817e		       a9 01		      lda	#1
   2124  8180		       8d 50 01 	      sta	randomSeed
   2125  8183				   .skipL0102
   2126  8183				   .
   2127  8183							;; 
   2128  8183
   2129  8183				   .L0103		;;  drawscreen
   2130  8183
   2131  8183		       20 c3 f0 	      jsr	drawscreen
   2132  8186				   .
   2133  8186							;; 
   2134  8186
   2135  8186				   .L0104		;;  goto titleLoop
   2136  8186
   2137  8186		       4c a9 80 	      jmp	.titleLoop
   2138  8189
   2139  8189				   .
   2140  8189							;; 
   2141  8189
   2142  8189				   .
   2143  8189							;; 
   2144  8189
   2145  8189				   .initGame
   2146  8189							;; initGame
   2147  8189
   2148  8189				   .
   2149  8189							;; 
   2150  8189
   2151  8189				   .L0105		;;  lives  =  3
   2152  8189
   2153  8189		       a9 03		      lda	#3
   2154  818b		       8d 43 01 	      sta	lives
   2155  818e				   .L0106		;;  score0  =	0
   2156  818e
   2157  818e		       a9 00		      lda	#$00
   2158  8190		       8d a8 01 	      sta	score0+2
   2159  8193		       a9 00		      lda	#$00
   2160  8195		       8d a7 01 	      sta	score0+1
   2161  8198		       a9 00		      lda	#$00
   2162  819a		       8d a6 01 	      sta	score0
   2163  819d				   .L0107		;;  BACKGRND = $00
   2164  819d
   2165  819d		       a9 00		      lda	#$00
   2166  819f		       85 20		      sta	BACKGRND
   2167  81a1				   .L0108		;;  playerX  =  70
   2168  81a1
   2169  81a1		       a9 46		      lda	#70
   2170  81a3		       8d 45 01 	      sta	playerX
   2171  81a6				   .L0109		;;  playerY  =  90
   2172  81a6
   2173  81a6		       a9 5a		      lda	#90
   2174  81a8		       8d 46 01 	      sta	playerY
   2175  81ab				   .L0110		;;  playerAnimFrame  =  0
   2176  81ab
   2177  81ab		       a9 00		      lda	#0
   2178  81ad		       8d 47 01 	      sta	playerAnimFrame
   2179  81b0				   .L0111		;;  playerAnimWait  =	0
   2180  81b0
   2181  81b0		       a9 00		      lda	#0
   2182  81b2		       8d 48 01 	      sta	playerAnimWait
   2183  81b5				   .L0112		;;  playerSpeed  =  2
   2184  81b5
   2185  81b5		       a9 02		      lda	#2
   2186  81b7		       8d 52 01 	      sta	playerSpeed
   2187  81ba				   .L0113		;;  level  =  0
   2188  81ba
   2189  81ba		       a9 00		      lda	#0
   2190  81bc		       8d 53 01 	      sta	level
   2191  81bf				   .
   2192  81bf							;; 
   2193  81bf
   2194  81bf				   .L0114		;;  rand  =  randomSeed
   2195  81bf
   2196  81bf		       20 6d f4 	      jsr	randomize
   2197  81c2		       85 40		      sta	rand
   2198  81c4				   .
   2199  81c4							;; 
   2200  81c4
   2201  81c4				   .L0115		;;  rem pallette 0 text
   2202  81c4
   2203  81c4				   .L0116		;;  P0C1 = $0F
   2204  81c4
   2205  81c4		       a9 0f		      lda	#$0F
   2206  81c6		       85 21		      sta	P0C1
   2207  81c8				   .L0117		;;  P0C2 = $0C
   2208  81c8
   2209  81c8		       a9 0c		      lda	#$0C
   2210  81ca		       85 22		      sta	P0C2
   2211  81cc				   .L0118		;;  P0C3 = $0A
   2212  81cc
   2213  81cc		       a9 0a		      lda	#$0A
   2214  81ce		       85 23		      sta	P0C3
   2215  81d0				   .
   2216  81d0							;; 
   2217  81d0
   2218  81d0				   .L0119		;;  rem pallette 1 player
   2219  81d0
   2220  81d0				   .L0120		;;  P1C1  =  $0D
   2221  81d0
   2222  81d0		       a9 0d		      lda	#$0D
   2223  81d2		       85 25		      sta	P1C1
   2224  81d4				   .L0121		;;  P1C2  =  $08
   2225  81d4
   2226  81d4		       a9 08		      lda	#$08
   2227  81d6		       85 26		      sta	P1C2
   2228  81d8				   .L0122		;;  P1C3  =  $33
   2229  81d8
   2230  81d8		       a9 33		      lda	#$33
   2231  81da		       85 27		      sta	P1C3
   2232  81dc				   .
   2233  81dc							;; 
   2234  81dc
   2235  81dc				   .L0123		;;  rem orb colors
   2236  81dc
   2237  81dc				   .
   2238  81dc							;; 
   2239  81dc
   2240  81dc				   .L0124		;;  P2C1  =  $92
   2241  81dc
   2242  81dc		       a9 92		      lda	#$92
   2243  81de		       85 29		      sta	P2C1
   2244  81e0				   .L0125		;;  P2C2  =  $94
   2245  81e0
   2246  81e0		       a9 94		      lda	#$94
   2247  81e2		       85 2a		      sta	P2C2
   2248  81e4				   .L0126		;;  P2C3  =  $99
   2249  81e4
   2250  81e4		       a9 99		      lda	#$99
   2251  81e6		       85 2b		      sta	P2C3
   2252  81e8				   .
   2253  81e8							;; 
   2254  81e8
   2255  81e8				   .L0127		;;  rem portal colors
   2256  81e8
   2257  81e8				   .
   2258  81e8							;; 
   2259  81e8
   2260  81e8				   .L0128		;;  P3C1  =  $55
   2261  81e8
   2262  81e8		       a9 55		      lda	#$55
   2263  81ea		       85 2d		      sta	P3C1
   2264  81ec				   .L0129		;;  P3C2  =  $63
   2265  81ec
   2266  81ec		       a9 63		      lda	#$63
   2267  81ee		       85 2e		      sta	P3C2
   2268  81f0				   .L0130		;;  P3C3  =  $60
   2269  81f0
   2270  81f0		       a9 60		      lda	#$60
   2271  81f2		       85 2f		      sta	P3C3
   2272  81f4				   .
   2273  81f4							;; 
   2274  81f4
   2275  81f4				   .
   2276  81f4							;; 
   2277  81f4
   2278  81f4				   .
   2279  81f4							;; 
   2280  81f4
   2281  81f4				   .initLevel
   2282  81f4							;; initLevel
   2283  81f4
   2284  81f4				   .L0131		;;  level  =  level  +  1
   2285  81f4
   2286  81f4		       ad 53 01 	      lda	level
   2287  81f7		       18		      CLC
   2288  81f8		       69 01		      ADC	#1
   2289  81fa		       8d 53 01 	      sta	level
   2290  81fd				   .L0132		;;  maxOrbs  =  32
   2291  81fd
   2292  81fd		       a9 20		      lda	#32
   2293  81ff		       8d 51 01 	      sta	maxOrbs
   2294  8202				   .L0133		;;  orbsLeft  =  32
   2295  8202
   2296  8202		       a9 20		      lda	#32
   2297  8204		       8d 58 01 	      sta	orbsLeft
   2298  8207				   .L0134		;;  portalX  =  64
   2299  8207
   2300  8207		       a9 40		      lda	#64
   2301  8209		       8d 54 01 	      sta	portalX
   2302  820c				   .L0135		;;  portalY  =  80
   2303  820c
   2304  820c		       a9 50		      lda	#80
   2305  820e		       8d 55 01 	      sta	portalY
   2306  8211				   .L0136		;;  gosub makeOrbs
   2307  8211
   2308  8211		       20 d3 85 	      jsr	.makeOrbs
   2309  8214
   2310  8214				   .
   2311  8214							;; 
   2312  8214
   2313  8214				   .
   2314  8214							;; 
   2315  8214
   2316  8214				   .gameLoop
   2317  8214							;; gameLoop
   2318  8214
   2319  8214				   .
   2320  8214							;; 
   2321  8214
   2322  8214				   .L0137		;;  clearscreen
   2323  8214
   2324  8214		       20 87 f0 	      jsr	clearscreen
   2325  8217				   .
   2326  8217							;; 
   2327  8217
   2328  8217				   .L0138		;;  rem *******
   2329  8217
   2330  8217				   .L0139		;;  rem * Update & Draw Orbs
   2331  8217
   2332  8217				   .L0140		;;  rem *******
   2333  8217
   2334  8217				   .
   2335  8217							;; 
   2336  8217
   2337  8217				   .L0141		;;  m	=  maxOrbs  -  1
   2338  8217
   2339  8217		       ad 51 01 	      lda	maxOrbs
   2340  821a		       38		      SEC
   2341  821b		       e9 01		      SBC	#1
   2342  821d		       85 f2		      sta	m
   2343  821f				   .L0142		;;  for i  =  0 to m
   2344  821f
   2345  821f		       a9 00		      lda	#0
   2346  8221		       85 ee		      sta	i
   2347  8223				   .L0142fori
   2348  8223				   .L0143		;;  tempCaptured  =  orbCaptured[i]
   2349  8223
   2350  8223		       a6 ee		      LDX	i
   2351  8225		       bd c0 22 	      lda	orbCaptured,x
   2352  8228		       8d 4f 01 	      sta	tempCaptured
   2353  822b				   .L0144		;;  if tempCaptured then goto _skipOrbDraw
   2354  822b
   2355  822b		       ad 4f 01 	      lda	tempCaptured
   2356  822e		       f0 03		      beq	.skipL0144
   2357  8230				   .condpart3
   2358  8230		       4c e9 82 	      jmp	._skipOrbDraw
   2359  8233
   2360  8233				   .skipL0144
   2361  8233				   .L0145		;;  tempX  =  orbX[i]
   2362  8233
   2363  8233		       a6 ee		      LDX	i
   2364  8235		       bd 00 22 	      lda	orbX,x
   2365  8238		       8d 49 01 	      sta	tempX
   2366  823b				   .L0146		;;  tempY  =  orbY[i]
   2367  823b
   2368  823b		       a6 ee		      LDX	i
   2369  823d		       bd 20 22 	      lda	orbY,x
   2370  8240		       8d 4a 01 	      sta	tempY
   2371  8243				   .L0147		;;  tempAnimFrame  =  orbAnimFrame[i]
   2372  8243
   2373  8243		       a6 ee		      LDX	i
   2374  8245		       bd 80 22 	      lda	orbAnimFrame,x
   2375  8248		       8d 4b 01 	      sta	tempAnimFrame
   2376  824b				   .L0148		;;  tempAnimWait  =  orbAnimWait[i]
   2377  824b
   2378  824b		       a6 ee		      LDX	i
   2379  824d		       bd a0 22 	      lda	orbAnimWait,x
   2380  8250		       8d 4c 01 	      sta	tempAnimWait
   2381  8253				   .L0149		;;  tempXVelocity  =  orbXVelocity[i]
   2382  8253
   2383  8253		       a6 ee		      LDX	i
   2384  8255		       bd 40 22 	      lda	orbXVelocity,x
   2385  8258		       8d 4d 01 	      sta	tempXVelocity
   2386  825b				   .L0150		;;  tempYVelocity  = orbYVelocity[i]
   2387  825b
   2388  825b		       a6 ee		      LDX	i
   2389  825d		       bd 60 22 	      lda	orbYVelocity,x
   2390  8260		       8d 4e 01 	      sta	tempYVelocity
   2391  8263				   .
   2392  8263							;; 
   2393  8263
   2394  8263				   .L0151		;;  tempX  =  tempX  +  tempXVelocity
   2395  8263
   2396  8263		       ad 49 01 	      lda	tempX
   2397  8266		       18		      CLC
   2398  8267		       6d 4d 01 	      ADC	tempXVelocity
   2399  826a		       8d 49 01 	      sta	tempX
   2400  826d				   .L0152		;;  tempY  =  tempY  +  tempYVelocity
   2401  826d
   2402  826d		       ad 4a 01 	      lda	tempY
   2403  8270		       18		      CLC
   2404  8271		       6d 4e 01 	      ADC	tempYVelocity
   2405  8274		       8d 4a 01 	      sta	tempY
   2406  8277				   .
   2407  8277							;; 
   2408  8277
   2409  8277				   .L0153		;;  plotsprite orb1 2 tempX tempY tempAnimFrame
   2410  8277
   2411  8277		       a9 45		      lda	#<orb1
   2412  8279		       a0 02		      ldy	#orb1_width
   2413  827b		       f0 07		      beq	plotspritewidthskip2
   2414  827d				   plotspritewidthloop2
   2415  827d		       18		      clc
   2416  827e		       6d 4b 01 	      adc	tempAnimFrame
   2417  8281		       88		      dey
   2418  8282		       d0 f9		      bne	plotspritewidthloop2
   2419  8284				   plotspritewidthskip2
   2420  8284		       85 42		      sta	temp1
   2421  8286
   2422  8286		       a9 a0		      lda	#>orb1
   2423  8288		       85 43		      sta	temp2
   2424  828a
   2425  828a		       a9 5e		      lda	#(64|orb1_width_twoscompliment)
   2426  828c		       85 44		      sta	temp3
   2427  828e
   2428  828e		       ad 49 01 	      lda	tempX
   2429  8291		       85 45		      sta	temp4
   2430  8293
   2431  8293		       ad 4a 01 	      lda	tempY
   2432  8296		       85 46		      sta	temp5
   2433  8298
   2434  8298		       a9 40		      lda	#(orb1_mode|%01000000)
   2435  829a		       85 47		      sta	temp6
   2436  829c
   2437  829c		       20 f8 f2 	      jsr	plotsprite
   2438  829f				   .L0154		;;  tempAnimWait  =  tempAnimWait  + 1
   2439  829f
   2440  829f		       ad 4c 01 	      lda	tempAnimWait
   2441  82a2		       18		      CLC
   2442  82a3		       69 01		      ADC	#1
   2443  82a5		       8d 4c 01 	      sta	tempAnimWait
   2444  82a8				   .L0155		;;  if tempAnimWait  >  1 then tempAnimFrame  =  tempAnimFrame  +  1  :  tempAnimWait	=  0
   2445  82a8
   2446  82a8		       a9 01		      lda	#1
   2447  82aa		       cd 4c 01 	      cmp	tempAnimWait
   2448  82ad		       b0 0e		      bcs	.skipL0155
   2449  82af				   .condpart4
   2450  82af		       ad 4b 01 	      lda	tempAnimFrame
   2451  82b2		       18		      CLC
   2452  82b3		       69 01		      ADC	#1
   2453  82b5		       8d 4b 01 	      sta	tempAnimFrame
   2454  82b8		       a9 00		      lda	#0
   2455  82ba		       8d 4c 01 	      sta	tempAnimWait
   2456  82bd				   .skipL0155
   2457  82bd				   .L0156		;;  if tempAnimFrame  >  5 then tempAnimFrame	=  0
   2458  82bd
   2459  82bd		       a9 05		      lda	#5
   2460  82bf		       cd 4b 01 	      cmp	tempAnimFrame
   2461  82c2		       b0 05		      bcs	.skipL0156
   2462  82c4				   .condpart5
   2463  82c4		       a9 00		      lda	#0
   2464  82c6		       8d 4b 01 	      sta	tempAnimFrame
   2465  82c9				   .skipL0156
   2466  82c9				   .L0157		;;  orbX[i]  =  tempX
   2467  82c9
   2468  82c9		       ad 49 01 	      lda	tempX
   2469  82cc		       a6 ee		      LDX	i
   2470  82ce		       9d 00 22 	      sta	orbX,x
   2471  82d1				   .L0158		;;  orbY[i]  =  tempY
   2472  82d1
   2473  82d1		       ad 4a 01 	      lda	tempY
   2474  82d4		       a6 ee		      LDX	i
   2475  82d6		       9d 20 22 	      sta	orbY,x
   2476  82d9				   .L0159		;;  orbAnimFrame[i]  =  tempAnimFrame
   2477  82d9
   2478  82d9		       ad 4b 01 	      lda	tempAnimFrame
   2479  82dc		       a6 ee		      LDX	i
   2480  82de		       9d 80 22 	      sta	orbAnimFrame,x
   2481  82e1				   .L0160		;;  orbAnimWait[i]  =	tempAnimWait
   2482  82e1
   2483  82e1		       ad 4c 01 	      lda	tempAnimWait
   2484  82e4		       a6 ee		      LDX	i
   2485  82e6		       9d a0 22 	      sta	orbAnimWait,x
   2486  82e9				   ._skipOrbDraw
   2487  82e9							;; _skipOrbDraw
   2488  82e9
   2489  82e9				   .L0161		;;  next
   2490  82e9
   2491  82e9		       a5 ee		      lda	i
   2492  82eb		       c5 f2		      cmp	m
   2493  82ed		       e6 ee		      inc	i
   2494  82ef				  -	      if	((* - .L0142fori) < 127) && ((* - .L0142fori) > -128)
   2495  82ef				  -	      bcc	.L0142fori
   2496  82ef					      else
   2497  82ef		       b0 03		      bcs	.0skipL0142fori
   2498  82f1		       4c 23 82 	      jmp	.L0142fori
   2499  82f4				   .0skipL0142fori
   2500  82f4					      endif
   2501  82f4				   .
   2502  82f4							;; 
   2503  82f4
   2504  82f4				   .
   2505  82f4							;; 
   2506  82f4
   2507  82f4				   .
   2508  82f4							;; 
   2509  82f4
   2510  82f4				   .
   2511  82f4							;; 
   2512  82f4
   2513  82f4				   .
   2514  82f4							;; 
   2515  82f4
   2516  82f4				   .L0162		;;  plotsprite player1 1 playerX playerY playerAnimFrame
   2517  82f4
   2518  82f4		       a9 35		      lda	#<player1
   2519  82f6		       a0 04		      ldy	#player1_width
   2520  82f8		       f0 07		      beq	plotspritewidthskip3
   2521  82fa				   plotspritewidthloop3
   2522  82fa		       18		      clc
   2523  82fb		       6d 47 01 	      adc	playerAnimFrame
   2524  82fe		       88		      dey
   2525  82ff		       d0 f9		      bne	plotspritewidthloop3
   2526  8301				   plotspritewidthskip3
   2527  8301		       85 42		      sta	temp1
   2528  8303
   2529  8303		       a9 a0		      lda	#>player1
   2530  8305		       85 43		      sta	temp2
   2531  8307
   2532  8307		       a9 3c		      lda	#(32|player1_width_twoscompliment)
   2533  8309		       85 44		      sta	temp3
   2534  830b
   2535  830b		       ad 45 01 	      lda	playerX
   2536  830e		       85 45		      sta	temp4
   2537  8310
   2538  8310		       ad 46 01 	      lda	playerY
   2539  8313		       85 46		      sta	temp5
   2540  8315
   2541  8315		       a9 40		      lda	#(player1_mode|%01000000)
   2542  8317		       85 47		      sta	temp6
   2543  8319
   2544  8319		       20 f8 f2 	      jsr	plotsprite
   2545  831c				   .L0163		;;  playerAnimWait  =	playerAnimWait	+ 1
   2546  831c
   2547  831c		       ad 48 01 	      lda	playerAnimWait
   2548  831f		       18		      CLC
   2549  8320		       69 01		      ADC	#1
   2550  8322		       8d 48 01 	      sta	playerAnimWait
   2551  8325				   .L0164		;;  if playerAnimWait	>  2 then playerAnimFrame  =  playerAnimFrame  +  1  :	playerAnimWait	=  0
   2552  8325
   2553  8325		       a9 02		      lda	#2
   2554  8327		       cd 48 01 	      cmp	playerAnimWait
   2555  832a		       b0 0e		      bcs	.skipL0164
   2556  832c				   .condpart6
   2557  832c		       ad 47 01 	      lda	playerAnimFrame
   2558  832f		       18		      CLC
   2559  8330		       69 01		      ADC	#1
   2560  8332		       8d 47 01 	      sta	playerAnimFrame
   2561  8335		       a9 00		      lda	#0
   2562  8337		       8d 48 01 	      sta	playerAnimWait
   2563  833a				   .skipL0164
   2564  833a				   .L0165		;;  if playerAnimFrame  >  3 then playerAnimFrame  =  0
   2565  833a
   2566  833a		       a9 03		      lda	#3
   2567  833c		       cd 47 01 	      cmp	playerAnimFrame
   2568  833f		       b0 05		      bcs	.skipL0165
   2569  8341				   .condpart7
   2570  8341		       a9 00		      lda	#0
   2571  8343		       8d 47 01 	      sta	playerAnimFrame
   2572  8346				   .skipL0165
   2573  8346				   .
   2574  8346							;; 
   2575  8346
   2576  8346				   .
   2577  8346							;; 
   2578  8346
   2579  8346				   .L0166		;;  if joy0left then playerX = playerX  -  playerSpeed
   2580  8346
   2581  8346		       2c 31 21 	      bit	sSWCHA
   2582  8349		       70 0a		      bvs	.skipL0166
   2583  834b				   .condpart8
   2584  834b		       ad 45 01 	      lda	playerX
   2585  834e		       38		      SEC
   2586  834f		       ed 52 01 	      SBC	playerSpeed
   2587  8352		       8d 45 01 	      sta	playerX
   2588  8355				   .skipL0166
   2589  8355				   .L0167		;;  if joy0right then playerX = playerX  +  playerSpeed
   2590  8355
   2591  8355		       2c 31 21 	      bit	sSWCHA
   2592  8358		       30 0a		      bmi	.skipL0167
   2593  835a				   .condpart9
   2594  835a		       ad 45 01 	      lda	playerX
   2595  835d		       18		      CLC
   2596  835e		       6d 52 01 	      ADC	playerSpeed
   2597  8361		       8d 45 01 	      sta	playerX
   2598  8364				   .skipL0167
   2599  8364				   .L0168		;;  if joy0up then playerY = playerY  -  playerSpeed
   2600  8364
   2601  8364		       a9 10		      lda	#$10
   2602  8366		       2c 31 21 	      bit	sSWCHA
   2603  8369		       d0 0a		      bne	.skipL0168
   2604  836b				   .condpart10
   2605  836b		       ad 46 01 	      lda	playerY
   2606  836e		       38		      SEC
   2607  836f		       ed 52 01 	      SBC	playerSpeed
   2608  8372		       8d 46 01 	      sta	playerY
   2609  8375				   .skipL0168
   2610  8375				   .L0169		;;  if joy0down then playerY = playerY  +  playerSpeed
   2611  8375
   2612  8375		       a9 20		      lda	#$20
   2613  8377		       2c 31 21 	      bit	sSWCHA
   2614  837a		       d0 0a		      bne	.skipL0169
   2615  837c				   .condpart11
   2616  837c		       ad 46 01 	      lda	playerY
   2617  837f		       18		      CLC
   2618  8380		       6d 52 01 	      ADC	playerSpeed
   2619  8383		       8d 46 01 	      sta	playerY
   2620  8386				   .skipL0169
   2621  8386				   .
   2622  8386							;; 
   2623  8386
   2624  8386				   .L0170		;;  if playerX  >  144  &&  playerX  <  160 then playerX  =  144
   2625  8386
   2626  8386		       a9 90		      lda	#144
   2627  8388		       cd 45 01 	      cmp	playerX
   2628  838b		       b0 0c		      bcs	.skipL0170
   2629  838d				   .condpart12
   2630  838d		       ad 45 01 	      lda	playerX
   2631  8390		       c9 a0		      cmp	#160
   2632  8392		       b0 05		      bcs	.skip12then
   2633  8394				   .condpart13
   2634  8394		       a9 90		      lda	#144
   2635  8396		       8d 45 01 	      sta	playerX
   2636  8399				   .skip12then
   2637  8399				   .skipL0170
   2638  8399				   .L0171		;;  if playerX  <=  255  &&  playerX  >  144 then playerX  =  0
   2639  8399
   2640  8399		       a9 ff		      lda	#255
   2641  839b		       cd 45 01 	      cmp	playerX
   2642  839e		       90 0c		      bcc	.skipL0171
   2643  83a0				   .condpart14
   2644  83a0		       a9 90		      lda	#144
   2645  83a2		       cd 45 01 	      cmp	playerX
   2646  83a5		       b0 05		      bcs	.skip14then
   2647  83a7				   .condpart15
   2648  83a7		       a9 00		      lda	#0
   2649  83a9		       8d 45 01 	      sta	playerX
   2650  83ac				   .skip14then
   2651  83ac				   .skipL0171
   2652  83ac				   .L0172		;;  if playerY  >  183  &&  playerY  <  199 then playerY  =  183
   2653  83ac
   2654  83ac		       a9 b7		      lda	#183
   2655  83ae		       cd 46 01 	      cmp	playerY
   2656  83b1		       b0 0c		      bcs	.skipL0172
   2657  83b3				   .condpart16
   2658  83b3		       ad 46 01 	      lda	playerY
   2659  83b6		       c9 c7		      cmp	#199
   2660  83b8		       b0 05		      bcs	.skip16then
   2661  83ba				   .condpart17
   2662  83ba		       a9 b7		      lda	#183
   2663  83bc		       8d 46 01 	      sta	playerY
   2664  83bf				   .skip16then
   2665  83bf				   .skipL0172
   2666  83bf				   .L0173		;;  if playerY  <=  255  &&  playerY  >  239 then playerY  =  0
   2667  83bf
   2668  83bf		       a9 ff		      lda	#255
   2669  83c1		       cd 46 01 	      cmp	playerY
   2670  83c4		       90 0c		      bcc	.skipL0173
   2671  83c6				   .condpart18
   2672  83c6		       a9 ef		      lda	#239
   2673  83c8		       cd 46 01 	      cmp	playerY
   2674  83cb		       b0 05		      bcs	.skip18then
   2675  83cd				   .condpart19
   2676  83cd		       a9 00		      lda	#0
   2677  83cf		       8d 46 01 	      sta	playerY
   2678  83d2				   .skip18then
   2679  83d2				   .skipL0173
   2680  83d2				   .
   2681  83d2							;; 
   2682  83d2
   2683  83d2				   .L0174		;;  gosub testCollisions
   2684  83d2
   2685  83d2		       20 b8 84 	      jsr	.testCollisions
   2686  83d5
   2687  83d5				   .L0175		;;  rem if maxOrbs = 0 then gosub _displayPortal
   2688  83d5
   2689  83d5				   .L0176		;;  tempX  =  portalX	+  10
   2690  83d5
   2691  83d5		       ad 54 01 	      lda	portalX
   2692  83d8		       18		      CLC
   2693  83d9		       69 0a		      ADC	#10
   2694  83db		       8d 49 01 	      sta	tempX
   2695  83de				   .L0177		;;  tempY  =  portalY	+  10
   2696  83de
   2697  83de		       ad 55 01 	      lda	portalY
   2698  83e1		       18		      CLC
   2699  83e2		       69 0a		      ADC	#10
   2700  83e4		       8d 4a 01 	      sta	tempY
   2701  83e7				   .L0178		;;  if orbsLeft  =  0 then gosub displayPortal
   2702  83e7
   2703  83e7		       ad 58 01 	      lda	orbsLeft
   2704  83ea		       c9 00		      cmp	#0
   2705  83ec		       d0 03		      bne	.skipL0178
   2706  83ee				   .condpart20
   2707  83ee		       20 46 85 	      jsr	.displayPortal
   2708  83f1
   2709  83f1				   .skipL0178
   2710  83f1				   .L0179		;;  if orbsLeft  =  0	&&  boxcollision ( playerX ,  playerY ,  13 ,  9 ,  tempX ,  tempY ,  6 ,  6 )	then goto initLevel
   2711  83f1
   2712  83f1		       ad 58 01 	      lda	orbsLeft
   2713  83f4		       c9 00		      cmp	#0
   2714  83f6		       d0 20		      bne	.skipL0179
   2715  83f8				   .condpart21
      0  83f8					      QBOXCOLLISIONCHECK	playerX,playerY,13,9,tempX,tempY,6,6
      1  83f8				   .boxx1     SET	playerX
      2  83f8				   .boxy1     SET	playerY
      3  83f8				   .boxw1     SET	13
      4  83f8				   .boxh1     SET	9
      5  83f8				   .boxx2     SET	tempX
      6  83f8				   .boxy2     SET	tempY
      7  83f8				   .boxw2     SET	6
      8  83f8				   .boxh2     SET	6
      9  83f8
     10  83f8		       ad 49 01 	      lda	.boxx2
     11  83fb		       18		      clc
     12  83fc		       69 06		      adc	#.boxw2
     13  83fe		       ed 45 01 	      sbc	.boxx1
     14  8401		       c9 12		      cmp	#.boxw1+.boxw2-1
     15  8403		       b0 0a		      bcs	.qboxcollisiondone
     16  8405
     17  8405		       ad 4a 01 	      lda	.boxy2
     18  8408		       69 06		      adc	#.boxh2
     19  840a		       ed 46 01 	      sbc	.boxy1
     20  840d		       c9 0e		      cmp	#.boxh1+.boxh2-1
     21  840f				   .qboxcollisiondone
     22  840f		       2a		      rol
     23  8410		       49 01		      eor	#1
     24  8412		       6a		      ror
   2717  8413		       90 03		      bcc	.skip21then
   2718  8415				   .condpart22
   2719  8415		       4c f4 81 	      jmp	.initLevel
   2720  8418
   2721  8418				   .skip21then
   2722  8418				   .skipL0179
   2723  8418				   .L0180		;;  plotchars 'orbs^left' 2 20 0
   2724  8418
   2725  8418		       4c 24 84 	      JMP	skipalphadata4
   2726  841b				   alphadata4
   2727  841b		       18		      .byte.b	(<font + $18)
   2728  841c		       1b		      .byte.b	(<font + $1b)
   2729  841d		       0b		      .byte.b	(<font + $0b)
   2730  841e		       1c		      .byte.b	(<font + $1c)
   2731  841f		       34		      .byte.b	(<font + $34)
   2732  8420		       15		      .byte.b	(<font + $15)
   2733  8421		       0e		      .byte.b	(<font + $0e)
   2734  8422		       0f		      .byte.b	(<font + $0f)
   2735  8423		       1d		      .byte.b	(<font + $1d)
   2736  8424				   skipalphadata4
   2737  8424		       a9 17		      lda	#23	; width in two's complement
   2738  8426		       09 40		      ora	#64	; palette left shifted 5 bits
   2739  8428		       85 44		      sta	temp3
   2740  842a		       a9 1b		      lda	#<alphadata4
   2741  842c		       85 42		      sta	temp1
   2742  842e
   2743  842e		       a9 84		      lda	#>alphadata4
   2744  8430		       85 43		      sta	temp2
   2745  8432
   2746  8432		       a9 14		      lda	#20
   2747  8434		       85 45		      sta	temp4
   2748  8436
   2749  8436		       a9 00		      lda	#0
   2750  8438
   2751  8438		       85 46		      sta	temp5
   2752  843a
   2753  843a		       20 bb f3 	      jsr	plotcharacters
   2754  843d				   .L0181		;;  k	=  converttobcd ( orbsLeft ) 
   2755  843d
   2756  843d		       ad 58 01 	      lda	orbsLeft
   2757  8440		       20 7b f4 	      jsr	converttobcd
   2758  8440		       00 01	   .calledfunction_converttobcd =	1
   2759  8443		       85 f0		      sta	k
   2760  8445				   .L0182		;;  plotvalue font 1 k 2 60 0
   2761  8445
   2762  8445		       a9 00		      lda	#<font
   2763  8447		       85 42		      sta	temp1
   2764  8449
   2765  8449		       a9 a0		      lda	#>font
   2766  844b		       85 43		      sta	temp2
   2767  844d
   2768  844d		       ad 06 21 	      lda	charactermode
   2769  8450		       85 4a		      sta	temp9
   2770  8452		       a9 60		      lda	#(font_mode | %01100000)
   2771  8454		       8d 06 21 	      sta	charactermode
   2772  8457		       a9 1e		      lda	#30	; width in two's complement
   2773  8459		       09 20		      ora	#32	; palette left shifted 5 bits
   2774  845b		       85 44		      sta	temp3
   2775  845d		       a9 3c		      lda	#60
   2776  845f		       85 45		      sta	temp4
   2777  8461
   2778  8461		       a9 00		      lda	#0
   2779  8463		       85 46		      sta	temp5
   2780  8465
   2781  8465		       a9 02		      lda	#2
   2782  8467		       85 47		      sta	temp6
   2783  8469
   2784  8469		       a9 f0		      lda	#<k
   2785  846b		       85 48		      sta	temp7
   2786  846d
   2787  846d		       a9 00		      lda	#>k
   2788  846f		       85 49		      sta	temp8
   2789  8471
   2790  8471		       20 25 f4 	      jsr	plotvalue
   2791  8471		       00 01	   USED_PLOTVALUE =	1
   2792  8474		       a5 4a		      lda	temp9
   2793  8476		       8d 06 21 	      sta	charactermode
   2794  8479				   .L0183		;;  plotvalue font 1 score0 6 124 0
   2795  8479
   2796  8479		       a9 00		      lda	#<font
   2797  847b		       85 42		      sta	temp1
   2798  847d
   2799  847d		       a9 a0		      lda	#>font
   2800  847f		       85 43		      sta	temp2
   2801  8481
   2802  8481		       ad 06 21 	      lda	charactermode
   2803  8484		       85 4a		      sta	temp9
   2804  8486		       a9 60		      lda	#(font_mode | %01100000)
   2805  8488		       8d 06 21 	      sta	charactermode
   2806  848b		       a9 1a		      lda	#26	; width in two's complement
   2807  848d		       09 20		      ora	#32	; palette left shifted 5 bits
   2808  848f		       85 44		      sta	temp3
   2809  8491		       a9 7c		      lda	#124
   2810  8493		       85 45		      sta	temp4
   2811  8495
   2812  8495		       a9 00		      lda	#0
   2813  8497		       85 46		      sta	temp5
   2814  8499
   2815  8499		       a9 06		      lda	#6
   2816  849b		       85 47		      sta	temp6
   2817  849d
   2818  849d		       a9 a6		      lda	#<score0
   2819  849f		       85 48		      sta	temp7
   2820  84a1
   2821  84a1		       a9 01		      lda	#>score0
   2822  84a3		       85 49		      sta	temp8
   2823  84a5
   2824  84a5		       20 25 f4 	      jsr	plotvalue
   2825  84a5		       00 01	   USED_PLOTVALUE =	1
   2826  84a8		       a5 4a		      lda	temp9
   2827  84aa		       8d 06 21 	      sta	charactermode
   2828  84ad				   .
   2829  84ad							;; 
   2830  84ad
   2831  84ad				   .L0184		;;  doublebuffer flip 2
   2832  84ad
   2833  84ad		       20 48 f5 	      jsr	flipdisplaybuffer
   2834  84b0		       a9 02		      lda	#2
   2835  84b2		       8d b3 01 	      sta	doublebufferminimumframetarget
   2836  84b5				   .L0185		;;  goto gameLoop
   2837  84b5
   2838  84b5		       4c 14 82 	      jmp	.gameLoop
   2839  84b8
   2840  84b8				   .
   2841  84b8							;; 
   2842  84b8
   2843  84b8				   .
   2844  84b8							;; 
   2845  84b8
   2846  84b8				   .testCollisions
   2847  84b8							;; testCollisions
   2848  84b8
   2849  84b8				   .L0186		;;  m	=  maxOrbs  -  1
   2850  84b8
   2851  84b8		       ad 51 01 	      lda	maxOrbs
   2852  84bb		       38		      SEC
   2853  84bc		       e9 01		      SBC	#1
   2854  84be		       85 f2		      sta	m
   2855  84c0				   .L0187		;;  for i  =  0 to m
   2856  84c0
   2857  84c0		       a9 00		      lda	#0
   2858  84c2		       85 ee		      sta	i
   2859  84c4				   .L0187fori
   2860  84c4				   .L0188		;;  tempCaptured  =  orbCaptured[i]
   2861  84c4
   2862  84c4		       a6 ee		      LDX	i
   2863  84c6		       bd c0 22 	      lda	orbCaptured,x
   2864  84c9		       8d 4f 01 	      sta	tempCaptured
   2865  84cc				   .L0189		;;  if tempCaptured  =  1 then goto _skipCollide
   2866  84cc
   2867  84cc		       ad 4f 01 	      lda	tempCaptured
   2868  84cf		       c9 01		      cmp	#1
   2869  84d1		       d0 03		      bne	.skipL0189
   2870  84d3				   .condpart23
   2871  84d3		       4c 34 85 	      jmp	._skipCollide
   2872  84d6
   2873  84d6				   .skipL0189
   2874  84d6				   .L0190		;;  tempX  =  orbX[i]
   2875  84d6
   2876  84d6		       a6 ee		      LDX	i
   2877  84d8		       bd 00 22 	      lda	orbX,x
   2878  84db		       8d 49 01 	      sta	tempX
   2879  84de				   .L0191		;;  tempY  =  orbY[i]
   2880  84de
   2881  84de		       a6 ee		      LDX	i
   2882  84e0		       bd 20 22 	      lda	orbY,x
   2883  84e3		       8d 4a 01 	      sta	tempY
   2884  84e6				   .L0192		;;  if boxcollision ( playerX ,  playerY ,  13 ,  9 ,	tempX ,  tempY ,  8 ,  8 )  then goto _doCollide
   2885  84e6
      0  84e6					      QBOXCOLLISIONCHECK	playerX,playerY,13,9,tempX,tempY,8,8
      1  84e6				   .boxx1     SET	playerX
      2  84e6				   .boxy1     SET	playerY
      3  84e6				   .boxw1     SET	13
      4  84e6				   .boxh1     SET	9
      5  84e6				   .boxx2     SET	tempX
      6  84e6				   .boxy2     SET	tempY
      7  84e6				   .boxw2     SET	8
      8  84e6				   .boxh2     SET	8
      9  84e6
     10  84e6		       ad 49 01 	      lda	.boxx2
     11  84e9		       18		      clc
     12  84ea		       69 08		      adc	#.boxw2
     13  84ec		       ed 45 01 	      sbc	.boxx1
     14  84ef		       c9 14		      cmp	#.boxw1+.boxw2-1
     15  84f1		       b0 0a		      bcs	.qboxcollisiondone
     16  84f3
     17  84f3		       ad 4a 01 	      lda	.boxy2
     18  84f6		       69 08		      adc	#.boxh2
     19  84f8		       ed 46 01 	      sbc	.boxy1
     20  84fb		       c9 10		      cmp	#.boxh1+.boxh2-1
     21  84fd				   .qboxcollisiondone
     22  84fd		       2a		      rol
     23  84fe		       49 01		      eor	#1
     24  8500		       6a		      ror
   2887  8501		       90 03		      bcc	.skipL0192
   2888  8503				   .condpart24
   2889  8503		       4c 09 85 	      jmp	._doCollide
   2890  8506
   2891  8506				   .skipL0192
   2892  8506				   .L0193		;;  goto _skipCollide
   2893  8506
   2894  8506		       4c 34 85 	      jmp	._skipCollide
   2895  8509
   2896  8509				   ._doCollide
   2897  8509							;; _doCollide
   2898  8509
   2899  8509				   .L0194		;;  score0  =	score0	+  10
   2900  8509
   2901  8509		       f8		      sed
   2902  850a		       18		      clc
   2903  850b		       ad a8 01 	      lda	score0+2
   2904  850e		       69 10		      adc	#$10
   2905  8510		       8d a8 01 	      sta	score0+2
   2906  8513		       ad a7 01 	      lda	score0+1
   2907  8516		       69 00		      adc	#$00
   2908  8518		       8d a7 01 	      sta	score0+1
   2909  851b		       ad a6 01 	      lda	score0
   2910  851e		       69 00		      adc	#$00
   2911  8520		       8d a6 01 	      sta	score0
   2912  8523		       d8		      cld
   2913  8524				   .L0195		;;  orbCaptured[i]  =	1
   2914  8524
   2915  8524		       a9 01		      lda	#1
   2916  8526		       a6 ee		      LDX	i
   2917  8528		       9d c0 22 	      sta	orbCaptured,x
   2918  852b				   .L0196		;;  orbsLeft  =  orbsLeft  -  1
   2919  852b
   2920  852b		       ad 58 01 	      lda	orbsLeft
   2921  852e		       38		      SEC
   2922  852f		       e9 01		      SBC	#1
   2923  8531		       8d 58 01 	      sta	orbsLeft
   2924  8534				   ._skipCollide
   2925  8534							;; _skipCollide
   2926  8534
   2927  8534				   .L0197		;;  next
   2928  8534
   2929  8534		       a5 ee		      lda	i
   2930  8536		       c5 f2		      cmp	m
   2931  8538		       e6 ee		      inc	i
   2932  853a					      if	((* - .L0187fori) < 127) && ((* - .L0187fori) > -128)
   2933  853a		       90 88		      bcc	.L0187fori
   2934  853c				  -	      else
   2935  853c				  -	      bcs	.1skipL0187fori
   2936  853c				  -	      jmp	.L0187fori
   2937  853c				  -.1skipL0187fori
   2938  853c					      endif
   2939  853c				   .
   2940  853c							;; 
   2941  853c
   2942  853c				   .L0198		;;  return
   2943  853c
   2944  853c		       ba		      tsx
   2945  853d		       bd 02 01 	      lda	$102,x
   2946  8540		       f0 01		      beq	bankswitchret6
   2947  8542		       60		      rts
   2948  8543				   bankswitchret6
   2949  8543		       4c 9b f4 	      jmp	BS_return
   2950  8546				   .
   2951  8546							;; 
   2952  8546
   2953  8546				   .displayPortal
   2954  8546							;; displayPortal
   2955  8546
   2956  8546				   .
   2957  8546							;; 
   2958  8546
   2959  8546				   .L0199		;;  tempY  =  portalY	+  16
   2960  8546
   2961  8546		       ad 55 01 	      lda	portalY
   2962  8549		       18		      CLC
   2963  854a		       69 10		      ADC	#16
   2964  854c		       8d 4a 01 	      sta	tempY
   2965  854f				   .L0200		;;  plotsprite portal1_top 3 portalX portalY portalAnimFrame
   2966  854f
   2967  854f		       a9 51		      lda	#<portal1_top
   2968  8551		       a0 08		      ldy	#portal1_top_width
   2969  8553		       f0 07		      beq	plotspritewidthskip6
   2970  8555				   plotspritewidthloop6
   2971  8555		       18		      clc
   2972  8556		       6d 56 01 	      adc	portalAnimFrame
   2973  8559		       88		      dey
   2974  855a		       d0 f9		      bne	plotspritewidthloop6
   2975  855c				   plotspritewidthskip6
   2976  855c		       85 42		      sta	temp1
   2977  855e
   2978  855e		       a9 a0		      lda	#>portal1_top
   2979  8560		       85 43		      sta	temp2
   2980  8562
   2981  8562		       a9 78		      lda	#(96|portal1_top_width_twoscompliment)
   2982  8564		       85 44		      sta	temp3
   2983  8566
   2984  8566		       ad 54 01 	      lda	portalX
   2985  8569		       85 45		      sta	temp4
   2986  856b
   2987  856b		       ad 55 01 	      lda	portalY
   2988  856e		       85 46		      sta	temp5
   2989  8570
   2990  8570		       a9 40		      lda	#(portal1_top_mode|%01000000)
   2991  8572		       85 47		      sta	temp6
   2992  8574
   2993  8574		       20 f8 f2 	      jsr	plotsprite
   2994  8577				   .L0201		;;  plotsprite portal1_bottom 3 portalX tempY portalAnimFrame
   2995  8577
   2996  8577		       a9 61		      lda	#<portal1_bottom
   2997  8579		       a0 08		      ldy	#portal1_bottom_width
   2998  857b		       f0 07		      beq	plotspritewidthskip7
   2999  857d				   plotspritewidthloop7
   3000  857d		       18		      clc
   3001  857e		       6d 56 01 	      adc	portalAnimFrame
   3002  8581		       88		      dey
   3003  8582		       d0 f9		      bne	plotspritewidthloop7
   3004  8584				   plotspritewidthskip7
   3005  8584		       85 42		      sta	temp1
   3006  8586
   3007  8586		       a9 a0		      lda	#>portal1_bottom
   3008  8588		       85 43		      sta	temp2
   3009  858a
   3010  858a		       a9 78		      lda	#(96|portal1_bottom_width_twoscompliment)
   3011  858c		       85 44		      sta	temp3
   3012  858e
   3013  858e		       ad 54 01 	      lda	portalX
   3014  8591		       85 45		      sta	temp4
   3015  8593
   3016  8593		       ad 4a 01 	      lda	tempY
   3017  8596		       85 46		      sta	temp5
   3018  8598
   3019  8598		       a9 40		      lda	#(portal1_bottom_mode|%01000000)
   3020  859a		       85 47		      sta	temp6
   3021  859c
   3022  859c		       20 f8 f2 	      jsr	plotsprite
   3023  859f				   .L0202		;;  portalAnimWait  =	portalAnimWait	+ 1
   3024  859f
   3025  859f		       ad 57 01 	      lda	portalAnimWait
   3026  85a2		       18		      CLC
   3027  85a3		       69 01		      ADC	#1
   3028  85a5		       8d 57 01 	      sta	portalAnimWait
   3029  85a8				   .L0203		;;  if portalAnimWait	>  2 then portalAnimFrame  =  portalAnimFrame  +  1  :	portalAnimWait	=  0
   3030  85a8
   3031  85a8		       a9 02		      lda	#2
   3032  85aa		       cd 57 01 	      cmp	portalAnimWait
   3033  85ad		       b0 0e		      bcs	.skipL0203
   3034  85af				   .condpart25
   3035  85af		       ad 56 01 	      lda	portalAnimFrame
   3036  85b2		       18		      CLC
   3037  85b3		       69 01		      ADC	#1
   3038  85b5		       8d 56 01 	      sta	portalAnimFrame
   3039  85b8		       a9 00		      lda	#0
   3040  85ba		       8d 57 01 	      sta	portalAnimWait
   3041  85bd				   .skipL0203
   3042  85bd				   .L0204		;;  if portalAnimFrame  >  1 then portalAnimFrame  =  0
   3043  85bd
   3044  85bd		       a9 01		      lda	#1
   3045  85bf		       cd 56 01 	      cmp	portalAnimFrame
   3046  85c2		       b0 05		      bcs	.skipL0204
   3047  85c4				   .condpart26
   3048  85c4		       a9 00		      lda	#0
   3049  85c6		       8d 56 01 	      sta	portalAnimFrame
   3050  85c9				   .skipL0204
   3051  85c9				   .
   3052  85c9							;; 
   3053  85c9
   3054  85c9				   .L0205		;;  return
   3055  85c9
   3056  85c9		       ba		      tsx
   3057  85ca		       bd 02 01 	      lda	$102,x
   3058  85cd		       f0 01		      beq	bankswitchret9
   3059  85cf		       60		      rts
   3060  85d0				   bankswitchret9
   3061  85d0		       4c 9b f4 	      jmp	BS_return
   3062  85d3				   .
   3063  85d3							;; 
   3064  85d3
   3065  85d3				   .
   3066  85d3							;; 
   3067  85d3
   3068  85d3				   .makeOrbs
   3069  85d3							;; makeOrbs
   3070  85d3
   3071  85d3				   .
   3072  85d3							;; 
   3073  85d3
   3074  85d3				   .L0206		;;  rem ************************************
   3075  85d3
   3076  85d3				   .L0207		;;  rem * fill up orbs to display
   3077  85d3
   3078  85d3				   .L0208		;;  rem ************************************
   3079  85d3
   3080  85d3				   .
   3081  85d3							;; 
   3082  85d3
   3083  85d3				   .L0209		;;  m	=  maxOrbs  -  1
   3084  85d3
   3085  85d3		       ad 51 01 	      lda	maxOrbs
   3086  85d6		       38		      SEC
   3087  85d7		       e9 01		      SBC	#1
   3088  85d9		       85 f2		      sta	m
   3089  85db				   .
   3090  85db							;; 
   3091  85db
   3092  85db				   .L0210		;;  for i  =  0 to m
   3093  85db
   3094  85db		       a9 00		      lda	#0
   3095  85dd		       85 ee		      sta	i
   3096  85df				   .L0210fori
   3097  85df				   ._getX
   3098  85df							;; _getX
   3099  85df
   3100  85df				   .L0211		;;  tempX  =  rand
   3101  85df
   3102  85df		       20 6d f4 	      jsr	randomize
   3103  85e2		       8d 49 01 	      sta	tempX
   3104  85e5				   .L0212		;;  if tempX  >  152 then goto _getX
   3105  85e5
   3106  85e5		       a9 98		      lda	#152
   3107  85e7		       cd 49 01 	      cmp	tempX
   3108  85ea		       b0 03		      bcs	.skipL0212
   3109  85ec				   .condpart27
   3110  85ec		       4c df 85 	      jmp	._getX
   3111  85ef
   3112  85ef				   .skipL0212
   3113  85ef				   ._getY
   3114  85ef							;; _getY
   3115  85ef
   3116  85ef				   .L0213		;;  tempY  =  rand
   3117  85ef
   3118  85ef		       20 6d f4 	      jsr	randomize
   3119  85f2		       8d 4a 01 	      sta	tempY
   3120  85f5				   .L0214		;;  if tempY  >  184 then goto _getY
   3121  85f5
   3122  85f5		       a9 b8		      lda	#184
   3123  85f7		       cd 4a 01 	      cmp	tempY
   3124  85fa		       b0 03		      bcs	.skipL0214
   3125  85fc				   .condpart28
   3126  85fc		       4c ef 85 	      jmp	._getY
   3127  85ff
   3128  85ff				   .skipL0214
   3129  85ff				   .L0215		;;  orbX[i]  =  tempX
   3130  85ff
   3131  85ff		       ad 49 01 	      lda	tempX
   3132  8602		       a6 ee		      LDX	i
   3133  8604		       9d 00 22 	      sta	orbX,x
   3134  8607				   .L0216		;;  orbY[i]  =  tempY
   3135  8607
   3136  8607		       ad 4a 01 	      lda	tempY
   3137  860a		       a6 ee		      LDX	i
   3138  860c		       9d 20 22 	      sta	orbY,x
   3139  860f				   .L0217		;;  r	=  rand
   3140  860f
   3141  860f		       20 6d f4 	      jsr	randomize
   3142  8612		       85 f7		      sta	r
   3143  8614				   .L0218		;;  if r  <  255 then orbXVelocity[i]	=  0  :  orbYVelocity[i]  =   - 1
   3144  8614
   3145  8614		       a5 f7		      lda	r
   3146  8616		       c9 ff		      cmp	#255
   3147  8618		       b0 0e		      bcs	.skipL0218
   3148  861a				   .condpart29
   3149  861a		       a9 00		      lda	#0
   3150  861c		       a6 ee		      LDX	i
   3151  861e		       9d 40 22 	      sta	orbXVelocity,x
   3152  8621		       a9 ff		      lda	#255
   3153  8623		       a6 ee		      LDX	i
   3154  8625		       9d 60 22 	      sta	orbYVelocity,x
   3155  8628				   .skipL0218
   3156  8628				   .L0219		;;  if r  <  228 then orbXVelocity[i]	=  1  :  orbYVelocity[i]  =   - 1
   3157  8628
   3158  8628		       a5 f7		      lda	r
   3159  862a		       c9 e4		      cmp	#228
   3160  862c		       b0 0e		      bcs	.skipL0219
   3161  862e				   .condpart30
   3162  862e		       a9 01		      lda	#1
   3163  8630		       a6 ee		      LDX	i
   3164  8632		       9d 40 22 	      sta	orbXVelocity,x
   3165  8635		       a9 ff		      lda	#255
   3166  8637		       a6 ee		      LDX	i
   3167  8639		       9d 60 22 	      sta	orbYVelocity,x
   3168  863c				   .skipL0219
   3169  863c				   .L0220		;;  if r  <  196 then orbXVelocity[i]	=  1  :  orbYVelocity[i]  =  0
   3170  863c
   3171  863c		       a5 f7		      lda	r
   3172  863e		       c9 c4		      cmp	#196
   3173  8640		       b0 0e		      bcs	.skipL0220
   3174  8642				   .condpart31
   3175  8642		       a9 01		      lda	#1
   3176  8644		       a6 ee		      LDX	i
   3177  8646		       9d 40 22 	      sta	orbXVelocity,x
   3178  8649		       a9 00		      lda	#0
   3179  864b		       a6 ee		      LDX	i
   3180  864d		       9d 60 22 	      sta	orbYVelocity,x
   3181  8650				   .skipL0220
   3182  8650				   .L0221		;;  if r  <  164 then orbXVelocity[i]	=  1  :  orbYVelocity[i]  =  1
   3183  8650
   3184  8650		       a5 f7		      lda	r
   3185  8652		       c9 a4		      cmp	#164
   3186  8654		       b0 0c		      bcs	.skipL0221
   3187  8656				   .condpart32
   3188  8656		       a9 01		      lda	#1
   3189  8658		       a6 ee		      LDX	i
   3190  865a		       9d 40 22 	      sta	orbXVelocity,x
   3191  865d		       a6 ee		      LDX	i
   3192  865f		       9d 60 22 	      sta	orbYVelocity,x
   3193  8662				   .skipL0221
   3194  8662				   .L0222		;;  if r  <  128 then orbXVelocity[i]	=  0  :  orbYVelocity[i]  =  1
   3195  8662
   3196  8662		       a5 f7		      lda	r
   3197  8664		       c9 80		      cmp	#128
   3198  8666		       b0 0e		      bcs	.skipL0222
   3199  8668				   .condpart33
   3200  8668		       a9 00		      lda	#0
   3201  866a		       a6 ee		      LDX	i
   3202  866c		       9d 40 22 	      sta	orbXVelocity,x
   3203  866f		       a9 01		      lda	#1
   3204  8671		       a6 ee		      LDX	i
   3205  8673		       9d 60 22 	      sta	orbYVelocity,x
   3206  8676				   .skipL0222
   3207  8676				   .L0223		;;  if r  <  96 then orbXVelocity[i]  =   - 1	:  orbYVelocity[i]  =  1
   3208  8676
   3209  8676		       a5 f7		      lda	r
   3210  8678		       c9 60		      cmp	#96
   3211  867a		       b0 0e		      bcs	.skipL0223
   3212  867c				   .condpart34
   3213  867c		       a9 ff		      lda	#255
   3214  867e		       a6 ee		      LDX	i
   3215  8680		       9d 40 22 	      sta	orbXVelocity,x
   3216  8683		       a9 01		      lda	#1
   3217  8685		       a6 ee		      LDX	i
   3218  8687		       9d 60 22 	      sta	orbYVelocity,x
   3219  868a				   .skipL0223
   3220  868a				   .L0224		;;  if r  <  64 then orbXVelocity[i]  =   - 1	:  orbYVelocity[i]  =  0
   3221  868a
   3222  868a		       a5 f7		      lda	r
   3223  868c		       c9 40		      cmp	#64
   3224  868e		       b0 0e		      bcs	.skipL0224
   3225  8690				   .condpart35
   3226  8690		       a9 ff		      lda	#255
   3227  8692		       a6 ee		      LDX	i
   3228  8694		       9d 40 22 	      sta	orbXVelocity,x
   3229  8697		       a9 00		      lda	#0
   3230  8699		       a6 ee		      LDX	i
   3231  869b		       9d 60 22 	      sta	orbYVelocity,x
   3232  869e				   .skipL0224
   3233  869e				   .L0225		;;  if r  <  32 then orbXVelocity[i]  =   - 1	:  orbYVelocity[i]  =	- 1
   3234  869e
   3235  869e		       a5 f7		      lda	r
   3236  86a0		       c9 20		      cmp	#32
   3237  86a2		       b0 0e		      bcs	.skipL0225
   3238  86a4				   .condpart36
   3239  86a4		       a9 ff		      lda	#255
   3240  86a6		       a6 ee		      LDX	i
   3241  86a8		       9d 40 22 	      sta	orbXVelocity,x
   3242  86ab		       a9 ff		      lda	#255
   3243  86ad		       a6 ee		      LDX	i
   3244  86af		       9d 60 22 	      sta	orbYVelocity,x
   3245  86b2				   .skipL0225
   3246  86b2				   .
   3247  86b2							;; 
   3248  86b2
   3249  86b2				   .L0226		;;  r	=  rand
   3250  86b2
   3251  86b2		       20 6d f4 	      jsr	randomize
   3252  86b5		       85 f7		      sta	r
   3253  86b7				   .
   3254  86b7							;; 
   3255  86b7
   3256  86b7				   .L0227		;;  if r  <  255 then orbAnimFrame[i]	=  0
   3257  86b7
   3258  86b7		       a5 f7		      lda	r
   3259  86b9		       c9 ff		      cmp	#255
   3260  86bb		       b0 07		      bcs	.skipL0227
   3261  86bd				   .condpart37
   3262  86bd		       a9 00		      lda	#0
   3263  86bf		       a6 ee		      LDX	i
   3264  86c1		       9d 80 22 	      sta	orbAnimFrame,x
   3265  86c4				   .skipL0227
   3266  86c4				   .L0228		;;  if r  <  213 then orbAnimFrame[i]	=  1
   3267  86c4
   3268  86c4		       a5 f7		      lda	r
   3269  86c6		       c9 d5		      cmp	#213
   3270  86c8		       b0 07		      bcs	.skipL0228
   3271  86ca				   .condpart38
   3272  86ca		       a9 01		      lda	#1
   3273  86cc		       a6 ee		      LDX	i
   3274  86ce		       9d 80 22 	      sta	orbAnimFrame,x
   3275  86d1				   .skipL0228
   3276  86d1				   .L0229		;;  if r  <  170 then orbAnimFrame[i]	=  2
   3277  86d1
   3278  86d1		       a5 f7		      lda	r
   3279  86d3		       c9 aa		      cmp	#170
   3280  86d5		       b0 07		      bcs	.skipL0229
   3281  86d7				   .condpart39
   3282  86d7		       a9 02		      lda	#2
   3283  86d9		       a6 ee		      LDX	i
   3284  86db		       9d 80 22 	      sta	orbAnimFrame,x
   3285  86de				   .skipL0229
   3286  86de				   .L0230		;;  if r  <  127 then orbAnimFrame[i]	=  3
   3287  86de
   3288  86de		       a5 f7		      lda	r
   3289  86e0		       c9 7f		      cmp	#127
   3290  86e2		       b0 07		      bcs	.skipL0230
   3291  86e4				   .condpart40
   3292  86e4		       a9 03		      lda	#3
   3293  86e6		       a6 ee		      LDX	i
   3294  86e8		       9d 80 22 	      sta	orbAnimFrame,x
   3295  86eb				   .skipL0230
   3296  86eb				   .L0231		;;  if r  <  84 then orbAnimFrame[i]  =  4
   3297  86eb
   3298  86eb		       a5 f7		      lda	r
   3299  86ed		       c9 54		      cmp	#84
   3300  86ef		       b0 07		      bcs	.skipL0231
   3301  86f1				   .condpart41
   3302  86f1		       a9 04		      lda	#4
   3303  86f3		       a6 ee		      LDX	i
   3304  86f5		       9d 80 22 	      sta	orbAnimFrame,x
   3305  86f8				   .skipL0231
   3306  86f8				   .L0232		;;  if r  <  42 then orbAnimFrame[i]  =  5
   3307  86f8
   3308  86f8		       a5 f7		      lda	r
   3309  86fa		       c9 2a		      cmp	#42
   3310  86fc		       b0 07		      bcs	.skipL0232
   3311  86fe				   .condpart42
   3312  86fe		       a9 05		      lda	#5
   3313  8700		       a6 ee		      LDX	i
   3314  8702		       9d 80 22 	      sta	orbAnimFrame,x
   3315  8705				   .skipL0232
   3316  8705				   .
   3317  8705							;; 
   3318  8705
   3319  8705				   .L0233		;;  orbAnimWait[i]  =	0
   3320  8705
   3321  8705		       a9 00		      lda	#0
   3322  8707		       a6 ee		      LDX	i
   3323  8709		       9d a0 22 	      sta	orbAnimWait,x
   3324  870c				   .L0234		;;  orbCaptured[i]  =	0
   3325  870c
   3326  870c		       a9 00		      lda	#0
   3327  870e		       a6 ee		      LDX	i
   3328  8710		       9d c0 22 	      sta	orbCaptured,x
   3329  8713				   ._orbDone
   3330  8713							;; _orbDone
   3331  8713
   3332  8713				   .L0235		;;  next
   3333  8713
   3334  8713		       a5 ee		      lda	i
   3335  8715		       c5 f2		      cmp	m
   3336  8717		       e6 ee		      inc	i
   3337  8719				  -	      if	((* - .L0210fori) < 127) && ((* - .L0210fori) > -128)
   3338  8719				  -	      bcc	.L0210fori
   3339  8719					      else
   3340  8719		       b0 03		      bcs	.2skipL0210fori
   3341  871b		       4c df 85 	      jmp	.L0210fori
   3342  871e				   .2skipL0210fori
   3343  871e					      endif
   3344  871e				   .
   3345  871e							;; 
   3346  871e
   3347  871e				   .L0236		;;  return
   3348  871e
   3349  871e		       ba		      tsx
   3350  871f		       bd 02 01 	      lda	$102,x
   3351  8722		       f0 01		      beq	bankswitchret10
   3352  8724		       60		      rts
   3353  8725				   bankswitchret10
   3354  8725		       4c 9b f4 	      jmp	BS_return
   3355  8728				   .
   3356  8728							;; 
   3357  8728
   3358  8728				   DMAHOLEEND0 SET	.
   3359  8728				   gameend
   3360  8728				   DMAHOLEEND0 SET	.
   6360 bytes of ROM space left in the main area of bank 1.
   3361  8728					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   3362  8728				  -	      if	($A000 - .) < 0
   3363  8728				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3364  8728					      endif
   3365  8728				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   3366  8728				  -	      .byte	0
   3367  8728					      endif
   3368  8728				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   3369  8728
   3370  a000					      ORG	$A000,0	; *************
   3371  a000
   3372  a000					      RORG	$A000	; *************
   3373  a000
   3374  a000		       a0 00	   font       =	$A000
   3375  a000
   3376  a000				   font
   3377  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3378  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3379  a020		       a0 35	   player1    =	$A035
   3380  a035
   3381  a035				   player1
   3382  a035		       00 00 00 00	      HEX	00000000
   3383  a035		       a0 39	   player2    =	$A039
   3384  a039
   3385  a039				   player2
   3386  a039		       00 00 00 00	      HEX	00000000
   3387  a039		       a0 3d	   player3    =	$A03D
   3388  a03d
   3389  a03d				   player3
   3390  a03d		       00 00 00 00	      HEX	00000000
   3391  a03d		       a0 41	   player4    =	$A041
   3392  a041
   3393  a041				   player4
   3394  a041		       00 00 00 00	      HEX	00000000
   3395  a041		       a0 45	   orb1       =	$A045
   3396  a045
   3397  a045				   orb1
   3398  a045		       00 00		      HEX	0000
   3399  a045		       a0 47	   orb2       =	$A047
   3400  a047
   3401  a047				   orb2
   3402  a047		       00 00		      HEX	0000
   3403  a047		       a0 49	   orb3       =	$A049
   3404  a049
   3405  a049				   orb3
   3406  a049		       00 00		      HEX	0000
   3407  a049		       a0 4b	   orb4       =	$A04B
   3408  a04b
   3409  a04b				   orb4
   3410  a04b		       00 00		      HEX	0000
   3411  a04b		       a0 4d	   orb5       =	$A04D
   3412  a04d
   3413  a04d				   orb5
   3414  a04d		       00 00		      HEX	0000
   3415  a04d		       a0 4f	   orb6       =	$A04F
   3416  a04f
   3417  a04f				   orb6
   3418  a04f		       00 00		      HEX	0000
   3419  a04f		       a0 51	   portal1_top =	$A051
   3420  a051
   3421  a051				   portal1_top
   3422  a051		       08 00 12 30*	      HEX	080012300c840103
   3423  a051		       a0 59	   portal2_top =	$A059
   3424  a059
   3425  a059				   portal2_top
   3426  a059		       c0 40 04 8c*	      HEX	c040048c32100020
   3427  a059		       a0 61	   portal1_bottom =	$A061
   3428  a061
   3429  a061				   portal1_bottom
   3430  a061		       0f 0f 0f 0f*	      HEX	0f0f0f0f0f0f0f0f
   3431  a061		       a0 69	   portal2_bottom =	$A069
   3432  a069
   3433  a069				   portal2_bottom
   3434  a069		       f0 f0 f0 f0*	      HEX	f0f0f0f0f0f0f0f0
   3435  a069		       a0 71	   drone1     =	$A071
   3436  a071
   3437  a071				   drone1
   3438  a071		       00 00 00 00	      HEX	00000000
   3439  a071		       a0 75	   drone2     =	$A075
   3440  a075
   3441  a075				   drone2
   3442  a075		       00 00 00 00	      HEX	00000000
   3443  a075		       a0 79	   drone3     =	$A079
   3444  a079
   3445  a079				   drone3
   3446  a079		       00 00 00 00	      HEX	00000000
   3447  a079		       a0 7d	   drone4     =	$A07D
   3448  a07d
   3449  a07d				   drone4
   3450  a07d		       00 00 00 00	      HEX	00000000
   3451  a07d		       a0 81	   title00    =	$A081
   3452  a081
   3453  a081				   title00
   3454  a081		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0c0000030f0f0c0000000
   3455  a0a1		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f0c0
   3456  a0a1		       a0 b1	   title01    =	$A0B1
   3457  a0b1
   3458  a0b1				   title01
   3459  a0b1		       00 00 55 55*	      HEX	0000555555555555555555550000115500555555440000000000001155555500
   3460  a0d1		       55 44 55 55*	      HEX	55445555554400000000000000005544
   3461  a0e1
   3462  a100					      ORG	$A100,0	; *************
   3463  a100
   3464  a100					      RORG	$A100	; *************
   3465  a100
   3466  a100							;font
   3467  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3468  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3469  a135							;player1
   3470  a135		       00 00 00 00	      HEX	00000000
   3471  a139							;player2
   3472  a139		       00 00 00 00	      HEX	00000000
   3473  a13d							;player3
   3474  a13d		       00 00 00 00	      HEX	00000000
   3475  a141							;player4
   3476  a141		       00 00 00 00	      HEX	00000000
   3477  a145							;orb1
   3478  a145		       00 00		      HEX	0000
   3479  a147							;orb2
   3480  a147		       00 00		      HEX	0000
   3481  a149							;orb3
   3482  a149		       00 00		      HEX	0000
   3483  a14b							;orb4
   3484  a14b		       00 00		      HEX	0000
   3485  a14d							;orb5
   3486  a14d		       00 00		      HEX	0000
   3487  a14f							;orb6
   3488  a14f		       00 00		      HEX	0000
   3489  a151							;portal1_top
   3490  a151		       c0 40 12 30*	      HEX	c04012300c840020
   3491  a159							;portal2_top
   3492  a159		       08 00 04 8f*	      HEX	0800048ff2100103
   3493  a161							;portal1_bottom
   3494  a161		       c0 00 00 00*	      HEX	c000000000000000
   3495  a169							;portal2_bottom
   3496  a169		       00 00 00 00*	      HEX	0000000000000003
   3497  a171							;drone1
   3498  a171		       00 00 00 00	      HEX	00000000
   3499  a175							;drone2
   3500  a175		       00 00 00 00	      HEX	00000000
   3501  a179							;drone3
   3502  a179		       00 00 00 00	      HEX	00000000
   3503  a17d							;drone4
   3504  a17d		       00 00 00 00	      HEX	00000000
   3505  a181							;title00
   3506  a181		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3507  a1a1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3508  a1b1							;title01
   3509  a1b1		       00 55 55 55*	      HEX	0055555555555555555555550000115500555555550000000000005555555500
   3510  a1d1		       55 44 55 55*	      HEX	55445555554400000000000000005544
   3511  a1e1
   3512  a200					      ORG	$A200,0	; *************
   3513  a200
   3514  a200					      RORG	$A200	; *************
   3515  a200
   3516  a200							;font
   3517  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3518  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3519  a235							;player1
   3520  a235		       00 00 00 00	      HEX	00000000
   3521  a239							;player2
   3522  a239		       00 00 00 00	      HEX	00000000
   3523  a23d							;player3
   3524  a23d		       00 00 00 00	      HEX	00000000
   3525  a241							;player4
   3526  a241		       00 00 00 00	      HEX	00000000
   3527  a245							;orb1
   3528  a245		       00 00		      HEX	0000
   3529  a247							;orb2
   3530  a247		       00 00		      HEX	0000
   3531  a249							;orb3
   3532  a249		       00 00		      HEX	0000
   3533  a24b							;orb4
   3534  a24b		       00 00		      HEX	0000
   3535  a24d							;orb5
   3536  a24d		       00 00		      HEX	0000
   3537  a24f							;orb6
   3538  a24f		       00 00		      HEX	0000
   3539  a251							;portal1_top
   3540  a251		       c0 40 12 3f*	      HEX	c040123ffc840020
   3541  a259							;portal2_top
   3542  a259		       08 00 04 80*	      HEX	0800048002100103
   3543  a261							;portal1_bottom
   3544  a261		       c0 a0 a0 a0*	      HEX	c0a0a0a0a0a0a0a0
   3545  a269							;portal2_bottom
   3546  a269		       0a 0a 0a 0a*	      HEX	0a0a0a0a0a0a0a03
   3547  a271							;drone1
   3548  a271		       00 00 00 00	      HEX	00000000
   3549  a275							;drone2
   3550  a275		       00 00 00 00	      HEX	00000000
   3551  a279							;drone3
   3552  a279		       00 00 00 00	      HEX	00000000
   3553  a27d							;drone4
   3554  a27d		       00 00 00 00	      HEX	00000000
   3555  a281							;title00
   3556  a281		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   3557  a2a1		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000135f5f5f
   3558  a2b1							;title01
   3559  a2b1		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3560  a2d1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3561  a2e1
   3562  a300					      ORG	$A300,0	; *************
   3563  a300
   3564  a300					      RORG	$A300	; *************
   3565  a300
   3566  a300							;font
   3567  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3568  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3569  a335							;player1
   3570  a335		       00 00 00 00	      HEX	00000000
   3571  a339							;player2
   3572  a339		       00 00 00 00	      HEX	00000000
   3573  a33d							;player3
   3574  a33d		       00 00 00 00	      HEX	00000000
   3575  a341							;player4
   3576  a341		       00 00 00 00	      HEX	00000000
   3577  a345							;orb1
   3578  a345		       00 00		      HEX	0000
   3579  a347							;orb2
   3580  a347		       00 00		      HEX	0000
   3581  a349							;orb3
   3582  a349		       00 00		      HEX	0000
   3583  a34b							;orb4
   3584  a34b		       00 00		      HEX	0000
   3585  a34d							;orb5
   3586  a34d		       00 00		      HEX	0000
   3587  a34f							;orb6
   3588  a34f		       00 00		      HEX	0000
   3589  a351							;portal1_top
   3590  a351		       08 00 12 00*	      HEX	0800120000840103
   3591  a359							;portal2_top
   3592  a359		       c0 40 04 aa*	      HEX	c04004aaaa100020
   3593  a361							;portal1_bottom
   3594  a361		       08 00 00 00*	      HEX	0800000000000003
   3595  a369							;portal2_bottom
   3596  a369		       c0 00 00 00*	      HEX	c000000000000020
   3597  a371							;drone1
   3598  a371		       00 00 00 00	      HEX	00000000
   3599  a375							;drone2
   3600  a375		       00 00 00 00	      HEX	00000000
   3601  a379							;drone3
   3602  a379		       00 00 00 00	      HEX	00000000
   3603  a37d							;drone4
   3604  a37d		       00 00 00 00	      HEX	00000000
   3605  a381							;title00
   3606  a381		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   3607  a3a1		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000005f5f5f
   3608  a3b1							;title01
   3609  a3b1		       31 f5 f5 f5*	      HEX	31f5f5f5f5f5f5f5f5f5f5f5f5c400000031f5f5f5c40000000031f5f5f5c400
   3610  a3d1		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   3611  a3e1
   3612  a400					      ORG	$A400,0	; *************
   3613  a400
   3614  a400					      RORG	$A400	; *************
   3615  a400
   3616  a400							;font
   3617  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3618  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3619  a435							;player1
   3620  a435		       00 00 00 00	      HEX	00000000
   3621  a439							;player2
   3622  a439		       00 00 00 00	      HEX	00000000
   3623  a43d							;player3
   3624  a43d		       00 00 00 00	      HEX	00000000
   3625  a441							;player4
   3626  a441		       00 00 00 00	      HEX	00000000
   3627  a445							;orb1
   3628  a445		       00 00		      HEX	0000
   3629  a447							;orb2
   3630  a447		       00 00		      HEX	0000
   3631  a449							;orb3
   3632  a449		       00 00		      HEX	0000
   3633  a44b							;orb4
   3634  a44b		       00 00		      HEX	0000
   3635  a44d							;orb5
   3636  a44d		       00 00		      HEX	0000
   3637  a44f							;orb6
   3638  a44f		       00 00		      HEX	0000
   3639  a451							;portal1_top
   3640  a451		       08 00 12 aa*	      HEX	080012aaaa840103
   3641  a459							;portal2_top
   3642  a459		       c0 40 04 00*	      HEX	c040040000100020
   3643  a461							;portal1_bottom
   3644  a461		       08 05 05 05*	      HEX	0805050505050503
   3645  a469							;portal2_bottom
   3646  a469		       c0 50 50 50*	      HEX	c050505050505020
   3647  a471							;drone1
   3648  a471		       00 00 00 00	      HEX	00000000
   3649  a475							;drone2
   3650  a475		       00 00 00 00	      HEX	00000000
   3651  a479							;drone3
   3652  a479		       00 00 00 00	      HEX	00000000
   3653  a47d							;drone4
   3654  a47d		       00 00 00 00	      HEX	00000000
   3655  a481							;title00
   3656  a481		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3657  a4a1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3658  a4b1							;title01
   3659  a4b1		       f5 f5 f5 f5*	      HEX	f5f5f5f5f5f5f5f5f5f5f5f5f5f500000031f5f5f5c40000000031f5f5f5c400
   3660  a4d1		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   3661  a4e1
   3662  a500					      ORG	$A500,0	; *************
   3663  a500
   3664  a500					      RORG	$A500	; *************
   3665  a500
   3666  a500							;font
   3667  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3668  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3669  a535							;player1
   3670  a535		       00 00 00 00	      HEX	00000000
   3671  a539							;player2
   3672  a539		       00 00 00 00	      HEX	00000000
   3673  a53d							;player3
   3674  a53d		       00 00 00 00	      HEX	00000000
   3675  a541							;player4
   3676  a541		       00 00 00 00	      HEX	00000000
   3677  a545							;orb1
   3678  a545		       00 00		      HEX	0000
   3679  a547							;orb2
   3680  a547		       00 00		      HEX	0000
   3681  a549							;orb3
   3682  a549		       00 00		      HEX	0000
   3683  a54b							;orb4
   3684  a54b		       00 00		      HEX	0000
   3685  a54d							;orb5
   3686  a54d		       00 00		      HEX	0000
   3687  a54f							;orb6
   3688  a54f		       00 00		      HEX	0000
   3689  a551							;portal1_top
   3690  a551		       c0 40 10 00*	      HEX	c040100000040020
   3691  a559							;portal2_top
   3692  a559		       08 00 05 55*	      HEX	0800055555500103
   3693  a561							;portal1_bottom
   3694  a561		       c0 40 00 00*	      HEX	c040000000000020
   3695  a569							;portal2_bottom
   3696  a569		       08 00 00 00*	      HEX	0800000000000103
   3697  a571							;drone1
   3698  a571		       00 00 00 00	      HEX	00000000
   3699  a575							;drone2
   3700  a575		       00 00 00 00	      HEX	00000000
   3701  a579							;drone3
   3702  a579		       00 00 00 00	      HEX	00000000
   3703  a57d							;drone4
   3704  a57d		       00 00 00 00	      HEX	00000000
   3705  a581							;title00
   3706  a581		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffcc33ffffcc00000000
   3707  a5a1		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   3708  a5b1							;title01
   3709  a5b1		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3710  a5d1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3711  a5e1
   3712  a600					      ORG	$A600,0	; *************
   3713  a600
   3714  a600					      RORG	$A600	; *************
   3715  a600
   3716  a600							;font
   3717  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3718  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3719  a635							;player1
   3720  a635		       00 00 00 00	      HEX	00000000
   3721  a639							;player2
   3722  a639		       00 00 00 00	      HEX	00000000
   3723  a63d							;player3
   3724  a63d		       00 00 00 00	      HEX	00000000
   3725  a641							;player4
   3726  a641		       00 00 00 00	      HEX	00000000
   3727  a645							;orb1
   3728  a645		       00 00		      HEX	0000
   3729  a647							;orb2
   3730  a647		       00 00		      HEX	0000
   3731  a649							;orb3
   3732  a649		       00 00		      HEX	0000
   3733  a64b							;orb4
   3734  a64b		       00 00		      HEX	0000
   3735  a64d							;orb5
   3736  a64d		       00 00		      HEX	0000
   3737  a64f							;orb6
   3738  a64f		       00 00		      HEX	0000
   3739  a651							;portal1_top
   3740  a651		       c0 40 15 55*	      HEX	c040155555540020
   3741  a659							;portal2_top
   3742  a659		       08 00 00 00*	      HEX	0800000000000103
   3743  a661							;portal1_bottom
   3744  a661		       c0 40 00 00*	      HEX	c040000000000020
   3745  a669							;portal2_bottom
   3746  a669		       08 00 00 00*	      HEX	0800000000000103
   3747  a671							;drone1
   3748  a671		       00 00 00 00	      HEX	00000000
   3749  a675							;drone2
   3750  a675		       00 00 00 00	      HEX	00000000
   3751  a679							;drone3
   3752  a679		       00 00 00 00	      HEX	00000000
   3753  a67d							;drone4
   3754  a67d		       00 00 00 00	      HEX	00000000
   3755  a681							;title00
   3756  a681		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffffffffffcc00000000
   3757  a6a1		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   3758  a6b1							;title01
   3759  a6b1		       aa aa aa aa*	      HEX	aaaaaaaaaa00000000aaaaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   3760  a6d1		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   3761  a6e1
   3762  a700					      ORG	$A700,0	; *************
   3763  a700
   3764  a700					      RORG	$A700	; *************
   3765  a700
   3766  a700							;font
   3767  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3768  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3769  a735							;player1
   3770  a735		       0f 57 d4 00	      HEX	0f57d400
   3771  a739							;player2
   3772  a739		       07 d5 f4 00	      HEX	07d5f400
   3773  a73d							;player3
   3774  a73d		       05 f5 7c 00	      HEX	05f57c00
   3775  a741							;player4
   3776  a741		       0d 7d 5c 00	      HEX	0d7d5c00
   3777  a745							;orb1
   3778  a745		       00 00		      HEX	0000
   3779  a747							;orb2
   3780  a747		       00 00		      HEX	0000
   3781  a749							;orb3
   3782  a749		       00 00		      HEX	0000
   3783  a74b							;orb4
   3784  a74b		       00 00		      HEX	0000
   3785  a74d							;orb5
   3786  a74d		       00 00		      HEX	0000
   3787  a74f							;orb6
   3788  a74f		       00 00		      HEX	0000
   3789  a751							;portal1_top
   3790  a751		       08 00 00 00*	      HEX	0800000000000103
   3791  a759							;portal2_top
   3792  a759		       c0 40 00 00*	      HEX	c040000000000020
   3793  a761							;portal1_bottom
   3794  a761		       08 00 00 00*	      HEX	0800000000000103
   3795  a769							;portal2_bottom
   3796  a769		       c0 40 00 00*	      HEX	c040000000000020
   3797  a771							;drone1
   3798  a771		       00 00 00 00	      HEX	00000000
   3799  a775							;drone2
   3800  a775		       00 00 00 00	      HEX	00000000
   3801  a779							;drone3
   3802  a779		       00 00 00 00	      HEX	00000000
   3803  a77d							;drone4
   3804  a77d		       00 00 00 00	      HEX	00000000
   3805  a781							;title00
   3806  a781		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3807  a7a1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3808  a7b1							;title01
   3809  a7b1		       aa aa aa aa*	      HEX	aaaaaaaa000000000000aaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   3810  a7d1		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   3811  a7e1
   3812  a800					      ORG	$A800,0	; *************
   3813  a800
   3814  a800					      RORG	$A800	; *************
   3815  a800
   3816  a800							;font
   3817  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3818  a820		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   3819  a835							;player1
   3820  a835		       15 55 55 00	      HEX	15555500
   3821  a839							;player2
   3822  a839		       15 55 55 00	      HEX	15555500
   3823  a83d							;player3
   3824  a83d		       15 55 55 00	      HEX	15555500
   3825  a841							;player4
   3826  a841		       15 55 55 00	      HEX	15555500
   3827  a845							;orb1
   3828  a845		       0b e0		      HEX	0be0
   3829  a847							;orb2
   3830  a847		       0f 70		      HEX	0f70
   3831  a849							;orb3
   3832  a849		       0e f0		      HEX	0ef0
   3833  a84b							;orb4
   3834  a84b		       0b e0		      HEX	0be0
   3835  a84d							;orb5
   3836  a84d		       0f b0		      HEX	0fb0
   3837  a84f							;orb6
   3838  a84f		       0d f0		      HEX	0df0
   3839  a851							;portal1_top
   3840  a851		       08 00 00 00*	      HEX	0800000000000103
   3841  a859							;portal2_top
   3842  a859		       c0 40 00 00*	      HEX	c040000000000020
   3843  a861							;portal1_bottom
   3844  a861		       08 00 00 00*	      HEX	0800000000000103
   3845  a869							;portal2_bottom
   3846  a869		       c0 40 00 00*	      HEX	c040000000000020
   3847  a871							;drone1
   3848  a871		       00 00 00 00	      HEX	00000000
   3849  a875							;drone2
   3850  a875		       00 00 00 00	      HEX	00000000
   3851  a879							;drone3
   3852  a879		       00 00 00 00	      HEX	00000000
   3853  a87d							;drone4
   3854  a87d		       00 00 00 00	      HEX	00000000
   3855  a881							;title00
   3856  a881		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   3857  a8a1		       00 00 af af*	      HEX	0000afafaf8c00000000000000afafaf
   3858  a8b1							;title01
   3859  a8b1		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3860  a8d1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3861  a8e1
   3862  a900					      ORG	$A900,0	; *************
   3863  a900
   3864  a900					      RORG	$A900	; *************
   3865  a900
   3866  a900							;font
   3867  a900		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   3868  a920		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   3869  a935							;player1
   3870  a935		       55 55 55 40	      HEX	55555540
   3871  a939							;player2
   3872  a939		       55 55 55 40	      HEX	55555540
   3873  a93d							;player3
   3874  a93d		       55 55 55 40	      HEX	55555540
   3875  a941							;player4
   3876  a941		       55 55 55 40	      HEX	55555540
   3877  a945							;orb1
   3878  a945		       3f fc		      HEX	3ffc
   3879  a947							;orb2
   3880  a947		       3f fc		      HEX	3ffc
   3881  a949							;orb3
   3882  a949		       3f fc		      HEX	3ffc
   3883  a94b							;orb4
   3884  a94b		       3f fc		      HEX	3ffc
   3885  a94d							;orb5
   3886  a94d		       3f fc		      HEX	3ffc
   3887  a94f							;orb6
   3888  a94f		       3f fc		      HEX	3ffc
   3889  a951							;portal1_top
   3890  a951		       c0 40 00 00*	      HEX	c040000000000020
   3891  a959							;portal2_top
   3892  a959		       08 00 00 00*	      HEX	0800000000000103
   3893  a961							;portal1_bottom
   3894  a961		       c0 40 15 55*	      HEX	c040155555540020
   3895  a969							;portal2_bottom
   3896  a969		       08 00 00 00*	      HEX	0800000000000103
   3897  a971							;drone1
   3898  a971		       00 00 00 00	      HEX	00000000
   3899  a975							;drone2
   3900  a975		       00 00 00 00	      HEX	00000000
   3901  a979							;drone3
   3902  a979		       00 00 00 00	      HEX	00000000
   3903  a97d							;drone4
   3904  a97d		       00 00 00 00	      HEX	00000000
   3905  a981							;title00
   3906  a981		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   3907  a9a1		       00 00 af af*	      HEX	0000afafaf8c00000000000023afafaf
   3908  a9b1							;title01
   3909  a9b1		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafac8000032fafafac80000
   3910  a9d1		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   3911  a9e1
   3912  aa00					      ORG	$AA00,0	; *************
   3913  aa00
   3914  aa00					      RORG	$AA00	; *************
   3915  aa00
   3916  aa00							;font
   3917  aa00		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   3918  aa20		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   3919  aa35							;player1
   3920  aa35		       00 00 00 00	      HEX	00000000
   3921  aa39							;player2
   3922  aa39		       00 00 00 00	      HEX	00000000
   3923  aa3d							;player3
   3924  aa3d		       a8 2a 0a 80	      HEX	a82a0a80
   3925  aa41							;player4
   3926  aa41		       00 00 00 00	      HEX	00000000
   3927  aa45							;orb1
   3928  aa45		       b9 6e		      HEX	b96e
   3929  aa47							;orb2
   3930  aa47		       69 fd		      HEX	69fd
   3931  aa49							;orb3
   3932  aa49		       bf fe		      HEX	bffe
   3933  aa4b							;orb4
   3934  aa4b		       bf fe		      HEX	bffe
   3935  aa4d							;orb5
   3936  aa4d		       bf fe		      HEX	bffe
   3937  aa4f							;orb6
   3938  aa4f		       7f 69		      HEX	7f69
   3939  aa51							;portal1_top
   3940  aa51		       c0 40 00 00*	      HEX	c040000000000020
   3941  aa59							;portal2_top
   3942  aa59		       08 00 00 00*	      HEX	0800000000000103
   3943  aa61							;portal1_bottom
   3944  aa61		       c0 40 10 00*	      HEX	c040100000040020
   3945  aa69							;portal2_bottom
   3946  aa69		       08 00 05 55*	      HEX	0800055555500103
   3947  aa71							;drone1
   3948  aa71		       00 00 00 00	      HEX	00000000
   3949  aa75							;drone2
   3950  aa75		       00 00 00 00	      HEX	00000000
   3951  aa79							;drone3
   3952  aa79		       00 00 00 00	      HEX	00000000
   3953  aa7d							;drone4
   3954  aa7d		       00 00 00 00	      HEX	00000000
   3955  aa81							;title00
   3956  aa81		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   3957  aaa1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   3958  aab1							;title01
   3959  aab1		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafafafafafafafafac80000
   3960  aad1		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   3961  aae1
   3962  ab00					      ORG	$AB00,0	; *************
   3963  ab00
   3964  ab00					      RORG	$AB00	; *************
   3965  ab00
   3966  ab00							;font
   3967  ab00		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   3968  ab20		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   3969  ab35							;player1
   3970  ab35		       ff ff ff c0	      HEX	ffffffc0
   3971  ab39							;player2
   3972  ab39		       ab ea fa 80	      HEX	abeafa80
   3973  ab3d							;player3
   3974  ab3d		       ff ff ff c0	      HEX	ffffffc0
   3975  ab41							;player4
   3976  ab41		       ff ff ff c0	      HEX	ffffffc0
   3977  ab45							;orb1
   3978  ab45		       f5 5f		      HEX	f55f
   3979  ab47							;orb2
   3980  ab47		       aa ff		      HEX	aaff
   3981  ab49							;orb3
   3982  ab49		       7f ff		      HEX	7fff
   3983  ab4b							;orb4
   3984  ab4b		       ff ff		      HEX	ffff
   3985  ab4d							;orb5
   3986  ab4d		       ff fd		      HEX	fffd
   3987  ab4f							;orb6
   3988  ab4f		       ff aa		      HEX	ffaa
   3989  ab51							;portal1_top
   3990  ab51		       08 05 05 05*	      HEX	0805050505050503
   3991  ab59							;portal2_top
   3992  ab59		       c0 50 50 50*	      HEX	c050505050505020
   3993  ab61							;portal1_bottom
   3994  ab61		       08 00 12 aa*	      HEX	080012aaaa840103
   3995  ab69							;portal2_bottom
   3996  ab69		       c0 40 04 00*	      HEX	c040040000100020
   3997  ab71							;drone1
   3998  ab71		       00 00 00 00	      HEX	00000000
   3999  ab75							;drone2
   4000  ab75		       00 00 00 00	      HEX	00000000
   4001  ab79							;drone3
   4002  ab79		       00 00 00 00	      HEX	00000000
   4003  ab7d							;drone4
   4004  ab7d		       00 00 00 00	      HEX	00000000
   4005  ab81							;title00
   4006  ab81		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   4007  aba1		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a5a5
   4008  abb1							;title01
   4009  abb1		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   4010  abd1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   4011  abe1
   4012  ac00					      ORG	$AC00,0	; *************
   4013  ac00
   4014  ac00					      RORG	$AC00	; *************
   4015  ac00
   4016  ac00							;font
   4017  ac00		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   4018  ac20		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   4019  ac35							;player1
   4020  ac35		       a8 2a 0a 80	      HEX	a82a0a80
   4021  ac39							;player2
   4022  ac39		       00 00 00 00	      HEX	00000000
   4023  ac3d							;player3
   4024  ac3d		       00 00 00 00	      HEX	00000000
   4025  ac41							;player4
   4026  ac41		       00 00 00 00	      HEX	00000000
   4027  ac45							;orb1
   4028  ac45		       f5 5f		      HEX	f55f
   4029  ac47							;orb2
   4030  ac47		       aa ff		      HEX	aaff
   4031  ac49							;orb3
   4032  ac49		       7f ff		      HEX	7fff
   4033  ac4b							;orb4
   4034  ac4b		       ff ff		      HEX	ffff
   4035  ac4d							;orb5
   4036  ac4d		       ff fd		      HEX	fffd
   4037  ac4f							;orb6
   4038  ac4f		       ff aa		      HEX	ffaa
   4039  ac51							;portal1_top
   4040  ac51		       08 00 00 00*	      HEX	0800000000000003
   4041  ac59							;portal2_top
   4042  ac59		       c0 00 00 00*	      HEX	c000000000000020
   4043  ac61							;portal1_bottom
   4044  ac61		       08 00 12 00*	      HEX	0800120000840103
   4045  ac69							;portal2_bottom
   4046  ac69		       c0 40 04 aa*	      HEX	c04004aaaa100020
   4047  ac71							;drone1
   4048  ac71		       aa 00 aa 00	      HEX	aa00aa00
   4049  ac75							;drone2
   4050  ac75		       1a 00 1a 00	      HEX	1a001a00
   4051  ac79							;drone3
   4052  ac79		       18 00 18 00	      HEX	18001800
   4053  ac7d							;drone4
   4054  ac7d		       a4 00 a4 00	      HEX	a400a400
   4055  ac81							;title00
   4056  ac81		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   4057  aca1		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a584
   4058  acb1							;title01
   4059  acb1		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   4060  acd1		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0800000
   4061  ace1
   4062  ad00					      ORG	$AD00,0	; *************
   4063  ad00
   4064  ad00					      RORG	$AD00	; *************
   4065  ad00
   4066  ad00							;font
   4067  ad00		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   4068  ad20		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   4069  ad35							;player1
   4070  ad35		       55 55 55 40	      HEX	55555540
   4071  ad39							;player2
   4072  ad39		       55 55 55 40	      HEX	55555540
   4073  ad3d							;player3
   4074  ad3d		       55 55 55 40	      HEX	55555540
   4075  ad41							;player4
   4076  ad41		       55 55 55 40	      HEX	55555540
   4077  ad45							;orb1
   4078  ad45		       b9 6e		      HEX	b96e
   4079  ad47							;orb2
   4080  ad47		       69 fd		      HEX	69fd
   4081  ad49							;orb3
   4082  ad49		       bf fe		      HEX	bffe
   4083  ad4b							;orb4
   4084  ad4b		       bf fe		      HEX	bffe
   4085  ad4d							;orb5
   4086  ad4d		       bf fe		      HEX	bffe
   4087  ad4f							;orb6
   4088  ad4f		       7f 69		      HEX	7f69
   4089  ad51							;portal1_top
   4090  ad51		       c0 a0 a0 a0*	      HEX	c0a0a0a0a0a0a0a0
   4091  ad59							;portal2_top
   4092  ad59		       0a 0a 0a 0a*	      HEX	0a0a0a0a0a0a0a03
   4093  ad61							;portal1_bottom
   4094  ad61		       c0 40 12 3f*	      HEX	c040123ffc840020
   4095  ad69							;portal2_bottom
   4096  ad69		       08 00 04 80*	      HEX	0800048002100103
   4097  ad71							;drone1
   4098  ad71		       3c ff 3c 00	      HEX	3cff3c00
   4099  ad75							;drone2
   4100  ad75		       3c ff 3c 00	      HEX	3cff3c00
   4101  ad79							;drone3
   4102  ad79		       3c ff 3c 00	      HEX	3cff3c00
   4103  ad7d							;drone4
   4104  ad7d		       3c ff 3c 00	      HEX	3cff3c00
   4105  ad81							;title00
   4106  ad81		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   4107  ada1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   4108  adb1							;title01
   4109  adb1		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   4110  add1		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0a08000
   4111  ade1
   4112  ae00					      ORG	$AE00,0	; *************
   4113  ae00
   4114  ae00					      RORG	$AE00	; *************
   4115  ae00
   4116  ae00							;font
   4117  ae00		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   4118  ae20		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   4119  ae35							;player1
   4120  ae35		       15 55 55 00	      HEX	15555500
   4121  ae39							;player2
   4122  ae39		       15 55 55 00	      HEX	15555500
   4123  ae3d							;player3
   4124  ae3d		       15 55 55 00	      HEX	15555500
   4125  ae41							;player4
   4126  ae41		       15 55 55 00	      HEX	15555500
   4127  ae45							;orb1
   4128  ae45		       3f fc		      HEX	3ffc
   4129  ae47							;orb2
   4130  ae47		       3f fc		      HEX	3ffc
   4131  ae49							;orb3
   4132  ae49		       3f fc		      HEX	3ffc
   4133  ae4b							;orb4
   4134  ae4b		       3f fc		      HEX	3ffc
   4135  ae4d							;orb5
   4136  ae4d		       3f fc		      HEX	3ffc
   4137  ae4f							;orb6
   4138  ae4f		       3f fc		      HEX	3ffc
   4139  ae51							;portal1_top
   4140  ae51		       c0 00 00 00*	      HEX	c000000000000000
   4141  ae59							;portal2_top
   4142  ae59		       00 00 00 00*	      HEX	0000000000000003
   4143  ae61							;portal1_bottom
   4144  ae61		       c0 40 12 30*	      HEX	c04012300c840020
   4145  ae69							;portal2_bottom
   4146  ae69		       08 00 04 8f*	      HEX	0800048ff2100103
   4147  ae71							;drone1
   4148  ae71		       aa 14 aa 00	      HEX	aa14aa00
   4149  ae75							;drone2
   4150  ae75		       1a 14 1a 00	      HEX	1a141a00
   4151  ae79							;drone3
   4152  ae79		       18 14 18 00	      HEX	18141800
   4153  ae7d							;drone4
   4154  ae7d		       a4 14 a4 00	      HEX	a414a400
   4155  ae81							;title00
   4156  ae81		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a00000000000000005a5a5a5a000000000000
   4157  aea1		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a5a00
   4158  aeb1							;title01
   4159  aeb1		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   4160  aed1		       50 50 50 50*	      HEX	50505050505050505050505050505050
   4161  aee1
   4162  af00					      ORG	$AF00,0	; *************
   4163  af00
   4164  af00					      RORG	$AF00	; *************
   4165  af00
   4166  af00							;font
   4167  af00		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   4168  af20		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   4169  af35							;player1
   4170  af35		       05 f5 7c 00	      HEX	05f57c00
   4171  af39							;player2
   4172  af39		       07 d5 f4 00	      HEX	07d5f400
   4173  af3d							;player3
   4174  af3d		       0f 57 d4 00	      HEX	0f57d400
   4175  af41							;player4
   4176  af41		       0d 5f 5c 00	      HEX	0d5f5c00
   4177  af45							;orb1
   4178  af45		       0b e0		      HEX	0be0
   4179  af47							;orb2
   4180  af47		       0f 70		      HEX	0f70
   4181  af49							;orb3
   4182  af49		       0e f0		      HEX	0ef0
   4183  af4b							;orb4
   4184  af4b		       0b e0		      HEX	0be0
   4185  af4d							;orb5
   4186  af4d		       0f b0		      HEX	0fb0
   4187  af4f							;orb6
   4188  af4f		       0d f0		      HEX	0df0
   4189  af51							;portal1_top
   4190  af51		       0f 0f 0f 0f*	      HEX	0f0f0f0f0f0f0f0f
   4191  af59							;portal2_top
   4192  af59		       f0 f0 f0 f0*	      HEX	f0f0f0f0f0f0f0f0
   4193  af61							;portal1_bottom
   4194  af61		       08 00 12 30*	      HEX	080012300c840103
   4195  af69							;portal2_bottom
   4196  af69		       c0 40 04 8c*	      HEX	c040048c32100020
   4197  af71							;drone1
   4198  af71		       00 3c 00 00	      HEX	003c0000
   4199  af75							;drone2
   4200  af75		       00 3c 00 00	      HEX	003c0000
   4201  af79							;drone3
   4202  af79		       00 3c 00 00	      HEX	003c0000
   4203  af7d							;drone4
   4204  af7d		       00 3c 00 00	      HEX	003c0000
   4205  af81							;title00
   4206  af81		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a0000000000000000125a5a48000000000000
   4207  afa1		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a0000
   4208  afb1							;title01
   4209  afb1		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0f0f0f0f0f0f0c0000000
   4210  afd1		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f000
   4211  afe1
   4212  b000					      ORG	$B000,0	; *************
   4213  b000
   4214  b000					      RORG	$B000	; *************
   4215  b000				  -	      if	SPACEOVERFLOW > 0
   4216  b000				  -	      echo	""
   4217  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   4218  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   4219  b000				  -	      echo	"######## Aborting assembly."
   4220  b000				  -SET	      SPACEOVERFLOWPASS	= (SPACEOVERFLOWPASS + 1)
   4221  b000				  -	      if	SPACEOVERFLOWPASS > 0
   4222  b000				  -	      ERR
   4223  b000				  -	      endif
   4224  b000					      endif
   4225  b000
   4226  b000
   4227  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4228  b000
   4229  b000				  -	      ifnconst	bankswitchmode
   4230  b000				  -	      if	( * < $f000 )
   4231  b000				  -	      ORG	$F000
   4232  b000				  -	      endif
   4233  b000					      else
   4234  b000					      ifconst	ROM128K
   4235  b000					      if	( * < $f000 )
   4236  27000					       ORG	$27000
   4237  27000					       RORG	$F000
   4238  27000					       endif
   4239  27000					       endif
   4240  27000				   -	       ifconst	ROM144K
   4241  27000				   -	       if	( * < $f000 )
   4242  27000				   -	       ORG	$27000
   4243  27000				   -	       RORG	$F000
   4244  27000				   -	       endif
   4245  27000					       endif
   4246  27000				   -	       ifconst	ROM256K
   4247  27000				   -	       if	( * < $f000 )
   4248  27000				   -	       ORG	$47000
   4249  27000				   -	       RORG	$F000
   4250  27000				   -	       endif
   4251  27000					       endif
   4252  27000				   -	       ifconst	ROM272K
   4253  27000				   -	       if	( * < $f000 )
   4254  27000				   -	       ORG	$47000
   4255  27000				   -	       RORG	$F000
   4256  27000				   -	       endif
   4257  27000					       endif
   4258  27000				   -	       ifconst	ROM512K
   4259  27000				   -	       if	( * < $f000 )
   4260  27000				   -	       ORG	$87000
   4261  27000				   -	       RORG	$F000
   4262  27000				   -	       endif
   4263  27000					       endif
   4264  27000				   -	       ifconst	ROM528K
   4265  27000				   -	       if	( * < $f000 )
   4266  27000				   -	       ORG	$87000
   4267  27000				   -	       RORG	$F000
   4268  27000				   -	       endif
   4269  27000					       endif
   4270  27000					       endif
   4271  27000
   4272  27000							; all of these "modules" have conditional clauses in them, so even though
   4273  27000							; they're always included here, they don't take up rom unless the user
   4274  27000							; explicitly enables support for the feature.
   4275  27000
   4276  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* More small changes were made to use this code with 7800basic, and
     15  27000				   -			;* comments by VinsCool on more recent versions were back-ported.
     16  27000				   -			;* --Mike Saarna.
     17  27000				   -			;*
     18  27000				   -			;* Warnings:
     19  27000				   -			;*
     20  27000				   -			;* 1. RMT player routine needs 19 dedicated zero page bytes, as well as cca
     21  27000				   -			;* 1KB of memory before the "PLAYER" address for frequency tables and
     22  27000				   -			;* functionary variables. It's:
     23  27000				   -			;* a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     24  27000				   -			;* b) from PLAYER-$380 to PLAYER for mono RMTplayer
     25  27000				   -			;*
     26  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER
     27  27000				   -			;* points to the start of the frequency tables. The player routines follows
     28  27000				   -			;* after that. The variables are now independent and can be located with
     29  27000				   -			;* PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     30  27000				   -			;*
     31  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled aligned to a memory page.
     32  27000				   -			;* i.e. "PLAYER" address can be $..00 only!
     33  27000				   -			;*
     34  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of
     35  27000				   -			;* CPU time.
     36  27000				   -			;*
     37  27000				   -			;*
     38  27000				   -			;* Define the following equates here or in your main code file.
     39  27000				   -			;* Set the values according to the system you compile for.
     40  27000				   -			;*
     41  27000				   -
     42  27000				   -POKEY_BASE equ	pokeyaddress
     43  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	;* player routine needs 19 bytes
     44  27000				   -			;* of zero page RAM
     45  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;* variables in main RAM - 173 bytes
     46  27000				   -			;* mono - 337 stereo
     47  27000				   -
     48  27000				   -ROM_BASED  equ	1	;* using a ROM based system - no self modifying code
     49  27000				   -STEREO8T   equ	0	;* 0 => compile RMTplayer for mono 4 tracks
     50  27000				   -			; ;1 => compile RMTplayer for stereo 8 tracks
     51  27000				   -
     52  27000				   -HARD_OF_HEARING equ	1	;* repeat output to pokey
     53  27000				   -
     54  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     55  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     56  27000				   -
     57  27000				   -			;*
     58  27000				   -
     59  27000				   -	       IF	STEREO8T
     60  27000				   -TRACKS     equ	8
     61  27000				   -	       ELSE
     62  27000				   -TRACKS     equ	4
     63  27000				   -	       ENDIF
     64  27000				   -
     65  27000				   -			;*
     66  27000				   -			;* RMT FEATures definitions
     67  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     68  27000				   -			;* --------BEGIN--------
     69  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     70  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page)
     71  27000				   -			;* and quicker whole RMT routine
     72  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     73  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     74  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     75  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     76  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     77  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     78  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     79  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     80  27000				   -			;* PORTAMENTO
     81  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     82  27000				   -			;* FILTER
     83  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     84  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     85  27000				   -FEAT_FILTERG1L equ	1
     86  27000				   -FEAT_FILTERG0R equ	1
     87  27000				   -FEAT_FILTERG1R equ	1
     88  27000				   -			;* BASS16B (i.e. distortion value 6)
     89  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and
     90  27000				   -			;* quicker whole RMT routine
     91  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     92  27000				   -FEAT_BASS16G3L equ	1
     93  27000				   -FEAT_BASS16G1R equ	1
     94  27000				   -FEAT_BASS16G3R equ	1
     95  27000				   -			;* VOLUME ONLY for particular generators
     96  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     97  27000				   -FEAT_VOLUMEONLYG2L equ	1
     98  27000				   -FEAT_VOLUMEONLYG3L equ	1
     99  27000				   -FEAT_VOLUMEONLYG0R equ	1
    100  27000				   -FEAT_VOLUMEONLYG2R equ	1
    101  27000				   -FEAT_VOLUMEONLYG3R equ	1
    102  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
    103  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
    104  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
    105  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
    106  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
    107  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
    108  27000				   -			;* --------END--------
    109  27000				   -			;*
    110  27000				   -			;*
    111  27000				   -			;* RMT ZeroPage addresses
    112  27000				   -
    113  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    114  27000				   -p_tis      =	MEMLOC
    115  27000				   -p_instrstable =	MEMLOC
    116  27000				   -MEMLOC     SET	(MEMLOC+2)
    117  27000				   -ptrTracksTblLo =	MEMLOC
    118  27000				   -MEMLOC     SET	(MEMLOC+2)
    119  27000				   -ptrTracksTblHi =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+2)
    121  27000				   -ptrSongLines =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+2)
    123  27000				   -
    124  27000				   -_ns        =	MEMLOC
    125  27000				   -MEMLOC     SET	(MEMLOC+2)
    126  27000				   -_nr        =	MEMLOC
    127  27000				   -MEMLOC     SET	(MEMLOC+2)
    128  27000				   -_nt        =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+2)
    130  27000				   -
    131  27000				   -rmtreg1    =	MEMLOC
    132  27000				   -MEMLOC     SET	(MEMLOC+1)
    133  27000				   -rmtreg2    =	MEMLOC
    134  27000				   -MEMLOC     SET	(MEMLOC+1)
    135  27000				   -rmtreg3    =	MEMLOC
    136  27000				   -MEMLOC     SET	(MEMLOC+1)
    137  27000				   -_tmp       =	MEMLOC
    138  27000				   -MEMLOC     SET	(MEMLOC+1)
    139  27000				   -	       IF	FEAT_COMMAND2
    140  27000				   -frqaddcmd2 =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+1)
    142  27000				   -	       ENDIF
    143  27000				   -
    144  27000				   -			;*
    145  27000				   -			;* Variables in main RAM used by player routine.
    146  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    147  27000				   -			;*
    148  27000				   -
    149  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    150  27000				   -track_variables =	MEMLOC
    151  27000				   -
    152  27000				   -trackn_TblLo =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_TblHi =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -trackn_idx =	MEMLOC
    157  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    158  27000				   -trackn_pause =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_note =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_volume =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_distor =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_shiftfrq =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -
    169  27000				   -	       IF	FEAT_PORTAMENTO
    170  27000				   -trackn_portafrqc =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_portafrqa =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_portaspeed =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_portaspeeda =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_portadepth =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -	       ENDIF
    181  27000				   -
    182  27000				   -trackn_instrx2 =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_instrdb =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_instrhb =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_instridx =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_instrlen =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_instrlop =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_instrreachend =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_volumeslidedepth =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_volumeslidevalue =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_volumemin =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -trackn_effdelay =	MEMLOC
    203  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    204  27000				   -trackn_effvibratoa =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -trackn_effvibratobeg =	MEMLOC
    207  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    208  27000				   -trackn_effvibratoend =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -trackn_effshift =	MEMLOC
    211  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    212  27000				   -trackn_tabletypespeed =	MEMLOC
    213  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    214  27000				   -
    215  27000				   -	       IF	FEAT_TABLEMODE
    216  27000				   -trackn_tablemode =	MEMLOC
    217  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    218  27000				   -	       ENDIF
    219  27000				   -
    220  27000				   -trackn_tablenote =	MEMLOC
    221  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    222  27000				   -
    223  27000				   -trackn_tablea =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -trackn_tableend =	MEMLOC
    226  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    227  27000				   -trackn_tablelop =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -trackn_tablespeeda =	MEMLOC
    230  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    231  27000				   -trackn_command =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -
    234  27000				   -	       IF	FEAT_BASS16
    235  27000				   -trackn_outnote =	MEMLOC
    236  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    237  27000				   -	       ENDIF
    238  27000				   -	       IF	FEAT_FILTER
    239  27000				   -trackn_filter =	MEMLOC
    240  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    241  27000				   -	       ENDIF
    242  27000				   -
    243  27000				   -trackn_audf =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    245  27000				   -trackn_audc =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    247  27000				   -
    248  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    249  27000				   -trackn_audctl =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    251  27000				   -	       ENDIF
    252  27000				   -
    253  27000				   -v_audctl   =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_audctl2  =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_speed    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -v_aspeed   =	MEMLOC
    260  27000				   -MEMLOC     SET	(MEMLOC+1)
    261  27000				   -v_bspeed   =	MEMLOC
    262  27000				   -MEMLOC     SET	(MEMLOC+1)
    263  27000				   -v_instrspeed =	MEMLOC
    264  27000				   -MEMLOC     SET	(MEMLOC+1)
    265  27000				   -smc_silence_instrspeed =	MEMLOC
    266  27000				   -MEMLOC     SET	(MEMLOC+1)
    267  27000				   -v_maxtracklen =	MEMLOC
    268  27000				   -MEMLOC     SET	(MEMLOC+1)
    269  27000				   -v_abeat    =	MEMLOC
    270  27000				   -MEMLOC     SET	(MEMLOC+1)
    271  27000				   -
    272  27000				   -track_endvariables =	MEMLOC
    273  27000				   -
    274  27000				   -			;*
    275  27000				   -			;* Data tables used by player routine.
    276  27000				   -			;*
    277  27000				   -	       ALIGN	256
    278  27000				   -PLAYER     =	.
    279  27000				   -
    280  27000				   -volumetab
    281  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    282  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    283  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    284  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    285  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    286  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    287  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    288  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    289  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    290  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    291  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    292  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    293  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    294  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    295  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    296  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    297  27000				   -
    298  27000				   -frqtab
    299  27000				   -			; ERT [<frqtab]!=0 ;* frqtab must begin at the memory page bound!
    300  27000				   -			;* (i.e. $..00 address)
    301  27000				   -frqtabbass1
    302  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    303  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    304  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    305  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    306  27000				   -frqtabbass2
    307  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    308  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    309  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    310  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    311  27000				   -frqtabpure
    312  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    313  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    314  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    315  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    316  27000				   -	       IF	FEAT_BASS16
    317  27000				   -frqtabbasshi
    318  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    319  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    320  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    321  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    322  27000				   -	       ENDIF
    323  27000				   -
    324  27000				   -	       IF	FEAT_BASS16
    325  27000				   -frqtabbasslo
    326  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    327  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    328  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    329  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    330  27000				   -	       ENDIF
    331  27000				   -
    332  27000				   -	       IF	ROM_BASED
    333  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    334  27000				   -	       ENDIF
    335  27000				   -INSTRPAR   equ	12
    336  27000				   -tabbeganddistor
    337  27000				   -	       dc.b	frqtabpure-frqtab,$00
    338  27000				   -	       dc.b	frqtabpure-frqtab,$20
    339  27000				   -	       dc.b	frqtabpure-frqtab,$40
    340  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    341  27000				   -	       dc.b	frqtabpure-frqtab,$80
    342  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    343  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    344  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    345  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    346  27000				   -vib0       dc.b	0
    347  27000				   -vib1       dc.b	1,-1,-1,1
    348  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    349  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    350  27000				   -vibx
    351  27000				   -emptytrack
    352  27000				   -	       dc.b	62,0
    353  27000				   -
    354  27000				   -			;*
    355  27000				   -			;* Set of RMT main vectors:
    356  27000				   -			;*
    357  27000				   -RASTERMUSICTRACKER
    358  27000				   -	       jmp	rmt_init	;* Must be run first, to clear memory and initialise
    359  27000				   -			;* the player... Once this is done, run rmt_play
    360  27000				   -			;* afterwards, or Set_Pokey if you want to manually
    361  27000				   -			;* time certain things.
    362  27000				   -
    363  27000				   -	       jmp	rmt_play	;* One play each subroutine call. SetPokey is
    364  27000				   -			;* executed first, then all the play code is ran
    365  27000				   -			;* once, until the RTS. rmt_play could be called
    366  27000				   -			;* multiple times per frame if wanted.
    367  27000				   -
    368  27000				   -	       jmp	rmt_p3	;* Similar to rmt_play, but will also skip SetPokey
    369  27000				   -			;* and the instruments/songlines/tracklines
    370  27000				   -			;* initialisation, very useful for playing simple
    371  27000				   -			;* things.
    372  27000				   -
    373  27000				   -	       jmp	rmt_silence	;* Run this to stop the driver, and reset all POKEY
    374  27000				   -			;* registers to 0. This is also part of rmt_init
    375  27000				   -			;* when it is executed first.
    376  27000				   -
    377  27000				   -	       jmp	SetPokey	;* Run to copy the contents of the Shadow POKEY
    378  27000				   -			;* registers (v_audctl, v_skctl, trackn_audf,x etc)
    379  27000				   -			;* into the real ones. Will be run first each time
    380  27000				   -			;* rmt_play is called.
    381  27000				   -rmt_init
    382  27000				   -	       stx	_ns
    383  27000				   -	       sty	_ns+1
    384  27000				   -	       pha
    385  27000				   -	       IF	track_endvariables-track_variables>255
    386  27000				   -	       ldy	#0
    387  27000				   -	       tya
    388  27000				   -ri_clear_loop
    389  27000				   -	       sta	track_variables,y
    390  27000				   -	       sta	track_endvariables-$100,y
    391  27000				   -	       iny
    392  27000				   -	       bne	ri_clear_loop
    393  27000				   -	       ELSE
    394  27000				   -	       ldy	#track_endvariables-track_variables
    395  27000				   -	       lda	#0
    396  27000				   -ri_clear_loop
    397  27000				   -	       sta	track_variables-1,y
    398  27000				   -	       dey
    399  27000				   -	       bne	ri_clear_loop
    400  27000				   -	       ENDIF
    401  27000				   -			;* Parse the RMT module data
    402  27000				   -			;* Track length: +4
    403  27000				   -	       ldy	#4
    404  27000				   -	       lda	(_ns),y
    405  27000				   -	       sta	v_maxtracklen	;* Change the code to store the track length
    406  27000				   -	       iny
    407  27000				   -	       lda	(_ns),y
    408  27000				   -	       sta	v_speed	;* Change the code to store the song speed
    409  27000				   -	       iny
    410  27000				   -	       lda	(_ns),y
    411  27000				   -	       sta	v_instrspeed	;* Change the code to store the instrument speed
    412  27000				   -	       sta	smc_silence_instrspeed
    413  27000				   -
    414  27000				   -			; Copy 4 pointers: +8
    415  27000				   -			; -> InstrumentPtrs[]	       2 bytes
    416  27000				   -			; -> TracksPtrsLow[]	       2 bytes
    417  27000				   -			; -> TracksPtrsHi	       2 bytes
    418  27000				   -			; -> SongData		       2 bytes
    419  27000				   -	       ldy	#8
    420  27000				   -ri_copy_loop
    421  27000				   -	       lda	(_ns),y
    422  27000				   -	       sta	p_tis-8,y
    423  27000				   -	       iny
    424  27000				   -	       cpy	#8+8	;* we started at 8, so loop until 16
    425  27000				   -	       bne	ri_copy_loop
    426  27000				   -
    427  27000				   -	       pla
    428  27000				   -	       pha
    429  27000				   -	       IF	STEREO8T
    430  27000				   -	       asl
    431  27000				   -	       asl
    432  27000				   -	       asl
    433  27000				   -	       clc
    434  27000				   -	       adc	ptrSongLines
    435  27000				   -	       sta	ptrSongLines
    436  27000				   -	       pla
    437  27000				   -	       and	#$e0
    438  27000				   -	       asl
    439  27000				   -	       rol
    440  27000				   -	       rol
    441  27000				   -	       rol
    442  27000				   -	       ELSE
    443  27000				   -	       asl
    444  27000				   -	       asl
    445  27000				   -	       clc
    446  27000				   -	       adc	ptrSongLines
    447  27000				   -	       sta	ptrSongLines
    448  27000				   -	       pla
    449  27000				   -	       and	#$c0
    450  27000				   -	       asl
    451  27000				   -	       rol
    452  27000				   -	       rol
    453  27000				   -	       ENDIF
    454  27000				   -	       adc	ptrSongLines+1
    455  27000				   -	       sta	ptrSongLines+1
    456  27000				   -
    457  27000				   -	       jsr	GetSongLine
    458  27000				   -
    459  27000				   -	       jsr	GetTrackLine
    460  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    461  27000				   -	       jsr	rmt_silence
    462  27000				   -	       lda	v_instrspeed
    463  27000				   -	       rts
    464  27000				   -
    465  27000				   -rmt_silence
    466  27000				   -	       IF	STEREO8T
    467  27000				   -	       lda	#0
    468  27000				   -	       sta	POKEY_BASE+$08
    469  27000				   -	       sta	POKEY_BASE_S+$08
    470  27000				   -	       ldy	#3
    471  27000				   -	       sty	POKEY_BASE+$0f
    472  27000				   -	       sty	POKEY_BASE_S+$0f
    473  27000				   -	       ldy	#8
    474  27000				   -rmt_silence_loop
    475  27000				   -	       sta	POKEY_BASE+$00,y
    476  27000				   -	       sta	POKEY_BASE_S+$00,y
    477  27000				   -	       dey
    478  27000				   -	       bpl	rmt_silence_loop
    479  27000				   -	       ELSE
    480  27000				   -	       lda	#0
    481  27000				   -	       sta	POKEY_BASE+$08
    482  27000				   -	       ldy	#3
    483  27000				   -	       sty	POKEY_BASE+$0f
    484  27000				   -	       ldy	#8
    485  27000				   -rmt_silence_loop
    486  27000				   -	       sta	POKEY_BASE+$00,y
    487  27000				   -	       dey
    488  27000				   -	       bpl	rmt_silence_loop
    489  27000				   -	       ENDIF
    490  27000				   -	       rts
    491  27000				   -
    492  27000				   -GetSongLine
    493  27000				   -	       ldx	#0
    494  27000				   -	       stx	v_abeat
    495  27000				   -gsl_loop
    496  27000				   -	       ldx	#0
    497  27000				   -gsl_nextSongLine
    498  27000				   -	       txa
    499  27000				   -	       tay
    500  27000				   -	       lda	(ptrSongLines),y
    501  27000				   -	       cmp	#$fe	;* check for "goto line"
    502  27000				   -	       bcs	gsl_GotoOrEmpty	;* and handle it.
    503  27000				   -			;* (A) = Real track #
    504  27000				   -			;* Get the ptr to the track data and store it in ptrTracksTblLo
    505  27000				   -	       tay
    506  27000				   -	       lda	(ptrTracksTblLo),y
    507  27000				   -	       sta	trackn_TblLo,x
    508  27000				   -	       lda	(ptrTracksTblHi),y
    509  27000				   -gsl_initTrack
    510  27000				   -	       sta	trackn_TblHi,x
    511  27000				   -
    512  27000				   -	       lda	#0	;* reset the track index to 0 trackn_idx[x] = 0
    513  27000				   -	       sta	trackn_idx,x
    514  27000				   -
    515  27000				   -	       lda	#1
    516  27000				   -	       sta	trackn_pause,x	;* #1 is a new track, #0 is no new track
    517  27000				   -
    518  27000				   -	       lda	#$80	;* mark that there is no new instrument
    519  27000				   -	       sta	trackn_instrx2,x	;* #$80 is negative, will BMI when encountered,
    520  27000				   -			;* meaning no new instrument initialisation
    521  27000				   -	       inx
    522  27000				   -	       cpx	#TRACKS	;* if x < TRACKS --> gsl_nextSongLine
    523  27000				   -	       bne	gsl_nextSongLine
    524  27000				   -
    525  27000				   -			;* Done with data points of a song line, move to the next line
    526  27000				   -	       lda	ptrSongLines
    527  27000				   -	       clc
    528  27000				   -	       adc	#TRACKS
    529  27000				   -	       sta	ptrSongLines
    530  27000				   -	       bcc	gsl_skipSongHiIncrement
    531  27000				   -	       inc	ptrSongLines+1
    532  27000				   -gsl_skipSongHiIncrement
    533  27000				   -	       rts
    534  27000				   -
    535  27000				   -gsl_GotoOrEmpty
    536  27000				   -			; "cmp #$FE" performed prior to getting here
    537  27000				   -	       beq	gsl_Goto
    538  27000				   -
    539  27000				   -gsl_Empty
    540  27000				   -	       lda	#<emptytrack
    541  27000				   -	       sta	trackn_TblLo,x
    542  27000				   -	       lda	#>emptytrack
    543  27000				   -	       jmp	gsl_initTrack
    544  27000				   -
    545  27000				   -gsl_Goto
    546  27000				   -			; Data format: 0xFE, ???, low, high bytes of ptr to next song line
    547  27000				   -	       ldy	#2
    548  27000				   -	       lda	(ptrSongLines),y
    549  27000				   -	       tax
    550  27000				   -	       iny
    551  27000				   -	       lda	(ptrSongLines),y
    552  27000				   -	       sta	ptrSongLines+1
    553  27000				   -	       stx	ptrSongLines
    554  27000				   -	       jmp	gsl_loop
    555  27000				   -
    556  27000				   -GetTrackLine
    557  27000				   -rmtoo0
    558  27000				   -rmtoo0a
    559  27000				   -	       lda	v_speed
    560  27000				   -	       sta	v_bspeed
    561  27000				   -	       ldx	#0
    562  27000				   -gtl_loopTracks
    563  27000				   -	       lda	trackn_pause,x
    564  27000				   -	       beq	gtl_checkEndOfLoop
    565  27000				   -	       dec	trackn_pause,x
    566  27000				   -	       bne	gtl_checkEndOfLoop
    567  27000				   -	       inc	trackn_pause,x
    568  27000				   -
    569  27000				   -	       lda	trackn_TblLo,x
    570  27000				   -	       sta	_ns
    571  27000				   -	       lda	trackn_TblHi,x
    572  27000				   -	       sta	_ns+1
    573  27000				   -
    574  27000				   -oo1i
    575  27000				   -	       ldy	trackn_idx,x
    576  27000				   -			;* Get a track data point
    577  27000				   -			;* 0 - 60 = Note, instr and volume data
    578  27000				   -			;* 61 - Volume only
    579  27000				   -			;* 62 = Pause/empty line
    580  27000				   -			;* 63 - Speed, go loop or end
    581  27000				   -	       lda	(_ns),y
    582  27000				   -	       sta	rmtreg1
    583  27000				   -	       iny
    584  27000				   -	       lda	(_ns),y
    585  27000				   -	       sta	rmtreg2
    586  27000				   -	       iny
    587  27000				   -	       tya
    588  27000				   -	       sta	trackn_idx,x
    589  27000				   -
    590  27000				   -	       lda	rmtreg1
    591  27000				   -	       and	#$3f
    592  27000				   -	       cmp	#61
    593  27000				   -	       beq	gtl_ProcessVolumeData
    594  27000				   -	       bcs	gtl_Is62or63
    595  27000				   -
    596  27000				   -			;* if we're here it's a note, so store it.
    597  27000				   -	       sta	trackn_note,x
    598  27000				   -	       IF	FEAT_BASS16
    599  27000				   -	       sta	trackn_outnote,x
    600  27000				   -	       ENDIF
    601  27000				   -
    602  27000				   -			;* Process the instrument #
    603  27000				   -	       lda	rmtreg2
    604  27000				   -	       lsr
    605  27000				   -	       and	#$3f*2
    606  27000				   -	       sta	trackn_instrx2,x
    607  27000				   -
    608  27000				   -gtl_ProcessVolumeData
    609  27000				   -	       lda	rmtreg2
    610  27000				   -	       lsr
    611  27000				   -	       ror	rmtreg1
    612  27000				   -	       lsr
    613  27000				   -	       ror	rmtreg1
    614  27000				   -	       lda	rmtreg1
    615  27000				   -	       and	#$f0
    616  27000				   -	       sta	trackn_volume,x
    617  27000				   -gtl_checkEndOfLoop
    618  27000				   -	       inx
    619  27000				   -	       cpx	#TRACKS
    620  27000				   -	       bne	gtl_loopTracks
    621  27000				   -	       lda	v_bspeed
    622  27000				   -	       sta	v_speed
    623  27000				   -	       sta	v_aspeed
    624  27000				   -	       rts
    625  27000				   -
    626  27000				   -gtl_Is62or63
    627  27000				   -	       cmp	#63
    628  27000				   -	       beq	rmtoo63
    629  27000				   -	       lda	rmtreg1
    630  27000				   -	       and	#$c0
    631  27000				   -	       beq	rmtoo62_b
    632  27000				   -	       asl
    633  27000				   -	       rol
    634  27000				   -	       rol
    635  27000				   -	       sta	trackn_pause,x
    636  27000				   -	       dec	trackn_idx,x
    637  27000				   -	       jmp	gtl_checkEndOfLoop
    638  27000				   -
    639  27000				   -rmtoo62_b
    640  27000				   -	       lda	rmtreg2
    641  27000				   -	       sta	trackn_pause,x
    642  27000				   -	       jmp	gtl_checkEndOfLoop
    643  27000				   -
    644  27000				   -rmtoo63
    645  27000				   -	       lda	rmtreg1
    646  27000				   -	       bmi	rmtoo63_1X
    647  27000				   -	       lda	rmtreg2
    648  27000				   -	       sta	v_bspeed
    649  27000				   -	       jmp	oo1i
    650  27000				   -rmtoo63_1X
    651  27000				   -	       cmp	#255
    652  27000				   -	       beq	rmtoo63_11
    653  27000				   -	       lda	rmtreg2
    654  27000				   -	       sta	trackn_idx,x
    655  27000				   -	       jmp	oo1i
    656  27000				   -
    657  27000				   -rmtoo63_11
    658  27000				   -	       jsr	GetSongLine
    659  27000				   -	       jmp	rmtoo0
    660  27000				   -
    661  27000				   -InitOfNewSetInstrumentsOnly
    662  27000				   -	       ldx	#0
    663  27000				   -p2x1       ldy	trackn_instrx2,x
    664  27000				   -	       bmi	p2x2	;* if negative, no new instrument to initialise for this channel
    665  27000				   -	       jsr	SetUpInstrumentY2
    666  27000				   -	       lda	#$80
    667  27000				   -	       sta	trackn_instrx2,x
    668  27000				   -p2x2
    669  27000				   -	       inx
    670  27000				   -	       cpx	#TRACKS
    671  27000				   -	       bne	p2x1
    672  27000				   -	       rts
    673  27000				   -
    674  27000				   -rmt_play
    675  27000				   -rmt_p0
    676  27000				   -	       jsr	SetPokey
    677  27000				   -rmt_p1
    678  27000				   -	       dec	smc_silence_instrspeed
    679  27000				   -	       beq	rmtp1a
    680  27000				   -	       jmp	rmt_p3
    681  27000				   -rmtp1a
    682  27000				   -	       lda	v_instrspeed
    683  27000				   -	       sta	smc_silence_instrspeed
    684  27000				   -rmt_p2
    685  27000				   -	       dec	v_aspeed
    686  27000				   -	       bne	rmt_p3
    687  27000				   -	       inc	v_abeat
    688  27000				   -	       lda	v_abeat
    689  27000				   -	       cmp	v_maxtracklen
    690  27000				   -	       bne	rmtp2o2
    691  27000				   -	       jsr	GetSongLine
    692  27000				   -rmtp2o2
    693  27000				   -	       jsr	GetTrackLine
    694  27000				   -	       jmp	rmt_p2X
    695  27000				   -go_ppnext
    696  27000				   -	       jmp	ppnext
    697  27000				   -rmt_p2X
    698  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    699  27000				   -rmt_p3
    700  27000				   -	       lda	#>frqtab
    701  27000				   -	       sta	_nr+1
    702  27000				   -
    703  27000				   -	       ldx	#0
    704  27000				   -rmtpp1
    705  27000				   -	       lda	trackn_instrhb,x
    706  27000				   -	       beq	go_ppnext
    707  27000				   -	       sta	_ns+1
    708  27000				   -	       lda	trackn_instrdb,x
    709  27000				   -	       sta	_ns
    710  27000				   -	       ldy	trackn_instridx,x
    711  27000				   -	       lda	(_ns),y
    712  27000				   -	       sta	rmtreg1
    713  27000				   -	       iny
    714  27000				   -	       lda	(_ns),y
    715  27000				   -	       sta	rmtreg2
    716  27000				   -	       iny
    717  27000				   -	       lda	(_ns),y
    718  27000				   -	       sta	rmtreg3
    719  27000				   -	       iny
    720  27000				   -	       tya
    721  27000				   -	       cmp	trackn_instrlen,x
    722  27000				   -	       bcc	rmtpp2
    723  27000				   -	       beq	rmtpp2
    724  27000				   -	       lda	#$80
    725  27000				   -	       sta	trackn_instrreachend,x
    726  27000				   -rmtpp1b
    727  27000				   -	       lda	trackn_instrlop,x
    728  27000				   -rmtpp2
    729  27000				   -	       sta	trackn_instridx,x
    730  27000				   -	       lda	rmtreg1
    731  27000				   -	       IF	STEREO8T
    732  27000				   -	       cpx	#4
    733  27000				   -	       bcc	rmtpp2s
    734  27000				   -	       lsr
    735  27000				   -	       lsr
    736  27000				   -	       lsr
    737  27000				   -	       lsr
    738  27000				   -rmtpp2s
    739  27000				   -	       ENDIF
    740  27000				   -	       and	#$0f
    741  27000				   -	       ora	trackn_volume,x
    742  27000				   -	       tay
    743  27000				   -	       lda	volumetab,y
    744  27000				   -	       pha
    745  27000				   -	       lda	rmtreg2
    746  27000				   -	       and	#$0e
    747  27000				   -	       tay
    748  27000				   -	       lda	tabbeganddistor,y
    749  27000				   -	       sta	_nr
    750  27000				   -	       pla
    751  27000				   -	       ora	tabbeganddistor+1,y
    752  27000				   -	       sta	trackn_audc,x
    753  27000				   -	       jmp	InstrumentsEffects
    754  27000				   -returnfromInstrumentsEffects
    755  27000				   -	       IF	FEAT_COMMAND2
    756  27000				   -	       lda	#0
    757  27000				   -	       sta	frqaddcmd2
    758  27000				   -	       ENDIF
    759  27000				   -	       lda	rmtreg2
    760  27000				   -	       sta	trackn_command,x
    761  27000				   -	       and	#$70
    762  27000				   -	       lsr
    763  27000				   -	       lsr
    764  27000				   -	       IF	ROM_BASED
    765  27000				   -	       lsr
    766  27000				   -	       tay
    767  27000				   -	       lda	rts_tab+1,y
    768  27000				   -	       pha
    769  27000				   -	       lda	rts_tab,y
    770  27000				   -	       pha
    771  27000				   -	       rts
    772  27000				   -	       ELSE
    773  27000				   -	       sta	jmx+1
    774  27000				   -jmx
    775  27000				   -	       bcc	*
    776  27000				   -	       jmp	cmd0
    777  27000				   -	       nop
    778  27000				   -	       jmp	cmd1
    779  27000				   -	       nop
    780  27000				   -	       jmp	cmd2
    781  27000				   -	       nop
    782  27000				   -	       jmp	cmd3
    783  27000				   -	       nop
    784  27000				   -	       jmp	cmd4
    785  27000				   -	       nop
    786  27000				   -	       jmp	cmd5
    787  27000				   -	       nop
    788  27000				   -	       jmp	cmd6
    789  27000				   -	       nop
    790  27000				   -	       jmp	cmd7
    791  27000				   -	       ENDIF
    792  27000				   -cmd0
    793  27000				   -	       lda	trackn_note,x
    794  27000				   -	       clc
    795  27000				   -	       adc	rmtreg3
    796  27000				   -cmd0a
    797  27000				   -	       IF	FEAT_TABLETYPE
    798  27000				   -	       ldy	trackn_tabletypespeed,x
    799  27000				   -	       bmi	cmd0b
    800  27000				   -	       ENDIF
    801  27000				   -	       clc
    802  27000				   -	       adc	trackn_tablenote,x
    803  27000				   -	       cmp	#61
    804  27000				   -	       bcc	cmd0a1
    805  27000				   -	       lda	#0
    806  27000				   -	       sta	trackn_audc,x
    807  27000				   -	       lda	#63
    808  27000				   -cmd0a1
    809  27000				   -	       IF	FEAT_BASS16
    810  27000				   -	       sta	trackn_outnote,x
    811  27000				   -	       ENDIF
    812  27000				   -	       tay
    813  27000				   -	       lda	(_nr),y
    814  27000				   -	       clc
    815  27000				   -	       adc	trackn_shiftfrq,x
    816  27000				   -	       IF	FEAT_COMMAND2
    817  27000				   -	       clc
    818  27000				   -	       adc	frqaddcmd2
    819  27000				   -	       ENDIF
    820  27000				   -	       sta	trackn_audf,x
    821  27000				   -	       jmp	rmtpp9
    822  27000				   -	       IF	FEAT_TABLETYPE
    823  27000				   -cmd0b
    824  27000				   -	       cmp	#61
    825  27000				   -	       bcc	cmd0b1
    826  27000				   -	       lda	#0
    827  27000				   -	       sta	trackn_audc,x
    828  27000				   -	       lda	#63
    829  27000				   -cmd0b1
    830  27000				   -	       tay
    831  27000				   -	       lda	trackn_shiftfrq,x
    832  27000				   -	       clc
    833  27000				   -	       adc	trackn_tablenote,x
    834  27000				   -	       clc
    835  27000				   -	       adc	(_nr),y
    836  27000				   -	       IF	FEAT_COMMAND2
    837  27000				   -	       clc
    838  27000				   -	       adc	frqaddcmd2
    839  27000				   -	       ENDIF
    840  27000				   -	       sta	trackn_audf,x
    841  27000				   -	       jmp	rmtpp9
    842  27000				   -	       ENDIF
    843  27000				   -cmd1
    844  27000				   -	       IF	FEAT_COMMAND1
    845  27000				   -	       lda	rmtreg3
    846  27000				   -	       sta	trackn_audf,x
    847  27000				   -	       jmp	rmtpp9
    848  27000				   -	       ENDIF
    849  27000				   -cmd2
    850  27000				   -	       IF	FEAT_COMMAND2
    851  27000				   -	       lda	rmtreg3
    852  27000				   -	       sta	frqaddcmd2
    853  27000				   -	       lda	trackn_note,x
    854  27000				   -	       jmp	cmd0a
    855  27000				   -	       ENDIF
    856  27000				   -cmd3
    857  27000				   -	       IF	FEAT_COMMAND3
    858  27000				   -	       lda	trackn_note,x
    859  27000				   -	       clc
    860  27000				   -	       adc	rmtreg3
    861  27000				   -	       sta	trackn_note,x
    862  27000				   -	       jmp	cmd0a
    863  27000				   -	       ENDIF
    864  27000				   -cmd4
    865  27000				   -	       IF	FEAT_COMMAND4
    866  27000				   -	       lda	trackn_shiftfrq,x
    867  27000				   -	       clc
    868  27000				   -	       adc	rmtreg3
    869  27000				   -	       sta	trackn_shiftfrq,x
    870  27000				   -	       lda	trackn_note,x
    871  27000				   -	       jmp	cmd0a
    872  27000				   -	       ENDIF
    873  27000				   -cmd5
    874  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    875  27000				   -	       IF	FEAT_TABLETYPE
    876  27000				   -	       lda	trackn_tabletypespeed,x
    877  27000				   -	       bpl	cmd5a1
    878  27000				   -	       ldy	trackn_note,x
    879  27000				   -	       lda	(_nr),y
    880  27000				   -	       clc
    881  27000				   -	       adc	trackn_tablenote,x
    882  27000				   -	       jmp	cmd5ax
    883  27000				   -	       ENDIF
    884  27000				   -cmd5a1
    885  27000				   -	       lda	trackn_note,x
    886  27000				   -	       clc
    887  27000				   -	       adc	trackn_tablenote,x
    888  27000				   -	       cmp	#61
    889  27000				   -	       bcc	cmd5a2
    890  27000				   -	       lda	#63
    891  27000				   -cmd5a2
    892  27000				   -	       tay
    893  27000				   -	       lda	(_nr),y
    894  27000				   -cmd5ax
    895  27000				   -	       sta	trackn_portafrqc,x
    896  27000				   -	       ldy	rmtreg3
    897  27000				   -	       bne	cmd5a
    898  27000				   -	       sta	trackn_portafrqa,x
    899  27000				   -cmd5a
    900  27000				   -	       tya
    901  27000				   -	       lsr
    902  27000				   -	       lsr
    903  27000				   -	       lsr
    904  27000				   -	       lsr
    905  27000				   -	       sta	trackn_portaspeed,x
    906  27000				   -	       sta	trackn_portaspeeda,x
    907  27000				   -	       lda	rmtreg3
    908  27000				   -	       and	#$0f
    909  27000				   -	       sta	trackn_portadepth,x
    910  27000				   -	       lda	trackn_note,x
    911  27000				   -	       jmp	cmd0a
    912  27000				   -	       ELSE
    913  27000				   -	       IF	FEAT_COMMAND5
    914  27000				   -	       jmp	rmtpp9
    915  27000				   -	       ENDIF
    916  27000				   -	       ENDIF
    917  27000				   -cmd6
    918  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    919  27000				   -	       lda	rmtreg3
    920  27000				   -	       clc
    921  27000				   -	       adc	trackn_filter,x
    922  27000				   -	       sta	trackn_filter,x
    923  27000				   -	       lda	trackn_note,x
    924  27000				   -	       jmp	cmd0a
    925  27000				   -	       ELSE
    926  27000				   -	       IF	FEAT_COMMAND6
    927  27000				   -	       jmp	rmtpp9
    928  27000				   -	       ENDIF
    929  27000				   -	       ENDIF
    930  27000				   -cmd7
    931  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    932  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    933  27000				   -	       lda	rmtreg3
    934  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    935  27000				   -	       cmp	#$80
    936  27000				   -	       beq	cmd7a
    937  27000				   -	       ENDIF
    938  27000				   -	       sta	trackn_note,x
    939  27000				   -	       jmp	cmd0a
    940  27000				   -	       ENDIF
    941  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    942  27000				   -cmd7a
    943  27000				   -	       lda	trackn_audc,x
    944  27000				   -	       ora	#$f0
    945  27000				   -	       sta	trackn_audc,x
    946  27000				   -	       lda	trackn_note,x
    947  27000				   -	       jmp	cmd0a
    948  27000				   -	       ENDIF
    949  27000				   -	       ENDIF
    950  27000				   -rmtpp9
    951  27000				   -	       IF	FEAT_PORTAMENTO
    952  27000				   -	       lda	trackn_portaspeeda,x
    953  27000				   -	       beq	rmtpp10
    954  27000				   -	       sec
    955  27000				   -	       sbc	#1
    956  27000				   -	       sta	trackn_portaspeeda,x
    957  27000				   -	       bne	rmtpp10
    958  27000				   -	       lda	trackn_portaspeed,x
    959  27000				   -	       sta	trackn_portaspeeda,x
    960  27000				   -	       lda	trackn_portafrqa,x
    961  27000				   -	       cmp	trackn_portafrqc,x
    962  27000				   -	       beq	rmtpp10
    963  27000				   -	       bcs	pps1
    964  27000				   -	       adc	trackn_portadepth,x
    965  27000				   -	       bcs	pps8
    966  27000				   -	       cmp	trackn_portafrqc,x
    967  27000				   -	       bcs	pps8
    968  27000				   -	       jmp	pps9
    969  27000				   -pps1
    970  27000				   -	       sbc	trackn_portadepth,x
    971  27000				   -	       bcc	pps8
    972  27000				   -	       cmp	trackn_portafrqc,x
    973  27000				   -	       bcs	pps9
    974  27000				   -pps8
    975  27000				   -	       lda	trackn_portafrqc,x
    976  27000				   -pps9
    977  27000				   -	       sta	trackn_portafrqa,x
    978  27000				   -rmtpp10
    979  27000				   -	       lda	rmtreg2
    980  27000				   -	       and	#$01
    981  27000				   -	       beq	rmtpp11
    982  27000				   -	       lda	trackn_portafrqa,x
    983  27000				   -	       clc
    984  27000				   -	       adc	trackn_shiftfrq,x
    985  27000				   -	       sta	trackn_audf,x
    986  27000				   -rmtpp11
    987  27000				   -	       ENDIF
    988  27000				   -ppnext
    989  27000				   -	       inx
    990  27000				   -	       cpx	#TRACKS
    991  27000				   -	       beq	rmt_p4
    992  27000				   -	       jmp	rmtpp1
    993  27000				   -rmt_p4
    994  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    995  27000				   -	       ldx	#3
    996  27000				   -	       lda	#0
    997  27000				   -qq0        ora	trackn_audctl,x
    998  27000				   -	       dex
    999  27000				   -	       bpl	qq0
   1000  27000				   -	       sta	v_audctl
   1001  27000				   -qq1
   1002  27000				   -	       ldx	v_audctl
   1003  27000				   -	       ELSE
   1004  27000				   -	       ldx	#0
   1005  27000				   -	       stx	v_audctl
   1006  27000				   -	       ENDIF
   1007  27000				   -	       IF	FEAT_FILTER
   1008  27000				   -	       IF	FEAT_FILTERG0L
   1009  27000				   -	       lda	trackn_command+0
   1010  27000				   -	       bpl	qq2
   1011  27000				   -	       lda	trackn_audc+0
   1012  27000				   -	       and	#$0f
   1013  27000				   -	       beq	qq2
   1014  27000				   -	       lda	trackn_audf+0
   1015  27000				   -	       clc
   1016  27000				   -	       adc	trackn_filter+0
   1017  27000				   -	       sta	trackn_audf+2
   1018  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1019  27000				   -	       lda	trackn_audc+2
   1020  27000				   -	       and	#$10
   1021  27000				   -	       bne	qq1a
   1022  27000				   -	       ENDIF
   1023  27000				   -	       lda	#0
   1024  27000				   -	       sta	trackn_audc+2
   1025  27000				   -qq1a
   1026  27000				   -	       txa
   1027  27000				   -	       ora	#4
   1028  27000				   -	       tax
   1029  27000				   -	       ENDIF
   1030  27000				   -qq2
   1031  27000				   -	       IF	FEAT_FILTERG1L
   1032  27000				   -	       lda	trackn_command+1
   1033  27000				   -	       bpl	qq3
   1034  27000				   -	       lda	trackn_audc+1
   1035  27000				   -	       and	#$0f
   1036  27000				   -	       beq	qq3
   1037  27000				   -	       lda	trackn_audf+1
   1038  27000				   -	       clc
   1039  27000				   -	       adc	trackn_filter+1
   1040  27000				   -	       sta	trackn_audf+3
   1041  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
   1042  27000				   -	       lda	trackn_audc+3
   1043  27000				   -	       and	#$10
   1044  27000				   -	       bne	qq2a
   1045  27000				   -	       ENDIF
   1046  27000				   -	       lda	#0
   1047  27000				   -	       sta	trackn_audc+3
   1048  27000				   -qq2a
   1049  27000				   -	       txa
   1050  27000				   -	       ora	#2
   1051  27000				   -	       tax
   1052  27000				   -	       ENDIF
   1053  27000				   -qq3
   1054  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
   1055  27000				   -	       cpx	v_audctl
   1056  27000				   -	       bne	qq5
   1057  27000				   -	       ENDIF
   1058  27000				   -	       ENDIF
   1059  27000				   -	       IF	FEAT_BASS16
   1060  27000				   -	       IF	FEAT_BASS16G1L
   1061  27000				   -	       lda	trackn_command+1
   1062  27000				   -	       and	#$0e
   1063  27000				   -	       cmp	#6
   1064  27000				   -	       bne	qq4
   1065  27000				   -	       lda	trackn_audc+1
   1066  27000				   -	       and	#$0f
   1067  27000				   -	       beq	qq4
   1068  27000				   -	       ldy	trackn_outnote+1
   1069  27000				   -	       lda	frqtabbasslo,y
   1070  27000				   -	       sta	trackn_audf+0
   1071  27000				   -	       lda	frqtabbasshi,y
   1072  27000				   -	       sta	trackn_audf+1
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
   1074  27000				   -	       lda	trackn_audc+0
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qq3a
   1077  27000				   -	       ENDIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+0
   1080  27000				   -qq3a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#$50
   1083  27000				   -	       tax
   1084  27000				   -	       ENDIF
   1085  27000				   -qq4
   1086  27000				   -	       IF	FEAT_BASS16G3L
   1087  27000				   -	       lda	trackn_command+3
   1088  27000				   -	       and	#$0e
   1089  27000				   -	       cmp	#6
   1090  27000				   -	       bne	qq5
   1091  27000				   -	       lda	trackn_audc+3
   1092  27000				   -	       and	#$0f
   1093  27000				   -	       beq	qq5
   1094  27000				   -	       ldy	trackn_outnote+3
   1095  27000				   -	       lda	frqtabbasslo,y
   1096  27000				   -	       sta	trackn_audf+2
   1097  27000				   -	       lda	frqtabbasshi,y
   1098  27000				   -	       sta	trackn_audf+3
   1099  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1100  27000				   -	       lda	trackn_audc+2
   1101  27000				   -	       and	#$10
   1102  27000				   -	       bne	qq4a
   1103  27000				   -	       ENDIF
   1104  27000				   -	       lda	#0
   1105  27000				   -	       sta	trackn_audc+2
   1106  27000				   -qq4a
   1107  27000				   -	       txa
   1108  27000				   -	       ora	#$28
   1109  27000				   -	       tax
   1110  27000				   -	       ENDIF
   1111  27000				   -	       ENDIF
   1112  27000				   -qq5
   1113  27000				   -	       stx	v_audctl
   1114  27000				   -	       IF	STEREO8T
   1115  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1116  27000				   -	       ldx	#3
   1117  27000				   -	       lda	#0
   1118  27000				   -qs0        ora	trackn_audctl+4,x
   1119  27000				   -	       dex
   1120  27000				   -	       bpl	qs0
   1121  27000				   -	       sta	v_audctl2
   1122  27000				   -qs1
   1123  27000				   -	       ldx	v_audctl2
   1124  27000				   -	       ELSE
   1125  27000				   -	       ldx	#0
   1126  27000				   -	       stx	v_audctl2
   1127  27000				   -	       ENDIF
   1128  27000				   -	       IF	FEAT_FILTER
   1129  27000				   -	       IF	FEAT_FILTERG0R
   1130  27000				   -	       lda	trackn_command+0+4
   1131  27000				   -	       bpl	qs2
   1132  27000				   -	       lda	trackn_audc+0+4
   1133  27000				   -	       and	#$0f
   1134  27000				   -	       beq	qs2
   1135  27000				   -	       lda	trackn_audf+0+4
   1136  27000				   -	       clc
   1137  27000				   -	       adc	trackn_filter+0+4
   1138  27000				   -	       sta	trackn_audf+2+4
   1139  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1140  27000				   -	       lda	trackn_audc+2+4
   1141  27000				   -	       and	#$10
   1142  27000				   -	       bne	qs1a
   1143  27000				   -	       ENDIF
   1144  27000				   -	       lda	#0
   1145  27000				   -	       sta	trackn_audc+2+4
   1146  27000				   -qs1a
   1147  27000				   -	       txa
   1148  27000				   -	       ora	#4
   1149  27000				   -	       tax
   1150  27000				   -	       ENDIF
   1151  27000				   -qs2
   1152  27000				   -	       IF	FEAT_FILTERG1R
   1153  27000				   -	       lda	trackn_command+1+4
   1154  27000				   -	       bpl	qs3
   1155  27000				   -	       lda	trackn_audc+1+4
   1156  27000				   -	       and	#$0f
   1157  27000				   -	       beq	qs3
   1158  27000				   -	       lda	trackn_audf+1+4
   1159  27000				   -	       clc
   1160  27000				   -	       adc	trackn_filter+1+4
   1161  27000				   -	       sta	trackn_audf+3+4
   1162  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1163  27000				   -	       lda	trackn_audc+3+4
   1164  27000				   -	       and	#$10
   1165  27000				   -	       bne	qs2a
   1166  27000				   -	       ENDIF
   1167  27000				   -	       lda	#0
   1168  27000				   -	       sta	trackn_audc+3+4
   1169  27000				   -qs2a
   1170  27000				   -	       txa
   1171  27000				   -	       ora	#2
   1172  27000				   -	       tax
   1173  27000				   -	       ENDIF
   1174  27000				   -qs3
   1175  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1176  27000				   -	       cpx	v_audctl2
   1177  27000				   -	       bne	qs5
   1178  27000				   -	       ENDIF
   1179  27000				   -	       ENDIF
   1180  27000				   -	       IF	FEAT_BASS16
   1181  27000				   -	       IF	FEAT_BASS16G1R
   1182  27000				   -	       lda	trackn_command+1+4
   1183  27000				   -	       and	#$0e
   1184  27000				   -	       cmp	#6
   1185  27000				   -	       bne	qs4
   1186  27000				   -	       lda	trackn_audc+1+4
   1187  27000				   -	       and	#$0f
   1188  27000				   -	       beq	qs4
   1189  27000				   -	       ldy	trackn_outnote+1+4
   1190  27000				   -	       lda	frqtabbasslo,y
   1191  27000				   -	       sta	trackn_audf+0+4
   1192  27000				   -	       lda	frqtabbasshi,y
   1193  27000				   -	       sta	trackn_audf+1+4
   1194  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1195  27000				   -	       lda	trackn_audc+0+4
   1196  27000				   -	       and	#$10
   1197  27000				   -	       bne	qs3a
   1198  27000				   -	       ENDIF
   1199  27000				   -	       lda	#0
   1200  27000				   -	       sta	trackn_audc+0+4
   1201  27000				   -qs3a
   1202  27000				   -	       txa
   1203  27000				   -	       ora	#$50
   1204  27000				   -	       tax
   1205  27000				   -	       ENDIF
   1206  27000				   -qs4
   1207  27000				   -	       IF	FEAT_BASS16G3R
   1208  27000				   -	       lda	trackn_command+3+4
   1209  27000				   -	       and	#$0e
   1210  27000				   -	       cmp	#6
   1211  27000				   -	       bne	qs5
   1212  27000				   -	       lda	trackn_audc+3+4
   1213  27000				   -	       and	#$0f
   1214  27000				   -	       beq	qs5
   1215  27000				   -	       ldy	trackn_outnote+3+4
   1216  27000				   -	       lda	frqtabbasslo,y
   1217  27000				   -	       sta	trackn_audf+2+4
   1218  27000				   -	       lda	frqtabbasshi,y
   1219  27000				   -	       sta	trackn_audf+3+4
   1220  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1221  27000				   -	       lda	trackn_audc+2+4
   1222  27000				   -	       and	#$10
   1223  27000				   -	       bne	qs4a
   1224  27000				   -	       ENDIF
   1225  27000				   -	       lda	#0
   1226  27000				   -	       sta	trackn_audc+2+4
   1227  27000				   -qs4a
   1228  27000				   -	       txa
   1229  27000				   -	       ora	#$28
   1230  27000				   -	       tax
   1231  27000				   -	       ENDIF
   1232  27000				   -	       ENDIF
   1233  27000				   -qs5
   1234  27000				   -	       stx	v_audctl2
   1235  27000				   -	       ENDIF
   1236  27000				   -rmt_p5
   1237  27000				   -	       lda	smc_silence_instrspeed
   1238  27000				   -	       rts
   1239  27000				   -SetPokey
   1240  27000				   -	       IF	STEREO8T
   1241  27000				   -	       ldy	v_audctl2
   1242  27000				   -	       lda	trackn_audf+0+4
   1243  27000				   -	       ldx	trackn_audf+0
   1244  27000				   -	       sta	POKEY_BASE_S+$00
   1245  27000				   -	       stx	POKEY_BASE+$00
   1246  27000				   -	       lda	trackn_audc+0+4
   1247  27000				   -	       ldx	trackn_audc+0
   1248  27000				   -	       sta	POKEY_BASE_S+$01
   1249  27000				   -	       stx	POKEY_BASE+$01
   1250  27000				   -	       lda	trackn_audf+1+4
   1251  27000				   -	       ldx	trackn_audf+1
   1252  27000				   -	       sta	POKEY_BASE_S+$02
   1253  27000				   -	       stx	POKEY_BASE+$02
   1254  27000				   -	       lda	trackn_audc+1+4
   1255  27000				   -	       ldx	trackn_audc+1
   1256  27000				   -	       sta	POKEY_BASE_S+$03
   1257  27000				   -	       stx	POKEY_BASE+$03
   1258  27000				   -	       lda	trackn_audf+2+4
   1259  27000				   -	       ldx	trackn_audf+2
   1260  27000				   -	       sta	POKEY_BASE_S+$04
   1261  27000				   -	       stx	POKEY_BASE+$04
   1262  27000				   -	       lda	trackn_audc+2+4
   1263  27000				   -	       ldx	trackn_audc+2
   1264  27000				   -	       sta	POKEY_BASE_S+$05
   1265  27000				   -	       stx	POKEY_BASE+$05
   1266  27000				   -	       lda	trackn_audf+3+4
   1267  27000				   -	       ldx	trackn_audf+3
   1268  27000				   -	       sta	POKEY_BASE_S+$06
   1269  27000				   -	       stx	POKEY_BASE+$06
   1270  27000				   -	       lda	trackn_audc+3+4
   1271  27000				   -	       ldx	trackn_audc+3
   1272  27000				   -	       sta	POKEY_BASE_S+$07
   1273  27000				   -	       stx	POKEY_BASE+$07
   1274  27000				   -	       lda	v_audctl
   1275  27000				   -	       sty	POKEY_BASE_S+$08
   1276  27000				   -	       sta	POKEY_BASE+$08
   1277  27000				   -	       ELSE
   1278  27000				   -
   1279  27000				   -	       ifconst	RMTVOLUME
   1280  27000				   -	       lda	rmtvolume
   1281  27000				   -	       sta	fourbitfadevalueint
   1282  27000				   -	       endif
   1283  27000				   -	       ldy	v_audctl
   1284  27000				   -	       ldx	trackn_audf+0
   1285  27000				   -	       lda	trackn_audc+0
   1286  27000				   -	       ifconst	RMTVOLUME
   1287  27000				   -	       jsr	fourbitfadeint
   1288  27000				   -	       endif
   1289  27000				   -	       stx	POKEY_BASE+$00+0
   1290  27000				   -	       if	HARD_OF_HEARING
   1291  27000				   -	       stx	POKEY_BASE+$00+0
   1292  27000				   -	       endif
   1293  27000				   -	       sta	POKEY_BASE+$01+0
   1294  27000				   -	       if	HARD_OF_HEARING
   1295  27000				   -	       sta	POKEY_BASE+$01+0
   1296  27000				   -	       endif
   1297  27000				   -
   1298  27000				   -	       ldx	trackn_audf+1
   1299  27000				   -	       lda	trackn_audc+1
   1300  27000				   -	       ifconst	RMTVOLUME
   1301  27000				   -	       jsr	fourbitfadeint
   1302  27000				   -	       endif
   1303  27000				   -	       stx	POKEY_BASE+$00+2
   1304  27000				   -	       if	HARD_OF_HEARING
   1305  27000				   -	       stx	POKEY_BASE+$00+2
   1306  27000				   -	       endif
   1307  27000				   -	       sta	POKEY_BASE+$01+2
   1308  27000				   -	       if	HARD_OF_HEARING
   1309  27000				   -	       sta	POKEY_BASE+$01+2
   1310  27000				   -	       endif
   1311  27000				   -
   1312  27000				   -	       ldx	trackn_audf+2
   1313  27000				   -	       lda	trackn_audc+2
   1314  27000				   -	       ifconst	RMTVOLUME
   1315  27000				   -	       jsr	fourbitfadeint
   1316  27000				   -	       endif
   1317  27000				   -	       stx	POKEY_BASE+$00+4
   1318  27000				   -	       if	HARD_OF_HEARING
   1319  27000				   -	       stx	POKEY_BASE+$00+4
   1320  27000				   -	       endif
   1321  27000				   -	       sta	POKEY_BASE+$01+4
   1322  27000				   -	       if	HARD_OF_HEARING
   1323  27000				   -	       sta	POKEY_BASE+$01+4
   1324  27000				   -	       endif
   1325  27000				   -
   1326  27000				   -	       ldx	trackn_audf+3
   1327  27000				   -	       lda	trackn_audc+3
   1328  27000				   -	       ifconst	RMTVOLUME
   1329  27000				   -	       jsr	fourbitfadeint
   1330  27000				   -	       endif
   1331  27000				   -	       stx	POKEY_BASE+$00+6
   1332  27000				   -	       if	HARD_OF_HEARING
   1333  27000				   -	       stx	POKEY_BASE+$00+6
   1334  27000				   -	       endif
   1335  27000				   -	       sta	POKEY_BASE+$01+6
   1336  27000				   -	       if	HARD_OF_HEARING
   1337  27000				   -	       sta	POKEY_BASE+$01+6
   1338  27000				   -	       endif
   1339  27000				   -
   1340  27000				   -	       sty	POKEY_BASE+$08
   1341  27000				   -	       if	HARD_OF_HEARING
   1342  27000				   -	       sty	POKEY_BASE+$08
   1343  27000				   -	       endif
   1344  27000				   -
   1345  27000				   -	       ENDIF
   1346  27000				   -	       rts
   1347  27000				   -SetUpInstrumentY2
   1348  27000				   -	       lda	(p_instrstable),y
   1349  27000				   -	       sta	trackn_instrdb,x
   1350  27000				   -	       sta	_nt
   1351  27000				   -	       iny
   1352  27000				   -	       lda	(p_instrstable),y
   1353  27000				   -	       sta	trackn_instrhb,x
   1354  27000				   -	       sta	_nt+1
   1355  27000				   -	       ldy	#0
   1356  27000				   -	       lda	(_nt),y
   1357  27000				   -	       sta	trackn_tableend,x
   1358  27000				   -	       clc
   1359  27000				   -	       adc	#1
   1360  27000				   -	       sta	trackn_instridx,x
   1361  27000				   -	       iny
   1362  27000				   -	       lda	(_nt),y
   1363  27000				   -	       sta	trackn_tablelop,x
   1364  27000				   -	       iny
   1365  27000				   -	       lda	(_nt),y
   1366  27000				   -	       sta	trackn_instrlen,x
   1367  27000				   -	       iny
   1368  27000				   -	       lda	(_nt),y
   1369  27000				   -	       sta	trackn_instrlop,x
   1370  27000				   -	       iny
   1371  27000				   -	       lda	(_nt),y
   1372  27000				   -	       sta	trackn_tabletypespeed,x
   1373  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1374  27000				   -	       and	#$3f
   1375  27000				   -	       ENDIF
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -	       IF	FEAT_TABLEMODE
   1378  27000				   -	       lda	(_nt),y
   1379  27000				   -	       and	#$40
   1380  27000				   -	       sta	trackn_tablemode,x
   1381  27000				   -	       ENDIF
   1382  27000				   -	       iny
   1383  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1384  27000				   -	       lda	(_nt),y
   1385  27000				   -	       sta	trackn_audctl,x
   1386  27000				   -	       ENDIF
   1387  27000				   -	       iny
   1388  27000				   -	       lda	(_nt),y
   1389  27000				   -	       sta	trackn_volumeslidedepth,x
   1390  27000				   -	       iny
   1391  27000				   -	       lda	(_nt),y
   1392  27000				   -	       sta	trackn_volumemin,x
   1393  27000				   -	       iny
   1394  27000				   -	       lda	(_nt),y
   1395  27000				   -	       sta	trackn_effdelay,x
   1396  27000				   -	       iny
   1397  27000				   -	       lda	(_nt),y
   1398  27000				   -	       tay
   1399  27000				   -	       lda	vibtabbeg,y
   1400  27000				   -	       sta	trackn_effvibratoa,x
   1401  27000				   -	       sta	trackn_effvibratobeg,x
   1402  27000				   -	       lda	vibtabbeg+1,y
   1403  27000				   -	       sta	trackn_effvibratoend,x
   1404  27000				   -	       ldy	#10
   1405  27000				   -	       lda	(_nt),y
   1406  27000				   -	       sta	trackn_effshift,x
   1407  27000				   -	       lda	#128
   1408  27000				   -	       sta	trackn_volumeslidevalue,x
   1409  27000				   -	       lda	#0
   1410  27000				   -	       sta	trackn_instrreachend,x
   1411  27000				   -	       sta	trackn_shiftfrq,x
   1412  27000				   -	       lda	#INSTRPAR
   1413  27000				   -	       sta	trackn_tablea,x
   1414  27000				   -	       tay
   1415  27000				   -	       lda	(_nt),y
   1416  27000				   -	       sta	trackn_tablenote,x
   1417  27000				   -	       IF	FEAT_FILTER
   1418  27000				   -	       lda	#1
   1419  27000				   -	       sta	trackn_filter,x
   1420  27000				   -	       ENDIF
   1421  27000				   -	       rts
   1422  27000				   -InstrumentsEffects
   1423  27000				   -	       lda	trackn_effdelay,x
   1424  27000				   -	       beq	ei2
   1425  27000				   -	       tay
   1426  27000				   -	       dey
   1427  27000				   -	       bne	ei1
   1428  27000				   -	       lda	trackn_shiftfrq,x
   1429  27000				   -	       clc
   1430  27000				   -	       adc	trackn_effshift,x
   1431  27000				   -	       clc
   1432  27000				   -	       ldy	trackn_effvibratoa,x
   1433  27000				   -	       adc	vib0,y
   1434  27000				   -	       sta	trackn_shiftfrq,x
   1435  27000				   -	       iny
   1436  27000				   -	       tya
   1437  27000				   -	       cmp	trackn_effvibratoend,x
   1438  27000				   -	       bne	ei1a
   1439  27000				   -	       lda	trackn_effvibratobeg,x
   1440  27000				   -ei1a
   1441  27000				   -	       sta	trackn_effvibratoa,x
   1442  27000				   -	       jmp	ei2
   1443  27000				   -ei1
   1444  27000				   -	       tya
   1445  27000				   -	       sta	trackn_effdelay,x
   1446  27000				   -ei2
   1447  27000				   -	       lda	trackn_tableend,x
   1448  27000				   -	       cmp	#INSTRPAR
   1449  27000				   -	       beq	ei3
   1450  27000				   -	       lda	trackn_tablespeeda,x
   1451  27000				   -	       bpl	ei2f
   1452  27000				   -ei2c
   1453  27000				   -	       lda	trackn_tablea,x
   1454  27000				   -	       clc
   1455  27000				   -	       adc	#1
   1456  27000				   -	       cmp	trackn_tableend,x
   1457  27000				   -	       bcc	ei2a
   1458  27000				   -	       beq	ei2a
   1459  27000				   -	       lda	trackn_tablelop,x
   1460  27000				   -ei2a
   1461  27000				   -	       sta	trackn_tablea,x
   1462  27000				   -	       lda	trackn_instrdb,x
   1463  27000				   -	       sta	_nt
   1464  27000				   -	       lda	trackn_instrhb,x
   1465  27000				   -	       sta	_nt+1
   1466  27000				   -	       ldy	trackn_tablea,x
   1467  27000				   -	       lda	(_nt),y
   1468  27000				   -	       IF	FEAT_TABLEMODE
   1469  27000				   -	       ldy	trackn_tablemode,x
   1470  27000				   -	       beq	ei2e
   1471  27000				   -	       clc
   1472  27000				   -	       adc	trackn_tablenote,x
   1473  27000				   -ei2e
   1474  27000				   -	       ENDIF
   1475  27000				   -	       sta	trackn_tablenote,x
   1476  27000				   -	       lda	trackn_tabletypespeed,x
   1477  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1478  27000				   -	       and	#$3f
   1479  27000				   -	       ENDIF
   1480  27000				   -ei2f
   1481  27000				   -	       sec
   1482  27000				   -	       sbc	#1
   1483  27000				   -	       sta	trackn_tablespeeda,x
   1484  27000				   -ei3
   1485  27000				   -	       lda	trackn_instrreachend,x
   1486  27000				   -	       bpl	ei4
   1487  27000				   -	       lda	trackn_volume,x
   1488  27000				   -	       beq	ei4
   1489  27000				   -	       cmp	trackn_volumemin,x
   1490  27000				   -	       beq	ei4
   1491  27000				   -	       bcc	ei4
   1492  27000				   -	       tay
   1493  27000				   -	       lda	trackn_volumeslidevalue,x
   1494  27000				   -	       clc
   1495  27000				   -	       adc	trackn_volumeslidedepth,x
   1496  27000				   -	       sta	trackn_volumeslidevalue,x
   1497  27000				   -	       bcc	ei4
   1498  27000				   -	       tya
   1499  27000				   -	       sbc	#16
   1500  27000				   -	       sta	trackn_volume,x
   1501  27000				   -ei4
   1502  27000				   -	       jmp	returnfromInstrumentsEffects
   1503  27000				   -
   1504  27000				   -rmtmoduleend
   1505  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1506  27000				   -	       echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1507  27000				   -
   1508  27000					       endif		; RMT
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4278  27000					       endif
   4279  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4281  27000					       endif
   4282  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -	       ifconst	pokeysfxsupport
     19  27000				   -
     20  27000				   -checkpokeyplaying
     21  27000				   -	       ldx	#6
     22  27000				   -checkpokeyplayingloop
     23  27000				   -	       lda	pokey1pointlo,x
     24  27000				   -	       ora	pokey1pointhi,x
     25  27000				   -	       beq	pokeychannelinactive
     26  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     27  27000				   -pokeychannelinactive
     28  27000				   -	       dex
     29  27000				   -	       dex
     30  27000				   -	       bpl	checkpokeyplayingloop
     31  27000				   -	       rts
     32  27000				   -
     33  27000				   -playpokeysfxA
     34  27000				   -	       txa
     35  27000				   -	       tay
     36  27000				   -	       lda	pokey1tick,x
     37  27000				   -	       beq	playpokeysfxAcont
     38  27000				   -	       sec
     39  27000				   -	       sbc	#1
     40  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     41  27000				   -	       rts
     42  27000				   -
     43  27000				   -playpokeysfxAcont
     44  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     45  27000				   -	       sta	pokey1tick,x
     46  27000				   -
     47  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     48  27000				   -	       beq	playpokeysfxAcont2
     49  27000				   -	       sec
     50  27000				   -	       sbc	#1
     51  27000				   -	       sta	pokey1priority,x
     52  27000				   -playpokeysfxAcont2
     53  27000				   -
     54  27000				   -			; *** FREQUENCY
     55  27000				   -	       lda	(pokey1pointlo,x)
     56  27000				   -	       sta	inttemp1
     57  27000				   -	       clc
     58  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     59  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     60  27000				   -
     61  27000				   -			;advance the data pointer +1
     62  27000				   -	       inc	pokey1pointlo,x
     63  27000				   -	       bne	skippokeyhiinc1
     64  27000				   -	       inc	pokey1pointhi,x
     65  27000				   -skippokeyhiinc1
     66  27000				   -
     67  27000				   -			; *** WAVE
     68  27000				   -	       lda	(pokey1pointlo,x)
     69  27000				   -	       asl
     70  27000				   -	       asl
     71  27000				   -	       asl
     72  27000				   -	       asl		; x16
     73  27000				   -
     74  27000				   -			;advance the data pointer +1
     75  27000				   -	       inc	pokey1pointlo,x
     76  27000				   -	       bne	skippokeyhiinc2
     77  27000				   -	       inc	pokey1pointhi,x
     78  27000				   -skippokeyhiinc2
     79  27000				   -
     80  27000				   -	       ora	(pokey1pointlo,x)
     81  27000				   -	       iny
     82  27000				   -	       sta	(pokeybaselo),y
     83  27000				   -
     84  27000				   -	       ora	inttemp1	; check if F|C|V=0
     85  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     86  27000				   -
     87  27000				   -			; advance the pointer +1, on to the next sound chunk
     88  27000				   -	       inc	pokey1pointlo,x
     89  27000				   -	       bne	skippokeyhiinc3
     90  27000				   -	       inc	pokey1pointhi,x
     91  27000				   -skippokeyhiinc3
     92  27000				   -	       rts
     93  27000				   -
     94  27000				   -zeropokeypoint
     95  27000				   -	       sta	pokey1pointlo,x
     96  27000				   -	       sta	pokey1pointhi,x
     97  27000				   -	       sta	pokey1priority,x
     98  27000				   -	       rts
     99  27000				   -
    100  27000				   -schedulepokeysfx
    101  27000				   -	       ldx	#6
    102  27000				   -schedulepokeysfxloop
    103  27000				   -	       lda	pokey1pointlo,x
    104  27000				   -	       ora	pokey1pointhi,x
    105  27000				   -	       bne	schedulespokeysearch
    106  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    107  27000				   -schedulespokeysearch
    108  27000				   -	       dex
    109  27000				   -	       dex
    110  27000				   -	       bpl	schedulepokeysfxloop
    111  27000				   -
    112  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    113  27000				   -	       ldy	#1
    114  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    115  27000				   -	       bne	schedulepokeysfxcont1
    116  27000				   -	       rts		; ...and skip it if it's 0 priority
    117  27000				   -schedulepokeysfxcont1
    118  27000				   -
    119  27000				   -			; figure out which current sound has the lowest priority...
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	temp8
    122  27000				   -	       lda	pokey1priority
    123  27000				   -	       sta	temp9
    124  27000				   -	       ldx	#6
    125  27000				   -findlowprioritypokeyloop
    126  27000				   -	       lda	pokey1priority,x
    127  27000				   -	       cmp	temp9
    128  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    129  27000				   -	       sta	temp9
    130  27000				   -	       stx	temp8
    131  27000				   -findlowprioritypokeyloopcontinue
    132  27000				   -	       dex
    133  27000				   -	       dex
    134  27000				   -	       bne	findlowprioritypokeyloop
    135  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    136  27000				   -
    137  27000				   -schedulepokeyX
    138  27000				   -			;called with X=2*pokey channel to play on...
    139  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    140  27000				   -	       lda	(sfxinstrumentlo),y
    141  27000				   -	       sta	pokey1priority,x
    142  27000				   -	       iny
    143  27000				   -	       lda	(sfxinstrumentlo),y
    144  27000				   -	       sta	pokey1frames,x
    145  27000				   -
    146  27000				   -	       lda	sfxinstrumentlo
    147  27000				   -	       clc
    148  27000				   -	       adc	#3
    149  27000				   -	       sta	pokey1pointlo,x
    150  27000				   -	       lda	sfxinstrumenthi
    151  27000				   -	       adc	#0
    152  27000				   -	       sta	pokey1pointhi,x
    153  27000				   -	       lda	sfxpitchoffset
    154  27000				   -	       sta	pokey1offset,x
    155  27000				   -	       lda	#0
    156  27000				   -	       sta	pokey1tick,x
    157  27000				   -	       rts
    158  27000				   -	       else
    159  27000				   -schedulepokeysfx		; just some stubs
    160  27000				   -checkpokeyplaying
    161  27000				   -	       rts
    162  27000				   -	       endif		; pokeysfxsupport
    163  27000				   -
    164  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    165  27000				   -			; and the standard $4000 location.
    166  27000				   -			; if pokey the pokey is present, this routine will reset it.
    167  27000				   -	       ifconst	pokeyaddress
    168  27000				   -detectpokeylocation
    169  27000				   -	       lda	#<pokeyaddress
    170  27000				   -	       sta	pokeybaselo
    171  27000				   -	       lda	#>pokeyaddress
    172  27000				   -	       sta	pokeybasehi
    173  27000				   -	       lda	#$ff
    174  27000				   -	       sta	pokeydetected
    175  27000				   -
    176  27000				   -	       if	pokeyaddress = $450
    177  27000				   -	       lda	XCTRL1s
    178  27000				   -	       ora	#%00010100
    179  27000				   -	       sta	XCTRL1s
    180  27000				   -	       sta	XCTRL1
    181  27000				   -	       endif
    182  27000				   -
    183  27000				   -
    184  27000				   -	       lda	#0
    185  27000				   -	       ldy	#15
    186  27000				   -clearpokeyloop
    187  27000				   -	       sta	(pokeybase),y
    188  27000				   -	       dey
    189  27000				   -	       bpl	clearpokeyloop
    190  27000				   -			; take pokey out of reset...
    191  27000				   -	       ldy	#PSKCTL
    192  27000				   -	       lda	#3
    193  27000				   -	       sta	(pokeybase),y
    194  27000				   -	       ldy	#PAUDCTL
    195  27000				   -	       lda	#0
    196  27000				   -	       sta	(pokeybase),y
    197  27000				   -	       rts
    198  27000				   -	       else		; !pokeyaddress
    199  27000				   -detectpokeylocation
    200  27000				   -			;XBoard/XM...
    201  27000				   -	       ldx	#2
    202  27000				   -detectpokeyloop
    203  27000				   -	       lda	XCTRL1s
    204  27000				   -	       ora	#%00010100
    205  27000				   -	       and	POKEYXMMASK,x
    206  27000				   -	       sta	XCTRL1s
    207  27000				   -	       sta	XCTRL1
    208  27000				   -
    209  27000				   -	       lda	POKEYCHECKLO,x
    210  27000				   -	       sta	pokeybaselo
    211  27000				   -	       lda	POKEYCHECKHI,x
    212  27000				   -	       sta	pokeybasehi
    213  27000				   -	       jsr	checkforpokey
    214  27000				   -	       lda	pokeydetected
    215  27000				   -	       beq	foundpokeychip
    216  27000				   -	       dex
    217  27000				   -	       bpl	detectpokeyloop
    218  27000				   -foundpokeychip
    219  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    220  27000				   -	       sta	pokeydetected
    221  27000				   -	       rts
    222  27000				   -
    223  27000				   -POKEYXMMASK
    224  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    225  27000				   -	       .byte	%11111111, %11101111, %11101111
    226  27000				   -
    227  27000				   -POKEYCHECKLO
    228  27000				   -	       .byte	<$0450, <$0450, <$4000
    229  27000				   -POKEYCHECKHI
    230  27000				   -	       .byte	>$0450, >$0450, >$4000
    231  27000				   -
    232  27000				   -checkforpokey
    233  27000				   -	       ldy	#$0f
    234  27000				   -	       lda	#$00
    235  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    236  27000				   -resetpokeyregistersloop
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -	       dey
    239  27000				   -	       bpl	resetpokeyregistersloop
    240  27000				   -
    241  27000				   -	       ldy	#PAUDCTL
    242  27000				   -	       sta	(pokeybase),y
    243  27000				   -	       ldy	#PSKCTL
    244  27000				   -	       sta	(pokeybase),y
    245  27000				   -
    246  27000				   -			; let the dust settle...
    247  27000				   -	       nop
    248  27000				   -	       nop
    249  27000				   -	       nop
    250  27000				   -
    251  27000				   -	       lda	#4
    252  27000				   -	       sta	temp9
    253  27000				   -pokeycheckloop1
    254  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    255  27000				   -	       ldy	#PRANDOM
    256  27000				   -	       lda	(pokeybase),y
    257  27000				   -	       cmp	#$ff
    258  27000				   -	       bne	nopokeydetected
    259  27000				   -	       dec	temp9
    260  27000				   -	       bne	pokeycheckloop1
    261  27000				   -
    262  27000				   -			; take pokey out of reset...
    263  27000				   -	       ldy	#PSKCTL
    264  27000				   -	       lda	#3
    265  27000				   -	       sta	(pokeybase),y
    266  27000				   -	       ldy	#PAUDCTL
    267  27000				   -	       lda	#0
    268  27000				   -	       sta	(pokeybase),y
    269  27000				   -
    270  27000				   -			; let the dust settle again...
    271  27000				   -	       nop
    272  27000				   -	       nop
    273  27000				   -	       nop
    274  27000				   -
    275  27000				   -	       lda	#4
    276  27000				   -	       sta	temp9
    277  27000				   -pokeycheckloop2
    278  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    279  27000				   -	       ldy	#PRANDOM
    280  27000				   -	       lda	(pokeybase),y
    281  27000				   -	       cmp	#$ff
    282  27000				   -	       beq	skippokeycheckreturn
    283  27000				   -	       rts
    284  27000				   -skippokeycheckreturn
    285  27000				   -	       dec	temp9
    286  27000				   -	       bne	pokeycheckloop2
    287  27000				   -nopokeydetected
    288  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    289  27000				   -	       rts
    290  27000				   -
    291  27000				   -	       endif		; !pokeyaddress
    292  27000				   -
    293  27000				   -pokeysoundmoduleend
    294  27000				   -
    295  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes of rom)"
    296  27000				   -
    297  27000					       endif		; pokeysupport
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4284  27000					       endif
   4285  27000					       ifnconst	included.snes2atari.asm
------- FILE snes2atari.asm LEVEL 2 PASS 3
      0  27000					       include	snes2atari.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	SNES2ATARISUPPORT
      4  27000				   -snes2atarimodulestart
      5  27000				   -
      6  27000				   -SNES_CLOCK_PORT_BIT
      7  27000				   -	       .byte	$10,$01
      8  27000				   -SNES_CTLSWA_MASK
      9  27000				   -	       .byte	$30,$03
     10  27000				   -SNES_CTLSWA_SIGNAL
     11  27000				   -	       .byte	$C0,$0C
     12  27000				   -
     13  27000				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
     14  27000				   -SNES_AUTODETECT
     15  27000				   -	       ifconst	HSSUPPORT
     16  27000				   -			; ** an atarivox might be plugged in, so we skip scanning the second
     17  27000				   -			; ** port for a snes if vox was detected...
     18  27000				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
     19  27000				   -	       lsr
     20  27000				   -	       and	#1
     21  27000				   -	       eor	#1
     22  27000				   -	       tax
     23  27000				   -	       else
     24  27000				   -	       ldx	#1
     25  27000				   -	       endif		; HSSUPPORT
     26  27000				   -
     27  27000				   -SNES_AUTODETECT_LOOP
     28  27000				   -	       ifnconst	MULTIBUTTON	; snesdetect shouldn't be used in multibutton mode
     29  27000				   -	       lda	#1	; proline
     30  27000				   -	       sta	port0control,x
     31  27000				   -	       jsr	setportforinput
     32  27000				   -	       jsr	setonebuttonmode
     33  27000				   -	       jsr	SNES_READ
     34  27000				   -	       lda	snesdetected0,x
     35  27000				   -	       bne	SNES_AUTODETECT_FOUND
     36  27000				   -			; detection failed
     37  27000				   -	       jsr	setportforinput
     38  27000				   -	       jsr	settwobuttonmode
     39  27000				   -	       dex
     40  27000				   -	       bpl	SNES_AUTODETECT_LOOP
     41  27000				   -	       rts
     42  27000				   -SNES_AUTODETECT_FOUND
     43  27000				   -	       lda	#11	; formally set the snes controller
     44  27000				   -	       sta	port0control,x
     45  27000				   -	       stx	snesport
     46  27000				   -	       endif		; !MULTIBUTTON
     47  27000				   -	       rts
     48  27000					       endif		; SNES2ATARISUPPORT
     49  27000
     50  27000				    snes2atarihandler
     51  27000				   -	       ifconst	SNES2ATARISUPPORT
     52  27000				   -SNES2ATARI
     53  27000				   -	       jsr	SNES_READ
     54  27000				   -	       jmp	buttonreadloopreturn
     55  27000				   -
     56  27000				   -SNES_READ
     57  27000				   -			; x=0 for left port, x=1 for right
     58  27000				   -	       lda	port0control,x
     59  27000				   -	       cmp	#11	; snes
     60  27000				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
     61  27000				   -	       lda	snesdetected0,x
     62  27000				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
     63  27000				   -snes2atari_signal_go
     64  27000				   -	       jsr	SNES2ATARI_SIGNAL
     65  27000				   -snes2atari_signal_skip
     66  27000				   -
     67  27000				   -	       lda	CTLSWA
     68  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     69  27000				   -	       ora	SNES_CTLSWA_MASK,x
     70  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     71  27000				   -
     72  27000				   -	       lda	SWCHA
     73  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     74  27000				   -	       ora	SNES_CTLSWA_MASK,x
     75  27000				   -
     76  27000				   -	       sta	SWCHA	; latch+clock high
     77  27000				   -	       nop
     78  27000				   -	       nop
     79  27000				   -	       nop
     80  27000				   -	       nop
     81  27000				   -	       nop
     82  27000				   -	       nop
     83  27000				   -	       nop
     84  27000				   -	       lda	SWCHA
     85  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     86  27000				   -	       sta	SWCHA	; latch and clock low
     87  27000				   -	       ldy	#16	; 16 bits
     88  27000				   -SNES2ATARILOOP
     89  27000				   -	       rol	INPT4,x	; sample data into carry
     90  27000				   -	       lda	SWCHA
     91  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     92  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
     93  27000				   -	       sta	SWCHA	; clock low
     94  27000				   -	       rol	snes2atari0lo,x
     95  27000				   -	       rol	snes2atari0hi,x
     96  27000				   -	       lda	SWCHA
     97  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     98  27000				   -	       sta	SWCHA	; latch and clock low
     99  27000				   -	       dey		; next bit
    100  27000				   -	       bne	SNES2ATARILOOP
    101  27000				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
    102  27000				   -	       rol		; 17th snes bit into A low bit
    103  27000				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
    104  27000				   -	       and	#1
    105  27000				   -	       sta	snesdetected0,x
    106  27000				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
    107  27000				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
    108  27000				   -	       lda	SWCHA
    109  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    110  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
    111  27000				   -	       jmp	SNES_STOP_CLOCK
    112  27000				   -SNES_STOP_CLOCK
    113  27000				   -	       sta	SWCHA	; clock low
    114  27000				   -	       lda	CTLSWA
    115  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    116  27000				   -			;ora SNES_CLOCK_PORT_BIT,x
    117  27000				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
    118  27000				   -	       ifconst	MULTIBUTTON
    119  27000				   -	       lda	snesdetected0,x
    120  27000				   -	       bne	snesexit
    121  27000				   -	       lda	#1	; proline
    122  27000				   -	       sta	port0control,x
    123  27000				   -	       jmp	settwobuttonmode
    124  27000				   -snesexit
    125  27000				   -	       lda	#6
    126  27000				   -	       sta	multibuttoncount0,x
    127  27000				   -			; stuff directions into sSWCHA nibble and buttons into sINPT1,x...
    128  27000				   -	       lda	s2a_joyshiftcount,x
    129  27000				   -	       tay
    130  27000				   -	       lda	snes2atari0hi,x
    131  27000				   -snesjoypadloop
    132  27000				   -	       lsr
    133  27000				   -	       rol	inttemp6
    134  27000				   -	       dey
    135  27000				   -	       bpl	snesjoypadloop
    136  27000				   -	       lda	sSWCHA
    137  27000				   -	       ora	SWCHA_DIRMASK,x	; turn off the bits for this port
    138  27000				   -	       sta	sSWCHA
    139  27000				   -	       lda	inttemp6
    140  27000				   -	       ora	SWCHA_DIRMASK+1,x	; don't change the other port
    141  27000				   -	       and	sSWCHA
    142  27000				   -	       sta	sSWCHA
    143  27000				   -
    144  27000				   -			; snes2atari0hi = B  Y  Se St *  *  *	*
    145  27000				   -			; snes2atari0lo = A  X  Ls Rs
    146  27000				   -			; sINPT1	 = B  A  Y  X  Ls Rs Se St
    147  27000				   -	       lda	snes2atari0lo,x
    148  27000				   -	       sta	inttemp5
    149  27000				   -	       lda	snes2atari0hi,x
    150  27000				   -	       sta	inttemp6
    151  27000				   -	       asl	inttemp5	; A
    152  27000				   -	       rol
    153  27000				   -	       asl	inttemp6	; B
    154  27000				   -	       rol
    155  27000				   -	       asl	inttemp6	; Y
    156  27000				   -	       rol
    157  27000				   -	       asl	inttemp5	; X
    158  27000				   -	       rol
    159  27000				   -	       asl	inttemp5	; Ls
    160  27000				   -	       rol
    161  27000				   -	       asl	inttemp5	; Rs
    162  27000				   -	       rol
    163  27000				   -	       asl	inttemp6	; Ls
    164  27000				   -	       rol
    165  27000				   -	       asl	inttemp6	; Rs
    166  27000				   -	       rol
    167  27000				   -	       eor	#%11000000	; invert to match proline
    168  27000				   -	       sta	sINPT1,x
    169  27000				   -	       endif		; MULTIBUTTON
    170  27000				   -	       rts
    171  27000				   -SNES2ATARI_SIGNAL
    172  27000				   -			; signal to SNES2ATARI++ that we want SNES mode...
    173  27000				   -	       lda	CTLSWA
    174  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    175  27000				   -	       ora	SNES_CTLSWA_SIGNAL,x
    176  27000				   -	       sta	CTLSWA
    177  27000				   -	       lda	SWCHA
    178  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    179  27000				   -	       sta	SWCHA
    180  27000				   -	       ldy	#16
    181  27000				   -SNES_SIGNAL_LOOP
    182  27000				   -	       dey
    183  27000				   -	       bne	SNES_SIGNAL_LOOP
    184  27000				   -	       lda	SWCHA
    185  27000				   -	       ora	SWCHA_DIRMASK,x
    186  27000				   -	       sta	SWCHA
    187  27000				   -	       rts
    188  27000				   -s2a_joyshiftcount
    189  27000				   -	       .byte	7,3
    190  27000				   -snes2atarimoduleend
    191  27000				   -	       echo	"  (snes2atari module is using ",[(snes2atarimoduleend-snes2atarimodulestart)]d," bytes of rom)"
    192  27000					       endif		; SNES2ATARISUPPORT
    193  27000
    194  27000
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4287  27000					       endif
   4288  27000					       ifnconst	included.mega7800.asm
------- FILE mega7800.asm LEVEL 2 PASS 3
      0  27000					       include	mega7800.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				    mega7800handlerstart
      4  27000				    mega7800handler
      5  27000				   -	       ifconst	MEGA7800SUPPORT
      6  27000				   -
      7  27000				   -			; ** stuff the joyick directions into the shadow register
      8  27000				   -	       lda	sSWCHA	; clear previous dirs for this pad, from
      9  27000				   -	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
     10  27000				   -	       sta	sSWCHA
     11  27000				   -	       lda	SWCHA	; load the actual joystick dirs, ensuring
     12  27000				   -	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
     13  27000				   -	       and	sSWCHA
     14  27000				   -	       sta	sSWCHA
     15  27000				   -
     16  27000				   -			; x=0 for left port, x=1 for right
     17  27000				   -
     18  27000				   -	       lda	#0
     19  27000				   -	       sta	inttemp5	; temporary button-state storage
     20  27000				   -	       sta	inttemp6	; temporary button-state storage
     21  27000				   -
     22  27000				   -	       lda	CTLSWA
     23  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     24  27000				   -	       ora	MEGA_INIT,x
     25  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     26  27000				   -
     27  27000				   -			; the controller type bits take a few cycles to get set after we start
     28  27000				   -			; an extended read, so we'll start the first extended read early...
     29  27000				   -	       lda	SWCHA
     30  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     31  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the extended read
     32  27000				   -	       nop
     33  27000				   -	       nop
     34  27000				   -
     35  27000				   -			; first read  will be pad state (mega7800 connect and controller type)
     36  27000				   -			; second read will be 3 button support (SACB)
     37  27000				   -			; third read  will be 6 button support (MXYZ)
     38  27000				   -
     39  27000				   -	       ldy	#5	; read 6x states, with the first 2x being the controller type
     40  27000				   -m7readloop
     41  27000				   -	       lda	SWCHA
     42  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     43  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the read
     44  27000				   -
     45  27000				   -	       lda	SWCHA
     46  27000				   -	       cpx	#1
     47  27000				   -	       bne	m7skipp1shift
     48  27000				   -	       asl
     49  27000				   -	       asl
     50  27000				   -	       asl
     51  27000				   -	       asl
     52  27000				   -m7skipp1shift
     53  27000				   -	       asl		; button bit 1 into carry
     54  27000				   -	       rol	inttemp6
     55  27000				   -	       rol	inttemp5
     56  27000				   -	       asl		; button bit 0 into carry
     57  27000				   -	       rol	inttemp6
     58  27000				   -	       rol	inttemp5
     59  27000				   -
     60  27000				   -	       lda	SWCHA
     61  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     62  27000				   -	       ora	MEGA_NEXT,x
     63  27000				   -	       sta	SWCHA
     64  27000				   -
     65  27000				   -	       dey
     66  27000				   -	       bpl	m7readloop
     67  27000				   -
     68  27000				   -	       lda	CTLSWA
     69  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     70  27000				   -	       sta	CTLSWA	; set this port back to input
     71  27000				   -
     72  27000				   -			; if mega7800 isn't detected this frame, unpress any buttons...
     73  27000				   -	       lda	inttemp5
     74  27000				   -	       and	#%00000011
     75  27000				   -	       beq	m7skipscuttle
     76  27000				   -	       lda	#$ff
     77  27000				   -	       sta	inttemp6
     78  27000				   -	       ifconst	MULTIBUTTON
     79  27000				   -			; the controller isn't present... revert to proline
     80  27000				   -	       lda	#1	; proline
     81  27000				   -	       sta	port0control,x
     82  27000				   -	       rts
     83  27000				   -	       endif		; MULTIBUTTON
     84  27000				   -m7skipscuttle
     85  27000				   -	       ifconst	MULTIBUTTON
     86  27000				   -	       lda	inttemp5
     87  27000				   -	       lsr
     88  27000				   -	       lsr
     89  27000				   -	       and	#3
     90  27000				   -	       tay
     91  27000				   -	       lda	megabuttons,y
     92  27000				   -	       sta	multibuttoncount0,x
     93  27000				   -	       endif		; MULTIBUTTON
     94  27000				   -
     95  27000				   -	       lda	inttemp5
     96  27000				   -	       sta	mega7800state0,x
     97  27000				   -	       lda	inttemp6
     98  27000				   -	       sta	mega7800data0,x
     99  27000				   -
    100  27000				   -	       ifconst	MULTIBUTTON
    101  27000				   -			; now update the genric multi-button bits...
    102  27000				   -	       ldy	#7
    103  27000				   -m7shuffleloop
    104  27000				   -	       lda	inttemp6
    105  27000				   -	       and	m7reorder,y
    106  27000				   -	       clc
    107  27000				   -	       adc	#$FF	; bit value in carry
    108  27000				   -	       rol	inttemp5
    109  27000				   -	       dey
    110  27000				   -	       bpl	m7shuffleloop
    111  27000				   -	       lda	inttemp5
    112  27000				   -	       eor	#%11000000
    113  27000				   -	       sta	sINPT1,x
    114  27000				   -	       rts
    115  27000				   -
    116  27000				   -megabuttons
    117  27000				   -	       .byte	6,2,3,2
    118  27000				   -m7reorder
    119  27000				   -			;	  S	     M	       Z	 Y
    120  27000				   -	       .byte	%00100000,%00000010,%00000100,%00001000
    121  27000				   -			;	  X	     C	       A	 B
    122  27000				   -	       .byte	%00000001,%10000000,%00010000,%01000000
    123  27000				   -	       else		;  !MULTIBUTTON
    124  27000				   -	       rts
    125  27000				   -	       endif		; !MULTIBUTTON
    126  27000				   -
    127  27000				   -MEGA_INIT
    128  27000				   -	       .byte	%00110000,%00000011
    129  27000				   -MEGA_NEXT
    130  27000				   -	       .byte	%00100000,%00000010
    131  27000				   -
    132  27000				   -mega7800handlerend
    133  27000				   -	       echo	"  (mega7800 module is using ",[(mega7800handlerend-mega7800handlerstart)]d," bytes of rom)"
    134  27000				   -
    135  27000					       endif		; MEGA7800SUPPORT
    136  27000
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4290  27000					       endif
   4291  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       ifconst	PAUSESILENT
     15  27000				   -	       lda	pausestate
     16  27000				   -	       bne	servicesongover
     17  27000				   -	       endif
     18  27000				   -	       lda	songtempo
     19  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     20  27000				   -servicesongcontinue
     21  27000				   -	       lda	sfxschedulelock
     22  27000				   -	       sta	sfxschedulemissed
     23  27000				   -	       bne	servicesongover
     24  27000				   -	       lda	songtempo
     25  27000				   -	       clc
     26  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     27  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     28  27000				   -	       bcc	servicesongover
     29  27000				   -			; ** if we're here a new 16th note has passed
     30  27000				   -			; ** check if a new note is due on any of the 4 channels
     31  27000				   -servicesongredo
     32  27000				   -	       ldx	#3
     33  27000				   -checkchannelloop
     34  27000				   -	       dec	songchannel1busywait,x
     35  27000				   -	       bpl	carryoncheckingchannel
     36  27000				   -	       txa
     37  27000				   -	       pha		; save X for the loop
     38  27000				   -	       jsr	processsongdata
     39  27000				   -	       pla		; restore X for the loop
     40  27000				   -	       tax
     41  27000				   -carryoncheckingchannel
     42  27000				   -	       dex
     43  27000				   -	       bpl	checkchannelloop
     44  27000				   -	       lda	inactivechannelcount
     45  27000				   -	       cmp	#15
     46  27000				   -	       bne	skipstopsong
     47  27000				   -	       lda	songloops
     48  27000				   -	       bne	doasongloop
     49  27000				   -			;lda #0
     50  27000				   -	       sta	songtempo	; all channels are done. stop the song
     51  27000				   -	       rts
     52  27000				   -doasongloop
     53  27000				   -	       bmi	skipsongloopadjust
     54  27000				   -	       dec	songloops
     55  27000				   -skipsongloopadjust
     56  27000				   -	       jsr	setsongchannels
     57  27000				   -	       jmp	servicesongredo
     58  27000				   -skipstopsong
     59  27000				   -	       rts
     60  27000				   -
     61  27000				   -processsongdata
     62  27000				   -			; channel needs processing
     63  27000				   -			; X=channel #
     64  27000				   -
     65  27000				   -	       txa
     66  27000				   -	       clc
     67  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     68  27000				   -	       tay
     69  27000				   -
     70  27000				   -
     71  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     72  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     73  27000				   -	       lda	songchannel1layer1lo,y
     74  27000				   -	       sta	songdatalo
     75  27000				   -	       lda	songchannel1layer1hi,y
     76  27000				   -	       sta	songdatahi
     77  27000				   -			;ora songdatalo
     78  27000				   -	       bne	channelhasdata
     79  27000				   -			;channel data is pointing at $0000
     80  27000				   -	       lda	#$7F
     81  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     82  27000				   -setchannelcountbits
     83  27000				   -	       lda	channel2bits,x
     84  27000				   -	       ora	inactivechannelcount
     85  27000				   -	       sta	inactivechannelcount
     86  27000				   -	       rts
     87  27000				   -channelhasdata
     88  27000				   -
     89  27000				   -	       sty	songstackindex
     90  27000				   -	       ldy	#0
     91  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     92  27000				   -	       cmp	#$ff
     93  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     94  27000				   -	       jmp	handlechannelEOD
     95  27000				   -
     96  27000				   -carryoncheckingdatatype
     97  27000				   -	       and	#$F0
     98  27000				   -	       cmp	#$C0
     99  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
    100  27000				   -	       cmp	#$F0
    101  27000				   -	       beq	handlemultibytecommand
    102  27000				   -	       cmp	#$D0
    103  27000				   -	       beq	handlesemiup
    104  27000				   -	       cmp	#$E0
    105  27000				   -	       beq	handlesemidown
    106  27000				   -handlenotedata
    107  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    108  27000				   -
    109  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    110  27000				   -
    111  27000				   -			; ** set the note length
    112  27000				   -	       lda	(songdatalo),y
    113  27000				   -	       and	#$0F
    114  27000				   -	       sta	songchannel1busywait,x
    115  27000				   -
    116  27000				   -			; ** load the instrument
    117  27000				   -	       lda	songchannel1instrumentlo,x
    118  27000				   -	       sta	sfxinstrumentlo
    119  27000				   -	       lda	songchannel1instrumenthi,x
    120  27000				   -	       sta	sfxinstrumenthi
    121  27000				   -
    122  27000				   -			; ** get the note, and transpose
    123  27000				   -	       lda	(songdatalo),y
    124  27000				   -	       lsr
    125  27000				   -	       lsr
    126  27000				   -	       lsr
    127  27000				   -	       lsr
    128  27000				   -	       clc
    129  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    130  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    131  27000				   -	       sta	sfxnoteindex
    132  27000				   -
    133  27000				   -	       lda	#0
    134  27000				   -	       sta	sfxpitchoffset
    135  27000				   -
    136  27000				   -	       jsr	schedulesfx
    137  27000				   -skipnoteschedule
    138  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  27000				   -
    140  27000				   -handlechannelrest
    141  27000				   -			; ** set the note length
    142  27000				   -	       lda	(songdatalo),y
    143  27000				   -	       and	#$0F
    144  27000				   -	       sta	songchannel1busywait,x
    145  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    146  27000				   -
    147  27000				   -handlesemiup
    148  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    149  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    150  27000				   -	       clc
    151  27000				   -handlesemidownentry
    152  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    153  27000				   -	       sta	songchannel1transpose,x
    154  27000				   -	       jsr	advancethesongpointer1byte
    155  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    156  27000				   -
    157  27000				   -handlesemidown
    158  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    161  27000				   -	       sec
    162  27000				   -	       jmp	handlesemidownentry
    163  27000				   -
    164  27000				   -handlemultibytecommand
    165  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    166  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    167  27000				   -	       cmp	#$08	; ** load new instrument?
    168  27000				   -	       bne	nothandleinstrumentchange
    169  27000				   -handleinstrumentchange
    170  27000				   -	       iny
    171  27000				   -	       lda	(songdatalo),y
    172  27000				   -	       sta	songchannel1instrumentlo,x
    173  27000				   -	       iny
    174  27000				   -	       lda	(songdatalo),y
    175  27000				   -	       sta	songchannel1instrumenthi,x
    176  27000				   -	       lda	#3
    177  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    178  27000				   -	       jmp	processsongdata
    179  27000				   -
    180  27000				   -nothandleinstrumentchange
    181  27000				   -	       cmp	#$09	; ** absolute tempo change?
    182  27000				   -	       bne	nothandletempochange
    183  27000				   -	       lda	#0
    184  27000				   -	       sta	songtempo
    185  27000				   -handlerelativetempochange
    186  27000				   -	       iny
    187  27000				   -	       lda	(songdatalo),y
    188  27000				   -	       clc
    189  27000				   -	       adc	songtempo
    190  27000				   -	       sta	songtempo
    191  27000				   -	       lda	#2
    192  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    193  27000				   -	       jmp	processsongdata
    194  27000				   -
    195  27000				   -nothandletempochange
    196  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    197  27000				   -	       beq	handlerelativetempochange
    198  27000				   -	       cmp	#$0B	; ** octave/semi change?
    199  27000				   -	       beq	handleoctavesemichange
    200  27000				   -handlepatterndata
    201  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    202  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    203  27000				   -
    204  27000				   -	       lda	#4
    205  27000				   -	       clc
    206  27000				   -	       adc	songchannel1stackdepth,x
    207  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    208  27000				   -
    209  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    210  27000				   -	       lda	songstackindex
    211  27000				   -	       adc	#4
    212  27000				   -	       tax
    213  27000				   -
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       and	#$7
    216  27000				   -	       sta	songchannel1layer1loops,x
    217  27000				   -	       iny
    218  27000				   -	       lda	(songdatalo),y
    219  27000				   -	       sta	songchannel1layer1lo,x
    220  27000				   -	       iny
    221  27000				   -	       lda	(songdatalo),y
    222  27000				   -	       sta	songchannel1layer1hi,x
    223  27000				   -
    224  27000				   -	       ldx	inttemp6	; restore x with the channel #
    225  27000				   -
    226  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    227  27000				   -	       lda	#3
    228  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    229  27000				   -
    230  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    231  27000				   -	       jmp	processsongdata
    232  27000				   -
    233  27000				   -handlechannelEOD
    234  27000				   -			; ** check if there are loops remaining on the pattern
    235  27000				   -	       stx	inttemp6
    236  27000				   -	       ldx	songstackindex
    237  27000				   -	       dec	songchannel1layer1loops,x
    238  27000				   -	       bmi	handlechannelEODnoloop
    239  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    240  27000				   -	       iny
    241  27000				   -	       lda	(songdatalo),y
    242  27000				   -	       sta	songchannel1layer1lo,x
    243  27000				   -	       iny
    244  27000				   -	       lda	(songdatalo),y
    245  27000				   -	       sta	songchannel1layer1hi,x
    246  27000				   -	       ldx	inttemp6
    247  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    248  27000				   -
    249  27000				   -handlechannelEODnoloop
    250  27000				   -			; this pattern/loop is done playing. "pop" the stack
    251  27000				   -	       ldx	inttemp6
    252  27000				   -	       lda	songchannel1stackdepth,x
    253  27000				   -	       beq	handlerootchannelEOD
    254  27000				   -	       sec
    255  27000				   -	       sbc	#4
    256  27000				   -	       sta	songchannel1stackdepth,x
    257  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    258  27000				   -
    259  27000				   -handlerootchannelEOD
    260  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    261  27000				   -	       lda	#0
    262  27000				   -	       sta	songchannel1layer1lo,x
    263  27000				   -	       sta	songchannel1layer1hi,x
    264  27000				   -	       sta	songchannel1busywait,x
    265  27000				   -	       jmp	setchannelcountbits
    266  27000				   -	       rts
    267  27000				   -
    268  27000				   -nothandlepatternchange
    269  27000				   -handleoctavesemichange
    270  27000				   -	       iny
    271  27000				   -	       lda	(songdatalo),y
    272  27000				   -	       sta	songchannel1transpose,x
    273  27000				   -	       lda	#2
    274  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    275  27000				   -	       jmp	processsongdata
    276  27000				   -
    277  27000				   -advancethesongpointer1byte
    278  27000				   -	       txa
    279  27000				   -	       ldx	songstackindex
    280  27000				   -	       inc	songchannel1layer1lo,x
    281  27000				   -	       bne	skiphiadvancethesongpointer1byte
    282  27000				   -	       inc	songchannel1layer1hi,x
    283  27000				   -skiphiadvancethesongpointer1byte
    284  27000				   -	       tax
    285  27000				   -	       rts
    286  27000				   -
    287  27000				   -advancethesongpointerNbytes
    288  27000				   -			; entered with A=# of byte to advance
    289  27000				   -	       stx	inttemp6
    290  27000				   -	       ldx	songstackindex
    291  27000				   -	       clc
    292  27000				   -	       adc	songchannel1layer1lo,x
    293  27000				   -	       sta	songchannel1layer1lo,x
    294  27000				   -	       lda	#0
    295  27000				   -	       adc	songchannel1layer1hi,x
    296  27000				   -	       sta	songchannel1layer1hi,x
    297  27000				   -	       ldx	inttemp6
    298  27000				   -	       rts
    299  27000				   -
    300  27000				   -clearsongmemory
    301  27000				   -	       lda	#0
    302  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    303  27000				   -clearsongmemoryloop1
    304  27000				   -	       sta	songchannel1layer1lo,x
    305  27000				   -	       dex
    306  27000				   -	       bpl	clearsongmemoryloop1
    307  27000				   -
    308  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    309  27000				   -clearsongmemoryloop2
    310  27000				   -	       sta	songchannel1layer1loops,x
    311  27000				   -	       dex
    312  27000				   -	       bpl	clearsongmemoryloop2
    313  27000				   -
    314  27000				   -	       lda	#$ff
    315  27000				   -	       ldx	#3
    316  27000				   -clearsongmemoryloop3
    317  27000				   -	       sta	songchannel1busywait,x
    318  27000				   -	       dex
    319  27000				   -	       bpl	clearsongmemoryloop3
    320  27000				   -	       rts
    321  27000				   -
    322  27000				   -setsongchannels
    323  27000				   -	       jsr	clearsongmemory
    324  27000				   -	       ldy	#7
    325  27000				   -	       ldx	#3
    326  27000				   -setsongchannelsloop
    327  27000				   -	       lda	(songpointerlo),y
    328  27000				   -	       sta	songchannel1layer1hi,x
    329  27000				   -	       dey
    330  27000				   -	       lda	(songpointerlo),y
    331  27000				   -	       sta	songchannel1layer1lo,x
    332  27000				   -	       dex
    333  27000				   -	       dey
    334  27000				   -	       bpl	setsongchannelsloop
    335  27000				   -	       rts
    336  27000				   -
    337  27000				   -channel2bits
    338  27000				   -	       .byte	1,2,4,8
    339  27000				   -
    340  27000				   -tiatrackeroctavenotes
    341  27000				   -	       ifconst	BUZZBASS
    342  27000				   -LOWC       =	15
    343  27000				   -	       else
    344  27000				   -LOWC       =	14
    345  27000				   -	       endif
    346  27000				   -			; ****** ELECTRONIC (0 to 11)
    347  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    348  27000				   -	       .byte	LOWC,18	; c#0
    349  27000				   -	       .byte	LOWC,17	; d0
    350  27000				   -	       .byte	LOWC,16	; d#0
    351  27000				   -	       .byte	LOWC,15	; e0
    352  27000				   -	       .byte	LOWC,14	; f0  (very off)
    353  27000				   -	       .byte	LOWC,14	; f#0
    354  27000				   -	       .byte	LOWC,13	; g0
    355  27000				   -	       .byte	LOWC,12	; g#0
    356  27000				   -	       .byte	LOWC,11	; a0
    357  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    358  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    359  27000				   -
    360  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    361  27000				   -	       .byte	6,30	; c1	 32.7Hz
    362  27000				   -	       .byte	6,28	; c#1
    363  27000				   -	       .byte	6,27	; d1
    364  27000				   -	       .byte	6,25	; d#1
    365  27000				   -	       .byte	6,24	; e1
    366  27000				   -	       .byte	6,22	; f1
    367  27000				   -	       .byte	6,21	; f#1
    368  27000				   -	       .byte	6,20	; g1
    369  27000				   -	       .byte	6,18	; g#1
    370  27000				   -	       .byte	6,17	; a1
    371  27000				   -	       .byte	6,16	; a#1
    372  27000				   -	       .byte	6,15	; b1	 63.4Hz
    373  27000				   -
    374  27000				   -			; ****** BUZZY (24 to 39)
    375  27000				   -	       .byte	1,31	; c2	 65.5
    376  27000				   -	       .byte	1,30	; c#2	 67.6
    377  27000				   -	       .byte	1,27	; d2	 72.3
    378  27000				   -	       .byte	1,26	; d#2	 77.6
    379  27000				   -	       .byte	1,24	; e2
    380  27000				   -	       .byte	1,23	; f2
    381  27000				   -	       .byte	1,22	; f#2
    382  27000				   -	       .byte	1,20	; g2
    383  27000				   -	       .byte	1,19	; g#2
    384  27000				   -	       .byte	1,18	; a2
    385  27000				   -	       .byte	1,17	; a#2
    386  27000				   -	       .byte	1,16	; b2
    387  27000				   -	       .byte	1,15	; c3	126.8Hz
    388  27000				   -	       .byte	1,14	; c#3
    389  27000				   -	       .byte	1,13	; d3	149.7Hz
    390  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    391  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    392  27000				   -	       .byte	12,31	; e3	163.8Hz
    393  27000				   -	       .byte	12,29	; f3
    394  27000				   -	       .byte	12,28	; f#3
    395  27000				   -	       .byte	12,26	; g3
    396  27000				   -	       .byte	12,24	; g#3
    397  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    398  27000				   -	       .byte	12,22	; a#3
    399  27000				   -	       .byte	12,20	; b3
    400  27000				   -	       .byte	12,19	; c4  (middle C)
    401  27000				   -	       .byte	12,18	; c#4
    402  27000				   -	       .byte	12,17	; d4
    403  27000				   -	       .byte	12,16	; d#4
    404  27000				   -	       .byte	12,15	; e4
    405  27000				   -	       .byte	12,14	; f4
    406  27000				   -	       .byte	12,13	; f#4
    407  27000				   -	       .byte	12,12	; g4  (very off)
    408  27000				   -	       .byte	12,12	; g#4
    409  27000				   -	       .byte	12,11	; a4
    410  27000				   -	       .byte	12,10	; a#4
    411  27000				   -	       .byte	4,31	; b4
    412  27000				   -	       .byte	4,29	; c5
    413  27000				   -	       .byte	4,28	; c#5
    414  27000				   -	       .byte	4,26	; d5
    415  27000				   -	       .byte	4,24	; d#5
    416  27000				   -	       .byte	4,23	; e5
    417  27000				   -	       .byte	4,22	; f5
    418  27000				   -	       .byte	4,20	; f#5
    419  27000				   -	       .byte	4,19	; g5
    420  27000				   -	       .byte	4,18	; g#5
    421  27000				   -	       .byte	4,17	; a5
    422  27000				   -	       .byte	4,16	; a#5
    423  27000				   -	       .byte	4,15	; b5
    424  27000				   -
    425  27000				   -			; ****** TUNED WIND (72 to 83)
    426  27000				   -	       .byte	8,30	; c
    427  27000				   -	       .byte	8,28	; c#
    428  27000				   -	       .byte	8,27	; d
    429  27000				   -	       .byte	8,25	; d#
    430  27000				   -	       .byte	8,24	; e
    431  27000				   -	       .byte	8,22	; f
    432  27000				   -	       .byte	8,21	; f#
    433  27000				   -	       .byte	8,20	; g
    434  27000				   -	       .byte	8,18	; g#
    435  27000				   -	       .byte	8,17	; a
    436  27000				   -	       .byte	8,16	; a#
    437  27000				   -	       .byte	8,15	; b
    438  27000				   -
    439  27000				   -	       include	"tiadrumkit.asm"
    440  27000				   -
    441  27000				   -trackerend
    442  27000				   -
    443  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    444  27000				   -
    445  27000					       endif		;MUSICTRACKER
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4293  27000					       endif
   4294  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -	       ifconst	BANKSETROM
      6  27000				   -	       ifconst	isBANKSETBANK
      7  27000				   -HSCHARSHERE =	1
      8  27000				   -	       endif
      9  27000				   -	       else		; !BANKSETROM so embed the character strings
     10  27000				   -HSCHARSHERE =	1
     11  27000				   -	       endif
     12  27000				   -
     13  27000				   -	       ifnconst	isBANKSETBANK
     14  27000				   -hiscorestart
     15  27000				   -
     16  27000				   -detectatarivoxeeprom
     17  27000				   -hiscoremodulestart
     18  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  27000				   -	       jsr	AVoxDetect
     20  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  27000				   -	       sta	avoxdetected
     22  27000				   -	       lda	#$0
     23  27000				   -	       sta	SWACNT
     24  27000				   -	       lda	avoxdetected
     25  27000				   -	       rts
     26  27000				   -
     27  27000				   -detecthsc
     28  27000				   -			; check for the HSC ROM signature...
     29  27000				   -	       lda	XCTRL1s
     30  27000				   -	       ora	#%00001100
     31  27000				   -	       sta	XCTRL1s
     32  27000				   -	       sta	XCTRL1
     33  27000				   -
     34  27000				   -	       lda	$3900
     35  27000				   -	       eor	#$C6
     36  27000				   -	       bne	detecthscfail
     37  27000				   -	       lda	$3904
     38  27000				   -	       eor	#$FE
     39  27000				   -	       bne	detecthscfail
     40  27000				   -
     41  27000				   -			; check if it's initialized...
     42  27000				   -	       ldy	#0
     43  27000				   -	       lda	#$ff
     44  27000				   -checkhscinit
     45  27000				   -	       and	$1000,y
     46  27000				   -	       dey
     47  27000				   -	       bpl	checkhscinit
     48  27000				   -	       cmp	#$ff
     49  27000				   -	       bne	hscisalreadyinit
     50  27000				   -checkhscinit2
     51  27000				   -	       ora	$1000,y
     52  27000				   -	       dey
     53  27000				   -	       bpl	checkhscinit2
     54  27000				   -	       cmp	#0
     55  27000				   -	       bne	hscisalreadyinit
     56  27000				   -			; if we're here, we need to do a minimal HSC init...
     57  27000				   -	       ldy	#$28
     58  27000				   -hscinitloop1
     59  27000				   -	       lda	hscheader,y
     60  27000				   -	       sta	$1000,y
     61  27000				   -	       dey
     62  27000				   -	       bpl	hscinitloop1
     63  27000				   -	       ldy	#$89
     64  27000				   -	       lda	#$7F
     65  27000				   -hscinitloop2
     66  27000				   -	       sta	$10B3,y
     67  27000				   -	       dey
     68  27000				   -	       cpy	#$ff
     69  27000				   -	       bne	hscinitloop2
     70  27000				   -hscisalreadyinit
     71  27000				   -	       lda	#$ff
     72  27000				   -	       rts
     73  27000				   -hscheader
     74  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     75  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     76  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     77  27000				   -detecthscfail
     78  27000				   -	       lda	XCTRL1s
     79  27000				   -	       and	#%11110111
     80  27000				   -	       sta	XCTRL1s
     81  27000				   -	       lda	#0
     82  27000				   -	       rts
     83  27000				   -	       endif		; isBANKSETBANK
     84  27000				   -
     85  27000				   -	       ifnconst	hiscorefont
     86  27000				   -	       echo	""
     87  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     88  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     89  27000				   -	       echo	" has been omitted from this build."
     90  27000				   -	       echo	""
     91  27000				   -	       else		; hiscorefont
     92  27000				   -	       ifnconst	isBANKSETBANK
     93  27000				   -hscdrawscreen
     94  27000				   -
     95  27000				   -			; we use 20 lines on a 24 line display
     96  27000				   -			; HSSCOREY to dynamically centers based on
     97  27000				   -			;HSSCOREY = 0
     98  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     99  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
    100  27000				   -
    101  27000				   -	       ifconst	HSSCORESIZE
    102  27000				   -SCORESIZE  =	HSSCORESIZE
    103  27000				   -	       else
    104  27000				   -SCORESIZE  =	6
    105  27000				   -	       endif
    106  27000				   -
    107  27000				   -			;save shadow registers for later return...
    108  27000				   -	       lda	sCTRL
    109  27000				   -	       pha
    110  27000				   -	       lda	sCHARBASE
    111  27000				   -	       pha
    112  27000				   -
    113  27000				   -	       jsr	blacken320colors
    114  27000				   -	       jsr	drawoverwait
    115  27000				   -	       jsr	drawwait
    116  27000				   -	       jsr	hiscorecleardlmem
    117  27000				   -	       jsr	clearscreen
    118  27000				   -
    119  27000				   -	       lda	#$60
    120  27000				   -	       sta	charactermode
    121  27000				   -
    122  27000				   -			;set the character base to the HSC font
    123  27000				   -	       lda	#>hiscorefont
    124  27000				   -	       sta	CHARBASE
    125  27000				   -	       sta	sCHARBASE
    126  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    127  27000				   -	       sta	CTRL
    128  27000				   -	       sta	sCTRL
    129  27000				   -
    130  27000				   -	       lda	#60
    131  27000				   -	       sta	hsjoydebounce
    132  27000				   -
    133  27000				   -	       lda	#0
    134  27000				   -	       sta	hscursorx
    135  27000				   -	       sta	framecounter
    136  27000				   -
    137  27000				   -	       ifnconst	HSCOLORCHASESTART
    138  27000				   -	       lda	#$8D	; default is blue. why not?
    139  27000				   -	       else
    140  27000				   -	       lda	#HSCOLORCHASESTART
    141  27000				   -	       endif
    142  27000				   -	       sta	hscolorchaseindex
    143  27000				   -	       lda	#$0F
    144  27000				   -	       sta	P0C2	; base text is white
    145  27000				   -	       jsr	hschasecolors
    146  27000				   -
    147  27000				   -			; ** plot all of the initials
    148  27000				   -	       lda	#<HSRAMInitials
    149  27000				   -	       sta	temp1	; charmaplo
    150  27000				   -	       lda	#>HSRAMInitials
    151  27000				   -	       sta	temp2	; charmaphi
    152  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    153  27000				   -	       sta	temp3	; palette/width
    154  27000				   -	       lda	#104
    155  27000				   -	       sta	temp4	; X
    156  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    157  27000				   -	       sta	temp5	; Y
    158  27000				   -plothsinitialsloop
    159  27000				   -	       jsr	plotcharacters
    160  27000				   -	       clc
    161  27000				   -	       lda	temp3
    162  27000				   -	       adc	#32
    163  27000				   -	       sta	temp3
    164  27000				   -	       inc	temp5
    165  27000				   -	       if	WZONEHEIGHT = 8
    166  27000				   -	       inc	temp5
    167  27000				   -	       endif
    168  27000				   -	       clc
    169  27000				   -	       lda	#3
    170  27000				   -	       adc	temp1
    171  27000				   -	       sta	temp1
    172  27000				   -	       cmp	#(<(HSRAMInitials+15))
    173  27000				   -	       bcc	plothsinitialsloop
    174  27000				   -
    175  27000				   -	       ifconst	HSGAMENAMELEN
    176  27000				   -			;plot the game name...
    177  27000				   -	       lda	#<HSGAMENAMEtable
    178  27000				   -	       sta	temp1	; charmaplo
    179  27000				   -	       lda	#>HSGAMENAMEtable
    180  27000				   -	       sta	temp2	; charmaphi
    181  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    182  27000				   -	       sta	temp3	; palette/width
    183  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    184  27000				   -	       sta	temp4	; X
    185  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    186  27000				   -	       sta	temp5	; Y
    187  27000				   -	       jsr	plotcharacters
    188  27000				   -	       endif		; HSGAMENAMELEN
    189  27000				   -
    190  27000				   -			;plot "difficulty"...
    191  27000				   -	       ldy	gamedifficulty
    192  27000				   -	       ifnconst	HSNOLEVELNAMES
    193  27000				   -	       lda	highscoredifficultytextlo,y
    194  27000				   -	       sta	temp1
    195  27000				   -	       lda	highscoredifficultytexthi,y
    196  27000				   -	       sta	temp2
    197  27000				   -	       sec
    198  27000				   -	       lda	#32
    199  27000				   -	       sbc	highscoredifficultytextlen,y
    200  27000				   -	       sta	temp3	; palette/width
    201  27000				   -	       sec
    202  27000				   -	       lda	#40
    203  27000				   -	       sbc	highscoredifficultytextlen,y
    204  27000				   -	       asl
    205  27000				   -	       sta	temp4	; X
    206  27000				   -	       else
    207  27000				   -	       lda	#<HSHIGHSCOREStext
    208  27000				   -	       sta	temp1	; charmaplo
    209  27000				   -	       lda	#>HSHIGHSCOREStext
    210  27000				   -	       sta	temp2	; charmaphi
    211  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    212  27000				   -	       sta	temp3	; palette/width
    213  27000				   -	       lda	#(80-(11*2))
    214  27000				   -	       sta	temp4	; X
    215  27000				   -	       endif		; HSNOLEVELNAMES
    216  27000				   -
    217  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    218  27000				   -	       sta	temp5	; Y
    219  27000				   -	       jsr	plotcharacters
    220  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    221  27000				   -	       bne	carronwithscoreevaluation
    222  27000				   -	       jmp	donoscoreevaluation
    223  27000				   -carronwithscoreevaluation
    224  27000				   -	       dey
    225  27000				   -	       lda	highscorelabeltextlo,y
    226  27000				   -	       sta	temp1
    227  27000				   -	       lda	highscorelabeltexthi,y
    228  27000				   -	       sta	temp2
    229  27000				   -	       sec
    230  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    231  27000				   -	       sta	temp3	; palette/width
    232  27000				   -	       lda	highscorelabeladjust1,y
    233  27000				   -	       sta	temp4	; X
    234  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    235  27000				   -	       sta	temp5	; Y
    236  27000				   -	       jsr	plotcharacters
    237  27000				   -
    238  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    239  27000				   -	       dey
    240  27000				   -			;plot the current player score...
    241  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    242  27000				   -	       sta	temp3	; palette/width
    243  27000				   -	       lda	highscorelabeladjust2,y
    244  27000				   -	       sta	temp4	; X
    245  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    246  27000				   -	       sta	temp5	; Y
    247  27000				   -
    248  27000				   -	       lda	scorevarlo,y
    249  27000				   -	       sta	temp7	; score variable lo
    250  27000				   -	       lda	scorevarhi,y
    251  27000				   -	       sta	temp8	; score variable hi
    252  27000				   -
    253  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    254  27000				   -	       sta	temp9
    255  27000				   -
    256  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    257  27000				   -	       sta	temp1	; charmaplo
    258  27000				   -	       lda	#>(hiscorefont+33)
    259  27000				   -	       sta	temp2	; charmaphi
    260  27000				   -	       lda	#SCORESIZE
    261  27000				   -	       sta	temp6
    262  27000				   -	       ifnconst	DOUBLEWIDE
    263  27000				   -	       jsr	plotvalue
    264  27000				   -	       else
    265  27000				   -	       jsr	plotvaluedw
    266  27000				   -	       endif
    267  27000				   -
    268  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    269  27000				   -
    270  27000				   -	       ifconst	HSGAMERANKS
    271  27000				   -
    272  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    273  27000				   -comparescore2rankloop
    274  27000				   -	       inx
    275  27000				   -	       ldy	#0
    276  27000				   -	       lda	rankvalue_0,x
    277  27000				   -	       cmp	(temp7),y
    278  27000				   -	       bcc	score2rankloopdone
    279  27000				   -	       bne	comparescore2rankloop
    280  27000				   -	       iny
    281  27000				   -	       lda	rankvalue_1,x
    282  27000				   -	       cmp	(temp7),y
    283  27000				   -	       bcc	score2rankloopdone
    284  27000				   -	       bne	comparescore2rankloop
    285  27000				   -	       iny
    286  27000				   -	       lda	(temp7),y
    287  27000				   -	       cmp	rankvalue_2,x
    288  27000				   -	       bcs	score2rankloopdone
    289  27000				   -	       jmp	comparescore2rankloop
    290  27000				   -score2rankloopdone
    291  27000				   -	       stx	hsnewscorerank
    292  27000				   -
    293  27000				   -	       lda	ranklabello,x
    294  27000				   -	       sta	temp1
    295  27000				   -	       lda	ranklabelhi,x
    296  27000				   -	       sta	temp2
    297  27000				   -	       sec
    298  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    299  27000				   -	       sbc	ranklabellengths,x
    300  27000				   -	       sta	temp3	; palette/width
    301  27000				   -	       sec
    302  27000				   -	       lda	#(40+6)
    303  27000				   -	       sbc	ranklabellengths,x
    304  27000				   -	       asl
    305  27000				   -	       sta	temp4	; X
    306  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    307  27000				   -	       sta	temp5	; Y
    308  27000				   -	       jsr	plotcharacters
    309  27000				   -
    310  27000				   -	       ldx	hsnewscorerank
    311  27000				   -
    312  27000				   -	       lda	#<highscoreranklabel
    313  27000				   -	       sta	temp1
    314  27000				   -	       lda	#>highscoreranklabel
    315  27000				   -	       sta	temp2
    316  27000				   -
    317  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    318  27000				   -	       sta	temp3	; palette/width
    319  27000				   -	       lda	#(40-6)
    320  27000				   -	       sec
    321  27000				   -	       sbc	ranklabellengths,x
    322  27000				   -	       asl
    323  27000				   -	       sta	temp4	; X
    324  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    325  27000				   -	       sta	temp5	; Y
    326  27000				   -	       jsr	plotcharacters
    327  27000				   -	       endif		; HSGAMERANKS
    328  27000				   -
    329  27000				   -
    330  27000				   -			; ** which line did this player beat?
    331  27000				   -	       lda	#$ff
    332  27000				   -	       sta	hsnewscoreline
    333  27000				   -	       ldx	#$fd
    334  27000				   -comparescoreadd2x
    335  27000				   -	       inx
    336  27000				   -comparescoreadd1x
    337  27000				   -	       inx
    338  27000				   -comparescore2lineloop
    339  27000				   -	       inc	hsnewscoreline
    340  27000				   -	       inx		; initialrun, x=0
    341  27000				   -	       cpx	#15
    342  27000				   -	       beq	nohighscoreforyou
    343  27000				   -	       ldy	#0
    344  27000				   -	       lda	HSRAMScores,x
    345  27000				   -	       cmp	(temp7),y	; first score digit
    346  27000				   -	       bcc	score2lineloopdonedel1x
    347  27000				   -	       bne	comparescoreadd2x
    348  27000				   -	       iny
    349  27000				   -	       inx
    350  27000				   -	       lda	HSRAMScores,x
    351  27000				   -	       cmp	(temp7),y
    352  27000				   -	       bcc	score2lineloopdonedel2x
    353  27000				   -	       bne	comparescoreadd1x
    354  27000				   -	       iny
    355  27000				   -	       inx
    356  27000				   -	       lda	(temp7),y
    357  27000				   -	       cmp	HSRAMScores,x
    358  27000				   -	       bcs	score2lineloopdonedel3x
    359  27000				   -	       jmp	comparescore2lineloop
    360  27000				   -nohighscoreforyou
    361  27000				   -	       lda	#$ff
    362  27000				   -	       sta	hsnewscoreline
    363  27000				   -	       sta	countdownseconds
    364  27000				   -	       jmp	donoscoreevaluation
    365  27000				   -score2lineloopdonedel3x
    366  27000				   -	       dex
    367  27000				   -score2lineloopdonedel2x
    368  27000				   -	       dex
    369  27000				   -score2lineloopdonedel1x
    370  27000				   -	       dex
    371  27000				   -
    372  27000				   -			; 0 1 2
    373  27000				   -			; 3 4 5
    374  27000				   -			; 6 7 8
    375  27000				   -			; 9 0 1
    376  27000				   -			; 2 3 4
    377  27000				   -
    378  27000				   -	       stx	temp9
    379  27000				   -	       cpx	#11
    380  27000				   -	       beq	postsortscoresuploop
    381  27000				   -	       ldx	#11
    382  27000				   -sortscoresuploop
    383  27000				   -	       lda	HSRAMScores,x
    384  27000				   -	       sta	HSRAMScores+3,x
    385  27000				   -	       lda	HSRAMInitials,x
    386  27000				   -	       sta	HSRAMInitials+3,x
    387  27000				   -	       dex
    388  27000				   -	       cpx	temp9
    389  27000				   -	       bne	sortscoresuploop
    390  27000				   -postsortscoresuploop
    391  27000				   -
    392  27000				   -			;stick the score and cleared initials in the slot...
    393  27000				   -	       inx
    394  27000				   -	       ldy	#0
    395  27000				   -	       sty	hsinitialhold
    396  27000				   -	       lda	(temp7),y
    397  27000				   -	       sta	HSRAMScores,x
    398  27000				   -	       iny
    399  27000				   -	       lda	(temp7),y
    400  27000				   -	       sta	HSRAMScores+1,x
    401  27000				   -	       iny
    402  27000				   -	       lda	(temp7),y
    403  27000				   -	       sta	HSRAMScores+2,x
    404  27000				   -	       lda	#0
    405  27000				   -	       sta	HSRAMInitials,x
    406  27000				   -	       lda	#29
    407  27000				   -	       sta	HSRAMInitials+1,x
    408  27000				   -	       sta	HSRAMInitials+2,x
    409  27000				   -
    410  27000				   -	       stx	hsinitialpos
    411  27000				   -
    412  27000				   -	       ifconst	vox_highscore
    413  27000				   -	       lda	<#vox_highscore
    414  27000				   -	       sta	speech_addr
    415  27000				   -	       lda	>#vox_highscore
    416  27000				   -	       sta	speech_addr+1
    417  27000				   -	       endif		; vox_highscore
    418  27000				   -	       ifconst	sfx_highscore
    419  27000				   -	       lda	<#sfx_highscore
    420  27000				   -	       sta	temp1
    421  27000				   -	       lda	>#sfx_highscore
    422  27000				   -	       sta	temp2
    423  27000				   -	       lda	#0
    424  27000				   -	       sta	temp3
    425  27000				   -	       jsr	schedulesfx
    426  27000				   -	       endif		; sfx_highscore
    427  27000				   -	       ifconst	songdatastart_song_highscore
    428  27000				   -	       lda	#<songchanneltable_song_highscore
    429  27000				   -	       sta	songpointerlo
    430  27000				   -	       lda	#>songchanneltable_song_highscore
    431  27000				   -	       sta	songpointerhi
    432  27000				   -	       lda	#73
    433  27000				   -	       sta	songtempo
    434  27000				   -	       jsr	setsongchannels
    435  27000				   -	       endif		; songdatastart_song_highscore
    436  27000				   -
    437  27000				   -
    438  27000				   -donoscoreevaluation
    439  27000				   -
    440  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    441  27000				   -	       sta	temp3	; palette/width
    442  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    443  27000				   -	       sta	temp4	; X
    444  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    445  27000				   -	       sta	temp5	; Y
    446  27000				   -	       lda	#<HSRAMScores
    447  27000				   -	       sta	temp7	; score variable lo
    448  27000				   -	       lda	#>HSRAMScores
    449  27000				   -	       sta	temp8	; score variable hi
    450  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    451  27000				   -	       sta	temp9
    452  27000				   -plothsscoresloop
    453  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    454  27000				   -	       sta	temp1	; charmaplo
    455  27000				   -	       lda	#>(hiscorefont+33)
    456  27000				   -	       sta	temp2	; charmaphi
    457  27000				   -	       lda	#6
    458  27000				   -	       sta	temp6
    459  27000				   -	       ifnconst	DOUBLEWIDE
    460  27000				   -	       jsr	plotvalue
    461  27000				   -	       else
    462  27000				   -	       jsr	plotvaluedw
    463  27000				   -	       endif
    464  27000				   -	       clc
    465  27000				   -	       lda	temp3
    466  27000				   -	       adc	#32
    467  27000				   -	       sta	temp3
    468  27000				   -	       inc	temp5
    469  27000				   -	       if	WZONEHEIGHT = 8
    470  27000				   -	       inc	temp5
    471  27000				   -	       endif
    472  27000				   -	       clc
    473  27000				   -	       lda	#3
    474  27000				   -	       adc	temp7
    475  27000				   -	       sta	temp7
    476  27000				   -	       cmp	#(<(HSRAMScores+15))
    477  27000				   -	       bcc	plothsscoresloop
    478  27000				   -plothsindex
    479  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    480  27000				   -	       sta	temp3	; palette/width
    481  27000				   -	       lda	#44
    482  27000				   -	       sta	temp4	; X
    483  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    484  27000				   -	       sta	temp5	; Y
    485  27000				   -	       lda	#<hsgameslotnumbers
    486  27000				   -	       sta	temp7	; score variable lo
    487  27000				   -	       lda	#>hsgameslotnumbers
    488  27000				   -	       sta	temp8	; score variable hi
    489  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    490  27000				   -	       sta	temp9
    491  27000				   -plothsindexloop
    492  27000				   -	       lda	#<(hiscorefont+33)
    493  27000				   -	       sta	temp1	; charmaplo
    494  27000				   -	       lda	#>(hiscorefont+33)
    495  27000				   -	       sta	temp2	; charmaphi
    496  27000				   -	       lda	#1
    497  27000				   -	       sta	temp6	; number of characters
    498  27000				   -	       ifnconst	DOUBLEWIDE
    499  27000				   -	       jsr	plotvalue
    500  27000				   -	       else
    501  27000				   -	       jsr	plotvaluedw
    502  27000				   -	       endif
    503  27000				   -	       clc
    504  27000				   -	       lda	temp3
    505  27000				   -	       adc	#32
    506  27000				   -	       sta	temp3
    507  27000				   -	       inc	temp5
    508  27000				   -	       if	WZONEHEIGHT = 8
    509  27000				   -	       inc	temp5
    510  27000				   -	       endif
    511  27000				   -	       inc	temp7
    512  27000				   -	       lda	temp7
    513  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    514  27000				   -	       bcc	plothsindexloop
    515  27000				   -
    516  27000				   -	       jsr	savescreen
    517  27000				   -	       ifnconst	HSSECONDS
    518  27000				   -	       lda	#6
    519  27000				   -	       else
    520  27000				   -	       lda	#HSSECONDS
    521  27000				   -	       endif
    522  27000				   -
    523  27000				   -	       sta	countdownseconds
    524  27000				   -
    525  27000				   -keepdisplayinghs
    526  27000				   -	       jsr	restorescreen
    527  27000				   -
    528  27000				   -	       jsr	setuphsinpt1
    529  27000				   -
    530  27000				   -	       lda	hsnewscoreline
    531  27000				   -	       bpl	carryonkeepdisplayinghs
    532  27000				   -	       jmp	skipenterscorecontrol
    533  27000				   -carryonkeepdisplayinghs
    534  27000				   -
    535  27000				   -
    536  27000				   -	       ifnconst	HSSECONDS
    537  27000				   -	       lda	#6
    538  27000				   -	       else
    539  27000				   -	       lda	#HSSECONDS
    540  27000				   -	       endif
    541  27000				   -
    542  27000				   -	       sta	countdownseconds
    543  27000				   -
    544  27000				   -			;plot the "cursor" initial sprite...
    545  27000				   -	       lda	hsinitialhold
    546  27000				   -
    547  27000				   -	       sta	temp1
    548  27000				   -	       lda	#>(hiscorefont+32)
    549  27000				   -	       sta	temp2
    550  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    551  27000				   -	       sta	temp3	; palette/width
    552  27000				   -	       lda	hscursorx
    553  27000				   -	       asl
    554  27000				   -	       asl
    555  27000				   -	       clc
    556  27000				   -	       adc	#104
    557  27000				   -	       sta	temp4	; X
    558  27000				   -	       lda	hsnewscoreline
    559  27000				   -	       asl
    560  27000				   -	       asl
    561  27000				   -	       asl
    562  27000				   -	       asl
    563  27000				   -	       adc	#((3*16)+HSCURSORY)
    564  27000				   -	       sta	temp5	; Y
    565  27000				   -	       lda	#%01000000
    566  27000				   -	       sta	temp6
    567  27000				   -	       jsr	plotsprite
    568  27000				   -
    569  27000				   -	       ldx	hscursorx
    570  27000				   -	       ldy	hsdisplaymode
    571  27000				   -	       ifnconst	.HSup
    572  27000				   -	       lda	sSWCHA
    573  27000				   -	       cpy	#3
    574  27000				   -	       bne	hsskipadjustjoystick1
    575  27000				   -	       asl
    576  27000				   -	       asl
    577  27000				   -	       asl
    578  27000				   -	       asl
    579  27000				   -hsskipadjustjoystick1
    580  27000				   -	       sta	hsswcha
    581  27000				   -	       else		; there are user-defined routines!
    582  27000				   -	       jsr	.HSdown
    583  27000				   -	       lda	hsreturn	; b0
    584  27000				   -	       asl
    585  27000				   -	       pha
    586  27000				   -	       jsr	.HSup
    587  27000				   -	       pla
    588  27000				   -	       ora	hsreturn
    589  27000				   -	       asl
    590  27000				   -	       asl
    591  27000				   -	       asl
    592  27000				   -	       asl
    593  27000				   -	       eor	#$FF
    594  27000				   -	       sta	hsswcha
    595  27000				   -	       endif
    596  27000				   -	       lda	SWCHB
    597  27000				   -	       and	#%00000010
    598  27000				   -	       bne	hsskipselectswitch
    599  27000				   -	       lda	#%00010000
    600  27000				   -	       sta	hsswcha
    601  27000				   -	       bne	hsdodebouncecheck
    602  27000				   -hsskipselectswitch
    603  27000				   -	       lda	hsswcha
    604  27000				   -	       and	#%00110000
    605  27000				   -	       cmp	#%00110000
    606  27000				   -	       beq	hsjoystickskipped
    607  27000				   -hsdodebouncecheck
    608  27000				   -	       lda	hsjoydebounce
    609  27000				   -	       beq	hsdontdebounce
    610  27000				   -	       jmp	hspostjoystick
    611  27000				   -hsdontdebounce
    612  27000				   -	       ldx	#1	; small tick sound
    613  27000				   -	       jsr	playhssfx
    614  27000				   -	       lda	hsswcha
    615  27000				   -	       and	#%00110000
    616  27000				   -	       ldx	hscursorx
    617  27000				   -	       cmp	#%00100000	; check down
    618  27000				   -	       bne	hsjoycheckup
    619  27000				   -	       ldy	hsinitialhold
    620  27000				   -	       cpx	#0
    621  27000				   -	       bne	skipavoid31_1
    622  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    623  27000				   -	       bne	skipavoid31_1
    624  27000				   -	       dey
    625  27000				   -skipavoid31_1
    626  27000				   -	       dey
    627  27000				   -	       jmp	hssetdebounce
    628  27000				   -hsjoycheckup
    629  27000				   -	       cmp	#%00010000	; check up
    630  27000				   -	       bne	hsjoystickskipped
    631  27000				   -	       ldy	hsinitialhold
    632  27000				   -	       cpx	#0
    633  27000				   -	       bne	skipavoid31_2
    634  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    635  27000				   -	       bne	skipavoid31_2
    636  27000				   -	       iny
    637  27000				   -skipavoid31_2
    638  27000				   -	       iny
    639  27000				   -hssetdebounce
    640  27000				   -	       tya
    641  27000				   -	       and	#31
    642  27000				   -	       sta	hsinitialhold
    643  27000				   -	       lda	#15
    644  27000				   -	       sta	hsjoydebounce
    645  27000				   -	       bne	hspostjoystick
    646  27000				   -hsjoystickskipped
    647  27000				   -			; check the fire button only when the stick isn't engaged
    648  27000				   -	       lda	hsinpt1
    649  27000				   -	       bpl	hsbuttonskipped
    650  27000				   -	       lda	hsjoydebounce
    651  27000				   -	       bne	hspostjoystick
    652  27000				   -hsfiredontdebounce
    653  27000				   -	       lda	hsinitialhold
    654  27000				   -	       cmp	#31
    655  27000				   -	       beq	hsmovecursorback
    656  27000				   -	       inc	hscursorx
    657  27000				   -	       inc	hsinitialpos
    658  27000				   -	       lda	hscursorx
    659  27000				   -	       cmp	#3
    660  27000				   -	       bne	skiphsentryisdone
    661  27000				   -	       lda	#0
    662  27000				   -	       sta	framecounter
    663  27000				   -	       lda	#$ff
    664  27000				   -	       sta	hsnewscoreline
    665  27000				   -	       dec	hsinitialpos
    666  27000				   -	       bne	skiphsentryisdone
    667  27000				   -hsmovecursorback
    668  27000				   -	       lda	hscursorx
    669  27000				   -	       beq	skiphsmovecursorback
    670  27000				   -	       lda	#29
    671  27000				   -	       ldx	hsinitialpos
    672  27000				   -	       sta	HSRAMInitials,x
    673  27000				   -	       dec	hsinitialpos
    674  27000				   -	       dec	hscursorx
    675  27000				   -	       dex
    676  27000				   -	       lda	HSRAMInitials,x
    677  27000				   -	       sta	hsinitialhold
    678  27000				   -skiphsmovecursorback
    679  27000				   -skiphsentryisdone
    680  27000				   -	       ldx	#0
    681  27000				   -	       jsr	playhssfx
    682  27000				   -	       lda	#20
    683  27000				   -	       sta	hsjoydebounce
    684  27000				   -	       bne	hspostjoystick
    685  27000				   -
    686  27000				   -hsbuttonskipped
    687  27000				   -	       lda	#0
    688  27000				   -	       sta	hsjoydebounce
    689  27000				   -hspostjoystick
    690  27000				   -
    691  27000				   -	       ldx	hsinitialpos
    692  27000				   -	       lda	hsinitialhold
    693  27000				   -	       sta	HSRAMInitials,x
    694  27000				   -
    695  27000				   -	       jmp	skiphschasecolors
    696  27000				   -
    697  27000				   -skipenterscorecontrol
    698  27000				   -	       jsr	hschasecolors
    699  27000				   -	       jsr	setuphsinpt1
    700  27000				   -	       lda	hsjoydebounce
    701  27000				   -	       bne	skiphschasecolors
    702  27000				   -	       lda	hsinpt1
    703  27000				   -	       bmi	returnfromhs
    704  27000				   -skiphschasecolors
    705  27000				   -
    706  27000				   -	       jsr	drawscreen
    707  27000				   -
    708  27000				   -	       lda	countdownseconds
    709  27000				   -	       beq	returnfromhs
    710  27000				   -	       jmp	keepdisplayinghs
    711  27000				   -returnfromhs
    712  27000				   -
    713  27000				   -	       ifconst	songdatastart_song_highscore
    714  27000				   -	       lda	hsdisplaymode
    715  27000				   -	       beq	skipclearHSCsong
    716  27000				   -	       lda	#0
    717  27000				   -	       sta	songtempo
    718  27000				   -skipclearHSCsong
    719  27000				   -	       endif
    720  27000				   -	       jsr	drawwait
    721  27000				   -	       jsr	clearscreen
    722  27000				   -	       lda	#0
    723  27000				   -	       ldy	#7
    724  27000				   -	       jsr	blacken320colors
    725  27000				   -			;lda ssCHARBASE
    726  27000				   -	       pla
    727  27000				   -	       sta	sCHARBASE
    728  27000				   -			;lda ssCTRL
    729  27000				   -	       pla
    730  27000				   -	       sta	sCTRL
    731  27000				   -	       rts
    732  27000				   -
    733  27000				   -setuphsinpt1
    734  27000				   -	       lda	#$ff
    735  27000				   -	       sta	hsinpt1
    736  27000				   -	       lda	hsjoydebounce
    737  27000				   -	       beq	skipdebounceadjust
    738  27000				   -	       dec	hsjoydebounce
    739  27000				   -	       bne	skipstorefirebuttonstatus
    740  27000				   -skipdebounceadjust
    741  27000				   -	       lda	SWCHB
    742  27000				   -	       and	#%00000001
    743  27000				   -	       bne	hscheckresetover
    744  27000				   -	       lda	#$ff
    745  27000				   -	       sta	hsinpt1
    746  27000				   -	       rts
    747  27000				   -hscheckresetover
    748  27000				   -	       ifnconst	.HSup
    749  27000				   -	       ldx	hsdisplaymode
    750  27000				   -	       cpx	#3
    751  27000				   -	       bne	hsskipadjustjoyfire1
    752  27000				   -	       lda	sINPT3
    753  27000				   -	       jmp	hsskipadjustjoyfire1done
    754  27000				   -hsskipadjustjoyfire1
    755  27000				   -	       lda	sINPT1
    756  27000				   -hsskipadjustjoyfire1done
    757  27000				   -	       sta	hsinpt1
    758  27000				   -	       else		; there are user-defined routines!
    759  27000				   -	       jsr	.HSselect
    760  27000				   -	       lda	hsreturn
    761  27000				   -	       ror		; carry
    762  27000				   -	       ror		; b7
    763  27000				   -	       sta	hsinpt1
    764  27000				   -	       endif	.HSup
    765  27000				   -skipstorefirebuttonstatus
    766  27000				   -	       rts
    767  27000				   -
    768  27000				   -blacken320colors
    769  27000				   -	       ldy	#7
    770  27000				   -blacken320colorsloop
    771  27000				   -	       sta	P0C2,y
    772  27000				   -	       dey
    773  27000				   -	       bpl	blacken320colorsloop
    774  27000				   -	       rts
    775  27000				   -
    776  27000				   -hschasecolors
    777  27000				   -	       lda	framecounter
    778  27000				   -	       and	#3
    779  27000				   -	       bne	hschasecolorsreturn
    780  27000				   -	       inc	hscolorchaseindex
    781  27000				   -	       lda	hscolorchaseindex
    782  27000				   -
    783  27000				   -	       sta	P5C2
    784  27000				   -	       sbc	#$02
    785  27000				   -	       sta	P4C2
    786  27000				   -	       sbc	#$02
    787  27000				   -	       sta	P3C2
    788  27000				   -	       sbc	#$02
    789  27000				   -	       sta	P2C2
    790  27000				   -	       sbc	#$02
    791  27000				   -	       sta	P1C2
    792  27000				   -hschasecolorsreturn
    793  27000				   -	       rts
    794  27000				   -
    795  27000				   -playhssfx
    796  27000				   -	       lda	hssfx_lo,x
    797  27000				   -	       sta	temp1
    798  27000				   -	       lda	hssfx_hi,x
    799  27000				   -	       sta	temp2
    800  27000				   -	       lda	#0
    801  27000				   -	       sta	temp3
    802  27000				   -	       jmp	schedulesfx
    803  27000				   -
    804  27000				   -hssfx_lo
    805  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    806  27000				   -hssfx_hi
    807  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    808  27000				   -
    809  27000				   -sfx_hsletterpositionchange
    810  27000				   -	       .byte	$10,$18,$00
    811  27000				   -	       .byte	$02,$06,$08
    812  27000				   -	       .byte	$02,$06,$04
    813  27000				   -	       .byte	$00,$00,$00
    814  27000				   -sfx_hslettertick
    815  27000				   -	       .byte	$10,$18,$00
    816  27000				   -	       .byte	$00,$00,$0a
    817  27000				   -	       .byte	$00,$00,$00
    818  27000				   -
    819  27000				   -highscorelabeladjust1
    820  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    821  27000				   -highscorelabeladjust2
    822  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    823  27000				   -
    824  27000				   -scorevarlo
    825  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    826  27000				   -scorevarhi
    827  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    828  27000				   -
    829  27000				   -	       endif		; !isBANKSETBANK
    830  27000				   -
    831  27000				   -	       ifnconst	HSNOLEVELNAMES
    832  27000				   -	       ifnconst	isBANKSETBANK
    833  27000				   -highscoredifficultytextlo
    834  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    835  27000				   -highscoredifficultytexthi
    836  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    837  27000				   -	       endif		; !isBANKSETBANK
    838  27000				   -
    839  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    840  27000				   -	       ifnconst	isBANKSETBANK
    841  27000				   -highscoredifficultytextlen
    842  27000				   -	       .byte	22, 30, 26, 24
    843  27000				   -	       endif		; !isBANKSETBANK
    844  27000				   -
    845  27000				   -	       ifconst	HSCHARSHERE
    846  27000				   -
    847  27000				   -easylevelname
    848  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  27000				   -mediumlevelname
    850  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    851  27000				   -hardlevelname
    852  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    853  27000				   -expertlevelname
    854  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    855  27000				   -	       endif		; HSCHARSHERE
    856  27000				   -	       else		; HSCUSTOMLEVELNAMES
    857  27000				   -	       include	"7800hsgamediffnames.asm"
    858  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    859  27000				   -	       else		; HSNOLEVELNAMES
    860  27000				   -	       ifconst	HSCHARSHERE
    861  27000				   -HSHIGHSCOREStext
    862  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    863  27000				   -	       endif		; HSCHARSHERE
    864  27000				   -	       endif		; HSNOLEVELNAMES
    865  27000				   -
    866  27000				   -	       ifnconst	isBANKSETBANK
    867  27000				   -highscorelabeltextlo
    868  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    869  27000				   -highscorelabeltexthi
    870  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    871  27000				   -	       endif		; !isBANKSETBANK
    872  27000				   -
    873  27000				   -	       ifconst	HSCHARSHERE
    874  27000				   -player0label
    875  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    876  27000				   -
    877  27000				   -player1label
    878  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    879  27000				   -
    880  27000				   -player2label
    881  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    882  27000				   -	       endif		; HSCHARSHERE
    883  27000				   -
    884  27000				   -
    885  27000				   -	       ifconst	HSGAMENAMELEN
    886  27000				   -	       ifconst	HSCHARSHERE
    887  27000				   -HSGAMENAMEtable
    888  27000				   -	       include	"7800hsgamename.asm"
    889  27000				   -	       endif		; HSCHARSHERE
    890  27000				   -	       endif		; HSGAMENAMELEN
    891  27000				   -	       ifconst	HSGAMERANKS
    892  27000				   -	       include	"7800hsgameranks.asm"
    893  27000				   -	       ifconst	HSCHARSHERE
    894  27000				   -highscoreranklabel
    895  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    896  27000				   -	       endif		; HSCHARSHERE
    897  27000				   -	       endif		; HSGAMERANKS
    898  27000				   -
    899  27000				   -			;ensure our table doesn't wrap a page...
    900  27000				   -	       if	((<*)>251)
    901  27000				   -	       align	256
    902  27000				   -	       endif
    903  27000				   -hsgameslotnumbers
    904  27000				   -	       .byte	33,34,35,36,37
    905  27000				   -	       endif		; hiscorefont
    906  27000				   -
    907  27000				   -
    908  27000				   -	       ifnconst	isBANKSETBANK
    909  27000				   -loaddifficultytable
    910  27000				   -	       lda	gamedifficulty
    911  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    912  27000				   -	       sta	gamedifficulty
    913  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    914  27000				   -	       bne	loaddifficultytablecontinue1
    915  27000				   -	       rts		; this high score difficulty table is already loaded
    916  27000				   -loaddifficultytablecontinue1
    917  27000				   -	       lda	gamedifficulty
    918  27000				   -	       sta	hsdifficulty
    919  27000				   -			;we need to check the device for the table
    920  27000				   -	       lda	hsdevice
    921  27000				   -	       bne	loaddifficultytablecontinue2
    922  27000				   -			; there's no save device. clear out this table.
    923  27000				   -	       jmp	cleardifficultytablemem
    924  27000				   -loaddifficultytablecontinue2
    925  27000				   -	       lda	hsdevice
    926  27000				   -	       and	#1
    927  27000				   -	       beq	memdeviceisntHSC
    928  27000				   -	       jmp	loaddifficultytableHSC
    929  27000				   -memdeviceisntHSC
    930  27000				   -	       jmp	loaddifficultytableAVOX
    931  27000				   -
    932  27000				   -savedifficultytable
    933  27000				   -			;*** we need to check which device we should use...
    934  27000				   -	       lda	hsdevice
    935  27000				   -	       bne	savedifficultytablerealdevice
    936  27000				   -	       rts		; its a ram device
    937  27000				   -savedifficultytablerealdevice
    938  27000				   -	       and	#1
    939  27000				   -	       beq	savememdeviceisntHSC
    940  27000				   -	       jmp	savedifficultytableHSC
    941  27000				   -savememdeviceisntHSC
    942  27000				   -	       jmp	savedifficultytableAVOX
    943  27000				   -
    944  27000				   -savedifficultytableAVOX
    945  27000				   -			; the load call already setup the memory structure and atarivox memory location
    946  27000				   -	       jsr	savealoadedHSCtablecontinue
    947  27000				   -savedifficultytableAVOXskipconvert
    948  27000				   -	       lda	#HSIDHI
    949  27000				   -	       sta	eeprombuffer
    950  27000				   -	       lda	#HSIDLO
    951  27000				   -	       sta	eeprombuffer+1
    952  27000				   -	       lda	hsdifficulty
    953  27000				   -	       sta	eeprombuffer+2
    954  27000				   -	       lda	#32
    955  27000				   -	       jsr	AVoxWriteBytes
    956  27000				   -	       rts
    957  27000				   -
    958  27000				   -savedifficultytableHSC
    959  27000				   -			;we always load a table before reaching here, so the
    960  27000				   -			;memory structures from the load should be intact...
    961  27000				   -	       ldy	hsgameslot
    962  27000				   -	       bpl	savealoadedHSCtable
    963  27000				   -	       rts
    964  27000				   -savealoadedHSCtable
    965  27000				   -	       lda	HSCGameDifficulty,y
    966  27000				   -	       cmp	#$7F
    967  27000				   -	       bne	savealoadedHSCtablecontinue
    968  27000				   -	       jsr	initializeHSCtableentry
    969  27000				   -savealoadedHSCtablecontinue
    970  27000				   -			;convert our RAM table to HSC format and write it out...
    971  27000				   -	       ldy	#0
    972  27000				   -	       ldx	#0
    973  27000				   -savedifficultytableScores
    974  27000				   -
    975  27000				   -	       lda	HSRAMInitials,x
    976  27000				   -	       sta	temp3
    977  27000				   -	       lda	HSRAMInitials+1,x
    978  27000				   -	       sta	temp4
    979  27000				   -	       lda	HSRAMInitials+2,x
    980  27000				   -	       sta	temp5
    981  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    982  27000				   -
    983  27000				   -	       lda	temp1
    984  27000				   -	       sta	(HSGameTableLo),y
    985  27000				   -	       iny
    986  27000				   -	       lda	temp2
    987  27000				   -	       sta	(HSGameTableLo),y
    988  27000				   -	       iny
    989  27000				   -
    990  27000				   -	       lda	HSRAMScores,x
    991  27000				   -	       sta	(HSGameTableLo),y
    992  27000				   -	       iny
    993  27000				   -	       lda	HSRAMScores+1,x
    994  27000				   -	       sta	(HSGameTableLo),y
    995  27000				   -	       iny
    996  27000				   -	       lda	HSRAMScores+2,x
    997  27000				   -	       sta	(HSGameTableLo),y
    998  27000				   -	       iny
    999  27000				   -	       inx
   1000  27000				   -	       inx
   1001  27000				   -	       inx		; +3
   1002  27000				   -	       cpx	#15
   1003  27000				   -	       bne	savedifficultytableScores
   1004  27000				   -	       rts
   1005  27000				   -
   1006  27000				   -loaddifficultytableHSC
   1007  27000				   -			; routine responsible for loading the difficulty table from HSC
   1008  27000				   -	       jsr	findindexHSC
   1009  27000				   -	       ldy	hsgameslot
   1010  27000				   -	       lda	HSCGameDifficulty,y
   1011  27000				   -	       cmp	#$7F
   1012  27000				   -	       bne	loaddifficultytableHSCcontinue
   1013  27000				   -			;there was an error. use a new RAM table instead...
   1014  27000				   -	       jsr	initializeHSCtableentry
   1015  27000				   -	       jmp	cleardifficultytablemem
   1016  27000				   -loaddifficultytableHSCcontinue
   1017  27000				   -			; parse the data into the HS memory...
   1018  27000				   -	       ldy	#0
   1019  27000				   -	       ldx	#0
   1020  27000				   -loaddifficultytableScores
   1021  27000				   -	       lda	(HSGameTableLo),y
   1022  27000				   -	       sta	temp1
   1023  27000				   -	       iny
   1024  27000				   -	       lda	(HSGameTableLo),y
   1025  27000				   -	       sta	temp2
   1026  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1027  27000				   -	       iny
   1028  27000				   -	       lda	(HSGameTableLo),y
   1029  27000				   -	       sta	HSRAMScores,x
   1030  27000				   -	       lda	temp3
   1031  27000				   -	       sta	HSRAMInitials,x
   1032  27000				   -	       inx
   1033  27000				   -	       iny
   1034  27000				   -	       lda	(HSGameTableLo),y
   1035  27000				   -	       sta	HSRAMScores,x
   1036  27000				   -	       lda	temp4
   1037  27000				   -	       sta	HSRAMInitials,x
   1038  27000				   -	       inx
   1039  27000				   -	       iny
   1040  27000				   -	       lda	(HSGameTableLo),y
   1041  27000				   -	       sta	HSRAMScores,x
   1042  27000				   -	       lda	temp5
   1043  27000				   -	       sta	HSRAMInitials,x
   1044  27000				   -	       inx
   1045  27000				   -	       iny
   1046  27000				   -	       cpx	#15
   1047  27000				   -	       bne	loaddifficultytableScores
   1048  27000				   -	       ldx	#14
   1049  27000				   -	       lda	#$ff
   1050  27000				   -validatescoresloop
   1051  27000				   -	       and	HSRAMScores,x
   1052  27000				   -	       dex
   1053  27000				   -	       bpl	validatescoresloop
   1054  27000				   -	       cmp	#$ff
   1055  27000				   -	       bne	exitloaddifficultytableScores
   1056  27000				   -	       jmp	cleardifficultytablemem
   1057  27000				   -exitloaddifficultytableScores
   1058  27000				   -	       rts
   1059  27000				   -
   1060  27000				   -decodeHSCInitials
   1061  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1062  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1063  27000				   -	       lda	#0
   1064  27000				   -	       sta	temp4
   1065  27000				   -	       lda	temp1
   1066  27000				   -	       and	#%00011111
   1067  27000				   -	       sta	temp3
   1068  27000				   -
   1069  27000				   -	       lda	temp2
   1070  27000				   -	       and	#%00011111
   1071  27000				   -	       sta	temp5
   1072  27000				   -
   1073  27000				   -	       lda	temp1
   1074  27000				   -	       asl
   1075  27000				   -	       rol	temp4
   1076  27000				   -	       asl
   1077  27000				   -	       rol	temp4
   1078  27000				   -	       asl
   1079  27000				   -	       rol	temp4
   1080  27000				   -	       lda	temp2
   1081  27000				   -	       asl
   1082  27000				   -	       rol	temp4
   1083  27000				   -	       asl
   1084  27000				   -	       rol	temp4
   1085  27000				   -	       rts
   1086  27000				   -encodeHSCInitials
   1087  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1088  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1089  27000				   -			; start with packing temp1...
   1090  27000				   -	       lda	temp4
   1091  27000				   -	       and	#%00011100
   1092  27000				   -	       sta	temp1
   1093  27000				   -	       asl	temp1
   1094  27000				   -	       asl	temp1
   1095  27000				   -	       asl	temp1
   1096  27000				   -	       lda	temp3
   1097  27000				   -	       and	#%00011111
   1098  27000				   -	       ora	temp1
   1099  27000				   -	       sta	temp1
   1100  27000				   -			; ...temp1 is now packed, on to temp2...
   1101  27000				   -	       lda	temp5
   1102  27000				   -	       asl
   1103  27000				   -	       asl
   1104  27000				   -	       ror	temp4
   1105  27000				   -	       ror
   1106  27000				   -	       ror	temp4
   1107  27000				   -	       ror
   1108  27000				   -	       sta	temp2
   1109  27000				   -	       rts
   1110  27000				   -
   1111  27000				   -findindexHSCerror
   1112  27000				   -			;the HSC is stuffed. return the bad slot flag
   1113  27000				   -	       ldy	#$ff
   1114  27000				   -	       sty	hsgameslot
   1115  27000				   -	       rts
   1116  27000				   -
   1117  27000				   -findindexHSC
   1118  27000				   -HSCGameID1 =	$1029
   1119  27000				   -HSCGameID2 =	$106E
   1120  27000				   -HSCGameDifficulty =	$10B3
   1121  27000				   -HSCGameIndex =	$10F8
   1122  27000				   -			; routine responsible for finding the game index from HSC
   1123  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1124  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1125  27000				   -	       ldy	#69	; start +1 to account for the dey
   1126  27000				   -findindexHSCloop
   1127  27000				   -	       dey
   1128  27000				   -	       bmi	findindexHSCerror
   1129  27000				   -	       lda	HSCGameDifficulty,y
   1130  27000				   -	       cmp	#$7F
   1131  27000				   -	       beq	findourindexHSC
   1132  27000				   -	       cmp	gamedifficulty
   1133  27000				   -	       bne	findindexHSCloop
   1134  27000				   -	       lda	HSCGameID1,y
   1135  27000				   -	       cmp	#HSIDHI
   1136  27000				   -	       bne	findindexHSCloop
   1137  27000				   -	       lda	HSCGameID2,y
   1138  27000				   -	       cmp	#HSIDLO
   1139  27000				   -	       bne	findindexHSCloop
   1140  27000				   -findourindexHSC
   1141  27000				   -			; if we're here we found our index in the table
   1142  27000				   -			; or we found the first empty one
   1143  27000				   -	       sty	hsgameslot
   1144  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1145  27000				   -	       rts
   1146  27000				   -
   1147  27000				   -
   1148  27000				   -initializeHSCtableentry
   1149  27000				   -	       ldy	hsgameslot
   1150  27000				   -			; we need to make a new entry...
   1151  27000				   -	       lda	#HSIDHI
   1152  27000				   -	       sta	HSCGameID1,y
   1153  27000				   -	       lda	#HSIDLO
   1154  27000				   -	       sta	HSCGameID2,y
   1155  27000				   -	       lda	gamedifficulty
   1156  27000				   -	       sta	HSCGameDifficulty,y
   1157  27000				   -	       ldx	#0
   1158  27000				   -fixHSDGameDifficultylistLoop
   1159  27000				   -	       inx
   1160  27000				   -	       txa
   1161  27000				   -	       sta	HSCGameIndex,y
   1162  27000				   -	       iny
   1163  27000				   -	       cpy	#69
   1164  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1165  27000				   -	       rts
   1166  27000				   -
   1167  27000				   -setupHSCGamepointer
   1168  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1169  27000				   -	       lda	#$17
   1170  27000				   -	       sta	HSGameTableHi
   1171  27000				   -	       lda	#$FA
   1172  27000				   -	       sta	HSGameTableLo
   1173  27000				   -setupHSCGamepointerLoop
   1174  27000				   -	       lda	HSGameTableLo
   1175  27000				   -	       sec
   1176  27000				   -	       sbc	#25
   1177  27000				   -	       sta	HSGameTableLo
   1178  27000				   -	       lda	HSGameTableHi
   1179  27000				   -	       sbc	#0
   1180  27000				   -	       sta	HSGameTableHi
   1181  27000				   -	       iny
   1182  27000				   -	       cpy	#69
   1183  27000				   -	       bne	setupHSCGamepointerLoop
   1184  27000				   -	       rts
   1185  27000				   -
   1186  27000				   -loaddifficultytableAVOX
   1187  27000				   -			; routine responsible for loading the difficulty table from Avox
   1188  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1189  27000				   -	       lda	#>(eeprombuffer+3)
   1190  27000				   -	       sta	HSGameTableHi
   1191  27000				   -	       lda	#<(eeprombuffer+3)
   1192  27000				   -	       sta	HSGameTableLo
   1193  27000				   -
   1194  27000				   -			; the start location in EEPROM, subtract 32...
   1195  27000				   -	       lda	#$5F
   1196  27000				   -	       sta	HSVoxHi
   1197  27000				   -	       lda	#$E0
   1198  27000				   -	       sta	HSVoxLo
   1199  27000				   -	       lda	#0
   1200  27000				   -	       sta	temp1
   1201  27000				   -loaddifficultytableAVOXloop
   1202  27000				   -	       inc	temp1
   1203  27000				   -	       beq	loaddifficultytableAVOXfull
   1204  27000				   -	       clc
   1205  27000				   -	       lda	HSVoxLo
   1206  27000				   -	       adc	#32
   1207  27000				   -	       sta	HSVoxLo
   1208  27000				   -	       lda	HSVoxHi
   1209  27000				   -	       adc	#0
   1210  27000				   -	       sta	HSVoxHi
   1211  27000				   -	       lda	#3
   1212  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1213  27000				   -	       lda	eeprombuffer
   1214  27000				   -	       cmp	#$FF
   1215  27000				   -	       beq	loaddifficultytableAVOXempty
   1216  27000				   -	       cmp	#HSIDHI
   1217  27000				   -	       bne	loaddifficultytableAVOXloop
   1218  27000				   -	       lda	eeprombuffer+1
   1219  27000				   -	       cmp	#HSIDLO
   1220  27000				   -	       bne	loaddifficultytableAVOXloop
   1221  27000				   -	       lda	eeprombuffer+2
   1222  27000				   -	       cmp	gamedifficulty
   1223  27000				   -	       bne	loaddifficultytableAVOXloop
   1224  27000				   -loaddifficultytableAVOXdone
   1225  27000				   -	       lda	#32
   1226  27000				   -	       jsr	AVoxReadBytes
   1227  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1228  27000				   -	       rts
   1229  27000				   -loaddifficultytableAVOXfull
   1230  27000				   -	       lda	#0
   1231  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1232  27000				   -loaddifficultytableAVOXempty
   1233  27000				   -	       jmp	cleardifficultytablemem
   1234  27000				   -	       rts
   1235  27000				   -
   1236  27000				   -cleardifficultytablemem
   1237  27000				   -	       ldy	#29
   1238  27000				   -	       lda	#0
   1239  27000				   -cleardifficultytablememloop
   1240  27000				   -	       sta	HSRAMTable,y
   1241  27000				   -	       dey
   1242  27000				   -	       bpl	cleardifficultytablememloop
   1243  27000				   -	       rts
   1244  27000				   -hiscoremoduleend
   1245  27000				   -
   1246  27000				   -hiscorecleardlmem
   1247  27000				   -	       ldx	#(WZONECOUNT-1)
   1248  27000				   -hiscorecleardlmemloop1
   1249  27000				   -	       lda	DLPOINTL,x
   1250  27000				   -	       sta	dlpnt
   1251  27000				   -	       lda	DLPOINTH,x
   1252  27000				   -	       sta	dlpnt+1
   1253  27000				   -	       lda	#0
   1254  27000				   -	       ldy	#17
   1255  27000				   -hiscorecleardlmemloop2
   1256  27000				   -	       sta	(dlpnt),y
   1257  27000				   -	       dey
   1258  27000				   -	       bpl	hiscorecleardlmemloop2
   1259  27000				   -	       dex
   1260  27000				   -	       bpl	hiscorecleardlmemloop1
   1261  27000				   -	       rts
   1262  27000				   -
   1263  27000				   -	       ifconst	DOUBLEWIDE
   1264  27000				   -plotvaluedw
   1265  27000				   -plotdigitcount =	temp6
   1266  27000				   -	       lda	#0
   1267  27000				   -	       tay
   1268  27000				   -	       ldx	valbufend
   1269  27000				   -
   1270  27000				   -	       lda	plotdigitcount
   1271  27000				   -	       and	#1
   1272  27000				   -	       beq	pvnibble2chardw
   1273  27000				   -	       lda	#0
   1274  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1275  27000				   -	       beq	pvnibble2char_skipnibbledw
   1276  27000				   -
   1277  27000				   -pvnibble2chardw
   1278  27000				   -			; high nibble...
   1279  27000				   -	       lda	(temp7),y
   1280  27000				   -	       and	#$f0
   1281  27000				   -	       lsr
   1282  27000				   -	       lsr
   1283  27000				   -	       lsr
   1284  27000				   -	       lsr
   1285  27000				   -
   1286  27000				   -	       clc
   1287  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1288  27000				   -	       sta	VALBUFFER,x
   1289  27000				   -	       inx
   1290  27000				   -	       dec	plotdigitcount
   1291  27000				   -pvnibble2char_skipnibbledw
   1292  27000				   -			; low nibble...
   1293  27000				   -	       lda	(temp7),y
   1294  27000				   -	       and	#$0f
   1295  27000				   -	       clc
   1296  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1297  27000				   -	       sta	VALBUFFER,x
   1298  27000				   -	       inx
   1299  27000				   -	       iny
   1300  27000				   -
   1301  27000				   -	       dec	plotdigitcount
   1302  27000				   -	       bne	pvnibble2chardw
   1303  27000				   -			;point to the start of our valuebuffer
   1304  27000				   -	       clc
   1305  27000				   -	       lda	#<VALBUFFER
   1306  27000				   -	       adc	valbufend
   1307  27000				   -	       sta	temp1
   1308  27000				   -	       lda	#>VALBUFFER
   1309  27000				   -	       adc	#0
   1310  27000				   -	       sta	temp2
   1311  27000				   -
   1312  27000				   -			;advance valbufend to the end of our value buffer
   1313  27000				   -	       stx	valbufend
   1314  27000				   -
   1315  27000				   -	       ifnconst	plotvalueonscreen
   1316  27000				   -	       jmp	plotcharacters
   1317  27000				   -	       else
   1318  27000				   -	       jmp	plotcharacterslive
   1319  27000				   -	       endif
   1320  27000				   -	       endif		; DOUBLEWIDE
   1321  27000				   -
   1322  27000				   -hiscoreend
   1323  27000				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1324  27000				   -	       endif		; !isBANKSETBANK
   1325  27000					       endif		; HSSUPPORT
   1326  27000
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4296  27000					       endif
   4297  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes of rom)"
     58  27000				   -
     59  27000					       endif
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4299  27000					       endif
   4300  27000					       ifnconst	included.plotsprite4.asm
------- FILE plotsprite4.asm LEVEL 2 PASS 3
      0  27000					       include	plotsprite4.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	PLOTSP4
      4  27000				   -
      5  27000				   -plotsprite4
      6  27000				   -	       ifnconst	NODRAWWAIT
      7  27000				   -	       ifconst	DOUBLEBUFFER
      8  27000				   -	       lda	doublebufferstate
      9  27000				   -	       bne	skipplotsprite4wait
     10  27000				   -	       endif		; DOUBLEBUFFER
     11  27000				   -	       ifconst	DEBUGWAITCOLOR
     12  27000				   -	       lda	#$41
     13  27000				   -	       sta	BACKGRND
     14  27000				   -	       endif
     15  27000				   -plotsprite4wait
     16  27000				   -	       lda	visibleover
     17  27000				   -	       bne	plotsprite4wait
     18  27000				   -skipplotsprite4wait
     19  27000				   -	       ifconst	DEBUGWAITCOLOR
     20  27000				   -	       lda	#$0
     21  27000				   -	       sta	BACKGRND
     22  27000				   -	       endif
     23  27000				   -	       endif
     24  27000				   -
     25  27000				   -			;arguments:
     26  27000				   -			; temp1=lo graphicdata
     27  27000				   -			; temp2=hi graphicdata
     28  27000				   -			; temp3=palette | width byte
     29  27000				   -			; temp4=x
     30  27000				   -			; temp5=y
     31  27000				   -
     32  27000				   -	       lda	temp5	;Y position
     33  27000				   -	       lsr		; 2 - Divide by 8 or 16
     34  27000				   -	       lsr		; 2
     35  27000				   -	       lsr		; 2
     36  27000				   -	       if	WZONEHEIGHT = 16
     37  27000				   -	       lsr		; 2
     38  27000				   -	       endif
     39  27000				   -
     40  27000				   -	       tax
     41  27000				   -
     42  27000				   -	       ifnconst	NOLIMITCHECKING
     43  27000				   -
     44  27000				   -			; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
     45  27000				   -
     46  27000				   -	       cmp	#WZONECOUNT
     47  27000				   -
     48  27000				   -	       bcc	continueplotsprite41	; the sprite is fully on-screen, so carry on...
     49  27000				   -			; otherwise, check to see if the bottom half is in zone 0...
     50  27000				   -
     51  27000				   -	       if	WZONEHEIGHT = 16
     52  27000				   -	       cmp	#15
     53  27000				   -	       else
     54  27000				   -	       cmp	#31
     55  27000				   -	       endif
     56  27000				   -
     57  27000				   -	       bne	exitplotsprite41
     58  27000				   -	       ldx	#0
     59  27000				   -	       jmp	continueplotsprite42
     60  27000				   -exitplotsprite41
     61  27000				   -	       rts
     62  27000				   -	       endif
     63  27000				   -
     64  27000				   -continueplotsprite41
     65  27000				   -
     66  27000				   -	       ifconst	VSCROLL
     67  27000				   -	       ldy	Xx3,x
     68  27000				   -	       lda	DLLMEM+11,y
     69  27000				   -	       else		; !VSCROLL
     70  27000				   -	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
     71  27000				   -	       endif		; !VSCROLL
     72  27000				   -	       ifconst	DOUBLEBUFFER
     73  27000				   -	       clc
     74  27000				   -	       adc	doublebufferdloffset
     75  27000				   -	       endif		; DOUBLEBUFFER
     76  27000				   -	       sta	dlpnt
     77  27000				   -	       ifconst	VSCROLL
     78  27000				   -	       lda	DLLMEM+10,y
     79  27000				   -	       else		; !VSCROLL
     80  27000				   -	       lda	DLPOINTH,x
     81  27000				   -	       endif		; !VSCROLL
     82  27000				   -	       ifconst	DOUBLEBUFFER
     83  27000				   -	       adc	#0
     84  27000				   -	       endif		; DOUBLEBUFFER
     85  27000				   -	       sta	dlpnt+1
     86  27000				   -
     87  27000				   -			;Create DL entry for upper part of sprite
     88  27000				   -
     89  27000				   -	       ldy	dlend,x	;Get the index to the end of this DL
     90  27000				   -
     91  27000				   -	       ifconst	CHECKOVERWRITE
     92  27000				   -	       cpy	#DLLASTOBJ
     93  27000				   -	       beq	checkcontinueplotsprite42
     94  27000				   -continueplotsprite41a
     95  27000				   -	       endif
     96  27000				   -
     97  27000				   -	       lda	temp1	; graphic data, lo byte
     98  27000				   -	       sta	(dlpnt),y	;Low byte of data address
     99  27000				   -
    100  27000				   -	       iny
    101  27000				   -	       lda	temp3	;palette|width
    102  27000				   -	       sta	(dlpnt),y
    103  27000				   -
    104  27000				   -	       iny
    105  27000				   -	       lda	temp5	;Y position
    106  27000				   -	       and	#(WZONEHEIGHT - 1)
    107  27000				   -	       cmp	#1	; clear carry if our sprite is just in this zone
    108  27000				   -	       ora	temp2	; graphic data, hi byte
    109  27000				   -	       sta	(dlpnt),y
    110  27000				   -
    111  27000				   -	       iny
    112  27000				   -	       lda	temp4	;Horizontal position
    113  27000				   -	       sta	(dlpnt),y
    114  27000				   -
    115  27000				   -	       iny
    116  27000				   -	       sty	dlend,x
    117  27000				   -
    118  27000				   -	       ifconst	ALWAYSTERMINATE
    119  27000				   -	       iny
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	(dlpnt),y
    122  27000				   -	       endif
    123  27000				   -
    124  27000				   -checkcontinueplotsprite42
    125  27000				   -
    126  27000				   -	       bcc	doneSPDL4	;branch if the sprite was fully in the last zone
    127  27000				   -
    128  27000				   -			;Create DL entry for lower part of sprite
    129  27000				   -
    130  27000				   -	       inx		;Next region
    131  27000				   -
    132  27000				   -	       ifnconst	NOLIMITCHECKING
    133  27000				   -	       cpx	#WZONECOUNT
    134  27000				   -
    135  27000				   -	       bcc	continueplotsprite42	; the second half of the sprite is fully on-screen, so carry on...
    136  27000				   -	       rts
    137  27000				   -continueplotsprite42
    138  27000				   -	       endif
    139  27000				   -
    140  27000				   -	       ifconst	VSCROLL
    141  27000				   -	       ldy	Xx3,x
    142  27000				   -	       lda	DLLMEM+11,y
    143  27000				   -	       else		; !VSCROLL
    144  27000				   -	       lda	DLPOINTL,x	;Get pointer to next DL
    145  27000				   -	       endif		; !VSCROLL
    146  27000				   -	       ifconst	DOUBLEBUFFER
    147  27000				   -	       clc
    148  27000				   -	       adc	doublebufferdloffset
    149  27000				   -	       endif		; DOUBLEBUFFER
    150  27000				   -	       sta	dlpnt
    151  27000				   -	       ifconst	VSCROLL
    152  27000				   -	       lda	DLLMEM+10,y
    153  27000				   -	       else		; !VSCROLL
    154  27000				   -	       lda	DLPOINTH,x
    155  27000				   -	       endif		; !VSCROLL
    156  27000				   -	       ifconst	DOUBLEBUFFER
    157  27000				   -	       adc	#0
    158  27000				   -	       endif		; DOUBLEBUFFER
    159  27000				   -	       sta	dlpnt+1
    160  27000				   -	       ldy	dlend,x	;Get the index to the end of this DL
    161  27000				   -
    162  27000				   -	       ifconst	CHECKOVERWRITE
    163  27000				   -	       cpy	#DLLASTOBJ
    164  27000				   -	       bne	continueplotsprite42a
    165  27000				   -	       rts
    166  27000				   -continueplotsprite42a
    167  27000				   -	       endif
    168  27000				   -
    169  27000				   -	       lda	temp1	; graphic data, lo byte
    170  27000				   -	       sta	(dlpnt),y
    171  27000				   -
    172  27000				   -	       iny
    173  27000				   -	       lda	temp3	;palette|width
    174  27000				   -	       sta	(dlpnt),y
    175  27000				   -
    176  27000				   -	       iny
    177  27000				   -	       lda	temp5	;Y position
    178  27000				   -	       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
    179  27000				   -	       ora	temp2	; graphic data, hi byte
    180  27000				   -	       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
    181  27000				   -	       sta	(dlpnt),y
    182  27000				   -
    183  27000				   -	       iny
    184  27000				   -	       lda	temp4	;Horizontal position
    185  27000				   -	       sta	(dlpnt),y
    186  27000				   -
    187  27000				   -	       iny
    188  27000				   -	       sty	dlend,x
    189  27000				   -
    190  27000				   -	       ifconst	ALWAYSTERMINATE
    191  27000				   -	       iny
    192  27000				   -	       lda	#0
    193  27000				   -	       sta	(dlpnt),y
    194  27000				   -	       endif
    195  27000				   -
    196  27000				   -doneSPDL4
    197  27000				   -	       rts
    198  27000				   -
    199  27000					       endif		; PLOTSP4
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4302  27000					       endif
   4303  27000					       ifnconst	included.lzsa1compression.asm
------- FILE lzsa1compression.asm LEVEL 2 PASS 3
      0  27000					       include	lzsa1compression.asm
      1  27000							; ***************************************************************************
      2  27000							; ***************************************************************************
      3  27000							;
      4  27000							; lzsa1_6502.s
      5  27000							;
      6  27000							; NMOS 6502 decompressor for data stored in Emmanuel Marty's LZSA1 format.
      7  27000							;
      8  27000							; Decompresses a raw LZSA1 block, created with the command-line lzsa utility:
      9  27000							;     lzsa -r <original_file> <compressed_file>
     10  27000							;
     11  27000							; in:
     12  27000							; * LZSA_SRC_LO and LZSA_SRC_HI contain the compressed raw block address
     13  27000							; * LZSA_DST_LO and LZSA_DST_HI contain the destination buffer address
     14  27000							;
     15  27000							; out:
     16  27000							; * the destination buffer will contain the decompressed data
     17  27000							; * LZSA_DST_LO and LZSA_DST_HI contain the last decompressed byte address +1
     18  27000							;
     19  27000							; ***************************************************************************
     20  27000							;
     21  27000							; This code is written for the ACME assembler.
     22  27000							;
     23  27000							; The code is 165 bytes for the small version, and 191 bytes for the normal.
     24  27000							;
     25  27000							; Copyright John Brandwood 2021.
     26  27000							;
     27  27000							; Changes intruduced by Mike Saarna, 2023:
     28  27000							;    -converted to DASM format.
     29  27000							;    -generalised memory locations, for easier incorporation into 7800basic
     30  27000							;    -removed self-modifying code, for execution from rom.
     31  27000							;    -added LZSAFASTCOPYBYTE optimisation ; +24 bytes rom, ~10% quicker
     32  27000							;
     33  27000							; get the original unmodified code from:
     34  27000							; https://raw.githubusercontent.com/emmanuel-marty/lzsa
     35  27000							;
     36  27000							; Distributed under the Boost Software License, Version 1.0.
     37  27000							; (See accompanying file LICENSE_1_0.txt or copy at
     38  27000							; http://www.boost.org/LICENSE_1_0.txt)
     39  27000							;
     40  27000							; ***************************************************************************
     41  27000							; ***************************************************************************
     42  27000
     43  27000
     44  27000
     45  27000							; ***************************************************************************
     46  27000							; ***************************************************************************
     47  27000							;
     48  27000							; Decompression Options & Macros
     49  27000							;
     50  27000
     51  27000							;
     52  27000							; Choose size over decompression speed (within sane limits)?
     53  27000							;
     54  27000
     55  27000			00 00	    LZSA_SMALL_SIZE =	0
     56  27000			00 01	    LZSAFASTCOPYBYTE =	1	; +24 bytes rom, ~10% quicker
     57  27000
     58  27000							; ***************************************************************************
     59  27000							; ***************************************************************************
     60  27000							;
     61  27000							; ZP memory allocations... (temp1-temp9 are 7800basic ZP locations)
     62  27000			00 42	    LSZA1ZPRAM =	temp1
     63  27000			00 42	    lzsa_winptr =	LSZA1ZPRAM	; 1 word (temp1+temp2)
     64  27000			00 44	    lzsa_srcptr =	LSZA1ZPRAM + 2	; 1 word (temp3+temp4)
     65  27000			00 46	    lzsa_dstptr =	LSZA1ZPRAM + 4	; 1 word (temp5+temp6)
     66  27000
     67  27000							; Doesn't need to be ZP allocations...
     68  27000			00 48	    LSZA1TEMPRAM =	temp7
     69  27000			00 48	    lzsa_cmdbuf =	LSZA1TEMPRAM	; 1 byte (temp7)
     70  27000			00 49	    lzsa_cp_npages =	LSZA1TEMPRAM + 1	; 1 byte (temp8)
     71  27000			00 4a	    lzsa_lz_npages =	LSZA1TEMPRAM + 2	; 1 byte (temp9)
     72  27000
     73  27000							; Alternate names for previous allocations...
     74  27000			00 42	    lzsa_offset =	lzsa_winptr
     75  27000			00 44	    LZSA_SRC_LO =	lzsa_srcptr
     76  27000			00 45	    LZSA_SRC_HI =	lzsa_srcptr+1
     77  27000			00 46	    LZSA_DST_LO =	lzsa_dstptr
     78  27000			00 47	    LZSA_DST_HI =	lzsa_dstptr+1
     79  27000
     80  27000				   -	       ifconst	lzsa1support
     81  27000				   -
     82  27000				   -lzsa1modulestart
     83  27000				   -
     84  27000				   -	       if	LZSAFASTCOPYBYTE = 1
     85  27000				   -.cp_fixpointer
     86  27000				   -			; the optimised pointer adjustment fails if .cp_byte copied a whole page.
     87  27000				   -			; so we deal with it as a special case here, out of the regular .cp_byte flow.
     88  27000				   -			; this only happens rarely.
     89  27000				   -	       inc	lzsa_srcptr+1	; CC
     90  27000				   -	       inc	lzsa_dstptr+1
     91  27000				   -	       bcc	.cp_skip3	; always taken
     92  27000				   -			; each of these happen infrequently (~1 in 256 byte copies)
     93  27000				   -.cp_fixsrc1
     94  27000				   -	       inc	lzsa_srcptr+1
     95  27000				   -	       clc
     96  27000				   -	       bcc	.cp_skip1
     97  27000				   -.cp_fixsrc2
     98  27000				   -	       inc	lzsa_dstptr+1
     99  27000				   -	       clc
    100  27000				   -	       bcc	.cp_skip2
    101  27000				   -	       endif
    102  27000				   -
    103  27000				   -			; ***************************************************************************
    104  27000				   -			; ***************************************************************************
    105  27000				   -			;
    106  27000				   -			; lzsa1_unpack - Decompress data stored in Emmanuel Marty's LZSA1 format.
    107  27000				   -			;
    108  27000				   -			; Args: lzsa_srcptr = ptr to compessed data
    109  27000				   -			; Args: lzsa_dstptr = ptr to output buffer
    110  27000				   -			;
    111  27000				   -
    112  27000				   -
    113  27000				   -DECOMPRESS_LZSA1_FAST
    114  27000				   -lzsa1_unpack
    115  27000				   -	       ldy	#0	; Initialize source index.
    116  27000				   -	       ldx	#0	; Initialize hi-byte of length.
    117  27000				   -	       stx	lzsa_cp_npages
    118  27000				   -	       stx	lzsa_lz_npages
    119  27000				   -
    120  27000				   -			;
    121  27000				   -			; Copy bytes from compressed source data.
    122  27000				   -			;
    123  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    124  27000				   -			;
    125  27000				   -
    126  27000				   -.cp_length
    127  27000				   -	       if	LZSA_SMALL_SIZE = 1
    128  27000				   -
    129  27000				   -	       jsr	.get_byte
    130  27000				   -
    131  27000				   -	       else		; !LZSA_SMALL_SIZE
    132  27000				   -
    133  27000				   -	       lda	(lzsa_srcptr),y
    134  27000				   -	       inc	lzsa_srcptr+0
    135  27000				   -	       bne	.cp_skip0
    136  27000				   -	       inc	lzsa_srcptr+1
    137  27000				   -
    138  27000				   -	       endif		; !LZSA_SMALL_SIZE
    139  27000				   -
    140  27000				   -.cp_skip0
    141  27000				   -	       sta	lzsa_cmdbuf	; Preserve this for later.
    142  27000				   -	       and	#$70	; Extract literal length.
    143  27000				   -	       lsr		; Set CC before ...
    144  27000				   -	       beq	.lz_offset	; Skip directly to match?
    145  27000				   -
    146  27000				   -	       lsr		; Get 3-bit literal length.
    147  27000				   -	       lsr
    148  27000				   -	       lsr
    149  27000				   -	       cmp	#$07	; Extended length?
    150  27000				   -	       bcc	.cp_got_len
    151  27000				   -
    152  27000				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    153  27000				   -	       stx	lzsa_cp_npages	; Hi-byte of length.
    154  27000				   -
    155  27000				   -.cp_got_len
    156  27000				   -	       tax		; Lo-byte of length.
    157  27000				   -
    158  27000				   -	       if	LZSAFASTCOPYBYTE = 0
    159  27000				   -
    160  27000				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    161  27000				   -	       lda	(lzsa_srcptr),y	; 5
    162  27000				   -	       sta	(lzsa_dstptr),y	; 5
    163  27000				   -	       inc	lzsa_srcptr+0	; 5
    164  27000				   -	       bne	.cp_skip1	; 3
    165  27000				   -	       inc	lzsa_srcptr+1
    166  27000				   -.cp_skip1
    167  27000				   -	       inc	lzsa_dstptr+0	; 5
    168  27000				   -	       bne	.cp_skip2	; 3
    169  27000				   -	       inc	lzsa_dstptr+1
    170  27000				   -.cp_skip2
    171  27000				   -	       dex		; 2
    172  27000				   -	       bne	.cp_byte	; 3
    173  27000				   -			;  ~29 cycles overall for X=1
    174  27000				   -			;  ~58 cycles overall for X=2
    175  27000				   -			;  ~87 cycles overall for X=3
    176  27000				   -			; ...
    177  27000				   -			; ~174 cycles overall for X=6
    178  27000				   -
    179  27000				   -	       else		; LZSAFASTCOPYBYTE != 0
    180  27000				   -
    181  27000				   -			; according to 7800heat, this loop is hot. It runs on average ~6x.
    182  27000				   -
    183  27000				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    184  27000				   -	       lda	(lzsa_srcptr),y	; 5+
    185  27000				   -	       sta	(lzsa_dstptr),y	; 5+
    186  27000				   -	       iny		; 2
    187  27000				   -	       dex		; 2
    188  27000				   -	       bne	.cp_byte	; 3/2
    189  27000				   -			; ~17 cycles each iteration
    190  27000				   -	       tya		; 2
    191  27000				   -	       beq	.cp_fixpointer	; 2 unlikely branch - only if we copied a full page
    192  27000				   -	       adc	lzsa_srcptr+0	; 3
    193  27000				   -	       sta	lzsa_srcptr+0	; 3
    194  27000				   -	       bcs	.cp_fixsrc1	; 2 (typical)
    195  27000				   -.cp_skip1
    196  27000				   -	       tya		; 2
    197  27000				   -	       adc	lzsa_dstptr+0	; 3
    198  27000				   -	       sta	lzsa_dstptr+0	; 3
    199  27000				   -	       bcs	.cp_fixsrc2	; 2 (typical)
    200  27000				   -.cp_skip2
    201  27000				   -	       ldy	#0	; 2
    202  27000				   -.cp_skip3
    203  27000				   -			; ~24 cycles overhead, typical
    204  27000				   -
    205  27000				   -			; ~41	cycles for X=1 (+12  cycles vs non-optimized)
    206  27000				   -			; ~58	cycles for X=2 (  0  cycles vs non-optimized)
    207  27000				   -			; ~75	cycles for X=3 (-12  cycles vs non-optimized)
    208  27000				   -			; ...
    209  27000				   -			; ~126 cycles for X=6 (-48  cycles vs non-optimized)
    210  27000				   -	       endif		; ! LZSAFASTCOPYBYTE = 0
    211  27000				   -
    212  27000				   -.cp_npages
    213  27000				   -	       lda	lzsa_cp_npages	; Any full pages left to copy?
    214  27000				   -	       beq	.lz_offset
    215  27000				   -
    216  27000				   -	       dec	lzsa_cp_npages	; Unlikely, so can be slow.
    217  27000				   -	       bcc	.cp_byte	; Always true!
    218  27000				   -
    219  27000				   -	       if	LZSA_SMALL_SIZE = 1
    220  27000				   -
    221  27000				   -			; Copy bytes from decompressed window.
    222  27000				   -			;
    223  27000				   -			; Shorter but slower version.
    224  27000				   -			;
    225  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    226  27000				   -			;
    227  27000				   -
    228  27000				   -.lz_offset
    229  27000				   -	       jsr	.get_byte	; Get offset-lo.
    230  27000				   -
    231  27000				   -.offset_lo
    232  27000				   -	       adc	lzsa_dstptr+0	; Always CC from .cp_page loop.
    233  27000				   -	       sta	lzsa_winptr+0
    234  27000				   -
    235  27000				   -	       lda	#$FF
    236  27000				   -	       bit	lzsa_cmdbuf
    237  27000				   -	       bpl	.offset_hi
    238  27000				   -
    239  27000				   -	       jsr	.get_byte	; Get offset-hi.
    240  27000				   -
    241  27000				   -.offset_hi
    242  27000				   -	       adc	lzsa_dstptr+1	; lzsa_winptr < lzsa_dstptr, so
    243  27000				   -	       sta	lzsa_winptr+1	; always leaves CS.
    244  27000				   -
    245  27000				   -.lz_length
    246  27000				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    247  27000				   -	       and	#$0F
    248  27000				   -	       adc	#$03 - 1	; CS from previous ADC.
    249  27000				   -	       cmp	#$12	; Extended length?
    250  27000				   -	       bcc	.lz_got_len
    251  27000				   -
    252  27000				   -	       jsr	.get_length	; CS from CMP, X=0, returns CC.
    253  27000				   -	       stx	lzsa_lz_npages	; Hi-byte of length.
    254  27000				   -
    255  27000				   -.lz_got_len
    256  27000				   -	       tax		; Lo-byte of length.
    257  27000				   -
    258  27000				   -.lz_byte
    259  27000				   -	       lda	(lzsa_winptr),y	; CC throughout the execution of
    260  27000				   -	       sta	(lzsa_dstptr),y	; of this .lz_page loop.
    261  27000				   -	       inc	lzsa_winptr+0
    262  27000				   -	       bne	.lz_skip1
    263  27000				   -	       inc	lzsa_winptr+1
    264  27000				   -.lz_skip1
    265  27000				   -	       inc	lzsa_dstptr+0
    266  27000				   -	       bne	.lz_skip2
    267  27000				   -	       inc	lzsa_dstptr+1
    268  27000				   -.lz_skip2
    269  27000				   -	       dex
    270  27000				   -	       bne	.lz_byte
    271  27000				   -.lz_npages
    272  27000				   -	       lda	lzsa_lz_npages	; Any full pages left to copy?
    273  27000				   -	       beq	.cp_length
    274  27000				   -
    275  27000				   -	       dec	lzsa_lz_npages	; Unlikely, so can be slow.
    276  27000				   -	       bcc	.lz_byte	; Always true!
    277  27000				   -
    278  27000				   -	       else		; !LZSA_SMALL_SIZE
    279  27000				   -
    280  27000				   -			;
    281  27000				   -			; Copy bytes from decompressed window.
    282  27000				   -			;
    283  27000				   -			; Longer but faster.
    284  27000				   -			;
    285  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    286  27000				   -			;
    287  27000				   -
    288  27000				   -.lz_offset
    289  27000				   -	       lda	(lzsa_srcptr),y	; Get offset-lo.
    290  27000				   -	       inc	lzsa_srcptr+0
    291  27000				   -	       bne	.offset_lo
    292  27000				   -	       inc	lzsa_srcptr+1
    293  27000				   -
    294  27000				   -.offset_lo
    295  27000				   -	       sta	lzsa_offset+0
    296  27000				   -
    297  27000				   -	       lda	#$FF	; Get offset-hi.
    298  27000				   -	       bit	lzsa_cmdbuf
    299  27000				   -	       bpl	.offset_hi
    300  27000				   -
    301  27000				   -	       lda	(lzsa_srcptr),y
    302  27000				   -	       inc	lzsa_srcptr+0
    303  27000				   -	       bne	.offset_hi
    304  27000				   -	       inc	lzsa_srcptr+1
    305  27000				   -
    306  27000				   -.offset_hi
    307  27000				   -	       sta	lzsa_offset+1
    308  27000				   -
    309  27000				   -.lz_length
    310  27000				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    311  27000				   -	       and	#$0F
    312  27000				   -	       adc	#$03	; Always CC from .cp_page loop.
    313  27000				   -	       cmp	#$12	; Extended length?
    314  27000				   -	       bcc	.got_lz_len
    315  27000				   -
    316  27000				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    317  27000				   -
    318  27000				   -.got_lz_len
    319  27000				   -	       inx		; Hi-byte of length+256.
    320  27000				   -
    321  27000				   -	       eor	#$FF	; Negate the lo-byte of length
    322  27000				   -	       tay
    323  27000				   -	       eor	#$FF
    324  27000				   -
    325  27000				   -.get_lz_dst
    326  27000				   -	       adc	lzsa_dstptr+0	; Calc address of partial page.
    327  27000				   -	       sta	lzsa_dstptr+0	; Always CC from previous CMP.
    328  27000				   -	       iny
    329  27000				   -	       bcs	.get_lz_win
    330  27000				   -	       beq	.get_lz_win	; Is lo-byte of length zero?
    331  27000				   -	       dec	lzsa_dstptr+1
    332  27000				   -
    333  27000				   -.get_lz_win
    334  27000				   -	       clc		; Calc address of match.
    335  27000				   -	       adc	lzsa_offset+0	; N.B. Offset is negative!
    336  27000				   -	       sta	lzsa_winptr+0
    337  27000				   -	       lda	lzsa_dstptr+1
    338  27000				   -	       adc	lzsa_offset+1
    339  27000				   -	       sta	lzsa_winptr+1
    340  27000				   -
    341  27000				   -			; according to 7800heat, this loop is hot. It runs on average ~7.5x.
    342  27000				   -			; TODO: see if there's a chance to unroll it.
    343  27000				   -.lz_byte
    344  27000				   -	       lda	(lzsa_winptr),y
    345  27000				   -	       sta	(lzsa_dstptr),y
    346  27000				   -	       iny
    347  27000				   -	       bne	.lz_byte
    348  27000				   -
    349  27000				   -	       inc	lzsa_dstptr+1
    350  27000				   -	       dex		; Any full pages left to copy?
    351  27000				   -	       bne	.lz_more
    352  27000				   -
    353  27000				   -	       jmp	.cp_length	; Loop around to the beginning.
    354  27000				   -
    355  27000				   -.lz_more
    356  27000				   -	       inc	lzsa_winptr+1	; Unlikely, so can be slow.
    357  27000				   -	       bne	.lz_byte	; Always true!
    358  27000				   -
    359  27000				   -	       endif		; !LZSA_SMALL_SIZE
    360  27000				   -
    361  27000				   -			;
    362  27000				   -			; Get 16-bit length in X:A register pair, return with CC.
    363  27000				   -			;
    364  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    365  27000				   -			;
    366  27000				   -
    367  27000				   -.get_length
    368  27000				   -	       clc		; Add on the next byte to get
    369  27000				   -	       adc	(lzsa_srcptr),y	; the length.
    370  27000				   -	       inc	lzsa_srcptr+0
    371  27000				   -	       bne	.skip_inc
    372  27000				   -	       inc	lzsa_srcptr+1
    373  27000				   -.skip_inc
    374  27000				   -
    375  27000				   -	       bcc	.got_length	; No overflow means done.
    376  27000				   -	       clc		; MUST return CC!
    377  27000				   -	       tax		; Preserve overflow value.
    378  27000				   -
    379  27000				   -.extra_byte
    380  27000				   -	       jsr	.get_byte	; So rare, this can be slow!
    381  27000				   -	       pha
    382  27000				   -	       txa		; Overflow to 256 or 257?
    383  27000				   -	       beq	.extra_word
    384  27000				   -
    385  27000				   -.check_length
    386  27000				   -	       pla		; Length-lo.
    387  27000				   -	       bne	.got_length	; Check for zero.
    388  27000				   -	       dex		; Do one less page loop if so.
    389  27000				   -.got_length
    390  27000				   -	       rts
    391  27000				   -
    392  27000				   -.extra_word
    393  27000				   -	       jsr	.get_byte	; So rare, this can be slow!
    394  27000				   -	       tax
    395  27000				   -	       bne	.check_length	; Length-hi == 0 at EOF.
    396  27000				   -
    397  27000				   -.finished
    398  27000				   -	       pla		; Length-lo.
    399  27000				   -	       pla		; Decompression completed, pop
    400  27000				   -	       pla		; return address.
    401  27000				   -	       rts
    402  27000				   -
    403  27000				   -.get_byte
    404  27000				   -	       lda	(lzsa_srcptr),y	; Subroutine version for when
    405  27000				   -	       inc	lzsa_srcptr+0	; inlining isn't advantageous.
    406  27000				   -	       bne	.got_byte
    407  27000				   -	       inc	lzsa_srcptr+1	; Inc & test for bank overflow.
    408  27000				   -.got_byte
    409  27000				   -	       rts
    410  27000				   -
    411  27000				   -lzsa1moduleend
    412  27000				   -
    413  27000				   -	       echo	"  (lzsa1compression module is using ",[(lzsa1moduleend-lzsa1modulestart)]d," bytes of rom)"
    414  27000				   -
    415  27000					       endif		; lzsa1support
------- FILE d:\2018dev\7800\7800basic\projects\demo1\lesson4_10.78b.asm
   4305  27000					       endif
   4306  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4307  27000
   4308  27000							;standard routimes needed for pretty much all games
   4309  27000
   4310  27000							; some definitions used with "set debug color"
   4311  27000			00 91	    DEBUGCALC  =	$91
   4312  27000			00 41	    DEBUGWASTE =	$41
   4313  27000			00 c1	    DEBUGDRAW  =	$C1
   4314  27000
   4315  27000							;NMI and IRQ handlers
   4316  27000				    NMI
   4317  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   4318  27000			48		       pha		; save A
   4319  27001			d8		       cld
   4320  27002			a5 4d		       lda	visibleover
   4321  27004			49 ff		       eor	#255
   4322  27006			85 4d		       sta	visibleover
   4323  27008				   -	       ifconst	DEBUGINTERRUPT
   4324  27008				   -	       and	#$93
   4325  27008				   -	       sta	BACKGRND
   4326  27008					       endif
   4327  27008			8a		       txa		; save X
   4328  27009			48		       pha
   4329  2700a			98		       tya		; save Y
   4330  2700b			48		       pha
   4331  2700c			ce b2 01	       dec	interruptindex
   4332  2700f			d0 03		       bne	skipreallyoffvisible
   4333  27011			4c 73 f0	       jmp	reallyoffvisible
   4334  27014				    skipreallyoffvisible
   4335  27014			a5 4d		       lda	visibleover
   4336  27016			d0 03		       bne	carryontopscreenroutine
   4337  27018				   -	       ifconst	.bottomscreenroutine
   4338  27018				   -	       lda	interrupthold
   4339  27018				   -	       beq	skipbottomroutine
   4340  27018				   -	       jsr	.bottomscreenroutine
   4341  27018				   -skipbottomroutine
   4342  27018					       endif
   4343  27018			4c 81 f0	       jmp	NMIexit
   4344  2701b				    carryontopscreenroutine
   4345  2701b				   -	       ifconst	.topscreenroutine
   4346  2701b				   -	       lda	interrupthold
   4347  2701b				   -	       beq	skiptoproutine
   4348  2701b				   -	       jsr	.topscreenroutine
   4349  2701b				   -skiptoproutine
   4350  2701b					       endif
   4351  2701b					       ifnconst	CANARYOFF
   4352  2701b			ad c4 01	       lda	canary
   4353  2701e			f0 07		       beq	skipcanarytriggered
   4354  27020			a9 45		       lda	#$45
   4355  27022			85 20		       sta	BACKGRND
   4356  27024			4c 6b f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   4357  27027				    skipcanarytriggered
   4358  27027					       endif
   4359  27027
   4360  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   4361  2702a
   4362  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   4363  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   4364  2702a
   4365  2702a				   -	       ifconst	LONGCONTROLLERREAD
   4366  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   4367  2702a				   -	       ldy	port1control
   4368  2702a				   -	       lda	longreadtype,y
   4369  2702a				   -	       beq	LLRET1
   4370  2702a				   -	       tay
   4371  2702a				   -	       lda	longreadroutinehiP1,y
   4372  2702a				   -	       sta	inttemp4
   4373  2702a				   -	       lda	longreadroutineloP1,y
   4374  2702a				   -	       sta	inttemp3
   4375  2702a				   -	       jmp	(inttemp3)
   4376  2702a				   -LLRET1
   4377  2702a				   -	       ldy	port0control
   4378  2702a				   -	       lda	longreadtype,y
   4379  2702a				   -	       beq	LLRET0
   4380  2702a				   -	       tay
   4381  2702a				   -	       lda	longreadroutinehiP0,y
   4382  2702a				   -	       sta	inttemp4
   4383  2702a				   -	       lda	longreadroutineloP0,y
   4384  2702a				   -	       sta	inttemp3
   4385  2702a				   -	       jmp	(inttemp3)
   4386  2702a				   -LLRET0
   4387  2702a				   -
   4388  2702a				   -
   4389  2702a				   -	       ifconst	PADDLERANGE
   4390  2702a				   -TIMEVAL    =	PADDLERANGE
   4391  2702a				   -	       else
   4392  2702a				   -TIMEVAL    =	160
   4393  2702a				   -	       endif
   4394  2702a				   -TIMEOFFSET =	10
   4395  2702a				   -
   4396  2702a					       endif		; LONGCONTROLLERREAD
   4397  2702a
   4398  2702a
   4399  2702a			20 18 f2	       jsr	servicesfxchannels
   4400  2702d				   -	       ifconst	MUSICTRACKER
   4401  2702d				   -	       jsr	servicesong
   4402  2702d					       endif		; MUSICTRACKER
   4403  2702d				   -	       ifconst	RMT
   4404  2702d				   -	       ifnconst	RMTOFFSPEED
   4405  2702d				   -	       ifconst	RMTPALSPEED
   4406  2702d				   -	       lda	ntscslowframe
   4407  2702d				   -	       bne	skiprasterupdate
   4408  2702d				   -	       endif
   4409  2702d				   -	       endif
   4410  2702d				   -	       lda	rasterpause
   4411  2702d				   -	       beq	skiprasterupdate
   4412  2702d				   -	       ifconst	PAUSESILENT
   4413  2702d				   -	       lda	pausestate
   4414  2702d				   -	       bne	skiprasterupdate
   4415  2702d				   -	       endif
   4416  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   4417  2702d				   -skiprasterupdate
   4418  2702d				   -RMT_Iend
   4419  2702d					       endif
   4420  2702d
   4421  2702d			ee a4 01	       inc	framecounter
   4422  27030			ad a4 01	       lda	framecounter
   4423  27033			29 3f		       and	#63
   4424  27035			d0 08		       bne	skipcountdownseconds
   4425  27037			ad a5 01	       lda	countdownseconds
   4426  2703a			f0 03		       beq	skipcountdownseconds
   4427  2703c			ce a5 01	       dec	countdownseconds
   4428  2703f				    skipcountdownseconds
   4429  2703f
   4430  2703f			a2 01		       ldx	#1
   4431  27041				    buttonreadloop
   4432  27041			8a		       txa
   4433  27042			48		       pha
   4434  27043			bc ba 01	       ldy	port0control,x
   4435  27046			b9 f4 f1	       lda	buttonhandlerlo,y
   4436  27049			85 da		       sta	inttemp3
   4437  2704b			b9 e7 f1	       lda	buttonhandlerhi,y
   4438  2704e			85 db		       sta	inttemp4
   4439  27050			05 da		       ora	inttemp3
   4440  27052			f0 03		       beq	buttonreadloopreturn
   4441  27054			6c da 00	       jmp	(inttemp3)
   4442  27057				    buttonreadloopreturn
   4443  27057			68		       pla
   4444  27058			aa		       tax
   4445  27059			ca		       dex
   4446  2705a			10 e5		       bpl	buttonreadloop
   4447  2705c
   4448  2705c					       ifconst	DOUBLEBUFFER
   4449  2705c			ad b4 01	       lda	doublebufferminimumframeindex
   4450  2705f			f0 03		       beq	skipdoublebufferminimumframeindexadjust
   4451  27061			ce b4 01	       dec	doublebufferminimumframeindex
   4452  27064				    skipdoublebufferminimumframeindexadjust
   4453  27064					       endif
   4454  27064
   4455  27064			4c 81 f0	       jmp	NMIexit
   4456  27067
   4457  27067				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   4458  27067					       ifnconst	BREAKPROTECTOFF
   4459  27067			a9 1a		       lda	#$1A
   4460  27069			85 20		       sta	BACKGRND
   4461  2706b				    skipbrkolorset
   4462  2706b				    skipbrkdetected
   4463  2706b			a9 60		       lda	#$60
   4464  2706d			8d 07 21	       sta	sCTRL
   4465  27070			85 3c		       sta	CTRL
   4466  27072					       ifnconst	hiscorefont
   4467  27072			02		       .byte.b	$02	; KIL/JAM
   4468  27073				   -	       else		; hiscorefont is present
   4469  27073				   -	       ifconst	CRASHDUMP
   4470  27073				   -	       bit	MSTAT
   4471  27073				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   4472  27073				   -
   4473  27073				   -	       ifconst	dumpbankswitch
   4474  27073				   -	       lda	dumpbankswitch
   4475  27073				   -	       pha
   4476  27073				   -	       endif
   4477  27073				   -
   4478  27073				   -			; bankswitch if needed, to get to the hiscore font
   4479  27073				   -	       ifconst	bankswitchmode
   4480  27073				   -	       ifconst	included.hiscore.asm.bank
   4481  27073				   -	       ifconst	MCPDEVCART
   4482  27073				   -	       lda	#($18 | included.hiscore.asm.bank)
   4483  27073				   -	       sta	$3000
   4484  27073				   -	       else
   4485  27073				   -	       lda	#(included.hiscore.asm.bank)
   4486  27073				   -	       sta	$8000
   4487  27073				   -	       endif
   4488  27073				   -	       endif		; included.hiscore.asm.bank
   4489  27073				   -	       endif		; bankswitchmode
   4490  27073				   -
   4491  27073				   -	       ifconst	DOUBLEBUFFER
   4492  27073				   -			;turn off double-buffering, if on...
   4493  27073				   -	       lda	#>DLLMEM
   4494  27073				   -	       sta	DPPH
   4495  27073				   -	       lda	#<DLLMEM
   4496  27073				   -	       sta	DPPL
   4497  27073				   -	       endif
   4498  27073				   -
   4499  27073				   -	       lda	#$00
   4500  27073				   -	       sta	P0C2
   4501  27073				   -
   4502  27073				   -			;update the second-from-top DL...
   4503  27073				   -	       ldy	#8
   4504  27073				   -NMIupdatetopDL
   4505  27073				   -	       lda	show2700,y
   4506  27073				   -	       sta	ZONE1ADDRESS,y
   4507  27073				   -	       dey
   4508  27073				   -	       bpl	NMIupdatetopDL
   4509  27073				   -
   4510  27073				   -			; the hiscore font is present, so we try to output the stack
   4511  27073				   -	       ldy	#0
   4512  27073				   -copystackloop
   4513  27073				   -	       pla
   4514  27073				   -	       pha
   4515  27073				   -	       lsr
   4516  27073				   -	       lsr
   4517  27073				   -	       lsr
   4518  27073				   -	       lsr
   4519  27073				   -	       tax
   4520  27073				   -	       lda	hiscorehexlut,x
   4521  27073				   -	       sta	$2700,y
   4522  27073				   -	       iny
   4523  27073				   -
   4524  27073				   -	       pla
   4525  27073				   -	       and	#$0F
   4526  27073				   -	       tax
   4527  27073				   -	       lda	hiscorehexlut,x
   4528  27073				   -	       sta	$2700,y
   4529  27073				   -	       iny
   4530  27073				   -
   4531  27073				   -	       lda	#27	; period
   4532  27073				   -	       sta	$2700,y
   4533  27073				   -	       iny
   4534  27073				   -
   4535  27073				   -	       cpy	#30
   4536  27073				   -	       bne	copystackloop
   4537  27073				   -
   4538  27073				   -	       lda	#>hiscorefont
   4539  27073				   -	       sta	CHARBASE
   4540  27073				   -	       sta	sCHARBASE
   4541  27073				   -	       lda	#%01000011	;Enable DMA, mode=320A
   4542  27073				   -	       sta	CTRL
   4543  27073				   -	       sta	sCTRL
   4544  27073				   -	       .byte	$02	; KIL/JAM
   4545  27073				   -hiscorehexlut
   4546  27073				   -			; 0 1 2 3 4 5 6 7 8 9 A B C D E F
   4547  27073				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   4548  27073				   -show2700
   4549  27073				   -			; lo mode hi width=29 x EODL
   4550  27073				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   4551  27073				   -	       else		; CRASHDUMP
   4552  27073				   -	       .byte	$02	; KIL/JAM
   4553  27073				   -	       endif		; crashdump
   4554  27073					       endif		; hiscorefont
   4555  27073				   -	       else
   4556  27073				   -	       RTI
   4557  27073					       endif
   4558  27073
   4559  27073				   -	       ifconst	LONGCONTROLLERREAD
   4560  27073				   -
   4561  27073				   -longreadtype
   4562  27073				   -	       .byte	0, 0, 0, 1	; NONE PROLINE LIGHTGUN PADDLE
   4563  27073				   -	       .byte	2, 0, 3, 0	; TRKBALL VCSSTICK DRIVING KEYPAD
   4564  27073				   -	       .byte	3, 3, 0, 0	; STMOUSE AMOUSE ATARIVOX SNES
   4565  27073				   -
   4566  27073				   -longreadroutineloP0
   4567  27073				   -	       .byte	<LLRET0	; 0 = no routine
   4568  27073				   -	       .byte	<paddleport0update	; 1 = paddle
   4569  27073				   -	       .byte	<trakball0update	; 2 = trakball
   4570  27073				   -	       .byte	<mouse0update	; 3 = mouse
   4571  27073				   -
   4572  27073				   -longreadroutinehiP0
   4573  27073				   -	       .byte	>LLRET0	; 0 = no routine
   4574  27073				   -	       .byte	>paddleport0update	; 1 = paddle
   4575  27073				   -	       .byte	>trakball0update	; 2 = trackball
   4576  27073				   -	       .byte	>mouse0update	; 3 = mouse
   4577  27073				   -
   4578  27073				   -longreadroutineloP1
   4579  27073				   -	       .byte	<LLRET1	; 0 = no routine
   4580  27073				   -	       .byte	<paddleport1update	; 1 = paddle
   4581  27073				   -	       .byte	<trakball1update	; 2 = trakball
   4582  27073				   -	       .byte	<mouse1update	; 3 = mouse
   4583  27073				   -
   4584  27073				   -longreadroutinehiP1
   4585  27073				   -	       .byte	>LLRET1	; 0 = no routine
   4586  27073				   -	       .byte	>paddleport1update	; 1 = paddle
   4587  27073				   -	       .byte	>trakball1update	; 2 = trackball
   4588  27073				   -	       .byte	>mouse1update	; 3 = mouse
   4589  27073				   -
   4590  27073				   -
   4591  27073				   -SETTIM64T
   4592  27073				   -	       bne	skipdefaulttime
   4593  27073				   -	       ifnconst	PADDLESMOOTHINGOFF
   4594  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   4595  27073				   -	       else
   4596  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   4597  27073				   -	       endif
   4598  27073				   -skipdefaulttime
   4599  27073				   -	       tay
   4600  27073				   -	       dey
   4601  27073				   -.setTIM64Tloop
   4602  27073				   -	       sta	TIM64T
   4603  27073				   -	       cpy	INTIM
   4604  27073				   -	       bne	.setTIM64Tloop
   4605  27073				   -	       rts
   4606  27073					       endif		; LONGCONTROLLERREAD
   4607  27073
   4608  27073				    reallyoffvisible
   4609  27073			85 24		       sta	WSYNC
   4610  27075
   4611  27075			a9 00		       lda	#0
   4612  27077			85 4d		       sta	visibleover
   4613  27079				   -	       ifconst	DEBUGINTERRUPT
   4614  27079				   -	       sta	BACKGRND
   4615  27079					       endif
   4616  27079
   4617  27079			a9 03		       lda	#3
   4618  2707b			8d b2 01	       sta	interruptindex
   4619  2707e
   4620  2707e			20 65 f1	       jsr	uninterruptableroutines
   4621  27081
   4622  27081				   -	       ifconst	.userinterrupt
   4623  27081				   -	       lda	interrupthold
   4624  27081				   -	       beq	skipuserintroutine
   4625  27081				   -	       jsr	.userinterrupt
   4626  27081				   -skipuserintroutine
   4627  27081					       endif
   4628  27081
   4629  27081				   -	       ifconst	KEYPADSUPPORT
   4630  27081				   -	       jsr	keypadcolumnread
   4631  27081				   -	       jsr	keypadrowselect
   4632  27081					       endif
   4633  27081
   4634  27081				    NMIexit
   4635  27081			68		       pla
   4636  27082			a8		       tay
   4637  27083			68		       pla
   4638  27084			aa		       tax
   4639  27085			68		       pla
   4640  27086			40		       RTI
   4641  27087
   4642  27087				    clearscreen
   4643  27087			a2 0b		       ldx	#(WZONECOUNT-1)
   4644  27089			a9 00		       lda	#0
   4645  2708b				    clearscreenloop
   4646  2708b			95 65		       sta	dlend,x
   4647  2708d			ca		       dex
   4648  2708e			10 fb		       bpl	clearscreenloop
   4649  27090			a9 00		       lda	#0
   4650  27092			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   4651  27095			8d ae 01	       sta	valbufendsave
   4652  27098			60		       rts
   4653  27099
   4654  27099				    restorescreen
   4655  27099			a2 0b		       ldx	#(WZONECOUNT-1)
   4656  2709b			a9 00		       lda	#0
   4657  2709d				    restorescreenloop
   4658  2709d			b5 82		       lda	dlendsave,x
   4659  2709f			95 65		       sta	dlend,x
   4660  270a1			ca		       dex
   4661  270a2			10 f9		       bpl	restorescreenloop
   4662  270a4			ad ae 01	       lda	valbufendsave
   4663  270a7			8d ad 01	       sta	valbufend
   4664  270aa			60		       rts
   4665  270ab
   4666  270ab				    savescreen
   4667  270ab			a2 0b		       ldx	#(WZONECOUNT-1)
   4668  270ad				    savescreenloop
   4669  270ad			b5 65		       lda	dlend,x
   4670  270af			95 82		       sta	dlendsave,x
   4671  270b1			ca		       dex
   4672  270b2			10 f9		       bpl	savescreenloop
   4673  270b4			ad ad 01	       lda	valbufend
   4674  270b7			8d ae 01	       sta	valbufendsave
   4675  270ba					       ifconst	DOUBLEBUFFER
   4676  270ba			a5 d5		       lda	doublebufferstate
   4677  270bc			f0 04		       beq	savescreenrts
   4678  270be			a9 01		       lda	#1
   4679  270c0			85 d7		       sta	doublebufferbufferdirty
   4680  270c2				    savescreenrts
   4681  270c2					       endif		; DOUBLEBUFFER
   4682  270c2			60		       rts
   4683  270c3
   4684  270c3				    drawscreen
   4685  270c3
   4686  270c3				   -	       ifconst	interrupthold
   4687  270c3				   -	       lda	#$FF
   4688  270c3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   4689  270c3					       endif
   4690  270c3
   4691  270c3			a9 00		       lda	#0
   4692  270c5			85 42		       sta	temp1	; not B&W if we're here...
   4693  270c7
   4694  270c7				    drawscreenwait
   4695  270c7			a5 4d		       lda	visibleover
   4696  270c9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   4697  270cb
   4698  270cb							;restore some registers in case the game changed them mid-screen...
   4699  270cb			ad 07 21	       lda	sCTRL
   4700  270ce			05 42		       ora	temp1
   4701  270d0			85 3c		       sta	CTRL
   4702  270d2			ad 0b 21	       lda	sCHARBASE
   4703  270d5			85 34		       sta	CHARBASE
   4704  270d7
   4705  270d7							;ensure all of the display list is terminated...
   4706  270d7			20 42 f1	       jsr	terminatedisplaylist
   4707  270da
   4708  270da					       ifnconst	pauseroutineoff
   4709  270da			20 e5 f0	       jsr	pauseroutine
   4710  270dd					       endif		; pauseroutineoff
   4711  270dd
   4712  270dd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   4713  270dd							; delaying a full frame, but still allowing time for basic calculations.
   4714  270dd				    visiblescreenstartedwait
   4715  270dd			a5 4d		       lda	visibleover
   4716  270df			f0 fc		       beq	visiblescreenstartedwait
   4717  270e1				    visiblescreenstartedwaitdone
   4718  270e1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   4719  270e4			60		       rts
   4720  270e5
   4721  270e5					       ifnconst	pauseroutineoff
   4722  270e5							; check to see if pause was pressed and released
   4723  270e5				    pauseroutine
   4724  270e5			ad b5 01	       lda	pausedisable
   4725  270e8			d0 47		       bne	leavepauseroutine
   4726  270ea			a9 08		       lda	#8
   4727  270ec			2c 82 02	       bit	SWCHB
   4728  270ef			f0 22		       beq	pausepressed
   4729  270f1
   4730  270f1				   -	       ifconst	SNES0PAUSE
   4731  270f1				   -	       lda	port0control
   4732  270f1				   -	       cmp	#11
   4733  270f1				   -	       bne	skipsnes0pause
   4734  270f1				   -	       lda	snesdetected0
   4735  270f1				   -	       beq	skipsnes0pause
   4736  270f1				   -	       lda	snes2atari0hi
   4737  270f1				   -	       and	#%00010000
   4738  270f1				   -	       beq	pausepressed
   4739  270f1				   -skipsnes0pause
   4740  270f1					       endif
   4741  270f1				   -	       ifconst	SNES1PAUSE
   4742  270f1				   -
   4743  270f1				   -	       lda	port1control
   4744  270f1				   -	       cmp	#11
   4745  270f1				   -	       bne	skipsnes1pause
   4746  270f1				   -	       lda	snesdetected1
   4747  270f1				   -	       beq	skipsnes1pause
   4748  270f1				   -	       lda	snes2atari1hi
   4749  270f1				   -	       and	#%00010000
   4750  270f1				   -	       beq	pausepressed
   4751  270f1				   -skipsnes1pause
   4752  270f1					       endif
   4753  270f1				   -	       ifconst	SNESNPAUSE
   4754  270f1				   -	       ldx	snesport
   4755  270f1				   -	       lda	port0control,x
   4756  270f1				   -	       cmp	#11
   4757  270f1				   -	       bne	skipsnesNpause
   4758  270f1				   -	       lda	snesdetected0,x
   4759  270f1				   -	       beq	skipsnesNpause
   4760  270f1				   -	       lda	snes2atari0hi,x
   4761  270f1				   -	       and	#%00010000
   4762  270f1				   -	       beq	pausepressed
   4763  270f1				   -skipsnesNpause
   4764  270f1					       endif
   4765  270f1				   -	       ifconst	MULTIBUTTONPAUSE
   4766  270f1				   -	       ldx	#1
   4767  270f1				   -multibuttonpauseloop
   4768  270f1				   -	       lda	port0control,x
   4769  270f1				   -	       cmp	#11
   4770  270f1				   -	       bcc	multibuttonpauseloopbottom
   4771  270f1				   -	       lda	sINPT1,x
   4772  270f1				   -	       and	#1
   4773  270f1				   -	       beq	pausepressed
   4774  270f1				   -multibuttonpauseloopbottom
   4775  270f1				   -	       dex
   4776  270f1				   -	       bpl	multibuttonpauseloop
   4777  270f1					       endif		; MULTIBUTTONPAUSE
   4778  270f1
   4779  270f1							;pause isn't pressed
   4780  270f1			a9 00		       lda	#0
   4781  270f3			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   4782  270f6
   4783  270f6							;check if we're in an already paused state
   4784  270f6			ad 00 21	       lda	pausestate
   4785  270f9			f0 36		       beq	leavepauseroutine	; nope, leave
   4786  270fb
   4787  270fb			c9 01		       cmp	#1	; last frame was the start of pausing
   4788  270fd			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   4789  270ff
   4790  270ff			c9 02		       cmp	#2
   4791  27101			f0 34		       beq	carryonpausing
   4792  27103
   4793  27103							;pausestate must be >2, which means we're ending an unpause 
   4794  27103			a9 00		       lda	#0
   4795  27105			8d ac 01	       sta	pausebuttonflag
   4796  27108			8d 00 21	       sta	pausestate
   4797  2710b			ad 07 21	       lda	sCTRL
   4798  2710e			85 3c		       sta	CTRL
   4799  27110			4c 31 f1	       jmp	leavepauseroutine
   4800  27113
   4801  27113				    pausepressed
   4802  27113							;pause is pressed
   4803  27113			ad ac 01	       lda	pausebuttonflag
   4804  27116			c9 ff		       cmp	#$ff
   4805  27118			f0 1d		       beq	carryonpausing
   4806  2711a
   4807  2711a							;its a new press, increment the state
   4808  2711a			ee 00 21	       inc	pausestate
   4809  2711d
   4810  2711d							;silence volume at the start and end of pausing
   4811  2711d			a9 00		       lda	#0
   4812  2711f			85 19		       sta	AUDV0
   4813  27121			85 1a		       sta	AUDV1
   4814  27123
   4815  27123				   -	       ifconst	pokeysupport
   4816  27123				   -	       ldy	#7
   4817  27123				   -pausesilencepokeyaudioloop
   4818  27123				   -	       sta	(pokeybase),y
   4819  27123				   -	       dey
   4820  27123				   -	       bpl	pausesilencepokeyaudioloop
   4821  27123					       endif		; pokeysupport
   4822  27123
   4823  27123			a9 ff		       lda	#$ff
   4824  27125			8d ac 01	       sta	pausebuttonflag
   4825  27128			d0 0d		       bne	carryonpausing
   4826  2712a
   4827  2712a				    enterpausestate2
   4828  2712a			a9 02		       lda	#2
   4829  2712c			8d 00 21	       sta	pausestate
   4830  2712f			d0 06		       bne	carryonpausing
   4831  27131				    leavepauseroutine
   4832  27131			ad 07 21	       lda	sCTRL
   4833  27134			85 3c		       sta	CTRL
   4834  27136			60		       rts
   4835  27137				    carryonpausing
   4836  27137				   -	       ifconst	.pause
   4837  27137				   -	       jsr	.pause
   4838  27137					       endif		; .pause
   4839  27137			ad 07 21	       lda	sCTRL
   4840  2713a			09 80		       ora	#%10000000	; turn off colorburst during pause...
   4841  2713c			85 3c		       sta	CTRL
   4842  2713e			4c e5 f0	       jmp	pauseroutine
   4843  27141					       endif		; pauseroutineoff
   4844  27141
   4845  27141
   4846  27141					       ifconst	DOUBLEBUFFER
   4847  27141				    skipterminatedisplaylistreturn
   4848  27141			60		       rts
   4849  27142					       endif		; DOUBLEBUFFER
   4850  27142				    terminatedisplaylist
   4851  27142					       ifconst	DOUBLEBUFFER
   4852  27142			a5 d5		       lda	doublebufferstate
   4853  27144			d0 fb		       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   4854  27146					       endif		; DOUBLEBUFFER
   4855  27146				    terminatedisplaybuffer
   4856  27146							;add DL end entry on each DL
   4857  27146			a2 0b		       ldx	#(WZONECOUNT-1)
   4858  27148				    dlendloop
   4859  27148				   -	       ifconst	VSCROLL
   4860  27148				   -	       ldy	Xx3,x
   4861  27148				   -	       lda	DLLMEM+11,y
   4862  27148					       else		; !VSCROLL
   4863  27148			bd 93 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   4864  2714b					       endif		; !VSCROLL
   4865  2714b					       ifconst	DOUBLEBUFFER
   4866  2714b			18		       clc
   4867  2714c			65 d6		       adc	doublebufferdloffset
   4868  2714e					       endif		; DOUBLEBUFFER
   4869  2714e			85 63		       sta	dlpnt
   4870  27150				   -	       ifconst	VSCROLL
   4871  27150				   -	       lda	DLLMEM+10,y
   4872  27150					       else		; !VSCROLL
   4873  27150			bd 87 f6	       lda	DLPOINTH,x
   4874  27153					       endif		; !VSCROLL
   4875  27153					       ifconst	DOUBLEBUFFER
   4876  27153			69 00		       adc	#0
   4877  27155					       endif		; DOUBLEBUFFER
   4878  27155			85 64		       sta	dlpnt+1
   4879  27157			b4 65		       ldy	dlend,x
   4880  27159			a9 00		       lda	#$00
   4881  2715b				    dlendmoreloops
   4882  2715b			c8		       iny
   4883  2715c			91 63		       sta	(dlpnt),y
   4884  2715e				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   4885  2715e				   -	       cpy	#DLLASTOBJ+1
   4886  2715e				   -	       beq	dlendthiszonedone
   4887  2715e				   -	       iny
   4888  2715e				   -	       iny
   4889  2715e				   -	       iny
   4890  2715e				   -	       iny
   4891  2715e				   -	       iny
   4892  2715e				   -	       sta	(dlpnt),y
   4893  2715e				   -dlendthiszonedone
   4894  2715e					       endif	FRAMESKIPGLITCHFIXWEAK
   4895  2715e				   -	       ifconst	FRAMESKIPGLITCHFIX
   4896  2715e				   -	       iny
   4897  2715e				   -	       iny
   4898  2715e				   -	       iny
   4899  2715e				   -	       iny
   4900  2715e				   -	       cpy	#DLLASTOBJ-1
   4901  2715e				   -	       bcc	dlendmoreloops
   4902  2715e					       endif		; FRAMESKIPGLITCHFIX
   4903  2715e			ca		       dex
   4904  2715f			10 e7		       bpl	dlendloop
   4905  27161
   4906  27161					       ifnconst	pauseroutineoff
   4907  27161			20 e5 f0	       jsr	pauseroutine
   4908  27164					       endif		; pauseroutineoff
   4909  27164			60		       rts
   4910  27165
   4911  27165				    uninterruptableroutines
   4912  27165							; this is for routines that must happen off the visible screen, each frame.
   4913  27165
   4914  27165				   -	       ifconst	AVOXVOICE
   4915  27165				   -	       jsr	serviceatarivoxqueue
   4916  27165					       endif
   4917  27165				   -	       ifconst	MEGA7800SUPPORT
   4918  27165				   -	       ldx	#1
   4919  27165				   -mega7800polling
   4920  27165				   -	       lda	port0control,x
   4921  27165				   -	       cmp	#12	; mega7800
   4922  27165				   -	       bne	mega7800handlercheck2
   4923  27165				   -	       jsr	mega7800handler
   4924  27165				   -	       jmp	mega7800handlerdone
   4925  27165				   -mega7800handlercheck2
   4926  27165				   -	       ifconst	MULTIBUTTON
   4927  27165				   -	       cmp	#1	; proline
   4928  27165				   -	       bne	mega7800handlerdone
   4929  27165				   -	       lda	framecounter
   4930  27165				   -	       eor	#7	; avoid the same frame as the snes2atari probe
   4931  27165				   -	       and	#63
   4932  27165				   -	       bne	mega7800handlerdone
   4933  27165				   -	       lda	#12
   4934  27165				   -	       sta	port0control,x
   4935  27165				   -	       jsr	mega7800handler
   4936  27165				   -	       endif		; MULTIBUTTON
   4937  27165				   -mega7800handlerdone
   4938  27165				   -	       dex
   4939  27165				   -	       bpl	mega7800polling
   4940  27165					       endif		; MEGA7800SUPPORT
   4941  27165
   4942  27165			a9 00		       lda	#0
   4943  27167			8d b9 01	       sta	palfastframe
   4944  2716a			8d b8 01	       sta	ntscslowframe
   4945  2716d			ae 09 21	       ldx	paldetected	; 0=ntsc 1=pal
   4946  27170			ac b7 01	       ldy	palframes
   4947  27173			c8		       iny
   4948  27174			c0 05		       cpy	#5
   4949  27176			d0 08		       bne	palframeskipdone
   4950  27178			ad 09 21	       lda	paldetected
   4951  2717b			fe b8 01	       inc	ntscslowframe,x
   4952  2717e			a0 00		       ldy	#0
   4953  27180				    palframeskipdone
   4954  27180			8c b7 01	       sty	palframes
   4955  27183				    skippalframeadjusting
   4956  27183
   4957  27183				   -	       ifconst	MUSICTRACKER
   4958  27183				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   4959  27183				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   4960  27183				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   4961  27183				   -			; problem twice, and if we do, we just drop a musical note or two.
   4962  27183				   -	       lda	sfxschedulemissed
   4963  27183				   -	       beq	servicesongwasnotmissed
   4964  27183				   -	       jsr	servicesong
   4965  27183				   -servicesongwasnotmissed
   4966  27183					       endif		; MUSICTRACKER
   4967  27183
   4968  27183				   -	       ifconst	RMT
   4969  27183				   -	       ifnconst	RMTPALSPEED
   4970  27183				   -	       ifnconst	RMTOFFSPEED
   4971  27183				   -	       ifconst	PAUSESILENT
   4972  27183				   -	       lda	pausestate
   4973  27183				   -	       bne	skiprasterupdate2
   4974  27183				   -	       endif
   4975  27183				   -	       lda	palfastframe
   4976  27183				   -	       beq	skiprasterupdate2
   4977  27183				   -	       lda	rasterpause
   4978  27183				   -	       beq	skiprasterupdate2
   4979  27183				   -	       jsr	RASTERMUSICTRACKER+3
   4980  27183				   -skiprasterupdate2
   4981  27183				   -	       endif
   4982  27183				   -	       endif
   4983  27183					       endif
   4984  27183
   4985  27183			60		       rts
   4986  27184
   4987  27184				    serviceatarivoxqueue
   4988  27184				   -	       ifconst	AVOXVOICE
   4989  27184				   -	       lda	voxlock
   4990  27184				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   4991  27184				   -skipvoxqueuesizedec
   4992  27184				   -	       jmp	processavoxvoice
   4993  27184				   -skipvoxprocessing
   4994  27184				   -	       rts
   4995  27184				   -
   4996  27184				   -processavoxvoice
   4997  27184				   -	       ifconst	HSSUPPORT
   4998  27184				   -			; ** we skip speech if hi-score is on and no vox was detected
   4999  27184				   -			; ** this is to avoid later collision with snes pads.
   5000  27184				   -	       lda	hsdevice
   5001  27184				   -	       and	#2
   5002  27184				   -	       beq	processavoxvoicereturn
   5003  27184				   -	       endif		; HSSUPPORT
   5004  27184				   -	       lda	avoxenable
   5005  27184				   -	       bne	avoxfixport
   5006  27184				   -	       SPKOUT	tempavox
   5007  27184				   -	       rts
   5008  27184				   -avoxfixport
   5009  27184				   -	       lda	#0	; restore the port to all bits as inputs...
   5010  27184				   -	       sta	CTLSWA
   5011  27184				   -	       rts
   5012  27184				   -silenceavoxvoice
   5013  27184				   -	       SPEAK	avoxsilentdata
   5014  27184				   -processavoxvoicereturn
   5015  27184				   -	       rts
   5016  27184				   -avoxsilentdata
   5017  27184				   -	       .byte	31,255
   5018  27184					       else
   5019  27184			60		       rts
   5020  27185					       endif		; AVOXVOICE
   5021  27185
   5022  27185				    prolinebuttonpadhandler
   5023  27185				   -	       ifconst	MULTIBUTTON
   5024  27185				   -	       lda	framecounter
   5025  27185				   -	       and	#63
   5026  27185				   -	       bne	jbhandlercont1
   5027  27185				   -	       jsr	setonebuttonmode
   5028  27185				   -	       lda	#11
   5029  27185				   -	       sta	port0control,x
   5030  27185				   -	       jsr	snes2atari_signal_go
   5031  27185				   -	       lda	port0control,x
   5032  27185				   -	       cmp	#1	; check if it's still a proline 
   5033  27185				   -	       beq	jbhandlercont1
   5034  27185				   -	       jmp	buttonreadloopreturn
   5035  27185				   -jbhandlercont1
   5036  27185				   -	       lda	#2
   5037  27185				   -	       sta	multibuttoncount0,x
   5038  27185					       endif		; MULTIBUTTON
   5039  27185				    joybuttonpadhandler
   5040  27185			ad 31 21	       lda	sSWCHA	; clear previous dirs for this pad, from
   5041  27188			1d d7 f1	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
   5042  2718b			8d 31 21	       sta	sSWCHA
   5043  2718e			ad 80 02	       lda	SWCHA	; load th actual joystick dirs, ensuring
   5044  27191			1d d8 f1	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
   5045  27194			2d 31 21	       and	sSWCHA
   5046  27197			8d 31 21	       sta	sSWCHA
   5047  2719a				    joybuttonhandler
   5048  2719a			8a		       txa
   5049  2719b			0a		       asl
   5050  2719c			a8		       tay
   5051  2719d			b9 08 00	       lda	INPT0,y
   5052  271a0			4a		       lsr
   5053  271a1							;ora #%00111111
   5054  271a1			9d 02 21	       sta	sINPT1,x
   5055  271a4			b9 09 00	       lda	INPT1,y
   5056  271a7			29 80		       and	#%10000000
   5057  271a9			1d 02 21	       ora	sINPT1,x
   5058  271ac			9d 02 21	       sta	sINPT1,x
   5059  271af
   5060  271af			b5 0c		       lda	INPT4,x
   5061  271b1			30 19		       bmi	.skip1bjoyfirecheck
   5062  271b3							;one button joystick is down
   5063  271b3			49 80		       eor	#%10000000
   5064  271b5			9d 02 21	       sta	sINPT1,x
   5065  271b8
   5066  271b8			ad b1 01	       lda	joybuttonmode
   5067  271bb			3d 01 f6	       and	thisjoy2buttonbit,x
   5068  271be			f0 0c		       beq	.skip1bjoyfirecheck
   5069  271c0			ad b1 01	       lda	joybuttonmode
   5070  271c3			1d 01 f6	       ora	thisjoy2buttonbit,x
   5071  271c6			8d b1 01	       sta	joybuttonmode
   5072  271c9			8d 82 02	       sta	SWCHB
   5073  271cc				    .skip1bjoyfirecheck
   5074  271cc			a9 3f		       lda	#%00111111
   5075  271ce			1d 02 21	       ora	sINPT1,x
   5076  271d1			9d 02 21	       sta	sINPT1,x	; ensure multibutton bits are hi
   5077  271d4			4c 57 f0	       jmp	buttonreadloopreturn
   5078  271d7
   5079  271d7				    SWCHA_DIRMASK
   5080  271d7							;  p0	p1  p0
   5081  271d7			f0 0f f0	       .byte.b	$F0,$0F,$F0
   5082  271da
   5083  271da				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   5084  271da				   -	       ifconst	LIGHTGUNSUPPORT
   5085  271da				   -	       cpx	#0
   5086  271da				   -	       bne	secondportgunhandler
   5087  271da				   -firstportgunhandler
   5088  271da				   -	       lda	SWCHA
   5089  271da				   -	       asl
   5090  271da				   -	       asl
   5091  271da				   -	       asl		; shift D4 to D7
   5092  271da				   -	       and	#%10000000
   5093  271da				   -	       eor	#%10000000
   5094  271da				   -	       sta	sINPT1
   5095  271da				   -	       jmp	buttonreadloopreturn
   5096  271da				   -secondportgunhandler
   5097  271da				   -	       lda	SWCHA
   5098  271da				   -	       lsr		; shift D0 into carry
   5099  271da				   -	       lsr		; shift carry into D7
   5100  271da				   -	       and	#%10000000
   5101  271da				   -	       eor	#%10000000
   5102  271da				   -	       sta	sINPT3
   5103  271da				   -	       jmp	buttonreadloopreturn
   5104  271da					       endif		; LIGHTGUNSUPPORT
   5105  271da
   5106  271da				    controlsusing2buttoncode
   5107  271da			00		       .byte.b	0	; 00=no controller plugged in
   5108  271db			01		       .byte.b	1	; 01=proline joystick
   5109  271dc			00		       .byte.b	0	; 02=lightgun
   5110  271dd			00		       .byte.b	0	; 03=paddle
   5111  271de			01		       .byte.b	1	; 04=trakball
   5112  271df			01		       .byte.b	1	; 05=vcs joystick
   5113  271e0			01		       .byte.b	1	; 06=driving control
   5114  271e1			00		       .byte.b	0	; 07=keypad control
   5115  271e2			00		       .byte.b	0	; 08=st mouse/cx80
   5116  271e3			00		       .byte.b	0	; 09=amiga mouse
   5117  271e4			01		       .byte.b	1	; 10=atarivox
   5118  271e5			00		       .byte.b	0	; 11=snes2atari
   5119  271e6			00		       .byte.b	0	; 12=mega7800
   5120  271e7
   5121  271e7				    buttonhandlerhi
   5122  271e7			00		       .byte.b	0	; 00=no controller plugged in
   5123  271e8			f1		       .byte.b	>prolinebuttonpadhandler	; 01=proline joystick
   5124  271e9			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   5125  271ea			f5		       .byte.b	>paddlebuttonhandler	; 03=paddle
   5126  271eb			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   5127  271ec			f1		       .byte.b	>joybuttonpadhandler	; 05=vcs joystick
   5128  271ed			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   5129  271ee			00		       .byte.b	0	; 07=keypad
   5130  271ef			f5		       .byte.b	>mousebuttonhandler	; 08=st mouse
   5131  271f0			f5		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   5132  271f1			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   5133  271f2			f0		       .byte.b	>snes2atarihandler	; 11=snes
   5134  271f3			00		       .byte.b	0	; 12=mega7800
   5135  271f4				    buttonhandlerlo
   5136  271f4			00		       .byte.b	0	; 00=no controller plugged in
   5137  271f5			85		       .byte.b	<prolinebuttonpadhandler	; 01=proline joystick
   5138  271f6			da		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   5139  271f7			d1		       .byte.b	<paddlebuttonhandler	; 03=paddle
   5140  271f8			9a		       .byte.b	<joybuttonhandler	; 04=trakball
   5141  271f9			85		       .byte.b	<joybuttonpadhandler	; 05=vcs joystick
   5142  271fa			9a		       .byte.b	<joybuttonhandler	; 06=driving control
   5143  271fb			00		       .byte.b	0	; 07=keypad
   5144  271fc			d1		       .byte.b	<mousebuttonhandler	; 08=st mouse
   5145  271fd			d1		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   5146  271fe			9a		       .byte.b	<joybuttonhandler	; 10=atarivox
   5147  271ff			00		       .byte.b	<snes2atarihandler	; 11=snes
   5148  27200			00		       .byte.b	0	; 12=mega7800
   5149  27201
   5150  27201				    drawwait
   5151  27201			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   5152  27203			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   5153  27205			60		       rts
   5154  27206
   5155  27206				    drawoverwait
   5156  27206			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   5157  27208			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   5158  2720a			60		       rts
   5159  2720b
   5160  2720b
   5161  2720b				    mutetia
   5162  2720b			a9 00		       lda	#0
   5163  2720d			a2 03		       ldx	#3
   5164  2720f				    mutetialoop
   5165  2720f			95 4e		       sta	sfx1pointlo,x
   5166  27211			95 17		       sta	AUDF0,x
   5167  27213			ca		       dex
   5168  27214			10 f9		       bpl	mutetialoop
   5169  27216			60		       rts
   5170  27217
   5171  27217				    servicesfxchannelsdone
   5172  27217					       ifnconst	pokeysupport
   5173  27217			60		       rts
   5174  27218				   -	       else
   5175  27218				   -	       jmp	checkpokeyplaying
   5176  27218					       endif
   5177  27218				    servicesfxchannels
   5178  27218				   -	       ifconst	PAUSESILENT
   5179  27218				   -	       lda	pausestate
   5180  27218				   -	       beq	servicesfxchannels_1
   5181  27218				   -	       rts
   5182  27218				   -servicesfxchannels_1
   5183  27218					       endif
   5184  27218			a2 ff		       ldx	#255
   5185  2721a				    servicesfxchannelsloop
   5186  2721a			e8		       inx
   5187  2721b					       ifnconst	TIASFXMONO
   5188  2721b			e0 02		       cpx	#2
   5189  2721d				   -	       else
   5190  2721d				   -	       cpx	#1
   5191  2721d					       endif
   5192  2721d			f0 f8		       beq	servicesfxchannelsdone
   5193  2721f
   5194  2721f			a5 de		       lda	sfxschedulelock	; =1 if locked
   5195  27221			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   5196  27223
   5197  27223			b5 4e		       lda	sfx1pointlo,x
   5198  27225			85 dc		       sta	inttemp5
   5199  27227			15 50		       ora	sfx1pointhi,x
   5200  27229			f0 ef		       beq	servicesfxchannelsloop
   5201  2722b			b5 50		       lda	sfx1pointhi,x
   5202  2722d			85 dd		       sta	inttemp6
   5203  2722f
   5204  2722f			b5 58		       lda	sfx1tick,x
   5205  27231			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   5206  27233			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   5207  27235			4c 1a f2	       jmp	servicesfxchannelsloop
   5208  27238				    servicesfx_cont1
   5209  27238
   5210  27238			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   5211  2723a			b1 dc		       lda	(inttemp5),y
   5212  2723c			c9 10		       cmp	#$10
   5213  2723e			d0 1b		       bne	servicesfx_cont1a
   5214  27240			a0 02		       ldy	#2
   5215  27242			b1 dc		       lda	(inttemp5),y
   5216  27244			95 56		       sta	sfx1frames,x	; change the frame countdown
   5217  27246			a9 00		       lda	#0
   5218  27248			95 58		       sta	sfx1tick,x
   5219  2724a							; advance the sound pointer by 3...
   5220  2724a			b5 4e		       lda	sfx1pointlo,x
   5221  2724c			18		       clc
   5222  2724d			69 03		       adc	#3
   5223  2724f			95 4e		       sta	sfx1pointlo,x
   5224  27251			b5 50		       lda	sfx1pointhi,x
   5225  27253			69 00		       adc	#0
   5226  27255			95 50		       sta	sfx1pointhi,x
   5227  27257							; and then fetch another sample for this channel...
   5228  27257			ca		       dex
   5229  27258			4c 1a f2	       jmp	servicesfxchannelsloop
   5230  2725b				    servicesfx_cont1a
   5231  2725b
   5232  2725b			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   5233  2725d			95 58		       sta	sfx1tick,x
   5234  2725f
   5235  2725f			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   5236  27261			f0 02		       beq	servicesfx_cont2
   5237  27263			d6 52		       dec	sfx1priority,x
   5238  27265				    servicesfx_cont2
   5239  27265
   5240  27265			a0 00		       ldy	#0	; play the sound
   5241  27267			b1 dc		       lda	(inttemp5),y
   5242  27269			85 d8		       sta	inttemp1
   5243  2726b
   5244  2726b				   -	       ifconst	MUSICTRACKER
   5245  2726b				   -	       lda	sfx1notedata,x
   5246  2726b				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   5247  2726b				   -	       ldy	#0
   5248  2726b				   -	       sty	inttemp2
   5249  2726b				   -	       clc
   5250  2726b				   -	       adc	(inttemp5),y
   5251  2726b				   -	       asl		; x2
   5252  2726b				   -	       tay
   5253  2726b				   -	       lda	tiatrackeroctavenotes,y
   5254  2726b				   -	       sta	AUDC0,x
   5255  2726b				   -	       iny
   5256  2726b				   -	       lda	tiatrackeroctavenotes,y
   5257  2726b				   -	       sta	AUDF0,x
   5258  2726b				   -	       ldy	#1
   5259  2726b				   -	       jmp	sfxvolumeentrypt
   5260  2726b				   -exitmusictracker
   5261  2726b				   -	       lda	inttemp1
   5262  2726b					       endif		; MUSICTRACKER
   5263  2726b
   5264  2726b			18		       clc
   5265  2726c			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   5266  2726e			95 17		       sta	AUDF0,x
   5267  27270			c8		       iny
   5268  27271			b1 dc		       lda	(inttemp5),y
   5269  27273			95 15		       sta	AUDC0,x
   5270  27275			85 d9		       sta	inttemp2
   5271  27277			c8		       iny
   5272  27278				    sfxvolumeentrypt
   5273  27278				   -	       ifconst	TIAVOLUME
   5274  27278				   -	       lda	tiavolume
   5275  27278				   -	       asl
   5276  27278				   -	       asl
   5277  27278				   -	       asl
   5278  27278				   -	       asl
   5279  27278				   -	       sta	fourbitfadevalueint
   5280  27278					       endif		; TIAVOLUME
   5281  27278			b1 dc		       lda	(inttemp5),y
   5282  2727a				   -	       ifconst	TIAVOLUME
   5283  2727a				   -	       jsr	fourbitfadeint
   5284  2727a					       endif		; TIAVOLUME
   5285  2727a			95 19		       sta	AUDV0,x
   5286  2727c			c9 10		       cmp	#$10
   5287  2727e			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   5288  27280
   5289  27280			05 d9		       ora	inttemp2
   5290  27282			05 d8		       ora	inttemp1	; check if F|C|V=0
   5291  27284			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   5292  27286
   5293  27286				    advancesfxpointer
   5294  27286							; advance the pointer to the next sound chunk
   5295  27286			c8		       iny
   5296  27287			84 da		       sty	inttemp3
   5297  27289			18		       clc
   5298  2728a			b5 4e		       lda	sfx1pointlo,x
   5299  2728c			65 da		       adc	inttemp3
   5300  2728e			95 4e		       sta	sfx1pointlo,x
   5301  27290			b5 50		       lda	sfx1pointhi,x
   5302  27292			69 00		       adc	#0
   5303  27294			95 50		       sta	sfx1pointhi,x
   5304  27296			4c 1a f2	       jmp	servicesfxchannelsloop
   5305  27299
   5306  27299				    sfxsoundloop
   5307  27299			48		       pha
   5308  2729a			b5 52		       lda	sfx1priority,x
   5309  2729c			d0 04		       bne	sfxsoundloop_carryon
   5310  2729e			68		       pla		; fix the stack before we go
   5311  2729f			4c 86 f2	       jmp	advancesfxpointer
   5312  272a2				    sfxsoundloop_carryon
   5313  272a2			68		       pla
   5314  272a3			29 f0		       and	#$F0
   5315  272a5			4a		       lsr
   5316  272a6			4a		       lsr
   5317  272a7			4a		       lsr
   5318  272a8			4a		       lsr
   5319  272a9
   5320  272a9				    zerosfx
   5321  272a9			95 4e		       sta	sfx1pointlo,x
   5322  272ab			95 50		       sta	sfx1pointhi,x
   5323  272ad			95 52		       sta	sfx1priority,x
   5324  272af			4c 1a f2	       jmp	servicesfxchannelsloop
   5325  272b2
   5326  272b2
   5327  272b2				    schedulesfx
   5328  272b2							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   5329  272b2			a0 00		       ldy	#0
   5330  272b4				   -	       ifconst	pokeysupport
   5331  272b4				   -	       lda	sfxinstrumenthi
   5332  272b4				   -	       beq	scheduletiasfx	; drums have undefined instrument
   5333  272b4				   -	       lda	(sfxinstrumentlo),y
   5334  272b4				   -	       cmp	#$20	; POKEY?
   5335  272b4				   -	       bne	scheduletiasfx
   5336  272b4				   -	       jmp	schedulepokeysfx
   5337  272b4					       endif
   5338  272b4				    scheduletiasfx
   5339  272b4							;cmp #$10 ; TIA?
   5340  272b4							;beq continuescheduletiasfx
   5341  272b4							; rts ; unhandled!!! 
   5342  272b4				    continuescheduletiasfx
   5343  272b4					       ifnconst	TIASFXMONO
   5344  272b4			a5 50		       lda	sfx1pointhi
   5345  272b6			f0 15		       beq	schedulesfx1	;if channel 1 is idle, use it
   5346  272b8			a5 51		       lda	sfx2pointhi
   5347  272ba			f0 15		       beq	schedulesfx2	;if channel 2 is idle, use it
   5348  272bc							; Both channels are scheduled. 
   5349  272bc			a5 e1		       lda	sfxinstrumenthi
   5350  272be			f0 06		       beq	skipscheduledrums
   5351  272c0			a0 01		       ldy	#1
   5352  272c2			b1 e0		       lda	(sfxinstrumentlo),y
   5353  272c4			d0 01		       bne	interruptsfx
   5354  272c6				    skipscheduledrums
   5355  272c6			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   5356  272c7				    interruptsfx
   5357  272c7							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   5358  272c7			a5 52		       lda	sfx1priority
   5359  272c9			c5 53		       cmp	sfx2priority
   5360  272cb			b0 04		       bcs	schedulesfx2
   5361  272cd					       endif		; !TIASFXMONO
   5362  272cd
   5363  272cd				    schedulesfx1
   5364  272cd			a2 00		       ldx	#0	; channel 1
   5365  272cf					       ifnconst	TIASFXMONO
   5366  272cf			f0 02		       beq	skipschedulesfx2
   5367  272d1				    schedulesfx2
   5368  272d1			a2 01		       ldx	#1	; channel 2
   5369  272d3				    skipschedulesfx2
   5370  272d3					       endif		; !TIASFXMONO
   5371  272d3
   5372  272d3				   -	       ifconst	MUSICTRACKER
   5373  272d3				   -	       lda	sfxnoteindex
   5374  272d3				   -	       bpl	skipdrumkitoverride
   5375  272d3				   -	       and	#$7F	; subtract 128
   5376  272d3				   -	       sec
   5377  272d3				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   5378  272d3				   -	       asl
   5379  272d3				   -	       tay
   5380  272d3				   -	       lda	tiadrumkitdefinition,y
   5381  272d3				   -	       sta	sfxinstrumentlo
   5382  272d3				   -	       iny
   5383  272d3				   -	       lda	tiadrumkitdefinition,y
   5384  272d3				   -	       sta	sfxinstrumenthi
   5385  272d3				   -	       lda	#0
   5386  272d3				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   5387  272d3				   -skipdrumkitoverride
   5388  272d3					       endif		; MUSICTRACKER
   5389  272d3			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   5390  272d5			b1 e0		       lda	(sfxinstrumentlo),y
   5391  272d7			95 52		       sta	sfx1priority,x
   5392  272d9			c8		       iny
   5393  272da			b1 e0		       lda	(sfxinstrumentlo),y
   5394  272dc			95 56		       sta	sfx1frames,x
   5395  272de			a5 e0		       lda	sfxinstrumentlo
   5396  272e0			18		       clc
   5397  272e1			69 03		       adc	#3
   5398  272e3			95 4e		       sta	sfx1pointlo,x
   5399  272e5			a5 e1		       lda	sfxinstrumenthi
   5400  272e7			69 00		       adc	#0
   5401  272e9			95 50		       sta	sfx1pointhi,x
   5402  272eb			a5 e2		       lda	sfxpitchoffset
   5403  272ed			95 54		       sta	sfx1poffset,x
   5404  272ef			a9 00		       lda	#0
   5405  272f1			95 58		       sta	sfx1tick,x
   5406  272f3			a5 e3		       lda	sfxnoteindex
   5407  272f5			95 cd		       sta	sfx1notedata,x
   5408  272f7			60		       rts
   5409  272f8
   5410  272f8				    plotsprite
   5411  272f8					       ifnconst	NODRAWWAIT
   5412  272f8					       ifconst	DOUBLEBUFFER
   5413  272f8			a5 d5		       lda	doublebufferstate
   5414  272fa			d0 04		       bne	skipplotspritewait
   5415  272fc					       endif		; DOUBLEBUFFER
   5416  272fc				   -	       ifconst	DEBUGWAITCOLOR
   5417  272fc				   -	       lda	#$41
   5418  272fc				   -	       sta	BACKGRND
   5419  272fc					       endif
   5420  272fc				    plotspritewait
   5421  272fc			a5 4d		       lda	visibleover
   5422  272fe			d0 fc		       bne	plotspritewait
   5423  27300				    skipplotspritewait
   5424  27300				   -	       ifconst	DEBUGWAITCOLOR
   5425  27300				   -	       lda	#$0
   5426  27300				   -	       sta	BACKGRND
   5427  27300					       endif
   5428  27300					       endif
   5429  27300
   5430  27300							;arguments: 
   5431  27300							; temp1=lo graphicdata 
   5432  27300							; temp2=hi graphicdata 
   5433  27300							; temp3=palette | width byte
   5434  27300							; temp4=x
   5435  27300							; temp5=y
   5436  27300							; temp6=mode
   5437  27300			a5 46		       lda	temp5	;Y position
   5438  27302			4a		       lsr		; 2 - Divide by 8 or 16
   5439  27303			4a		       lsr		; 2
   5440  27304			4a		       lsr		; 2
   5441  27305					       if	WZONEHEIGHT = 16
   5442  27305			4a		       lsr		; 2
   5443  27306					       endif
   5444  27306
   5445  27306			aa		       tax
   5446  27307
   5447  27307					       ifnconst	NOLIMITCHECKING
   5448  27307
   5449  27307							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   5450  27307
   5451  27307			c9 0c		       cmp	#WZONECOUNT
   5452  27309
   5453  27309			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   5454  2730b							; otherwise, check to see if the bottom half is in zone 0...
   5455  2730b
   5456  2730b					       if	WZONEHEIGHT = 16
   5457  2730b			c9 0f		       cmp	#15
   5458  2730d				   -	       else
   5459  2730d				   -	       cmp	#31
   5460  2730d					       endif
   5461  2730d
   5462  2730d			d0 05		       bne	exitplotsprite1
   5463  2730f			a2 00		       ldx	#0
   5464  27311			4c 4f f3	       jmp	continueplotsprite2
   5465  27314				    exitplotsprite1
   5466  27314			60		       rts
   5467  27315
   5468  27315				    continueplotsprite1
   5469  27315					       endif
   5470  27315
   5471  27315				   -	       ifconst	VSCROLL
   5472  27315				   -	       ldy	Xx3,x
   5473  27315				   -	       lda	DLLMEM+11,y
   5474  27315					       else		; !VSCROLL
   5475  27315			bd 93 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   5476  27318					       endif		; !VSCROLL
   5477  27318					       ifconst	DOUBLEBUFFER
   5478  27318			18		       clc
   5479  27319			65 d6		       adc	doublebufferdloffset
   5480  2731b					       endif		; DOUBLEBUFFER
   5481  2731b			85 63		       sta	dlpnt
   5482  2731d				   -	       ifconst	VSCROLL
   5483  2731d				   -	       lda	DLLMEM+10,y
   5484  2731d					       else		; !VSCROLL
   5485  2731d			bd 87 f6	       lda	DLPOINTH,x
   5486  27320					       endif		; !VSCROLL
   5487  27320					       ifconst	DOUBLEBUFFER
   5488  27320			69 00		       adc	#0
   5489  27322					       endif		; DOUBLEBUFFER
   5490  27322			85 64		       sta	dlpnt+1
   5491  27324
   5492  27324							;Create DL entry for upper part of sprite
   5493  27324
   5494  27324			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   5495  27326
   5496  27326				   -	       ifconst	CHECKOVERWRITE
   5497  27326				   -	       cpy	#DLLASTOBJ
   5498  27326				   -	       beq	checkcontinueplotsprite2
   5499  27326				   -continueplotsprite1a
   5500  27326					       endif
   5501  27326
   5502  27326			a5 42		       lda	temp1	; graphic data, lo byte
   5503  27328			91 63		       sta	(dlpnt),y	;Low byte of data address
   5504  2732a
   5505  2732a					       ifnconst	ATOMICSPRITEUPDATE
   5506  2732a			c8		       iny
   5507  2732b			a5 47		       lda	temp6
   5508  2732d			91 63		       sta	(dlpnt),y
   5509  2732f				   -	       else
   5510  2732f				   -	       iny
   5511  2732f				   -	       sty	temp8
   5512  2732f					       endif
   5513  2732f
   5514  2732f			c8		       iny
   5515  27330
   5516  27330			a5 46		       lda	temp5	;Y position
   5517  27332			29 0f		       and	#(WZONEHEIGHT - 1)
   5518  27334			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   5519  27336			05 43		       ora	temp2	; graphic data, hi byte
   5520  27338			91 63		       sta	(dlpnt),y
   5521  2733a
   5522  2733a			c8		       iny
   5523  2733b			a5 44		       lda	temp3	;palette|width
   5524  2733d			91 63		       sta	(dlpnt),y
   5525  2733f
   5526  2733f			c8		       iny
   5527  27340			a5 45		       lda	temp4	;Horizontal position
   5528  27342			91 63		       sta	(dlpnt),y
   5529  27344
   5530  27344			c8		       iny
   5531  27345			94 65		       sty	dlend,x
   5532  27347
   5533  27347				   -	       ifconst	ALWAYSTERMINATE
   5534  27347				   -	       iny
   5535  27347				   -	       lda	#0
   5536  27347				   -	       sta	(dlpnt),y
   5537  27347					       endif
   5538  27347
   5539  27347				   -	       ifconst	ATOMICSPRITEUPDATE
   5540  27347				   -	       ldy	temp8
   5541  27347				   -	       lda	temp6
   5542  27347				   -	       sta	(dlpnt),y
   5543  27347					       endif
   5544  27347
   5545  27347				    checkcontinueplotsprite2
   5546  27347
   5547  27347			90 38		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   5548  27349
   5549  27349							;Create DL entry for lower part of sprite
   5550  27349
   5551  27349			e8		       inx		;Next region
   5552  2734a
   5553  2734a					       ifnconst	NOLIMITCHECKING
   5554  2734a			e0 0c		       cpx	#WZONECOUNT
   5555  2734c
   5556  2734c			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   5557  2734e			60		       rts
   5558  2734f				    continueplotsprite2
   5559  2734f					       endif
   5560  2734f
   5561  2734f				   -	       ifconst	VSCROLL
   5562  2734f				   -	       ldy	Xx3,x
   5563  2734f				   -	       lda	DLLMEM+11,y
   5564  2734f					       else		; !VSCROLL
   5565  2734f			bd 93 f6	       lda	DLPOINTL,x	;Get pointer to next DL
   5566  27352					       endif		; !VSCROLL
   5567  27352					       ifconst	DOUBLEBUFFER
   5568  27352			18		       clc
   5569  27353			65 d6		       adc	doublebufferdloffset
   5570  27355					       endif		; DOUBLEBUFFER
   5571  27355			85 63		       sta	dlpnt
   5572  27357				   -	       ifconst	VSCROLL
   5573  27357				   -	       lda	DLLMEM+10,y
   5574  27357					       else		; !VSCROLL
   5575  27357			bd 87 f6	       lda	DLPOINTH,x
   5576  2735a					       endif		; !VSCROLL
   5577  2735a					       ifconst	DOUBLEBUFFER
   5578  2735a			69 00		       adc	#0
   5579  2735c					       endif		; DOUBLEBUFFER
   5580  2735c			85 64		       sta	dlpnt+1
   5581  2735e			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   5582  27360
   5583  27360				   -	       ifconst	CHECKOVERWRITE
   5584  27360				   -	       cpy	#DLLASTOBJ
   5585  27360				   -	       bne	continueplotsprite2a
   5586  27360				   -	       rts
   5587  27360				   -continueplotsprite2a
   5588  27360					       endif
   5589  27360
   5590  27360			a5 42		       lda	temp1	; graphic data, lo byte
   5591  27362			91 63		       sta	(dlpnt),y
   5592  27364
   5593  27364					       ifnconst	ATOMICSPRITEUPDATE
   5594  27364			c8		       iny
   5595  27365			a5 47		       lda	temp6
   5596  27367			91 63		       sta	(dlpnt),y
   5597  27369				   -	       else
   5598  27369				   -	       iny
   5599  27369				   -	       sty	temp8
   5600  27369					       endif
   5601  27369
   5602  27369			c8		       iny
   5603  2736a
   5604  2736a			a5 46		       lda	temp5	;Y position
   5605  2736c			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   5606  2736e			05 43		       ora	temp2	; graphic data, hi byte
   5607  27370			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   5608  27372			91 63		       sta	(dlpnt),y
   5609  27374
   5610  27374			c8		       iny
   5611  27375
   5612  27375			a5 44		       lda	temp3	;palette|width
   5613  27377			91 63		       sta	(dlpnt),y
   5614  27379
   5615  27379			c8		       iny
   5616  2737a
   5617  2737a			a5 45		       lda	temp4	;Horizontal position
   5618  2737c			91 63		       sta	(dlpnt),y
   5619  2737e
   5620  2737e			c8		       iny
   5621  2737f			94 65		       sty	dlend,x
   5622  27381
   5623  27381				   -	       ifconst	ALWAYSTERMINATE
   5624  27381				   -	       iny
   5625  27381				   -	       lda	#0
   5626  27381				   -	       sta	(dlpnt),y
   5627  27381					       endif
   5628  27381
   5629  27381				   -	       ifconst	ATOMICSPRITEUPDATE
   5630  27381				   -	       ldy	temp8
   5631  27381				   -	       lda	temp6
   5632  27381				   -	       sta	(dlpnt),y
   5633  27381					       endif
   5634  27381
   5635  27381				    doneSPDL
   5636  27381			60		       rts
   5637  27382
   5638  27382				   -	       ifconst	VSCROLL
   5639  27382				   -			; x3 table for fast DLL parsing
   5640  27382				   -Xx3
   5641  27382				   -	       .byte	0,3,6,9,12,15,18,21,24,27
   5642  27382				   -	       .byte	30,33,36,39,42,45,48,51,54,57
   5643  27382				   -	       .byte	60,63,66,69,72,75,78,81,84,87
   5644  27382				   -maskscrollsprite
   5645  27382				   -	       .byte	$00,%11000000,($D0+WZONEHEIGHT),0,160	; 5*2 + 32*3 = 106 cycles
   5646  27382				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   5647  27382				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   5648  27382				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   5649  27382				   -	       .byte	$00,%01000000,($D0+WZONEHEIGHT),16,160	; 5*2 + 16*3 =  58 cycles
   5650  27382				   -			; MAX	============ 467 cycles
   5651  27382				   -			; MIN	============  59 cycles
   5652  27382				   -maskscrollspriteend
   5653  27382					       endif		; VSCROLL
   5654  27382
   5655  27382				    lockzonex
   5656  27382				   -	       ifconst	ZONELOCKS
   5657  27382				   -	       ldy	dlend,x
   5658  27382				   -	       cpy	#DLLASTOBJ
   5659  27382				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   5660  27382				   -	       lda	DLPOINTL,x
   5661  27382				   -	       ifconst	DOUBLEBUFFER
   5662  27382				   -	       clc
   5663  27382				   -	       adc	doublebufferdloffset
   5664  27382				   -	       endif		; DOUBLEBUFFER
   5665  27382				   -	       sta	dlpnt
   5666  27382				   -	       lda	DLPOINTH,x
   5667  27382				   -	       ifconst	DOUBLEBUFFER
   5668  27382				   -	       adc	#0
   5669  27382				   -	       endif		; DOUBLEBUFFER
   5670  27382				   -	       sta	dlpnt+1
   5671  27382				   -	       iny
   5672  27382				   -	       lda	#0
   5673  27382				   -	       sta	(dlpnt),y
   5674  27382				   -	       dey
   5675  27382				   -	       tya
   5676  27382				   -	       ldy	#(DLLASTOBJ-1)
   5677  27382				   -	       sta	(dlpnt),y
   5678  27382				   -	       iny
   5679  27382				   -	       sty	dlend,x
   5680  27382				   -lockzonexreturn
   5681  27382				   -	       rts
   5682  27382					       endif		; ZONELOCKS
   5683  27382				    unlockzonex
   5684  27382				   -	       ifconst	ZONELOCKS
   5685  27382				   -	       ldy	dlend,x
   5686  27382				   -	       cpy	#DLLASTOBJ
   5687  27382				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   5688  27382				   -	       lda	DLPOINTL,x
   5689  27382				   -	       ifconst	DOUBLEBUFFER
   5690  27382				   -	       clc
   5691  27382				   -	       adc	doublebufferdloffset
   5692  27382				   -	       endif		; DOUBLEBUFFER
   5693  27382				   -	       sta	dlpnt
   5694  27382				   -	       lda	DLPOINTH,x
   5695  27382				   -	       ifconst	DOUBLEBUFFER
   5696  27382				   -	       adc	#0
   5697  27382				   -	       endif		; DOUBLEBUFFER
   5698  27382				   -	       sta	dlpnt+1
   5699  27382				   -	       dey
   5700  27382				   -	       lda	(dlpnt),y
   5701  27382				   -	       tay
   5702  27382				   -	       sty	dlend,x
   5703  27382				   -unlockzonexreturn
   5704  27382					       endif		; ZONELOCKS
   5705  27382			60		       rts
   5706  27383
   5707  27383				    plotcharloop
   5708  27383							; ** read from a data indirectly pointed to from temp8,temp9
   5709  27383							; ** format is: lo_data, hi_data, palette|width, x, y
   5710  27383							; ** format ends with lo_data | hi_data = 0
   5711  27383
   5712  27383					       ifconst	DOUBLEBUFFER
   5713  27383			a5 d5		       lda	doublebufferstate
   5714  27385			d0 04		       bne	skipplotcharloopwait
   5715  27387					       endif		; DOUBLEBUFFER
   5716  27387				   -	       ifconst	DEBUGWAITCOLOR
   5717  27387				   -	       lda	#$61
   5718  27387				   -	       sta	BACKGRND
   5719  27387					       endif
   5720  27387				    plotcharloopwait
   5721  27387			a5 4d		       lda	visibleover
   5722  27389			d0 fc		       bne	plotcharloopwait
   5723  2738b				   -	       ifconst	DEBUGWAITCOLOR
   5724  2738b				   -	       lda	#0
   5725  2738b				   -	       sta	BACKGRND
   5726  2738b					       endif
   5727  2738b				    skipplotcharloopwait
   5728  2738b				    plotcharlooploop
   5729  2738b			a0 00		       ldy	#0
   5730  2738d			b1 49		       lda	(temp8),y
   5731  2738f			85 42		       sta	temp1
   5732  27391			c8		       iny
   5733  27392			b1 49		       lda	(temp8),y
   5734  27394			85 43		       sta	temp2
   5735  27396			05 42		       ora	temp1
   5736  27398			d0 01		       bne	plotcharloopcontinue
   5737  2739a							;the pointer=0, so return
   5738  2739a			60		       rts
   5739  2739b				    plotcharloopcontinue
   5740  2739b			c8		       iny
   5741  2739c			b1 49		       lda	(temp8),y
   5742  2739e			85 44		       sta	temp3
   5743  273a0			c8		       iny
   5744  273a1			b1 49		       lda	(temp8),y
   5745  273a3			85 45		       sta	temp4
   5746  273a5			c8		       iny
   5747  273a6			b1 49		       lda	(temp8),y
   5748  273a8							;sta temp5 ; not needed with our late entry.
   5749  273a8			20 c5 f3	       jsr	plotcharactersskipentry
   5750  273ab			a5 49		       lda	temp8
   5751  273ad			18		       clc
   5752  273ae			69 05		       adc	#5
   5753  273b0			85 49		       sta	temp8
   5754  273b2			a5 4a		       lda	temp9
   5755  273b4			69 00		       adc	#0
   5756  273b6			85 4a		       sta	temp9
   5757  273b8			4c 8b f3	       jmp	plotcharlooploop
   5758  273bb
   5759  273bb				    plotcharacters
   5760  273bb					       ifconst	DOUBLEBUFFER
   5761  273bb			a5 d5		       lda	doublebufferstate
   5762  273bd			d0 04		       bne	skipplotcharacterswait
   5763  273bf					       endif		; DOUBLEBUFFER
   5764  273bf				   -	       ifconst	DEBUGWAITCOLOR
   5765  273bf				   -	       lda	#$41
   5766  273bf				   -	       sta	BACKGRND
   5767  273bf					       endif
   5768  273bf				    plotcharacterswait
   5769  273bf			a5 4d		       lda	visibleover
   5770  273c1			d0 fc		       bne	plotcharacterswait
   5771  273c3				   -	       ifconst	DEBUGWAITCOLOR
   5772  273c3				   -	       sta	BACKGRND
   5773  273c3					       endif
   5774  273c3				    skipplotcharacterswait
   5775  273c3							;arguments: 
   5776  273c3							; temp1=lo charactermap
   5777  273c3							; temp2=hi charactermap
   5778  273c3							; temp3=palette | width byte
   5779  273c3							; temp4=x
   5780  273c3							; temp5=y
   5781  273c3
   5782  273c3			a5 46		       lda	temp5	;Y position
   5783  273c5
   5784  273c5				    plotcharactersskipentry
   5785  273c5
   5786  273c5							;ifconst ZONEHEIGHT
   5787  273c5							; if ZONEHEIGHT = 16
   5788  273c5							; and #$0F
   5789  273c5							; endif
   5790  273c5							; if ZONEHEIGHT = 8
   5791  273c5							; and #$1F
   5792  273c5							; endif
   5793  273c5							;else
   5794  273c5							; and #$0F
   5795  273c5							;endif
   5796  273c5
   5797  273c5			aa		       tax
   5798  273c6
   5799  273c6				   -	       ifconst	VSCROLL
   5800  273c6				   -	       ldy	Xx3,x
   5801  273c6				   -	       lda	DLLMEM+11,y
   5802  273c6					       else		; !VSCROLL
   5803  273c6			bd 93 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   5804  273c9					       endif		; !VSCROLL
   5805  273c9					       ifconst	DOUBLEBUFFER
   5806  273c9			18		       clc
   5807  273ca			65 d6		       adc	doublebufferdloffset
   5808  273cc					       endif		; DOUBLEBUFFER
   5809  273cc			85 63		       sta	dlpnt
   5810  273ce				   -	       ifconst	VSCROLL
   5811  273ce				   -	       lda	DLLMEM+10,y
   5812  273ce					       else		; !VSCROLL
   5813  273ce			bd 87 f6	       lda	DLPOINTH,x
   5814  273d1					       endif		; !VSCROLL
   5815  273d1					       ifconst	DOUBLEBUFFER
   5816  273d1			69 00		       adc	#0
   5817  273d3					       endif		; DOUBLEBUFFER
   5818  273d3			85 64		       sta	dlpnt+1
   5819  273d5
   5820  273d5							;Create DL entry for the characters
   5821  273d5
   5822  273d5			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   5823  273d7
   5824  273d7				   -	       ifconst	CHECKOVERWRITE
   5825  273d7				   -	       cpy	#DLLASTOBJ
   5826  273d7				   -	       bne	continueplotcharacters
   5827  273d7				   -	       rts
   5828  273d7				   -continueplotcharacters
   5829  273d7					       endif
   5830  273d7
   5831  273d7			a5 42		       lda	temp1	; character map data, lo byte
   5832  273d9			91 63		       sta	(dlpnt),y	;(1) store low address
   5833  273db
   5834  273db			c8		       iny
   5835  273dc			ad 06 21	       lda	charactermode
   5836  273df			91 63		       sta	(dlpnt),y	;(2) store mode
   5837  273e1
   5838  273e1			c8		       iny
   5839  273e2			a5 43		       lda	temp2	; character map, hi byte
   5840  273e4			91 63		       sta	(dlpnt),y	;(3) store high address
   5841  273e6
   5842  273e6			c8		       iny
   5843  273e7			a5 44		       lda	temp3	;palette|width
   5844  273e9			91 63		       sta	(dlpnt),y	;(4) store palette|width
   5845  273eb
   5846  273eb			c8		       iny
   5847  273ec			a5 45		       lda	temp4	;Horizontal position
   5848  273ee			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   5849  273f0
   5850  273f0			c8		       iny
   5851  273f1			94 65		       sty	dlend,x	; save display list end byte
   5852  273f3			60		       rts
   5853  273f4
   5854  273f4
   5855  273f4					       ifconst	plotvalueonscreen
   5856  273f4				    plotcharacterslive
   5857  273f4							; a version of plotcharacters that draws live and minimally disrupts the screen...
   5858  273f4
   5859  273f4							;arguments: 
   5860  273f4							; temp1=lo charactermap
   5861  273f4							; temp2=hi charactermap
   5862  273f4							; temp3=palette | width byte
   5863  273f4							; temp4=x
   5864  273f4							; temp5=y
   5865  273f4
   5866  273f4			a5 46		       lda	temp5	;Y position
   5867  273f6
   5868  273f6			aa		       tax
   5869  273f7
   5870  273f7				   -	       ifconst	VSCROLL
   5871  273f7				   -	       ldy	Xx3,x
   5872  273f7				   -	       lda	DLLMEM+11,y
   5873  273f7					       else		; !VSCROLL
   5874  273f7			bd 93 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   5875  273fa					       endif		; !VSCROLL
   5876  273fa					       ifconst	DOUBLEBUFFER
   5877  273fa			18		       clc
   5878  273fb			65 d6		       adc	doublebufferdloffset
   5879  273fd					       endif		; DOUBLEBUFFER
   5880  273fd			85 63		       sta	dlpnt
   5881  273ff				   -	       ifconst	VSCROLL
   5882  273ff				   -	       lda	DLLMEM+10,y
   5883  273ff					       else		; !VSCROLL
   5884  273ff			bd 87 f6	       lda	DLPOINTH,x
   5885  27402					       endif		; !VSCROLL
   5886  27402					       ifconst	DOUBLEBUFFER
   5887  27402			69 00		       adc	#0
   5888  27404					       endif		; DOUBLEBUFFER
   5889  27404			85 64		       sta	dlpnt+1
   5890  27406
   5891  27406							;Create DL entry for the characters
   5892  27406
   5893  27406			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   5894  27408
   5895  27408				   -	       ifconst	CHECKOVERWRITE
   5896  27408				   -	       cpy	#DLLASTOBJ
   5897  27408				   -	       bne	continueplotcharacterslive
   5898  27408				   -	       rts
   5899  27408				   -continueplotcharacterslive
   5900  27408					       endif
   5901  27408
   5902  27408			a5 42		       lda	temp1	; character map data, lo byte
   5903  2740a			91 63		       sta	(dlpnt),y	;(1) store low address
   5904  2740c
   5905  2740c			c8		       iny
   5906  2740d							; we don't add the second byte yet, since the charmap could briefly
   5907  2740d							; render without a proper character map address, width, or position.
   5908  2740d			ad 06 21	       lda	charactermode
   5909  27410			91 63		       sta	(dlpnt),y	;(2) store mode
   5910  27412
   5911  27412			c8		       iny
   5912  27413			a5 43		       lda	temp2	; character map, hi byte
   5913  27415			91 63		       sta	(dlpnt),y	;(3) store high address
   5914  27417
   5915  27417			c8		       iny
   5916  27418			a5 44		       lda	temp3	;palette|width
   5917  2741a			91 63		       sta	(dlpnt),y	;(4) store palette|width
   5918  2741c
   5919  2741c			c8		       iny
   5920  2741d			a5 45		       lda	temp4	;Horizontal position
   5921  2741f			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   5922  27421
   5923  27421			c8		       iny
   5924  27422			94 65		       sty	dlend,x	; save display list end byte
   5925  27424
   5926  27424			60		       rts
   5927  27425					       endif		;plotcharacterslive
   5928  27425
   5929  27425					       ifconst	USED_PLOTVALUE
   5930  27425				    plotvalue
   5931  27425							; calling 7800basic command:
   5932  27425							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   5933  27425							; ...displays the variable as BCD digits
   5934  27425							;
   5935  27425							; asm sub arguments: 
   5936  27425							; temp1=lo charactermap
   5937  27425							; temp2=hi charactermap
   5938  27425							; temp3=palette | width byte
   5939  27425							; temp4=x
   5940  27425							; temp5=y
   5941  27425							; temp6=number of digits
   5942  27425							; temp7=lo variable
   5943  27425							; temp8=hi variable
   5944  27425							; temp9=character mode
   5945  27425
   5946  27425			00 47	    plotdigitcount =	temp6
   5947  27425
   5948  27425				   -	       ifconst	ZONELOCKS
   5949  27425				   -	       ldx	temp5
   5950  27425				   -	       ldy	dlend,x
   5951  27425				   -	       cpy	#DLLASTOBJ
   5952  27425				   -	       bne	carryonplotvalue
   5953  27425				   -	       rts
   5954  27425				   -carryonplotvalue
   5955  27425					       endif
   5956  27425
   5957  27425			a9 00		       lda	#0
   5958  27427			a8		       tay
   5959  27428			ae ad 01	       ldx	valbufend
   5960  2742b
   5961  2742b			a5 47		       lda	plotdigitcount
   5962  2742d			29 01		       and	#1
   5963  2742f			f0 07		       beq	pvnibble2char
   5964  27431			a9 00		       lda	#0
   5965  27433			9d 00 20	       sta	VALBUFFER,x	; just in case we skip this digit
   5966  27436			f0 11		       beq	pvnibble2char_skipnibble
   5967  27438
   5968  27438				    pvnibble2char
   5969  27438							; high nibble...
   5970  27438			b1 48		       lda	(temp7),y
   5971  2743a			29 f0		       and	#$f0
   5972  2743c			4a		       lsr
   5973  2743d			4a		       lsr
   5974  2743e			4a		       lsr
   5975  2743f					       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5976  2743f			4a		       lsr
   5977  27440					       endif
   5978  27440
   5979  27440			18		       clc
   5980  27441			65 42		       adc	temp1	; add the offset to character graphics to our value
   5981  27443			9d 00 20	       sta	VALBUFFER,x
   5982  27446			e8		       inx
   5983  27447			c6 47		       dec	plotdigitcount
   5984  27449
   5985  27449				    pvnibble2char_skipnibble
   5986  27449							; low nibble...
   5987  27449			b1 48		       lda	(temp7),y
   5988  2744b			29 0f		       and	#$0f
   5989  2744d				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5990  2744d				   -	       asl
   5991  2744d					       endif
   5992  2744d			18		       clc
   5993  2744e			65 42		       adc	temp1	; add the offset to character graphics to our value
   5994  27450			9d 00 20	       sta	VALBUFFER,x
   5995  27453			e8		       inx
   5996  27454			c8		       iny
   5997  27455
   5998  27455			c6 47		       dec	plotdigitcount
   5999  27457			d0 df		       bne	pvnibble2char
   6000  27459
   6001  27459							;point to the start of our valuebuffer
   6002  27459			18		       clc
   6003  2745a			a9 00		       lda	#<VALBUFFER
   6004  2745c			6d ad 01	       adc	valbufend
   6005  2745f			85 42		       sta	temp1
   6006  27461			a9 20		       lda	#>VALBUFFER
   6007  27463			69 00		       adc	#0
   6008  27465			85 43		       sta	temp2
   6009  27467
   6010  27467							;advance valbufend to the end of our value buffer
   6011  27467			8e ad 01	       stx	valbufend
   6012  2746a
   6013  2746a				   -	       ifnconst	plotvalueonscreen
   6014  2746a				   -	       jmp	plotcharacters
   6015  2746a					       else
   6016  2746a			4c f4 f3	       jmp	plotcharacterslive
   6017  2746d					       endif
   6018  2746d
   6019  2746d					       endif		; USED_PLOTVALUE
   6020  2746d
   6021  2746d
   6022  2746d				   -	       ifconst	USED_PLOTVALUEEXTRA
   6023  2746d				   -plotdigitcount =	temp6
   6024  2746d				   -plotvalueextra
   6025  2746d				   -			; calling 7800basic command:
   6026  2746d				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   6027  2746d				   -			; ...displays the variable as BCD digits
   6028  2746d				   -			;
   6029  2746d				   -			; asm sub arguments: 
   6030  2746d				   -			; temp1=lo charactermap
   6031  2746d				   -			; temp2=hi charactermap
   6032  2746d				   -			; temp3=palette | width byte
   6033  2746d				   -			; temp4=x
   6034  2746d				   -			; temp5=y
   6035  2746d				   -			; temp6=number of digits
   6036  2746d				   -			; temp7=lo variable
   6037  2746d				   -			; temp8=hi variable
   6038  2746d				   -
   6039  2746d				   -	       lda	#0
   6040  2746d				   -	       tay
   6041  2746d				   -	       ldx	valbufend
   6042  2746d				   -	       ifnconst	plotvalueonscreen
   6043  2746d				   -	       sta	VALBUFFER,x
   6044  2746d				   -	       endif
   6045  2746d				   -
   6046  2746d				   -	       lda	plotdigitcount
   6047  2746d				   -	       and	#1
   6048  2746d				   -
   6049  2746d				   -	       bne	pvnibble2char_skipnibbleextra
   6050  2746d				   -
   6051  2746d				   -pvnibble2charextra
   6052  2746d				   -			; high nibble...
   6053  2746d				   -	       lda	(temp7),y
   6054  2746d				   -	       and	#$f0
   6055  2746d				   -	       lsr
   6056  2746d				   -	       lsr
   6057  2746d				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   6058  2746d				   -	       lsr
   6059  2746d				   -	       endif
   6060  2746d				   -	       clc
   6061  2746d				   -	       adc	temp1	; add the offset to character graphics to our value
   6062  2746d				   -	       sta	VALBUFFER,x
   6063  2746d				   -	       inx
   6064  2746d				   -
   6065  2746d				   -			; second half of the digit
   6066  2746d				   -	       clc
   6067  2746d				   -	       adc	#1
   6068  2746d				   -	       sta	VALBUFFER,x
   6069  2746d				   -	       inx
   6070  2746d				   -
   6071  2746d				   -pvnibble2char_skipnibbleextra
   6072  2746d				   -			; low nibble...
   6073  2746d				   -	       lda	(temp7),y
   6074  2746d				   -	       and	#$0f
   6075  2746d				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   6076  2746d				   -	       asl
   6077  2746d				   -	       endif
   6078  2746d				   -	       asl
   6079  2746d				   -
   6080  2746d				   -	       clc
   6081  2746d				   -	       adc	temp1	; add the offset to character graphics to our value
   6082  2746d				   -	       sta	VALBUFFER,x
   6083  2746d				   -	       inx
   6084  2746d				   -
   6085  2746d				   -	       clc
   6086  2746d				   -	       adc	#1
   6087  2746d				   -	       sta	VALBUFFER,x
   6088  2746d				   -	       inx
   6089  2746d				   -	       iny
   6090  2746d				   -
   6091  2746d				   -	       dec	plotdigitcount
   6092  2746d				   -	       bne	pvnibble2charextra
   6093  2746d				   -
   6094  2746d				   -			;point to the start of our valuebuffer
   6095  2746d				   -	       clc
   6096  2746d				   -	       lda	#<VALBUFFER
   6097  2746d				   -	       adc	valbufend
   6098  2746d				   -	       sta	temp1
   6099  2746d				   -	       lda	#>VALBUFFER
   6100  2746d				   -	       adc	#0
   6101  2746d				   -	       sta	temp2
   6102  2746d				   -
   6103  2746d				   -			;advance valbufend to the end of our value buffer
   6104  2746d				   -	       stx	valbufend
   6105  2746d				   -
   6106  2746d				   -	       ifnconst	plotvalueonscreen
   6107  2746d				   -	       jmp	plotcharacters
   6108  2746d				   -	       else
   6109  2746d				   -	       jmp	plotcharacterslive
   6110  2746d				   -	       endif
   6111  2746d					       endif		; USED_PLOTVALUEEXTRA
   6112  2746d
   6113  2746d				    boxcollision
   6114  2746d				   -	       ifconst	BOXCOLLISION
   6115  2746d				   -			; the worst case cycle-time for the code below is 43 cycles.
   6116  2746d				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   6117  2746d				   -
   6118  2746d				   -			;__boxx1 = accumulator
   6119  2746d				   -			;__boxy1 = y
   6120  2746d				   -__boxw1    =	temp3
   6121  2746d				   -__boxh1    =	temp4
   6122  2746d				   -
   6123  2746d				   -__boxx2    =	temp5
   6124  2746d				   -__boxy2    =	temp6
   6125  2746d				   -__boxw2    =	temp7
   6126  2746d				   -__boxh2    =	temp8
   6127  2746d				   -
   6128  2746d				   -DoXCollisionCheck
   6129  2746d				   -			;lda __boxx1 ; skipped. already in the accumulator
   6130  2746d				   -	       cmp	__boxx2	;3
   6131  2746d				   -	       bcs	X1isbiggerthanX2	;2/3
   6132  2746d				   -X2isbiggerthanX1
   6133  2746d				   -			; carry is clear
   6134  2746d				   -	       adc	__boxw1	;3
   6135  2746d				   -	       cmp	__boxx2	;3
   6136  2746d				   -	       bcs	DoYCollisionCheck	;3/2
   6137  2746d				   -	       rts		;6 - carry clear, no collision
   6138  2746d				   -X1isbiggerthanX2
   6139  2746d				   -	       clc		;2
   6140  2746d				   -	       sbc	__boxw2	;3
   6141  2746d				   -	       cmp	__boxx2	;3
   6142  2746d				   -	       bcs	noboxcollision	;3/2
   6143  2746d				   -DoYCollisionCheck
   6144  2746d				   -	       tya		; 2 ; use to be "lda __boxy1"
   6145  2746d				   -	       cmp	__boxy2	;3
   6146  2746d				   -	       bcs	Y1isbiggerthanY2	;3/2
   6147  2746d				   -Y2isbiggerthanY1
   6148  2746d				   -			; carry is clear
   6149  2746d				   -	       adc	__boxh1	;3
   6150  2746d				   -	       cmp	__boxy2	;3
   6151  2746d				   -	       rts		;6 
   6152  2746d				   -Y1isbiggerthanY2
   6153  2746d				   -	       clc		;2
   6154  2746d				   -	       sbc	__boxh2	;3
   6155  2746d				   -	       cmp	__boxy2	;3
   6156  2746d				   -	       bcs	noboxcollision	;3/2
   6157  2746d				   -yesboxcollision
   6158  2746d				   -	       sec		;2
   6159  2746d				   -	       rts		;6
   6160  2746d				   -noboxcollision
   6161  2746d				   -	       clc		;2
   6162  2746d				   -	       rts		;6
   6163  2746d					       endif		; BOXCOLLISION
   6164  2746d
   6165  2746d				    randomize
   6166  2746d			a5 40		       lda	rand
   6167  2746f			4a		       lsr
   6168  27470			26 41		       rol	rand16
   6169  27472			90 02		       bcc	noeor
   6170  27474			49 b4		       eor	#$B4
   6171  27476				    noeor
   6172  27476			85 40		       sta	rand
   6173  27478			45 41		       eor	rand16
   6174  2747a			60		       rts
   6175  2747b
   6176  2747b							; *** bcd conversion routine courtesy Omegamatrix
   6177  2747b							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   6178  2747b					       ifconst	.calledfunction_converttobcd
   6179  2747b				    converttobcd
   6180  2747b							;value to convert is in the accumulator
   6181  2747b			85 42		       sta	temp1
   6182  2747d			4a		       lsr
   6183  2747e			65 42		       adc	temp1
   6184  27480			6a		       ror
   6185  27481			4a		       lsr
   6186  27482			4a		       lsr
   6187  27483			65 42		       adc	temp1
   6188  27485			6a		       ror
   6189  27486			65 42		       adc	temp1
   6190  27488			6a		       ror
   6191  27489			4a		       lsr
   6192  2748a			29 3c		       and	#$3C
   6193  2748c			85 43		       sta	temp2
   6194  2748e			4a		       lsr
   6195  2748f			65 43		       adc	temp2
   6196  27491			65 42		       adc	temp1
   6197  27493			60		       rts		; return the result in the accumulator
   6198  27494					       endif		; .calledfunction_converttobcd
   6199  27494
   6200  27494				   -	       ifconst	.calledfunction_mul8
   6201  27494				   -			; Y and A contain multiplicands, result in A
   6202  27494				   -mul8
   6203  27494				   -	       sty	temp1
   6204  27494				   -	       sta	temp2
   6205  27494				   -	       lda	#0
   6206  27494				   -reptmul8
   6207  27494				   -	       lsr	temp2
   6208  27494				   -	       bcc	skipmul8
   6209  27494				   -	       clc
   6210  27494				   -	       adc	temp1
   6211  27494				   -			;bcs donemul8 might save cycles?
   6212  27494				   -skipmul8
   6213  27494				   -			;beq donemul8 might save cycles?
   6214  27494				   -	       asl	temp1
   6215  27494				   -	       bne	reptmul8
   6216  27494				   -donemul8
   6217  27494				   -	       rts
   6218  27494					       endif		; .calledfunction_mul8
   6219  27494
   6220  27494				   -	       ifconst	.calledfunction_div8
   6221  27494				   -div8
   6222  27494				   -			; A=numerator Y=denominator, result in A
   6223  27494				   -	       cpy	#2
   6224  27494				   -	       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   6225  27494				   -	       sty	temp1
   6226  27494				   -	       ldy	#$ff
   6227  27494				   -div8loop
   6228  27494				   -	       sbc	temp1
   6229  27494				   -	       iny
   6230  27494				   -	       bcs	div8loop
   6231  27494				   -div8end
   6232  27494				   -	       tya
   6233  27494				   -			; result in A
   6234  27494				   -	       rts
   6235  27494					       endif		; .calledfunction_div8
   6236  27494
   6237  27494				   -	       ifconst	.calledfunction_mul16
   6238  27494				   -			; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   6239  27494				   -mul16
   6240  27494				   -	       sty	temp1
   6241  27494				   -	       sta	temp2
   6242  27494				   -
   6243  27494				   -	       lda	#0
   6244  27494				   -	       ldx	#8
   6245  27494				   -	       lsr	temp1
   6246  27494				   -mul16_1
   6247  27494				   -	       bcc	mul16_2
   6248  27494				   -	       clc
   6249  27494				   -	       adc	temp2
   6250  27494				   -mul16_2
   6251  27494				   -	       ror
   6252  27494				   -	       ror	temp1
   6253  27494				   -	       dex
   6254  27494				   -	       bne	mul16_1
   6255  27494				   -	       sta	temp2
   6256  27494				   -	       rts
   6257  27494					       endif		; .calledfunction_mul16
   6258  27494
   6259  27494				   -	       ifconst	.calledfunction_div16
   6260  27494				   -			; div int/int
   6261  27494				   -			; numerator in A, denom in temp1
   6262  27494				   -			; returns with quotient in A, remainder in temp1
   6263  27494				   -div16
   6264  27494				   -	       sta	temp2
   6265  27494				   -	       sty	temp1
   6266  27494				   -	       lda	#0
   6267  27494				   -	       ldx	#8
   6268  27494				   -	       asl	temp2
   6269  27494				   -div16_1
   6270  27494				   -	       rol
   6271  27494				   -	       cmp	temp1
   6272  27494				   -	       bcc	div16_2
   6273  27494				   -	       sbc	temp1
   6274  27494				   -div16_2
   6275  27494				   -	       rol	temp2
   6276  27494				   -	       dex
   6277  27494				   -	       bne	div16_1
   6278  27494				   -	       sta	temp1
   6279  27494				   -	       lda	temp2
   6280  27494				   -	       rts
   6281  27494					       endif		; .calledfunction_div16
   6282  27494
   6283  27494					       ifconst	bankswitchmode
   6284  27494				    BS_jsr
   6285  27494				   -	       ifconst	dumpbankswitch
   6286  27494				   -	       sta	dumpbankswitch
   6287  27494					       endif
   6288  27494				   -	       ifconst	MCPDEVCART
   6289  27494				   -	       ora	#$18
   6290  27494				   -	       sta	$3000
   6291  27494					       else
   6292  27494			8d 00 80	       sta	$8000
   6293  27497					       endif
   6294  27497			68		       pla
   6295  27498			aa		       tax
   6296  27499			68		       pla
   6297  2749a			60		       rts
   6298  2749b
   6299  2749b				    BS_return
   6300  2749b			68		       pla		; bankswitch bank
   6301  2749c				   -	       ifconst	dumpbankswitch
   6302  2749c				   -	       sta	dumpbankswitch
   6303  2749c					       endif
   6304  2749c				   -	       ifconst	BANKRAM
   6305  2749c				   -	       sta	currentbank
   6306  2749c				   -	       ora	currentrambank
   6307  2749c					       endif
   6308  2749c				   -	       ifconst	MCPDEVCART
   6309  2749c				   -	       ora	#$18
   6310  2749c				   -	       sta	$3000
   6311  2749c					       else
   6312  2749c			8d 00 80	       sta	$8000
   6313  2749f					       endif
   6314  2749f			68		       pla		; bankswitch $0 flag
   6315  274a0			60		       rts
   6316  274a1					       endif
   6317  274a1
   6318  274a1				    checkselectswitch
   6319  274a1			ad 82 02	       lda	SWCHB	; check the real select switch...
   6320  274a4			29 02		       and	#%00000010
   6321  274a6				    checkselectswitchreturn
   6322  274a6			60		       rts
   6323  274a7
   6324  274a7				    checkresetswitch
   6325  274a7			ad 82 02	       lda	SWCHB	; check the real reset switch...
   6326  274aa			29 01		       and	#%00000001
   6327  274ac			60		       rts
   6328  274ad
   6329  274ad				   -	       ifconst	FINESCROLLENABLED
   6330  274ad				   -finescrolldlls
   6331  274ad				   -	       ldx	temp1	; first DLL index x3
   6332  274ad				   -	       lda	DLLMEM,x
   6333  274ad				   -	       and	#%11110000
   6334  274ad				   -	       ora	finescrolly
   6335  274ad				   -	       sta	DLLMEM,x
   6336  274ad				   -
   6337  274ad				   -	       ldx	temp2	; last DLL index x3
   6338  274ad				   -	       lda	DLLMEM,x
   6339  274ad				   -	       and	#%11110000
   6340  274ad				   -	       ora	finescrolly
   6341  274ad				   -	       eor	#(WZONEHEIGHT-1)
   6342  274ad				   -	       sta	DLLMEM,x
   6343  274ad				   -	       rts
   6344  274ad					       endif		; FINESCROLLENABLED
   6345  274ad
   6346  274ad				   -	       ifconst	USED_ADJUSTVISIBLE
   6347  274ad				   -adjustvisible
   6348  274ad				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   6349  274ad				   -	       jsr	waitforvblankstart	; ensure vblank just started
   6350  274ad				   -	       ldx	visibleDLLstart
   6351  274ad				   -findfirstinterrupt
   6352  274ad				   -	       lda	DLLMEM,x
   6353  274ad				   -	       bmi	foundfirstinterrupt
   6354  274ad				   -	       inx
   6355  274ad				   -	       inx
   6356  274ad				   -	       inx
   6357  274ad				   -	       bne	findfirstinterrupt
   6358  274ad				   -foundfirstinterrupt
   6359  274ad				   -	       and	#%01111111	; clear the interrupt bit
   6360  274ad				   -	       sta	DLLMEM,x
   6361  274ad				   -	       ifconst	DOUBLEBUFFER
   6362  274ad				   -	       sta	DLLMEM+DBOFFSET,x
   6363  274ad				   -	       endif		; DOUBLEBUFFER
   6364  274ad				   -	       ldx	overscanDLLstart
   6365  274ad				   -findlastinterrupt
   6366  274ad				   -	       lda	DLLMEM,x
   6367  274ad				   -	       bmi	foundlastinterrupt
   6368  274ad				   -	       dex
   6369  274ad				   -	       dex
   6370  274ad				   -	       dex
   6371  274ad				   -	       bne	findlastinterrupt
   6372  274ad				   -foundlastinterrupt
   6373  274ad				   -	       and	#%01111111	; clear the interrupt bit
   6374  274ad				   -	       sta	DLLMEM,x
   6375  274ad				   -	       ifconst	DOUBLEBUFFER
   6376  274ad				   -	       sta	DLLMEM+DBOFFSET,x
   6377  274ad				   -	       endif		; DOUBLEBUFFER
   6378  274ad				   -			;now we need to set the new interrupts
   6379  274ad				   -	       clc
   6380  274ad				   -	       lda	temp1
   6381  274ad				   -	       adc	visibleDLLstart
   6382  274ad				   -	       tax
   6383  274ad				   -	       lda	DLLMEM,x
   6384  274ad				   -	       ora	#%10000000
   6385  274ad				   -	       sta	DLLMEM,x
   6386  274ad				   -	       ifconst	DOUBLEBUFFER
   6387  274ad				   -	       sta	DLLMEM+DBOFFSET,x
   6388  274ad				   -	       endif		; DOUBLEBUFFER
   6389  274ad				   -	       clc
   6390  274ad				   -	       lda	temp2
   6391  274ad				   -	       adc	visibleDLLstart
   6392  274ad				   -	       tax
   6393  274ad				   -	       lda	DLLMEM,x
   6394  274ad				   -	       ora	#%10000000
   6395  274ad				   -	       sta	DLLMEM,x
   6396  274ad				   -	       ifconst	DOUBLEBUFFER
   6397  274ad				   -	       sta	DLLMEM+DBOFFSET,x
   6398  274ad				   -	       endif		; DOUBLEBUFFER
   6399  274ad				   -	       jsr	vblankresync
   6400  274ad				   -	       rts
   6401  274ad					       endif		; USED_ADJUSTVISIBLE
   6402  274ad
   6403  274ad				    vblankresync
   6404  274ad			20 3e f5	       jsr	waitforvblankstart	; ensure vblank just started
   6405  274b0			a9 00		       lda	#0
   6406  274b2			85 4d		       sta	visibleover
   6407  274b4			a9 03		       lda	#3
   6408  274b6			8d b2 01	       sta	interruptindex
   6409  274b9			60		       rts
   6410  274ba
   6411  274ba				    createallgamedlls
   6412  274ba			a0 3c		       ldy	#(DLLLUTEND-DLLLUT)
   6413  274bc				    createallgamedllsloop
   6414  274bc			88		       dey
   6415  274bd			b9 02 f5	       lda	DLLLUT,y
   6416  274c0			99 00 18	       sta	DLLMEM,y
   6417  274c3					       ifconst	DOUBLEBUFFER
   6418  274c3			99 70 18	       sta	DLLMEM+DBOFFSET,y
   6419  274c6					       endif		; DOUBLEBUFFER
   6420  274c6			c0 00		       cpy	#0
   6421  274c8			d0 f2		       bne	createallgamedllsloop
   6422  274ca
   6423  274ca					       ifconst	DOUBLEBUFFER
   6424  274ca			a0 24		       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   6425  274cc				    fixdoublebuffer
   6426  274cc			88		       dey
   6427  274cd			b9 79 18	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6428  274d0			18		       clc
   6429  274d1			69 ff		       adc	#DOUBLEBUFFEROFFSET
   6430  274d3			99 79 18	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6431  274d6			88		       dey
   6432  274d7			b9 79 18	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6433  274da			69 00		       adc	#0
   6434  274dc			99 79 18	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6435  274df			88		       dey
   6436  274e0			d0 ea		       bne	fixdoublebuffer
   6437  274e2					       endif
   6438  274e2
   6439  274e2				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   6440  274e2				   -			; N.B. banksets doesn't in-fact allow DL in cart-ram, so this conditional
   6441  274e2				   -			; is always skipped. This is here in case some day the limitation is
   6442  274e2				   -			; worked around, but it's untested. 
   6443  274e2				   -
   6444  274e2				   -			; With bankset cart ram, we added $8000 to the DL address so plot 
   6445  274e2				   -			; functions would hit the cart-ram write-address. We need to subtract $80
   6446  274e2				   -			; so Maria will read from the cart-ram read-address.
   6447  274e2				   -	       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   6448  274e2				   -fixbanksetaddresses
   6449  274e2				   -	       dey
   6450  274e2				   -	       dey
   6451  274e2				   -	       lda	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   6452  274e2				   -	       and	#%01111111
   6453  274e2				   -	       sta	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   6454  274e2				   -	       ifconst	DOUBLEBUFFER
   6455  274e2				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6456  274e2				   -	       and	#%01111111
   6457  274e2				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   6458  274e2				   -	       endif		; DOUBLEBUFFER
   6459  274e2				   -	       dey
   6460  274e2				   -	       bne	fixbanksetaddresses
   6461  274e2					       endif		; BANKSET_DL_IN_CARTRAM
   6462  274e2
   6463  274e2			ad 09 21	       lda	paldetected
   6464  274e5			f0 10		       beq	skippaladjust
   6465  274e7			a9 4f		       lda	#($0F|(WZONEHEIGHT*4))	; +15 lines
   6466  274e9			8d 06 18	       sta	DLLMEM+6
   6467  274ec					       ifconst	DOUBLEBUFFER
   6468  274ec			8d 76 18	       sta	DLLMEM+DBOFFSET+6
   6469  274ef					       endif
   6470  274ef					       if	WSCREENHEIGHT = 192
   6471  274ef			a9 4d		       lda	#($0D|(WZONEHEIGHT*4))	; +6 lines
   6472  274f1				   -	       else
   6473  274f1				   -	       lda	#($07|(WZONEHEIGHT*4))	; +6 lines
   6474  274f1					       endif		; 
   6475  274f1			8d 03 18	       sta	DLLMEM+3
   6476  274f4					       ifconst	DOUBLEBUFFER
   6477  274f4			8d 73 18	       sta	DLLMEM+DBOFFSET+3
   6478  274f7					       endif		; DOUBLEBUFFER
   6479  274f7
   6480  274f7				    skippaladjust
   6481  274f7
   6482  274f7							; save the DL markers...
   6483  274f7			a9 09		       lda	#(DLLLUTVISSTART-DLLLUT)
   6484  274f9			8d 3c 21	       sta	visibleDLLstart
   6485  274fc			a9 2d		       lda	#(DLLLUTNONVISSTART-DLLLUT)
   6486  274fe			8d 3d 21	       sta	overscanDLLstart
   6487  27501			60		       rts
   6488  27502
   6489  27502							; N.B. max DLL length is 112 bytes (for double-buffered)
   6490  27502
   6491  27502				    DLLLUT
   6492  27502					       if	WSCREENHEIGHT = 192
   6493  27502			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   6494  27505			47 21 00	       .byte.b	($07|(WZONEHEIGHT*4)),$21,$00	;  8 blank lines
   6495  27508			40 21 00	       .byte.b	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   6496  2750b							;=25 blank lines
   6497  2750b					       endif		; WSCREENHEIGHT = 192
   6498  2750b				   -	       if	WSCREENHEIGHT = 208
   6499  2750b				   -	       .byte	($0E|(WZONEHEIGHT*4)),$21,$00	; 15 blank lines
   6500  2750b				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   6501  2750b				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   6502  2750b				   -			;=17 blank lines
   6503  2750b					       endif		; WSCREENHEIGHT = 208
   6504  2750b				   -	       if	WSCREENHEIGHT = 224
   6505  2750b				   -	       .byte	($06|(WZONEHEIGHT*4)),$21,$00	;  7 blank lines
   6506  2750b				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   6507  2750b				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   6508  2750b				   -			;= 9 blank lines
   6509  2750b					       endif		; WSCREENHEIGHT = 224
   6510  2750b
   6511  2750b				    DLLLUTVISSTART
   6512  2750b			cf 40 00	       .byte.b	($80|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE0ADDRESS,<ZONE0ADDRESS
   6513  2750e							;	 ^--NMI 1: start of visible
   6514  2750e			4f 45 55	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE1ADDRESS,<ZONE1ADDRESS
   6515  27511			4f 4a aa	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE2ADDRESS,<ZONE2ADDRESS
   6516  27514			4f 50 00	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE3ADDRESS,<ZONE3ADDRESS
   6517  27517			4f 55 55	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE4ADDRESS,<ZONE4ADDRESS
   6518  2751a			4f 5a aa	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE5ADDRESS,<ZONE5ADDRESS
   6519  2751d			4f 60 00	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE6ADDRESS,<ZONE6ADDRESS
   6520  27520			4f 65 55	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE7ADDRESS,<ZONE7ADDRESS
   6521  27523			4f 6a aa	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE8ADDRESS,<ZONE8ADDRESS
   6522  27526			4f 70 00	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE9ADDRESS,<ZONE9ADDRESS
   6523  27529			4f 75 55	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE10ADDRESS,<ZONE10ADDRESS
   6524  2752c			4f 7a aa	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE11ADDRESS,<ZONE11ADDRESS
   6525  2752f				   -	       ifconst	ZONE12ADDRESS
   6526  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE12ADDRESS,<ZONE12ADDRESS
   6527  2752f					       endif
   6528  2752f				   -	       ifconst	ZONE13ADDRESS
   6529  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE13ADDRESS,<ZONE13ADDRESS
   6530  2752f					       endif
   6531  2752f				   -	       ifconst	ZONE14ADDRESS
   6532  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE14ADDRESS,<ZONE14ADDRESS
   6533  2752f					       endif
   6534  2752f				   -	       ifconst	ZONE15ADDRESS
   6535  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE15ADDRESS,<ZONE15ADDRESS
   6536  2752f					       endif
   6537  2752f				   -	       ifconst	ZONE16ADDRESS
   6538  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE16ADDRESS,<ZONE16ADDRESS
   6539  2752f					       endif
   6540  2752f				   -	       ifconst	ZONE17ADDRESS
   6541  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE17ADDRESS,<ZONE17ADDRESS
   6542  2752f					       endif
   6543  2752f				   -	       ifconst	ZONE18ADDRESS
   6544  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE18ADDRESS,<ZONE18ADDRESS
   6545  2752f					       endif
   6546  2752f				   -	       ifconst	ZONE19ADDRESS
   6547  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE19ADDRESS,<ZONE19ADDRESS
   6548  2752f					       endif
   6549  2752f				   -	       ifconst	ZONE20ADDRESS
   6550  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE20ADDRESS,<ZONE20ADDRESS
   6551  2752f					       endif
   6552  2752f				   -	       ifconst	ZONE21ADDRESS
   6553  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE21ADDRESS,<ZONE21ADDRESS
   6554  2752f					       endif
   6555  2752f				   -	       ifconst	ZONE22ADDRESS
   6556  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE22ADDRESS,<ZONE22ADDRESS
   6557  2752f					       endif
   6558  2752f				   -	       ifconst	ZONE23ADDRESS
   6559  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE23ADDRESS,<ZONE23ADDRESS
   6560  2752f					       endif
   6561  2752f				   -	       ifconst	ZONE24ADDRESS
   6562  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE24ADDRESS,<ZONE24ADDRESS
   6563  2752f					       endif
   6564  2752f				   -	       ifconst	ZONE25ADDRESS
   6565  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE25ADDRESS,<ZONE25ADDRESS
   6566  2752f					       endif
   6567  2752f				   -	       ifconst	ZONE26ADDRESS
   6568  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE26ADDRESS,<ZONE26ADDRESS
   6569  2752f					       endif
   6570  2752f				   -	       ifconst	ZONE27ADDRESS
   6571  2752f				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE27ADDRESS,<ZONE27ADDRESS
   6572  2752f					       endif
   6573  2752f				    DLLLUTNONVISSTART
   6574  2752f			c3 21 00	       .byte.b	($83|(WZONEHEIGHT*4)),$21,$00	;  4 blank lines
   6575  27532							;	 ^--NMI 2: start of non-visible
   6576  27532			cf 21 00	       .byte.b	($8F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   6577  27535							;	 ^--NMI 3: start of overscan
   6578  27535			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   6579  27538			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   6580  2753b			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   6581  2753e				    DLLLUTEND
   6582  2753e							;echo "DLL size: ",[(DLLLUTEND-DLLLUT)]d,"bytes"
   6583  2753e							;echo "DLL code size: ",[(DLLLUTEND-createallgamedlls)]d,"bytes"
   6584  2753e
   6585  2753e				    waitforvblankstart
   6586  2753e				    vblankendwait
   6587  2753e			24 28		       BIT	MSTAT
   6588  27540			30 fc		       bmi	vblankendwait
   6589  27542				    vblankstartwait
   6590  27542			24 28		       BIT	MSTAT
   6591  27544			10 fc		       bpl	vblankstartwait
   6592  27546			60		       rts
   6593  27547
   6594  27547					       ifconst	DOUBLEBUFFER
   6595  27547				    flipdisplaybufferreturn
   6596  27547			60		       rts
   6597  27548				    flipdisplaybuffer
   6598  27548				   -	       ifconst	interrupthold
   6599  27548				   -	       lda	#$FF
   6600  27548				   -	       sta	interrupthold
   6601  27548					       endif
   6602  27548			a5 d5		       lda	doublebufferstate
   6603  2754a			f0 fb		       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   6604  2754c
   6605  2754c			20 46 f1	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   6606  2754f
   6607  2754f			a5 d5		       lda	doublebufferstate
   6608  27551			4a		       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   6609  27552			aa		       tax
   6610  27553
   6611  27553							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   6612  27553
   6613  27553				    flipdisplaybufferwait1
   6614  27553			a5 4d		       lda	visibleover
   6615  27555			f0 fc		       beq	flipdisplaybufferwait1
   6616  27557
   6617  27557				    flipdisplaybufferwait
   6618  27557			a5 4d		       lda	visibleover
   6619  27559			d0 fc		       bne	flipdisplaybufferwait
   6620  2755b
   6621  2755b			ad b3 01	       lda	doublebufferminimumframetarget
   6622  2755e			f0 0b		       beq	skipminimumframecode
   6623  27560			ad b4 01	       lda	doublebufferminimumframeindex
   6624  27563			d0 ee		       bne	flipdisplaybufferwait1
   6625  27565			ad b3 01	       lda	doublebufferminimumframetarget
   6626  27568			8d b4 01	       sta	doublebufferminimumframeindex
   6627  2756b				    skipminimumframecode
   6628  2756b
   6629  2756b			bd cb f5	       lda	DLLMEMLutHi,x
   6630  2756e			85 2c		       sta	DPPH
   6631  27570			bd c9 f5	       lda	DLLMEMLutLo,x
   6632  27573			85 30		       sta	DPPL
   6633  27575
   6634  27575			bd cd f5	       lda	NewPageflipstate,x
   6635  27578			85 d5		       sta	doublebufferstate
   6636  2757a			bd cf f5	       lda	NewPageflipoffset,x
   6637  2757d			85 d6		       sta	doublebufferdloffset
   6638  2757f
   6639  2757f					       ifnconst	BANKSET_DL_IN_CARTRAM
   6640  2757f			a5 d7		       lda	doublebufferbufferdirty
   6641  27581			f0 c4		       beq	flipdisplaybufferreturn
   6642  27583
   6643  27583							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   6644  27583							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   6645  27583							; from the displayed buffer to the working buffer...
   6646  27583
   6647  27583			a5 d6		       lda	doublebufferdloffset
   6648  27585			49 ff		       eor	#DOUBLEBUFFEROFFSET
   6649  27587			85 47		       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   6650  27589
   6651  27589			a2 0b		       ldx	#(WZONECOUNT-1)
   6652  2758b				    copybufferzoneloop
   6653  2758b
   6654  2758b			bd 93 f6	       lda	DLPOINTL,x
   6655  2758e			18		       clc
   6656  2758f			65 d6		       adc	doublebufferdloffset
   6657  27591			85 42		       sta	temp1
   6658  27593			bd 87 f6	       lda	DLPOINTH,x
   6659  27596			69 00		       adc	#0
   6660  27598			85 43		       sta	temp2
   6661  2759a
   6662  2759a			bd 93 f6	       lda	DLPOINTL,x
   6663  2759d			18		       clc
   6664  2759e			65 47		       adc	temp6
   6665  275a0			85 44		       sta	temp3
   6666  275a2			bd 87 f6	       lda	DLPOINTH,x
   6667  275a5			69 00		       adc	#0
   6668  275a7			85 45		       sta	temp4
   6669  275a9
   6670  275a9			b5 82		       lda	dlendsave,x
   6671  275ab			a8		       tay
   6672  275ac				    copybuffercharsloop
   6673  275ac			b1 44		       lda	(temp3),y
   6674  275ae			91 42		       sta	(temp1),y
   6675  275b0			88		       dey
   6676  275b1			10 f9		       bpl	copybuffercharsloop
   6677  275b3			ca		       dex
   6678  275b4			10 d5		       bpl	copybufferzoneloop
   6679  275b6			a9 00		       lda	#0
   6680  275b8			85 d7		       sta	doublebufferbufferdirty
   6681  275ba					       endif		; ! BANKSET_DL_IN_CARTRAM
   6682  275ba			60		       rts
   6683  275bb
   6684  275bb				    doublebufferoff
   6685  275bb			a9 01		       lda	#1
   6686  275bd			85 d5		       sta	doublebufferstate
   6687  275bf			20 48 f5	       jsr	flipdisplaybuffer
   6688  275c2			a9 00		       lda	#0
   6689  275c4			85 d5		       sta	doublebufferstate
   6690  275c6			85 d6		       sta	doublebufferdloffset
   6691  275c8			60		       rts
   6692  275c9
   6693  275c9				    DLLMEMLutLo
   6694  275c9			00 70		       .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   6695  275cb				    DLLMEMLutHi
   6696  275cb			18 18		       .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   6697  275cd				    NewPageflipstate
   6698  275cd			03 01		       .byte.b	3,1
   6699  275cf				    NewPageflipoffset
   6700  275cf			ff 00		       .byte.b	DOUBLEBUFFEROFFSET,0
   6701  275d1
   6702  275d1					       endif		; DOUBLEBUFFER
   6703  275d1
   6704  275d1				   -	       ifconst	MOUSESUPPORT
   6705  275d1				   -
   6706  275d1				   -rotationalcompare
   6707  275d1				   -			; old = 00 01 10 11
   6708  275d1				   -	       .byte	$00, $01, $ff, $00	; new=00
   6709  275d1				   -	       .byte	$ff, $00, $00, $01	; new=01
   6710  275d1				   -	       .byte	$01, $00, $00, $ff	; new=10
   6711  275d1				   -	       .byte	$00, $ff, $01, $00	; new=11
   6712  275d1				   -
   6713  275d1				   -			; 0000YyXx st mouse
   6714  275d1				   -
   6715  275d1				   -			; 0000xyXY amiga mouse
   6716  275d1				   -
   6717  275d1				   -	       ifconst	MOUSEXONLY
   6718  275d1				   -amigatoataribits		; swap bits 1 and 4...
   6719  275d1				   -	       .byte	%0000, %0000, %0010, %0010
   6720  275d1				   -	       .byte	%0000, %0000, %0010, %0010
   6721  275d1				   -	       .byte	%0001, %0001, %0011, %0011
   6722  275d1				   -	       .byte	%0001, %0001, %0011, %0011
   6723  275d1				   -
   6724  275d1				   -			; null change bits
   6725  275d1				   -	       .byte	%0000, %0001, %0010, %0011
   6726  275d1				   -	       .byte	%0000, %0001, %0010, %0011
   6727  275d1				   -	       .byte	%0000, %0001, %0010, %0011
   6728  275d1				   -	       .byte	%0000, %0001, %0010, %0011
   6729  275d1				   -
   6730  275d1				   -	       else		; !MOUSEXONLY
   6731  275d1				   -
   6732  275d1				   -amigatoataribits		; swap bits 1 and 4...
   6733  275d1				   -	       .byte	%0000, %1000, %0010, %1010
   6734  275d1				   -	       .byte	%0100, %1100, %0110, %1110
   6735  275d1				   -	       .byte	%0001, %1001, %0011, %1011
   6736  275d1				   -	       .byte	%0101, %1101, %0111, %1111
   6737  275d1				   -			; null change bits
   6738  275d1				   -	       .byte	%0000, %0001, %0010, %0011
   6739  275d1				   -	       .byte	%0100, %0101, %0110, %0111
   6740  275d1				   -	       .byte	%1000, %1001, %1010, %1011
   6741  275d1				   -	       .byte	%1100, %1101, %1110, %1111
   6742  275d1				   -	       endif		; !MOUSEXONLY
   6743  275d1				   -
   6744  275d1					       endif		; MOUSESUPPORT
   6745  275d1
   6746  275d1				    mouse0update
   6747  275d1				   -	       ifconst	MOUSE0SUPPORT
   6748  275d1				   -
   6749  275d1				   -mousetableselect =	inttemp2
   6750  275d1				   -mousexdelta =	inttemp3
   6751  275d1				   -mouseydelta =	inttemp4
   6752  275d1				   -lastSWCHA  =	inttemp6
   6753  275d1				   -
   6754  275d1				   -			; 0000YyXx st mouse
   6755  275d1				   -			; 0000xyXY amiga mouse
   6756  275d1				   -
   6757  275d1				   -	       lda	#$ff
   6758  275d1				   -	       sta	lastSWCHA
   6759  275d1				   -
   6760  275d1				   -	       ldy	port0control
   6761  275d1				   -
   6762  275d1				   -	       lda	#%00010000
   6763  275d1				   -	       cpy	#9	; AMIGA?
   6764  275d1				   -	       bne	skipamigabitsfix0
   6765  275d1				   -	       lda	#0
   6766  275d1				   -skipamigabitsfix0
   6767  275d1				   -	       sta	mousetableselect
   6768  275d1				   -	       ifconst	DRIVINGBOOST
   6769  275d1				   -	       cpy	#6	; DRIVING?
   6770  275d1				   -	       bne	skipdriving0setup
   6771  275d1				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   6772  275d1				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   6773  275d1				   -			; the actual position. This actual position is stored in mousey0 
   6774  275d1				   -			; after the driver has run.
   6775  275d1				   -	       ldx	mousex0
   6776  275d1				   -	       lda	mousey0
   6777  275d1				   -	       stx	mousey0
   6778  275d1				   -	       sta	mousex0
   6779  275d1				   -skipdriving0setup
   6780  275d1				   -	       endif		; DRIVINGBOOST
   6781  275d1				   -
   6782  275d1				   -	       lda	#0
   6783  275d1				   -	       sta	mousexdelta
   6784  275d1				   -	       sta	mouseydelta
   6785  275d1				   -
   6786  275d1				   -	       ifnconst	MOUSETIME
   6787  275d1				   -	       ifnconst	MOUSEXONLY
   6788  275d1				   -	       lda	#180	; minimum for x+y
   6789  275d1				   -	       else
   6790  275d1				   -	       lda	#100	; minimum for just x
   6791  275d1				   -	       endif
   6792  275d1				   -	       else
   6793  275d1				   -	       lda	#MOUSETIME
   6794  275d1				   -	       endif
   6795  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   6796  275d1				   -
   6797  275d1				   -mouse0updateloop
   6798  275d1				   -	       lda	SWCHA
   6799  275d1				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   6800  275d1				   -	       cmp	lastSWCHA
   6801  275d1				   -	       beq	mouse0loopcondition
   6802  275d1				   -	       sta	lastSWCHA
   6803  275d1				   -	       lsr
   6804  275d1				   -	       lsr
   6805  275d1				   -	       lsr
   6806  275d1				   -
   6807  275d1				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   6808  275d1				   -
   6809  275d1				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   6810  275d1				   -			; 0000YyXx st mouse
   6811  275d1				   -			; 0000xyXY amiga mouse
   6812  275d1				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   6813  275d1				   -	       tay
   6814  275d1				   -	       lax	amigatoataribits,y
   6815  275d1				   -
   6816  275d1				   -	       ifnconst	MOUSEXONLY
   6817  275d1				   -			; first the Y...
   6818  275d1				   -	       and	#%00001100
   6819  275d1				   -	       ora	mousecodey0
   6820  275d1				   -	       tay
   6821  275d1				   -	       lda	rotationalcompare,y
   6822  275d1				   -	       clc
   6823  275d1				   -	       adc	mouseydelta
   6824  275d1				   -	       sta	mouseydelta
   6825  275d1				   -	       tya
   6826  275d1				   -	       lsr
   6827  275d1				   -	       lsr
   6828  275d1				   -	       sta	mousecodey0
   6829  275d1				   -	       txa
   6830  275d1				   -			; ...then the X...
   6831  275d1				   -	       and	#%00000011
   6832  275d1				   -	       tax
   6833  275d1				   -	       endif		; !MOUSEXONLY
   6834  275d1				   -
   6835  275d1				   -	       asl
   6836  275d1				   -	       asl
   6837  275d1				   -	       ora	mousecodex0
   6838  275d1				   -	       tay
   6839  275d1				   -	       lda	rotationalcompare,y
   6840  275d1				   -	       adc	mousexdelta	; carry was clear by previous ASL
   6841  275d1				   -	       sta	mousexdelta
   6842  275d1				   -	       stx	mousecodex0
   6843  275d1				   -mouse0loopcondition
   6844  275d1				   -	       lda	TIMINT
   6845  275d1				   -	       bpl	mouse0updateloop
   6846  275d1				   -
   6847  275d1				   -			; *** adapt to selected device resolution. 
   6848  275d1				   -	       ldx	port0control
   6849  275d1				   -
   6850  275d1				   -	       ifconst	PRECISIONMOUSING
   6851  275d1				   -	       ldy	port0resolution
   6852  275d1				   -	       bne	mouse0halveddone
   6853  275d1				   -	       cpx	#6	; half-resolution is no good for driving wheels
   6854  275d1				   -	       beq	mouse0halveddone
   6855  275d1				   -			; resolution=0 is half mouse resolution, necessary for precision 
   6856  275d1				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   6857  275d1				   -
   6858  275d1				   -	       lda	mousexdelta
   6859  275d1				   -	       cmp	#$80
   6860  275d1				   -	       ror		; do a signed divide by 2.
   6861  275d1				   -	       clc
   6862  275d1				   -	       adc	mousex0
   6863  275d1				   -	       sta	mousex0
   6864  275d1				   -	       ifnconst	MOUSEXONLY
   6865  275d1				   -	       lda	mouseydelta
   6866  275d1				   -	       clc
   6867  275d1				   -	       adc	mousey0
   6868  275d1				   -	       sta	mousey0
   6869  275d1				   -	       endif
   6870  275d1				   -			; at half resolution we just exit after updating x and y
   6871  275d1				   -	       jmp	LLRET0
   6872  275d1				   -mouse0halveddone
   6873  275d1				   -	       endif		; PRECISIONMOUSING
   6874  275d1				   -
   6875  275d1				   -	       ifnconst	MOUSEXONLY
   6876  275d1				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   6877  275d1				   -	       ldy	port0resolution
   6878  275d1				   -	       dey
   6879  275d1				   -	       lda	#0
   6880  275d1				   -mousey0resolutionfix
   6881  275d1				   -	       clc
   6882  275d1				   -	       adc	mouseydelta
   6883  275d1				   -	       dey
   6884  275d1				   -	       bpl	mousey0resolutionfix
   6885  275d1				   -	       clc
   6886  275d1				   -	       adc	mousey0
   6887  275d1				   -	       sta	mousey0
   6888  275d1				   -	       endif		; MOUSEXONLY
   6889  275d1				   -
   6890  275d1				   -	       ldy	port0resolution
   6891  275d1				   -	       dey
   6892  275d1				   -	       lda	#0
   6893  275d1				   -mousex0resolutionfix
   6894  275d1				   -	       clc
   6895  275d1				   -	       adc	mousexdelta
   6896  275d1				   -	       dey
   6897  275d1				   -	       bpl	mousex0resolutionfix
   6898  275d1				   -	       ifnconst	DRIVINGBOOST
   6899  275d1				   -	       clc
   6900  275d1				   -	       adc	mousex0
   6901  275d1				   -	       sta	mousex0
   6902  275d1				   -	       else
   6903  275d1				   -	       cpx	#6
   6904  275d1				   -	       beq	carryonmouse0boost
   6905  275d1				   -	       clc
   6906  275d1				   -	       adc	mousex0
   6907  275d1				   -	       sta	mousex0
   6908  275d1				   -	       jmp	LLRET0
   6909  275d1				   -carryonmouse0boost
   6910  275d1				   -	       sta	mousexdelta
   6911  275d1				   -	       clc
   6912  275d1				   -	       adc	mousecodey0
   6913  275d1				   -	       sta	mousecodey0
   6914  275d1				   -	       clc
   6915  275d1				   -	       adc	mousex0
   6916  275d1				   -	       tay		; save the target X
   6917  275d1				   -	       adc	mousey0	; average in the smoothly-trailing X
   6918  275d1				   -	       ror
   6919  275d1				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   6920  275d1				   -	       sty	mousey0	; and mousey0 has the the target X
   6921  275d1				   -
   6922  275d1				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   6923  275d1				   -			; A has mousex0, the smoothly trailing X
   6924  275d1				   -	       sbc	mousey0	; less the target X
   6925  275d1				   -	       bpl	skipabsolutedrive0
   6926  275d1				   -	       eor	#$ff
   6927  275d1				   -skipabsolutedrive0
   6928  275d1				   -	       cmp	#64	; just an unreasonably large change
   6929  275d1				   -	       bcc	skipdrivewrapfix0
   6930  275d1				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   6931  275d1				   -skipdrivewrapfix0
   6932  275d1				   -
   6933  275d1				   -			; get rid of the tweening if the distance travelled was very small
   6934  275d1				   -	       lda	mousexdelta
   6935  275d1				   -	       cmp	port0resolution
   6936  275d1				   -	       bcs	skipbetweenfix0
   6937  275d1				   -	       lda	mousex0
   6938  275d1				   -	       sta	mousey0
   6939  275d1				   -skipbetweenfix0
   6940  275d1				   -
   6941  275d1				   -drivingboostreductioncheck0
   6942  275d1				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   6943  275d1				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   6944  275d1				   -			; negated again because truncation during BCD math results in 
   6945  275d1				   -			; differing magnitudes, depending if the value is +ve or -ve.
   6946  275d1				   -driving0fix
   6947  275d1				   -	       lax	mousecodey0
   6948  275d1				   -	       cmp	#$80
   6949  275d1				   -	       bcs	driving0skipnegate1
   6950  275d1				   -	       eor	#$FF
   6951  275d1				   -	       adc	#1
   6952  275d1				   -	       sta	mousecodey0
   6953  275d1				   -driving0skipnegate1
   6954  275d1				   -	       cmp	#$80
   6955  275d1				   -	       ror
   6956  275d1				   -	       cmp	#$80
   6957  275d1				   -	       ror
   6958  275d1				   -	       cmp	#$80
   6959  275d1				   -	       ror
   6960  275d1				   -	       sta	inttemp1
   6961  275d1				   -	       lda	mousecodey0
   6962  275d1				   -	       sec
   6963  275d1				   -	       sbc	inttemp1
   6964  275d1				   -	       cpx	#$80
   6965  275d1				   -	       bcs	driving0skipnegate2
   6966  275d1				   -	       eor	#$FF
   6967  275d1				   -	       adc	#1
   6968  275d1				   -driving0skipnegate2
   6969  275d1				   -	       sta	mousecodey0
   6970  275d1				   -drivingboostdone0
   6971  275d1				   -	       endif		; DRIVINGBOOST
   6972  275d1				   -
   6973  275d1				   -	       jmp	LLRET0
   6974  275d1				   -
   6975  275d1					       endif		; MOUSE0SUPPORT
   6976  275d1
   6977  275d1				    mouse1update
   6978  275d1				   -	       ifconst	MOUSE1SUPPORT
   6979  275d1				   -
   6980  275d1				   -mousetableselect =	inttemp2
   6981  275d1				   -mousexdelta =	inttemp3
   6982  275d1				   -mouseydelta =	inttemp4
   6983  275d1				   -lastSWCHA  =	inttemp6
   6984  275d1				   -
   6985  275d1				   -			; 0000YyXx st mouse
   6986  275d1				   -			; 0000xyXY amiga mouse
   6987  275d1				   -
   6988  275d1				   -	       lda	#$ff
   6989  275d1				   -	       sta	lastSWCHA
   6990  275d1				   -
   6991  275d1				   -	       ldy	port1control
   6992  275d1				   -
   6993  275d1				   -	       lda	#%00010000
   6994  275d1				   -	       cpy	#9	; AMIGA?
   6995  275d1				   -	       bne	skipamigabitsfix1
   6996  275d1				   -	       lda	#0
   6997  275d1				   -skipamigabitsfix1
   6998  275d1				   -	       sta	mousetableselect
   6999  275d1				   -	       ifconst	DRIVINGBOOST
   7000  275d1				   -	       cpy	#6	; DRIVING?
   7001  275d1				   -	       bne	skipdriving1setup
   7002  275d1				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   7003  275d1				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   7004  275d1				   -			; the actual position. This actual position is stored in mousey1 
   7005  275d1				   -			; after the driver has run.
   7006  275d1				   -	       ldx	mousex1
   7007  275d1				   -	       lda	mousey1
   7008  275d1				   -	       stx	mousey1
   7009  275d1				   -	       sta	mousex1
   7010  275d1				   -skipdriving1setup
   7011  275d1				   -	       endif		; DRIVINGBOOST
   7012  275d1				   -
   7013  275d1				   -	       lda	#0
   7014  275d1				   -	       sta	mousexdelta
   7015  275d1				   -	       sta	mouseydelta
   7016  275d1				   -
   7017  275d1				   -	       ifnconst	MOUSETIME
   7018  275d1				   -	       ifnconst	MOUSEXONLY
   7019  275d1				   -	       lda	#180	; minimum for x+y
   7020  275d1				   -	       else
   7021  275d1				   -	       lda	#100	; minimum for just x
   7022  275d1				   -	       endif
   7023  275d1				   -	       else
   7024  275d1				   -	       lda	#MOUSETIME
   7025  275d1				   -	       endif
   7026  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   7027  275d1				   -
   7028  275d1				   -mouse1updateloop
   7029  275d1				   -	       lda	SWCHA
   7030  275d1				   -	       and	#%00001111
   7031  275d1				   -	       cmp	lastSWCHA
   7032  275d1				   -	       beq	mouse1loopcondition
   7033  275d1				   -	       sta	lastSWCHA
   7034  275d1				   -
   7035  275d1				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   7036  275d1				   -
   7037  275d1				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   7038  275d1				   -			; 0000YyXx st mouse
   7039  275d1				   -			; 0000xyXY amiga mouse
   7040  275d1				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   7041  275d1				   -	       tay
   7042  275d1				   -	       lax	amigatoataribits,y
   7043  275d1				   -
   7044  275d1				   -	       ifnconst	MOUSEXONLY
   7045  275d1				   -			; first the Y...
   7046  275d1				   -	       and	#%00001100
   7047  275d1				   -	       ora	mousecodey1
   7048  275d1				   -	       tay
   7049  275d1				   -	       lda	rotationalcompare,y
   7050  275d1				   -	       clc
   7051  275d1				   -	       adc	mouseydelta
   7052  275d1				   -	       sta	mouseydelta
   7053  275d1				   -	       tya
   7054  275d1				   -	       lsr
   7055  275d1				   -	       lsr
   7056  275d1				   -	       sta	mousecodey1
   7057  275d1				   -	       txa
   7058  275d1				   -			; ...then the X...
   7059  275d1				   -	       and	#%00000011
   7060  275d1				   -	       tax
   7061  275d1				   -	       endif		; !MOUSEXONLY
   7062  275d1				   -
   7063  275d1				   -	       asl
   7064  275d1				   -	       asl
   7065  275d1				   -	       ora	mousecodex1
   7066  275d1				   -	       tay
   7067  275d1				   -	       lda	rotationalcompare,y
   7068  275d1				   -	       adc	mousexdelta	; carry was clear by previous ASL
   7069  275d1				   -	       sta	mousexdelta
   7070  275d1				   -	       stx	mousecodex1
   7071  275d1				   -mouse1loopcondition
   7072  275d1				   -	       lda	TIMINT
   7073  275d1				   -	       bpl	mouse1updateloop
   7074  275d1				   -
   7075  275d1				   -			; *** adapt to selected device resolution. 
   7076  275d1				   -	       ldx	port1control
   7077  275d1				   -
   7078  275d1				   -	       ifconst	PRECISIONMOUSING
   7079  275d1				   -	       ldy	port1resolution
   7080  275d1				   -	       bne	mouse1halveddone
   7081  275d1				   -	       cpx	#6	; half-resolution is no good for driving wheels
   7082  275d1				   -	       beq	mouse1halveddone
   7083  275d1				   -			; resolution=0 is half mouse resolution, necessary for precision 
   7084  275d1				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   7085  275d1				   -
   7086  275d1				   -	       lda	mousexdelta
   7087  275d1				   -	       cmp	#$80
   7088  275d1				   -	       ror		; do a signed divide by 2.
   7089  275d1				   -	       clc
   7090  275d1				   -	       adc	mousex1
   7091  275d1				   -	       sta	mousex1
   7092  275d1				   -	       ifnconst	MOUSEXONLY
   7093  275d1				   -	       lda	mouseydelta
   7094  275d1				   -	       clc
   7095  275d1				   -	       adc	mousey1
   7096  275d1				   -	       sta	mousey1
   7097  275d1				   -	       endif
   7098  275d1				   -			; at half resolution we just exit after updating x and y
   7099  275d1				   -	       jmp	LLRET1
   7100  275d1				   -mouse1halveddone
   7101  275d1				   -	       endif		; PRECISIONMOUSING
   7102  275d1				   -
   7103  275d1				   -	       ifnconst	MOUSEXONLY
   7104  275d1				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   7105  275d1				   -	       ldy	port1resolution
   7106  275d1				   -	       dey
   7107  275d1				   -	       lda	#0
   7108  275d1				   -mousey1resolutionfix
   7109  275d1				   -	       clc
   7110  275d1				   -	       adc	mouseydelta
   7111  275d1				   -	       dey
   7112  275d1				   -	       bpl	mousey1resolutionfix
   7113  275d1				   -	       clc
   7114  275d1				   -	       adc	mousey1
   7115  275d1				   -	       sta	mousey1
   7116  275d1				   -	       endif		; MOUSEXONLY
   7117  275d1				   -
   7118  275d1				   -	       ldy	port1resolution
   7119  275d1				   -	       dey
   7120  275d1				   -	       lda	#0
   7121  275d1				   -mousex1resolutionfix
   7122  275d1				   -	       clc
   7123  275d1				   -	       adc	mousexdelta
   7124  275d1				   -	       dey
   7125  275d1				   -	       bpl	mousex1resolutionfix
   7126  275d1				   -	       ifnconst	DRIVINGBOOST
   7127  275d1				   -	       clc
   7128  275d1				   -	       adc	mousex1
   7129  275d1				   -	       sta	mousex1
   7130  275d1				   -	       else
   7131  275d1				   -	       cpx	#6
   7132  275d1				   -	       beq	carryonmouse1boost
   7133  275d1				   -	       clc
   7134  275d1				   -	       adc	mousex1
   7135  275d1				   -	       sta	mousex1
   7136  275d1				   -	       jmp	LLRET1
   7137  275d1				   -carryonmouse1boost
   7138  275d1				   -	       sta	mousexdelta
   7139  275d1				   -	       clc
   7140  275d1				   -	       adc	mousecodey1
   7141  275d1				   -	       sta	mousecodey1
   7142  275d1				   -	       clc
   7143  275d1				   -	       adc	mousex1
   7144  275d1				   -	       tay		; save the target X
   7145  275d1				   -	       adc	mousey1	; average in the smoothly-trailing X
   7146  275d1				   -	       ror
   7147  275d1				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   7148  275d1				   -	       sty	mousey1	; and mousey0 has the the target X
   7149  275d1				   -
   7150  275d1				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   7151  275d1				   -			; A has mousex1, the smoothly trailing X
   7152  275d1				   -	       sbc	mousey1	; less the target X
   7153  275d1				   -	       bpl	skipabsolutedrive1
   7154  275d1				   -	       eor	#$ff
   7155  275d1				   -skipabsolutedrive1
   7156  275d1				   -	       cmp	#64	; just an unreasonably large change
   7157  275d1				   -	       bcc	skipdrivewrapfix1
   7158  275d1				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   7159  275d1				   -skipdrivewrapfix1
   7160  275d1				   -
   7161  275d1				   -			; get rid of the tweening if the distance travelled was very small
   7162  275d1				   -	       lda	mousexdelta
   7163  275d1				   -	       cmp	port1resolution
   7164  275d1				   -	       bcs	skipbetweenfix1
   7165  275d1				   -	       lda	mousex1
   7166  275d1				   -	       sta	mousey1
   7167  275d1				   -skipbetweenfix1
   7168  275d1				   -
   7169  275d1				   -drivingboostreductioncheck1
   7170  275d1				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   7171  275d1				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   7172  275d1				   -			; negated again because truncation during BCD math results in 
   7173  275d1				   -			; differing magnitudes, depending if the value is +ve or -ve.
   7174  275d1				   -driving1fix
   7175  275d1				   -	       lax	mousecodey1
   7176  275d1				   -	       cmp	#$80
   7177  275d1				   -	       bcs	driving0skipnegate1
   7178  275d1				   -	       eor	#$FF
   7179  275d1				   -	       adc	#1
   7180  275d1				   -	       sta	mousecodey1
   7181  275d1				   -driving0skipnegate1
   7182  275d1				   -	       cmp	#$80
   7183  275d1				   -	       ror
   7184  275d1				   -	       cmp	#$80
   7185  275d1				   -	       ror
   7186  275d1				   -	       cmp	#$80
   7187  275d1				   -	       ror
   7188  275d1				   -	       sta	inttemp1
   7189  275d1				   -	       lda	mousecodey1
   7190  275d1				   -	       sec
   7191  275d1				   -	       sbc	inttemp1
   7192  275d1				   -	       cpx	#$80
   7193  275d1				   -	       bcs	driving1skipnegate2
   7194  275d1				   -	       eor	#$FF
   7195  275d1				   -	       adc	#1
   7196  275d1				   -driving1skipnegate2
   7197  275d1				   -	       sta	mousecodey1
   7198  275d1				   -drivingboostdone1
   7199  275d1				   -	       endif		; DRIVINGBOOST
   7200  275d1				   -
   7201  275d1				   -	       jmp	LLRET1
   7202  275d1				   -
   7203  275d1					       endif		; MOUSE1SUPPORT
   7204  275d1
   7205  275d1
   7206  275d1				    trakball0update
   7207  275d1				   -	       ifconst	TRAKBALL0SUPPORT
   7208  275d1				   -	       ifnconst	TRAKTIME
   7209  275d1				   -	       ifnconst	TRAKXONLY
   7210  275d1				   -	       lda	#180	; minimum for x+y
   7211  275d1				   -	       else		; !TRAKXONLY
   7212  275d1				   -	       lda	#100	; minimum for just x
   7213  275d1				   -	       endif		; !TRAKXONLY
   7214  275d1				   -	       else		; !TRAKTIME
   7215  275d1				   -	       lda	#TRAKTIME
   7216  275d1				   -	       endif		; !TRAKTIME
   7217  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   7218  275d1				   -	       ldx	#0
   7219  275d1				   -	       ifnconst	TRAKXONLY
   7220  275d1				   -	       ldy	#0
   7221  275d1				   -	       endif		; TRAKXONLY
   7222  275d1				   -trakball0updateloop
   7223  275d1				   -	       lda	SWCHA
   7224  275d1				   -	       and	#%00110000
   7225  275d1				   -	       cmp	trakballcodex0
   7226  275d1				   -	       sta	trakballcodex0
   7227  275d1				   -	       beq	trakball0movementXdone
   7228  275d1				   -	       and	#%00010000
   7229  275d1				   -	       beq	trakball0negativeX
   7230  275d1				   -trakball0positiveX
   7231  275d1				   -			;(2 from beq)
   7232  275d1				   -	       inx		; 2
   7233  275d1				   -	       jmp	trakball0movementXdone	; 3
   7234  275d1				   -trakball0negativeX
   7235  275d1				   -			;(3 from beq)
   7236  275d1				   -	       dex		; 2
   7237  275d1				   -	       nop		; 2
   7238  275d1				   -trakball0movementXdone
   7239  275d1				   -
   7240  275d1				   -	       ifnconst	TRAKXONLY
   7241  275d1				   -	       lda	SWCHA
   7242  275d1				   -	       and	#%11000000
   7243  275d1				   -	       cmp	trakballcodey0
   7244  275d1				   -	       sta	trakballcodey0
   7245  275d1				   -	       beq	trakball0movementYdone
   7246  275d1				   -	       and	#%01000000
   7247  275d1				   -	       beq	trakball0negativeY
   7248  275d1				   -trakball0positiveY
   7249  275d1				   -			;(2 from beq)
   7250  275d1				   -	       iny		; 2
   7251  275d1				   -	       jmp	trakball0movementYdone	; 3
   7252  275d1				   -trakball0negativeY
   7253  275d1				   -			;(3 from beq)
   7254  275d1				   -	       dey		; 2
   7255  275d1				   -	       nop		; 2
   7256  275d1				   -trakball0movementYdone
   7257  275d1				   -	       endif		; !TRAKXONLY
   7258  275d1				   -
   7259  275d1				   -	       lda	TIMINT
   7260  275d1				   -	       bpl	trakball0updateloop
   7261  275d1				   -	       lda	#0
   7262  275d1				   -	       cpx	#0
   7263  275d1				   -	       beq	trakball0skipXadjust
   7264  275d1				   -	       clc
   7265  275d1				   -trakball0Xloop
   7266  275d1				   -	       adc	port0resolution
   7267  275d1				   -	       dex
   7268  275d1				   -	       bne	trakball0Xloop
   7269  275d1				   -	       clc
   7270  275d1				   -	       adc	trakballx0
   7271  275d1				   -	       sta	trakballx0
   7272  275d1				   -trakball0skipXadjust
   7273  275d1				   -	       ifnconst	TRAKXONLY
   7274  275d1				   -	       lda	#0
   7275  275d1				   -	       cpy	#0
   7276  275d1				   -	       beq	trakball0skipYadjust
   7277  275d1				   -	       clc
   7278  275d1				   -trakball0yloop
   7279  275d1				   -	       adc	port0resolution
   7280  275d1				   -	       dey
   7281  275d1				   -	       bne	trakball0yloop
   7282  275d1				   -	       clc
   7283  275d1				   -	       adc	trakbally0
   7284  275d1				   -	       sta	trakbally0
   7285  275d1				   -trakball0skipYadjust
   7286  275d1				   -	       endif		; !TRAKXONLY
   7287  275d1				   -
   7288  275d1				   -	       jmp	LLRET0
   7289  275d1					       endif
   7290  275d1
   7291  275d1
   7292  275d1
   7293  275d1				    trakball1update
   7294  275d1				   -	       ifconst	TRAKBALL1SUPPORT
   7295  275d1				   -	       ifnconst	TRAKTIME
   7296  275d1				   -	       ifnconst	TRAKXONLY
   7297  275d1				   -	       lda	#180	; minimum for x+y
   7298  275d1				   -	       else		; !TRAKXONLY
   7299  275d1				   -	       lda	#100	; minimum for just x
   7300  275d1				   -	       endif		; !TRAKXONLY
   7301  275d1				   -	       else		; !TRAKTIME
   7302  275d1				   -	       lda	#TRAKTIME
   7303  275d1				   -	       endif		; !TRAKTIME
   7304  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   7305  275d1				   -	       ldx	#0
   7306  275d1				   -	       ifnconst	TRAKXONLY
   7307  275d1				   -	       ldy	#0
   7308  275d1				   -	       endif		; TRAKXONLY
   7309  275d1				   -trakball1updateloop
   7310  275d1				   -	       lda	SWCHA
   7311  275d1				   -	       and	#%00000011
   7312  275d1				   -	       cmp	trakballcodex1
   7313  275d1				   -	       sta	trakballcodex1
   7314  275d1				   -	       beq	trakball1movementXdone
   7315  275d1				   -	       and	#%00000001
   7316  275d1				   -	       beq	trakball1negativeX
   7317  275d1				   -trakball1positiveX
   7318  275d1				   -			;(2 from beq)
   7319  275d1				   -	       inx		; 2
   7320  275d1				   -	       jmp	trakball1movementXdone	; 3
   7321  275d1				   -trakball1negativeX
   7322  275d1				   -			;(3 from beq)
   7323  275d1				   -	       dex		; 2
   7324  275d1				   -	       nop		; 2
   7325  275d1				   -trakball1movementXdone
   7326  275d1				   -
   7327  275d1				   -	       ifnconst	TRAKXONLY
   7328  275d1				   -	       lda	SWCHA
   7329  275d1				   -	       and	#%00001100
   7330  275d1				   -	       cmp	trakballcodey1
   7331  275d1				   -	       sta	trakballcodey1
   7332  275d1				   -	       beq	trakball1movementYdone
   7333  275d1				   -	       and	#%00000100
   7334  275d1				   -	       beq	trakball1negativeY
   7335  275d1				   -trakball1positiveY
   7336  275d1				   -			;(2 from beq)
   7337  275d1				   -	       iny		; 2
   7338  275d1				   -	       jmp	trakball1movementYdone	; 3
   7339  275d1				   -trakball1negativeY
   7340  275d1				   -			;(3 from beq)
   7341  275d1				   -	       dey		; 2
   7342  275d1				   -	       nop		; 2
   7343  275d1				   -trakball1movementYdone
   7344  275d1				   -	       endif		; !TRAKXONLY
   7345  275d1				   -
   7346  275d1				   -	       lda	TIMINT
   7347  275d1				   -	       bpl	trakball1updateloop
   7348  275d1				   -	       lda	#0
   7349  275d1				   -	       cpx	#0
   7350  275d1				   -	       beq	trakball1skipXadjust
   7351  275d1				   -	       clc
   7352  275d1				   -trakball1Xloop
   7353  275d1				   -	       adc	port1resolution
   7354  275d1				   -	       dex
   7355  275d1				   -	       bne	trakball1Xloop
   7356  275d1				   -	       clc
   7357  275d1				   -	       adc	trakballx1
   7358  275d1				   -	       sta	trakballx1
   7359  275d1				   -trakball1skipXadjust
   7360  275d1				   -	       ifnconst	TRAKXONLY
   7361  275d1				   -	       lda	#0
   7362  275d1				   -	       cpy	#0
   7363  275d1				   -	       beq	trakball1skipYadjust
   7364  275d1				   -	       clc
   7365  275d1				   -trakball1yloop
   7366  275d1				   -	       adc	port1resolution
   7367  275d1				   -	       dey
   7368  275d1				   -	       bne	trakball1yloop
   7369  275d1				   -	       clc
   7370  275d1				   -	       adc	trakbally1
   7371  275d1				   -	       sta	trakbally1
   7372  275d1				   -trakball1skipYadjust
   7373  275d1				   -	       endif		; !TRAKXONLY
   7374  275d1				   -
   7375  275d1				   -	       jmp	LLRET1
   7376  275d1					       endif
   7377  275d1
   7378  275d1
   7379  275d1				    paddleport0update
   7380  275d1				   -	       ifconst	PADDLE0SUPPORT
   7381  275d1				   -	       lda	#6
   7382  275d1				   -	       sta	VBLANK	; start charging the paddle caps
   7383  275d1				   -	       lda	#0	; use PADDLE timing
   7384  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   7385  275d1				   -
   7386  275d1				   -paddleport0updateloop
   7387  275d1				   -	       lda	INPT0
   7388  275d1				   -	       bmi	skippaddle0setposition
   7389  275d1				   -	       sty	paddleposition0
   7390  275d1				   -skippaddle0setposition
   7391  275d1				   -	       ifconst	TWOPADDLESUPPORT
   7392  275d1				   -	       lda	INPT1
   7393  275d1				   -	       bmi	skippaddle1setposition
   7394  275d1				   -	       sty	paddleposition1
   7395  275d1				   -skippaddle1setposition
   7396  275d1				   -	       endif
   7397  275d1				   -	       ldy	INTIM
   7398  275d1				   -	       cpy	#TIMEOFFSET
   7399  275d1				   -	       bcs	paddleport0updateloop
   7400  275d1				   -
   7401  275d1				   -	       lda	#%10000110
   7402  275d1				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   7403  275d1				   -	       sec
   7404  275d1				   -	       lda	paddleposition0
   7405  275d1				   -	       sbc	#TIMEOFFSET
   7406  275d1				   -	       ifconst	PADDLESCALEX2
   7407  275d1				   -	       asl
   7408  275d1				   -	       endif
   7409  275d1				   -
   7410  275d1				   -	       ifnconst	PADDLESMOOTHINGOFF
   7411  275d1				   -	       clc
   7412  275d1				   -	       adc	paddleprevious0
   7413  275d1				   -	       ror
   7414  275d1				   -	       sta	paddleprevious0
   7415  275d1				   -	       endif
   7416  275d1				   -
   7417  275d1				   -	       sta	paddleposition0
   7418  275d1				   -
   7419  275d1				   -	       ifconst	TWOPADDLESUPPORT
   7420  275d1				   -	       sec
   7421  275d1				   -	       lda	paddleposition1
   7422  275d1				   -	       sbc	#TIMEOFFSET
   7423  275d1				   -	       ifconst	PADDLESCALEX2
   7424  275d1				   -	       asl
   7425  275d1				   -	       endif
   7426  275d1				   -
   7427  275d1				   -	       ifnconst	PADDLESMOOTHINGOFF
   7428  275d1				   -	       clc
   7429  275d1				   -	       adc	paddleprevious1
   7430  275d1				   -	       ror
   7431  275d1				   -	       sta	paddleprevious1
   7432  275d1				   -	       endif
   7433  275d1				   -	       sta	paddleposition1
   7434  275d1				   -	       endif		; TWOPADDLESUPPORT
   7435  275d1				   -
   7436  275d1				   -	       jmp	LLRET0
   7437  275d1					       endif
   7438  275d1
   7439  275d1				    paddleport1update
   7440  275d1				   -	       ifconst	PADDLE1SUPPORT
   7441  275d1				   -	       lda	#6
   7442  275d1				   -	       sta	VBLANK	; start charging the paddle caps
   7443  275d1				   -
   7444  275d1				   -	       lda	#0	; use PADDLE timing
   7445  275d1				   -	       jsr	SETTIM64T	; INTIM is in Y
   7446  275d1				   -
   7447  275d1				   -paddleport1updateloop
   7448  275d1				   -	       lda	INPT2
   7449  275d1				   -	       bmi	skippaddle2setposition
   7450  275d1				   -	       sty	paddleposition2
   7451  275d1				   -skippaddle2setposition
   7452  275d1				   -	       ifconst	TWOPADDLESUPPORT
   7453  275d1				   -	       lda	INPT3
   7454  275d1				   -	       bmi	skippaddle3setposition
   7455  275d1				   -	       sty	paddleposition3
   7456  275d1				   -skippaddle3setposition
   7457  275d1				   -	       endif
   7458  275d1				   -	       ldy	INTIM
   7459  275d1				   -	       cpy	#TIMEOFFSET
   7460  275d1				   -	       bcs	paddleport1updateloop
   7461  275d1				   -
   7462  275d1				   -	       lda	#%10000110
   7463  275d1				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   7464  275d1				   -	       sec
   7465  275d1				   -	       lda	paddleposition2
   7466  275d1				   -	       sbc	#TIMEOFFSET
   7467  275d1				   -	       ifconst	PADDLESCALEX2
   7468  275d1				   -	       asl
   7469  275d1				   -	       endif
   7470  275d1				   -
   7471  275d1				   -	       ifnconst	PADDLESMOOTHINGOFF
   7472  275d1				   -	       clc
   7473  275d1				   -	       adc	paddleprevious2
   7474  275d1				   -	       ror
   7475  275d1				   -	       sta	paddleprevious2
   7476  275d1				   -	       endif
   7477  275d1				   -
   7478  275d1				   -	       sta	paddleposition2
   7479  275d1				   -
   7480  275d1				   -	       ifconst	TWOPADDLESUPPORT
   7481  275d1				   -	       sec
   7482  275d1				   -	       lda	paddleposition3
   7483  275d1				   -	       sbc	#TIMEOFFSET
   7484  275d1				   -	       ifconst	PADDLESCALEX2
   7485  275d1				   -	       asl
   7486  275d1				   -	       endif
   7487  275d1				   -
   7488  275d1				   -	       ifnconst	PADDLESMOOTHINGOFF
   7489  275d1				   -	       clc
   7490  275d1				   -	       adc	paddleprevious3
   7491  275d1				   -	       ror
   7492  275d1				   -	       sta	paddleprevious3
   7493  275d1				   -	       endif
   7494  275d1				   -	       sta	paddleposition3
   7495  275d1				   -	       endif		; TWOPADDLESUPPORT
   7496  275d1				   -
   7497  275d1				   -	       jmp	LLRET1
   7498  275d1					       endif
   7499  275d1
   7500  275d1
   7501  275d1				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   7502  275d1				   -	       ifconst	PADDLESUPPORT
   7503  275d1				   -			; x=0|1 for port, rather than paddle #. 
   7504  275d1				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   7505  275d1				   -			; game wants to support 2 paddles, up to the game to instead test the 
   7506  275d1				   -			; joystick right+left directions instead.
   7507  275d1				   -	       lda	SWCHA	; top of nibble is first paddle button
   7508  275d1				   -	       cpx	#0	; port 0?
   7509  275d1				   -	       beq	skippaddleport2shift
   7510  275d1				   -	       asl		; shift second port to upper nibble
   7511  275d1				   -	       asl
   7512  275d1				   -	       asl
   7513  275d1				   -	       asl
   7514  275d1				   -skippaddleport2shift
   7515  275d1				   -	       and	#%10000000
   7516  275d1				   -	       eor	#%10000000	; invert
   7517  275d1				   -	       sta	sINPT1,x
   7518  275d1				   -	       jmp	buttonreadloopreturn
   7519  275d1					       endif		; PADDLESUPPORT
   7520  275d1
   7521  275d1				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   7522  275d1				   -	       ifconst	MOUSESUPPORT
   7523  275d1				   -			; stick the mouse buttons in the correct shadow register...
   7524  275d1				   -	       txa
   7525  275d1				   -	       asl
   7526  275d1				   -	       tay		; y=x*2
   7527  275d1				   -	       lda	INPT4,x
   7528  275d1				   -	       eor	#%10000000
   7529  275d1				   -	       lsr
   7530  275d1				   -	       sta	sINPT1,x
   7531  275d1				   -
   7532  275d1				   -	       lda	INPT1,y
   7533  275d1				   -	       and	#%10000000
   7534  275d1				   -	       eor	#%10000000
   7535  275d1				   -	       ora	sINPT1,x
   7536  275d1				   -	       sta	sINPT1,x
   7537  275d1				   -	       jmp	buttonreadloopreturn
   7538  275d1					       endif		; MOUSESUPPORT
   7539  275d1
   7540  275d1				   -	       ifconst	KEYPADSUPPORT
   7541  275d1				   -			; ** select keypad rows 0 to 3 over 4 frames...
   7542  275d1				   -keypadrowselect
   7543  275d1				   -	       inc	keypadcounter
   7544  275d1				   -	       ldy	#0
   7545  275d1				   -	       lda	port0control
   7546  275d1				   -	       cmp	#7
   7547  275d1				   -	       bne	skipport0val
   7548  275d1				   -	       iny		; y=y+1
   7549  275d1				   -skipport0val
   7550  275d1				   -	       lda	port1control
   7551  275d1				   -	       cmp	#7
   7552  275d1				   -	       bne	skipport1val
   7553  275d1				   -	       iny
   7554  275d1				   -	       iny		; y=y+2
   7555  275d1				   -skipport1val
   7556  275d1				   -	       cpy	#0
   7557  275d1				   -	       beq	exitkeypadrowselect
   7558  275d1				   -	       lda	keyrowdirectionmask,y
   7559  275d1				   -	       sta	CTLSWA
   7560  275d1				   -	       tya
   7561  275d1				   -	       asl
   7562  275d1				   -	       asl
   7563  275d1				   -	       sta	inttemp1
   7564  275d1				   -	       lda	keypadcounter
   7565  275d1				   -	       and	#3
   7566  275d1				   -	       ora	inttemp1
   7567  275d1				   -	       tax
   7568  275d1				   -	       lda	keyrowselectvalue,x
   7569  275d1				   -	       sta	SWCHA
   7570  275d1				   -exitkeypadrowselect
   7571  275d1				   -	       rts
   7572  275d1				   -
   7573  275d1				   -keyrowdirectionmask
   7574  275d1				   -	       .byte	#%00000000	; 0 : port0=input port1=input
   7575  275d1				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   7576  275d1				   -	       .byte	#%00001111	; 2 : port0=input port1=output
   7577  275d1				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   7578  275d1				   -
   7579  275d1				   -keyrowselectvalue
   7580  275d1				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   7581  275d1				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   7582  275d1				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   7583  275d1				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   7584  275d1					       endif		; KEYPADSUPPORT
   7585  275d1
   7586  275d1				   -	       ifconst	KEYPADSUPPORT
   7587  275d1				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   7588  275d1				   -keypadcolumnread
   7589  275d1				   -	       lda	port0control
   7590  275d1				   -	       cmp	#7
   7591  275d1				   -	       bne	skipkeypadcolumnread0
   7592  275d1				   -	       lda	keypadcounter
   7593  275d1				   -	       and	#3
   7594  275d1				   -	       asl		; x2 because keypad variables are interleaved
   7595  275d1				   -	       tax
   7596  275d1				   -	       lda	#0
   7597  275d1				   -	       sta	keypadmatrix0a,x
   7598  275d1				   -	       lda	INPT0
   7599  275d1				   -	       cmp	#$80
   7600  275d1				   -	       rol	keypadmatrix0a,x
   7601  275d1				   -	       lda	INPT1
   7602  275d1				   -	       cmp	#$80
   7603  275d1				   -	       rol	keypadmatrix0a,x
   7604  275d1				   -	       lda	INPT4
   7605  275d1				   -	       cmp	#$80
   7606  275d1				   -	       rol	keypadmatrix0a,x
   7607  275d1				   -	       lda	keypadmatrix0a,x
   7608  275d1				   -	       eor	#%00000111
   7609  275d1				   -	       sta	keypadmatrix0a,x
   7610  275d1				   -skipkeypadcolumnread0
   7611  275d1				   -
   7612  275d1				   -	       lda	port1control
   7613  275d1				   -	       cmp	#7
   7614  275d1				   -	       bne	skipkeypadcolumnread1
   7615  275d1				   -	       lda	keypadcounter
   7616  275d1				   -	       and	#3
   7617  275d1				   -	       asl		; x2 because keypad variables are interleaved
   7618  275d1				   -	       tax
   7619  275d1				   -	       lda	#0
   7620  275d1				   -	       sta	keypadmatrix1a,x
   7621  275d1				   -	       rol	keypadmatrix1a,x
   7622  275d1				   -	       lda	INPT2
   7623  275d1				   -	       cmp	#$80
   7624  275d1				   -	       rol	keypadmatrix1a,x
   7625  275d1				   -	       lda	INPT3
   7626  275d1				   -	       cmp	#$80
   7627  275d1				   -	       rol	keypadmatrix1a,x
   7628  275d1				   -	       lda	INPT5
   7629  275d1				   -	       cmp	#$80
   7630  275d1				   -	       rol	keypadmatrix1a,x
   7631  275d1				   -	       lda	keypadmatrix1a,x
   7632  275d1				   -	       eor	#%00000111
   7633  275d1				   -	       sta	keypadmatrix1a,x
   7634  275d1				   -skipkeypadcolumnread1
   7635  275d1				   -	       rts
   7636  275d1					       endif		; KEYPADSUPPORT
   7637  275d1
   7638  275d1				    setportforinput
   7639  275d1			ad 81 02	       lda	CTLSWA
   7640  275d4			3d d7 f1	       and	SWCHA_DIRMASK,x
   7641  275d7			8d 81 02	       sta	CTLSWA
   7642  275da			60		       rts
   7643  275db
   7644  275db				    setonebuttonmode
   7645  275db			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   7646  275dd			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   7647  275df			a9 14		       lda	#$14
   7648  275e1			8d 83 02	       sta	CTLSWB
   7649  275e4			ad 82 02	       lda	SWCHB
   7650  275e7			1d 01 f6	       ora	thisjoy2buttonbit,x	; disable: write 1 to the 2-button bit
   7651  275ea			8d 82 02	       sta	SWCHB
   7652  275ed			60		       rts
   7653  275ee
   7654  275ee				    settwobuttonmode
   7655  275ee			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   7656  275f0			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   7657  275f2			a9 14		       lda	#$14
   7658  275f4			8d 83 02	       sta	CTLSWB
   7659  275f7			ad 82 02	       lda	SWCHB
   7660  275fa			3d 02 f6	       and	thisjoy2buttonbit+1,x	; enable: write 0 to the 2-button bit
   7661  275fd			8d 82 02	       sta	SWCHB
   7662  27600			60		       rts
   7663  27601
   7664  27601				    thisjoy2buttonbit
   7665  27601							; p0	p1   p0
   7666  27601			04 10 04	       .byte.b	$04, $10, $04
   7667  27604
   7668  27604							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7669  27604
   7670  27604				    START
   7671  27604				    start
   7672  27604
   7673  27604							;******** more or less the Atari recommended startup procedure
   7674  27604
   7675  27604			78		       sei
   7676  27605			d8		       cld
   7677  27606
   7678  27606					       ifnconst	NOTIALOCK
   7679  27606			a9 07		       lda	#$07
   7680  27608				   -	       else
   7681  27608				   -	       lda	#$06
   7682  27608					       endif
   7683  27608			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   7684  2760a			a9 7f		       lda	#$7F
   7685  2760c			85 3c		       sta	CTRL	;disable DMA
   7686  2760e			a9 00		       lda	#$00
   7687  27610			85 38		       sta	OFFSET
   7688  27612					       ifnconst	NOTIALOCK
   7689  27612			85 01		       sta	INPTCTRL
   7690  27614			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   7691  27616					       endif
   7692  27616			a2 ff		       ldx	#$FF
   7693  27618			9a		       txs
   7694  27619
   7695  27619							;************** Clear Memory
   7696  27619
   7697  27619							; ** Clear 1800-27FF, pg0+pg1 memory.
   7698  27619				    ClearMemPages
   7699  27619			a9 00		       lda	#0
   7700  2761b			a8		       tay		; y=0
   7701  2761c			85 80		       sta	$80
   7702  2761e			a2 18		       ldx	#$18
   7703  27620				    ClearMemPagesLoop
   7704  27620			86 81		       stx	$81	; needed for when we step on ZP memory
   7705  27622			91 80		       sta	($80),y	;Store data
   7706  27624			c8		       iny		;Next byte
   7707  27625			d0 f9		       bne	ClearMemPagesLoop
   7708  27627			e8		       inx
   7709  27628			e0 28		       cpx	#$28
   7710  2762a			d0 f4		       bne	ClearMemPagesLoop
   7711  2762c			85 81		       sta	$81
   7712  2762e
   7713  2762e							;seed random number with hopefully-random timer value
   7714  2762e			a9 01		       lda	#1
   7715  27630			0d 84 02	       ora	INTIM
   7716  27633			85 40		       sta	rand
   7717  27635
   7718  27635							; detect the console type...
   7719  27635				    pndetectvblankstart
   7720  27635			a5 28		       lda	MSTAT
   7721  27637			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   7722  27639				    pndetectvblankover
   7723  27639			a5 28		       lda	MSTAT
   7724  2763b			30 fc		       bmi	pndetectvblankover	; then wait for it to be over
   7725  2763d			a0 00		       ldy	#$00
   7726  2763f			a2 00		       ldx	#$00
   7727  27641				    pndetectvblankhappening
   7728  27641			a5 28		       lda	MSTAT
   7729  27643			30 07		       bmi	pndetectinvblank	; if VBLANK starts, exit our counting loop 
   7730  27645			85 24		       sta	WSYNC
   7731  27647			85 24		       sta	WSYNC
   7732  27649			e8		       inx
   7733  2764a			d0 f5		       bne	pndetectvblankhappening
   7734  2764c				    pndetectinvblank
   7735  2764c			e0 7d		       cpx	#125
   7736  2764e			90 02		       bcc	pndetecispal
   7737  27650			a0 01		       ldy	#$01
   7738  27652				    pndetecispal
   7739  27652			8c 09 21	       sty	paldetected
   7740  27655
   7741  27655			20 ba f4	       jsr	createallgamedlls
   7742  27658
   7743  27658			a9 18		       lda	#>DLLMEM
   7744  2765a			85 2c		       sta	DPPH
   7745  2765c			a9 00		       lda	#<DLLMEM
   7746  2765e			85 30		       sta	DPPL
   7747  27660
   7748  27660				   -	       ifconst	pokeysupport
   7749  27660				   -			; pokey support is compiled in, so try to detect it...
   7750  27660				   -	       jsr	detectpokeylocation
   7751  27660					       endif
   7752  27660
   7753  27660			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   7754  27662			8d ba 01	       sta	port0control
   7755  27665			8d bb 01	       sta	port1control
   7756  27668
   7757  27668							;Setup port A to read mode
   7758  27668							;lda #$00
   7759  27668							;sta SWCHA
   7760  27668							;sta CTLSWA
   7761  27668
   7762  27668				   -	       ifconst	HSSUPPORT
   7763  27668				   -	       ifconst	bankswitchmode
   7764  27668				   -	       ifconst	included.hiscore.asm.bank
   7765  27668				   -	       ifconst	MCPDEVCART
   7766  27668				   -	       lda	#($18 | included.hiscore.asm.bank)
   7767  27668				   -	       ifconst	dumpbankswitch
   7768  27668				   -	       sta	dumpbankswitch
   7769  27668				   -	       endif
   7770  27668				   -	       sta	$3000
   7771  27668				   -	       else
   7772  27668				   -	       lda	#(included.hiscore.asm.bank)
   7773  27668				   -	       ifconst	dumpbankswitch
   7774  27668				   -	       sta	dumpbankswitch
   7775  27668				   -	       endif
   7776  27668				   -	       sta	$8000
   7777  27668				   -	       endif
   7778  27668				   -	       endif		; included.hiscore.asm.bank
   7779  27668				   -	       endif		; bankswitchmode
   7780  27668				   -			; try to detect HSC
   7781  27668				   -	       jsr	detecthsc
   7782  27668				   -	       and	#1
   7783  27668				   -	       sta	hsdevice
   7784  27668				   -skipHSCdetect
   7785  27668				   -			; try to detect AtariVox eeprom
   7786  27668				   -	       jsr	detectatarivoxeeprom
   7787  27668				   -	       and	#2
   7788  27668				   -	       ora	hsdevice
   7789  27668				   -	       cmp	#3
   7790  27668				   -	       bne	storeAinhsdevice
   7791  27668				   -			; For now, we tie break by giving HSC priority over AtariVox.
   7792  27668				   -			; Later we should check each device's priority byte if set, instead, 
   7793  27668				   -	       lda	#2
   7794  27668				   -storeAinhsdevice
   7795  27668				   -	       sta	hsdevice
   7796  27668				   -	       lda	#$ff
   7797  27668				   -	       sta	hsdifficulty
   7798  27668				   -	       sta	hsgameslot
   7799  27668				   -	       sta	hsnewscoreline
   7800  27668					       endif		; HSSUPPORT
   7801  27668
   7802  27668				   -	       ifconst	AVOXVOICE
   7803  27668				   -	       jsr	silenceavoxvoice
   7804  27668					       endif
   7805  27668
   7806  27668				   -	       ifconst	RMT
   7807  27668				   -	       ifconst	RMTVOLUME
   7808  27668				   -	       lda	#$F0	; default to full RMT volume
   7809  27668				   -	       sta	rmtvolume
   7810  27668				   -	       ifconst	TIAVOLUME
   7811  27668				   -	       sta	tiavolume
   7812  27668				   -	       endif		; TIAVOLUME
   7813  27668				   -	       endif		; RMTVOLUME
   7814  27668					       else		; !RMT
   7815  27668				   -	       ifconst	TIAVOLUME
   7816  27668				   -	       lda	#$F0	; default to full TIA volume
   7817  27668				   -	       sta	tiavolume
   7818  27668					       endif		; TIAVOLUME
   7819  27668					       endif		; RMT
   7820  27668
   7821  27668					       ifconst	bankswitchmode
   7822  27668							; we need to switch to the first bank as a default. this needs to
   7823  27668							; happen before DMA, in case there's a topscreenroutine in bank 0
   7824  27668				   -	       ifconst	MCPDEVCART
   7825  27668				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   7826  27668				   -	       ifconst	dumpbankswitch
   7827  27668				   -	       sta	dumpbankswitch
   7828  27668				   -	       endif
   7829  27668				   -	       sta	$3000
   7830  27668					       else
   7831  27668			a9 00		       lda	#0
   7832  2766a				   -	       ifconst	dumpbankswitch
   7833  2766a				   -	       sta	dumpbankswitch
   7834  2766a					       endif
   7835  2766a			8d 00 80	       sta	$8000
   7836  2766d					       endif
   7837  2766d					       endif
   7838  2766d
   7839  2766d							; CTRL 76543210
   7840  2766d							; 7 colorburst kill
   7841  2766d							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   7842  2766d							; 4 character width 1=2 byte chars, 0=1 byte chars
   7843  2766d							; 3 border control 0=background color border, 1=black border
   7844  2766d							; 2 kangaroo mode 0=transparency, 1=kangaroo
   7845  2766d							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   7846  2766d
   7847  2766d				   -	       ifconst	DOUBLEWIDE
   7848  2766d				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   7849  2766d					       else
   7850  2766d			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   7851  2766f					       endif
   7852  2766f
   7853  2766f			20 3e f5	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   7854  27672
   7855  27672			85 3c		       sta	CTRL
   7856  27674			8d 07 21	       sta	sCTRL
   7857  27677
   7858  27677			20 ad f4	       jsr	vblankresync
   7859  2767a
   7860  2767a			a2 01		       ldx	#1
   7861  2767c			20 ee f5	       jsr	settwobuttonmode
   7862  2767f			a2 00		       ldx	#0
   7863  27681			20 ee f5	       jsr	settwobuttonmode
   7864  27684
   7865  27684					       ifnconst	.altgamestart
   7866  27684			4c 00 80	       jmp	game
   7867  27687				   -	       else
   7868  27687				   -	       jmp	.altgamestart
   7869  27687					       endif
   7870  27687
   7871  27687							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7872  27687
   7873  27687							;************** Setup DLL entries
   7874  27687
   7875  27687							; setup some working definitions, to avoid ifnconst mess elsewhere...
   7876  27687					       ifnconst	SCREENHEIGHT
   7877  27687			00 c0	    WSCREENHEIGHT =	192
   7878  27687				   -	       else
   7879  27687				   -WSCREENHEIGHT =	SCREENHEIGHT
   7880  27687					       endif
   7881  27687
   7882  27687				   -	       ifnconst	ZONEHEIGHT
   7883  27687				   -WZONEHEIGHT =	16
   7884  27687					       else
   7885  27687			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   7886  27687					       endif
   7887  27687
   7888  27687					       ifnconst	ZONECOUNT
   7889  27687				   -	       ifconst	VSCROLL
   7890  27687				   -WZONECOUNT =	((WSCREENHEIGHT/WZONEHEIGHT)+1)
   7891  27687					       else		; !VSCROLL
   7892  27687			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   7893  27687					       endif		; !VSCROLL
   7894  27687				   -	       else
   7895  27687				   -	       ifconst	VSCROLL
   7896  27687				   -WZONECOUNT =	(ZONECOUNT+1)
   7897  27687				   -	       else		; !VSCROLL
   7898  27687				   -WZONECOUNT =	ZONECOUNT
   7899  27687				   -	       endif		; !VSCROLL
   7900  27687					       endif
   7901  27687
   7902  27687							; top of the frame, non-visible lines. this is based on NTSC,
   7903  27687							; but we add in extra NV lines at the end of the display to ensure
   7904  27687							; our PAL friends can play the game without it crashing.
   7905  27687			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   7906  27687
   7907  27687				   -	       ifnconst	DLMEMSTART
   7908  27687				   -	       ifnconst	DOUBLEBUFFER
   7909  27687				   -WDLMEMSTART =	$1880
   7910  27687				   -	       else
   7911  27687				   -WDLMEMSTART =	$18E0
   7912  27687				   -	       endif		; DOUBLEBUFFER
   7913  27687					       else
   7914  27687			40 00	    WDLMEMSTART =	DLMEMSTART
   7915  27687					       endif
   7916  27687
   7917  27687				   -	       ifnconst	DLMEMEND
   7918  27687				   -	       ifconst	EXTRADLMEMORY
   7919  27687				   -WDLMEMEND  =	$23FF
   7920  27687				   -	       else
   7921  27687				   -WDLMEMEND  =	$1FFF
   7922  27687				   -	       endif
   7923  27687					       else
   7924  27687			7f ff	    WDLMEMEND  =	DLMEMEND
   7925  27687					       endif
   7926  27687
   7927  27687
   7928  27687				    WMEMSIZE   SET	(WDLMEMEND-WDLMEMSTART+1)
   7929  27687
   7930  27687				   -	       ifconst	VSCROLL
   7931  27687				   -	       ifnconst	DOUBLEBUFFER
   7932  27687				   -			; give the last zone extra ram for the dma mask objects...
   7933  27687				   -WMEMSIZE   SET	(WMEMSIZE-(maskscrollspriteend-maskscrollsprite))
   7934  27687				   -	       endif		; DOUBLEBUFFER
   7935  27687					       endif		; VSCROLL
   7936  27687
   7937  27687				   -	       ifnconst	DOUBLEBUFFER
   7938  27687				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   7939  27687					       else
   7940  27687			02 a8	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   7941  27687					       endif
   7942  27687
   7943  27687			02 aa	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   7944  27687					       if	TDOUBLEBUFFEROFFSET > 255
   7945  27687			00 ff	    DOUBLEBUFFEROFFSET =	255
   7946  27687				   -	       else
   7947  27687				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   7948  27687					       endif
   7949  27687
   7950  27687				   -	       ifconst	EXTRADLMEMORY
   7951  27687				   -SECONDDLHALFSTART SET	$2300
   7952  27687					       endif
   7953  27687
   7954  27687				    DLPOINTH
   7955  27687				    DLINDEX    SET	0
   7956  27687					       REPEAT	WZONECOUNT
   7957  27687				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27687				   -	       ifconst	EXTRADLMEMORY
   7959  27687				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27687				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27687				   -	       else
   7962  27687				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27687				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27687				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27687				   -	       endif
   7966  27687				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27687					       endif		; EXTRADLMEMORY
   7968  27687							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27687			40		       .byte.b	>TMPMEMADDRESS
   7970  27687				    DLINDEX    SET	DLINDEX + 1
   7956  27687					       REPEND
   7957  27687				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27688				   -	       ifconst	EXTRADLMEMORY
   7959  27688				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27688				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27688				   -	       else
   7962  27688				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27688				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27688				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27688				   -	       endif
   7966  27688				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27688					       endif		; EXTRADLMEMORY
   7968  27688							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27688			45		       .byte.b	>TMPMEMADDRESS
   7970  27688				    DLINDEX    SET	DLINDEX + 1
   7956  27688					       REPEND
   7957  27688				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27689				   -	       ifconst	EXTRADLMEMORY
   7959  27689				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27689				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27689				   -	       else
   7962  27689				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27689				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27689				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27689				   -	       endif
   7966  27689				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27689					       endif		; EXTRADLMEMORY
   7968  27689							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27689			4a		       .byte.b	>TMPMEMADDRESS
   7970  27689				    DLINDEX    SET	DLINDEX + 1
   7956  27689					       REPEND
   7957  27689				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768a				   -	       ifconst	EXTRADLMEMORY
   7959  2768a				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768a				   -	       else
   7962  2768a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768a				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768a				   -	       endif
   7966  2768a				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768a					       endif		; EXTRADLMEMORY
   7968  2768a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768a			50		       .byte.b	>TMPMEMADDRESS
   7970  2768a				    DLINDEX    SET	DLINDEX + 1
   7956  2768a					       REPEND
   7957  2768a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768b				   -	       ifconst	EXTRADLMEMORY
   7959  2768b				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768b				   -	       else
   7962  2768b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768b				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768b				   -	       endif
   7966  2768b				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768b					       endif		; EXTRADLMEMORY
   7968  2768b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768b			55		       .byte.b	>TMPMEMADDRESS
   7970  2768b				    DLINDEX    SET	DLINDEX + 1
   7956  2768b					       REPEND
   7957  2768b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768c				   -	       ifconst	EXTRADLMEMORY
   7959  2768c				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768c				   -	       else
   7962  2768c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768c				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768c				   -	       endif
   7966  2768c				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768c					       endif		; EXTRADLMEMORY
   7968  2768c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768c			5a		       .byte.b	>TMPMEMADDRESS
   7970  2768c				    DLINDEX    SET	DLINDEX + 1
   7956  2768c					       REPEND
   7957  2768c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768d				   -	       ifconst	EXTRADLMEMORY
   7959  2768d				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768d				   -	       else
   7962  2768d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768d				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768d				   -	       endif
   7966  2768d				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768d					       endif		; EXTRADLMEMORY
   7968  2768d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768d			60		       .byte.b	>TMPMEMADDRESS
   7970  2768d				    DLINDEX    SET	DLINDEX + 1
   7956  2768d					       REPEND
   7957  2768d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768e				   -	       ifconst	EXTRADLMEMORY
   7959  2768e				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768e				   -	       else
   7962  2768e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768e				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768e				   -	       endif
   7966  2768e				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768e					       endif		; EXTRADLMEMORY
   7968  2768e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768e			65		       .byte.b	>TMPMEMADDRESS
   7970  2768e				    DLINDEX    SET	DLINDEX + 1
   7956  2768e					       REPEND
   7957  2768e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  2768f				   -	       ifconst	EXTRADLMEMORY
   7959  2768f				   -	       if	TMPMEMADDRESS > $1FFF
   7960  2768f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  2768f				   -	       else
   7962  2768f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  2768f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  2768f				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  2768f				   -	       endif
   7966  2768f				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  2768f					       endif		; EXTRADLMEMORY
   7968  2768f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  2768f			6a		       .byte.b	>TMPMEMADDRESS
   7970  2768f				    DLINDEX    SET	DLINDEX + 1
   7956  2768f					       REPEND
   7957  2768f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27690				   -	       ifconst	EXTRADLMEMORY
   7959  27690				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27690				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27690				   -	       else
   7962  27690				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27690				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27690				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27690				   -	       endif
   7966  27690				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27690					       endif		; EXTRADLMEMORY
   7968  27690							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27690			70		       .byte.b	>TMPMEMADDRESS
   7970  27690				    DLINDEX    SET	DLINDEX + 1
   7956  27690					       REPEND
   7957  27690				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27691				   -	       ifconst	EXTRADLMEMORY
   7959  27691				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27691				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27691				   -	       else
   7962  27691				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27691				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27691				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27691				   -	       endif
   7966  27691				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27691					       endif		; EXTRADLMEMORY
   7968  27691							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27691			75		       .byte.b	>TMPMEMADDRESS
   7970  27691				    DLINDEX    SET	DLINDEX + 1
   7956  27691					       REPEND
   7957  27691				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7958  27692				   -	       ifconst	EXTRADLMEMORY
   7959  27692				   -	       if	TMPMEMADDRESS > $1FFF
   7960  27692				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7961  27692				   -	       else
   7962  27692				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7963  27692				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7964  27692				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   7965  27692				   -	       endif
   7966  27692				   -	       endif		; TMPMEMADDRESS > $1FFF
   7967  27692					       endif		; EXTRADLMEMORY
   7968  27692							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   7969  27692			7a		       .byte.b	>TMPMEMADDRESS
   7970  27692				    DLINDEX    SET	DLINDEX + 1
   7971  27693					       REPEND
   7972  27693
   7973  27693				   -	       ifconst	EXTRADLMEMORY
   7974  27693				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   7975  27693					       endif
   7976  27693
   7977  27693
   7978  27693				    DLPOINTL
   7979  27693				    DLINDEX    SET	0
   7980  27693					       REPEAT	WZONECOUNT
   7981  27693				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27693				   -	       ifconst	EXTRADLMEMORY
   7983  27693				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27693				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27693				   -	       else
   7986  27693				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27693				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27693				   -	       endif
   7989  27693				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27693					       endif		; EXTRADLMEMORY
   7991  27693			00		       .byte.b	<TMPMEMADDRESS
   7992  27693				    DLINDEX    SET	DLINDEX + 1
   7980  27693					       REPEND
   7981  27693				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27694				   -	       ifconst	EXTRADLMEMORY
   7983  27694				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27694				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27694				   -	       else
   7986  27694				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27694				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27694				   -	       endif
   7989  27694				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27694					       endif		; EXTRADLMEMORY
   7991  27694			55		       .byte.b	<TMPMEMADDRESS
   7992  27694				    DLINDEX    SET	DLINDEX + 1
   7980  27694					       REPEND
   7981  27694				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27695				   -	       ifconst	EXTRADLMEMORY
   7983  27695				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27695				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27695				   -	       else
   7986  27695				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27695				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27695				   -	       endif
   7989  27695				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27695					       endif		; EXTRADLMEMORY
   7991  27695			aa		       .byte.b	<TMPMEMADDRESS
   7992  27695				    DLINDEX    SET	DLINDEX + 1
   7980  27695					       REPEND
   7981  27695				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27696				   -	       ifconst	EXTRADLMEMORY
   7983  27696				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27696				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27696				   -	       else
   7986  27696				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27696				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27696				   -	       endif
   7989  27696				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27696					       endif		; EXTRADLMEMORY
   7991  27696			00		       .byte.b	<TMPMEMADDRESS
   7992  27696				    DLINDEX    SET	DLINDEX + 1
   7980  27696					       REPEND
   7981  27696				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27697				   -	       ifconst	EXTRADLMEMORY
   7983  27697				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27697				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27697				   -	       else
   7986  27697				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27697				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27697				   -	       endif
   7989  27697				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27697					       endif		; EXTRADLMEMORY
   7991  27697			55		       .byte.b	<TMPMEMADDRESS
   7992  27697				    DLINDEX    SET	DLINDEX + 1
   7980  27697					       REPEND
   7981  27697				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27698				   -	       ifconst	EXTRADLMEMORY
   7983  27698				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27698				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27698				   -	       else
   7986  27698				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27698				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27698				   -	       endif
   7989  27698				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27698					       endif		; EXTRADLMEMORY
   7991  27698			aa		       .byte.b	<TMPMEMADDRESS
   7992  27698				    DLINDEX    SET	DLINDEX + 1
   7980  27698					       REPEND
   7981  27698				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  27699				   -	       ifconst	EXTRADLMEMORY
   7983  27699				   -	       if	TMPMEMADDRESS > $1FFF
   7984  27699				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  27699				   -	       else
   7986  27699				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  27699				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  27699				   -	       endif
   7989  27699				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  27699					       endif		; EXTRADLMEMORY
   7991  27699			00		       .byte.b	<TMPMEMADDRESS
   7992  27699				    DLINDEX    SET	DLINDEX + 1
   7980  27699					       REPEND
   7981  27699				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  2769a				   -	       ifconst	EXTRADLMEMORY
   7983  2769a				   -	       if	TMPMEMADDRESS > $1FFF
   7984  2769a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  2769a				   -	       else
   7986  2769a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  2769a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  2769a				   -	       endif
   7989  2769a				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  2769a					       endif		; EXTRADLMEMORY
   7991  2769a			55		       .byte.b	<TMPMEMADDRESS
   7992  2769a				    DLINDEX    SET	DLINDEX + 1
   7980  2769a					       REPEND
   7981  2769a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  2769b				   -	       ifconst	EXTRADLMEMORY
   7983  2769b				   -	       if	TMPMEMADDRESS > $1FFF
   7984  2769b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  2769b				   -	       else
   7986  2769b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  2769b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  2769b				   -	       endif
   7989  2769b				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  2769b					       endif		; EXTRADLMEMORY
   7991  2769b			aa		       .byte.b	<TMPMEMADDRESS
   7992  2769b				    DLINDEX    SET	DLINDEX + 1
   7980  2769b					       REPEND
   7981  2769b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  2769c				   -	       ifconst	EXTRADLMEMORY
   7983  2769c				   -	       if	TMPMEMADDRESS > $1FFF
   7984  2769c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  2769c				   -	       else
   7986  2769c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  2769c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  2769c				   -	       endif
   7989  2769c				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  2769c					       endif		; EXTRADLMEMORY
   7991  2769c			00		       .byte.b	<TMPMEMADDRESS
   7992  2769c				    DLINDEX    SET	DLINDEX + 1
   7980  2769c					       REPEND
   7981  2769c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  2769d				   -	       ifconst	EXTRADLMEMORY
   7983  2769d				   -	       if	TMPMEMADDRESS > $1FFF
   7984  2769d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  2769d				   -	       else
   7986  2769d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  2769d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  2769d				   -	       endif
   7989  2769d				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  2769d					       endif		; EXTRADLMEMORY
   7991  2769d			55		       .byte.b	<TMPMEMADDRESS
   7992  2769d				    DLINDEX    SET	DLINDEX + 1
   7980  2769d					       REPEND
   7981  2769d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7982  2769e				   -	       ifconst	EXTRADLMEMORY
   7983  2769e				   -	       if	TMPMEMADDRESS > $1FFF
   7984  2769e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7985  2769e				   -	       else
   7986  2769e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7987  2769e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7988  2769e				   -	       endif
   7989  2769e				   -	       endif		; TMPMEMADDRESS > $1FFF
   7990  2769e					       endif		; EXTRADLMEMORY
   7991  2769e			aa		       .byte.b	<TMPMEMADDRESS
   7992  2769e				    DLINDEX    SET	DLINDEX + 1
   7993  2769f					       REPEND
   7994  2769f
   7995  2769f
   7996  2769f				    DLINDEX    SET	0
   7997  2769f					       REPEAT	WZONECOUNT
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   7997  2769f					       REPEND
   7998  2769f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7999  2769f				   -	       ifconst	EXTRADLMEMORY
   8000  2769f				   -	       if	TMPMEMADDRESS > $1FFF
   8001  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8002  2769f				   -	       else
   8003  2769f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   8004  2769f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   8005  2769f				   -	       endif
   8006  2769f				   -	       endif		; TMPMEMADDRESS > $1FFF
   8007  2769f					       endif		; EXTRADLMEMORY
   8008  2769f
   8009  2769f			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   8010  2769f				    LASTZONEADDRESS SET	TMPMEMADDRESS
   8011  2769f
   8012  2769f				    DLINDEX    SET	DLINDEX + 1
   8013  2769f					       REPEND
   8014  2769f
   8015  2769f
     $4000 to $7fff used as zone memory, allowing 136 display objects per zone.
   8016  2769f					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   8017  2769f
   8018  2769f				    DLHEIGHT
   8019  2769f					       REPEAT	WZONECOUNT
   8020  2769f			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  2769f					       REPEND
   8020  276a0			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a0					       REPEND
   8020  276a1			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a1					       REPEND
   8020  276a2			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a2					       REPEND
   8020  276a3			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a3					       REPEND
   8020  276a4			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a4					       REPEND
   8020  276a5			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a5					       REPEND
   8020  276a6			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a6					       REPEND
   8020  276a7			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a7					       REPEND
   8020  276a8			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a8					       REPEND
   8020  276a9			0f		       .byte.b	(WZONEHEIGHT-1)
   8019  276a9					       REPEND
   8020  276aa			0f		       .byte.b	(WZONEHEIGHT-1)
   8021  276ab					       REPEND
   8022  276ab
   8023  276ab							; Provided under the CC0 license. See the included LICENSE.txt for details.
   8024  276ab
   8025  276ab							; a simple guard, than ensures the 7800basic code hasn't
   8026  276ab							; spilled into the encryption area...
     2259 bytes left in the 7800basic reserved area.
   8027  276ab					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   8028  276ab				   -	       if	(*>$FF7D)
   8029  276ab				   -	       echo
   8030  276ab				   -	       echo	"***************************"
   8031  276ab				   -	       echo	"*** Abort: ROM Overflow ***"
   8032  276ab				   -	       echo	"***************************"
   8033  276ab				   -	       ERR		; abort the assembly
   8034  276ab					       endif
   8035  276ab
   8036  276ab							; throw a compile
   8037  276ab				   -	       ifconst	RMT
   8038  276ab				   -	       ifnconst	pokeysupport
   8039  276ab				   -	       echo
   8040  276ab				   -	       echo	"************************************************************"
   8041  276ab				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   8042  276ab				   -	       echo	"************************************************************"
   8043  276ab				   -	       ERR		; abort
   8044  276ab				   -	       endif		; pokeysupport
   8045  276ab				   -	       ifnconst	pokeyaddress
   8046  276ab				   -	       echo
   8047  276ab				   -	       echo	"************************************************************"
   8048  276ab				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   8049  276ab				   -	       echo	"************************************************************"
   8050  276ab				   -	       ERR		; abort
   8051  276ab				   -	       endif		; pokeyaddress
   8052  276ab					       endif
   8053  276ab
   8054  276ab							; Provided under the CC0 license. See the included LICENSE.txt for details.
   8055  276ab
   8056  276ab				   -	       ifconst	DEV
   8057  276ab				   -	       ifnconst	ZONEHEIGHT
   8058  276ab				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   8059  276ab				   -	       else
   8060  276ab				   -	       if	ZONEHEIGHT = 8
   8061  276ab				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   8062  276ab				   -	       else
   8063  276ab				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   8064  276ab				   -	       endif
   8065  276ab				   -	       endif
   8066  276ab					       endif
   8067  276ab
   8068  276ab				   -	       if	START_OF_ROM = .
   8069  276ab				   -	       .byte	0
   8070  276ab					       endif
   8071  276ab				    START_OF_ROM SET	0
   8072  276ab
   8073  276ab							; FF7E/FF7F contains the 7800basic crc checksum word
   8074  276ab
   8075  276ab							; FF80 - FFF7 contains the 7800 encryption key 
   8076  276ab
   8077  276ab				   -	       ifnconst	bankswitchmode
   8078  276ab				   -	       ORG	$FFF8
   8079  276ab					       else
   8080  276ab					       ifconst	ROM128K
   8081  27ff8					       ORG	$27FF8
   8082  27ff8					       RORG	$FFF8
   8083  27ff8					       endif
   8084  27ff8				   -	       ifconst	ROM144K
   8085  27ff8				   -	       ORG	$27FF8
   8086  27ff8				   -	       RORG	$FFF8
   8087  27ff8					       endif
   8088  27ff8				   -	       ifconst	ROM256K
   8089  27ff8				   -	       ORG	$47FF8
   8090  27ff8				   -	       RORG	$FFF8
   8091  27ff8					       endif
   8092  27ff8				   -	       ifconst	ROM272K
   8093  27ff8				   -	       ORG	$47FF8
   8094  27ff8				   -	       RORG	$FFF8
   8095  27ff8					       endif
   8096  27ff8				   -	       ifconst	ROM512K
   8097  27ff8				   -	       ORG	$87FF8
   8098  27ff8				   -	       RORG	$FFF8
   8099  27ff8					       endif
   8100  27ff8				   -	       ifconst	ROM528K
   8101  27ff8				   -	       ORG	$87FF8
   8102  27ff8				   -	       RORG	$FFF8
   8103  27ff8					       endif
   8104  27ff8					       endif
   8105  27ff8
   8106  27ff8
   8107  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   8108  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   8109  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   8110  27ffa
   8111  27ffa							;Vectors
   8112  27ffa			00 f0		       .word.w	NMI
   8113  27ffc			04 f6		       .word.w	START
   8114  27ffe			67 f0		       .word.w	IRQ
   8115  28000
