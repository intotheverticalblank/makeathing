------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}
    273  28000 ????			    .Palette   SET	{2}	; constant
    274  28000 ????			    .SpriteX   SET	{3}	; variable
    275  28000 ????			    .SpriteY   SET	{4}	; variable
    276  28000 ????			    .ByteOffset SET	{5}	; variable 
    277  28000 ????
    278  28000 ????				       lda	.SpriteY
    279  28000 ????				       lsr
    280  28000 ????				       lsr
    281  28000 ????				       asr	#%11111110	; ensure carry is clear
    282  28000 ????				       if	WZONEHEIGHT = 16
    283  28000 ????				       asr	#%11111110	; ensure carry is clear
    284  28000 ????				       endif
    285  28000 ????
    286  28000 ????				       tax
    287  28000 ????
    288  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  28000 ????				       sta	dlpnt
    290  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  28000 ????				       sta	dlpnt+1
    292  28000 ????
    293  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  28000 ????
    295  28000 ????				       lda	.ByteOffset
    296  28000 ????				       if	{1}_width = 2
    297  28000 ????				       asl
    298  28000 ????				       endif
    299  28000 ????				       if	{1}_width = 3
    300  28000 ????				       asl
    301  28000 ????				       adc	.ByteOffset
    302  28000 ????				       endif
    303  28000 ????				       if	{1}_width = 4
    304  28000 ????				       asl
    305  28000 ????				       asl
    306  28000 ????				       endif
    307  28000 ????				       if	{1}_width = 5
    308  28000 ????				       asl
    309  28000 ????				       asl
    310  28000 ????				       adc	.ByteOffset
    311  28000 ????				       endif
    312  28000 ????				       if	{1}_width = 6
    313  28000 ????				       asl
    314  28000 ????				       adc	.ByteOffset
    315  28000 ????				       asl
    316  28000 ????				       endif
    317  28000 ????				       if	{1}_width = 7
    318  28000 ????				       asl
    319  28000 ????				       adc	.ByteOffset
    320  28000 ????				       asl
    321  28000 ????				       adc	.ByteOffset
    322  28000 ????				       endif
    323  28000 ????				       if	{1}_width = 8
    324  28000 ????				       asl
    325  28000 ????				       asl
    326  28000 ????				       asl
    327  28000 ????				       endif
    328  28000 ????				       if	{1}_width = 9
    329  28000 ????				       asl
    330  28000 ????				       asl
    331  28000 ????				       asl
    332  28000 ????				       adc	.ByteOffset
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 10
    335  28000 ????				       asl
    336  28000 ????				       asl
    337  28000 ????				       adc	.ByteOffset
    338  28000 ????				       asl
    339  28000 ????				       endif
    340  28000 ????				       if	{1}_width = 11
    341  28000 ????				       asl
    342  28000 ????				       asl
    343  28000 ????				       adc	.ByteOffset
    344  28000 ????				       asl
    345  28000 ????				       adc	.ByteOffset
    346  28000 ????				       endif
    347  28000 ????				       if	{1}_width = 12
    348  28000 ????				       asl
    349  28000 ????				       adc	.ByteOffset
    350  28000 ????				       asl
    351  28000 ????				       asl
    352  28000 ????				       endif
    353  28000 ????				       if	{1}_width = 13
    354  28000 ????				       asl
    355  28000 ????				       adc	.ByteOffset
    356  28000 ????				       asl
    357  28000 ????				       asl
    358  28000 ????				       adc	.ByteOffset
    359  28000 ????				       endif
    360  28000 ????				       if	{1}_width = 14
    361  28000 ????				       asl
    362  28000 ????				       adc	.ByteOffset
    363  28000 ????				       asl
    364  28000 ????				       adc	.ByteOffset
    365  28000 ????				       asl
    366  28000 ????				       endif
    367  28000 ????
    368  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  28000 ????
    371  28000 ????				       iny
    372  28000 ????
    373  28000 ????				       lda	#({1}_mode | %01000000)
    374  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  28000 ????
    376  28000 ????				       iny
    377  28000 ????
    378  28000 ????				       lda	.SpriteY
    379  28000 ????				       and	#(WZONEHEIGHT - 1)
    380  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  28000 ????				       ora	#>.GFXLabel
    382  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  28000 ????
    384  28000 ????				       iny
    385  28000 ????
    386  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  28000 ????
    389  28000 ????				       iny
    390  28000 ????
    391  28000 ????				       lda	.SpriteX
    392  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  28000 ????
    394  28000 ????				       iny
    395  28000 ????				       sty	dlend,x
    396  28000 ????
    397  28000 ????				       ifconst	ALWAYSTERMINATE
    398  28000 ????				       iny
    399  28000 ????				       lda	#0
    400  28000 ????				       sta	(dlpnt),y
    401  28000 ????				       endif
    402  28000 ????
    403  28000 ????				       bcc	.PLOTSPRITEend
    404  28000 ????
    405  28000 ????				       inx		; next zone
    406  28000 ????
    407  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  28000 ????				       sta	dlpnt
    409  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  28000 ????				       sta	dlpnt+1
    411  28000 ????
    412  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  28000 ????
    414  28000 ????				       lda	.ByteOffset
    415  28000 ????				       if	{1}_width = 1
    416  28000 ????				       clc
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 2
    419  28000 ????				       asl		; carry clear
    420  28000 ????				       endif
    421  28000 ????				       if	{1}_width = 3
    422  28000 ????				       asl		; carry clear
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       if	{1}_width = 4
    426  28000 ????				       asl		; carry clear
    427  28000 ????				       asl
    428  28000 ????				       endif
    429  28000 ????				       if	{1}_width = 5
    430  28000 ????				       asl		; carry clear
    431  28000 ????				       asl
    432  28000 ????				       adc	.ByteOffset
    433  28000 ????				       endif
    434  28000 ????				       if	{1}_width = 6
    435  28000 ????				       asl		; carry clear
    436  28000 ????				       adc	.ByteOffset
    437  28000 ????				       asl
    438  28000 ????				       endif
    439  28000 ????				       if	{1}_width = 7
    440  28000 ????				       asl		; carry clear
    441  28000 ????				       adc	.ByteOffset
    442  28000 ????				       asl
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 8
    445  28000 ????				       asl		; carry clear
    446  28000 ????				       asl
    447  28000 ????				       asl
    448  28000 ????				       endif
    449  28000 ????				       if	{1}_width = 9
    450  28000 ????				       asl		; carry clear
    451  28000 ????				       asl
    452  28000 ????				       asl
    453  28000 ????				       adc	.ByteOffset
    454  28000 ????				       endif
    455  28000 ????				       if	{1}_width = 10
    456  28000 ????				       asl		; carry clear
    457  28000 ????				       asl
    458  28000 ????				       adc	.ByteOffset
    459  28000 ????				       asl
    460  28000 ????				       endif
    461  28000 ????				       if	{1}_width = 11
    462  28000 ????				       asl		; carry clear
    463  28000 ????				       asl
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       asl
    466  28000 ????				       adc	.ByteOffset
    467  28000 ????				       endif
    468  28000 ????				       if	{1}_width = 12
    469  28000 ????				       asl		; carry clear
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       asl
    472  28000 ????				       asl
    473  28000 ????				       endif
    474  28000 ????				       if	{1}_width = 13
    475  28000 ????				       asl		; carry clear
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       asl
    478  28000 ????				       asl
    479  28000 ????				       adc	.ByteOffset
    480  28000 ????				       endif
    481  28000 ????				       if	{1}_width = 14
    482  28000 ????				       asl		; carry clear
    483  28000 ????				       adc	.ByteOffset
    484  28000 ????				       asl
    485  28000 ????				       adc	.ByteOffset
    486  28000 ????				       asl
    487  28000 ????				       endif
    488  28000 ????
    489  28000 ????				       adc	#<.GFXLabel
    490  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  28000 ????
    492  28000 ????				       iny
    493  28000 ????
    494  28000 ????				       lda	#({1}_mode | %01000000)
    495  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  28000 ????
    497  28000 ????				       iny
    498  28000 ????
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       and	#(WZONEHEIGHT - 1)
    501  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  28000 ????
    504  28000 ????				       iny
    505  28000 ????
    506  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  28000 ????
    509  28000 ????				       iny
    510  28000 ????
    511  28000 ????				       lda	.SpriteX
    512  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  28000 ????
    514  28000 ????				       iny
    515  28000 ????				       sty	dlend,x
    516  28000 ????
    517  28000 ????				       ifconst	ALWAYSTERMINATE
    518  28000 ????				       iny
    519  28000 ????				       lda	#0
    520  28000 ????				       sta	(dlpnt),y
    521  28000 ????				       endif
    522  28000 ????
    523  28000 ????			    .PLOTSPRITEend
    524  28000 ????				       ENDM
    525  28000 ????
    526  28000 ????				       MAC	sizeof
    527  28000 ????
    528  28000 ????						; echo's the size difference between the current address and the
    529  28000 ????						; a label that was passed as an argument. This is a quick way to
    530  28000 ????						; determine the size of a structure.
    531  28000 ????
    532  28000 ????			    .NAME      SETSTR	{1}
    533  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  28000 ????				       ENDM
    535  28000 ????
    536  28000 ????						;
    537  28000 ????						; speakjet.inc
    538  28000 ????						;
    539  28000 ????						;
    540  28000 ????						; AtariVox Speech Synth Driver
    541  28000 ????						;
    542  28000 ????						; By Alex Herbert, 2004
    543  28000 ????						;
    544  28000 ????
    545  28000 ????
    546  28000 ????
    547  28000 ????
    548  28000 ????						; Constants
    549  28000 ????
    550  28000 ????
    551  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  28000 ????
    554  28000 ????
    555  28000 ????
    556  28000 ????						; Macros
    557  28000 ????
    558  28000 ????				       mac	spkout
    559  28000 ????
    560  28000 ????						; check buffer-full status
    561  28000 ????				       lda	SWCHA
    562  28000 ????				       and	#SERIAL_RDYMASK
    563  28000 ????				       beq	.speech_done
    564  28000 ????
    565  28000 ????						; get next speech byte
    566  28000 ????				       ldy	#$00
    567  28000 ????				       lda	(speech_addr),y
    568  28000 ????
    569  28000 ????						; invert data and check for end of string
    570  28000 ????				       eor	#$ff
    571  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  28000 ????				       beq	.speech_done
    573  28000 ????				       sta	{1}
    574  28000 ????
    575  28000 ????						; increment speech pointer
    576  28000 ????				       inc	speech_addr
    577  28000 ????				       bne	.incaddr_skip
    578  28000 ????				       inc	speech_addr+1
    579  28000 ????			    .incaddr_skip
    580  28000 ????
    581  28000 ????						; output byte as serial data
    582  28000 ????
    583  28000 ????				       sec		; start bit
    584  28000 ????			    .byteout_loop
    585  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  28000 ????				       lda	SWACNT	; 4
    587  28000 ????				       and	#$fe	; 2 6
    588  28000 ????				       adc	#$00	; 2 8
    589  28000 ????				       sta	SWACNT	; 4 12
    590  28000 ????
    591  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  28000 ????				       cpy	#$09	; 2 14
    593  28000 ????				       beq	.speech_done	; 2 16
    594  28000 ????				       iny		; 2 18
    595  28000 ????
    596  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  28000 ????						; to match the original baud rate...
    598  28000 ????						;ldx	  #$07 ; 2600
    599  28000 ????				       ldx	#$0D
    600  28000 ????
    601  28000 ????			    .delay_loop
    602  28000 ????				       dex		; 
    603  28000 ????				       bne	.delay_loop	; 36 54
    604  28000 ????
    605  28000 ????						; shift next data bit into carry
    606  28000 ????				       lsr	{1}	; 5 59
    607  28000 ????
    608  28000 ????						; and loop (branch always taken)
    609  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  28000 ????
    611  28000 ????			    .speech_done
    612  28000 ????
    613  28000 ????				       endm
    614  28000 ????
    615  28000 ????
    616  28000 ????				       mac	speak
    617  28000 ????
    618  28000 ????				       lda	#<{1}
    619  28000 ????				       sta	speech_addr
    620  28000 ????				       lda	#>{1}
    621  28000 ????				       sta	speech_addr+1
    622  28000 ????
    623  28000 ????				       endm
    624  28000 ????
    625  28000 ????
    626  28000 ????
    627  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  28000 ????
    629  28000 ????				       processor	6502
    630  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????
    123  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 80	    title01_mode =	$80
      4  28000 ????		00 10	    title01_width_twoscompliment =	$10
      5  28000 ????		00 30	    title01_width =	$30
      6  28000 ????		00 80	    title00_mode =	$80
      7  28000 ????		00 10	    title00_width_twoscompliment =	$10
      8  28000 ????		00 30	    title00_width =	$30
      9  28000 ????		00 00	    player4_mode =	$00
     10  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
     11  28000 ????		00 04	    player4_width =	$04
     12  28000 ????		00 00	    player3_mode =	$00
     13  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
     14  28000 ????		00 04	    player3_width =	$04
     15  28000 ????		00 00	    player2_mode =	$00
     16  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     17  28000 ????		00 04	    player2_width =	$04
     18  28000 ????		00 00	    player1_mode =	$00
     19  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     20  28000 ????		00 04	    player1_width =	$04
     21  28000 ????		00 00	    font_mode  =	$00
     22  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     23  28000 ????		00 35	    font_width =	$35
     24  28000 ????		01 48	    playerAnimWait =	var8
     25  28000 ????
     26  28000 ????		01 47	    playerAnimFrame =	var7
     27  28000 ????
     28  28000 ????		01 46	    playerY    =	var6
     29  28000 ????
     30  28000 ????		01 45	    playerX    =	var5
     31  28000 ????
     32  28000 ????		01 44	    score      =	var4
     33  28000 ????
     34  28000 ????		01 43	    lives      =	var3
     35  28000 ????
     36  28000 ????		01 42	    wait       =	var2
     37  28000 ????
     38  28000 ????		01 41	    bgColor    =	var1
     39  28000 ????
     40  28000 ????		00 a8	    title_color12 =	title00_color12
     41  28000 ????		00 a9	    title_color11 =	title00_color11
     42  28000 ????		00 a7	    title_color10 =	title00_color10
     43  28000 ????		00 a4	    title_color9 =	title00_color9
     44  28000 ????		00 93	    title_color8 =	title00_color8
     45  28000 ????		00 ab	    title_color7 =	title00_color7
     46  28000 ????		00 92	    title_color6 =	title00_color6
     47  28000 ????		00 aa	    title_color5 =	title00_color5
     48  28000 ????		00 91	    title_color4 =	title00_color4
     49  28000 ????		00 a6	    title_color3 =	title00_color3
     50  28000 ????		00 a5	    title_color2 =	title00_color2
     51  28000 ????		00 91	    title_color1 =	title00_color1
     52  28000 ????		00 00	    title01_color15 =	0
     53  28000 ????		00 00	    title01_color14 =	0
     54  28000 ????		00 00	    title01_color13 =	0
     55  28000 ????		00 a8	    title01_color12 =	$a8
     56  28000 ????		00 a9	    title01_color11 =	$a9
     57  28000 ????		00 a7	    title01_color10 =	$a7
     58  28000 ????		00 a4	    title01_color9 =	$a4
     59  28000 ????		00 93	    title01_color8 =	$93
     60  28000 ????		00 ab	    title01_color7 =	$ab
     61  28000 ????		00 92	    title01_color6 =	$92
     62  28000 ????		00 aa	    title01_color5 =	$aa
     63  28000 ????		00 91	    title01_color4 =	$91
     64  28000 ????		00 a6	    title01_color3 =	$a6
     65  28000 ????		00 a5	    title01_color2 =	$a5
     66  28000 ????		00 91	    title01_color1 =	$91
     67  28000 ????		00 00	    title01_color0 =	$00
     68  28000 ????		00 00	    title00_color15 =	0
     69  28000 ????		00 00	    title00_color14 =	0
     70  28000 ????		00 00	    title00_color13 =	0
     71  28000 ????		00 a8	    title00_color12 =	$a8
     72  28000 ????		00 a9	    title00_color11 =	$a9
     73  28000 ????		00 a7	    title00_color10 =	$a7
     74  28000 ????		00 a4	    title00_color9 =	$a4
     75  28000 ????		00 93	    title00_color8 =	$93
     76  28000 ????		00 ab	    title00_color7 =	$ab
     77  28000 ????		00 92	    title00_color6 =	$92
     78  28000 ????		00 aa	    title00_color5 =	$aa
     79  28000 ????		00 91	    title00_color4 =	$91
     80  28000 ????		00 a6	    title00_color3 =	$a6
     81  28000 ????		00 a5	    title00_color2 =	$a5
     82  28000 ????		00 91	    title00_color1 =	$91
     83  28000 ????		00 00	    title00_color0 =	$00
     84  28000 ????		00 00	    player4_color3 =	0
     85  28000 ????		00 44	    player4_color2 =	$44
     86  28000 ????		00 0d	    player4_color1 =	$0d
     87  28000 ????		00 00	    player4_color0 =	$00
     88  28000 ????		00 07	    player3_color3 =	$07
     89  28000 ????		00 44	    player3_color2 =	$44
     90  28000 ????		00 0d	    player3_color1 =	$0d
     91  28000 ????		00 00	    player3_color0 =	$00
     92  28000 ????		00 07	    player2_color3 =	$07
     93  28000 ????		00 44	    player2_color2 =	$44
     94  28000 ????		00 0d	    player2_color1 =	$0d
     95  28000 ????		00 00	    player2_color0 =	$00
     96  28000 ????		00 07	    player1_color3 =	$07
     97  28000 ????		00 44	    player1_color2 =	$44
     98  28000 ????		00 0d	    player1_color1 =	$0d
     99  28000 ????		00 00	    player1_color0 =	$00
    100  28000 ????		00 0f	    font_color1 =	$0f
    101  28000 ????		00 00	    font_color0 =	$00
    102  28000 ????		00 01	    DOUBLEBUFFER =	1
    103  28000 ????		00 01	    SGRAM      =	1
    104  28000 ????		00 08	    bankswitchmode =	8
    105  28000 ????		00 01	    ROM128K    =	1
    106  28000 ????		00 01	    plotvalueonscreen =	1
    107  28000 ????		00 10	    ZONEHEIGHT =	16
    108  28000 ????		00 01	    collisionwrap =	1
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    sSWCHA     =	$2131
     63  28000 ????						; reserved	 = $2132
     64  28000 ????
     65  28000 ????		21 33	    hsdisplaymode =	$2133
     66  28000 ????		21 34	    gamedifficulty =	$2134
     67  28000 ????		21 35	    hsinitialpos =	$2135
     68  28000 ????		21 36	    hsinitialhold =	$2136
     69  28000 ????		21 37	    hscursorx  =	$2137
     70  28000 ????		21 38	    hsjoydebounce =	$2138
     71  28000 ????		21 39	    hsswcha    =	$2139
     72  28000 ????		21 3a	    hsinpt1    =	$213A
     73  28000 ????		21 3b	    hscolorchaseindex =	$213B
     74  28000 ????		21 3c	    visibleDLLstart =	$213C
     75  28000 ????		21 3d	    overscanDLLstart =	$213D
     76  28000 ????		21 3e	    frameslost =	$213E
     77  28000 ????		21 3f	    hsreturn   =	$213F
     78  28000 ????
     79  28000 ????
     80  28000 ????		00 40	    rand       =	$40
     81  28000 ????		00 41	    rand16     =	$41
     82  28000 ????		00 42	    temp1      =	$42
     83  28000 ????		00 43	    temp2      =	$43
     84  28000 ????		00 44	    temp3      =	$44
     85  28000 ????		00 45	    temp4      =	$45
     86  28000 ????		00 46	    temp5      =	$46
     87  28000 ????		00 47	    temp6      =	$47
     88  28000 ????		00 48	    temp7      =	$48
     89  28000 ????		00 49	    temp8      =	$49
     90  28000 ????		00 4a	    temp9      =	$4a
     91  28000 ????
     92  28000 ????		00 4b	    pokeybase  =	$4b
     93  28000 ????		00 4b	    pokeybaselo =	$4b
     94  28000 ????		00 4c	    pokeybasehi =	$4c
     95  28000 ????
     96  28000 ????		00 4d	    visibleover =	$4d
     97  28000 ????
     98  28000 ????		00 4e	    sfx1pointlo =	$4e
     99  28000 ????		00 4f	    sfx2pointlo =	$4f
    100  28000 ????		00 50	    sfx1pointhi =	$50
    101  28000 ????		00 51	    sfx2pointhi =	$51
    102  28000 ????
    103  28000 ????		00 52	    sfx1priority =	$52
    104  28000 ????		00 53	    sfx2priority =	$53
    105  28000 ????		00 54	    sfx1poffset =	$54
    106  28000 ????		00 55	    sfx2poffset =	$55
    107  28000 ????
    108  28000 ????		00 56	    sfx1frames =	$56
    109  28000 ????		00 57	    sfx2frames =	$57
    110  28000 ????		00 58	    sfx1tick   =	$58
    111  28000 ????		00 59	    sfx2tick   =	$59
    112  28000 ????
    113  28000 ????		00 5a	    tempmath   =	$5a
    114  28000 ????
    115  28000 ????		00 5b	    pokey1pointlo =	$5b
    116  28000 ????		00 5c	    pokey1pointhi =	$5c
    117  28000 ????		00 5d	    pokey2pointlo =	$5d
    118  28000 ????		00 5e	    pokey2pointhi =	$5e
    119  28000 ????		00 5f	    pokey3pointlo =	$5f
    120  28000 ????		00 60	    pokey3pointhi =	$60
    121  28000 ????		00 61	    pokey4pointlo =	$61
    122  28000 ????		00 62	    pokey4pointhi =	$62
    123  28000 ????
    124  28000 ????		00 63	    dlpnt      =	$63	; to $64
    125  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    126  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    127  28000 ????
    128  28000 ????		00 9f	    speech_addr =	$9f
    129  28000 ????		00 a0	    speech_addr_hi =	$a0
    130  28000 ????
    131  28000 ????		00 a1	    HSGameTableLo =	$a1
    132  28000 ????		00 a2	    HSGameTableHi =	$a2
    133  28000 ????		00 a3	    HSVoxHi    =	$a3
    134  28000 ????		00 a4	    HSVoxLo    =	$a4
    135  28000 ????
    136  28000 ????						;channel pointers
    137  28000 ????
    138  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    139  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    140  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    141  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    142  28000 ????
    143  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    144  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    145  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    146  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    147  28000 ????
    148  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    149  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    150  28000 ????		00 af	    songchannel3layer3lo =	$aF
    151  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    152  28000 ????
    153  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    154  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    155  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    156  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    157  28000 ????
    158  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    159  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    160  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    161  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    162  28000 ????
    163  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    164  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    165  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    166  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    167  28000 ????
    168  28000 ????		00 bd	    songdatalo =	$bd
    169  28000 ????		00 be	    songdatahi =	$be
    170  28000 ????
    171  28000 ????		00 bf	    inactivechannelcount =	$bf
    172  28000 ????
    173  28000 ????		00 c0	    songchannel1transpose =	$c0
    174  28000 ????		00 c1	    songchannel2transpose =	$c1
    175  28000 ????		00 c2	    songchannel3transpose =	$c2
    176  28000 ????		00 c3	    songchannel4transpose =	$c3
    177  28000 ????
    178  28000 ????		00 c4	    songstackindex =	$c4
    179  28000 ????
    180  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    181  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    182  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    183  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    184  28000 ????
    185  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    186  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    187  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    188  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    189  28000 ????
    190  28000 ????		00 cd	    sfx1notedata =	$cd
    191  28000 ????		00 ce	    sfx2notedata =	$ce
    192  28000 ????
    193  28000 ????		00 cf	    songloops  =	$cf
    194  28000 ????
    195  28000 ????		00 d0	    songpointerlo =	$D0
    196  28000 ????		00 d1	    songpointerhi =	$D1
    197  28000 ????
    198  28000 ????		00 d2	    voxlock    =	$D2
    199  28000 ????		00 d3	    voxqueuesize =	$D3
    200  28000 ????
    201  28000 ????		00 d4	    vblankroutines =	$D4
    202  28000 ????
    203  28000 ????		00 d5	    doublebufferstate =	$D5
    204  28000 ????		00 d6	    doublebufferdloffset =	$D6
    205  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    206  28000 ????
    207  28000 ????		00 d8	    inttemp1   =	$D8
    208  28000 ????		00 d9	    inttemp2   =	$D9
    209  28000 ????		00 da	    inttemp3   =	$DA
    210  28000 ????		00 db	    inttemp4   =	$DB
    211  28000 ????		00 dc	    inttemp5   =	$DC
    212  28000 ????		00 dd	    inttemp6   =	$DD
    213  28000 ????
    214  28000 ????		00 de	    sfxschedulelock =	$DE
    215  28000 ????		00 df	    sfxschedulemissed =	$DF
    216  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    217  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    218  28000 ????		00 e2	    sfxpitchoffset =	$E2
    219  28000 ????		00 e3	    sfxnoteindex =	$E3
    220  28000 ????
    221  28000 ????						; reserved = $E4
    222  28000 ????						; reserved = $E5
    223  28000 ????
    224  28000 ????		00 e6	    A	       =	$e6
    225  28000 ????		00 e6	    a	       =	$e6
    226  28000 ????		00 e7	    B	       =	$e7
    227  28000 ????		00 e7	    b	       =	$e7
    228  28000 ????		00 e8	    C	       =	$e8
    229  28000 ????		00 e8	    c	       =	$e8
    230  28000 ????		00 e9	    D	       =	$e9
    231  28000 ????		00 e9	    d	       =	$e9
    232  28000 ????		00 ea	    E	       =	$ea
    233  28000 ????		00 ea	    e	       =	$ea
    234  28000 ????		00 eb	    F	       =	$eb
    235  28000 ????		00 eb	    f	       =	$eb
    236  28000 ????		00 ec	    G	       =	$ec
    237  28000 ????		00 ec	    g	       =	$ec
    238  28000 ????		00 ed	    H	       =	$ed
    239  28000 ????		00 ed	    h	       =	$ed
    240  28000 ????		00 ee	    I	       =	$ee
    241  28000 ????		00 ee	    i	       =	$ee
    242  28000 ????		00 ef	    J	       =	$ef
    243  28000 ????		00 ef	    j	       =	$ef
    244  28000 ????		00 f0	    K	       =	$f0
    245  28000 ????		00 f0	    k	       =	$f0
    246  28000 ????		00 f1	    L	       =	$f1
    247  28000 ????		00 f1	    l	       =	$f1
    248  28000 ????		00 f2	    M	       =	$f2
    249  28000 ????		00 f2	    m	       =	$f2
    250  28000 ????		00 f3	    N	       =	$f3
    251  28000 ????		00 f3	    n	       =	$f3
    252  28000 ????		00 f4	    O	       =	$f4
    253  28000 ????		00 f4	    o	       =	$f4
    254  28000 ????		00 f5	    P	       =	$f5
    255  28000 ????		00 f5	    p	       =	$f5
    256  28000 ????		00 f6	    Q	       =	$f6
    257  28000 ????		00 f6	    q	       =	$f6
    258  28000 ????		00 f7	    R	       =	$f7
    259  28000 ????		00 f7	    r	       =	$f7
    260  28000 ????		00 f8	    S	       =	$f8
    261  28000 ????		00 f8	    s	       =	$f8
    262  28000 ????		00 f9	    T	       =	$f9
    263  28000 ????		00 f9	    t	       =	$f9
    264  28000 ????		00 fa	    U	       =	$fa
    265  28000 ????		00 fa	    u	       =	$fa
    266  28000 ????		00 fb	    V	       =	$fb
    267  28000 ????		00 fb	    v	       =	$fb
    268  28000 ????		00 fc	    W	       =	$fc
    269  28000 ????		00 fc	    w	       =	$fc
    270  28000 ????		00 fd	    X	       =	$fd
    271  28000 ????		00 fd	    x	       =	$fd
    272  28000 ????		00 fe	    Y	       =	$fe
    273  28000 ????		00 fe	    y	       =	$fe
    274  28000 ????		00 ff	    Z	       =	$ff
    275  28000 ????		00 ff	    z	       =	$ff
    276  28000 ????
    277  28000 ????						; var0-var99 variables use the top of the stack
    278  28000 ????		01 40	    var0       =	$140
    279  28000 ????		01 41	    var1       =	$141
    280  28000 ????		01 42	    var2       =	$142
    281  28000 ????		01 43	    var3       =	$143
    282  28000 ????		01 44	    var4       =	$144
    283  28000 ????		01 45	    var5       =	$145
    284  28000 ????		01 46	    var6       =	$146
    285  28000 ????		01 47	    var7       =	$147
    286  28000 ????		01 48	    var8       =	$148
    287  28000 ????		01 49	    var9       =	$149
    288  28000 ????		01 4a	    var10      =	$14a
    289  28000 ????		01 4b	    var11      =	$14b
    290  28000 ????		01 4c	    var12      =	$14c
    291  28000 ????		01 4d	    var13      =	$14d
    292  28000 ????		01 4e	    var14      =	$14e
    293  28000 ????		01 4f	    var15      =	$14f
    294  28000 ????		01 50	    var16      =	$150
    295  28000 ????		01 51	    var17      =	$151
    296  28000 ????		01 52	    var18      =	$152
    297  28000 ????		01 53	    var19      =	$153
    298  28000 ????		01 54	    var20      =	$154
    299  28000 ????		01 55	    var21      =	$155
    300  28000 ????		01 56	    var22      =	$156
    301  28000 ????		01 57	    var23      =	$157
    302  28000 ????		01 58	    var24      =	$158
    303  28000 ????		01 59	    var25      =	$159
    304  28000 ????		01 5a	    var26      =	$15a
    305  28000 ????		01 5b	    var27      =	$15b
    306  28000 ????		01 5c	    var28      =	$15c
    307  28000 ????		01 5d	    var29      =	$15d
    308  28000 ????		01 5e	    var30      =	$15e
    309  28000 ????		01 5f	    var31      =	$15f
    310  28000 ????		01 60	    var32      =	$160
    311  28000 ????		01 61	    var33      =	$161
    312  28000 ????		01 62	    var34      =	$162
    313  28000 ????		01 63	    var35      =	$163
    314  28000 ????		01 64	    var36      =	$164
    315  28000 ????		01 65	    var37      =	$165
    316  28000 ????		01 66	    var38      =	$166
    317  28000 ????		01 67	    var39      =	$167
    318  28000 ????		01 68	    var40      =	$168
    319  28000 ????		01 69	    var41      =	$169
    320  28000 ????		01 6a	    var42      =	$16a
    321  28000 ????		01 6b	    var43      =	$16b
    322  28000 ????		01 6c	    var44      =	$16c
    323  28000 ????		01 6d	    var45      =	$16d
    324  28000 ????		01 6e	    var46      =	$16e
    325  28000 ????		01 6f	    var47      =	$16f
    326  28000 ????		01 70	    var48      =	$170
    327  28000 ????		01 71	    var49      =	$171
    328  28000 ????		01 72	    var50      =	$172
    329  28000 ????		01 73	    var51      =	$173
    330  28000 ????		01 74	    var52      =	$174
    331  28000 ????		01 75	    var53      =	$175
    332  28000 ????		01 76	    var54      =	$176
    333  28000 ????		01 77	    var55      =	$177
    334  28000 ????		01 78	    var56      =	$178
    335  28000 ????		01 79	    var57      =	$179
    336  28000 ????		01 7a	    var58      =	$17a
    337  28000 ????		01 7b	    var59      =	$17b
    338  28000 ????		01 7c	    var60      =	$17c
    339  28000 ????		01 7d	    var61      =	$17d
    340  28000 ????		01 7e	    var62      =	$17e
    341  28000 ????		01 7f	    var63      =	$17f
    342  28000 ????		01 80	    var64      =	$180
    343  28000 ????		01 81	    var65      =	$181
    344  28000 ????		01 82	    var66      =	$182
    345  28000 ????		01 83	    var67      =	$183
    346  28000 ????		01 84	    var68      =	$184
    347  28000 ????		01 85	    var69      =	$185
    348  28000 ????		01 86	    var70      =	$186
    349  28000 ????		01 87	    var71      =	$187
    350  28000 ????		01 88	    var72      =	$188
    351  28000 ????		01 89	    var73      =	$189
    352  28000 ????		01 8a	    var74      =	$18a
    353  28000 ????		01 8b	    var75      =	$18b
    354  28000 ????		01 8c	    var76      =	$18c
    355  28000 ????		01 8d	    var77      =	$18d
    356  28000 ????		01 8e	    var78      =	$18e
    357  28000 ????		01 8f	    var79      =	$18f
    358  28000 ????		01 90	    var80      =	$190
    359  28000 ????		01 91	    var81      =	$191
    360  28000 ????		01 92	    var82      =	$192
    361  28000 ????		01 93	    var83      =	$193
    362  28000 ????		01 94	    var84      =	$194
    363  28000 ????		01 95	    var85      =	$195
    364  28000 ????		01 96	    var86      =	$196
    365  28000 ????		01 97	    var87      =	$197
    366  28000 ????		01 98	    var88      =	$198
    367  28000 ????		01 99	    var89      =	$199
    368  28000 ????		01 9a	    var90      =	$19a
    369  28000 ????		01 9b	    var91      =	$19b
    370  28000 ????		01 9c	    var92      =	$19c
    371  28000 ????		01 9d	    var93      =	$19d
    372  28000 ????		01 9e	    var94      =	$19e
    373  28000 ????		01 9f	    var95      =	$19f
    374  28000 ????		01 a0	    var96      =	$1a0
    375  28000 ????		01 a1	    var97      =	$1a1
    376  28000 ????		01 a2	    var98      =	$1a2
    377  28000 ????		01 a3	    var99      =	$1a3
    378  28000 ????
    379 U01c5 ????				      SEG.U	"7800basicRAM"
    380 U01a4					      ORG	$1A4
    381 U01a4
    382 U01a4							; MAX allocation locations are in comments...
    383 U01a4		       00	   framecounter DS	1	; $1A4
    384 U01a5		       00	   countdownseconds DS	1	; $1A5
    385 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    386 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    387 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    388 U01ad		       00	   valbufend  DS	1	; $1AD
    389 U01ae		       00	   valbufendsave DS	1	; $1AE
    390 U01af		       00	   finescrollx DS	1	; $1AF
    391 U01b0		       00	   finescrolly DS	1	; $1B0
    392 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    393 U01b2		       00	   interruptindex DS	1	; $1B2
    394 U01b3
    395 U01b3					      ifconst	DOUBLEBUFFER
    396 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    397 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    398 U01b5					      endif
    399 U01b5
    400 U01b5		       00	   pausedisable DS	1	; $1B5
    401 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    402 U01b7
    403 U01b7				  -	      ifconst	AVOXVOICE
    404 U01b7				  -avoxenable DS	1	; $1B7
    405 U01b7				  -tempavox   DS	1	; $1B8
    406 U01b7					      endif
    407 U01b7
    408 U01b7				  -	      ifconst	MUSICTRACKER
    409 U01b7				  -songtempo  DS	1	; $1B9
    410 U01b7				  -songtick   DS	1	; $1BA
    411 U01b7				  -
    412 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    413 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    414 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    415 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    416 U01b7				  -
    417 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    418 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    419 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    420 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    421 U01b7				  -
    422 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    423 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    424 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    425 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    426 U01b7				  -
    427 U01b7				  -songchannel1busywait DS	1	; $1C7
    428 U01b7				  -songchannel2busywait DS	1	; $1C8
    429 U01b7				  -songchannel3busywait DS	1	; $1C9
    430 U01b7				  -songchannel4busywait DS	1	; $1CA
    431 U01b7				  -
    432 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    433 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    434 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    435 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    436 U01b7					      endif
    437 U01b7
    438 U01b7		       00	   palframes  DS	1
    439 U01b8		       00	   ntscslowframe DS	1
    440 U01b9		       00	   palfastframe DS	1
    441 U01ba
    442 U01ba				  -	      ifconst	MOUSESUPPORT
    443 U01ba				  -port0resolution DS	1
    444 U01ba				  -port1resolution DS	1
    445 U01ba					      else
    446 U01ba				  -	      ifconst	TRAKBALLSUPPORT
    447 U01ba				  -port0resolution DS	1
    448 U01ba				  -port1resolution DS	1
    449 U01ba					      endif
    450 U01ba					      endif
    451 U01ba
    452 U01ba		       00	   port0control DS	1
    453 U01bb		       00	   port1control DS	1
    454 U01bc
    455 U01bc							; port#control values...
    456 U01bc							;	1 = proline
    457 U01bc							;	2 = lightgun
    458 U01bc							;	3 = paddle
    459 U01bc							;	4 = trakball
    460 U01bc							;	5 = vcs joystick
    461 U01bc							;	6 = driving
    462 U01bc							;	7 = keypad
    463 U01bc							;	8 = st mouse/cx80
    464 U01bc							;	9 = amiga mouse
    465 U01bc							;     10 = atarivox
    466 U01bc
    467 U01bc							; controller 0 data...
    468 U01bc		       00	   paddleposition0 DS	1
    469 U01bc		       01 bc	   keypadmatrix0a =	paddleposition0
    470 U01bc		       01 bc	   drivingposition0 =	paddleposition0
    471 U01bc		       01 bc	   trakballx0 =	paddleposition0
    472 U01bc		       01 bc	   mousex0    =	paddleposition0
    473 U01bc		       01 bc	   lighttgunx0 =	paddleposition0
    474 U01bc		       01 bc	   snes2atari0lo =	paddleposition0
    475 U01bc		       01 bc	   mega7800data0 =	paddleposition0
    476 U01bd
    477 U01bd							; controller 1 data...
    478 U01bd		       00	   paddleposition2 DS	1
    479 U01bd		       01 bd	   keypadmatrix1a =	paddleposition2
    480 U01bd		       01 bd	   drivingposition1 =	paddleposition2
    481 U01bd		       01 bd	   trakballx1 =	paddleposition2
    482 U01bd		       01 bd	   mousex1    =	paddleposition2
    483 U01bd		       01 bd	   lightgunx1 =	paddleposition2
    484 U01bd		       01 bd	   snes2atari1lo =	paddleposition2
    485 U01bd		       01 bd	   mega7800data1 =	paddleposition2
    486 U01be
    487 U01be							; controller 0 altdata...
    488 U01be		       00	   paddleposition1 DS	1
    489 U01be		       01 be	   keypadmatrix0b =	paddleposition1
    490 U01be		       01 be	   trakbally0 =	paddleposition1
    491 U01be		       01 be	   mousey0    =	paddleposition1
    492 U01be		       01 be	   lightguny0 =	paddleposition1
    493 U01be		       01 be	   snes2atari0hi =	paddleposition1
    494 U01be		       01 be	   mega7800state0 =	paddleposition1
    495 U01bf
    496 U01bf							; controller 1 altdata...
    497 U01bf		       00	   paddleposition3 DS	1
    498 U01bf		       01 bf	   keypadmatrix1b =	paddleposition3
    499 U01bf		       01 bf	   trakbally1 =	paddleposition3
    500 U01bf		       01 bf	   mousey1    =	paddleposition3
    501 U01bf		       01 bf	   lightguny1 =	paddleposition3
    502 U01bf		       01 bf	   snes2atari1hi =	paddleposition3
    503 U01bf		       01 bf	   mega7800state1 =	paddleposition3
    504 U01c0
    505 U01c0							; controller state save. for trakball state+dir codes, rotary position codes
    506 U01c0		       00	   controller0statesave DS	1
    507 U01c0		       01 c0	   paddleprevious0 =	controller0statesave
    508 U01c0		       01 c0	   mousecodex0 =	controller0statesave
    509 U01c0		       01 c0	   trakballcodex0 =	controller0statesave
    510 U01c0		       01 c0	   keypadmatrix0c =	controller0statesave
    511 U01c0		       01 c0	   snesdetected0 =	controller0statesave
    512 U01c1
    513 U01c1		       00	   controller1statesave DS	1
    514 U01c1		       01 c1	   paddleprevious2 =	controller1statesave
    515 U01c1		       01 c1	   mousecodex1 =	controller1statesave
    516 U01c1		       01 c1	   trakballcodex1 =	controller1statesave
    517 U01c1		       01 c1	   keypadmatrix1c =	controller1statesave
    518 U01c1		       01 c1	   snesdetected1 =	controller1statesave
    519 U01c2
    520 U01c2		       00	   paddleprevious1 DS	1
    521 U01c2		       01 c2	   keypadmatrix0d =	paddleprevious1
    522 U01c2		       01 c2	   mousecodey0 =	paddleprevious1
    523 U01c2		       01 c2	   trakballcodey0 =	paddleprevious1
    524 U01c3
    525 U01c3		       00	   paddleprevious3 DS	1
    526 U01c3		       01 c3	   keypadmatrix1d =	paddleprevious3
    527 U01c3		       01 c3	   mousecodey1 =	paddleprevious3
    528 U01c3		       01 c3	   trakballcodey1 =	paddleprevious3
    529 U01c4
    530 U01c4				  -	      ifconst	pokeysupport
    531 U01c4				  -pokey1frames DS	1
    532 U01c4				  -pokey1tick DS	1
    533 U01c4				  -pokey2frames DS	1
    534 U01c4				  -pokey2tick DS	1
    535 U01c4				  -pokey3frames DS	1
    536 U01c4				  -pokey3tick DS	1
    537 U01c4				  -pokey4frames DS	1
    538 U01c4				  -pokey4tick DS	1
    539 U01c4				  -pokey1priority DS	1
    540 U01c4				  -pokey1offset DS	1
    541 U01c4				  -pokey2priority DS	1
    542 U01c4				  -pokey2offset DS	1
    543 U01c4				  -pokey3priority DS	1
    544 U01c4				  -pokey3offset DS	1
    545 U01c4				  -pokey4priority DS	1
    546 U01c4				  -pokey4offset DS	1
    547 U01c4					      endif
    548 U01c4
    549 U01c4				  -	      ifconst	pokeykeysupport
    550 U01c4				  -pokeylastkeycode DS	1
    551 U01c4				  -pokeykeycode DS	1
    552 U01c4				  -pokeykeydebounce DS	1
    553 U01c4					      endif
    554 U01c4
    555 U01c4				  -	      ifconst	RMT
    556 U01c4				  -rasterpause DS	1
    557 U01c4					      endif		; RMT
    558 U01c4				  -	      ifconst	RMTVOLUME
    559 U01c4				  -rmtvolume  DS	1
    560 U01c4					      endif		; RMTVOLUME
    561 U01c4				  -	      ifconst	TIAVOLUME
    562 U01c4				  -tiavolume  DS	1
    563 U01c4					      endif		; TIAVOLUME
    564 U01c4
    565 U01c4				  -	      ifconst	FOURBITFADE
    566 U01c4				  -fourbittemp1 DS	1
    567 U01c4				  -fourbitfadevalue DS	1
    568 U01c4				  -fourbittemp1int DS	1
    569 U01c4				  -fourbitfadevalueint DS	1
    570 U01c4					      endif		; FOURBITFADE
    571 U01c4
    572 U01c4				  -	      ifconst	SNES2ATARISUPPORT
    573 U01c4				  -snesport   DS	1
    574 U01c4					      endif		; SNES2ATARISUPPORT
    575 U01c4
    576 U01c4				  -	      ifconst	KEYPADSUPPORT
    577 U01c4				  -keypadcounter DS	1
    578 U01c4					      endif
    579 U01c4
    580 U01c4				  -	      ifconst	MULTIBUTTON
    581 U01c4				  -multibuttoncount0 DS	1
    582 U01c4				  -multibuttoncount1 DS	1
    583 U01c4					      endif
    584 U01c4
    585 U01c4							; see if we need an interrupthold byte...
    586 U01c4				   INTERRUPTNEEDED SET	0
    587 U01c4				  -	      ifconst	.topscreenroutine
    588 U01c4				  -INTERRUPTNEEDED SET	1
    589 U01c4					      endif
    590 U01c4				  -	      ifconst	.bottomscreenroutine
    591 U01c4				  -INTERRUPTNEEDED SET	1
    592 U01c4					      endif
    593 U01c4				  -	      ifconst	.userinterrupt
    594 U01c4				  -INTERRUPTNEEDED SET	1
    595 U01c4					      endif
    596 U01c4				  -	      if	INTERRUPTNEEDED = 1
    597 U01c4				  -interrupthold DS	1
    598 U01c4					      endif
    599 U01c4
    600 U01c4					      ifnconst	CANARYOFF
    601 U01c4		       00	   canary     DS	1
    602 U01c5					      endif
    603 U01c5
    604 U01c5				  -	      ifnconst	bankswitchmode
    605 U01c5				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    606 U01c5					      else
   stack allowance: 19 nested subroutines.
    607 U01c5					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    608 U01c5					      endif
    609 U01c5					      ifnconst	CANARYOFF
   the canary is situated at: $1c4
    610 U01c5					      echo	"  the canary is situated at:",[canary]
    611 U01c5				  -	      else
    612 U01c5				  -	      echo	"  the canary is disabled."
    613 U01c5					      endif
    614 U01c5
    615 U01c5							; $1EE - $1FF reserved for stack
    616 U01c5
    617  28000 ????				       SEG	"GAME"
    618  28000 ????
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
------- FILE 7800_extravars.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800_extravars.h"
      1  28000 ????		22 00	    var100     =	$2200
      2  28000 ????		22 01	    var101     =	$2201
      3  28000 ????		22 02	    var102     =	$2202
      4  28000 ????		22 03	    var103     =	$2203
      5  28000 ????		22 04	    var104     =	$2204
      6  28000 ????		22 05	    var105     =	$2205
      7  28000 ????		22 06	    var106     =	$2206
      8  28000 ????		22 07	    var107     =	$2207
      9  28000 ????		22 08	    var108     =	$2208
     10  28000 ????		22 09	    var109     =	$2209
     11  28000 ????		22 0a	    var110     =	$220A
     12  28000 ????		22 0b	    var111     =	$220B
     13  28000 ????		22 0c	    var112     =	$220C
     14  28000 ????		22 0d	    var113     =	$220D
     15  28000 ????		22 0e	    var114     =	$220E
     16  28000 ????		22 0f	    var115     =	$220F
     17  28000 ????		22 10	    var116     =	$2210
     18  28000 ????		22 11	    var117     =	$2211
     19  28000 ????		22 12	    var118     =	$2212
     20  28000 ????		22 13	    var119     =	$2213
     21  28000 ????		22 14	    var120     =	$2214
     22  28000 ????		22 15	    var121     =	$2215
     23  28000 ????		22 16	    var122     =	$2216
     24  28000 ????		22 17	    var123     =	$2217
     25  28000 ????		22 18	    var124     =	$2218
     26  28000 ????		22 19	    var125     =	$2219
     27  28000 ????		22 1a	    var126     =	$221A
     28  28000 ????		22 1b	    var127     =	$221B
     29  28000 ????		22 1c	    var128     =	$221C
     30  28000 ????		22 1d	    var129     =	$221D
     31  28000 ????		22 1e	    var130     =	$221E
     32  28000 ????		22 1f	    var131     =	$221F
     33  28000 ????		22 20	    var132     =	$2220
     34  28000 ????		22 21	    var133     =	$2221
     35  28000 ????		22 22	    var134     =	$2222
     36  28000 ????		22 23	    var135     =	$2223
     37  28000 ????		22 24	    var136     =	$2224
     38  28000 ????		22 25	    var137     =	$2225
     39  28000 ????		22 26	    var138     =	$2226
     40  28000 ????		22 27	    var139     =	$2227
     41  28000 ????		22 28	    var140     =	$2228
     42  28000 ????		22 29	    var141     =	$2229
     43  28000 ????		22 2a	    var142     =	$222A
     44  28000 ????		22 2b	    var143     =	$222B
     45  28000 ????		22 2c	    var144     =	$222C
     46  28000 ????		22 2d	    var145     =	$222D
     47  28000 ????		22 2e	    var146     =	$222E
     48  28000 ????		22 2f	    var147     =	$222F
     49  28000 ????		22 30	    var148     =	$2230
     50  28000 ????		22 31	    var149     =	$2231
     51  28000 ????		22 32	    var150     =	$2232
     52  28000 ????		22 33	    var151     =	$2233
     53  28000 ????		22 34	    var152     =	$2234
     54  28000 ????		22 35	    var153     =	$2235
     55  28000 ????		22 36	    var154     =	$2236
     56  28000 ????		22 37	    var155     =	$2237
     57  28000 ????		22 38	    var156     =	$2238
     58  28000 ????		22 39	    var157     =	$2239
     59  28000 ????		22 3a	    var158     =	$223A
     60  28000 ????		22 3b	    var159     =	$223B
     61  28000 ????		22 3c	    var160     =	$223C
     62  28000 ????		22 3d	    var161     =	$223D
     63  28000 ????		22 3e	    var162     =	$223E
     64  28000 ????		22 3f	    var163     =	$223F
     65  28000 ????		22 40	    var164     =	$2240
     66  28000 ????		22 41	    var165     =	$2241
     67  28000 ????		22 42	    var166     =	$2242
     68  28000 ????		22 43	    var167     =	$2243
     69  28000 ????		22 44	    var168     =	$2244
     70  28000 ????		22 45	    var169     =	$2245
     71  28000 ????		22 46	    var170     =	$2246
     72  28000 ????		22 47	    var171     =	$2247
     73  28000 ????		22 48	    var172     =	$2248
     74  28000 ????		22 49	    var173     =	$2249
     75  28000 ????		22 4a	    var174     =	$224A
     76  28000 ????		22 4b	    var175     =	$224B
     77  28000 ????		22 4c	    var176     =	$224C
     78  28000 ????		22 4d	    var177     =	$224D
     79  28000 ????		22 4e	    var178     =	$224E
     80  28000 ????		22 4f	    var179     =	$224F
     81  28000 ????		22 50	    var180     =	$2250
     82  28000 ????		22 51	    var181     =	$2251
     83  28000 ????		22 52	    var182     =	$2252
     84  28000 ????		22 53	    var183     =	$2253
     85  28000 ????		22 54	    var184     =	$2254
     86  28000 ????		22 55	    var185     =	$2255
     87  28000 ????		22 56	    var186     =	$2256
     88  28000 ????		22 57	    var187     =	$2257
     89  28000 ????		22 58	    var188     =	$2258
     90  28000 ????		22 59	    var189     =	$2259
     91  28000 ????		22 5a	    var190     =	$225A
     92  28000 ????		22 5b	    var191     =	$225B
     93  28000 ????		22 5c	    var192     =	$225C
     94  28000 ????		22 5d	    var193     =	$225D
     95  28000 ????		22 5e	    var194     =	$225E
     96  28000 ????		22 5f	    var195     =	$225F
     97  28000 ????		22 60	    var196     =	$2260
     98  28000 ????		22 61	    var197     =	$2261
     99  28000 ????		22 62	    var198     =	$2262
    100  28000 ????		22 63	    var199     =	$2263
    101  28000 ????		22 64	    var200     =	$2264
    102  28000 ????		22 65	    var201     =	$2265
    103  28000 ????		22 66	    var202     =	$2266
    104  28000 ????		22 67	    var203     =	$2267
    105  28000 ????		22 68	    var204     =	$2268
    106  28000 ????		22 69	    var205     =	$2269
    107  28000 ????		22 6a	    var206     =	$226A
    108  28000 ????		22 6b	    var207     =	$226B
    109  28000 ????		22 6c	    var208     =	$226C
    110  28000 ????		22 6d	    var209     =	$226D
    111  28000 ????		22 6e	    var210     =	$226E
    112  28000 ????		22 6f	    var211     =	$226F
    113  28000 ????		22 70	    var212     =	$2270
    114  28000 ????		22 71	    var213     =	$2271
    115  28000 ????		22 72	    var214     =	$2272
    116  28000 ????		22 73	    var215     =	$2273
    117  28000 ????		22 74	    var216     =	$2274
    118  28000 ????		22 75	    var217     =	$2275
    119  28000 ????		22 76	    var218     =	$2276
    120  28000 ????		22 77	    var219     =	$2277
    121  28000 ????		22 78	    var220     =	$2278
    122  28000 ????		22 79	    var221     =	$2279
    123  28000 ????		22 7a	    var222     =	$227A
    124  28000 ????		22 7b	    var223     =	$227B
    125  28000 ????		22 7c	    var224     =	$227C
    126  28000 ????		22 7d	    var225     =	$227D
    127  28000 ????		22 7e	    var226     =	$227E
    128  28000 ????		22 7f	    var227     =	$227F
    129  28000 ????		22 80	    var228     =	$2280
    130  28000 ????		22 81	    var229     =	$2281
    131  28000 ????		22 82	    var230     =	$2282
    132  28000 ????		22 83	    var231     =	$2283
    133  28000 ????		22 84	    var232     =	$2284
    134  28000 ????		22 85	    var233     =	$2285
    135  28000 ????		22 86	    var234     =	$2286
    136  28000 ????		22 87	    var235     =	$2287
    137  28000 ????		22 88	    var236     =	$2288
    138  28000 ????		22 89	    var237     =	$2289
    139  28000 ????		22 8a	    var238     =	$228A
    140  28000 ????		22 8b	    var239     =	$228B
    141  28000 ????		22 8c	    var240     =	$228C
    142  28000 ????		22 8d	    var241     =	$228D
    143  28000 ????		22 8e	    var242     =	$228E
    144  28000 ????		22 8f	    var243     =	$228F
    145  28000 ????		22 90	    var244     =	$2290
    146  28000 ????		22 91	    var245     =	$2291
    147  28000 ????		22 92	    var246     =	$2292
    148  28000 ????		22 93	    var247     =	$2293
    149  28000 ????		22 94	    var248     =	$2294
    150  28000 ????		22 95	    var249     =	$2295
    151  28000 ????		22 96	    var250     =	$2296
    152  28000 ????		22 97	    var251     =	$2297
    153  28000 ????		22 98	    var252     =	$2298
    154  28000 ????		22 99	    var253     =	$2299
    155  28000 ????		22 9a	    var254     =	$229A
    156  28000 ????		22 9b	    var255     =	$229B
    157  28000 ????		22 9c	    var256     =	$229C
    158  28000 ????		22 9d	    var257     =	$229D
    159  28000 ????		22 9e	    var258     =	$229E
    160  28000 ????		22 9f	    var259     =	$229F
    161  28000 ????		22 a0	    var260     =	$22A0
    162  28000 ????		22 a1	    var261     =	$22A1
    163  28000 ????		22 a2	    var262     =	$22A2
    164  28000 ????		22 a3	    var263     =	$22A3
    165  28000 ????		22 a4	    var264     =	$22A4
    166  28000 ????		22 a5	    var265     =	$22A5
    167  28000 ????		22 a6	    var266     =	$22A6
    168  28000 ????		22 a7	    var267     =	$22A7
    169  28000 ????		22 a8	    var268     =	$22A8
    170  28000 ????		22 a9	    var269     =	$22A9
    171  28000 ????		22 aa	    var270     =	$22AA
    172  28000 ????		22 ab	    var271     =	$22AB
    173  28000 ????		22 ac	    var272     =	$22AC
    174  28000 ????		22 ad	    var273     =	$22AD
    175  28000 ????		22 ae	    var274     =	$22AE
    176  28000 ????		22 af	    var275     =	$22AF
    177  28000 ????		22 b0	    var276     =	$22B0
    178  28000 ????		22 b1	    var277     =	$22B1
    179  28000 ????		22 b2	    var278     =	$22B2
    180  28000 ????		22 b3	    var279     =	$22B3
    181  28000 ????		22 b4	    var280     =	$22B4
    182  28000 ????		22 b5	    var281     =	$22B5
    183  28000 ????		22 b6	    var282     =	$22B6
    184  28000 ????		22 b7	    var283     =	$22B7
    185  28000 ????		22 b8	    var284     =	$22B8
    186  28000 ????		22 b9	    var285     =	$22B9
    187  28000 ????		22 ba	    var286     =	$22BA
    188  28000 ????		22 bb	    var287     =	$22BB
    189  28000 ????		22 bc	    var288     =	$22BC
    190  28000 ????		22 bd	    var289     =	$22BD
    191  28000 ????		22 be	    var290     =	$22BE
    192  28000 ????		22 bf	    var291     =	$22BF
    193  28000 ????		22 c0	    var292     =	$22C0
    194  28000 ????		22 c1	    var293     =	$22C1
    195  28000 ????		22 c2	    var294     =	$22C2
    196  28000 ????		22 c3	    var295     =	$22C3
    197  28000 ????		22 c4	    var296     =	$22C4
    198  28000 ????		22 c5	    var297     =	$22C5
    199  28000 ????		22 c6	    var298     =	$22C6
    200  28000 ????		22 c7	    var299     =	$22C7
    201  28000 ????		22 c8	    var300     =	$22C8
    202  28000 ????		22 c9	    var301     =	$22C9
    203  28000 ????		22 ca	    var302     =	$22CA
    204  28000 ????		22 cb	    var303     =	$22CB
    205  28000 ????		22 cc	    var304     =	$22CC
    206  28000 ????		22 cd	    var305     =	$22CD
    207  28000 ????		22 ce	    var306     =	$22CE
    208  28000 ????		22 cf	    var307     =	$22CF
    209  28000 ????		22 d0	    var308     =	$22D0
    210  28000 ????		22 d1	    var309     =	$22D1
    211  28000 ????		22 d2	    var310     =	$22D2
    212  28000 ????		22 d3	    var311     =	$22D3
    213  28000 ????		22 d4	    var312     =	$22D4
    214  28000 ????		22 d5	    var313     =	$22D5
    215  28000 ????		22 d6	    var314     =	$22D6
    216  28000 ????		22 d7	    var315     =	$22D7
    217  28000 ????		22 d8	    var316     =	$22D8
    218  28000 ????		22 d9	    var317     =	$22D9
    219  28000 ????		22 da	    var318     =	$22DA
    220  28000 ????		22 db	    var319     =	$22DB
    221  28000 ????		22 dc	    var320     =	$22DC
    222  28000 ????		22 dd	    var321     =	$22DD
    223  28000 ????		22 de	    var322     =	$22DE
    224  28000 ????		22 df	    var323     =	$22DF
    225  28000 ????		22 e0	    var324     =	$22E0
    226  28000 ????		22 e1	    var325     =	$22E1
    227  28000 ????		22 e2	    var326     =	$22E2
    228  28000 ????		22 e3	    var327     =	$22E3
    229  28000 ????		22 e4	    var328     =	$22E4
    230  28000 ????		22 e5	    var329     =	$22E5
    231  28000 ????		22 e6	    var330     =	$22E6
    232  28000 ????		22 e7	    var331     =	$22E7
    233  28000 ????		22 e8	    var332     =	$22E8
    234  28000 ????		22 e9	    var333     =	$22E9
    235  28000 ????		22 ea	    var334     =	$22EA
    236  28000 ????		22 eb	    var335     =	$22EB
    237  28000 ????		22 ec	    var336     =	$22EC
    238  28000 ????		22 ed	    var337     =	$22ED
    239  28000 ????		22 ee	    var338     =	$22EE
    240  28000 ????		22 ef	    var339     =	$22EF
    241  28000 ????		22 f0	    var340     =	$22F0
    242  28000 ????		22 f1	    var341     =	$22F1
    243  28000 ????		22 f2	    var342     =	$22F2
    244  28000 ????		22 f3	    var343     =	$22F3
    245  28000 ????		22 f4	    var344     =	$22F4
    246  28000 ????		22 f5	    var345     =	$22F5
    247  28000 ????		22 f6	    var346     =	$22F6
    248  28000 ????		22 f7	    var347     =	$22F7
    249  28000 ????		22 f8	    var348     =	$22F8
    250  28000 ????		22 f9	    var349     =	$22F9
    251  28000 ????		22 fa	    var350     =	$22FA
    252  28000 ????		22 fb	    var351     =	$22FB
    253  28000 ????		22 fc	    var352     =	$22FC
    254  28000 ????		22 fd	    var353     =	$22FD
    255  28000 ????		22 fe	    var354     =	$22FE
    256  28000 ????		22 ff	    var355     =	$22FF
    257  28000 ????		23 00	    var356     =	$2300
    258  28000 ????		23 01	    var357     =	$2301
    259  28000 ????		23 02	    var358     =	$2302
    260  28000 ????		23 03	    var359     =	$2303
    261  28000 ????		23 04	    var360     =	$2304
    262  28000 ????		23 05	    var361     =	$2305
    263  28000 ????		23 06	    var362     =	$2306
    264  28000 ????		23 07	    var363     =	$2307
    265  28000 ????		23 08	    var364     =	$2308
    266  28000 ????		23 09	    var365     =	$2309
    267  28000 ????		23 0a	    var366     =	$230A
    268  28000 ????		23 0b	    var367     =	$230B
    269  28000 ????		23 0c	    var368     =	$230C
    270  28000 ????		23 0d	    var369     =	$230D
    271  28000 ????		23 0e	    var370     =	$230E
    272  28000 ????		23 0f	    var371     =	$230F
    273  28000 ????		23 10	    var372     =	$2310
    274  28000 ????		23 11	    var373     =	$2311
    275  28000 ????		23 12	    var374     =	$2312
    276  28000 ????		23 13	    var375     =	$2313
    277  28000 ????		23 14	    var376     =	$2314
    278  28000 ????		23 15	    var377     =	$2315
    279  28000 ????		23 16	    var378     =	$2316
    280  28000 ????		23 17	    var379     =	$2317
    281  28000 ????		23 18	    var380     =	$2318
    282  28000 ????		23 19	    var381     =	$2319
    283  28000 ????		23 1a	    var382     =	$231A
    284  28000 ????		23 1b	    var383     =	$231B
    285  28000 ????		23 1c	    var384     =	$231C
    286  28000 ????		23 1d	    var385     =	$231D
    287  28000 ????		23 1e	    var386     =	$231E
    288  28000 ????		23 1f	    var387     =	$231F
    289  28000 ????		23 20	    var388     =	$2320
    290  28000 ????		23 21	    var389     =	$2321
    291  28000 ????		23 22	    var390     =	$2322
    292  28000 ????		23 23	    var391     =	$2323
    293  28000 ????		23 24	    var392     =	$2324
    294  28000 ????		23 25	    var393     =	$2325
    295  28000 ????		23 26	    var394     =	$2326
    296  28000 ????		23 27	    var395     =	$2327
    297  28000 ????		23 28	    var396     =	$2328
    298  28000 ????		23 29	    var397     =	$2329
    299  28000 ????		23 2a	    var398     =	$232A
    300  28000 ????		23 2b	    var399     =	$232B
    301  28000 ????		23 2c	    var400     =	$232C
    302  28000 ????		23 2d	    var401     =	$232D
    303  28000 ????		23 2e	    var402     =	$232E
    304  28000 ????		23 2f	    var403     =	$232F
    305  28000 ????		23 30	    var404     =	$2330
    306  28000 ????		23 31	    var405     =	$2331
    307  28000 ????		23 32	    var406     =	$2332
    308  28000 ????		23 33	    var407     =	$2333
    309  28000 ????		23 34	    var408     =	$2334
    310  28000 ????		23 35	    var409     =	$2335
    311  28000 ????		23 36	    var410     =	$2336
    312  28000 ????		23 37	    var411     =	$2337
    313  28000 ????		23 38	    var412     =	$2338
    314  28000 ????		23 39	    var413     =	$2339
    315  28000 ????		23 3a	    var414     =	$233A
    316  28000 ????		23 3b	    var415     =	$233B
    317  28000 ????		23 3c	    var416     =	$233C
    318  28000 ????		23 3d	    var417     =	$233D
    319  28000 ????		23 3e	    var418     =	$233E
    320  28000 ????		23 3f	    var419     =	$233F
    321  28000 ????		23 40	    var420     =	$2340
    322  28000 ????		23 41	    var421     =	$2341
    323  28000 ????		23 42	    var422     =	$2342
    324  28000 ????		23 43	    var423     =	$2343
    325  28000 ????		23 44	    var424     =	$2344
    326  28000 ????		23 45	    var425     =	$2345
    327  28000 ????		23 46	    var426     =	$2346
    328  28000 ????		23 47	    var427     =	$2347
    329  28000 ????		23 48	    var428     =	$2348
    330  28000 ????		23 49	    var429     =	$2349
    331  28000 ????		23 4a	    var430     =	$234A
    332  28000 ????		23 4b	    var431     =	$234B
    333  28000 ????		23 4c	    var432     =	$234C
    334  28000 ????		23 4d	    var433     =	$234D
    335  28000 ????		23 4e	    var434     =	$234E
    336  28000 ????		23 4f	    var435     =	$234F
    337  28000 ????		23 50	    var436     =	$2350
    338  28000 ????		23 51	    var437     =	$2351
    339  28000 ????		23 52	    var438     =	$2352
    340  28000 ????		23 53	    var439     =	$2353
    341  28000 ????		23 54	    var440     =	$2354
    342  28000 ????		23 55	    var441     =	$2355
    343  28000 ????		23 56	    var442     =	$2356
    344  28000 ????		23 57	    var443     =	$2357
    345  28000 ????		23 58	    var444     =	$2358
    346  28000 ????		23 59	    var445     =	$2359
    347  28000 ????		23 5a	    var446     =	$235A
    348  28000 ????		23 5b	    var447     =	$235B
    349  28000 ????		23 5c	    var448     =	$235C
    350  28000 ????		23 5d	    var449     =	$235D
    351  28000 ????		23 5e	    var450     =	$235E
    352  28000 ????		23 5f	    var451     =	$235F
    353  28000 ????		23 60	    var452     =	$2360
    354  28000 ????		23 61	    var453     =	$2361
    355  28000 ????		23 62	    var454     =	$2362
    356  28000 ????		23 63	    var455     =	$2363
    357  28000 ????		23 64	    var456     =	$2364
    358  28000 ????		23 65	    var457     =	$2365
    359  28000 ????		23 66	    var458     =	$2366
    360  28000 ????		23 67	    var459     =	$2367
    361  28000 ????		23 68	    var460     =	$2368
    362  28000 ????		23 69	    var461     =	$2369
    363  28000 ????		23 6a	    var462     =	$236A
    364  28000 ????		23 6b	    var463     =	$236B
    365  28000 ????		23 6c	    var464     =	$236C
    366  28000 ????		23 6d	    var465     =	$236D
    367  28000 ????		23 6e	    var466     =	$236E
    368  28000 ????		23 6f	    var467     =	$236F
    369  28000 ????		23 70	    var468     =	$2370
    370  28000 ????		23 71	    var469     =	$2371
    371  28000 ????		23 72	    var470     =	$2372
    372  28000 ????		23 73	    var471     =	$2373
    373  28000 ????		23 74	    var472     =	$2374
    374  28000 ????		23 75	    var473     =	$2375
    375  28000 ????		23 76	    var474     =	$2376
    376  28000 ????		23 77	    var475     =	$2377
    377  28000 ????		23 78	    var476     =	$2378
    378  28000 ????		23 79	    var477     =	$2379
    379  28000 ????		23 7a	    var478     =	$237A
    380  28000 ????		23 7b	    var479     =	$237B
    381  28000 ????		23 7c	    var480     =	$237C
    382  28000 ????		23 7d	    var481     =	$237D
    383  28000 ????		23 7e	    var482     =	$237E
    384  28000 ????		23 7f	    var483     =	$237F
    385  28000 ????		23 80	    var484     =	$2380
    386  28000 ????		23 81	    var485     =	$2381
    387  28000 ????		23 82	    var486     =	$2382
    388  28000 ????		23 83	    var487     =	$2383
    389  28000 ????		23 84	    var488     =	$2384
    390  28000 ????		23 85	    var489     =	$2385
    391  28000 ????		23 86	    var490     =	$2386
    392  28000 ????		23 87	    var491     =	$2387
    393  28000 ????		23 88	    var492     =	$2388
    394  28000 ????		23 89	    var493     =	$2389
    395  28000 ????		23 8a	    var494     =	$238A
    396  28000 ????		23 8b	    var495     =	$238B
    397  28000 ????		23 8c	    var496     =	$238C
    398  28000 ????		23 8d	    var497     =	$238D
    399  28000 ????		23 8e	    var498     =	$238E
    400  28000 ????		23 8f	    var499     =	$238F
    401  28000 ????		23 90	    var500     =	$2390
    402  28000 ????		23 91	    var501     =	$2391
    403  28000 ????		23 92	    var502     =	$2392
    404  28000 ????		23 93	    var503     =	$2393
    405  28000 ????		23 94	    var504     =	$2394
    406  28000 ????		23 95	    var505     =	$2395
    407  28000 ????		23 96	    var506     =	$2396
    408  28000 ????		23 97	    var507     =	$2397
    409  28000 ????		23 98	    var508     =	$2398
    410  28000 ????		23 99	    var509     =	$2399
    411  28000 ????		23 9a	    var510     =	$239A
    412  28000 ????		23 9b	    var511     =	$239B
    413  28000 ????		23 9c	    var512     =	$239C
    414  28000 ????		23 9d	    var513     =	$239D
    415  28000 ????		23 9e	    var514     =	$239E
    416  28000 ????		23 9f	    var515     =	$239F
    417  28000 ????		23 a0	    var516     =	$23A0
    418  28000 ????		23 a1	    var517     =	$23A1
    419  28000 ????		23 a2	    var518     =	$23A2
    420  28000 ????		23 a3	    var519     =	$23A3
    421  28000 ????		23 a4	    var520     =	$23A4
    422  28000 ????		23 a5	    var521     =	$23A5
    423  28000 ????		23 a6	    var522     =	$23A6
    424  28000 ????		23 a7	    var523     =	$23A7
    425  28000 ????		23 a8	    var524     =	$23A8
    426  28000 ????		23 a9	    var525     =	$23A9
    427  28000 ????		23 aa	    var526     =	$23AA
    428  28000 ????		23 ab	    var527     =	$23AB
    429  28000 ????		23 ac	    var528     =	$23AC
    430  28000 ????		23 ad	    var529     =	$23AD
    431  28000 ????		23 ae	    var530     =	$23AE
    432  28000 ????		23 af	    var531     =	$23AF
    433  28000 ????		23 b0	    var532     =	$23B0
    434  28000 ????		23 b1	    var533     =	$23B1
    435  28000 ????		23 b2	    var534     =	$23B2
    436  28000 ????		23 b3	    var535     =	$23B3
    437  28000 ????		23 b4	    var536     =	$23B4
    438  28000 ????		23 b5	    var537     =	$23B5
    439  28000 ????		23 b6	    var538     =	$23B6
    440  28000 ????		23 b7	    var539     =	$23B7
    441  28000 ????		23 b8	    var540     =	$23B8
    442  28000 ????		23 b9	    var541     =	$23B9
    443  28000 ????		23 ba	    var542     =	$23BA
    444  28000 ????		23 bb	    var543     =	$23BB
    445  28000 ????		23 bc	    var544     =	$23BC
    446  28000 ????		23 bd	    var545     =	$23BD
    447  28000 ????		23 be	    var546     =	$23BE
    448  28000 ????		23 bf	    var547     =	$23BF
    449  28000 ????		23 c0	    var548     =	$23C0
    450  28000 ????		23 c1	    var549     =	$23C1
    451  28000 ????		23 c2	    var550     =	$23C2
    452  28000 ????		23 c3	    var551     =	$23C3
    453  28000 ????		23 c4	    var552     =	$23C4
    454  28000 ????		23 c5	    var553     =	$23C5
    455  28000 ????		23 c6	    var554     =	$23C6
    456  28000 ????		23 c7	    var555     =	$23C7
    457  28000 ????		23 c8	    var556     =	$23C8
    458  28000 ????		23 c9	    var557     =	$23C9
    459  28000 ????		23 ca	    var558     =	$23CA
    460  28000 ????		23 cb	    var559     =	$23CB
    461  28000 ????		23 cc	    var560     =	$23CC
    462  28000 ????		23 cd	    var561     =	$23CD
    463  28000 ????		23 ce	    var562     =	$23CE
    464  28000 ????		23 cf	    var563     =	$23CF
    465  28000 ????		23 d0	    var564     =	$23D0
    466  28000 ????		23 d1	    var565     =	$23D1
    467  28000 ????		23 d2	    var566     =	$23D2
    468  28000 ????		23 d3	    var567     =	$23D3
    469  28000 ????		23 d4	    var568     =	$23D4
    470  28000 ????		23 d5	    var569     =	$23D5
    471  28000 ????		23 d6	    var570     =	$23D6
    472  28000 ????		23 d7	    var571     =	$23D7
    473  28000 ????		23 d8	    var572     =	$23D8
    474  28000 ????		23 d9	    var573     =	$23D9
    475  28000 ????		23 da	    var574     =	$23DA
    476  28000 ????		23 db	    var575     =	$23DB
    477  28000 ????		23 dc	    var576     =	$23DC
    478  28000 ????		23 dd	    var577     =	$23DD
    479  28000 ????		23 de	    var578     =	$23DE
    480  28000 ????		23 df	    var579     =	$23DF
    481  28000 ????		23 e0	    var580     =	$23E0
    482  28000 ????		23 e1	    var581     =	$23E1
    483  28000 ????		23 e2	    var582     =	$23E2
    484  28000 ????		23 e3	    var583     =	$23E3
    485  28000 ????		23 e4	    var584     =	$23E4
    486  28000 ????		23 e5	    var585     =	$23E5
    487  28000 ????		23 e6	    var586     =	$23E6
    488  28000 ????		23 e7	    var587     =	$23E7
    489  28000 ????		23 e8	    var588     =	$23E8
    490  28000 ????		23 e9	    var589     =	$23E9
    491  28000 ????		23 ea	    var590     =	$23EA
    492  28000 ????		23 eb	    var591     =	$23EB
    493  28000 ????		23 ec	    var592     =	$23EC
    494  28000 ????		23 ed	    var593     =	$23ED
    495  28000 ????		23 ee	    var594     =	$23EE
    496  28000 ????		23 ef	    var595     =	$23EF
    497  28000 ????		23 f0	    var596     =	$23F0
    498  28000 ????		23 f1	    var597     =	$23F1
    499  28000 ????		23 f2	    var598     =	$23F2
    500  28000 ????		23 f3	    var599     =	$23F3
    501  28000 ????		23 f4	    var600     =	$23F4
    502  28000 ????		23 f5	    var601     =	$23F5
    503  28000 ????		23 f6	    var602     =	$23F6
    504  28000 ????		23 f7	    var603     =	$23F7
    505  28000 ????		23 f8	    var604     =	$23F8
    506  28000 ????		23 f9	    var605     =	$23F9
    507  28000 ????		23 fa	    var606     =	$23FA
    508  28000 ????		23 fb	    var607     =	$23FB
    509  28000 ????		23 fc	    var608     =	$23FC
    510  28000 ????		23 fd	    var609     =	$23FD
    511  28000 ????		23 fe	    var610     =	$23FE
    512  28000 ????		23 ff	    var611     =	$23FF
    513  28000 ????		24 00	    var612     =	$2400
    514  28000 ????		24 01	    var613     =	$2401
    515  28000 ????		24 02	    var614     =	$2402
    516  28000 ????		24 03	    var615     =	$2403
    517  28000 ????		24 04	    var616     =	$2404
    518  28000 ????		24 05	    var617     =	$2405
    519  28000 ????		24 06	    var618     =	$2406
    520  28000 ????		24 07	    var619     =	$2407
    521  28000 ????		24 08	    var620     =	$2408
    522  28000 ????		24 09	    var621     =	$2409
    523  28000 ????		24 0a	    var622     =	$240A
    524  28000 ????		24 0b	    var623     =	$240B
    525  28000 ????		24 0c	    var624     =	$240C
    526  28000 ????		24 0d	    var625     =	$240D
    527  28000 ????		24 0e	    var626     =	$240E
    528  28000 ????		24 0f	    var627     =	$240F
    529  28000 ????		24 10	    var628     =	$2410
    530  28000 ????		24 11	    var629     =	$2411
    531  28000 ????		24 12	    var630     =	$2412
    532  28000 ????		24 13	    var631     =	$2413
    533  28000 ????		24 14	    var632     =	$2414
    534  28000 ????		24 15	    var633     =	$2415
    535  28000 ????		24 16	    var634     =	$2416
    536  28000 ????		24 17	    var635     =	$2417
    537  28000 ????		24 18	    var636     =	$2418
    538  28000 ????		24 19	    var637     =	$2419
    539  28000 ????		24 1a	    var638     =	$241A
    540  28000 ????		24 1b	    var639     =	$241B
    541  28000 ????		24 1c	    var640     =	$241C
    542  28000 ????		24 1d	    var641     =	$241D
    543  28000 ????		24 1e	    var642     =	$241E
    544  28000 ????		24 1f	    var643     =	$241F
    545  28000 ????		24 20	    var644     =	$2420
    546  28000 ????		24 21	    var645     =	$2421
    547  28000 ????		24 22	    var646     =	$2422
    548  28000 ????		24 23	    var647     =	$2423
    549  28000 ????		24 24	    var648     =	$2424
    550  28000 ????		24 25	    var649     =	$2425
    551  28000 ????		24 26	    var650     =	$2426
    552  28000 ????		24 27	    var651     =	$2427
    553  28000 ????		24 28	    var652     =	$2428
    554  28000 ????		24 29	    var653     =	$2429
    555  28000 ????		24 2a	    var654     =	$242A
    556  28000 ????		24 2b	    var655     =	$242B
    557  28000 ????		24 2c	    var656     =	$242C
    558  28000 ????		24 2d	    var657     =	$242D
    559  28000 ????		24 2e	    var658     =	$242E
    560  28000 ????		24 2f	    var659     =	$242F
    561  28000 ????		24 30	    var660     =	$2430
    562  28000 ????		24 31	    var661     =	$2431
    563  28000 ????		24 32	    var662     =	$2432
    564  28000 ????		24 33	    var663     =	$2433
    565  28000 ????		24 34	    var664     =	$2434
    566  28000 ????		24 35	    var665     =	$2435
    567  28000 ????		24 36	    var666     =	$2436
    568  28000 ????		24 37	    var667     =	$2437
    569  28000 ????		24 38	    var668     =	$2438
    570  28000 ????		24 39	    var669     =	$2439
    571  28000 ????		24 3a	    var670     =	$243A
    572  28000 ????		24 3b	    var671     =	$243B
    573  28000 ????		24 3c	    var672     =	$243C
    574  28000 ????		24 3d	    var673     =	$243D
    575  28000 ????		24 3e	    var674     =	$243E
    576  28000 ????		24 3f	    var675     =	$243F
    577  28000 ????		24 40	    var676     =	$2440
    578  28000 ????		24 41	    var677     =	$2441
    579  28000 ????		24 42	    var678     =	$2442
    580  28000 ????		24 43	    var679     =	$2443
    581  28000 ????		24 44	    var680     =	$2444
    582  28000 ????		24 45	    var681     =	$2445
    583  28000 ????		24 46	    var682     =	$2446
    584  28000 ????		24 47	    var683     =	$2447
    585  28000 ????		24 48	    var684     =	$2448
    586  28000 ????		24 49	    var685     =	$2449
    587  28000 ????		24 4a	    var686     =	$244A
    588  28000 ????		24 4b	    var687     =	$244B
    589  28000 ????		24 4c	    var688     =	$244C
    590  28000 ????		24 4d	    var689     =	$244D
    591  28000 ????		24 4e	    var690     =	$244E
    592  28000 ????		24 4f	    var691     =	$244F
    593  28000 ????		24 50	    var692     =	$2450
    594  28000 ????		24 51	    var693     =	$2451
    595  28000 ????		24 52	    var694     =	$2452
    596  28000 ????		24 53	    var695     =	$2453
    597  28000 ????		24 54	    var696     =	$2454
    598  28000 ????		24 55	    var697     =	$2455
    599  28000 ????		24 56	    var698     =	$2456
    600  28000 ????		24 57	    var699     =	$2457
    601  28000 ????		24 58	    var700     =	$2458
    602  28000 ????		24 59	    var701     =	$2459
    603  28000 ????		24 5a	    var702     =	$245A
    604  28000 ????		24 5b	    var703     =	$245B
    605  28000 ????		24 5c	    var704     =	$245C
    606  28000 ????		24 5d	    var705     =	$245D
    607  28000 ????		24 5e	    var706     =	$245E
    608  28000 ????		24 5f	    var707     =	$245F
    609  28000 ????		24 60	    var708     =	$2460
    610  28000 ????		24 61	    var709     =	$2461
    611  28000 ????		24 62	    var710     =	$2462
    612  28000 ????		24 63	    var711     =	$2463
    613  28000 ????		24 64	    var712     =	$2464
    614  28000 ????		24 65	    var713     =	$2465
    615  28000 ????		24 66	    var714     =	$2466
    616  28000 ????		24 67	    var715     =	$2467
    617  28000 ????		24 68	    var716     =	$2468
    618  28000 ????		24 69	    var717     =	$2469
    619  28000 ????		24 6a	    var718     =	$246A
    620  28000 ????		24 6b	    var719     =	$246B
    621  28000 ????		24 6c	    var720     =	$246C
    622  28000 ????		24 6d	    var721     =	$246D
    623  28000 ????		24 6e	    var722     =	$246E
    624  28000 ????		24 6f	    var723     =	$246F
    625  28000 ????		24 70	    var724     =	$2470
    626  28000 ????		24 71	    var725     =	$2471
    627  28000 ????		24 72	    var726     =	$2472
    628  28000 ????		24 73	    var727     =	$2473
    629  28000 ????		24 74	    var728     =	$2474
    630  28000 ????		24 75	    var729     =	$2475
    631  28000 ????		24 76	    var730     =	$2476
    632  28000 ????		24 77	    var731     =	$2477
    633  28000 ????		24 78	    var732     =	$2478
    634  28000 ????		24 79	    var733     =	$2479
    635  28000 ????		24 7a	    var734     =	$247A
    636  28000 ????		24 7b	    var735     =	$247B
    637  28000 ????		24 7c	    var736     =	$247C
    638  28000 ????		24 7d	    var737     =	$247D
    639  28000 ????		24 7e	    var738     =	$247E
    640  28000 ????		24 7f	    var739     =	$247F
    641  28000 ????		24 80	    var740     =	$2480
    642  28000 ????		24 81	    var741     =	$2481
    643  28000 ????		24 82	    var742     =	$2482
    644  28000 ????		24 83	    var743     =	$2483
    645  28000 ????		24 84	    var744     =	$2484
    646  28000 ????		24 85	    var745     =	$2485
    647  28000 ????		24 86	    var746     =	$2486
    648  28000 ????		24 87	    var747     =	$2487
    649  28000 ????		24 88	    var748     =	$2488
    650  28000 ????		24 89	    var749     =	$2489
    651  28000 ????		24 8a	    var750     =	$248A
    652  28000 ????		24 8b	    var751     =	$248B
    653  28000 ????		24 8c	    var752     =	$248C
    654  28000 ????		24 8d	    var753     =	$248D
    655  28000 ????		24 8e	    var754     =	$248E
    656  28000 ????		24 8f	    var755     =	$248F
    657  28000 ????		24 90	    var756     =	$2490
    658  28000 ????		24 91	    var757     =	$2491
    659  28000 ????		24 92	    var758     =	$2492
    660  28000 ????		24 93	    var759     =	$2493
    661  28000 ????		24 94	    var760     =	$2494
    662  28000 ????		24 95	    var761     =	$2495
    663  28000 ????		24 96	    var762     =	$2496
    664  28000 ????		24 97	    var763     =	$2497
    665  28000 ????		24 98	    var764     =	$2498
    666  28000 ????		24 99	    var765     =	$2499
    667  28000 ????		24 9a	    var766     =	$249A
    668  28000 ????		24 9b	    var767     =	$249B
    669  28000 ????		24 9c	    var768     =	$249C
    670  28000 ????		24 9d	    var769     =	$249D
    671  28000 ????		24 9e	    var770     =	$249E
    672  28000 ????		24 9f	    var771     =	$249F
    673  28000 ????		24 a0	    var772     =	$24A0
    674  28000 ????		24 a1	    var773     =	$24A1
    675  28000 ????		24 a2	    var774     =	$24A2
    676  28000 ????		24 a3	    var775     =	$24A3
    677  28000 ????		24 a4	    var776     =	$24A4
    678  28000 ????		24 a5	    var777     =	$24A5
    679  28000 ????		24 a6	    var778     =	$24A6
    680  28000 ????		24 a7	    var779     =	$24A7
    681  28000 ????		24 a8	    var780     =	$24A8
    682  28000 ????		24 a9	    var781     =	$24A9
    683  28000 ????		24 aa	    var782     =	$24AA
    684  28000 ????		24 ab	    var783     =	$24AB
    685  28000 ????		24 ac	    var784     =	$24AC
    686  28000 ????		24 ad	    var785     =	$24AD
    687  28000 ????		24 ae	    var786     =	$24AE
    688  28000 ????		24 af	    var787     =	$24AF
    689  28000 ????		24 b0	    var788     =	$24B0
    690  28000 ????		24 b1	    var789     =	$24B1
    691  28000 ????		24 b2	    var790     =	$24B2
    692  28000 ????		24 b3	    var791     =	$24B3
    693  28000 ????		24 b4	    var792     =	$24B4
    694  28000 ????		24 b5	    var793     =	$24B5
    695  28000 ????		24 b6	    var794     =	$24B6
    696  28000 ????		24 b7	    var795     =	$24B7
    697  28000 ????		24 b8	    var796     =	$24B8
    698  28000 ????		24 b9	    var797     =	$24B9
    699  28000 ????		24 ba	    var798     =	$24BA
    700  28000 ????		24 bb	    var799     =	$24BB
    701  28000 ????		24 bc	    var800     =	$24BC
    702  28000 ????		24 bd	    var801     =	$24BD
    703  28000 ????		24 be	    var802     =	$24BE
    704  28000 ????		24 bf	    var803     =	$24BF
    705  28000 ????		24 c0	    var804     =	$24C0
    706  28000 ????		24 c1	    var805     =	$24C1
    707  28000 ????		24 c2	    var806     =	$24C2
    708  28000 ????		24 c3	    var807     =	$24C3
    709  28000 ????		24 c4	    var808     =	$24C4
    710  28000 ????		24 c5	    var809     =	$24C5
    711  28000 ????		24 c6	    var810     =	$24C6
    712  28000 ????		24 c7	    var811     =	$24C7
    713  28000 ????		24 c8	    var812     =	$24C8
    714  28000 ????		24 c9	    var813     =	$24C9
    715  28000 ????		24 ca	    var814     =	$24CA
    716  28000 ????		24 cb	    var815     =	$24CB
    717  28000 ????		24 cc	    var816     =	$24CC
    718  28000 ????		24 cd	    var817     =	$24CD
    719  28000 ????		24 ce	    var818     =	$24CE
    720  28000 ????		24 cf	    var819     =	$24CF
    721  28000 ????		24 d0	    var820     =	$24D0
    722  28000 ????		24 d1	    var821     =	$24D1
    723  28000 ????		24 d2	    var822     =	$24D2
    724  28000 ????		24 d3	    var823     =	$24D3
    725  28000 ????		24 d4	    var824     =	$24D4
    726  28000 ????		24 d5	    var825     =	$24D5
    727  28000 ????		24 d6	    var826     =	$24D6
    728  28000 ????		24 d7	    var827     =	$24D7
    729  28000 ????		24 d8	    var828     =	$24D8
    730  28000 ????		24 d9	    var829     =	$24D9
    731  28000 ????		24 da	    var830     =	$24DA
    732  28000 ????		24 db	    var831     =	$24DB
    733  28000 ????		24 dc	    var832     =	$24DC
    734  28000 ????		24 dd	    var833     =	$24DD
    735  28000 ????		24 de	    var834     =	$24DE
    736  28000 ????		24 df	    var835     =	$24DF
    737  28000 ????		24 e0	    var836     =	$24E0
    738  28000 ????		24 e1	    var837     =	$24E1
    739  28000 ????		24 e2	    var838     =	$24E2
    740  28000 ????		24 e3	    var839     =	$24E3
    741  28000 ????		24 e4	    var840     =	$24E4
    742  28000 ????		24 e5	    var841     =	$24E5
    743  28000 ????		24 e6	    var842     =	$24E6
    744  28000 ????		24 e7	    var843     =	$24E7
    745  28000 ????		24 e8	    var844     =	$24E8
    746  28000 ????		24 e9	    var845     =	$24E9
    747  28000 ????		24 ea	    var846     =	$24EA
    748  28000 ????		24 eb	    var847     =	$24EB
    749  28000 ????		24 ec	    var848     =	$24EC
    750  28000 ????		24 ed	    var849     =	$24ED
    751  28000 ????		24 ee	    var850     =	$24EE
    752  28000 ????		24 ef	    var851     =	$24EF
    753  28000 ????		24 f0	    var852     =	$24F0
    754  28000 ????		24 f1	    var853     =	$24F1
    755  28000 ????		24 f2	    var854     =	$24F2
    756  28000 ????		24 f3	    var855     =	$24F3
    757  28000 ????		24 f4	    var856     =	$24F4
    758  28000 ????		24 f5	    var857     =	$24F5
    759  28000 ????		24 f6	    var858     =	$24F6
    760  28000 ????		24 f7	    var859     =	$24F7
    761  28000 ????		24 f8	    var860     =	$24F8
    762  28000 ????		24 f9	    var861     =	$24F9
    763  28000 ????		24 fa	    var862     =	$24FA
    764  28000 ????		24 fb	    var863     =	$24FB
    765  28000 ????		24 fc	    var864     =	$24FC
    766  28000 ????		24 fd	    var865     =	$24FD
    767  28000 ????		24 fe	    var866     =	$24FE
    768  28000 ????		24 ff	    var867     =	$24FF
    769  28000 ????		25 00	    var868     =	$2500
    770  28000 ????		25 01	    var869     =	$2501
    771  28000 ????		25 02	    var870     =	$2502
    772  28000 ????		25 03	    var871     =	$2503
    773  28000 ????		25 04	    var872     =	$2504
    774  28000 ????		25 05	    var873     =	$2505
    775  28000 ????		25 06	    var874     =	$2506
    776  28000 ????		25 07	    var875     =	$2507
    777  28000 ????		25 08	    var876     =	$2508
    778  28000 ????		25 09	    var877     =	$2509
    779  28000 ????		25 0a	    var878     =	$250A
    780  28000 ????		25 0b	    var879     =	$250B
    781  28000 ????		25 0c	    var880     =	$250C
    782  28000 ????		25 0d	    var881     =	$250D
    783  28000 ????		25 0e	    var882     =	$250E
    784  28000 ????		25 0f	    var883     =	$250F
    785  28000 ????		25 10	    var884     =	$2510
    786  28000 ????		25 11	    var885     =	$2511
    787  28000 ????		25 12	    var886     =	$2512
    788  28000 ????		25 13	    var887     =	$2513
    789  28000 ????		25 14	    var888     =	$2514
    790  28000 ????		25 15	    var889     =	$2515
    791  28000 ????		25 16	    var890     =	$2516
    792  28000 ????		25 17	    var891     =	$2517
    793  28000 ????		25 18	    var892     =	$2518
    794  28000 ????		25 19	    var893     =	$2519
    795  28000 ????		25 1a	    var894     =	$251A
    796  28000 ????		25 1b	    var895     =	$251B
    797  28000 ????		25 1c	    var896     =	$251C
    798  28000 ????		25 1d	    var897     =	$251D
    799  28000 ????		25 1e	    var898     =	$251E
    800  28000 ????		25 1f	    var899     =	$251F
    801  28000 ????		25 20	    var900     =	$2520
    802  28000 ????		25 21	    var901     =	$2521
    803  28000 ????		25 22	    var902     =	$2522
    804  28000 ????		25 23	    var903     =	$2523
    805  28000 ????		25 24	    var904     =	$2524
    806  28000 ????		25 25	    var905     =	$2525
    807  28000 ????		25 26	    var906     =	$2526
    808  28000 ????		25 27	    var907     =	$2527
    809  28000 ????		25 28	    var908     =	$2528
    810  28000 ????		25 29	    var909     =	$2529
    811  28000 ????		25 2a	    var910     =	$252A
    812  28000 ????		25 2b	    var911     =	$252B
    813  28000 ????		25 2c	    var912     =	$252C
    814  28000 ????		25 2d	    var913     =	$252D
    815  28000 ????		25 2e	    var914     =	$252E
    816  28000 ????		25 2f	    var915     =	$252F
    817  28000 ????		25 30	    var916     =	$2530
    818  28000 ????		25 31	    var917     =	$2531
    819  28000 ????		25 32	    var918     =	$2532
    820  28000 ????		25 33	    var919     =	$2533
    821  28000 ????		25 34	    var920     =	$2534
    822  28000 ????		25 35	    var921     =	$2535
    823  28000 ????		25 36	    var922     =	$2536
    824  28000 ????		25 37	    var923     =	$2537
    825  28000 ????		25 38	    var924     =	$2538
    826  28000 ????		25 39	    var925     =	$2539
    827  28000 ????		25 3a	    var926     =	$253A
    828  28000 ????		25 3b	    var927     =	$253B
    829  28000 ????		25 3c	    var928     =	$253C
    830  28000 ????		25 3d	    var929     =	$253D
    831  28000 ????		25 3e	    var930     =	$253E
    832  28000 ????		25 3f	    var931     =	$253F
    833  28000 ????		25 40	    var932     =	$2540
    834  28000 ????		25 41	    var933     =	$2541
    835  28000 ????		25 42	    var934     =	$2542
    836  28000 ????		25 43	    var935     =	$2543
    837  28000 ????		25 44	    var936     =	$2544
    838  28000 ????		25 45	    var937     =	$2545
    839  28000 ????		25 46	    var938     =	$2546
    840  28000 ????		25 47	    var939     =	$2547
    841  28000 ????		25 48	    var940     =	$2548
    842  28000 ????		25 49	    var941     =	$2549
    843  28000 ????		25 4a	    var942     =	$254A
    844  28000 ????		25 4b	    var943     =	$254B
    845  28000 ????		25 4c	    var944     =	$254C
    846  28000 ????		25 4d	    var945     =	$254D
    847  28000 ????		25 4e	    var946     =	$254E
    848  28000 ????		25 4f	    var947     =	$254F
    849  28000 ????		25 50	    var948     =	$2550
    850  28000 ????		25 51	    var949     =	$2551
    851  28000 ????		25 52	    var950     =	$2552
    852  28000 ????		25 53	    var951     =	$2553
    853  28000 ????		25 54	    var952     =	$2554
    854  28000 ????		25 55	    var953     =	$2555
    855  28000 ????		25 56	    var954     =	$2556
    856  28000 ????		25 57	    var955     =	$2557
    857  28000 ????		25 58	    var956     =	$2558
    858  28000 ????		25 59	    var957     =	$2559
    859  28000 ????		25 5a	    var958     =	$255A
    860  28000 ????		25 5b	    var959     =	$255B
    861  28000 ????		25 5c	    var960     =	$255C
    862  28000 ????		25 5d	    var961     =	$255D
    863  28000 ????		25 5e	    var962     =	$255E
    864  28000 ????		25 5f	    var963     =	$255F
    865  28000 ????		25 60	    var964     =	$2560
    866  28000 ????		25 61	    var965     =	$2561
    867  28000 ????		25 62	    var966     =	$2562
    868  28000 ????		25 63	    var967     =	$2563
    869  28000 ????		25 64	    var968     =	$2564
    870  28000 ????		25 65	    var969     =	$2565
    871  28000 ????		25 66	    var970     =	$2566
    872  28000 ????		25 67	    var971     =	$2567
    873  28000 ????		25 68	    var972     =	$2568
    874  28000 ????		25 69	    var973     =	$2569
    875  28000 ????		25 6a	    var974     =	$256A
    876  28000 ????		25 6b	    var975     =	$256B
    877  28000 ????		25 6c	    var976     =	$256C
    878  28000 ????		25 6d	    var977     =	$256D
    879  28000 ????		25 6e	    var978     =	$256E
    880  28000 ????		25 6f	    var979     =	$256F
    881  28000 ????		25 70	    var980     =	$2570
    882  28000 ????		25 71	    var981     =	$2571
    883  28000 ????		25 72	    var982     =	$2572
    884  28000 ????		25 73	    var983     =	$2573
    885  28000 ????		25 74	    var984     =	$2574
    886  28000 ????		25 75	    var985     =	$2575
    887  28000 ????		25 76	    var986     =	$2576
    888  28000 ????		25 77	    var987     =	$2577
    889  28000 ????		25 78	    var988     =	$2578
    890  28000 ????		25 79	    var989     =	$2579
    891  28000 ????		25 7a	    var990     =	$257A
    892  28000 ????		25 7b	    var991     =	$257B
    893  28000 ????		25 7c	    var992     =	$257C
    894  28000 ????		25 7d	    var993     =	$257D
    895  28000 ????		25 7e	    var994     =	$257E
    896  28000 ????		25 7f	    var995     =	$257F
    897  28000 ????		25 80	    var996     =	$2580
    898  28000 ????		25 81	    var997     =	$2581
    899  28000 ????		25 82	    var998     =	$2582
    900  28000 ????		25 83	    var999     =	$2583
    901  28000 ????		25 84	    var1000    =	$2584
    902  28000 ????		25 85	    var1001    =	$2585
    903  28000 ????		25 86	    var1002    =	$2586
    904  28000 ????		25 87	    var1003    =	$2587
    905  28000 ????		25 88	    var1004    =	$2588
    906  28000 ????		25 89	    var1005    =	$2589
    907  28000 ????		25 8a	    var1006    =	$258A
    908  28000 ????		25 8b	    var1007    =	$258B
    909  28000 ????		25 8c	    var1008    =	$258C
    910  28000 ????		25 8d	    var1009    =	$258D
    911  28000 ????		25 8e	    var1010    =	$258E
    912  28000 ????		25 8f	    var1011    =	$258F
    913  28000 ????		25 90	    var1012    =	$2590
    914  28000 ????		25 91	    var1013    =	$2591
    915  28000 ????		25 92	    var1014    =	$2592
    916  28000 ????		25 93	    var1015    =	$2593
    917  28000 ????		25 94	    var1016    =	$2594
    918  28000 ????		25 95	    var1017    =	$2595
    919  28000 ????		25 96	    var1018    =	$2596
    920  28000 ????		25 97	    var1019    =	$2597
    921  28000 ????		25 98	    var1020    =	$2598
    922  28000 ????		25 99	    var1021    =	$2599
    923  28000 ????		25 9a	    var1022    =	$259A
    924  28000 ????		25 9b	    var1023    =	$259B
    925  28000 ????		25 9c	    var1024    =	$259C
    926  28000 ????		25 9d	    var1025    =	$259D
    927  28000 ????		25 9e	    var1026    =	$259E
    928  28000 ????		25 9f	    var1027    =	$259F
    929  28000 ????		25 a0	    var1028    =	$25A0
    930  28000 ????		25 a1	    var1029    =	$25A1
    931  28000 ????		25 a2	    var1030    =	$25A2
    932  28000 ????		25 a3	    var1031    =	$25A3
    933  28000 ????		25 a4	    var1032    =	$25A4
    934  28000 ????		25 a5	    var1033    =	$25A5
    935  28000 ????		25 a6	    var1034    =	$25A6
    936  28000 ????		25 a7	    var1035    =	$25A7
    937  28000 ????		25 a8	    var1036    =	$25A8
    938  28000 ????		25 a9	    var1037    =	$25A9
    939  28000 ????		25 aa	    var1038    =	$25AA
    940  28000 ????		25 ab	    var1039    =	$25AB
    941  28000 ????		25 ac	    var1040    =	$25AC
    942  28000 ????		25 ad	    var1041    =	$25AD
    943  28000 ????		25 ae	    var1042    =	$25AE
    944  28000 ????		25 af	    var1043    =	$25AF
    945  28000 ????		25 b0	    var1044    =	$25B0
    946  28000 ????		25 b1	    var1045    =	$25B1
    947  28000 ????		25 b2	    var1046    =	$25B2
    948  28000 ????		25 b3	    var1047    =	$25B3
    949  28000 ????		25 b4	    var1048    =	$25B4
    950  28000 ????		25 b5	    var1049    =	$25B5
    951  28000 ????		25 b6	    var1050    =	$25B6
    952  28000 ????		25 b7	    var1051    =	$25B7
    953  28000 ????		25 b8	    var1052    =	$25B8
    954  28000 ????		25 b9	    var1053    =	$25B9
    955  28000 ????		25 ba	    var1054    =	$25BA
    956  28000 ????		25 bb	    var1055    =	$25BB
    957  28000 ????		25 bc	    var1056    =	$25BC
    958  28000 ????		25 bd	    var1057    =	$25BD
    959  28000 ????		25 be	    var1058    =	$25BE
    960  28000 ????		25 bf	    var1059    =	$25BF
    961  28000 ????		25 c0	    var1060    =	$25C0
    962  28000 ????		25 c1	    var1061    =	$25C1
    963  28000 ????		25 c2	    var1062    =	$25C2
    964  28000 ????		25 c3	    var1063    =	$25C3
    965  28000 ????		25 c4	    var1064    =	$25C4
    966  28000 ????		25 c5	    var1065    =	$25C5
    967  28000 ????		25 c6	    var1066    =	$25C6
    968  28000 ????		25 c7	    var1067    =	$25C7
    969  28000 ????		25 c8	    var1068    =	$25C8
    970  28000 ????		25 c9	    var1069    =	$25C9
    971  28000 ????		25 ca	    var1070    =	$25CA
    972  28000 ????		25 cb	    var1071    =	$25CB
    973  28000 ????		25 cc	    var1072    =	$25CC
    974  28000 ????		25 cd	    var1073    =	$25CD
    975  28000 ????		25 ce	    var1074    =	$25CE
    976  28000 ????		25 cf	    var1075    =	$25CF
    977  28000 ????		25 d0	    var1076    =	$25D0
    978  28000 ????		25 d1	    var1077    =	$25D1
    979  28000 ????		25 d2	    var1078    =	$25D2
    980  28000 ????		25 d3	    var1079    =	$25D3
    981  28000 ????		25 d4	    var1080    =	$25D4
    982  28000 ????		25 d5	    var1081    =	$25D5
    983  28000 ????		25 d6	    var1082    =	$25D6
    984  28000 ????		25 d7	    var1083    =	$25D7
    985  28000 ????		25 d8	    var1084    =	$25D8
    986  28000 ????		25 d9	    var1085    =	$25D9
    987  28000 ????		25 da	    var1086    =	$25DA
    988  28000 ????		25 db	    var1087    =	$25DB
    989  28000 ????		25 dc	    var1088    =	$25DC
    990  28000 ????		25 dd	    var1089    =	$25DD
    991  28000 ????		25 de	    var1090    =	$25DE
    992  28000 ????		25 df	    var1091    =	$25DF
    993  28000 ????		25 e0	    var1092    =	$25E0
    994  28000 ????		25 e1	    var1093    =	$25E1
    995  28000 ????		25 e2	    var1094    =	$25E2
    996  28000 ????		25 e3	    var1095    =	$25E3
    997  28000 ????		25 e4	    var1096    =	$25E4
    998  28000 ????		25 e5	    var1097    =	$25E5
    999  28000 ????		25 e6	    var1098    =	$25E6
   1000  28000 ????		25 e7	    var1099    =	$25E7
   1001  28000 ????		25 e8	    var1100    =	$25E8
   1002  28000 ????		25 e9	    var1101    =	$25E9
   1003  28000 ????		25 ea	    var1102    =	$25EA
   1004  28000 ????		25 eb	    var1103    =	$25EB
   1005  28000 ????		25 ec	    var1104    =	$25EC
   1006  28000 ????		25 ed	    var1105    =	$25ED
   1007  28000 ????		25 ee	    var1106    =	$25EE
   1008  28000 ????		25 ef	    var1107    =	$25EF
   1009  28000 ????		25 f0	    var1108    =	$25F0
   1010  28000 ????		25 f1	    var1109    =	$25F1
   1011  28000 ????		25 f2	    var1110    =	$25F2
   1012  28000 ????		25 f3	    var1111    =	$25F3
   1013  28000 ????		25 f4	    var1112    =	$25F4
   1014  28000 ????		25 f5	    var1113    =	$25F5
   1015  28000 ????		25 f6	    var1114    =	$25F6
   1016  28000 ????		25 f7	    var1115    =	$25F7
   1017  28000 ????		25 f8	    var1116    =	$25F8
   1018  28000 ????		25 f9	    var1117    =	$25F9
   1019  28000 ????		25 fa	    var1118    =	$25FA
   1020  28000 ????		25 fb	    var1119    =	$25FB
   1021  28000 ????		25 fc	    var1120    =	$25FC
   1022  28000 ????		25 fd	    var1121    =	$25FD
   1023  28000 ????		25 fe	    var1122    =	$25FE
   1024  28000 ????		25 ff	    var1123    =	$25FF
   1025  28000 ????		26 00	    var1124    =	$2600
   1026  28000 ????		26 01	    var1125    =	$2601
   1027  28000 ????		26 02	    var1126    =	$2602
   1028  28000 ????		26 03	    var1127    =	$2603
   1029  28000 ????		26 04	    var1128    =	$2604
   1030  28000 ????		26 05	    var1129    =	$2605
   1031  28000 ????		26 06	    var1130    =	$2606
   1032  28000 ????		26 07	    var1131    =	$2607
   1033  28000 ????		26 08	    var1132    =	$2608
   1034  28000 ????		26 09	    var1133    =	$2609
   1035  28000 ????		26 0a	    var1134    =	$260A
   1036  28000 ????		26 0b	    var1135    =	$260B
   1037  28000 ????		26 0c	    var1136    =	$260C
   1038  28000 ????		26 0d	    var1137    =	$260D
   1039  28000 ????		26 0e	    var1138    =	$260E
   1040  28000 ????		26 0f	    var1139    =	$260F
   1041  28000 ????		26 10	    var1140    =	$2610
   1042  28000 ????		26 11	    var1141    =	$2611
   1043  28000 ????		26 12	    var1142    =	$2612
   1044  28000 ????		26 13	    var1143    =	$2613
   1045  28000 ????		26 14	    var1144    =	$2614
   1046  28000 ????		26 15	    var1145    =	$2615
   1047  28000 ????		26 16	    var1146    =	$2616
   1048  28000 ????		26 17	    var1147    =	$2617
   1049  28000 ????		26 18	    var1148    =	$2618
   1050  28000 ????		26 19	    var1149    =	$2619
   1051  28000 ????		26 1a	    var1150    =	$261A
   1052  28000 ????		26 1b	    var1151    =	$261B
   1053  28000 ????		26 1c	    var1152    =	$261C
   1054  28000 ????		26 1d	    var1153    =	$261D
   1055  28000 ????		26 1e	    var1154    =	$261E
   1056  28000 ????		26 1f	    var1155    =	$261F
   1057  28000 ????		26 20	    var1156    =	$2620
   1058  28000 ????		26 21	    var1157    =	$2621
   1059  28000 ????		26 22	    var1158    =	$2622
   1060  28000 ????		26 23	    var1159    =	$2623
   1061  28000 ????		26 24	    var1160    =	$2624
   1062  28000 ????		26 25	    var1161    =	$2625
   1063  28000 ????		26 26	    var1162    =	$2626
   1064  28000 ????		26 27	    var1163    =	$2627
   1065  28000 ????		26 28	    var1164    =	$2628
   1066  28000 ????		26 29	    var1165    =	$2629
   1067  28000 ????		26 2a	    var1166    =	$262A
   1068  28000 ????		26 2b	    var1167    =	$262B
   1069  28000 ????		26 2c	    var1168    =	$262C
   1070  28000 ????		26 2d	    var1169    =	$262D
   1071  28000 ????		26 2e	    var1170    =	$262E
   1072  28000 ????		26 2f	    var1171    =	$262F
   1073  28000 ????		26 30	    var1172    =	$2630
   1074  28000 ????		26 31	    var1173    =	$2631
   1075  28000 ????		26 32	    var1174    =	$2632
   1076  28000 ????		26 33	    var1175    =	$2633
   1077  28000 ????		26 34	    var1176    =	$2634
   1078  28000 ????		26 35	    var1177    =	$2635
   1079  28000 ????		26 36	    var1178    =	$2636
   1080  28000 ????		26 37	    var1179    =	$2637
   1081  28000 ????		26 38	    var1180    =	$2638
   1082  28000 ????		26 39	    var1181    =	$2639
   1083  28000 ????		26 3a	    var1182    =	$263A
   1084  28000 ????		26 3b	    var1183    =	$263B
   1085  28000 ????		26 3c	    var1184    =	$263C
   1086  28000 ????		26 3d	    var1185    =	$263D
   1087  28000 ????		26 3e	    var1186    =	$263E
   1088  28000 ????		26 3f	    var1187    =	$263F
   1089  28000 ????		26 40	    var1188    =	$2640
   1090  28000 ????		26 41	    var1189    =	$2641
   1091  28000 ????		26 42	    var1190    =	$2642
   1092  28000 ????		26 43	    var1191    =	$2643
   1093  28000 ????		26 44	    var1192    =	$2644
   1094  28000 ????		26 45	    var1193    =	$2645
   1095  28000 ????		26 46	    var1194    =	$2646
   1096  28000 ????		26 47	    var1195    =	$2647
   1097  28000 ????		26 48	    var1196    =	$2648
   1098  28000 ????		26 49	    var1197    =	$2649
   1099  28000 ????		26 4a	    var1198    =	$264A
   1100  28000 ????		26 4b	    var1199    =	$264B
   1101  28000 ????		26 4c	    var1200    =	$264C
   1102  28000 ????		26 4d	    var1201    =	$264D
   1103  28000 ????		26 4e	    var1202    =	$264E
   1104  28000 ????		26 4f	    var1203    =	$264F
   1105  28000 ????		26 50	    var1204    =	$2650
   1106  28000 ????		26 51	    var1205    =	$2651
   1107  28000 ????		26 52	    var1206    =	$2652
   1108  28000 ????		26 53	    var1207    =	$2653
   1109  28000 ????		26 54	    var1208    =	$2654
   1110  28000 ????		26 55	    var1209    =	$2655
   1111  28000 ????		26 56	    var1210    =	$2656
   1112  28000 ????		26 57	    var1211    =	$2657
   1113  28000 ????		26 58	    var1212    =	$2658
   1114  28000 ????		26 59	    var1213    =	$2659
   1115  28000 ????		26 5a	    var1214    =	$265A
   1116  28000 ????		26 5b	    var1215    =	$265B
   1117  28000 ????		26 5c	    var1216    =	$265C
   1118  28000 ????		26 5d	    var1217    =	$265D
   1119  28000 ????		26 5e	    var1218    =	$265E
   1120  28000 ????		26 5f	    var1219    =	$265F
   1121  28000 ????		26 60	    var1220    =	$2660
   1122  28000 ????		26 61	    var1221    =	$2661
   1123  28000 ????		26 62	    var1222    =	$2662
   1124  28000 ????		26 63	    var1223    =	$2663
   1125  28000 ????		26 64	    var1224    =	$2664
   1126  28000 ????		26 65	    var1225    =	$2665
   1127  28000 ????		26 66	    var1226    =	$2666
   1128  28000 ????		26 67	    var1227    =	$2667
   1129  28000 ????		26 68	    var1228    =	$2668
   1130  28000 ????		26 69	    var1229    =	$2669
   1131  28000 ????		26 6a	    var1230    =	$266A
   1132  28000 ????		26 6b	    var1231    =	$266B
   1133  28000 ????		26 6c	    var1232    =	$266C
   1134  28000 ????		26 6d	    var1233    =	$266D
   1135  28000 ????		26 6e	    var1234    =	$266E
   1136  28000 ????		26 6f	    var1235    =	$266F
   1137  28000 ????		26 70	    var1236    =	$2670
   1138  28000 ????		26 71	    var1237    =	$2671
   1139  28000 ????		26 72	    var1238    =	$2672
   1140  28000 ????		26 73	    var1239    =	$2673
   1141  28000 ????		26 74	    var1240    =	$2674
   1142  28000 ????		26 75	    var1241    =	$2675
   1143  28000 ????		26 76	    var1242    =	$2676
   1144  28000 ????		26 77	    var1243    =	$2677
   1145  28000 ????		26 78	    var1244    =	$2678
   1146  28000 ????		26 79	    var1245    =	$2679
   1147  28000 ????		26 7a	    var1246    =	$267A
   1148  28000 ????		26 7b	    var1247    =	$267B
   1149  28000 ????		26 7c	    var1248    =	$267C
   1150  28000 ????		26 7d	    var1249    =	$267D
   1151  28000 ????		26 7e	    var1250    =	$267E
   1152  28000 ????		26 7f	    var1251    =	$267F
   1153  28000 ????		26 80	    var1252    =	$2680
   1154  28000 ????		26 81	    var1253    =	$2681
   1155  28000 ????		26 82	    var1254    =	$2682
   1156  28000 ????		26 83	    var1255    =	$2683
   1157  28000 ????		26 84	    var1256    =	$2684
   1158  28000 ????		26 85	    var1257    =	$2685
   1159  28000 ????		26 86	    var1258    =	$2686
   1160  28000 ????		26 87	    var1259    =	$2687
   1161  28000 ????		26 88	    var1260    =	$2688
   1162  28000 ????		26 89	    var1261    =	$2689
   1163  28000 ????		26 8a	    var1262    =	$268A
   1164  28000 ????		26 8b	    var1263    =	$268B
   1165  28000 ????		26 8c	    var1264    =	$268C
   1166  28000 ????		26 8d	    var1265    =	$268D
   1167  28000 ????		26 8e	    var1266    =	$268E
   1168  28000 ????		26 8f	    var1267    =	$268F
   1169  28000 ????		26 90	    var1268    =	$2690
   1170  28000 ????		26 91	    var1269    =	$2691
   1171  28000 ????		26 92	    var1270    =	$2692
   1172  28000 ????		26 93	    var1271    =	$2693
   1173  28000 ????		26 94	    var1272    =	$2694
   1174  28000 ????		26 95	    var1273    =	$2695
   1175  28000 ????		26 96	    var1274    =	$2696
   1176  28000 ????		26 97	    var1275    =	$2697
   1177  28000 ????		26 98	    var1276    =	$2698
   1178  28000 ????		26 99	    var1277    =	$2699
   1179  28000 ????		26 9a	    var1278    =	$269A
   1180  28000 ????		26 9b	    var1279    =	$269B
   1181  28000 ????		26 9c	    var1280    =	$269C
   1182  28000 ????		26 9d	    var1281    =	$269D
   1183  28000 ????		26 9e	    var1282    =	$269E
   1184  28000 ????		26 9f	    var1283    =	$269F
   1185  28000 ????		26 a0	    var1284    =	$26A0
   1186  28000 ????		26 a1	    var1285    =	$26A1
   1187  28000 ????		26 a2	    var1286    =	$26A2
   1188  28000 ????		26 a3	    var1287    =	$26A3
   1189  28000 ????		26 a4	    var1288    =	$26A4
   1190  28000 ????		26 a5	    var1289    =	$26A5
   1191  28000 ????		26 a6	    var1290    =	$26A6
   1192  28000 ????		26 a7	    var1291    =	$26A7
   1193  28000 ????		26 a8	    var1292    =	$26A8
   1194  28000 ????		26 a9	    var1293    =	$26A9
   1195  28000 ????		26 aa	    var1294    =	$26AA
   1196  28000 ????		26 ab	    var1295    =	$26AB
   1197  28000 ????		26 ac	    var1296    =	$26AC
   1198  28000 ????		26 ad	    var1297    =	$26AD
   1199  28000 ????		26 ae	    var1298    =	$26AE
   1200  28000 ????		26 af	    var1299    =	$26AF
   1201  28000 ????		26 b0	    var1300    =	$26B0
   1202  28000 ????		26 b1	    var1301    =	$26B1
   1203  28000 ????		26 b2	    var1302    =	$26B2
   1204  28000 ????		26 b3	    var1303    =	$26B3
   1205  28000 ????		26 b4	    var1304    =	$26B4
   1206  28000 ????		26 b5	    var1305    =	$26B5
   1207  28000 ????		26 b6	    var1306    =	$26B6
   1208  28000 ????		26 b7	    var1307    =	$26B7
   1209  28000 ????		26 b8	    var1308    =	$26B8
   1210  28000 ????		26 b9	    var1309    =	$26B9
   1211  28000 ????		26 ba	    var1310    =	$26BA
   1212  28000 ????		26 bb	    var1311    =	$26BB
   1213  28000 ????		26 bc	    var1312    =	$26BC
   1214  28000 ????		26 bd	    var1313    =	$26BD
   1215  28000 ????		26 be	    var1314    =	$26BE
   1216  28000 ????		26 bf	    var1315    =	$26BF
   1217  28000 ????		26 c0	    var1316    =	$26C0
   1218  28000 ????		26 c1	    var1317    =	$26C1
   1219  28000 ????		26 c2	    var1318    =	$26C2
   1220  28000 ????		26 c3	    var1319    =	$26C3
   1221  28000 ????		26 c4	    var1320    =	$26C4
   1222  28000 ????		26 c5	    var1321    =	$26C5
   1223  28000 ????		26 c6	    var1322    =	$26C6
   1224  28000 ????		26 c7	    var1323    =	$26C7
   1225  28000 ????		26 c8	    var1324    =	$26C8
   1226  28000 ????		26 c9	    var1325    =	$26C9
   1227  28000 ????		26 ca	    var1326    =	$26CA
   1228  28000 ????		26 cb	    var1327    =	$26CB
   1229  28000 ????		26 cc	    var1328    =	$26CC
   1230  28000 ????		26 cd	    var1329    =	$26CD
   1231  28000 ????		26 ce	    var1330    =	$26CE
   1232  28000 ????		26 cf	    var1331    =	$26CF
   1233  28000 ????		26 d0	    var1332    =	$26D0
   1234  28000 ????		26 d1	    var1333    =	$26D1
   1235  28000 ????		26 d2	    var1334    =	$26D2
   1236  28000 ????		26 d3	    var1335    =	$26D3
   1237  28000 ????		26 d4	    var1336    =	$26D4
   1238  28000 ????		26 d5	    var1337    =	$26D5
   1239  28000 ????		26 d6	    var1338    =	$26D6
   1240  28000 ????		26 d7	    var1339    =	$26D7
   1241  28000 ????		26 d8	    var1340    =	$26D8
   1242  28000 ????		26 d9	    var1341    =	$26D9
   1243  28000 ????		26 da	    var1342    =	$26DA
   1244  28000 ????		26 db	    var1343    =	$26DB
   1245  28000 ????		26 dc	    var1344    =	$26DC
   1246  28000 ????		26 dd	    var1345    =	$26DD
   1247  28000 ????		26 de	    var1346    =	$26DE
   1248  28000 ????		26 df	    var1347    =	$26DF
   1249  28000 ????		26 e0	    var1348    =	$26E0
   1250  28000 ????		26 e1	    var1349    =	$26E1
   1251  28000 ????		26 e2	    var1350    =	$26E2
   1252  28000 ????		26 e3	    var1351    =	$26E3
   1253  28000 ????		26 e4	    var1352    =	$26E4
   1254  28000 ????		26 e5	    var1353    =	$26E5
   1255  28000 ????		26 e6	    var1354    =	$26E6
   1256  28000 ????		26 e7	    var1355    =	$26E7
   1257  28000 ????		26 e8	    var1356    =	$26E8
   1258  28000 ????		26 e9	    var1357    =	$26E9
   1259  28000 ????		26 ea	    var1358    =	$26EA
   1260  28000 ????		26 eb	    var1359    =	$26EB
   1261  28000 ????		26 ec	    var1360    =	$26EC
   1262  28000 ????		26 ed	    var1361    =	$26ED
   1263  28000 ????		26 ee	    var1362    =	$26EE
   1264  28000 ????		26 ef	    var1363    =	$26EF
   1265  28000 ????		26 f0	    var1364    =	$26F0
   1266  28000 ????		26 f1	    var1365    =	$26F1
   1267  28000 ????		26 f2	    var1366    =	$26F2
   1268  28000 ????		26 f3	    var1367    =	$26F3
   1269  28000 ????		26 f4	    var1368    =	$26F4
   1270  28000 ????		26 f5	    var1369    =	$26F5
   1271  28000 ????		26 f6	    var1370    =	$26F6
   1272  28000 ????		26 f7	    var1371    =	$26F7
   1273  28000 ????		26 f8	    var1372    =	$26F8
   1274  28000 ????		26 f9	    var1373    =	$26F9
   1275  28000 ????		26 fa	    var1374    =	$26FA
   1276  28000 ????		26 fb	    var1375    =	$26FB
   1277  28000 ????		26 fc	    var1376    =	$26FC
   1278  28000 ????		26 fd	    var1377    =	$26FD
   1279  28000 ????		26 fe	    var1378    =	$26FE
   1280  28000 ????		26 ff	    var1379    =	$26FF
   1281  28000 ????		27 00	    var1380    =	$2700
   1282  28000 ????		27 01	    var1381    =	$2701
   1283  28000 ????		27 02	    var1382    =	$2702
   1284  28000 ????		27 03	    var1383    =	$2703
   1285  28000 ????		27 04	    var1384    =	$2704
   1286  28000 ????		27 05	    var1385    =	$2705
   1287  28000 ????		27 06	    var1386    =	$2706
   1288  28000 ????		27 07	    var1387    =	$2707
   1289  28000 ????		27 08	    var1388    =	$2708
   1290  28000 ????		27 09	    var1389    =	$2709
   1291  28000 ????		27 0a	    var1390    =	$270A
   1292  28000 ????		27 0b	    var1391    =	$270B
   1293  28000 ????		27 0c	    var1392    =	$270C
   1294  28000 ????		27 0d	    var1393    =	$270D
   1295  28000 ????		27 0e	    var1394    =	$270E
   1296  28000 ????		27 0f	    var1395    =	$270F
   1297  28000 ????		27 10	    var1396    =	$2710
   1298  28000 ????		27 11	    var1397    =	$2711
   1299  28000 ????		27 12	    var1398    =	$2712
   1300  28000 ????		27 13	    var1399    =	$2713
   1301  28000 ????		27 14	    var1400    =	$2714
   1302  28000 ????		27 15	    var1401    =	$2715
   1303  28000 ????		27 16	    var1402    =	$2716
   1304  28000 ????		27 17	    var1403    =	$2717
   1305  28000 ????		27 18	    var1404    =	$2718
   1306  28000 ????		27 19	    var1405    =	$2719
   1307  28000 ????		27 1a	    var1406    =	$271A
   1308  28000 ????		27 1b	    var1407    =	$271B
   1309  28000 ????		27 1c	    var1408    =	$271C
   1310  28000 ????		27 1d	    var1409    =	$271D
   1311  28000 ????		27 1e	    var1410    =	$271E
   1312  28000 ????		27 1f	    var1411    =	$271F
   1313  28000 ????		27 20	    var1412    =	$2720
   1314  28000 ????		27 21	    var1413    =	$2721
   1315  28000 ????		27 22	    var1414    =	$2722
   1316  28000 ????		27 23	    var1415    =	$2723
   1317  28000 ????		27 24	    var1416    =	$2724
   1318  28000 ????		27 25	    var1417    =	$2725
   1319  28000 ????		27 26	    var1418    =	$2726
   1320  28000 ????		27 27	    var1419    =	$2727
   1321  28000 ????		27 28	    var1420    =	$2728
   1322  28000 ????		27 29	    var1421    =	$2729
   1323  28000 ????		27 2a	    var1422    =	$272A
   1324  28000 ????		27 2b	    var1423    =	$272B
   1325  28000 ????		27 2c	    var1424    =	$272C
   1326  28000 ????		27 2d	    var1425    =	$272D
   1327  28000 ????		27 2e	    var1426    =	$272E
   1328  28000 ????		27 2f	    var1427    =	$272F
   1329  28000 ????		27 30	    var1428    =	$2730
   1330  28000 ????		27 31	    var1429    =	$2731
   1331  28000 ????		27 32	    var1430    =	$2732
   1332  28000 ????		27 33	    var1431    =	$2733
   1333  28000 ????		27 34	    var1432    =	$2734
   1334  28000 ????		27 35	    var1433    =	$2735
   1335  28000 ????		27 36	    var1434    =	$2736
   1336  28000 ????		27 37	    var1435    =	$2737
   1337  28000 ????		27 38	    var1436    =	$2738
   1338  28000 ????		27 39	    var1437    =	$2739
   1339  28000 ????		27 3a	    var1438    =	$273A
   1340  28000 ????		27 3b	    var1439    =	$273B
   1341  28000 ????		27 3c	    var1440    =	$273C
   1342  28000 ????		27 3d	    var1441    =	$273D
   1343  28000 ????		27 3e	    var1442    =	$273E
   1344  28000 ????		27 3f	    var1443    =	$273F
   1345  28000 ????		27 40	    var1444    =	$2740
   1346  28000 ????		27 41	    var1445    =	$2741
   1347  28000 ????		27 42	    var1446    =	$2742
   1348  28000 ????		27 43	    var1447    =	$2743
   1349  28000 ????		27 44	    var1448    =	$2744
   1350  28000 ????		27 45	    var1449    =	$2745
   1351  28000 ????		27 46	    var1450    =	$2746
   1352  28000 ????		27 47	    var1451    =	$2747
   1353  28000 ????		27 48	    var1452    =	$2748
   1354  28000 ????		27 49	    var1453    =	$2749
   1355  28000 ????		27 4a	    var1454    =	$274A
   1356  28000 ????		27 4b	    var1455    =	$274B
   1357  28000 ????		27 4c	    var1456    =	$274C
   1358  28000 ????		27 4d	    var1457    =	$274D
   1359  28000 ????		27 4e	    var1458    =	$274E
   1360  28000 ????		27 4f	    var1459    =	$274F
   1361  28000 ????		27 50	    var1460    =	$2750
   1362  28000 ????		27 51	    var1461    =	$2751
   1363  28000 ????		27 52	    var1462    =	$2752
   1364  28000 ????		27 53	    var1463    =	$2753
   1365  28000 ????		27 54	    var1464    =	$2754
   1366  28000 ????		27 55	    var1465    =	$2755
   1367  28000 ????		27 56	    var1466    =	$2756
   1368  28000 ????		27 57	    var1467    =	$2757
   1369  28000 ????		27 58	    var1468    =	$2758
   1370  28000 ????		27 59	    var1469    =	$2759
   1371  28000 ????		27 5a	    var1470    =	$275A
   1372  28000 ????		27 5b	    var1471    =	$275B
   1373  28000 ????		27 5c	    var1472    =	$275C
   1374  28000 ????		27 5d	    var1473    =	$275D
   1375  28000 ????		27 5e	    var1474    =	$275E
   1376  28000 ????		27 5f	    var1475    =	$275F
   1377  28000 ????		27 60	    var1476    =	$2760
   1378  28000 ????		27 61	    var1477    =	$2761
   1379  28000 ????		27 62	    var1478    =	$2762
   1380  28000 ????		27 63	    var1479    =	$2763
   1381  28000 ????		27 64	    var1480    =	$2764
   1382  28000 ????		27 65	    var1481    =	$2765
   1383  28000 ????		27 66	    var1482    =	$2766
   1384  28000 ????		27 67	    var1483    =	$2767
   1385  28000 ????		27 68	    var1484    =	$2768
   1386  28000 ????		27 69	    var1485    =	$2769
   1387  28000 ????		27 6a	    var1486    =	$276A
   1388  28000 ????		27 6b	    var1487    =	$276B
   1389  28000 ????		27 6c	    var1488    =	$276C
   1390  28000 ????		27 6d	    var1489    =	$276D
   1391  28000 ????		27 6e	    var1490    =	$276E
   1392  28000 ????		27 6f	    var1491    =	$276F
   1393  28000 ????		27 70	    var1492    =	$2770
   1394  28000 ????		27 71	    var1493    =	$2771
   1395  28000 ????		27 72	    var1494    =	$2772
   1396  28000 ????		27 73	    var1495    =	$2773
   1397  28000 ????		27 74	    var1496    =	$2774
   1398  28000 ????		27 75	    var1497    =	$2775
   1399  28000 ????		27 76	    var1498    =	$2776
   1400  28000 ????		27 77	    var1499    =	$2777
   1401  28000 ????		27 78	    var1500    =	$2778
   1402  28000 ????		27 79	    var1501    =	$2779
   1403  28000 ????		27 7a	    var1502    =	$277A
   1404  28000 ????		27 7b	    var1503    =	$277B
   1405  28000 ????		27 7c	    var1504    =	$277C
   1406  28000 ????		27 7d	    var1505    =	$277D
   1407  28000 ????		27 7e	    var1506    =	$277E
   1408  28000 ????		27 7f	    var1507    =	$277F
   1409  28000 ????		27 80	    var1508    =	$2780
   1410  28000 ????		27 81	    var1509    =	$2781
   1411  28000 ????		27 82	    var1510    =	$2782
   1412  28000 ????		27 83	    var1511    =	$2783
   1413  28000 ????		27 84	    var1512    =	$2784
   1414  28000 ????		27 85	    var1513    =	$2785
   1415  28000 ????		27 86	    var1514    =	$2786
   1416  28000 ????		27 87	    var1515    =	$2787
   1417  28000 ????		27 88	    var1516    =	$2788
   1418  28000 ????		27 89	    var1517    =	$2789
   1419  28000 ????		27 8a	    var1518    =	$278A
   1420  28000 ????		27 8b	    var1519    =	$278B
   1421  28000 ????		27 8c	    var1520    =	$278C
   1422  28000 ????		27 8d	    var1521    =	$278D
   1423  28000 ????		27 8e	    var1522    =	$278E
   1424  28000 ????		27 8f	    var1523    =	$278F
   1425  28000 ????		27 90	    var1524    =	$2790
   1426  28000 ????		27 91	    var1525    =	$2791
   1427  28000 ????		27 92	    var1526    =	$2792
   1428  28000 ????		27 93	    var1527    =	$2793
   1429  28000 ????		27 94	    var1528    =	$2794
   1430  28000 ????		27 95	    var1529    =	$2795
   1431  28000 ????		27 96	    var1530    =	$2796
   1432  28000 ????		27 97	    var1531    =	$2797
   1433  28000 ????		27 98	    var1532    =	$2798
   1434  28000 ????		27 99	    var1533    =	$2799
   1435  28000 ????		27 9a	    var1534    =	$279A
   1436  28000 ????		27 9b	    var1535    =	$279B
   1437  28000 ????		27 9c	    var1536    =	$279C
   1438  28000 ????		27 9d	    var1537    =	$279D
   1439  28000 ????		27 9e	    var1538    =	$279E
   1440  28000 ????		27 9f	    var1539    =	$279F
   1441  28000 ????		27 a0	    var1540    =	$27A0
   1442  28000 ????		27 a1	    var1541    =	$27A1
   1443  28000 ????		27 a2	    var1542    =	$27A2
   1444  28000 ????		27 a3	    var1543    =	$27A3
   1445  28000 ????		27 a4	    var1544    =	$27A4
   1446  28000 ????		27 a5	    var1545    =	$27A5
   1447  28000 ????		27 a6	    var1546    =	$27A6
   1448  28000 ????		27 a7	    var1547    =	$27A7
   1449  28000 ????		27 a8	    var1548    =	$27A8
   1450  28000 ????		27 a9	    var1549    =	$27A9
   1451  28000 ????		27 aa	    var1550    =	$27AA
   1452  28000 ????		27 ab	    var1551    =	$27AB
   1453  28000 ????		27 ac	    var1552    =	$27AC
   1454  28000 ????		27 ad	    var1553    =	$27AD
   1455  28000 ????		27 ae	    var1554    =	$27AE
   1456  28000 ????		27 af	    var1555    =	$27AF
   1457  28000 ????		27 b0	    var1556    =	$27B0
   1458  28000 ????		27 b1	    var1557    =	$27B1
   1459  28000 ????		27 b2	    var1558    =	$27B2
   1460  28000 ????		27 b3	    var1559    =	$27B3
   1461  28000 ????		27 b4	    var1560    =	$27B4
   1462  28000 ????		27 b5	    var1561    =	$27B5
   1463  28000 ????		27 b6	    var1562    =	$27B6
   1464  28000 ????		27 b7	    var1563    =	$27B7
   1465  28000 ????		27 b8	    var1564    =	$27B8
   1466  28000 ????		27 b9	    var1565    =	$27B9
   1467  28000 ????		27 ba	    var1566    =	$27BA
   1468  28000 ????		27 bb	    var1567    =	$27BB
   1469  28000 ????		27 bc	    var1568    =	$27BC
   1470  28000 ????		27 bd	    var1569    =	$27BD
   1471  28000 ????		27 be	    var1570    =	$27BE
   1472  28000 ????		27 bf	    var1571    =	$27BF
   1473  28000 ????		27 c0	    var1572    =	$27C0
   1474  28000 ????		27 c1	    var1573    =	$27C1
   1475  28000 ????		27 c2	    var1574    =	$27C2
   1476  28000 ????		27 c3	    var1575    =	$27C3
   1477  28000 ????		27 c4	    var1576    =	$27C4
   1478  28000 ????		27 c5	    var1577    =	$27C5
   1479  28000 ????		27 c6	    var1578    =	$27C6
   1480  28000 ????		27 c7	    var1579    =	$27C7
   1481  28000 ????		27 c8	    var1580    =	$27C8
   1482  28000 ????		27 c9	    var1581    =	$27C9
   1483  28000 ????		27 ca	    var1582    =	$27CA
   1484  28000 ????		27 cb	    var1583    =	$27CB
   1485  28000 ????		27 cc	    var1584    =	$27CC
   1486  28000 ????		27 cd	    var1585    =	$27CD
   1487  28000 ????		27 ce	    var1586    =	$27CE
   1488  28000 ????		27 cf	    var1587    =	$27CF
   1489  28000 ????		27 d0	    var1588    =	$27D0
   1490  28000 ????		27 d1	    var1589    =	$27D1
   1491  28000 ????		27 d2	    var1590    =	$27D2
   1492  28000 ????		27 d3	    var1591    =	$27D3
   1493  28000 ????		27 d4	    var1592    =	$27D4
   1494  28000 ????		27 d5	    var1593    =	$27D5
   1495  28000 ????		27 d6	    var1594    =	$27D6
   1496  28000 ????		27 d7	    var1595    =	$27D7
   1497  28000 ????		27 d8	    var1596    =	$27D8
   1498  28000 ????		27 d9	    var1597    =	$27D9
   1499  28000 ????		27 da	    var1598    =	$27DA
   1500  28000 ????		27 db	    var1599    =	$27DB
   1501  28000 ????		27 dc	    var1600    =	$27DC
   1502  28000 ????		27 dd	    var1601    =	$27DD
   1503  28000 ????		27 de	    var1602    =	$27DE
   1504  28000 ????		27 df	    var1603    =	$27DF
   1505  28000 ????		27 e0	    var1604    =	$27E0
   1506  28000 ????		27 e1	    var1605    =	$27E1
   1507  28000 ????		27 e2	    var1606    =	$27E2
   1508  28000 ????		27 e3	    var1607    =	$27E3
   1509  28000 ????		27 e4	    var1608    =	$27E4
   1510  28000 ????		27 e5	    var1609    =	$27E5
   1511  28000 ????		27 e6	    var1610    =	$27E6
   1512  28000 ????		27 e7	    var1611    =	$27E7
   1513  28000 ????		27 e8	    var1612    =	$27E8
   1514  28000 ????		27 e9	    var1613    =	$27E9
   1515  28000 ????		27 ea	    var1614    =	$27EA
   1516  28000 ????		27 eb	    var1615    =	$27EB
   1517  28000 ????		27 ec	    var1616    =	$27EC
   1518  28000 ????		27 ed	    var1617    =	$27ED
   1519  28000 ????		27 ee	    var1618    =	$27EE
   1520  28000 ????		27 ef	    var1619    =	$27EF
   1521  28000 ????		27 f0	    var1620    =	$27F0
   1522  28000 ????		27 f1	    var1621    =	$27F1
   1523  28000 ????		27 f2	    var1622    =	$27F2
   1524  28000 ????		27 f3	    var1623    =	$27F3
   1525  28000 ????		27 f4	    var1624    =	$27F4
   1526  28000 ????		27 f5	    var1625    =	$27F5
   1527  28000 ????		27 f6	    var1626    =	$27F6
   1528  28000 ????		27 f7	    var1627    =	$27F7
   1529  28000 ????		27 f8	    var1628    =	$27F8
   1530  28000 ????		27 f9	    var1629    =	$27F9
   1531  28000 ????		27 fa	    var1630    =	$27FA
   1532  28000 ????		27 fb	    var1631    =	$27FB
   1533  28000 ????		27 fc	    var1632    =	$27FC
   1534  28000 ????		27 fd	    var1633    =	$27FD
   1535  28000 ????		27 fe	    var1634    =	$27FE
   1536  28000 ????		27 ff	    var1635    =	$27FF
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
    633  28000 ????
    634  28000 ????						; BEADHEADER... disabled for now
    635  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    636  28000 ????						; For more BEAD executable info, check out the spec...
    637  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  28000 ????
    639  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  28000 ????
    642  28000 ????
    643  28000 ????		00 40	    BDHSC      =	%01000000
    644  28000 ????		00 20	    BDYM       =	%00100000
    645  28000 ????		00 10	    BDPOKEY    =	%00010000
    646  28000 ????		00 08	    BDROF      =	%00001000
    647  28000 ????		00 00	    BD16K      =	%00000000
    648  28000 ????		00 01	    BD32K      =	%00000001
    649  28000 ????		00 02	    BD48K      =	%00000010
    650  28000 ????		00 05	    BD1800     =	%00000101
    651  28000 ????		00 06	    BD4000     =	%00000110
    652  28000 ????
    653  28000 ????			   -	       ifconst	BEADHEADER
    654  28000 ????			   -BEADHARDWARE SET	0
    655  28000 ????			   -	       ifconst	ROM16K
    656  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  28000 ????			   -	       endif
    658  28000 ????			   -	       ifconst	ROM32K
    659  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  28000 ????			   -	       endif
    661  28000 ????			   -	       ifconst	ROM48K
    662  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  28000 ????			   -	       endif
    664  28000 ????			   -	       ifconst	pokeysupport
    665  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  28000 ????			   -	       endif
    667  28000 ????			   -	       ifconst	HSSUPPORT
    668  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  28000 ????			   -	       endif
    670  28000 ????				       endif
    671  28000 ????
    672  28000 ????						;start address of cart...
    673  28000 ????
    674  28000 ????			    BANK_WAS_SET SET	0
    675  28000 ????
    676  28000 ????			   -	       ifconst	ROM8K
    677  28000 ????			   -	       ORG	$E000,0
    678  28000 ????			   -BANK_WAS_SET SET	1
    679  28000 ????				       endif		; ROM8K
    680  28000 ????
    681  28000 ????			   -	       ifconst	ROM16K
    682  28000 ????			   -	       ORG	$C000,0
    683  28000 ????			   -BANK_WAS_SET SET	1
    684  28000 ????			   -	       ifconst	BEADHEADER
    685  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  28000 ????			   -	       CLC
    688  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  28000 ????			   -_SKIPDESCRIPTION
    691  28000 ????			   -	       endif		; GAMEDESCRIPTION
    692  28000 ????			   -	       jmp	($FFFC)
    693  28000 ????			   -	       endif		; BEADHEADER
    694  28000 ????				       endif		; ROM16K
    695  28000 ????
    696  28000 ????			   -	       ifconst	ROM32K
    697  28000 ????			   -	       ORG	$8000,0
    698  28000 ????			   -BANK_WAS_SET SET	1
    699  28000 ????			   -	       ifconst	BEADHEADER
    700  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    701  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    702  28000 ????			   -	       CLC
    703  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    704  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    705  28000 ????			   -_SKIPDESCRIPTION
    706  28000 ????			   -	       endif		; GAMEDESCRIPTION
    707  28000 ????			   -	       jmp	($FFFC)
    708  28000 ????			   -	       endif		; BEADHEADER
    709  28000 ????				       endif		; ROM32K
    710  28000 ????
    711  28000 ????			   -	       ifconst	ROM48K
    712  28000 ????			   -	       ORG	$4000,0
    713  28000 ????			   -BANK_WAS_SET SET	1
    714  28000 ????			   -	       ifconst	BEADHEADER
    715  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    716  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    717  28000 ????			   -	       CLC
    718  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    719  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    720  28000 ????			   -_SKIPDESCRIPTION
    721  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
    722  28000 ????			   -	       jmp	($FFFC)
    723  28000 ????			   -	       endif		; BEADHEADER
    724  28000 ????				       endif		; ROM48K
    725  28000 ????
    726  28000 ????			   -	       ifconst	ROM52K
    727  28000 ????			   -BANK_WAS_SET SET	1
    728  28000 ????			   -	       ORG	$3000,0
    729  28000 ????				       endif		; ROM52K
    730  28000 ????
    731  28000 ????				       ifconst	bankswitchmode
    732  28000 ????			   -	       ifconst	ROMAT4K
    733  28000 ????			   -BANK_WAS_SET SET	1
    734  28000 ????			   -	       ORG	$4000,0
    735  28000 ????			   -	       RORG	$4000
    736  28000 ????				       else		; ROMAT4K
    737  28000 ????			    BANK_WAS_SET SET	1
    738  8000					      ORG	$8000,0
    739  8000					      RORG	$8000
    740  8000					      endif
    741  8000					      endif
    742  8000
    743  8000				  -	      if	BANK_WAS_SET = 0
    744  8000				  -	      ORG	$8000,0	; default is 32K
    745  8000					      endif
    746  8000
    747  8000				   START_OF_ROM SET	.
    748  8000							;7800basic v0.29 Aug  9 2023 20:58:43
    749  8000				   SPACEOVERFLOW SET	0
    750  8000				  -	      ifnconst	SPACEOVERFLOWPASS
    751  8000				  -SPACEOVERFLOWPASS SET	0
    752  8000					      endif	SPACEOVERFLOWPASS
    753  8000				   game
    754  8000				   .L00 		;;  set zoneheight 16
    755  8000
    756  8000				   .L01 		;;  displaymode 160A
    757  8000
    758  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    759  8002		       85 3c		      sta	CTRL
    760  8004
    761  8004		       8d 07 21 	      sta	sCTRL
    762  8007
    763  8007				   .L02 		;;  set plotvalueonscreen on
    764  8007
    765  8007				   .L03 		;;  set romsize 128kRAM
    766  8007
    767  8007				   .L04 		;;  set dlmemory $4000 $7FFF
    768  8007
    769  8007		       40 00	   DLMEMSTART =	$4000
    770  8007		       7f ff	   DLMEMEND   =	$7FFF
    771  8007				   .L05 		;;  doublebuffer on
    772  8007
    773  8007		       a9 01		      lda	#1
    774  8009		       85 d5		      sta	doublebufferstate
    775  800b				   .
    776  800b							;; 
    777  800b
    778  800b				   .L06 		;;  incgraphic font.png 160A 
    779  800b
    780  800b				   .L07 		;;  characterset font
    781  800b
    782  800b		       a9 a0		      lda	#>font
    783  800d		       8d 0b 21 	      sta	sCHARBASE
    784  8010
    785  8010		       85 34		      sta	CHARBASE
    786  8012		       a9 60		      lda	#(font_mode | %01100000)
    787  8014		       8d 06 21 	      sta	charactermode
    788  8017
    789  8017				   .L08 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    790  8017
    791  8017				   .
    792  8017							;; 
    793  8017
    794  8017				   .L09 		;;  rem sprites
    795  8017
    796  8017				   .L010		;;  incgraphic images/player1.png 160A 0 1 3 2
    797  8017
    798  8017				   .L011		;;  incgraphic images/player2.png 160A 0 1 3 2
    799  8017
    800  8017				   .L012		;;  incgraphic images/player3.png 160A 0 1 3 2
    801  8017
    802  8017				   .L013		;;  incgraphic images/player4.png 160A 0 1 3 2
    803  8017
    804  8017				   .L014		;;  incbanner	images/title.png 160B 
    805  8017
    806  8017				   .
    807  8017							;; 
    808  8017
    809  8017				   .L015		;;  BACKGRND = $00
    810  8017
    811  8017		       a9 00		      lda	#$00
    812  8019		       85 20		      sta	BACKGRND
    813  801b				   .
    814  801b							;; 
    815  801b
    816  801b				   .
    817  801b							;; 
    818  801b
    819  801b				   .
    820  801b							;; 
    821  801b
    822  801b				   .L016		;;  dim bgColor  =  var1
    823  801b
    824  801b				   .L017		;;  dim wait  =  var2
    825  801b
    826  801b				   .L018		;;  dim lives	=  var3
    827  801b
    828  801b				   .L019		;;  dim score	=  var4
    829  801b
    830  801b				   .L020		;;  dim playerX  = var5
    831  801b
    832  801b				   .L021		;;  dim playerY  =  var6
    833  801b
    834  801b				   .L022		;;  dim playerAnimFrame  =  var7
    835  801b
    836  801b				   .L023		;;  dim playerAnimWait  =  var8
    837  801b
    838  801b				   .
    839  801b							;; 
    840  801b
    841  801b				   .L024		;;  bgColor  =  $
    842  801b
    843  801b		       a9 00		      lda	#$
    844  801d		       8d 41 01 	      sta	bgColor
    845  8020				   .L025		;;  wait  =  0
    846  8020
    847  8020		       a9 00		      lda	#0
    848  8022		       8d 42 01 	      sta	wait
    849  8025				   .L026		;;  lives  =  0
    850  8025
    851  8025		       a9 00		      lda	#0
    852  8027		       8d 43 01 	      sta	lives
    853  802a				   .L027		;;  score  =  0
    854  802a
    855  802a		       a9 00		      lda	#0
    856  802c		       8d 44 01 	      sta	score
    857  802f				   .L028		;;  playerY  =  0
    858  802f
    859  802f		       a9 00		      lda	#0
    860  8031		       8d 46 01 	      sta	playerY
    861  8034				   .L029		;;  playerX  =  0
    862  8034
    863  8034		       a9 00		      lda	#0
    864  8036		       8d 45 01 	      sta	playerX
    865  8039				   .L030		;;  playerAnimFrame  =  0
    866  8039
    867  8039		       a9 00		      lda	#0
    868  803b		       8d 47 01 	      sta	playerAnimFrame
    869  803e				   .L031		;;  playerAnimWait  =	0
    870  803e
    871  803e		       a9 00		      lda	#0
    872  8040		       8d 48 01 	      sta	playerAnimWait
    873  8043				   .
    874  8043							;; 
    875  8043
    876  8043				   .L032		;;  BACKGRND  =  $00
    877  8043
    878  8043		       a9 00		      lda	#$00
    879  8045		       85 20		      sta	BACKGRND
    880  8047				   .
    881  8047							;; 
    882  8047
    883  8047				   ._setTitleColors
    884  8047							;; _setTitleColors
    885  8047
    886  8047				   .L033		;;  P0C1  =  title_color1
    887  8047
    888  8047		       a9 91		      lda	#title_color1
    889  8049		       85 21		      sta	P0C1
    890  804b				   .L034		;;  P0C2  =  title_color2
    891  804b
    892  804b		       a9 a5		      lda	#title_color2
    893  804d		       85 22		      sta	P0C2
    894  804f				   .L035		;;  P0C3  =  title_color3
    895  804f
    896  804f		       a9 a6		      lda	#title_color3
    897  8051		       85 23		      sta	P0C3
    898  8053				   .L036		;;  P1C1  =  title_color4
    899  8053
    900  8053		       a9 91		      lda	#title_color4
    901  8055		       85 25		      sta	P1C1
    902  8057				   .L037		;;  P1C2  =  title_color5
    903  8057
    904  8057		       a9 aa		      lda	#title_color5
    905  8059		       85 26		      sta	P1C2
    906  805b				   .L038		;;  P1C3  =  title_color6
    907  805b
    908  805b		       a9 92		      lda	#title_color6
    909  805d		       85 27		      sta	P1C3
    910  805f				   .L039		;;  P2C1  =  title_color7
    911  805f
    912  805f		       a9 ab		      lda	#title_color7
    913  8061		       85 29		      sta	P2C1
    914  8063				   .L040		;;  P2C2  =  title_color8
    915  8063
    916  8063		       a9 93		      lda	#title_color8
    917  8065		       85 2a		      sta	P2C2
    918  8067				   .L041		;;  P2C3  =  title_color9
    919  8067
    920  8067		       a9 a4		      lda	#title_color9
    921  8069		       85 2b		      sta	P2C3
    922  806b				   .L042		;;  P3C1  =  title_color10
    923  806b
    924  806b		       a9 a7		      lda	#title_color10
    925  806d		       85 2d		      sta	P3C1
    926  806f				   .L043		;;  P3C2  =  title_color11
    927  806f
    928  806f		       a9 a9		      lda	#title_color11
    929  8071		       85 2e		      sta	P3C2
    930  8073				   .L044		;;  P3C3  =  title_color12
    931  8073
    932  8073		       a9 a8		      lda	#title_color12
    933  8075		       85 2f		      sta	P3C3
    934  8077				   .
    935  8077							;; 
    936  8077
    937  8077				   .
    938  8077							;; 
    939  8077
    940  8077				   ._titleLoop
    941  8077							;; _titleLoop
    942  8077
    943  8077				   .L045		;;  clearscreen
    944  8077
    945  8077		       20 87 f0 	      jsr	clearscreen
    946  807a				   .L046		;;  plotbanner title 0 32 50
    947  807a
    948  807a		       a9 00		      lda	#(0)
    949  807c		       85 44		      sta	temp3
    950  807e
    951  807e		       a9 20		      lda	#32
    952  8080		       85 45		      sta	temp4
    953  8082
    954  8082		       a9 32		      lda	#50
    955  8084
    956  8084		       85 46		      sta	temp5
    957  8086
    958  8086		       a9 c0		      lda	#(title00_mode|%01000000)
    959  8088		       85 47		      sta	temp6
    960  808a
    961  808a		       a9 45		      lda	#<(title00 + 0)
    962  808c		       85 42		      sta	temp1
    963  808e
    964  808e		       a9 a0		      lda	#>(title00 + 0)
    965  8090		       85 43		      sta	temp2
    966  8092
    967  8092		       20 fa f2 	      jsr	plotsprite
    968  8095		       18		      clc
    969  8096		       a9 10		      lda	#16
    970  8098		       65 46		      adc	temp5
    971  809a		       85 46		      sta	temp5
    972  809c		       a9 75		      lda	#<(title01 + 0)
    973  809e		       85 42		      sta	temp1
    974  80a0
    975  80a0		       a9 a0		      lda	#>(title01 + 0)
    976  80a2		       85 43		      sta	temp2
    977  80a4
    978  80a4		       20 fa f2 	      jsr	plotsprite
    979  80a7		       a9 10		      lda	#(0|title00_width_twoscompliment)
    980  80a9		       85 44		      sta	temp3
    981  80ab
    982  80ab		       a9 20		      lda	#32
    983  80ad		       18		      clc
    984  80ae		       69 40		      adc	#64
    985  80b0		       85 45		      sta	temp4
    986  80b2
    987  80b2		       a9 32		      lda	#50
    988  80b4
    989  80b4		       85 46		      sta	temp5
    990  80b6
    991  80b6		       a9 c0		      lda	#(title00_mode|%01000000)
    992  80b8		       85 47		      sta	temp6
    993  80ba
    994  80ba		       a9 65		      lda	#<(title00 + 32)
    995  80bc		       85 42		      sta	temp1
    996  80be
    997  80be		       a9 a0		      lda	#>(title00 + 32)
    998  80c0		       85 43		      sta	temp2
    999  80c2
   1000  80c2		       20 fa f2 	      jsr	plotsprite
   1001  80c5		       18		      clc
   1002  80c6		       a9 10		      lda	#16
   1003  80c8		       65 46		      adc	temp5
   1004  80ca		       85 46		      sta	temp5
   1005  80cc		       a9 95		      lda	#<(title01 + 32)
   1006  80ce		       85 42		      sta	temp1
   1007  80d0
   1008  80d0		       a9 a0		      lda	#>(title01 + 32)
   1009  80d2		       85 43		      sta	temp2
   1010  80d4
   1011  80d4		       20 fa f2 	      jsr	plotsprite
   1012  80d7				   .
   1013  80d7							;; 
   1014  80d7
   1015  80d7				   .L047		;;  plotchars 'quantum^lay^over' 3 47 6
   1016  80d7
   1017  80d7		       4c ea 80 	      JMP	skipalphadata0
   1018  80da				   alphadata0
   1019  80da		       1a		      .byte.b	(<font + $1a)
   1020  80db		       1e		      .byte.b	(<font + $1e)
   1021  80dc		       0a		      .byte.b	(<font + $0a)
   1022  80dd		       17		      .byte.b	(<font + $17)
   1023  80de		       1d		      .byte.b	(<font + $1d)
   1024  80df		       1e		      .byte.b	(<font + $1e)
   1025  80e0		       16		      .byte.b	(<font + $16)
   1026  80e1		       34		      .byte.b	(<font + $34)
   1027  80e2		       15		      .byte.b	(<font + $15)
   1028  80e3		       0a		      .byte.b	(<font + $0a)
   1029  80e4		       22		      .byte.b	(<font + $22)
   1030  80e5		       34		      .byte.b	(<font + $34)
   1031  80e6		       18		      .byte.b	(<font + $18)
   1032  80e7		       1f		      .byte.b	(<font + $1f)
   1033  80e8		       0e		      .byte.b	(<font + $0e)
   1034  80e9		       1b		      .byte.b	(<font + $1b)
   1035  80ea				   skipalphadata0
   1036  80ea		       a9 10		      lda	#16	; width in two's complement
   1037  80ec		       09 60		      ora	#96	; palette left shifted 5 bits
   1038  80ee		       85 44		      sta	temp3
   1039  80f0		       a9 da		      lda	#<alphadata0
   1040  80f2		       85 42		      sta	temp1
   1041  80f4
   1042  80f4		       a9 80		      lda	#>alphadata0
   1043  80f6		       85 43		      sta	temp2
   1044  80f8
   1045  80f8		       a9 2f		      lda	#47
   1046  80fa		       85 45		      sta	temp4
   1047  80fc
   1048  80fc		       a9 06		      lda	#6
   1049  80fe
   1050  80fe		       85 46		      sta	temp5
   1051  8100
   1052  8100		       20 bd f3 	      jsr	plotcharacters
   1053  8103				   .L048		;;  plotchars 'fire^to^start' 2 54 10
   1054  8103
   1055  8103		       4c 13 81 	      JMP	skipalphadata1
   1056  8106				   alphadata1
   1057  8106		       0f		      .byte.b	(<font + $0f)
   1058  8107		       12		      .byte.b	(<font + $12)
   1059  8108		       1b		      .byte.b	(<font + $1b)
   1060  8109		       0e		      .byte.b	(<font + $0e)
   1061  810a		       34		      .byte.b	(<font + $34)
   1062  810b		       1d		      .byte.b	(<font + $1d)
   1063  810c		       18		      .byte.b	(<font + $18)
   1064  810d		       34		      .byte.b	(<font + $34)
   1065  810e		       1c		      .byte.b	(<font + $1c)
   1066  810f		       1d		      .byte.b	(<font + $1d)
   1067  8110		       0a		      .byte.b	(<font + $0a)
   1068  8111		       1b		      .byte.b	(<font + $1b)
   1069  8112		       1d		      .byte.b	(<font + $1d)
   1070  8113				   skipalphadata1
   1071  8113		       a9 13		      lda	#19	; width in two's complement
   1072  8115		       09 40		      ora	#64	; palette left shifted 5 bits
   1073  8117		       85 44		      sta	temp3
   1074  8119		       a9 06		      lda	#<alphadata1
   1075  811b		       85 42		      sta	temp1
   1076  811d
   1077  811d		       a9 81		      lda	#>alphadata1
   1078  811f		       85 43		      sta	temp2
   1079  8121
   1080  8121		       a9 36		      lda	#54
   1081  8123		       85 45		      sta	temp4
   1082  8125
   1083  8125		       a9 0a		      lda	#10
   1084  8127
   1085  8127		       85 46		      sta	temp5
   1086  8129
   1087  8129		       20 bd f3 	      jsr	plotcharacters
   1088  812c				   .L049		;;  if joy0fire0  ||  joy0fire1 then goto _initGame
   1089  812c
   1090  812c		       2c 02 21 	      bit	sINPT1
   1091  812f		       50 03		      bvc	.skipL049
   1092  8131				   .condpart0
   1093  8131		       4c 39 81 	      jmp	.condpart1
   1094  8134				   .skipL049
   1095  8134		       2c 02 21 	      bit	sINPT1
   1096  8137		       10 03		      bpl	.skip0OR
   1097  8139				   .condpart1
   1098  8139		       4c 42 81 	      jmp	._initGame
   1099  813c
   1100  813c				   .skip0OR
   1101  813c				   .
   1102  813c							;; 
   1103  813c
   1104  813c				   .L050		;;  drawscreen
   1105  813c
   1106  813c		       20 c3 f0 	      jsr	drawscreen
   1107  813f				   .
   1108  813f							;; 
   1109  813f
   1110  813f				   .L051		;;  goto _titleLoop
   1111  813f
   1112  813f		       4c 77 80 	      jmp	._titleLoop
   1113  8142
   1114  8142				   .
   1115  8142							;; 
   1116  8142
   1117  8142				   .
   1118  8142							;; 
   1119  8142
   1120  8142				   ._initGame
   1121  8142							;; _initGame
   1122  8142
   1123  8142				   .L052		;;  lives  =  3
   1124  8142
   1125  8142		       a9 03		      lda	#3
   1126  8144		       8d 43 01 	      sta	lives
   1127  8147				   .L053		;;  score  =  0
   1128  8147
   1129  8147		       a9 00		      lda	#0
   1130  8149		       8d 44 01 	      sta	score
   1131  814c				   .L054		;;  BACKGRND = $00
   1132  814c
   1133  814c		       a9 00		      lda	#$00
   1134  814e		       85 20		      sta	BACKGRND
   1135  8150				   .L055		;;  playerX  =  70
   1136  8150
   1137  8150		       a9 46		      lda	#70
   1138  8152		       8d 45 01 	      sta	playerX
   1139  8155				   .L056		;;  playerY  =  90
   1140  8155
   1141  8155		       a9 5a		      lda	#90
   1142  8157		       8d 46 01 	      sta	playerY
   1143  815a				   .L057		;;  playerAnimFrame  =  0
   1144  815a
   1145  815a		       a9 00		      lda	#0
   1146  815c		       8d 47 01 	      sta	playerAnimFrame
   1147  815f				   .L058		;;  playerAnimWait  =	0
   1148  815f
   1149  815f		       a9 00		      lda	#0
   1150  8161		       8d 48 01 	      sta	playerAnimWait
   1151  8164				   .L059		;;  rem pallette 0 text
   1152  8164
   1153  8164				   .L060		;;  P0C1 = $0F
   1154  8164
   1155  8164		       a9 0f		      lda	#$0F
   1156  8166		       85 21		      sta	P0C1
   1157  8168				   .L061		;;  P0C2 = $0C
   1158  8168
   1159  8168		       a9 0c		      lda	#$0C
   1160  816a		       85 22		      sta	P0C2
   1161  816c				   .L062		;;  P0C3 = $0A
   1162  816c
   1163  816c		       a9 0a		      lda	#$0A
   1164  816e		       85 23		      sta	P0C3
   1165  8170				   .
   1166  8170							;; 
   1167  8170
   1168  8170				   .L063		;;  rem pallette 1 player
   1169  8170
   1170  8170				   .L064		;;  P1C1  =  $0D
   1171  8170
   1172  8170		       a9 0d		      lda	#$0D
   1173  8172		       85 25		      sta	P1C1
   1174  8174				   .L065		;;  P1C2  =  $08
   1175  8174
   1176  8174		       a9 08		      lda	#$08
   1177  8176		       85 26		      sta	P1C2
   1178  8178				   .L066		;;  P1C3  =  $33
   1179  8178
   1180  8178		       a9 33		      lda	#$33
   1181  817a		       85 27		      sta	P1C3
   1182  817c				   .
   1183  817c							;; 
   1184  817c
   1185  817c				   .
   1186  817c							;; 
   1187  817c
   1188  817c				   ._gameLoop
   1189  817c							;; _gameLoop
   1190  817c
   1191  817c				   .
   1192  817c							;; 
   1193  817c
   1194  817c				   .L067		;;  clearscreen
   1195  817c
   1196  817c		       20 87 f0 	      jsr	clearscreen
   1197  817f				   .
   1198  817f							;; 
   1199  817f
   1200  817f				   .L068		;;  rem plotchars 'game'  0 68 5
   1201  817f
   1202  817f				   .L069		;;  plotsprite player1 1 playerX playerY playerAnimFrame
   1203  817f
   1204  817f		       a9 35		      lda	#<player1
   1205  8181		       a0 04		      ldy	#player1_width
   1206  8183		       18		      clc
   1207  8184		       f0 06		      beq	plotspritewidthskip2
   1208  8186				   plotspritewidthloop2
   1209  8186		       6d 47 01 	      adc	playerAnimFrame
   1210  8189		       88		      dey
   1211  818a		       d0 fa		      bne	plotspritewidthloop2
   1212  818c				   plotspritewidthskip2
   1213  818c		       85 42		      sta	temp1
   1214  818e
   1215  818e		       a9 a0		      lda	#>player1
   1216  8190		       85 43		      sta	temp2
   1217  8192
   1218  8192		       a9 3c		      lda	#(32|player1_width_twoscompliment)
   1219  8194		       85 44		      sta	temp3
   1220  8196
   1221  8196		       ad 45 01 	      lda	playerX
   1222  8199		       85 45		      sta	temp4
   1223  819b
   1224  819b		       ad 46 01 	      lda	playerY
   1225  819e		       85 46		      sta	temp5
   1226  81a0
   1227  81a0		       a9 40		      lda	#(player1_mode|%01000000)
   1228  81a2		       85 47		      sta	temp6
   1229  81a4
   1230  81a4		       20 fa f2 	      jsr	plotsprite
   1231  81a7				   .L070		;;  playerAnimWait  =	playerAnimWait	+ 1
   1232  81a7
   1233  81a7		       ad 48 01 	      lda	playerAnimWait
   1234  81aa		       18		      CLC
   1235  81ab		       69 01		      ADC	#1
   1236  81ad		       8d 48 01 	      sta	playerAnimWait
   1237  81b0				   .L071		;;  if playerAnimWait	>  2 then playerAnimFrame  =  playerAnimFrame  +  1  :	playerAnimWait	=  0
   1238  81b0
   1239  81b0		       a9 02		      lda	#2
   1240  81b2		       cd 48 01 	      cmp	playerAnimWait
   1241  81b5		       b0 0e		      bcs	.skipL071
   1242  81b7				   .condpart2
   1243  81b7		       ad 47 01 	      lda	playerAnimFrame
   1244  81ba		       18		      CLC
   1245  81bb		       69 01		      ADC	#1
   1246  81bd		       8d 47 01 	      sta	playerAnimFrame
   1247  81c0		       a9 00		      lda	#0
   1248  81c2		       8d 48 01 	      sta	playerAnimWait
   1249  81c5				   .skipL071
   1250  81c5				   .L072		;;  if playerAnimFrame  >  3 then playerAnimFrame  =  0
   1251  81c5
   1252  81c5		       a9 03		      lda	#3
   1253  81c7		       cd 47 01 	      cmp	playerAnimFrame
   1254  81ca		       b0 05		      bcs	.skipL072
   1255  81cc				   .condpart3
   1256  81cc		       a9 00		      lda	#0
   1257  81ce		       8d 47 01 	      sta	playerAnimFrame
   1258  81d1				   .skipL072
   1259  81d1				   .
   1260  81d1							;; 
   1261  81d1
   1262  81d1				   .L073		;;  if joy0left then playerX = playerX  -  1
   1263  81d1
   1264  81d1		       2c 31 21 	      bit	sSWCHA
   1265  81d4		       70 09		      bvs	.skipL073
   1266  81d6				   .condpart4
   1267  81d6		       ad 45 01 	      lda	playerX
   1268  81d9		       38		      SEC
   1269  81da		       e9 01		      SBC	#1
   1270  81dc		       8d 45 01 	      sta	playerX
   1271  81df				   .skipL073
   1272  81df				   .L074		;;  if joy0right then playerX = playerX  +  1
   1273  81df
   1274  81df		       2c 31 21 	      bit	sSWCHA
   1275  81e2		       30 09		      bmi	.skipL074
   1276  81e4				   .condpart5
   1277  81e4		       ad 45 01 	      lda	playerX
   1278  81e7		       18		      CLC
   1279  81e8		       69 01		      ADC	#1
   1280  81ea		       8d 45 01 	      sta	playerX
   1281  81ed				   .skipL074
   1282  81ed				   .L075		;;  if joy0up then playerY = playerY  -  1
   1283  81ed
   1284  81ed		       a9 10		      lda	#$10
   1285  81ef		       2c 31 21 	      bit	sSWCHA
   1286  81f2		       d0 09		      bne	.skipL075
   1287  81f4				   .condpart6
   1288  81f4		       ad 46 01 	      lda	playerY
   1289  81f7		       38		      SEC
   1290  81f8		       e9 01		      SBC	#1
   1291  81fa		       8d 46 01 	      sta	playerY
   1292  81fd				   .skipL075
   1293  81fd				   .L076		;;  if joy0down then playerY = playerY  +  1
   1294  81fd
   1295  81fd		       a9 20		      lda	#$20
   1296  81ff		       2c 31 21 	      bit	sSWCHA
   1297  8202		       d0 09		      bne	.skipL076
   1298  8204				   .condpart7
   1299  8204		       ad 46 01 	      lda	playerY
   1300  8207		       18		      CLC
   1301  8208		       69 01		      ADC	#1
   1302  820a		       8d 46 01 	      sta	playerY
   1303  820d				   .skipL076
   1304  820d				   .
   1305  820d							;; 
   1306  820d
   1307  820d				   .L077		;;  doublebuffer flip 2
   1308  820d
   1309  820d		       20 19 f5 	      jsr	flipdisplaybuffer
   1310  8210		       a9 02		      lda	#2
   1311  8212		       8d b3 01 	      sta	doublebufferminimumframetarget
   1312  8215				   .
   1313  8215							;; 
   1314  8215
   1315  8215				   .L078		;;  goto _gameLoop
   1316  8215		       4c 7c 81 	      jmp	._gameLoop
   1317  8215				   DMAHOLEEND0 SET	.
   1318  8218				   gameend
   1319  8218				   DMAHOLEEND0 SET	.
   7656 bytes of ROM space left in the main area of bank 1.
   1320  8218					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   1321  8218				  -	      if	($A000 - .) < 0
   1322  8218				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   1323  8218					      endif
   1324  8218				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   1325  8218				  -	      .byte	0
   1326  8218					      endif
   1327  8218				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   1328  8218
   1329  a000					      ORG	$A000,0	; *************
   1330  a000
   1331  a000					      RORG	$A000	; *************
   1332  a000
   1333  a000		       a0 00	   font       =	$A000
   1334  a000
   1335  a000				   font
   1336  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1337  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1338  a020		       a0 35	   player1    =	$A035
   1339  a035
   1340  a035				   player1
   1341  a035		       00 00 00 00	      HEX	00000000
   1342  a035		       a0 39	   player2    =	$A039
   1343  a039
   1344  a039				   player2
   1345  a039		       00 00 00 00	      HEX	00000000
   1346  a039		       a0 3d	   player3    =	$A03D
   1347  a03d
   1348  a03d				   player3
   1349  a03d		       00 00 00 00	      HEX	00000000
   1350  a03d		       a0 41	   player4    =	$A041
   1351  a041
   1352  a041				   player4
   1353  a041		       00 00 00 00	      HEX	00000000
   1354  a041		       a0 45	   title00    =	$A045
   1355  a045
   1356  a045				   title00
   1357  a045		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0c0000030f0f0c0000000
   1358  a065		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f0c0
   1359  a065		       a0 75	   title01    =	$A075
   1360  a075
   1361  a075				   title01
   1362  a075		       00 00 55 55*	      HEX	0000555555555555555555550000115500555555440000000000001155555500
   1363  a095		       55 44 55 55*	      HEX	55445555554400000000000000005544
   1364  a0a5
   1365  a100					      ORG	$A100,0	; *************
   1366  a100
   1367  a100					      RORG	$A100	; *************
   1368  a100
   1369  a100							;font
   1370  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1371  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1372  a135							;player1
   1373  a135		       00 00 00 00	      HEX	00000000
   1374  a139							;player2
   1375  a139		       00 00 00 00	      HEX	00000000
   1376  a13d							;player3
   1377  a13d		       00 00 00 00	      HEX	00000000
   1378  a141							;player4
   1379  a141		       00 00 00 00	      HEX	00000000
   1380  a145							;title00
   1381  a145		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1382  a165		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1383  a175							;title01
   1384  a175		       00 55 55 55*	      HEX	0055555555555555555555550000115500555555550000000000005555555500
   1385  a195		       55 44 55 55*	      HEX	55445555554400000000000000005544
   1386  a1a5
   1387  a200					      ORG	$A200,0	; *************
   1388  a200
   1389  a200					      RORG	$A200	; *************
   1390  a200
   1391  a200							;font
   1392  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1393  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1394  a235							;player1
   1395  a235		       00 00 00 00	      HEX	00000000
   1396  a239							;player2
   1397  a239		       00 00 00 00	      HEX	00000000
   1398  a23d							;player3
   1399  a23d		       00 00 00 00	      HEX	00000000
   1400  a241							;player4
   1401  a241		       00 00 00 00	      HEX	00000000
   1402  a245							;title00
   1403  a245		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   1404  a265		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000135f5f5f
   1405  a275							;title01
   1406  a275		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1407  a295		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1408  a2a5
   1409  a300					      ORG	$A300,0	; *************
   1410  a300
   1411  a300					      RORG	$A300	; *************
   1412  a300
   1413  a300							;font
   1414  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1415  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1416  a335							;player1
   1417  a335		       00 00 00 00	      HEX	00000000
   1418  a339							;player2
   1419  a339		       00 00 00 00	      HEX	00000000
   1420  a33d							;player3
   1421  a33d		       00 00 00 00	      HEX	00000000
   1422  a341							;player4
   1423  a341		       00 00 00 00	      HEX	00000000
   1424  a345							;title00
   1425  a345		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   1426  a365		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000005f5f5f
   1427  a375							;title01
   1428  a375		       31 f5 f5 f5*	      HEX	31f5f5f5f5f5f5f5f5f5f5f5f5c400000031f5f5f5c40000000031f5f5f5c400
   1429  a395		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   1430  a3a5
   1431  a400					      ORG	$A400,0	; *************
   1432  a400
   1433  a400					      RORG	$A400	; *************
   1434  a400
   1435  a400							;font
   1436  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1437  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1438  a435							;player1
   1439  a435		       00 00 00 00	      HEX	00000000
   1440  a439							;player2
   1441  a439		       00 00 00 00	      HEX	00000000
   1442  a43d							;player3
   1443  a43d		       00 00 00 00	      HEX	00000000
   1444  a441							;player4
   1445  a441		       00 00 00 00	      HEX	00000000
   1446  a445							;title00
   1447  a445		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1448  a465		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1449  a475							;title01
   1450  a475		       f5 f5 f5 f5*	      HEX	f5f5f5f5f5f5f5f5f5f5f5f5f5f500000031f5f5f5c40000000031f5f5f5c400
   1451  a495		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   1452  a4a5
   1453  a500					      ORG	$A500,0	; *************
   1454  a500
   1455  a500					      RORG	$A500	; *************
   1456  a500
   1457  a500							;font
   1458  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1459  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1460  a535							;player1
   1461  a535		       00 00 00 00	      HEX	00000000
   1462  a539							;player2
   1463  a539		       00 00 00 00	      HEX	00000000
   1464  a53d							;player3
   1465  a53d		       00 00 00 00	      HEX	00000000
   1466  a541							;player4
   1467  a541		       00 00 00 00	      HEX	00000000
   1468  a545							;title00
   1469  a545		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffcc33ffffcc00000000
   1470  a565		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   1471  a575							;title01
   1472  a575		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1473  a595		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1474  a5a5
   1475  a600					      ORG	$A600,0	; *************
   1476  a600
   1477  a600					      RORG	$A600	; *************
   1478  a600
   1479  a600							;font
   1480  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1481  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1482  a635							;player1
   1483  a635		       00 00 00 00	      HEX	00000000
   1484  a639							;player2
   1485  a639		       00 00 00 00	      HEX	00000000
   1486  a63d							;player3
   1487  a63d		       00 00 00 00	      HEX	00000000
   1488  a641							;player4
   1489  a641		       00 00 00 00	      HEX	00000000
   1490  a645							;title00
   1491  a645		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffffffffffcc00000000
   1492  a665		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   1493  a675							;title01
   1494  a675		       aa aa aa aa*	      HEX	aaaaaaaaaa00000000aaaaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   1495  a695		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   1496  a6a5
   1497  a700					      ORG	$A700,0	; *************
   1498  a700
   1499  a700					      RORG	$A700	; *************
   1500  a700
   1501  a700							;font
   1502  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1503  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1504  a735							;player1
   1505  a735		       0f 57 d4 00	      HEX	0f57d400
   1506  a739							;player2
   1507  a739		       07 d5 f4 00	      HEX	07d5f400
   1508  a73d							;player3
   1509  a73d		       05 f5 7c 00	      HEX	05f57c00
   1510  a741							;player4
   1511  a741		       0d 7d 5c 00	      HEX	0d7d5c00
   1512  a745							;title00
   1513  a745		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1514  a765		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1515  a775							;title01
   1516  a775		       aa aa aa aa*	      HEX	aaaaaaaa000000000000aaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   1517  a795		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   1518  a7a5
   1519  a800					      ORG	$A800,0	; *************
   1520  a800
   1521  a800					      RORG	$A800	; *************
   1522  a800
   1523  a800							;font
   1524  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1525  a820		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   1526  a835							;player1
   1527  a835		       15 55 55 00	      HEX	15555500
   1528  a839							;player2
   1529  a839		       15 55 55 00	      HEX	15555500
   1530  a83d							;player3
   1531  a83d		       15 55 55 00	      HEX	15555500
   1532  a841							;player4
   1533  a841		       15 55 55 00	      HEX	15555500
   1534  a845							;title00
   1535  a845		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   1536  a865		       00 00 af af*	      HEX	0000afafaf8c00000000000000afafaf
   1537  a875							;title01
   1538  a875		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1539  a895		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1540  a8a5
   1541  a900					      ORG	$A900,0	; *************
   1542  a900
   1543  a900					      RORG	$A900	; *************
   1544  a900
   1545  a900							;font
   1546  a900		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   1547  a920		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   1548  a935							;player1
   1549  a935		       55 55 55 40	      HEX	55555540
   1550  a939							;player2
   1551  a939		       55 55 55 40	      HEX	55555540
   1552  a93d							;player3
   1553  a93d		       55 55 55 40	      HEX	55555540
   1554  a941							;player4
   1555  a941		       55 55 55 40	      HEX	55555540
   1556  a945							;title00
   1557  a945		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   1558  a965		       00 00 af af*	      HEX	0000afafaf8c00000000000023afafaf
   1559  a975							;title01
   1560  a975		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafac8000032fafafac80000
   1561  a995		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   1562  a9a5
   1563  aa00					      ORG	$AA00,0	; *************
   1564  aa00
   1565  aa00					      RORG	$AA00	; *************
   1566  aa00
   1567  aa00							;font
   1568  aa00		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   1569  aa20		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   1570  aa35							;player1
   1571  aa35		       00 00 00 00	      HEX	00000000
   1572  aa39							;player2
   1573  aa39		       00 00 00 00	      HEX	00000000
   1574  aa3d							;player3
   1575  aa3d		       a8 2a 0a 80	      HEX	a82a0a80
   1576  aa41							;player4
   1577  aa41		       00 00 00 00	      HEX	00000000
   1578  aa45							;title00
   1579  aa45		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1580  aa65		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1581  aa75							;title01
   1582  aa75		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafafafafafafafafac80000
   1583  aa95		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   1584  aaa5
   1585  ab00					      ORG	$AB00,0	; *************
   1586  ab00
   1587  ab00					      RORG	$AB00	; *************
   1588  ab00
   1589  ab00							;font
   1590  ab00		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   1591  ab20		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   1592  ab35							;player1
   1593  ab35		       ff ff ff c0	      HEX	ffffffc0
   1594  ab39							;player2
   1595  ab39		       ab ea fa 80	      HEX	abeafa80
   1596  ab3d							;player3
   1597  ab3d		       ff ff ff c0	      HEX	ffffffc0
   1598  ab41							;player4
   1599  ab41		       ff ff ff c0	      HEX	ffffffc0
   1600  ab45							;title00
   1601  ab45		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   1602  ab65		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a5a5
   1603  ab75							;title01
   1604  ab75		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1605  ab95		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1606  aba5
   1607  ac00					      ORG	$AC00,0	; *************
   1608  ac00
   1609  ac00					      RORG	$AC00	; *************
   1610  ac00
   1611  ac00							;font
   1612  ac00		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   1613  ac20		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   1614  ac35							;player1
   1615  ac35		       a8 2a 0a 80	      HEX	a82a0a80
   1616  ac39							;player2
   1617  ac39		       00 00 00 00	      HEX	00000000
   1618  ac3d							;player3
   1619  ac3d		       00 00 00 00	      HEX	00000000
   1620  ac41							;player4
   1621  ac41		       00 00 00 00	      HEX	00000000
   1622  ac45							;title00
   1623  ac45		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   1624  ac65		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a584
   1625  ac75							;title01
   1626  ac75		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   1627  ac95		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0800000
   1628  aca5
   1629  ad00					      ORG	$AD00,0	; *************
   1630  ad00
   1631  ad00					      RORG	$AD00	; *************
   1632  ad00
   1633  ad00							;font
   1634  ad00		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   1635  ad20		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   1636  ad35							;player1
   1637  ad35		       55 55 55 40	      HEX	55555540
   1638  ad39							;player2
   1639  ad39		       55 55 55 40	      HEX	55555540
   1640  ad3d							;player3
   1641  ad3d		       55 55 55 40	      HEX	55555540
   1642  ad41							;player4
   1643  ad41		       55 55 55 40	      HEX	55555540
   1644  ad45							;title00
   1645  ad45		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1646  ad65		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1647  ad75							;title01
   1648  ad75		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   1649  ad95		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0a08000
   1650  ada5
   1651  ae00					      ORG	$AE00,0	; *************
   1652  ae00
   1653  ae00					      RORG	$AE00	; *************
   1654  ae00
   1655  ae00							;font
   1656  ae00		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   1657  ae20		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   1658  ae35							;player1
   1659  ae35		       15 55 55 00	      HEX	15555500
   1660  ae39							;player2
   1661  ae39		       15 55 55 00	      HEX	15555500
   1662  ae3d							;player3
   1663  ae3d		       15 55 55 00	      HEX	15555500
   1664  ae41							;player4
   1665  ae41		       15 55 55 00	      HEX	15555500
   1666  ae45							;title00
   1667  ae45		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a00000000000000005a5a5a5a000000000000
   1668  ae65		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a5a00
   1669  ae75							;title01
   1670  ae75		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1671  ae95		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1672  aea5
   1673  af00					      ORG	$AF00,0	; *************
   1674  af00
   1675  af00					      RORG	$AF00	; *************
   1676  af00
   1677  af00							;font
   1678  af00		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   1679  af20		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   1680  af35							;player1
   1681  af35		       05 f5 7c 00	      HEX	05f57c00
   1682  af39							;player2
   1683  af39		       07 d5 f4 00	      HEX	07d5f400
   1684  af3d							;player3
   1685  af3d		       0f 57 d4 00	      HEX	0f57d400
   1686  af41							;player4
   1687  af41		       0d 5f 5c 00	      HEX	0d5f5c00
   1688  af45							;title00
   1689  af45		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a0000000000000000125a5a48000000000000
   1690  af65		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a0000
   1691  af75							;title01
   1692  af75		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0f0f0f0f0f0f0c0000000
   1693  af95		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f000
   1694  afa5
   1695  b000					      ORG	$B000,0	; *************
   1696  b000
   1697  b000					      RORG	$B000	; *************
   1698  b000				  -	      if	SPACEOVERFLOW > 0
   1699  b000				  -	      echo	""
   1700  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   1701  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   1702  b000				  -	      echo	"######## Aborting assembly."
   1703  b000				  -SET	      SPACEOVERFLOWPASS	= (SPACEOVERFLOWPASS + 1)
   1704  b000				  -	      if	SPACEOVERFLOWPASS > 0
   1705  b000				  -	      ERR
   1706  b000				  -	      endif
   1707  b000					      endif
   1708  b000
   1709  b000
   1710  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1711  b000
   1712  b000				  -	      ifnconst	bankswitchmode
   1713  b000				  -	      if	( * < $f000 )
   1714  b000				  -	      ORG	$F000
   1715  b000				  -	      endif
   1716  b000					      else
   1717  b000					      ifconst	ROM128K
   1718  b000					      if	( * < $f000 )
   1719  27000					       ORG	$27000
   1720  27000					       RORG	$F000
   1721  27000					       endif
   1722  27000					       endif
   1723  27000				   -	       ifconst	ROM144K
   1724  27000				   -	       if	( * < $f000 )
   1725  27000				   -	       ORG	$27000
   1726  27000				   -	       RORG	$F000
   1727  27000				   -	       endif
   1728  27000					       endif
   1729  27000				   -	       ifconst	ROM256K
   1730  27000				   -	       if	( * < $f000 )
   1731  27000				   -	       ORG	$47000
   1732  27000				   -	       RORG	$F000
   1733  27000				   -	       endif
   1734  27000					       endif
   1735  27000				   -	       ifconst	ROM272K
   1736  27000				   -	       if	( * < $f000 )
   1737  27000				   -	       ORG	$47000
   1738  27000				   -	       RORG	$F000
   1739  27000				   -	       endif
   1740  27000					       endif
   1741  27000				   -	       ifconst	ROM512K
   1742  27000				   -	       if	( * < $f000 )
   1743  27000				   -	       ORG	$87000
   1744  27000				   -	       RORG	$F000
   1745  27000				   -	       endif
   1746  27000					       endif
   1747  27000				   -	       ifconst	ROM528K
   1748  27000				   -	       if	( * < $f000 )
   1749  27000				   -	       ORG	$87000
   1750  27000				   -	       RORG	$F000
   1751  27000				   -	       endif
   1752  27000					       endif
   1753  27000					       endif
   1754  27000
   1755  27000							; all of these "modules" have conditional clauses in them, so even though
   1756  27000							; they're always included here, they don't take up rom unless the user
   1757  27000							; explicitly enables support for the feature.
   1758  27000
   1759  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* More small changes were made to use this code with 7800basic, and
     15  27000				   -			;* comments by VinsCool on more recent versions were back-ported.
     16  27000				   -			;* --Mike Saarna.
     17  27000				   -			;*
     18  27000				   -			;* Warnings:
     19  27000				   -			;*
     20  27000				   -			;* 1. RMT player routine needs 19 dedicated zero page bytes, as well as cca
     21  27000				   -			;* 1KB of memory before the "PLAYER" address for frequency tables and
     22  27000				   -			;* functionary variables. It's:
     23  27000				   -			;* a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     24  27000				   -			;* b) from PLAYER-$380 to PLAYER for mono RMTplayer
     25  27000				   -			;*
     26  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER
     27  27000				   -			;* points to the start of the frequency tables. The player routines follows
     28  27000				   -			;* after that. The variables are now independent and can be located with
     29  27000				   -			;* PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     30  27000				   -			;*
     31  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled aligned to a memory page.
     32  27000				   -			;* i.e. "PLAYER" address can be $..00 only!
     33  27000				   -			;*
     34  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of
     35  27000				   -			;* CPU time.
     36  27000				   -			;*
     37  27000				   -			;*
     38  27000				   -			;* Define the following equates here or in your main code file.
     39  27000				   -			;* Set the values according to the system you compile for.
     40  27000				   -			;*
     41  27000				   -
     42  27000				   -POKEY_BASE equ	pokeyaddress
     43  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	;* player routine needs 19 bytes
     44  27000				   -			;* of zero page RAM
     45  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;* variables in main RAM - 173 bytes
     46  27000				   -			;* mono - 337 stereo
     47  27000				   -
     48  27000				   -ROM_BASED  equ	1	;* using a ROM based system - no self modifying code
     49  27000				   -STEREO8T   equ	0	;* 0 => compile RMTplayer for mono 4 tracks
     50  27000				   -			; ;1 => compile RMTplayer for stereo 8 tracks
     51  27000				   -
     52  27000				   -HARD_OF_HEARING equ	1	;* repeat output to pokey
     53  27000				   -
     54  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     55  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     56  27000				   -
     57  27000				   -			;*
     58  27000				   -
     59  27000				   -	       IF	STEREO8T
     60  27000				   -TRACKS     equ	8
     61  27000				   -	       ELSE
     62  27000				   -TRACKS     equ	4
     63  27000				   -	       ENDIF
     64  27000				   -
     65  27000				   -			;*
     66  27000				   -			;* RMT FEATures definitions
     67  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     68  27000				   -			;* --------BEGIN--------
     69  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     70  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page)
     71  27000				   -			;* and quicker whole RMT routine
     72  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     73  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     74  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     75  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     76  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     77  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     78  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     79  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     80  27000				   -			;* PORTAMENTO
     81  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     82  27000				   -			;* FILTER
     83  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     84  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     85  27000				   -FEAT_FILTERG1L equ	1
     86  27000				   -FEAT_FILTERG0R equ	1
     87  27000				   -FEAT_FILTERG1R equ	1
     88  27000				   -			;* BASS16B (i.e. distortion value 6)
     89  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and
     90  27000				   -			;* quicker whole RMT routine
     91  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     92  27000				   -FEAT_BASS16G3L equ	1
     93  27000				   -FEAT_BASS16G1R equ	1
     94  27000				   -FEAT_BASS16G3R equ	1
     95  27000				   -			;* VOLUME ONLY for particular generators
     96  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     97  27000				   -FEAT_VOLUMEONLYG2L equ	1
     98  27000				   -FEAT_VOLUMEONLYG3L equ	1
     99  27000				   -FEAT_VOLUMEONLYG0R equ	1
    100  27000				   -FEAT_VOLUMEONLYG2R equ	1
    101  27000				   -FEAT_VOLUMEONLYG3R equ	1
    102  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
    103  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
    104  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
    105  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
    106  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
    107  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
    108  27000				   -			;* --------END--------
    109  27000				   -			;*
    110  27000				   -			;*
    111  27000				   -			;* RMT ZeroPage addresses
    112  27000				   -
    113  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    114  27000				   -p_tis      =	MEMLOC
    115  27000				   -p_instrstable =	MEMLOC
    116  27000				   -MEMLOC     SET	(MEMLOC+2)
    117  27000				   -ptrTracksTblLo =	MEMLOC
    118  27000				   -MEMLOC     SET	(MEMLOC+2)
    119  27000				   -ptrTracksTblHi =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+2)
    121  27000				   -ptrSongLines =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+2)
    123  27000				   -
    124  27000				   -_ns        =	MEMLOC
    125  27000				   -MEMLOC     SET	(MEMLOC+2)
    126  27000				   -_nr        =	MEMLOC
    127  27000				   -MEMLOC     SET	(MEMLOC+2)
    128  27000				   -_nt        =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+2)
    130  27000				   -
    131  27000				   -rmtreg1    =	MEMLOC
    132  27000				   -MEMLOC     SET	(MEMLOC+1)
    133  27000				   -rmtreg2    =	MEMLOC
    134  27000				   -MEMLOC     SET	(MEMLOC+1)
    135  27000				   -rmtreg3    =	MEMLOC
    136  27000				   -MEMLOC     SET	(MEMLOC+1)
    137  27000				   -_tmp       =	MEMLOC
    138  27000				   -MEMLOC     SET	(MEMLOC+1)
    139  27000				   -	       IF	FEAT_COMMAND2
    140  27000				   -frqaddcmd2 =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+1)
    142  27000				   -	       ENDIF
    143  27000				   -
    144  27000				   -			;*
    145  27000				   -			;* Variables in main RAM used by player routine.
    146  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    147  27000				   -			;*
    148  27000				   -
    149  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    150  27000				   -track_variables =	MEMLOC
    151  27000				   -
    152  27000				   -trackn_TblLo =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_TblHi =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -trackn_idx =	MEMLOC
    157  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    158  27000				   -trackn_pause =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_note =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_volume =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_distor =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_shiftfrq =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -
    169  27000				   -	       IF	FEAT_PORTAMENTO
    170  27000				   -trackn_portafrqc =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_portafrqa =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_portaspeed =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_portaspeeda =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_portadepth =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -	       ENDIF
    181  27000				   -
    182  27000				   -trackn_instrx2 =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_instrdb =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_instrhb =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_instridx =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_instrlen =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_instrlop =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_instrreachend =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_volumeslidedepth =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_volumeslidevalue =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_volumemin =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -trackn_effdelay =	MEMLOC
    203  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    204  27000				   -trackn_effvibratoa =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -trackn_effvibratobeg =	MEMLOC
    207  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    208  27000				   -trackn_effvibratoend =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -trackn_effshift =	MEMLOC
    211  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    212  27000				   -trackn_tabletypespeed =	MEMLOC
    213  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    214  27000				   -
    215  27000				   -	       IF	FEAT_TABLEMODE
    216  27000				   -trackn_tablemode =	MEMLOC
    217  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    218  27000				   -	       ENDIF
    219  27000				   -
    220  27000				   -trackn_tablenote =	MEMLOC
    221  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    222  27000				   -
    223  27000				   -trackn_tablea =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -trackn_tableend =	MEMLOC
    226  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    227  27000				   -trackn_tablelop =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -trackn_tablespeeda =	MEMLOC
    230  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    231  27000				   -trackn_command =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -
    234  27000				   -	       IF	FEAT_BASS16
    235  27000				   -trackn_outnote =	MEMLOC
    236  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    237  27000				   -	       ENDIF
    238  27000				   -	       IF	FEAT_FILTER
    239  27000				   -trackn_filter =	MEMLOC
    240  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    241  27000				   -	       ENDIF
    242  27000				   -
    243  27000				   -trackn_audf =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    245  27000				   -trackn_audc =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    247  27000				   -
    248  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    249  27000				   -trackn_audctl =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    251  27000				   -	       ENDIF
    252  27000				   -
    253  27000				   -v_audctl   =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_audctl2  =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_speed    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -v_aspeed   =	MEMLOC
    260  27000				   -MEMLOC     SET	(MEMLOC+1)
    261  27000				   -v_bspeed   =	MEMLOC
    262  27000				   -MEMLOC     SET	(MEMLOC+1)
    263  27000				   -v_instrspeed =	MEMLOC
    264  27000				   -MEMLOC     SET	(MEMLOC+1)
    265  27000				   -smc_silence_instrspeed =	MEMLOC
    266  27000				   -MEMLOC     SET	(MEMLOC+1)
    267  27000				   -v_maxtracklen =	MEMLOC
    268  27000				   -MEMLOC     SET	(MEMLOC+1)
    269  27000				   -v_abeat    =	MEMLOC
    270  27000				   -MEMLOC     SET	(MEMLOC+1)
    271  27000				   -
    272  27000				   -track_endvariables =	MEMLOC
    273  27000				   -
    274  27000				   -			;*
    275  27000				   -			;* Data tables used by player routine.
    276  27000				   -			;*
    277  27000				   -	       ALIGN	256
    278  27000				   -PLAYER     =	.
    279  27000				   -
    280  27000				   -volumetab
    281  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    282  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    283  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    284  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    285  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    286  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    287  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    288  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    289  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    290  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    291  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    292  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    293  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    294  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    295  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    296  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    297  27000				   -
    298  27000				   -frqtab
    299  27000				   -			; ERT [<frqtab]!=0 ;* frqtab must begin at the memory page bound!
    300  27000				   -			;* (i.e. $..00 address)
    301  27000				   -frqtabbass1
    302  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    303  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    304  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    305  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    306  27000				   -frqtabbass2
    307  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    308  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    309  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    310  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    311  27000				   -frqtabpure
    312  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    313  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    314  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    315  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    316  27000				   -	       IF	FEAT_BASS16
    317  27000				   -frqtabbasshi
    318  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    319  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    320  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    321  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    322  27000				   -	       ENDIF
    323  27000				   -
    324  27000				   -	       IF	FEAT_BASS16
    325  27000				   -frqtabbasslo
    326  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    327  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    328  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    329  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    330  27000				   -	       ENDIF
    331  27000				   -
    332  27000				   -	       IF	ROM_BASED
    333  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    334  27000				   -	       ENDIF
    335  27000				   -INSTRPAR   equ	12
    336  27000				   -tabbeganddistor
    337  27000				   -	       dc.b	frqtabpure-frqtab,$00
    338  27000				   -	       dc.b	frqtabpure-frqtab,$20
    339  27000				   -	       dc.b	frqtabpure-frqtab,$40
    340  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    341  27000				   -	       dc.b	frqtabpure-frqtab,$80
    342  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    343  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    344  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    345  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    346  27000				   -vib0       dc.b	0
    347  27000				   -vib1       dc.b	1,-1,-1,1
    348  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    349  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    350  27000				   -vibx
    351  27000				   -emptytrack
    352  27000				   -	       dc.b	62,0
    353  27000				   -
    354  27000				   -			;*
    355  27000				   -			;* Set of RMT main vectors:
    356  27000				   -			;*
    357  27000				   -RASTERMUSICTRACKER
    358  27000				   -	       jmp	rmt_init	;* Must be run first, to clear memory and initialise
    359  27000				   -			;* the player... Once this is done, run rmt_play
    360  27000				   -			;* afterwards, or Set_Pokey if you want to manually
    361  27000				   -			;* time certain things.
    362  27000				   -
    363  27000				   -	       jmp	rmt_play	;* One play each subroutine call. SetPokey is
    364  27000				   -			;* executed first, then all the play code is ran
    365  27000				   -			;* once, until the RTS. rmt_play could be called
    366  27000				   -			;* multiple times per frame if wanted.
    367  27000				   -
    368  27000				   -	       jmp	rmt_p3	;* Similar to rmt_play, but will also skip SetPokey
    369  27000				   -			;* and the instruments/songlines/tracklines
    370  27000				   -			;* initialisation, very useful for playing simple
    371  27000				   -			;* things.
    372  27000				   -
    373  27000				   -	       jmp	rmt_silence	;* Run this to stop the driver, and reset all POKEY
    374  27000				   -			;* registers to 0. This is also part of rmt_init
    375  27000				   -			;* when it is executed first.
    376  27000				   -
    377  27000				   -	       jmp	SetPokey	;* Run to copy the contents of the Shadow POKEY
    378  27000				   -			;* registers (v_audctl, v_skctl, trackn_audf,x etc)
    379  27000				   -			;* into the real ones. Will be run first each time
    380  27000				   -			;* rmt_play is called.
    381  27000				   -rmt_init
    382  27000				   -	       stx	_ns
    383  27000				   -	       sty	_ns+1
    384  27000				   -	       pha
    385  27000				   -	       IF	track_endvariables-track_variables>255
    386  27000				   -	       ldy	#0
    387  27000				   -	       tya
    388  27000				   -ri_clear_loop
    389  27000				   -	       sta	track_variables,y
    390  27000				   -	       sta	track_endvariables-$100,y
    391  27000				   -	       iny
    392  27000				   -	       bne	ri_clear_loop
    393  27000				   -	       ELSE
    394  27000				   -	       ldy	#track_endvariables-track_variables
    395  27000				   -	       lda	#0
    396  27000				   -ri_clear_loop
    397  27000				   -	       sta	track_variables-1,y
    398  27000				   -	       dey
    399  27000				   -	       bne	ri_clear_loop
    400  27000				   -	       ENDIF
    401  27000				   -			;* Parse the RMT module data
    402  27000				   -			;* Track length: +4
    403  27000				   -	       ldy	#4
    404  27000				   -	       lda	(_ns),y
    405  27000				   -	       sta	v_maxtracklen	;* Change the code to store the track length
    406  27000				   -	       iny
    407  27000				   -	       lda	(_ns),y
    408  27000				   -	       sta	v_speed	;* Change the code to store the song speed
    409  27000				   -	       iny
    410  27000				   -	       lda	(_ns),y
    411  27000				   -	       sta	v_instrspeed	;* Change the code to store the instrument speed
    412  27000				   -	       sta	smc_silence_instrspeed
    413  27000				   -
    414  27000				   -			; Copy 4 pointers: +8
    415  27000				   -			; -> InstrumentPtrs[]	       2 bytes
    416  27000				   -			; -> TracksPtrsLow[]	       2 bytes
    417  27000				   -			; -> TracksPtrsHi	       2 bytes
    418  27000				   -			; -> SongData		       2 bytes
    419  27000				   -	       ldy	#8
    420  27000				   -ri_copy_loop
    421  27000				   -	       lda	(_ns),y
    422  27000				   -	       sta	p_tis-8,y
    423  27000				   -	       iny
    424  27000				   -	       cpy	#8+8	;* we started at 8, so loop until 16
    425  27000				   -	       bne	ri_copy_loop
    426  27000				   -
    427  27000				   -	       pla
    428  27000				   -	       pha
    429  27000				   -	       IF	STEREO8T
    430  27000				   -	       asl
    431  27000				   -	       asl
    432  27000				   -	       asl
    433  27000				   -	       clc
    434  27000				   -	       adc	ptrSongLines
    435  27000				   -	       sta	ptrSongLines
    436  27000				   -	       pla
    437  27000				   -	       and	#$e0
    438  27000				   -	       asl
    439  27000				   -	       rol
    440  27000				   -	       rol
    441  27000				   -	       rol
    442  27000				   -	       ELSE
    443  27000				   -	       asl
    444  27000				   -	       asl
    445  27000				   -	       clc
    446  27000				   -	       adc	ptrSongLines
    447  27000				   -	       sta	ptrSongLines
    448  27000				   -	       pla
    449  27000				   -	       and	#$c0
    450  27000				   -	       asl
    451  27000				   -	       rol
    452  27000				   -	       rol
    453  27000				   -	       ENDIF
    454  27000				   -	       adc	ptrSongLines+1
    455  27000				   -	       sta	ptrSongLines+1
    456  27000				   -
    457  27000				   -	       jsr	GetSongLine
    458  27000				   -
    459  27000				   -	       jsr	GetTrackLine
    460  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    461  27000				   -	       jsr	rmt_silence
    462  27000				   -	       lda	v_instrspeed
    463  27000				   -	       rts
    464  27000				   -
    465  27000				   -rmt_silence
    466  27000				   -	       IF	STEREO8T
    467  27000				   -	       lda	#0
    468  27000				   -	       sta	POKEY_BASE+$08
    469  27000				   -	       sta	POKEY_BASE_S+$08
    470  27000				   -	       ldy	#3
    471  27000				   -	       sty	POKEY_BASE+$0f
    472  27000				   -	       sty	POKEY_BASE_S+$0f
    473  27000				   -	       ldy	#8
    474  27000				   -rmt_silence_loop
    475  27000				   -	       sta	POKEY_BASE+$00,y
    476  27000				   -	       sta	POKEY_BASE_S+$00,y
    477  27000				   -	       dey
    478  27000				   -	       bpl	rmt_silence_loop
    479  27000				   -	       ELSE
    480  27000				   -	       lda	#0
    481  27000				   -	       sta	POKEY_BASE+$08
    482  27000				   -	       ldy	#3
    483  27000				   -	       sty	POKEY_BASE+$0f
    484  27000				   -	       ldy	#8
    485  27000				   -rmt_silence_loop
    486  27000				   -	       sta	POKEY_BASE+$00,y
    487  27000				   -	       dey
    488  27000				   -	       bpl	rmt_silence_loop
    489  27000				   -	       ENDIF
    490  27000				   -	       rts
    491  27000				   -
    492  27000				   -GetSongLine
    493  27000				   -	       ldx	#0
    494  27000				   -	       stx	v_abeat
    495  27000				   -gsl_loop
    496  27000				   -	       ldx	#0
    497  27000				   -gsl_nextSongLine
    498  27000				   -	       txa
    499  27000				   -	       tay
    500  27000				   -	       lda	(ptrSongLines),y
    501  27000				   -	       cmp	#$fe	;* check for "goto line"
    502  27000				   -	       bcs	gsl_GotoOrEmpty	;* and handle it.
    503  27000				   -			;* (A) = Real track #
    504  27000				   -			;* Get the ptr to the track data and store it in ptrTracksTblLo
    505  27000				   -	       tay
    506  27000				   -	       lda	(ptrTracksTblLo),y
    507  27000				   -	       sta	trackn_TblLo,x
    508  27000				   -	       lda	(ptrTracksTblHi),y
    509  27000				   -gsl_initTrack
    510  27000				   -	       sta	trackn_TblHi,x
    511  27000				   -
    512  27000				   -	       lda	#0	;* reset the track index to 0 trackn_idx[x] = 0
    513  27000				   -	       sta	trackn_idx,x
    514  27000				   -
    515  27000				   -	       lda	#1
    516  27000				   -	       sta	trackn_pause,x	;* #1 is a new track, #0 is no new track
    517  27000				   -
    518  27000				   -	       lda	#$80	;* mark that there is no new instrument
    519  27000				   -	       sta	trackn_instrx2,x	;* #$80 is negative, will BMI when encountered,
    520  27000				   -			;* meaning no new instrument initialisation
    521  27000				   -	       inx
    522  27000				   -	       cpx	#TRACKS	;* if x < TRACKS --> gsl_nextSongLine
    523  27000				   -	       bne	gsl_nextSongLine
    524  27000				   -
    525  27000				   -			;* Done with data points of a song line, move to the next line
    526  27000				   -	       lda	ptrSongLines
    527  27000				   -	       clc
    528  27000				   -	       adc	#TRACKS
    529  27000				   -	       sta	ptrSongLines
    530  27000				   -	       bcc	gsl_skipSongHiIncrement
    531  27000				   -	       inc	ptrSongLines+1
    532  27000				   -gsl_skipSongHiIncrement
    533  27000				   -	       rts
    534  27000				   -
    535  27000				   -gsl_GotoOrEmpty
    536  27000				   -			; "cmp #$FE" performed prior to getting here
    537  27000				   -	       beq	gsl_Goto
    538  27000				   -
    539  27000				   -gsl_Empty
    540  27000				   -	       lda	#<emptytrack
    541  27000				   -	       sta	trackn_TblLo,x
    542  27000				   -	       lda	#>emptytrack
    543  27000				   -	       jmp	gsl_initTrack
    544  27000				   -
    545  27000				   -gsl_Goto
    546  27000				   -			; Data format: 0xFE, ???, low, high bytes of ptr to next song line
    547  27000				   -	       ldy	#2
    548  27000				   -	       lda	(ptrSongLines),y
    549  27000				   -	       tax
    550  27000				   -	       iny
    551  27000				   -	       lda	(ptrSongLines),y
    552  27000				   -	       sta	ptrSongLines+1
    553  27000				   -	       stx	ptrSongLines
    554  27000				   -	       jmp	gsl_loop
    555  27000				   -
    556  27000				   -GetTrackLine
    557  27000				   -rmtoo0
    558  27000				   -rmtoo0a
    559  27000				   -	       lda	v_speed
    560  27000				   -	       sta	v_bspeed
    561  27000				   -	       ldx	#0
    562  27000				   -gtl_loopTracks
    563  27000				   -	       lda	trackn_pause,x
    564  27000				   -	       beq	gtl_checkEndOfLoop
    565  27000				   -	       dec	trackn_pause,x
    566  27000				   -	       bne	gtl_checkEndOfLoop
    567  27000				   -	       inc	trackn_pause,x
    568  27000				   -
    569  27000				   -	       lda	trackn_TblLo,x
    570  27000				   -	       sta	_ns
    571  27000				   -	       lda	trackn_TblHi,x
    572  27000				   -	       sta	_ns+1
    573  27000				   -
    574  27000				   -oo1i
    575  27000				   -	       ldy	trackn_idx,x
    576  27000				   -			;* Get a track data point
    577  27000				   -			;* 0 - 60 = Note, instr and volume data
    578  27000				   -			;* 61 - Volume only
    579  27000				   -			;* 62 = Pause/empty line
    580  27000				   -			;* 63 - Speed, go loop or end
    581  27000				   -	       lda	(_ns),y
    582  27000				   -	       sta	rmtreg1
    583  27000				   -	       iny
    584  27000				   -	       lda	(_ns),y
    585  27000				   -	       sta	rmtreg2
    586  27000				   -	       iny
    587  27000				   -	       tya
    588  27000				   -	       sta	trackn_idx,x
    589  27000				   -
    590  27000				   -	       lda	rmtreg1
    591  27000				   -	       and	#$3f
    592  27000				   -	       cmp	#61
    593  27000				   -	       beq	gtl_ProcessVolumeData
    594  27000				   -	       bcs	gtl_Is62or63
    595  27000				   -
    596  27000				   -			;* if we're here it's a note, so store it.
    597  27000				   -	       sta	trackn_note,x
    598  27000				   -	       IF	FEAT_BASS16
    599  27000				   -	       sta	trackn_outnote,x
    600  27000				   -	       ENDIF
    601  27000				   -
    602  27000				   -			;* Process the instrument #
    603  27000				   -	       lda	rmtreg2
    604  27000				   -	       lsr
    605  27000				   -	       and	#$3f*2
    606  27000				   -	       sta	trackn_instrx2,x
    607  27000				   -
    608  27000				   -gtl_ProcessVolumeData
    609  27000				   -	       lda	rmtreg2
    610  27000				   -	       lsr
    611  27000				   -	       ror	rmtreg1
    612  27000				   -	       lsr
    613  27000				   -	       ror	rmtreg1
    614  27000				   -	       lda	rmtreg1
    615  27000				   -	       and	#$f0
    616  27000				   -	       sta	trackn_volume,x
    617  27000				   -gtl_checkEndOfLoop
    618  27000				   -	       inx
    619  27000				   -	       cpx	#TRACKS
    620  27000				   -	       bne	gtl_loopTracks
    621  27000				   -	       lda	v_bspeed
    622  27000				   -	       sta	v_speed
    623  27000				   -	       sta	v_aspeed
    624  27000				   -	       rts
    625  27000				   -
    626  27000				   -gtl_Is62or63
    627  27000				   -	       cmp	#63
    628  27000				   -	       beq	rmtoo63
    629  27000				   -	       lda	rmtreg1
    630  27000				   -	       and	#$c0
    631  27000				   -	       beq	rmtoo62_b
    632  27000				   -	       asl
    633  27000				   -	       rol
    634  27000				   -	       rol
    635  27000				   -	       sta	trackn_pause,x
    636  27000				   -	       dec	trackn_idx,x
    637  27000				   -	       jmp	gtl_checkEndOfLoop
    638  27000				   -
    639  27000				   -rmtoo62_b
    640  27000				   -	       lda	rmtreg2
    641  27000				   -	       sta	trackn_pause,x
    642  27000				   -	       jmp	gtl_checkEndOfLoop
    643  27000				   -
    644  27000				   -rmtoo63
    645  27000				   -	       lda	rmtreg1
    646  27000				   -	       bmi	rmtoo63_1X
    647  27000				   -	       lda	rmtreg2
    648  27000				   -	       sta	v_bspeed
    649  27000				   -	       jmp	oo1i
    650  27000				   -rmtoo63_1X
    651  27000				   -	       cmp	#255
    652  27000				   -	       beq	rmtoo63_11
    653  27000				   -	       lda	rmtreg2
    654  27000				   -	       sta	trackn_idx,x
    655  27000				   -	       jmp	oo1i
    656  27000				   -
    657  27000				   -rmtoo63_11
    658  27000				   -	       jsr	GetSongLine
    659  27000				   -	       jmp	rmtoo0
    660  27000				   -
    661  27000				   -InitOfNewSetInstrumentsOnly
    662  27000				   -	       ldx	#0
    663  27000				   -p2x1       ldy	trackn_instrx2,x
    664  27000				   -	       bmi	p2x2	;* if negative, no new instrument to initialise for this channel
    665  27000				   -	       jsr	SetUpInstrumentY2
    666  27000				   -	       lda	#$80
    667  27000				   -	       sta	trackn_instrx2,x
    668  27000				   -p2x2
    669  27000				   -	       inx
    670  27000				   -	       cpx	#TRACKS
    671  27000				   -	       bne	p2x1
    672  27000				   -	       rts
    673  27000				   -
    674  27000				   -rmt_play
    675  27000				   -rmt_p0
    676  27000				   -	       jsr	SetPokey
    677  27000				   -rmt_p1
    678  27000				   -	       dec	smc_silence_instrspeed
    679  27000				   -	       beq	rmtp1a
    680  27000				   -	       jmp	rmt_p3
    681  27000				   -rmtp1a
    682  27000				   -	       lda	v_instrspeed
    683  27000				   -	       sta	smc_silence_instrspeed
    684  27000				   -rmt_p2
    685  27000				   -	       dec	v_aspeed
    686  27000				   -	       bne	rmt_p3
    687  27000				   -	       inc	v_abeat
    688  27000				   -	       lda	v_abeat
    689  27000				   -	       cmp	v_maxtracklen
    690  27000				   -	       bne	rmtp2o2
    691  27000				   -	       jsr	GetSongLine
    692  27000				   -rmtp2o2
    693  27000				   -	       jsr	GetTrackLine
    694  27000				   -	       jmp	rmt_p2X
    695  27000				   -go_ppnext
    696  27000				   -	       jmp	ppnext
    697  27000				   -rmt_p2X
    698  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    699  27000				   -rmt_p3
    700  27000				   -	       lda	#>frqtab
    701  27000				   -	       sta	_nr+1
    702  27000				   -
    703  27000				   -	       ldx	#0
    704  27000				   -rmtpp1
    705  27000				   -	       lda	trackn_instrhb,x
    706  27000				   -	       beq	go_ppnext
    707  27000				   -	       sta	_ns+1
    708  27000				   -	       lda	trackn_instrdb,x
    709  27000				   -	       sta	_ns
    710  27000				   -	       ldy	trackn_instridx,x
    711  27000				   -	       lda	(_ns),y
    712  27000				   -	       sta	rmtreg1
    713  27000				   -	       iny
    714  27000				   -	       lda	(_ns),y
    715  27000				   -	       sta	rmtreg2
    716  27000				   -	       iny
    717  27000				   -	       lda	(_ns),y
    718  27000				   -	       sta	rmtreg3
    719  27000				   -	       iny
    720  27000				   -	       tya
    721  27000				   -	       cmp	trackn_instrlen,x
    722  27000				   -	       bcc	rmtpp2
    723  27000				   -	       beq	rmtpp2
    724  27000				   -	       lda	#$80
    725  27000				   -	       sta	trackn_instrreachend,x
    726  27000				   -rmtpp1b
    727  27000				   -	       lda	trackn_instrlop,x
    728  27000				   -rmtpp2
    729  27000				   -	       sta	trackn_instridx,x
    730  27000				   -	       lda	rmtreg1
    731  27000				   -	       IF	STEREO8T
    732  27000				   -	       cpx	#4
    733  27000				   -	       bcc	rmtpp2s
    734  27000				   -	       lsr
    735  27000				   -	       lsr
    736  27000				   -	       lsr
    737  27000				   -	       lsr
    738  27000				   -rmtpp2s
    739  27000				   -	       ENDIF
    740  27000				   -	       and	#$0f
    741  27000				   -	       ora	trackn_volume,x
    742  27000				   -	       tay
    743  27000				   -	       lda	volumetab,y
    744  27000				   -	       pha
    745  27000				   -	       lda	rmtreg2
    746  27000				   -	       and	#$0e
    747  27000				   -	       tay
    748  27000				   -	       lda	tabbeganddistor,y
    749  27000				   -	       sta	_nr
    750  27000				   -	       pla
    751  27000				   -	       ora	tabbeganddistor+1,y
    752  27000				   -	       sta	trackn_audc,x
    753  27000				   -	       jmp	InstrumentsEffects
    754  27000				   -returnfromInstrumentsEffects
    755  27000				   -	       IF	FEAT_COMMAND2
    756  27000				   -	       lda	#0
    757  27000				   -	       sta	frqaddcmd2
    758  27000				   -	       ENDIF
    759  27000				   -	       lda	rmtreg2
    760  27000				   -	       sta	trackn_command,x
    761  27000				   -	       and	#$70
    762  27000				   -	       lsr
    763  27000				   -	       lsr
    764  27000				   -	       IF	ROM_BASED
    765  27000				   -	       lsr
    766  27000				   -	       tay
    767  27000				   -	       lda	rts_tab+1,y
    768  27000				   -	       pha
    769  27000				   -	       lda	rts_tab,y
    770  27000				   -	       pha
    771  27000				   -	       rts
    772  27000				   -	       ELSE
    773  27000				   -	       sta	jmx+1
    774  27000				   -jmx
    775  27000				   -	       bcc	*
    776  27000				   -	       jmp	cmd0
    777  27000				   -	       nop
    778  27000				   -	       jmp	cmd1
    779  27000				   -	       nop
    780  27000				   -	       jmp	cmd2
    781  27000				   -	       nop
    782  27000				   -	       jmp	cmd3
    783  27000				   -	       nop
    784  27000				   -	       jmp	cmd4
    785  27000				   -	       nop
    786  27000				   -	       jmp	cmd5
    787  27000				   -	       nop
    788  27000				   -	       jmp	cmd6
    789  27000				   -	       nop
    790  27000				   -	       jmp	cmd7
    791  27000				   -	       ENDIF
    792  27000				   -cmd0
    793  27000				   -	       lda	trackn_note,x
    794  27000				   -	       clc
    795  27000				   -	       adc	rmtreg3
    796  27000				   -cmd0a
    797  27000				   -	       IF	FEAT_TABLETYPE
    798  27000				   -	       ldy	trackn_tabletypespeed,x
    799  27000				   -	       bmi	cmd0b
    800  27000				   -	       ENDIF
    801  27000				   -	       clc
    802  27000				   -	       adc	trackn_tablenote,x
    803  27000				   -	       cmp	#61
    804  27000				   -	       bcc	cmd0a1
    805  27000				   -	       lda	#0
    806  27000				   -	       sta	trackn_audc,x
    807  27000				   -	       lda	#63
    808  27000				   -cmd0a1
    809  27000				   -	       IF	FEAT_BASS16
    810  27000				   -	       sta	trackn_outnote,x
    811  27000				   -	       ENDIF
    812  27000				   -	       tay
    813  27000				   -	       lda	(_nr),y
    814  27000				   -	       clc
    815  27000				   -	       adc	trackn_shiftfrq,x
    816  27000				   -	       IF	FEAT_COMMAND2
    817  27000				   -	       clc
    818  27000				   -	       adc	frqaddcmd2
    819  27000				   -	       ENDIF
    820  27000				   -	       sta	trackn_audf,x
    821  27000				   -	       jmp	rmtpp9
    822  27000				   -	       IF	FEAT_TABLETYPE
    823  27000				   -cmd0b
    824  27000				   -	       cmp	#61
    825  27000				   -	       bcc	cmd0b1
    826  27000				   -	       lda	#0
    827  27000				   -	       sta	trackn_audc,x
    828  27000				   -	       lda	#63
    829  27000				   -cmd0b1
    830  27000				   -	       tay
    831  27000				   -	       lda	trackn_shiftfrq,x
    832  27000				   -	       clc
    833  27000				   -	       adc	trackn_tablenote,x
    834  27000				   -	       clc
    835  27000				   -	       adc	(_nr),y
    836  27000				   -	       IF	FEAT_COMMAND2
    837  27000				   -	       clc
    838  27000				   -	       adc	frqaddcmd2
    839  27000				   -	       ENDIF
    840  27000				   -	       sta	trackn_audf,x
    841  27000				   -	       jmp	rmtpp9
    842  27000				   -	       ENDIF
    843  27000				   -cmd1
    844  27000				   -	       IF	FEAT_COMMAND1
    845  27000				   -	       lda	rmtreg3
    846  27000				   -	       sta	trackn_audf,x
    847  27000				   -	       jmp	rmtpp9
    848  27000				   -	       ENDIF
    849  27000				   -cmd2
    850  27000				   -	       IF	FEAT_COMMAND2
    851  27000				   -	       lda	rmtreg3
    852  27000				   -	       sta	frqaddcmd2
    853  27000				   -	       lda	trackn_note,x
    854  27000				   -	       jmp	cmd0a
    855  27000				   -	       ENDIF
    856  27000				   -cmd3
    857  27000				   -	       IF	FEAT_COMMAND3
    858  27000				   -	       lda	trackn_note,x
    859  27000				   -	       clc
    860  27000				   -	       adc	rmtreg3
    861  27000				   -	       sta	trackn_note,x
    862  27000				   -	       jmp	cmd0a
    863  27000				   -	       ENDIF
    864  27000				   -cmd4
    865  27000				   -	       IF	FEAT_COMMAND4
    866  27000				   -	       lda	trackn_shiftfrq,x
    867  27000				   -	       clc
    868  27000				   -	       adc	rmtreg3
    869  27000				   -	       sta	trackn_shiftfrq,x
    870  27000				   -	       lda	trackn_note,x
    871  27000				   -	       jmp	cmd0a
    872  27000				   -	       ENDIF
    873  27000				   -cmd5
    874  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    875  27000				   -	       IF	FEAT_TABLETYPE
    876  27000				   -	       lda	trackn_tabletypespeed,x
    877  27000				   -	       bpl	cmd5a1
    878  27000				   -	       ldy	trackn_note,x
    879  27000				   -	       lda	(_nr),y
    880  27000				   -	       clc
    881  27000				   -	       adc	trackn_tablenote,x
    882  27000				   -	       jmp	cmd5ax
    883  27000				   -	       ENDIF
    884  27000				   -cmd5a1
    885  27000				   -	       lda	trackn_note,x
    886  27000				   -	       clc
    887  27000				   -	       adc	trackn_tablenote,x
    888  27000				   -	       cmp	#61
    889  27000				   -	       bcc	cmd5a2
    890  27000				   -	       lda	#63
    891  27000				   -cmd5a2
    892  27000				   -	       tay
    893  27000				   -	       lda	(_nr),y
    894  27000				   -cmd5ax
    895  27000				   -	       sta	trackn_portafrqc,x
    896  27000				   -	       ldy	rmtreg3
    897  27000				   -	       bne	cmd5a
    898  27000				   -	       sta	trackn_portafrqa,x
    899  27000				   -cmd5a
    900  27000				   -	       tya
    901  27000				   -	       lsr
    902  27000				   -	       lsr
    903  27000				   -	       lsr
    904  27000				   -	       lsr
    905  27000				   -	       sta	trackn_portaspeed,x
    906  27000				   -	       sta	trackn_portaspeeda,x
    907  27000				   -	       lda	rmtreg3
    908  27000				   -	       and	#$0f
    909  27000				   -	       sta	trackn_portadepth,x
    910  27000				   -	       lda	trackn_note,x
    911  27000				   -	       jmp	cmd0a
    912  27000				   -	       ELSE
    913  27000				   -	       IF	FEAT_COMMAND5
    914  27000				   -	       jmp	rmtpp9
    915  27000				   -	       ENDIF
    916  27000				   -	       ENDIF
    917  27000				   -cmd6
    918  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    919  27000				   -	       lda	rmtreg3
    920  27000				   -	       clc
    921  27000				   -	       adc	trackn_filter,x
    922  27000				   -	       sta	trackn_filter,x
    923  27000				   -	       lda	trackn_note,x
    924  27000				   -	       jmp	cmd0a
    925  27000				   -	       ELSE
    926  27000				   -	       IF	FEAT_COMMAND6
    927  27000				   -	       jmp	rmtpp9
    928  27000				   -	       ENDIF
    929  27000				   -	       ENDIF
    930  27000				   -cmd7
    931  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    932  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    933  27000				   -	       lda	rmtreg3
    934  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    935  27000				   -	       cmp	#$80
    936  27000				   -	       beq	cmd7a
    937  27000				   -	       ENDIF
    938  27000				   -	       sta	trackn_note,x
    939  27000				   -	       jmp	cmd0a
    940  27000				   -	       ENDIF
    941  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    942  27000				   -cmd7a
    943  27000				   -	       lda	trackn_audc,x
    944  27000				   -	       ora	#$f0
    945  27000				   -	       sta	trackn_audc,x
    946  27000				   -	       lda	trackn_note,x
    947  27000				   -	       jmp	cmd0a
    948  27000				   -	       ENDIF
    949  27000				   -	       ENDIF
    950  27000				   -rmtpp9
    951  27000				   -	       IF	FEAT_PORTAMENTO
    952  27000				   -	       lda	trackn_portaspeeda,x
    953  27000				   -	       beq	rmtpp10
    954  27000				   -	       sec
    955  27000				   -	       sbc	#1
    956  27000				   -	       sta	trackn_portaspeeda,x
    957  27000				   -	       bne	rmtpp10
    958  27000				   -	       lda	trackn_portaspeed,x
    959  27000				   -	       sta	trackn_portaspeeda,x
    960  27000				   -	       lda	trackn_portafrqa,x
    961  27000				   -	       cmp	trackn_portafrqc,x
    962  27000				   -	       beq	rmtpp10
    963  27000				   -	       bcs	pps1
    964  27000				   -	       adc	trackn_portadepth,x
    965  27000				   -	       bcs	pps8
    966  27000				   -	       cmp	trackn_portafrqc,x
    967  27000				   -	       bcs	pps8
    968  27000				   -	       jmp	pps9
    969  27000				   -pps1
    970  27000				   -	       sbc	trackn_portadepth,x
    971  27000				   -	       bcc	pps8
    972  27000				   -	       cmp	trackn_portafrqc,x
    973  27000				   -	       bcs	pps9
    974  27000				   -pps8
    975  27000				   -	       lda	trackn_portafrqc,x
    976  27000				   -pps9
    977  27000				   -	       sta	trackn_portafrqa,x
    978  27000				   -rmtpp10
    979  27000				   -	       lda	rmtreg2
    980  27000				   -	       and	#$01
    981  27000				   -	       beq	rmtpp11
    982  27000				   -	       lda	trackn_portafrqa,x
    983  27000				   -	       clc
    984  27000				   -	       adc	trackn_shiftfrq,x
    985  27000				   -	       sta	trackn_audf,x
    986  27000				   -rmtpp11
    987  27000				   -	       ENDIF
    988  27000				   -ppnext
    989  27000				   -	       inx
    990  27000				   -	       cpx	#TRACKS
    991  27000				   -	       beq	rmt_p4
    992  27000				   -	       jmp	rmtpp1
    993  27000				   -rmt_p4
    994  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    995  27000				   -	       ldx	#3
    996  27000				   -	       lda	#0
    997  27000				   -qq0        ora	trackn_audctl,x
    998  27000				   -	       dex
    999  27000				   -	       bpl	qq0
   1000  27000				   -	       sta	v_audctl
   1001  27000				   -qq1
   1002  27000				   -	       ldx	v_audctl
   1003  27000				   -	       ELSE
   1004  27000				   -	       ldx	#0
   1005  27000				   -	       stx	v_audctl
   1006  27000				   -	       ENDIF
   1007  27000				   -	       IF	FEAT_FILTER
   1008  27000				   -	       IF	FEAT_FILTERG0L
   1009  27000				   -	       lda	trackn_command+0
   1010  27000				   -	       bpl	qq2
   1011  27000				   -	       lda	trackn_audc+0
   1012  27000				   -	       and	#$0f
   1013  27000				   -	       beq	qq2
   1014  27000				   -	       lda	trackn_audf+0
   1015  27000				   -	       clc
   1016  27000				   -	       adc	trackn_filter+0
   1017  27000				   -	       sta	trackn_audf+2
   1018  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1019  27000				   -	       lda	trackn_audc+2
   1020  27000				   -	       and	#$10
   1021  27000				   -	       bne	qq1a
   1022  27000				   -	       ENDIF
   1023  27000				   -	       lda	#0
   1024  27000				   -	       sta	trackn_audc+2
   1025  27000				   -qq1a
   1026  27000				   -	       txa
   1027  27000				   -	       ora	#4
   1028  27000				   -	       tax
   1029  27000				   -	       ENDIF
   1030  27000				   -qq2
   1031  27000				   -	       IF	FEAT_FILTERG1L
   1032  27000				   -	       lda	trackn_command+1
   1033  27000				   -	       bpl	qq3
   1034  27000				   -	       lda	trackn_audc+1
   1035  27000				   -	       and	#$0f
   1036  27000				   -	       beq	qq3
   1037  27000				   -	       lda	trackn_audf+1
   1038  27000				   -	       clc
   1039  27000				   -	       adc	trackn_filter+1
   1040  27000				   -	       sta	trackn_audf+3
   1041  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
   1042  27000				   -	       lda	trackn_audc+3
   1043  27000				   -	       and	#$10
   1044  27000				   -	       bne	qq2a
   1045  27000				   -	       ENDIF
   1046  27000				   -	       lda	#0
   1047  27000				   -	       sta	trackn_audc+3
   1048  27000				   -qq2a
   1049  27000				   -	       txa
   1050  27000				   -	       ora	#2
   1051  27000				   -	       tax
   1052  27000				   -	       ENDIF
   1053  27000				   -qq3
   1054  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
   1055  27000				   -	       cpx	v_audctl
   1056  27000				   -	       bne	qq5
   1057  27000				   -	       ENDIF
   1058  27000				   -	       ENDIF
   1059  27000				   -	       IF	FEAT_BASS16
   1060  27000				   -	       IF	FEAT_BASS16G1L
   1061  27000				   -	       lda	trackn_command+1
   1062  27000				   -	       and	#$0e
   1063  27000				   -	       cmp	#6
   1064  27000				   -	       bne	qq4
   1065  27000				   -	       lda	trackn_audc+1
   1066  27000				   -	       and	#$0f
   1067  27000				   -	       beq	qq4
   1068  27000				   -	       ldy	trackn_outnote+1
   1069  27000				   -	       lda	frqtabbasslo,y
   1070  27000				   -	       sta	trackn_audf+0
   1071  27000				   -	       lda	frqtabbasshi,y
   1072  27000				   -	       sta	trackn_audf+1
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
   1074  27000				   -	       lda	trackn_audc+0
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qq3a
   1077  27000				   -	       ENDIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+0
   1080  27000				   -qq3a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#$50
   1083  27000				   -	       tax
   1084  27000				   -	       ENDIF
   1085  27000				   -qq4
   1086  27000				   -	       IF	FEAT_BASS16G3L
   1087  27000				   -	       lda	trackn_command+3
   1088  27000				   -	       and	#$0e
   1089  27000				   -	       cmp	#6
   1090  27000				   -	       bne	qq5
   1091  27000				   -	       lda	trackn_audc+3
   1092  27000				   -	       and	#$0f
   1093  27000				   -	       beq	qq5
   1094  27000				   -	       ldy	trackn_outnote+3
   1095  27000				   -	       lda	frqtabbasslo,y
   1096  27000				   -	       sta	trackn_audf+2
   1097  27000				   -	       lda	frqtabbasshi,y
   1098  27000				   -	       sta	trackn_audf+3
   1099  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1100  27000				   -	       lda	trackn_audc+2
   1101  27000				   -	       and	#$10
   1102  27000				   -	       bne	qq4a
   1103  27000				   -	       ENDIF
   1104  27000				   -	       lda	#0
   1105  27000				   -	       sta	trackn_audc+2
   1106  27000				   -qq4a
   1107  27000				   -	       txa
   1108  27000				   -	       ora	#$28
   1109  27000				   -	       tax
   1110  27000				   -	       ENDIF
   1111  27000				   -	       ENDIF
   1112  27000				   -qq5
   1113  27000				   -	       stx	v_audctl
   1114  27000				   -	       IF	STEREO8T
   1115  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1116  27000				   -	       ldx	#3
   1117  27000				   -	       lda	#0
   1118  27000				   -qs0        ora	trackn_audctl+4,x
   1119  27000				   -	       dex
   1120  27000				   -	       bpl	qs0
   1121  27000				   -	       sta	v_audctl2
   1122  27000				   -qs1
   1123  27000				   -	       ldx	v_audctl2
   1124  27000				   -	       ELSE
   1125  27000				   -	       ldx	#0
   1126  27000				   -	       stx	v_audctl2
   1127  27000				   -	       ENDIF
   1128  27000				   -	       IF	FEAT_FILTER
   1129  27000				   -	       IF	FEAT_FILTERG0R
   1130  27000				   -	       lda	trackn_command+0+4
   1131  27000				   -	       bpl	qs2
   1132  27000				   -	       lda	trackn_audc+0+4
   1133  27000				   -	       and	#$0f
   1134  27000				   -	       beq	qs2
   1135  27000				   -	       lda	trackn_audf+0+4
   1136  27000				   -	       clc
   1137  27000				   -	       adc	trackn_filter+0+4
   1138  27000				   -	       sta	trackn_audf+2+4
   1139  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1140  27000				   -	       lda	trackn_audc+2+4
   1141  27000				   -	       and	#$10
   1142  27000				   -	       bne	qs1a
   1143  27000				   -	       ENDIF
   1144  27000				   -	       lda	#0
   1145  27000				   -	       sta	trackn_audc+2+4
   1146  27000				   -qs1a
   1147  27000				   -	       txa
   1148  27000				   -	       ora	#4
   1149  27000				   -	       tax
   1150  27000				   -	       ENDIF
   1151  27000				   -qs2
   1152  27000				   -	       IF	FEAT_FILTERG1R
   1153  27000				   -	       lda	trackn_command+1+4
   1154  27000				   -	       bpl	qs3
   1155  27000				   -	       lda	trackn_audc+1+4
   1156  27000				   -	       and	#$0f
   1157  27000				   -	       beq	qs3
   1158  27000				   -	       lda	trackn_audf+1+4
   1159  27000				   -	       clc
   1160  27000				   -	       adc	trackn_filter+1+4
   1161  27000				   -	       sta	trackn_audf+3+4
   1162  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1163  27000				   -	       lda	trackn_audc+3+4
   1164  27000				   -	       and	#$10
   1165  27000				   -	       bne	qs2a
   1166  27000				   -	       ENDIF
   1167  27000				   -	       lda	#0
   1168  27000				   -	       sta	trackn_audc+3+4
   1169  27000				   -qs2a
   1170  27000				   -	       txa
   1171  27000				   -	       ora	#2
   1172  27000				   -	       tax
   1173  27000				   -	       ENDIF
   1174  27000				   -qs3
   1175  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1176  27000				   -	       cpx	v_audctl2
   1177  27000				   -	       bne	qs5
   1178  27000				   -	       ENDIF
   1179  27000				   -	       ENDIF
   1180  27000				   -	       IF	FEAT_BASS16
   1181  27000				   -	       IF	FEAT_BASS16G1R
   1182  27000				   -	       lda	trackn_command+1+4
   1183  27000				   -	       and	#$0e
   1184  27000				   -	       cmp	#6
   1185  27000				   -	       bne	qs4
   1186  27000				   -	       lda	trackn_audc+1+4
   1187  27000				   -	       and	#$0f
   1188  27000				   -	       beq	qs4
   1189  27000				   -	       ldy	trackn_outnote+1+4
   1190  27000				   -	       lda	frqtabbasslo,y
   1191  27000				   -	       sta	trackn_audf+0+4
   1192  27000				   -	       lda	frqtabbasshi,y
   1193  27000				   -	       sta	trackn_audf+1+4
   1194  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1195  27000				   -	       lda	trackn_audc+0+4
   1196  27000				   -	       and	#$10
   1197  27000				   -	       bne	qs3a
   1198  27000				   -	       ENDIF
   1199  27000				   -	       lda	#0
   1200  27000				   -	       sta	trackn_audc+0+4
   1201  27000				   -qs3a
   1202  27000				   -	       txa
   1203  27000				   -	       ora	#$50
   1204  27000				   -	       tax
   1205  27000				   -	       ENDIF
   1206  27000				   -qs4
   1207  27000				   -	       IF	FEAT_BASS16G3R
   1208  27000				   -	       lda	trackn_command+3+4
   1209  27000				   -	       and	#$0e
   1210  27000				   -	       cmp	#6
   1211  27000				   -	       bne	qs5
   1212  27000				   -	       lda	trackn_audc+3+4
   1213  27000				   -	       and	#$0f
   1214  27000				   -	       beq	qs5
   1215  27000				   -	       ldy	trackn_outnote+3+4
   1216  27000				   -	       lda	frqtabbasslo,y
   1217  27000				   -	       sta	trackn_audf+2+4
   1218  27000				   -	       lda	frqtabbasshi,y
   1219  27000				   -	       sta	trackn_audf+3+4
   1220  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1221  27000				   -	       lda	trackn_audc+2+4
   1222  27000				   -	       and	#$10
   1223  27000				   -	       bne	qs4a
   1224  27000				   -	       ENDIF
   1225  27000				   -	       lda	#0
   1226  27000				   -	       sta	trackn_audc+2+4
   1227  27000				   -qs4a
   1228  27000				   -	       txa
   1229  27000				   -	       ora	#$28
   1230  27000				   -	       tax
   1231  27000				   -	       ENDIF
   1232  27000				   -	       ENDIF
   1233  27000				   -qs5
   1234  27000				   -	       stx	v_audctl2
   1235  27000				   -	       ENDIF
   1236  27000				   -rmt_p5
   1237  27000				   -	       lda	smc_silence_instrspeed
   1238  27000				   -	       rts
   1239  27000				   -SetPokey
   1240  27000				   -	       IF	STEREO8T
   1241  27000				   -	       ldy	v_audctl2
   1242  27000				   -	       lda	trackn_audf+0+4
   1243  27000				   -	       ldx	trackn_audf+0
   1244  27000				   -	       sta	POKEY_BASE_S+$00
   1245  27000				   -	       stx	POKEY_BASE+$00
   1246  27000				   -	       lda	trackn_audc+0+4
   1247  27000				   -	       ldx	trackn_audc+0
   1248  27000				   -	       sta	POKEY_BASE_S+$01
   1249  27000				   -	       stx	POKEY_BASE+$01
   1250  27000				   -	       lda	trackn_audf+1+4
   1251  27000				   -	       ldx	trackn_audf+1
   1252  27000				   -	       sta	POKEY_BASE_S+$02
   1253  27000				   -	       stx	POKEY_BASE+$02
   1254  27000				   -	       lda	trackn_audc+1+4
   1255  27000				   -	       ldx	trackn_audc+1
   1256  27000				   -	       sta	POKEY_BASE_S+$03
   1257  27000				   -	       stx	POKEY_BASE+$03
   1258  27000				   -	       lda	trackn_audf+2+4
   1259  27000				   -	       ldx	trackn_audf+2
   1260  27000				   -	       sta	POKEY_BASE_S+$04
   1261  27000				   -	       stx	POKEY_BASE+$04
   1262  27000				   -	       lda	trackn_audc+2+4
   1263  27000				   -	       ldx	trackn_audc+2
   1264  27000				   -	       sta	POKEY_BASE_S+$05
   1265  27000				   -	       stx	POKEY_BASE+$05
   1266  27000				   -	       lda	trackn_audf+3+4
   1267  27000				   -	       ldx	trackn_audf+3
   1268  27000				   -	       sta	POKEY_BASE_S+$06
   1269  27000				   -	       stx	POKEY_BASE+$06
   1270  27000				   -	       lda	trackn_audc+3+4
   1271  27000				   -	       ldx	trackn_audc+3
   1272  27000				   -	       sta	POKEY_BASE_S+$07
   1273  27000				   -	       stx	POKEY_BASE+$07
   1274  27000				   -	       lda	v_audctl
   1275  27000				   -	       sty	POKEY_BASE_S+$08
   1276  27000				   -	       sta	POKEY_BASE+$08
   1277  27000				   -	       ELSE
   1278  27000				   -
   1279  27000				   -	       ifconst	RMTVOLUME
   1280  27000				   -	       lda	rmtvolume
   1281  27000				   -	       sta	fourbitfadevalueint
   1282  27000				   -	       endif
   1283  27000				   -	       ldy	v_audctl
   1284  27000				   -	       ldx	trackn_audf+0
   1285  27000				   -	       lda	trackn_audc+0
   1286  27000				   -	       ifconst	RMTVOLUME
   1287  27000				   -	       jsr	fourbitfadeint
   1288  27000				   -	       endif
   1289  27000				   -	       stx	POKEY_BASE+$00+0
   1290  27000				   -	       if	HARD_OF_HEARING
   1291  27000				   -	       stx	POKEY_BASE+$00+0
   1292  27000				   -	       endif
   1293  27000				   -	       sta	POKEY_BASE+$01+0
   1294  27000				   -	       if	HARD_OF_HEARING
   1295  27000				   -	       sta	POKEY_BASE+$01+0
   1296  27000				   -	       endif
   1297  27000				   -
   1298  27000				   -	       ldx	trackn_audf+1
   1299  27000				   -	       lda	trackn_audc+1
   1300  27000				   -	       ifconst	RMTVOLUME
   1301  27000				   -	       jsr	fourbitfadeint
   1302  27000				   -	       endif
   1303  27000				   -	       stx	POKEY_BASE+$00+2
   1304  27000				   -	       if	HARD_OF_HEARING
   1305  27000				   -	       stx	POKEY_BASE+$00+2
   1306  27000				   -	       endif
   1307  27000				   -	       sta	POKEY_BASE+$01+2
   1308  27000				   -	       if	HARD_OF_HEARING
   1309  27000				   -	       sta	POKEY_BASE+$01+2
   1310  27000				   -	       endif
   1311  27000				   -
   1312  27000				   -	       ldx	trackn_audf+2
   1313  27000				   -	       lda	trackn_audc+2
   1314  27000				   -	       ifconst	RMTVOLUME
   1315  27000				   -	       jsr	fourbitfadeint
   1316  27000				   -	       endif
   1317  27000				   -	       stx	POKEY_BASE+$00+4
   1318  27000				   -	       if	HARD_OF_HEARING
   1319  27000				   -	       stx	POKEY_BASE+$00+4
   1320  27000				   -	       endif
   1321  27000				   -	       sta	POKEY_BASE+$01+4
   1322  27000				   -	       if	HARD_OF_HEARING
   1323  27000				   -	       sta	POKEY_BASE+$01+4
   1324  27000				   -	       endif
   1325  27000				   -
   1326  27000				   -	       ldx	trackn_audf+3
   1327  27000				   -	       lda	trackn_audc+3
   1328  27000				   -	       ifconst	RMTVOLUME
   1329  27000				   -	       jsr	fourbitfadeint
   1330  27000				   -	       endif
   1331  27000				   -	       stx	POKEY_BASE+$00+6
   1332  27000				   -	       if	HARD_OF_HEARING
   1333  27000				   -	       stx	POKEY_BASE+$00+6
   1334  27000				   -	       endif
   1335  27000				   -	       sta	POKEY_BASE+$01+6
   1336  27000				   -	       if	HARD_OF_HEARING
   1337  27000				   -	       sta	POKEY_BASE+$01+6
   1338  27000				   -	       endif
   1339  27000				   -
   1340  27000				   -	       sty	POKEY_BASE+$08
   1341  27000				   -	       if	HARD_OF_HEARING
   1342  27000				   -	       sty	POKEY_BASE+$08
   1343  27000				   -	       endif
   1344  27000				   -
   1345  27000				   -	       ENDIF
   1346  27000				   -	       rts
   1347  27000				   -SetUpInstrumentY2
   1348  27000				   -	       lda	(p_instrstable),y
   1349  27000				   -	       sta	trackn_instrdb,x
   1350  27000				   -	       sta	_nt
   1351  27000				   -	       iny
   1352  27000				   -	       lda	(p_instrstable),y
   1353  27000				   -	       sta	trackn_instrhb,x
   1354  27000				   -	       sta	_nt+1
   1355  27000				   -	       ldy	#0
   1356  27000				   -	       lda	(_nt),y
   1357  27000				   -	       sta	trackn_tableend,x
   1358  27000				   -	       clc
   1359  27000				   -	       adc	#1
   1360  27000				   -	       sta	trackn_instridx,x
   1361  27000				   -	       iny
   1362  27000				   -	       lda	(_nt),y
   1363  27000				   -	       sta	trackn_tablelop,x
   1364  27000				   -	       iny
   1365  27000				   -	       lda	(_nt),y
   1366  27000				   -	       sta	trackn_instrlen,x
   1367  27000				   -	       iny
   1368  27000				   -	       lda	(_nt),y
   1369  27000				   -	       sta	trackn_instrlop,x
   1370  27000				   -	       iny
   1371  27000				   -	       lda	(_nt),y
   1372  27000				   -	       sta	trackn_tabletypespeed,x
   1373  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1374  27000				   -	       and	#$3f
   1375  27000				   -	       ENDIF
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -	       IF	FEAT_TABLEMODE
   1378  27000				   -	       lda	(_nt),y
   1379  27000				   -	       and	#$40
   1380  27000				   -	       sta	trackn_tablemode,x
   1381  27000				   -	       ENDIF
   1382  27000				   -	       iny
   1383  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1384  27000				   -	       lda	(_nt),y
   1385  27000				   -	       sta	trackn_audctl,x
   1386  27000				   -	       ENDIF
   1387  27000				   -	       iny
   1388  27000				   -	       lda	(_nt),y
   1389  27000				   -	       sta	trackn_volumeslidedepth,x
   1390  27000				   -	       iny
   1391  27000				   -	       lda	(_nt),y
   1392  27000				   -	       sta	trackn_volumemin,x
   1393  27000				   -	       iny
   1394  27000				   -	       lda	(_nt),y
   1395  27000				   -	       sta	trackn_effdelay,x
   1396  27000				   -	       iny
   1397  27000				   -	       lda	(_nt),y
   1398  27000				   -	       tay
   1399  27000				   -	       lda	vibtabbeg,y
   1400  27000				   -	       sta	trackn_effvibratoa,x
   1401  27000				   -	       sta	trackn_effvibratobeg,x
   1402  27000				   -	       lda	vibtabbeg+1,y
   1403  27000				   -	       sta	trackn_effvibratoend,x
   1404  27000				   -	       ldy	#10
   1405  27000				   -	       lda	(_nt),y
   1406  27000				   -	       sta	trackn_effshift,x
   1407  27000				   -	       lda	#128
   1408  27000				   -	       sta	trackn_volumeslidevalue,x
   1409  27000				   -	       lda	#0
   1410  27000				   -	       sta	trackn_instrreachend,x
   1411  27000				   -	       sta	trackn_shiftfrq,x
   1412  27000				   -	       lda	#INSTRPAR
   1413  27000				   -	       sta	trackn_tablea,x
   1414  27000				   -	       tay
   1415  27000				   -	       lda	(_nt),y
   1416  27000				   -	       sta	trackn_tablenote,x
   1417  27000				   -	       IF	FEAT_FILTER
   1418  27000				   -	       lda	#1
   1419  27000				   -	       sta	trackn_filter,x
   1420  27000				   -	       ENDIF
   1421  27000				   -	       rts
   1422  27000				   -InstrumentsEffects
   1423  27000				   -	       lda	trackn_effdelay,x
   1424  27000				   -	       beq	ei2
   1425  27000				   -	       tay
   1426  27000				   -	       dey
   1427  27000				   -	       bne	ei1
   1428  27000				   -	       lda	trackn_shiftfrq,x
   1429  27000				   -	       clc
   1430  27000				   -	       adc	trackn_effshift,x
   1431  27000				   -	       clc
   1432  27000				   -	       ldy	trackn_effvibratoa,x
   1433  27000				   -	       adc	vib0,y
   1434  27000				   -	       sta	trackn_shiftfrq,x
   1435  27000				   -	       iny
   1436  27000				   -	       tya
   1437  27000				   -	       cmp	trackn_effvibratoend,x
   1438  27000				   -	       bne	ei1a
   1439  27000				   -	       lda	trackn_effvibratobeg,x
   1440  27000				   -ei1a
   1441  27000				   -	       sta	trackn_effvibratoa,x
   1442  27000				   -	       jmp	ei2
   1443  27000				   -ei1
   1444  27000				   -	       tya
   1445  27000				   -	       sta	trackn_effdelay,x
   1446  27000				   -ei2
   1447  27000				   -	       lda	trackn_tableend,x
   1448  27000				   -	       cmp	#INSTRPAR
   1449  27000				   -	       beq	ei3
   1450  27000				   -	       lda	trackn_tablespeeda,x
   1451  27000				   -	       bpl	ei2f
   1452  27000				   -ei2c
   1453  27000				   -	       lda	trackn_tablea,x
   1454  27000				   -	       clc
   1455  27000				   -	       adc	#1
   1456  27000				   -	       cmp	trackn_tableend,x
   1457  27000				   -	       bcc	ei2a
   1458  27000				   -	       beq	ei2a
   1459  27000				   -	       lda	trackn_tablelop,x
   1460  27000				   -ei2a
   1461  27000				   -	       sta	trackn_tablea,x
   1462  27000				   -	       lda	trackn_instrdb,x
   1463  27000				   -	       sta	_nt
   1464  27000				   -	       lda	trackn_instrhb,x
   1465  27000				   -	       sta	_nt+1
   1466  27000				   -	       ldy	trackn_tablea,x
   1467  27000				   -	       lda	(_nt),y
   1468  27000				   -	       IF	FEAT_TABLEMODE
   1469  27000				   -	       ldy	trackn_tablemode,x
   1470  27000				   -	       beq	ei2e
   1471  27000				   -	       clc
   1472  27000				   -	       adc	trackn_tablenote,x
   1473  27000				   -ei2e
   1474  27000				   -	       ENDIF
   1475  27000				   -	       sta	trackn_tablenote,x
   1476  27000				   -	       lda	trackn_tabletypespeed,x
   1477  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1478  27000				   -	       and	#$3f
   1479  27000				   -	       ENDIF
   1480  27000				   -ei2f
   1481  27000				   -	       sec
   1482  27000				   -	       sbc	#1
   1483  27000				   -	       sta	trackn_tablespeeda,x
   1484  27000				   -ei3
   1485  27000				   -	       lda	trackn_instrreachend,x
   1486  27000				   -	       bpl	ei4
   1487  27000				   -	       lda	trackn_volume,x
   1488  27000				   -	       beq	ei4
   1489  27000				   -	       cmp	trackn_volumemin,x
   1490  27000				   -	       beq	ei4
   1491  27000				   -	       bcc	ei4
   1492  27000				   -	       tay
   1493  27000				   -	       lda	trackn_volumeslidevalue,x
   1494  27000				   -	       clc
   1495  27000				   -	       adc	trackn_volumeslidedepth,x
   1496  27000				   -	       sta	trackn_volumeslidevalue,x
   1497  27000				   -	       bcc	ei4
   1498  27000				   -	       tya
   1499  27000				   -	       sbc	#16
   1500  27000				   -	       sta	trackn_volume,x
   1501  27000				   -ei4
   1502  27000				   -	       jmp	returnfromInstrumentsEffects
   1503  27000				   -
   1504  27000				   -rmtmoduleend
   1505  27000				   -	       echo	" (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1506  27000				   -	       echo	" (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1507  27000				   -
   1508  27000					       endif		; RMT
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1761  27000					       endif
   1762  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1764  27000					       endif
   1765  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -	       ifconst	pokeysfxsupport
     19  27000				   -
     20  27000				   -checkpokeyplaying
     21  27000				   -	       ldx	#6
     22  27000				   -checkpokeyplayingloop
     23  27000				   -	       lda	pokey1pointlo,x
     24  27000				   -	       ora	pokey1pointhi,x
     25  27000				   -	       beq	pokeychannelinactive
     26  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     27  27000				   -pokeychannelinactive
     28  27000				   -	       dex
     29  27000				   -	       dex
     30  27000				   -	       bpl	checkpokeyplayingloop
     31  27000				   -	       rts
     32  27000				   -
     33  27000				   -playpokeysfxA
     34  27000				   -	       txa
     35  27000				   -	       tay
     36  27000				   -	       lda	pokey1tick,x
     37  27000				   -	       beq	playpokeysfxAcont
     38  27000				   -	       sec
     39  27000				   -	       sbc	#1
     40  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     41  27000				   -	       rts
     42  27000				   -
     43  27000				   -playpokeysfxAcont
     44  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     45  27000				   -	       sta	pokey1tick,x
     46  27000				   -
     47  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     48  27000				   -	       beq	playpokeysfxAcont2
     49  27000				   -	       sec
     50  27000				   -	       sbc	#1
     51  27000				   -	       sta	pokey1priority,x
     52  27000				   -playpokeysfxAcont2
     53  27000				   -
     54  27000				   -			; *** FREQUENCY
     55  27000				   -	       lda	(pokey1pointlo,x)
     56  27000				   -	       sta	inttemp1
     57  27000				   -	       clc
     58  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     59  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     60  27000				   -
     61  27000				   -			;advance the data pointer +1
     62  27000				   -	       inc	pokey1pointlo,x
     63  27000				   -	       bne	skippokeyhiinc1
     64  27000				   -	       inc	pokey1pointhi,x
     65  27000				   -skippokeyhiinc1
     66  27000				   -
     67  27000				   -			; *** WAVE
     68  27000				   -	       lda	(pokey1pointlo,x)
     69  27000				   -	       asl
     70  27000				   -	       asl
     71  27000				   -	       asl
     72  27000				   -	       asl		; x16
     73  27000				   -
     74  27000				   -			;advance the data pointer +1
     75  27000				   -	       inc	pokey1pointlo,x
     76  27000				   -	       bne	skippokeyhiinc2
     77  27000				   -	       inc	pokey1pointhi,x
     78  27000				   -skippokeyhiinc2
     79  27000				   -
     80  27000				   -	       ora	(pokey1pointlo,x)
     81  27000				   -	       iny
     82  27000				   -	       sta	(pokeybaselo),y
     83  27000				   -
     84  27000				   -	       ora	inttemp1	; check if F|C|V=0
     85  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     86  27000				   -
     87  27000				   -			; advance the pointer +1, on to the next sound chunk
     88  27000				   -	       inc	pokey1pointlo,x
     89  27000				   -	       bne	skippokeyhiinc3
     90  27000				   -	       inc	pokey1pointhi,x
     91  27000				   -skippokeyhiinc3
     92  27000				   -	       rts
     93  27000				   -
     94  27000				   -zeropokeypoint
     95  27000				   -	       sta	pokey1pointlo,x
     96  27000				   -	       sta	pokey1pointhi,x
     97  27000				   -	       sta	pokey1priority,x
     98  27000				   -	       rts
     99  27000				   -
    100  27000				   -schedulepokeysfx
    101  27000				   -	       ldx	#6
    102  27000				   -schedulepokeysfxloop
    103  27000				   -	       lda	pokey1pointlo,x
    104  27000				   -	       ora	pokey1pointhi,x
    105  27000				   -	       bne	schedulespokeysearch
    106  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    107  27000				   -schedulespokeysearch
    108  27000				   -	       dex
    109  27000				   -	       dex
    110  27000				   -	       bpl	schedulepokeysfxloop
    111  27000				   -
    112  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    113  27000				   -	       ldy	#1
    114  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    115  27000				   -	       bne	schedulepokeysfxcont1
    116  27000				   -	       rts		; ...and skip it if it's 0 priority
    117  27000				   -schedulepokeysfxcont1
    118  27000				   -
    119  27000				   -			; figure out which current sound has the lowest priority...
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	temp8
    122  27000				   -	       lda	pokey1priority
    123  27000				   -	       sta	temp9
    124  27000				   -	       ldx	#6
    125  27000				   -findlowprioritypokeyloop
    126  27000				   -	       lda	pokey1priority,x
    127  27000				   -	       cmp	temp9
    128  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    129  27000				   -	       sta	temp9
    130  27000				   -	       stx	temp8
    131  27000				   -findlowprioritypokeyloopcontinue
    132  27000				   -	       dex
    133  27000				   -	       dex
    134  27000				   -	       bne	findlowprioritypokeyloop
    135  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    136  27000				   -
    137  27000				   -schedulepokeyX
    138  27000				   -			;called with X=2*pokey channel to play on...
    139  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    140  27000				   -	       lda	(sfxinstrumentlo),y
    141  27000				   -	       sta	pokey1priority,x
    142  27000				   -	       iny
    143  27000				   -	       lda	(sfxinstrumentlo),y
    144  27000				   -	       sta	pokey1frames,x
    145  27000				   -
    146  27000				   -	       lda	sfxinstrumentlo
    147  27000				   -	       clc
    148  27000				   -	       adc	#3
    149  27000				   -	       sta	pokey1pointlo,x
    150  27000				   -	       lda	sfxinstrumenthi
    151  27000				   -	       adc	#0
    152  27000				   -	       sta	pokey1pointhi,x
    153  27000				   -	       lda	sfxpitchoffset
    154  27000				   -	       sta	pokey1offset,x
    155  27000				   -	       lda	#0
    156  27000				   -	       sta	pokey1tick,x
    157  27000				   -	       rts
    158  27000				   -	       else
    159  27000				   -schedulepokeysfx		; just some stubs
    160  27000				   -checkpokeyplaying
    161  27000				   -	       rts
    162  27000				   -	       endif		; pokeysfxsupport
    163  27000				   -
    164  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    165  27000				   -			; and the standard $4000 location.
    166  27000				   -			; if pokey the pokey is present, this routine will reset it.
    167  27000				   -	       ifconst	pokeyaddress
    168  27000				   -detectpokeylocation
    169  27000				   -	       lda	#<pokeyaddress
    170  27000				   -	       sta	pokeybaselo
    171  27000				   -	       lda	#>pokeyaddress
    172  27000				   -	       sta	pokeybasehi
    173  27000				   -	       lda	#$ff
    174  27000				   -	       sta	pokeydetected
    175  27000				   -
    176  27000				   -	       if	pokeyaddress = $450
    177  27000				   -	       lda	XCTRL1s
    178  27000				   -	       ora	#%00010100
    179  27000				   -	       sta	XCTRL1s
    180  27000				   -	       sta	XCTRL1
    181  27000				   -	       endif
    182  27000				   -
    183  27000				   -
    184  27000				   -	       lda	#0
    185  27000				   -	       ldy	#15
    186  27000				   -clearpokeyloop
    187  27000				   -	       sta	(pokeybase),y
    188  27000				   -	       dey
    189  27000				   -	       bpl	clearpokeyloop
    190  27000				   -			; take pokey out of reset...
    191  27000				   -	       ldy	#PSKCTL
    192  27000				   -	       lda	#3
    193  27000				   -	       sta	(pokeybase),y
    194  27000				   -	       ldy	#PAUDCTL
    195  27000				   -	       lda	#0
    196  27000				   -	       sta	(pokeybase),y
    197  27000				   -	       rts
    198  27000				   -	       else		; !pokeyaddress
    199  27000				   -detectpokeylocation
    200  27000				   -			;XBoard/XM...
    201  27000				   -	       ldx	#2
    202  27000				   -detectpokeyloop
    203  27000				   -	       lda	XCTRL1s
    204  27000				   -	       ora	#%00010100
    205  27000				   -	       and	POKEYXMMASK,x
    206  27000				   -	       sta	XCTRL1s
    207  27000				   -	       sta	XCTRL1
    208  27000				   -
    209  27000				   -	       lda	POKEYCHECKLO,x
    210  27000				   -	       sta	pokeybaselo
    211  27000				   -	       lda	POKEYCHECKHI,x
    212  27000				   -	       sta	pokeybasehi
    213  27000				   -	       jsr	checkforpokey
    214  27000				   -	       lda	pokeydetected
    215  27000				   -	       beq	foundpokeychip
    216  27000				   -	       dex
    217  27000				   -	       bpl	detectpokeyloop
    218  27000				   -foundpokeychip
    219  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    220  27000				   -	       sta	pokeydetected
    221  27000				   -	       rts
    222  27000				   -
    223  27000				   -POKEYXMMASK
    224  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    225  27000				   -	       .byte	%11111111, %11101111, %11101111
    226  27000				   -
    227  27000				   -POKEYCHECKLO
    228  27000				   -	       .byte	<$0450, <$0450, <$4000
    229  27000				   -POKEYCHECKHI
    230  27000				   -	       .byte	>$0450, >$0450, >$4000
    231  27000				   -
    232  27000				   -checkforpokey
    233  27000				   -	       ldy	#$0f
    234  27000				   -	       lda	#$00
    235  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    236  27000				   -resetpokeyregistersloop
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -	       dey
    239  27000				   -	       bpl	resetpokeyregistersloop
    240  27000				   -
    241  27000				   -	       ldy	#PAUDCTL
    242  27000				   -	       sta	(pokeybase),y
    243  27000				   -	       ldy	#PSKCTL
    244  27000				   -	       sta	(pokeybase),y
    245  27000				   -
    246  27000				   -			; let the dust settle...
    247  27000				   -	       nop
    248  27000				   -	       nop
    249  27000				   -	       nop
    250  27000				   -
    251  27000				   -	       lda	#4
    252  27000				   -	       sta	temp9
    253  27000				   -pokeycheckloop1
    254  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    255  27000				   -	       ldy	#PRANDOM
    256  27000				   -	       lda	(pokeybase),y
    257  27000				   -	       cmp	#$ff
    258  27000				   -	       bne	nopokeydetected
    259  27000				   -	       dec	temp9
    260  27000				   -	       bne	pokeycheckloop1
    261  27000				   -
    262  27000				   -			; take pokey out of reset...
    263  27000				   -	       ldy	#PSKCTL
    264  27000				   -	       lda	#3
    265  27000				   -	       sta	(pokeybase),y
    266  27000				   -	       ldy	#PAUDCTL
    267  27000				   -	       lda	#0
    268  27000				   -	       sta	(pokeybase),y
    269  27000				   -
    270  27000				   -			; let the dust settle again...
    271  27000				   -	       nop
    272  27000				   -	       nop
    273  27000				   -	       nop
    274  27000				   -
    275  27000				   -	       lda	#4
    276  27000				   -	       sta	temp9
    277  27000				   -pokeycheckloop2
    278  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    279  27000				   -	       ldy	#PRANDOM
    280  27000				   -	       lda	(pokeybase),y
    281  27000				   -	       cmp	#$ff
    282  27000				   -	       beq	skippokeycheckreturn
    283  27000				   -	       rts
    284  27000				   -skippokeycheckreturn
    285  27000				   -	       dec	temp9
    286  27000				   -	       bne	pokeycheckloop2
    287  27000				   -nopokeydetected
    288  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    289  27000				   -	       rts
    290  27000				   -
    291  27000				   -	       endif		; !pokeyaddress
    292  27000				   -
    293  27000				   -pokeysoundmoduleend
    294  27000				   -
    295  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes of rom)"
    296  27000				   -
    297  27000					       endif		; pokeysupport
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1767  27000					       endif
   1768  27000					       ifnconst	included.snes2atari.asm
------- FILE snes2atari.asm LEVEL 2 PASS 3
      0  27000					       include	snes2atari.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	SNES2ATARISUPPORT
      4  27000				   -snes2atarimodulestart
      5  27000				   -
      6  27000				   -SNES_CLOCK_PORT_BIT
      7  27000				   -	       .byte	$10,$01
      8  27000				   -SNES_CTLSWA_MASK
      9  27000				   -	       .byte	$30,$03
     10  27000				   -SNES_CTLSWA_SIGNAL
     11  27000				   -	       .byte	$C0,$0C
     12  27000				   -
     13  27000				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
     14  27000				   -SNES_AUTODETECT
     15  27000				   -	       ifconst	HSSUPPORT
     16  27000				   -			; ** an atarivox might be plugged in, so we skip scanning the second
     17  27000				   -			; ** port for a snes if vox was detected...
     18  27000				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
     19  27000				   -	       lsr
     20  27000				   -	       and	#1
     21  27000				   -	       eor	#1
     22  27000				   -	       tax
     23  27000				   -	       else
     24  27000				   -	       ldx	#1
     25  27000				   -	       endif		; HSSUPPORT
     26  27000				   -
     27  27000				   -SNES_AUTODETECT_LOOP
     28  27000				   -	       ifnconst	MULTIBUTTON	; snesdetect shouldn't be used in multibutton mode
     29  27000				   -	       lda	#1	; proline
     30  27000				   -	       sta	port0control,x
     31  27000				   -	       jsr	setportforinput
     32  27000				   -	       jsr	setonebuttonmode
     33  27000				   -	       jsr	SNES_READ
     34  27000				   -	       lda	snesdetected0,x
     35  27000				   -	       bne	SNES_AUTODETECT_FOUND
     36  27000				   -			; detection failed
     37  27000				   -	       jsr	setportforinput
     38  27000				   -	       jsr	settwobuttonmode
     39  27000				   -	       dex
     40  27000				   -	       bpl	SNES_AUTODETECT_LOOP
     41  27000				   -	       rts
     42  27000				   -SNES_AUTODETECT_FOUND
     43  27000				   -	       lda	#11	; formally set the snes controller
     44  27000				   -	       sta	port0control,x
     45  27000				   -	       stx	snesport
     46  27000				   -	       endif		; !MULTIBUTTON
     47  27000				   -	       rts
     48  27000					       endif		; SNES2ATARISUPPORT
     49  27000
     50  27000				    snes2atarihandler
     51  27000				   -	       ifconst	SNES2ATARISUPPORT
     52  27000				   -SNES2ATARI
     53  27000				   -	       jsr	SNES_READ
     54  27000				   -	       jmp	buttonreadloopreturn
     55  27000				   -
     56  27000				   -SNES_READ
     57  27000				   -			; x=0 for left port, x=1 for right
     58  27000				   -	       lda	port0control,x
     59  27000				   -	       cmp	#11	; snes
     60  27000				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
     61  27000				   -	       lda	snesdetected0,x
     62  27000				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
     63  27000				   -snes2atari_signal_go
     64  27000				   -	       jsr	SNES2ATARI_SIGNAL
     65  27000				   -snes2atari_signal_skip
     66  27000				   -
     67  27000				   -	       lda	CTLSWA
     68  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     69  27000				   -	       ora	SNES_CTLSWA_MASK,x
     70  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     71  27000				   -
     72  27000				   -	       lda	SWCHA
     73  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     74  27000				   -	       ora	SNES_CTLSWA_MASK,x
     75  27000				   -
     76  27000				   -	       sta	SWCHA	; latch+clock high
     77  27000				   -	       nop
     78  27000				   -	       nop
     79  27000				   -	       nop
     80  27000				   -	       nop
     81  27000				   -	       nop
     82  27000				   -	       nop
     83  27000				   -	       nop
     84  27000				   -	       lda	SWCHA
     85  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     86  27000				   -	       sta	SWCHA	; latch and clock low
     87  27000				   -	       ldy	#16	; 16 bits
     88  27000				   -SNES2ATARILOOP
     89  27000				   -	       rol	INPT4,x	; sample data into carry
     90  27000				   -	       lda	SWCHA
     91  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     92  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
     93  27000				   -	       sta	SWCHA	; clock low
     94  27000				   -	       rol	snes2atari0lo,x
     95  27000				   -	       rol	snes2atari0hi,x
     96  27000				   -	       lda	SWCHA
     97  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     98  27000				   -	       sta	SWCHA	; latch and clock low
     99  27000				   -	       dey		; next bit
    100  27000				   -	       bne	SNES2ATARILOOP
    101  27000				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
    102  27000				   -	       rol		; 17th snes bit into A low bit
    103  27000				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
    104  27000				   -	       and	#1
    105  27000				   -	       sta	snesdetected0,x
    106  27000				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
    107  27000				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
    108  27000				   -	       lda	SWCHA
    109  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    110  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
    111  27000				   -	       jmp	SNES_STOP_CLOCK
    112  27000				   -SNES_STOP_CLOCK
    113  27000				   -	       sta	SWCHA	; clock low
    114  27000				   -	       lda	CTLSWA
    115  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    116  27000				   -			;ora SNES_CLOCK_PORT_BIT,x
    117  27000				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
    118  27000				   -	       ifconst	MULTIBUTTON
    119  27000				   -	       lda	snesdetected0,x
    120  27000				   -	       bne	snesexit
    121  27000				   -	       lda	#1	; proline
    122  27000				   -	       sta	port0control,x
    123  27000				   -	       jmp	settwobuttonmode
    124  27000				   -snesexit
    125  27000				   -	       lda	#6
    126  27000				   -	       sta	multibuttoncount0,x
    127  27000				   -			; stuff directions into sSWCHA nibble and buttons into sINPT1,x...
    128  27000				   -	       lda	s2a_joyshiftcount,x
    129  27000				   -	       tay
    130  27000				   -	       lda	snes2atari0hi,x
    131  27000				   -snesjoypadloop
    132  27000				   -	       lsr
    133  27000				   -	       rol	inttemp6
    134  27000				   -	       dey
    135  27000				   -	       bpl	snesjoypadloop
    136  27000				   -	       lda	sSWCHA
    137  27000				   -	       ora	SWCHA_DIRMASK,x	; turn off the bits for this port
    138  27000				   -	       sta	sSWCHA
    139  27000				   -	       lda	inttemp6
    140  27000				   -	       ora	SWCHA_DIRMASK+1,x	; don't change the other port
    141  27000				   -	       and	sSWCHA
    142  27000				   -	       sta	sSWCHA
    143  27000				   -
    144  27000				   -			; snes2atari0hi = B  Y  Se St *  *  *	*
    145  27000				   -			; snes2atari0lo = A  X  Ls Rs
    146  27000				   -			; sINPT1	 = B  A  Y  X  Ls Rs Se St
    147  27000				   -	       lda	snes2atari0lo
    148  27000				   -	       sta	inttemp5
    149  27000				   -	       lda	snes2atari0hi
    150  27000				   -	       sta	inttemp6
    151  27000				   -	       asl	inttemp5	; A
    152  27000				   -	       rol
    153  27000				   -	       asl	inttemp6	; B
    154  27000				   -	       rol
    155  27000				   -	       asl	inttemp6	; Y
    156  27000				   -	       rol
    157  27000				   -	       asl	inttemp5	; X
    158  27000				   -	       rol
    159  27000				   -	       asl	inttemp5	; Ls
    160  27000				   -	       rol
    161  27000				   -	       asl	inttemp5	; Rs
    162  27000				   -	       rol
    163  27000				   -	       asl	inttemp6	; Ls
    164  27000				   -	       rol
    165  27000				   -	       asl	inttemp6	; Rs
    166  27000				   -	       rol
    167  27000				   -	       eor	#%11000000	; invert to match proline
    168  27000				   -	       sta	sINPT1,x
    169  27000				   -	       endif		; MULTIBUTTON
    170  27000				   -	       rts
    171  27000				   -SNES2ATARI_SIGNAL
    172  27000				   -			; signal to SNES2ATARI++ that we want SNES mode...
    173  27000				   -	       lda	CTLSWA
    174  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    175  27000				   -	       ora	SNES_CTLSWA_SIGNAL,x
    176  27000				   -	       sta	CTLSWA
    177  27000				   -	       lda	SWCHA
    178  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    179  27000				   -	       sta	SWCHA
    180  27000				   -	       ldy	#16
    181  27000				   -SNES_SIGNAL_LOOP
    182  27000				   -	       dey
    183  27000				   -	       bne	SNES_SIGNAL_LOOP
    184  27000				   -	       lda	SWCHA
    185  27000				   -	       ora	SWCHA_DIRMASK,x
    186  27000				   -	       sta	SWCHA
    187  27000				   -	       rts
    188  27000				   -s2a_joyshiftcount
    189  27000				   -	       .byte	7,3
    190  27000				   -snes2atarimoduleend
    191  27000				   -	       echo	"  (snes2atari module is using ",[(snes2atarimoduleend-snes2atarimodulestart)]d," bytes of rom)"
    192  27000					       endif		; SNES2ATARISUPPORT
    193  27000
    194  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1770  27000					       endif
   1771  27000					       ifnconst	included.mega7800.asm
------- FILE mega7800.asm LEVEL 2 PASS 3
      0  27000					       include	mega7800.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				    mega7800handlerstart
      4  27000				    mega7800handler
      5  27000				   -	       ifconst	MEGA7800SUPPORT
      6  27000				   -
      7  27000				   -			; ** stuff the joyick directions into the shadow register
      8  27000				   -	       lda	sSWCHA	; clear previous dirs for this pad, from
      9  27000				   -	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
     10  27000				   -	       sta	sSWCHA
     11  27000				   -	       lda	SWCHA	; load the actual joystick dirs, ensuring
     12  27000				   -	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
     13  27000				   -	       and	sSWCHA
     14  27000				   -	       sta	sSWCHA
     15  27000				   -
     16  27000				   -			; x=0 for left port, x=1 for right
     17  27000				   -
     18  27000				   -	       lda	#0
     19  27000				   -	       sta	inttemp5	; temporary button-state storage
     20  27000				   -	       sta	inttemp6	; temporary button-state storage
     21  27000				   -
     22  27000				   -	       lda	CTLSWA
     23  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     24  27000				   -	       ora	MEGA_INIT,x
     25  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     26  27000				   -
     27  27000				   -			; the controller type bits take a few cycles to get set after we start
     28  27000				   -			; an extended read, so we'll start the first extended read early...
     29  27000				   -	       lda	SWCHA
     30  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     31  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the extended read
     32  27000				   -	       nop
     33  27000				   -	       nop
     34  27000				   -
     35  27000				   -			; first read  will be pad state (mega7800 connect and controller type)
     36  27000				   -			; second read will be 3 button support (SACB)
     37  27000				   -			; third read  will be 6 button support (MXYZ)
     38  27000				   -
     39  27000				   -	       ldy	#5	; read 6x states, with the first 2x being the controller type
     40  27000				   -m7readloop
     41  27000				   -	       lda	SWCHA
     42  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     43  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the read
     44  27000				   -
     45  27000				   -	       lda	SWCHA
     46  27000				   -	       cpx	#1
     47  27000				   -	       bne	m7skipp1shift
     48  27000				   -	       asl
     49  27000				   -	       asl
     50  27000				   -	       asl
     51  27000				   -	       asl
     52  27000				   -m7skipp1shift
     53  27000				   -	       asl		; button bit 1 into carry
     54  27000				   -	       rol	inttemp6
     55  27000				   -	       rol	inttemp5
     56  27000				   -	       asl		; button bit 0 into carry
     57  27000				   -	       rol	inttemp6
     58  27000				   -	       rol	inttemp5
     59  27000				   -
     60  27000				   -	       lda	SWCHA
     61  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     62  27000				   -	       ora	MEGA_NEXT,x
     63  27000				   -	       sta	SWCHA
     64  27000				   -
     65  27000				   -	       dey
     66  27000				   -	       bpl	m7readloop
     67  27000				   -
     68  27000				   -	       lda	CTLSWA
     69  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     70  27000				   -	       sta	CTLSWA	; set this port back to input
     71  27000				   -
     72  27000				   -			; if mega7800 isn't detected this frame, unpress any buttons...
     73  27000				   -	       lda	inttemp5
     74  27000				   -	       and	#%00000011
     75  27000				   -	       beq	m7skipscuttle
     76  27000				   -	       lda	#$ff
     77  27000				   -	       sta	inttemp6
     78  27000				   -	       ifconst	MULTIBUTTON
     79  27000				   -			; the controller isn't present... revert to proline
     80  27000				   -	       lda	#1	; proline
     81  27000				   -	       sta	port0control,x
     82  27000				   -	       rts
     83  27000				   -	       endif		; MULTIBUTTON
     84  27000				   -m7skipscuttle
     85  27000				   -	       ifconst	MULTIBUTTON
     86  27000				   -	       lda	inttemp5
     87  27000				   -	       lsr
     88  27000				   -	       lsr
     89  27000				   -	       and	#3
     90  27000				   -	       tay
     91  27000				   -	       lda	megabuttons,y
     92  27000				   -	       sta	multibuttoncount0,x
     93  27000				   -	       endif		; MULTIBUTTON
     94  27000				   -
     95  27000				   -	       lda	inttemp5
     96  27000				   -	       sta	mega7800state0,x
     97  27000				   -	       lda	inttemp6
     98  27000				   -	       sta	mega7800data0,x
     99  27000				   -
    100  27000				   -	       ifconst	MULTIBUTTON
    101  27000				   -			; now update the genric multi-button bits...
    102  27000				   -	       ldy	#7
    103  27000				   -m7shuffleloop
    104  27000				   -	       lda	inttemp6
    105  27000				   -	       and	m7reorder,y
    106  27000				   -	       clc
    107  27000				   -	       adc	#$FF	; bit value in carry
    108  27000				   -	       rol	inttemp5
    109  27000				   -	       dey
    110  27000				   -	       bpl	m7shuffleloop
    111  27000				   -	       lda	inttemp5
    112  27000				   -	       eor	#%11000000
    113  27000				   -	       sta	sINPT1,x
    114  27000				   -	       rts
    115  27000				   -
    116  27000				   -megabuttons
    117  27000				   -	       .byte	6,2,3,2
    118  27000				   -m7reorder
    119  27000				   -			;	  S	     M	       Z	 Y
    120  27000				   -	       .byte	%00100000,%00000010,%00000100,%00001000
    121  27000				   -			;	  X	     C	       A	 B
    122  27000				   -	       .byte	%00000001,%10000000,%00010000,%01000000
    123  27000				   -	       else		;  !MULTIBUTTON
    124  27000				   -	       rts
    125  27000				   -	       endif		; !MULTIBUTTON
    126  27000				   -
    127  27000				   -MEGA_INIT
    128  27000				   -	       .byte	%00110000,%00000011
    129  27000				   -MEGA_NEXT
    130  27000				   -	       .byte	%00100000,%00000010
    131  27000				   -
    132  27000				   -mega7800handlerend
    133  27000				   -	       echo	"  (mega7800 module is using ",[(mega7800handlerend-mega7800handlerstart)]d," bytes of rom)"
    134  27000				   -
    135  27000					       endif		; MEGA7800SUPPORT
    136  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1773  27000					       endif
   1774  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       lda	songtempo
     15  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     16  27000				   -servicesongcontinue
     17  27000				   -	       lda	sfxschedulelock
     18  27000				   -	       sta	sfxschedulemissed
     19  27000				   -	       bne	servicesongover
     20  27000				   -	       lda	songtempo
     21  27000				   -	       clc
     22  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     23  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     24  27000				   -	       bcc	servicesongover
     25  27000				   -			; ** if we're here a new 16th note has passed
     26  27000				   -			; ** check if a new note is due on any of the 4 channels
     27  27000				   -servicesongredo
     28  27000				   -	       ldx	#3
     29  27000				   -checkchannelloop
     30  27000				   -	       dec	songchannel1busywait,x
     31  27000				   -	       bpl	carryoncheckingchannel
     32  27000				   -	       txa
     33  27000				   -	       pha		; save X for the loop
     34  27000				   -	       jsr	processsongdata
     35  27000				   -	       pla		; restore X for the loop
     36  27000				   -	       tax
     37  27000				   -carryoncheckingchannel
     38  27000				   -	       dex
     39  27000				   -	       bpl	checkchannelloop
     40  27000				   -	       lda	inactivechannelcount
     41  27000				   -	       cmp	#15
     42  27000				   -	       bne	skipstopsong
     43  27000				   -	       lda	songloops
     44  27000				   -	       bne	doasongloop
     45  27000				   -			;lda #0
     46  27000				   -	       sta	songtempo	; all channels are done. stop the song
     47  27000				   -	       rts
     48  27000				   -doasongloop
     49  27000				   -	       bmi	skipsongloopadjust
     50  27000				   -	       dec	songloops
     51  27000				   -skipsongloopadjust
     52  27000				   -	       jsr	setsongchannels
     53  27000				   -	       jmp	servicesongredo
     54  27000				   -skipstopsong
     55  27000				   -	       rts
     56  27000				   -
     57  27000				   -processsongdata
     58  27000				   -			; channel needs processing
     59  27000				   -			; X=channel #
     60  27000				   -
     61  27000				   -	       txa
     62  27000				   -	       clc
     63  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  27000				   -	       tay
     65  27000				   -
     66  27000				   -
     67  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     68  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     69  27000				   -	       lda	songchannel1layer1lo,y
     70  27000				   -	       sta	songdatalo
     71  27000				   -	       lda	songchannel1layer1hi,y
     72  27000				   -	       sta	songdatahi
     73  27000				   -	       ora	songdatalo
     74  27000				   -	       bne	channelhasdata
     75  27000				   -			;channel data is pointing at $0000
     76  27000				   -	       lda	#$7F
     77  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     78  27000				   -setchannelcountbits
     79  27000				   -	       lda	channel2bits,x
     80  27000				   -	       ora	inactivechannelcount
     81  27000				   -	       sta	inactivechannelcount
     82  27000				   -	       rts
     83  27000				   -channelhasdata
     84  27000				   -
     85  27000				   -	       sty	songstackindex
     86  27000				   -	       ldy	#0
     87  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  27000				   -	       cmp	#$ff
     89  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  27000				   -	       jmp	handlechannelEOD
     91  27000				   -
     92  27000				   -carryoncheckingdatatype
     93  27000				   -	       and	#$F0
     94  27000				   -	       cmp	#$C0
     95  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
     96  27000				   -	       cmp	#$F0
     97  27000				   -	       beq	handlemultibytecommand
     98  27000				   -	       cmp	#$D0
     99  27000				   -	       beq	handlesemiup
    100  27000				   -	       cmp	#$E0
    101  27000				   -	       beq	handlesemidown
    102  27000				   -handlenotedata
    103  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    104  27000				   -
    105  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    106  27000				   -
    107  27000				   -			; ** set the note length
    108  27000				   -	       lda	(songdatalo),y
    109  27000				   -	       and	#$0F
    110  27000				   -	       sta	songchannel1busywait,x
    111  27000				   -
    112  27000				   -			; ** load the instrument
    113  27000				   -	       lda	songchannel1instrumentlo,x
    114  27000				   -	       sta	sfxinstrumentlo
    115  27000				   -	       lda	songchannel1instrumenthi,x
    116  27000				   -	       sta	sfxinstrumenthi
    117  27000				   -
    118  27000				   -			; ** get the note, and transpose
    119  27000				   -	       lda	(songdatalo),y
    120  27000				   -	       lsr
    121  27000				   -	       lsr
    122  27000				   -	       lsr
    123  27000				   -	       lsr
    124  27000				   -	       clc
    125  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    126  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    127  27000				   -	       sta	sfxnoteindex
    128  27000				   -
    129  27000				   -	       lda	#0
    130  27000				   -	       sta	sfxpitchoffset
    131  27000				   -
    132  27000				   -	       jsr	schedulesfx
    133  27000				   -
    134  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  27000				   -
    136  27000				   -handlechannelrest
    137  27000				   -			; ** set the note length
    138  27000				   -	       lda	(songdatalo),y
    139  27000				   -	       and	#$0F
    140  27000				   -	       sta	songchannel1busywait,x
    141  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  27000				   -
    143  27000				   -handlesemiup
    144  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  27000				   -	       clc
    147  27000				   -handlesemidownentry
    148  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    149  27000				   -	       sta	songchannel1transpose,x
    150  27000				   -	       jsr	advancethesongpointer1byte
    151  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  27000				   -
    153  27000				   -handlesemidown
    154  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  27000				   -	       sec
    158  27000				   -	       jmp	handlesemidownentry
    159  27000				   -
    160  27000				   -handlemultibytecommand
    161  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  27000				   -	       cmp	#$08	; ** load new instrument?
    164  27000				   -	       bne	nothandleinstrumentchange
    165  27000				   -handleinstrumentchange
    166  27000				   -	       iny
    167  27000				   -	       lda	(songdatalo),y
    168  27000				   -	       sta	songchannel1instrumentlo,x
    169  27000				   -	       iny
    170  27000				   -	       lda	(songdatalo),y
    171  27000				   -	       sta	songchannel1instrumenthi,x
    172  27000				   -	       lda	#3
    173  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  27000				   -	       jmp	processsongdata
    175  27000				   -
    176  27000				   -nothandleinstrumentchange
    177  27000				   -	       cmp	#$09	; ** absolute tempo change?
    178  27000				   -	       bne	nothandletempochange
    179  27000				   -	       lda	#0
    180  27000				   -	       sta	songtempo
    181  27000				   -handlerelativetempochange
    182  27000				   -	       iny
    183  27000				   -	       lda	(songdatalo),y
    184  27000				   -	       clc
    185  27000				   -	       adc	songtempo
    186  27000				   -	       sta	songtempo
    187  27000				   -	       lda	#2
    188  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  27000				   -	       jmp	processsongdata
    190  27000				   -
    191  27000				   -nothandletempochange
    192  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    193  27000				   -	       beq	handlerelativetempochange
    194  27000				   -	       cmp	#$0B	; ** octave/semi change?
    195  27000				   -	       beq	handleoctavesemichange
    196  27000				   -handlepatterndata
    197  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    198  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    199  27000				   -
    200  27000				   -	       lda	#4
    201  27000				   -	       clc
    202  27000				   -	       adc	songchannel1stackdepth,x
    203  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  27000				   -
    205  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    206  27000				   -	       lda	songstackindex
    207  27000				   -	       adc	#4
    208  27000				   -	       tax
    209  27000				   -
    210  27000				   -	       lda	(songdatalo),y
    211  27000				   -	       and	#$7
    212  27000				   -	       sta	songchannel1layer1loops,x
    213  27000				   -	       iny
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       sta	songchannel1layer1lo,x
    216  27000				   -	       iny
    217  27000				   -	       lda	(songdatalo),y
    218  27000				   -	       sta	songchannel1layer1hi,x
    219  27000				   -
    220  27000				   -	       ldx	inttemp6	; restore x with the channel #
    221  27000				   -
    222  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  27000				   -	       lda	#3
    224  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  27000				   -
    226  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  27000				   -	       jmp	processsongdata
    228  27000				   -
    229  27000				   -handlechannelEOD
    230  27000				   -			; ** check if there are loops remaining on the pattern
    231  27000				   -	       stx	inttemp6
    232  27000				   -	       ldx	songstackindex
    233  27000				   -	       dec	songchannel1layer1loops,x
    234  27000				   -	       bmi	handlechannelEODnoloop
    235  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  27000				   -	       iny
    237  27000				   -	       lda	(songdatalo),y
    238  27000				   -	       sta	songchannel1layer1lo,x
    239  27000				   -	       iny
    240  27000				   -	       lda	(songdatalo),y
    241  27000				   -	       sta	songchannel1layer1hi,x
    242  27000				   -	       ldx	inttemp6
    243  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  27000				   -
    245  27000				   -handlechannelEODnoloop
    246  27000				   -			; this pattern/loop is done playing. "pop" the stack
    247  27000				   -	       ldx	inttemp6
    248  27000				   -	       lda	songchannel1stackdepth,x
    249  27000				   -	       beq	handlerootchannelEOD
    250  27000				   -	       sec
    251  27000				   -	       sbc	#4
    252  27000				   -	       sta	songchannel1stackdepth,x
    253  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  27000				   -
    255  27000				   -handlerootchannelEOD
    256  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  27000				   -	       lda	#0
    258  27000				   -	       sta	songchannel1layer1lo,x
    259  27000				   -	       sta	songchannel1layer1hi,x
    260  27000				   -	       sta	songchannel1busywait,x
    261  27000				   -	       jmp	setchannelcountbits
    262  27000				   -	       rts
    263  27000				   -
    264  27000				   -nothandlepatternchange
    265  27000				   -handleoctavesemichange
    266  27000				   -	       iny
    267  27000				   -	       lda	(songdatalo),y
    268  27000				   -	       sta	songchannel1transpose,x
    269  27000				   -	       lda	#2
    270  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  27000				   -	       jmp	processsongdata
    272  27000				   -
    273  27000				   -advancethesongpointer1byte
    274  27000				   -	       txa
    275  27000				   -	       ldx	songstackindex
    276  27000				   -	       inc	songchannel1layer1lo,x
    277  27000				   -	       bne	skiphiadvancethesongpointer1byte
    278  27000				   -	       inc	songchannel1layer1hi,x
    279  27000				   -skiphiadvancethesongpointer1byte
    280  27000				   -	       tax
    281  27000				   -	       rts
    282  27000				   -
    283  27000				   -advancethesongpointerNbytes
    284  27000				   -			; entered with A=# of byte to advance
    285  27000				   -	       stx	inttemp6
    286  27000				   -	       ldx	songstackindex
    287  27000				   -	       clc
    288  27000				   -	       adc	songchannel1layer1lo,x
    289  27000				   -	       sta	songchannel1layer1lo,x
    290  27000				   -	       lda	#0
    291  27000				   -	       adc	songchannel1layer1hi,x
    292  27000				   -	       sta	songchannel1layer1hi,x
    293  27000				   -	       ldx	inttemp6
    294  27000				   -	       rts
    295  27000				   -
    296  27000				   -clearsongmemory
    297  27000				   -	       lda	#0
    298  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  27000				   -clearsongmemoryloop1
    300  27000				   -	       sta	songchannel1layer1lo,x
    301  27000				   -	       dex
    302  27000				   -	       bpl	clearsongmemoryloop1
    303  27000				   -
    304  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  27000				   -clearsongmemoryloop2
    306  27000				   -	       sta	songchannel1layer1loops,x
    307  27000				   -	       dex
    308  27000				   -	       bpl	clearsongmemoryloop2
    309  27000				   -
    310  27000				   -	       lda	#$ff
    311  27000				   -	       ldx	#3
    312  27000				   -clearsongmemoryloop3
    313  27000				   -	       sta	songchannel1busywait,x
    314  27000				   -	       dex
    315  27000				   -	       bpl	clearsongmemoryloop3
    316  27000				   -	       rts
    317  27000				   -
    318  27000				   -setsongchannels
    319  27000				   -	       jsr	clearsongmemory
    320  27000				   -	       ldy	#7
    321  27000				   -	       ldx	#3
    322  27000				   -setsongchannelsloop
    323  27000				   -	       lda	(songpointerlo),y
    324  27000				   -	       sta	songchannel1layer1hi,x
    325  27000				   -	       dey
    326  27000				   -	       lda	(songpointerlo),y
    327  27000				   -	       sta	songchannel1layer1lo,x
    328  27000				   -	       dex
    329  27000				   -	       dey
    330  27000				   -	       bpl	setsongchannelsloop
    331  27000				   -	       rts
    332  27000				   -
    333  27000				   -channel2bits
    334  27000				   -	       .byte	1,2,4,8
    335  27000				   -
    336  27000				   -tiatrackeroctavenotes
    337  27000				   -	       ifconst	BUZZBASS
    338  27000				   -LOWC       =	15
    339  27000				   -	       else
    340  27000				   -LOWC       =	14
    341  27000				   -	       endif
    342  27000				   -			; ****** ELECTRONIC (0 to 11)
    343  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    344  27000				   -	       .byte	LOWC,18	; c#0
    345  27000				   -	       .byte	LOWC,17	; d0
    346  27000				   -	       .byte	LOWC,16	; d#0
    347  27000				   -	       .byte	LOWC,15	; e0
    348  27000				   -	       .byte	LOWC,14	; f0  (very off)
    349  27000				   -	       .byte	LOWC,14	; f#0
    350  27000				   -	       .byte	LOWC,13	; g0
    351  27000				   -	       .byte	LOWC,12	; g#0
    352  27000				   -	       .byte	LOWC,11	; a0
    353  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    354  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    355  27000				   -
    356  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  27000				   -	       .byte	6,30	; c1	 32.7Hz
    358  27000				   -	       .byte	6,28	; c#1
    359  27000				   -	       .byte	6,27	; d1
    360  27000				   -	       .byte	6,25	; d#1
    361  27000				   -	       .byte	6,24	; e1
    362  27000				   -	       .byte	6,22	; f1
    363  27000				   -	       .byte	6,21	; f#1
    364  27000				   -	       .byte	6,20	; g1
    365  27000				   -	       .byte	6,18	; g#1
    366  27000				   -	       .byte	6,17	; a1
    367  27000				   -	       .byte	6,16	; a#1
    368  27000				   -	       .byte	6,15	; b1	 63.4Hz
    369  27000				   -
    370  27000				   -			; ****** BUZZY (24 to 39)
    371  27000				   -	       .byte	1,31	; c2	 65.5
    372  27000				   -	       .byte	1,30	; c#2	 67.6
    373  27000				   -	       .byte	1,27	; d2	 72.3
    374  27000				   -	       .byte	1,26	; d#2	 77.6
    375  27000				   -	       .byte	1,24	; e2
    376  27000				   -	       .byte	1,23	; f2
    377  27000				   -	       .byte	1,22	; f#2
    378  27000				   -	       .byte	1,20	; g2
    379  27000				   -	       .byte	1,19	; g#2
    380  27000				   -	       .byte	1,18	; a2
    381  27000				   -	       .byte	1,17	; a#2
    382  27000				   -	       .byte	1,16	; b2
    383  27000				   -	       .byte	1,15	; c3	126.8Hz
    384  27000				   -	       .byte	1,14	; c#3
    385  27000				   -	       .byte	1,13	; d3	149.7Hz
    386  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    387  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    388  27000				   -	       .byte	12,31	; e3	163.8Hz
    389  27000				   -	       .byte	12,29	; f3
    390  27000				   -	       .byte	12,28	; f#3
    391  27000				   -	       .byte	12,26	; g3
    392  27000				   -	       .byte	12,24	; g#3
    393  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  27000				   -	       .byte	12,22	; a#3
    395  27000				   -	       .byte	12,20	; b3
    396  27000				   -	       .byte	12,19	; c4  (middle C)
    397  27000				   -	       .byte	12,18	; c#4
    398  27000				   -	       .byte	12,17	; d4
    399  27000				   -	       .byte	12,16	; d#4
    400  27000				   -	       .byte	12,15	; e4
    401  27000				   -	       .byte	12,14	; f4
    402  27000				   -	       .byte	12,13	; f#4
    403  27000				   -	       .byte	12,12	; g4  (very off)
    404  27000				   -	       .byte	12,12	; g#4
    405  27000				   -	       .byte	12,11	; a4
    406  27000				   -	       .byte	12,10	; a#4
    407  27000				   -	       .byte	4,31	; b4
    408  27000				   -	       .byte	4,29	; c5
    409  27000				   -	       .byte	4,28	; c#5
    410  27000				   -	       .byte	4,26	; d5
    411  27000				   -	       .byte	4,24	; d#5
    412  27000				   -	       .byte	4,23	; e5
    413  27000				   -	       .byte	4,22	; f5
    414  27000				   -	       .byte	4,20	; f#5
    415  27000				   -	       .byte	4,19	; g5
    416  27000				   -	       .byte	4,18	; g#5
    417  27000				   -	       .byte	4,17	; a5
    418  27000				   -	       .byte	4,16	; a#5
    419  27000				   -	       .byte	4,15	; b5
    420  27000				   -
    421  27000				   -			; ****** TUNED WIND (72 to 83)
    422  27000				   -	       .byte	8,30	; c
    423  27000				   -	       .byte	8,28	; c#
    424  27000				   -	       .byte	8,27	; d
    425  27000				   -	       .byte	8,25	; d#
    426  27000				   -	       .byte	8,24	; e
    427  27000				   -	       .byte	8,22	; f
    428  27000				   -	       .byte	8,21	; f#
    429  27000				   -	       .byte	8,20	; g
    430  27000				   -	       .byte	8,18	; g#
    431  27000				   -	       .byte	8,17	; a
    432  27000				   -	       .byte	8,16	; a#
    433  27000				   -	       .byte	8,15	; b
    434  27000				   -
    435  27000				   -	       include	"tiadrumkit.asm"
    436  27000				   -
    437  27000				   -trackerend
    438  27000				   -
    439  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  27000				   -
    441  27000					       endif		;MUSICTRACKER
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1776  27000					       endif
   1777  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -	       ifconst	BANKSETROM
      6  27000				   -	       ifconst	isBANKSETBANK
      7  27000				   -HSCHARSHERE =	1
      8  27000				   -	       endif
      9  27000				   -	       else		; !BANKSETROM so embed the character strings
     10  27000				   -HSCHARSHERE =	1
     11  27000				   -	       endif
     12  27000				   -
     13  27000				   -	       ifnconst	isBANKSETBANK
     14  27000				   -hiscorestart
     15  27000				   -
     16  27000				   -detectatarivoxeeprom
     17  27000				   -hiscoremodulestart
     18  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  27000				   -	       jsr	AVoxDetect
     20  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  27000				   -	       sta	avoxdetected
     22  27000				   -	       lda	#$0
     23  27000				   -	       sta	SWACNT
     24  27000				   -	       lda	avoxdetected
     25  27000				   -	       rts
     26  27000				   -
     27  27000				   -detecthsc
     28  27000				   -			; check for the HSC ROM signature...
     29  27000				   -	       lda	XCTRL1s
     30  27000				   -	       ora	#%00001100
     31  27000				   -	       sta	XCTRL1s
     32  27000				   -	       sta	XCTRL1
     33  27000				   -
     34  27000				   -	       lda	$3900
     35  27000				   -	       eor	#$C6
     36  27000				   -	       bne	detecthscfail
     37  27000				   -	       lda	$3904
     38  27000				   -	       eor	#$FE
     39  27000				   -	       bne	detecthscfail
     40  27000				   -
     41  27000				   -			; check if it's initialized...
     42  27000				   -	       ldy	#0
     43  27000				   -	       lda	#$ff
     44  27000				   -checkhscinit
     45  27000				   -	       and	$1000,y
     46  27000				   -	       dey
     47  27000				   -	       bpl	checkhscinit
     48  27000				   -	       cmp	#$ff
     49  27000				   -	       bne	hscisalreadyinit
     50  27000				   -			; if we're here, we need to do a minimal HSC init...
     51  27000				   -	       ldy	#$28
     52  27000				   -hscinitloop1
     53  27000				   -	       lda	hscheader,y
     54  27000				   -	       sta	$1000,y
     55  27000				   -	       dey
     56  27000				   -	       bpl	hscinitloop1
     57  27000				   -	       ldy	#$89
     58  27000				   -	       lda	#$7F
     59  27000				   -hscinitloop2
     60  27000				   -	       sta	$10B3,y
     61  27000				   -	       dey
     62  27000				   -	       cpy	#$ff
     63  27000				   -	       bne	hscinitloop2
     64  27000				   -hscisalreadyinit
     65  27000				   -	       lda	#$ff
     66  27000				   -	       rts
     67  27000				   -hscheader
     68  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     69  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     70  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     71  27000				   -detecthscfail
     72  27000				   -	       lda	XCTRL1s
     73  27000				   -	       and	#%11110111
     74  27000				   -	       sta	XCTRL1s
     75  27000				   -	       lda	#0
     76  27000				   -	       rts
     77  27000				   -	       endif		; isBANKSETBANK
     78  27000				   -
     79  27000				   -	       ifnconst	hiscorefont
     80  27000				   -	       echo	""
     81  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     82  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     83  27000				   -	       echo	" has been omitted from this build."
     84  27000				   -	       echo	""
     85  27000				   -	       else		; hiscorefont
     86  27000				   -	       ifnconst	isBANKSETBANK
     87  27000				   -hscdrawscreen
     88  27000				   -
     89  27000				   -			; we use 20 lines on a 24 line display
     90  27000				   -			; HSSCOREY to dynamically centers based on
     91  27000				   -			;HSSCOREY = 0
     92  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     93  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     94  27000				   -
     95  27000				   -	       ifconst	HSSCORESIZE
     96  27000				   -SCORESIZE  =	HSSCORESIZE
     97  27000				   -	       else
     98  27000				   -SCORESIZE  =	6
     99  27000				   -	       endif
    100  27000				   -
    101  27000				   -			;save shadow registers for later return...
    102  27000				   -	       lda	sCTRL
    103  27000				   -			;sta ssCTRL
    104  27000				   -	       pha
    105  27000				   -	       lda	sCHARBASE
    106  27000				   -			;sta ssCHARBASE
    107  27000				   -	       pha
    108  27000				   -
    109  27000				   -	       lda	#$60
    110  27000				   -	       sta	charactermode
    111  27000				   -	       jsr	drawwait
    112  27000				   -	       jsr	blacken320colors
    113  27000				   -	       jsr	clearscreen
    114  27000				   -
    115  27000				   -			;set the character base to the HSC font
    116  27000				   -	       lda	#>hiscorefont
    117  27000				   -	       sta	CHARBASE
    118  27000				   -	       sta	sCHARBASE
    119  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    120  27000				   -	       sta	CTRL
    121  27000				   -	       sta	sCTRL
    122  27000				   -
    123  27000				   -	       lda	#60
    124  27000				   -	       sta	hsjoydebounce
    125  27000				   -
    126  27000				   -	       lda	#0
    127  27000				   -	       sta	hscursorx
    128  27000				   -	       sta	framecounter
    129  27000				   -	       ifnconst	HSCOLORCHASESTART
    130  27000				   -	       lda	#$8D	; default is blue. why not?
    131  27000				   -	       else
    132  27000				   -	       lda	#HSCOLORCHASESTART
    133  27000				   -	       endif
    134  27000				   -	       sta	hscolorchaseindex
    135  27000				   -
    136  27000				   -	       lda	#$0F
    137  27000				   -	       sta	P0C2	; base text is white
    138  27000				   -
    139  27000				   -	       jsr	hschasecolors
    140  27000				   -			; ** plot all of the initials
    141  27000				   -	       lda	#<HSRAMInitials
    142  27000				   -	       sta	temp1	; charmaplo
    143  27000				   -	       lda	#>HSRAMInitials
    144  27000				   -	       sta	temp2	; charmaphi
    145  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    146  27000				   -	       sta	temp3	; palette/width
    147  27000				   -	       lda	#104
    148  27000				   -	       sta	temp4	; X
    149  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    150  27000				   -	       sta	temp5	; Y
    151  27000				   -plothsinitialsloop
    152  27000				   -	       jsr	plotcharacters
    153  27000				   -	       clc
    154  27000				   -	       lda	temp3
    155  27000				   -	       adc	#32
    156  27000				   -	       sta	temp3
    157  27000				   -	       inc	temp5
    158  27000				   -	       if	WZONEHEIGHT = 8
    159  27000				   -	       inc	temp5
    160  27000				   -	       endif
    161  27000				   -	       clc
    162  27000				   -	       lda	#3
    163  27000				   -	       adc	temp1
    164  27000				   -	       sta	temp1
    165  27000				   -	       cmp	#(<(HSRAMInitials+15))
    166  27000				   -	       bcc	plothsinitialsloop
    167  27000				   -
    168  27000				   -	       ifconst	HSGAMENAMELEN
    169  27000				   -			;plot the game name...
    170  27000				   -	       lda	#<HSGAMENAMEtable
    171  27000				   -	       sta	temp1	; charmaplo
    172  27000				   -	       lda	#>HSGAMENAMEtable
    173  27000				   -	       sta	temp2	; charmaphi
    174  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    175  27000				   -	       sta	temp3	; palette/width
    176  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    177  27000				   -	       sta	temp4	; X
    178  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    179  27000				   -	       sta	temp5	; Y
    180  27000				   -	       jsr	plotcharacters
    181  27000				   -	       endif		; HSGAMENAMELEN
    182  27000				   -
    183  27000				   -			;plot "difficulty"...
    184  27000				   -	       ldy	gamedifficulty
    185  27000				   -	       ifnconst	HSNOLEVELNAMES
    186  27000				   -	       lda	highscoredifficultytextlo,y
    187  27000				   -	       sta	temp1
    188  27000				   -	       lda	highscoredifficultytexthi,y
    189  27000				   -	       sta	temp2
    190  27000				   -	       sec
    191  27000				   -	       lda	#32
    192  27000				   -	       sbc	highscoredifficultytextlen,y
    193  27000				   -	       sta	temp3	; palette/width
    194  27000				   -	       sec
    195  27000				   -	       lda	#40
    196  27000				   -	       sbc	highscoredifficultytextlen,y
    197  27000				   -	       asl
    198  27000				   -	       sta	temp4	; X
    199  27000				   -	       else
    200  27000				   -	       lda	#<HSHIGHSCOREStext
    201  27000				   -	       sta	temp1	; charmaplo
    202  27000				   -	       lda	#>HSHIGHSCOREStext
    203  27000				   -	       sta	temp2	; charmaphi
    204  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    205  27000				   -	       sta	temp3	; palette/width
    206  27000				   -	       lda	#(80-(11*2))
    207  27000				   -	       sta	temp4	; X
    208  27000				   -	       endif		; HSNOLEVELNAMES
    209  27000				   -
    210  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    211  27000				   -	       sta	temp5	; Y
    212  27000				   -	       jsr	plotcharacters
    213  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    214  27000				   -	       bne	carronwithscoreevaluation
    215  27000				   -	       jmp	donoscoreevaluation
    216  27000				   -carronwithscoreevaluation
    217  27000				   -	       dey
    218  27000				   -	       lda	highscorelabeltextlo,y
    219  27000				   -	       sta	temp1
    220  27000				   -	       lda	highscorelabeltexthi,y
    221  27000				   -	       sta	temp2
    222  27000				   -	       sec
    223  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    224  27000				   -	       sta	temp3	; palette/width
    225  27000				   -	       lda	highscorelabeladjust1,y
    226  27000				   -	       sta	temp4	; X
    227  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    228  27000				   -	       sta	temp5	; Y
    229  27000				   -	       jsr	plotcharacters
    230  27000				   -
    231  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    232  27000				   -	       dey
    233  27000				   -			;plot the current player score...
    234  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    235  27000				   -	       sta	temp3	; palette/width
    236  27000				   -	       lda	highscorelabeladjust2,y
    237  27000				   -	       sta	temp4	; X
    238  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    239  27000				   -	       sta	temp5	; Y
    240  27000				   -
    241  27000				   -	       lda	scorevarlo,y
    242  27000				   -	       sta	temp7	; score variable lo
    243  27000				   -	       lda	scorevarhi,y
    244  27000				   -	       sta	temp8	; score variable hi
    245  27000				   -
    246  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    247  27000				   -	       sta	temp9
    248  27000				   -
    249  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    250  27000				   -	       sta	temp1	; charmaplo
    251  27000				   -	       lda	#>(hiscorefont+33)
    252  27000				   -	       sta	temp2	; charmaphi
    253  27000				   -	       lda	#SCORESIZE
    254  27000				   -	       sta	temp6
    255  27000				   -	       ifnconst	DOUBLEWIDE
    256  27000				   -	       jsr	plotvalue
    257  27000				   -	       else
    258  27000				   -	       jsr	plotvaluedw
    259  27000				   -	       endif
    260  27000				   -
    261  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    262  27000				   -
    263  27000				   -	       ifconst	HSGAMERANKS
    264  27000				   -
    265  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    266  27000				   -comparescore2rankloop
    267  27000				   -	       inx
    268  27000				   -	       ldy	#0
    269  27000				   -	       lda	rankvalue_0,x
    270  27000				   -	       cmp	(temp7),y
    271  27000				   -	       bcc	score2rankloopdone
    272  27000				   -	       bne	comparescore2rankloop
    273  27000				   -	       iny
    274  27000				   -	       lda	rankvalue_1,x
    275  27000				   -	       cmp	(temp7),y
    276  27000				   -	       bcc	score2rankloopdone
    277  27000				   -	       bne	comparescore2rankloop
    278  27000				   -	       iny
    279  27000				   -	       lda	(temp7),y
    280  27000				   -	       cmp	rankvalue_2,x
    281  27000				   -	       bcs	score2rankloopdone
    282  27000				   -	       jmp	comparescore2rankloop
    283  27000				   -score2rankloopdone
    284  27000				   -	       stx	hsnewscorerank
    285  27000				   -
    286  27000				   -	       lda	ranklabello,x
    287  27000				   -	       sta	temp1
    288  27000				   -	       lda	ranklabelhi,x
    289  27000				   -	       sta	temp2
    290  27000				   -	       sec
    291  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    292  27000				   -	       sbc	ranklabellengths,x
    293  27000				   -	       sta	temp3	; palette/width
    294  27000				   -	       sec
    295  27000				   -	       lda	#(40+6)
    296  27000				   -	       sbc	ranklabellengths,x
    297  27000				   -	       asl
    298  27000				   -	       sta	temp4	; X
    299  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    300  27000				   -	       sta	temp5	; Y
    301  27000				   -	       jsr	plotcharacters
    302  27000				   -
    303  27000				   -	       ldx	hsnewscorerank
    304  27000				   -
    305  27000				   -	       lda	#<highscoreranklabel
    306  27000				   -	       sta	temp1
    307  27000				   -	       lda	#>highscoreranklabel
    308  27000				   -	       sta	temp2
    309  27000				   -
    310  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    311  27000				   -	       sta	temp3	; palette/width
    312  27000				   -	       lda	#(40-6)
    313  27000				   -	       sec
    314  27000				   -	       sbc	ranklabellengths,x
    315  27000				   -	       asl
    316  27000				   -	       sta	temp4	; X
    317  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    318  27000				   -	       sta	temp5	; Y
    319  27000				   -	       jsr	plotcharacters
    320  27000				   -	       endif		; HSGAMERANKS
    321  27000				   -
    322  27000				   -
    323  27000				   -			; ** which line did this player beat?
    324  27000				   -	       lda	#$ff
    325  27000				   -	       sta	hsnewscoreline
    326  27000				   -	       ldx	#$fd
    327  27000				   -comparescoreadd2x
    328  27000				   -	       inx
    329  27000				   -comparescoreadd1x
    330  27000				   -	       inx
    331  27000				   -comparescore2lineloop
    332  27000				   -	       inc	hsnewscoreline
    333  27000				   -	       inx		; initialrun, x=0
    334  27000				   -	       cpx	#15
    335  27000				   -	       beq	nohighscoreforyou
    336  27000				   -	       ldy	#0
    337  27000				   -	       lda	HSRAMScores,x
    338  27000				   -	       cmp	(temp7),y	; first score digit
    339  27000				   -	       bcc	score2lineloopdonedel1x
    340  27000				   -	       bne	comparescoreadd2x
    341  27000				   -	       iny
    342  27000				   -	       inx
    343  27000				   -	       lda	HSRAMScores,x
    344  27000				   -	       cmp	(temp7),y
    345  27000				   -	       bcc	score2lineloopdonedel2x
    346  27000				   -	       bne	comparescoreadd1x
    347  27000				   -	       iny
    348  27000				   -	       inx
    349  27000				   -	       lda	(temp7),y
    350  27000				   -	       cmp	HSRAMScores,x
    351  27000				   -	       bcs	score2lineloopdonedel3x
    352  27000				   -	       jmp	comparescore2lineloop
    353  27000				   -nohighscoreforyou
    354  27000				   -	       lda	#$ff
    355  27000				   -	       sta	hsnewscoreline
    356  27000				   -	       sta	countdownseconds
    357  27000				   -	       jmp	donoscoreevaluation
    358  27000				   -score2lineloopdonedel3x
    359  27000				   -	       dex
    360  27000				   -score2lineloopdonedel2x
    361  27000				   -	       dex
    362  27000				   -score2lineloopdonedel1x
    363  27000				   -	       dex
    364  27000				   -
    365  27000				   -			; 0 1 2
    366  27000				   -			; 3 4 5
    367  27000				   -			; 6 7 8
    368  27000				   -			; 9 0 1
    369  27000				   -			; 2 3 4
    370  27000				   -
    371  27000				   -	       stx	temp9
    372  27000				   -	       cpx	#11
    373  27000				   -	       beq	postsortscoresuploop
    374  27000				   -	       ldx	#11
    375  27000				   -sortscoresuploop
    376  27000				   -	       lda	HSRAMScores,x
    377  27000				   -	       sta	HSRAMScores+3,x
    378  27000				   -	       lda	HSRAMInitials,x
    379  27000				   -	       sta	HSRAMInitials+3,x
    380  27000				   -	       dex
    381  27000				   -	       cpx	temp9
    382  27000				   -	       bne	sortscoresuploop
    383  27000				   -postsortscoresuploop
    384  27000				   -
    385  27000				   -			;stick the score and cleared initials in the slot...
    386  27000				   -	       inx
    387  27000				   -	       ldy	#0
    388  27000				   -	       sty	hsinitialhold
    389  27000				   -	       lda	(temp7),y
    390  27000				   -	       sta	HSRAMScores,x
    391  27000				   -	       iny
    392  27000				   -	       lda	(temp7),y
    393  27000				   -	       sta	HSRAMScores+1,x
    394  27000				   -	       iny
    395  27000				   -	       lda	(temp7),y
    396  27000				   -	       sta	HSRAMScores+2,x
    397  27000				   -	       lda	#0
    398  27000				   -	       sta	HSRAMInitials,x
    399  27000				   -	       lda	#29
    400  27000				   -	       sta	HSRAMInitials+1,x
    401  27000				   -	       sta	HSRAMInitials+2,x
    402  27000				   -
    403  27000				   -	       stx	hsinitialpos
    404  27000				   -
    405  27000				   -	       ifconst	vox_highscore
    406  27000				   -	       lda	<#vox_highscore
    407  27000				   -	       sta	speech_addr
    408  27000				   -	       lda	>#vox_highscore
    409  27000				   -	       sta	speech_addr+1
    410  27000				   -	       endif		; vox_highscore
    411  27000				   -	       ifconst	sfx_highscore
    412  27000				   -	       lda	<#sfx_highscore
    413  27000				   -	       sta	temp1
    414  27000				   -	       lda	>#sfx_highscore
    415  27000				   -	       sta	temp2
    416  27000				   -	       lda	#0
    417  27000				   -	       sta	temp3
    418  27000				   -	       jsr	schedulesfx
    419  27000				   -	       endif		; sfx_highscore
    420  27000				   -	       ifconst	songdatastart_song_highscore
    421  27000				   -	       lda	#<songchanneltable_song_highscore
    422  27000				   -	       sta	songpointerlo
    423  27000				   -	       lda	#>songchanneltable_song_highscore
    424  27000				   -	       sta	songpointerhi
    425  27000				   -	       lda	#73
    426  27000				   -	       sta	songtempo
    427  27000				   -	       jsr	setsongchannels
    428  27000				   -	       endif		; songdatastart_song_highscore
    429  27000				   -
    430  27000				   -
    431  27000				   -donoscoreevaluation
    432  27000				   -
    433  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    434  27000				   -	       sta	temp3	; palette/width
    435  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    436  27000				   -	       sta	temp4	; X
    437  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    438  27000				   -	       sta	temp5	; Y
    439  27000				   -	       lda	#<HSRAMScores
    440  27000				   -	       sta	temp7	; score variable lo
    441  27000				   -	       lda	#>HSRAMScores
    442  27000				   -	       sta	temp8	; score variable hi
    443  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    444  27000				   -	       sta	temp9
    445  27000				   -plothsscoresloop
    446  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    447  27000				   -	       sta	temp1	; charmaplo
    448  27000				   -	       lda	#>(hiscorefont+33)
    449  27000				   -	       sta	temp2	; charmaphi
    450  27000				   -	       lda	#6
    451  27000				   -	       sta	temp6
    452  27000				   -	       ifnconst	DOUBLEWIDE
    453  27000				   -	       jsr	plotvalue
    454  27000				   -	       else
    455  27000				   -	       jsr	plotvaluedw
    456  27000				   -	       endif
    457  27000				   -	       clc
    458  27000				   -	       lda	temp3
    459  27000				   -	       adc	#32
    460  27000				   -	       sta	temp3
    461  27000				   -	       inc	temp5
    462  27000				   -	       if	WZONEHEIGHT = 8
    463  27000				   -	       inc	temp5
    464  27000				   -	       endif
    465  27000				   -	       clc
    466  27000				   -	       lda	#3
    467  27000				   -	       adc	temp7
    468  27000				   -	       sta	temp7
    469  27000				   -	       cmp	#(<(HSRAMScores+15))
    470  27000				   -	       bcc	plothsscoresloop
    471  27000				   -plothsindex
    472  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    473  27000				   -	       sta	temp3	; palette/width
    474  27000				   -	       lda	#44
    475  27000				   -	       sta	temp4	; X
    476  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    477  27000				   -	       sta	temp5	; Y
    478  27000				   -	       lda	#<hsgameslotnumbers
    479  27000				   -	       sta	temp7	; score variable lo
    480  27000				   -	       lda	#>hsgameslotnumbers
    481  27000				   -	       sta	temp8	; score variable hi
    482  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    483  27000				   -	       sta	temp9
    484  27000				   -plothsindexloop
    485  27000				   -	       lda	#<(hiscorefont+33)
    486  27000				   -	       sta	temp1	; charmaplo
    487  27000				   -	       lda	#>(hiscorefont+33)
    488  27000				   -	       sta	temp2	; charmaphi
    489  27000				   -	       lda	#1
    490  27000				   -	       sta	temp6	; number of characters
    491  27000				   -	       ifnconst	DOUBLEWIDE
    492  27000				   -	       jsr	plotvalue
    493  27000				   -	       else
    494  27000				   -	       jsr	plotvaluedw
    495  27000				   -	       endif
    496  27000				   -	       clc
    497  27000				   -	       lda	temp3
    498  27000				   -	       adc	#32
    499  27000				   -	       sta	temp3
    500  27000				   -	       inc	temp5
    501  27000				   -	       if	WZONEHEIGHT = 8
    502  27000				   -	       inc	temp5
    503  27000				   -	       endif
    504  27000				   -	       inc	temp7
    505  27000				   -	       lda	temp7
    506  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    507  27000				   -	       bcc	plothsindexloop
    508  27000				   -
    509  27000				   -	       jsr	savescreen
    510  27000				   -	       ifnconst	HSSECONDS
    511  27000				   -	       lda	#6
    512  27000				   -	       else
    513  27000				   -	       lda	#HSSECONDS
    514  27000				   -	       endif
    515  27000				   -
    516  27000				   -	       sta	countdownseconds
    517  27000				   -
    518  27000				   -keepdisplayinghs
    519  27000				   -	       jsr	restorescreen
    520  27000				   -
    521  27000				   -	       jsr	setuphsinpt1
    522  27000				   -
    523  27000				   -	       lda	hsnewscoreline
    524  27000				   -	       bpl	carryonkeepdisplayinghs
    525  27000				   -	       jmp	skipenterscorecontrol
    526  27000				   -carryonkeepdisplayinghs
    527  27000				   -
    528  27000				   -
    529  27000				   -	       ifnconst	HSSECONDS
    530  27000				   -	       lda	#6
    531  27000				   -	       else
    532  27000				   -	       lda	#HSSECONDS
    533  27000				   -	       endif
    534  27000				   -
    535  27000				   -	       sta	countdownseconds
    536  27000				   -
    537  27000				   -			;plot the "cursor" initial sprite...
    538  27000				   -	       lda	hsinitialhold
    539  27000				   -
    540  27000				   -	       sta	temp1
    541  27000				   -	       lda	#>(hiscorefont+32)
    542  27000				   -	       sta	temp2
    543  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    544  27000				   -	       sta	temp3	; palette/width
    545  27000				   -	       lda	hscursorx
    546  27000				   -	       asl
    547  27000				   -	       asl
    548  27000				   -	       clc
    549  27000				   -	       adc	#104
    550  27000				   -	       sta	temp4	; X
    551  27000				   -	       lda	hsnewscoreline
    552  27000				   -	       asl
    553  27000				   -	       asl
    554  27000				   -	       asl
    555  27000				   -	       asl
    556  27000				   -	       adc	#((3*16)+HSCURSORY)
    557  27000				   -	       sta	temp5	; Y
    558  27000				   -	       lda	#%01000000
    559  27000				   -	       sta	temp6
    560  27000				   -	       jsr	plotsprite
    561  27000				   -
    562  27000				   -	       ldx	hscursorx
    563  27000				   -	       ldy	hsdisplaymode
    564  27000				   -	       ifnconst	.HSup
    565  27000				   -	       lda	sSWCHA
    566  27000				   -	       cpy	#3
    567  27000				   -	       bne	hsskipadjustjoystick1
    568  27000				   -	       asl
    569  27000				   -	       asl
    570  27000				   -	       asl
    571  27000				   -	       asl
    572  27000				   -hsskipadjustjoystick1
    573  27000				   -	       sta	hsswcha
    574  27000				   -	       else		; there are user-defined routines!
    575  27000				   -	       jsr	.HSdown
    576  27000				   -	       lda	hsreturn	; b0
    577  27000				   -	       asl
    578  27000				   -	       pha
    579  27000				   -	       jsr	.HSup
    580  27000				   -	       pla
    581  27000				   -	       ora	hsreturn
    582  27000				   -	       asl
    583  27000				   -	       asl
    584  27000				   -	       asl
    585  27000				   -	       asl
    586  27000				   -	       eor	#$FF
    587  27000				   -	       sta	hsswcha
    588  27000				   -	       endif
    589  27000				   -	       lda	SWCHB
    590  27000				   -	       and	#%00000010
    591  27000				   -	       bne	hsskipselectswitch
    592  27000				   -	       lda	#%00010000
    593  27000				   -	       sta	hsswcha
    594  27000				   -	       bne	hsdodebouncecheck
    595  27000				   -hsskipselectswitch
    596  27000				   -	       lda	hsswcha
    597  27000				   -	       and	#%00110000
    598  27000				   -	       cmp	#%00110000
    599  27000				   -	       beq	hsjoystickskipped
    600  27000				   -hsdodebouncecheck
    601  27000				   -	       lda	hsjoydebounce
    602  27000				   -	       beq	hsdontdebounce
    603  27000				   -	       jmp	hspostjoystick
    604  27000				   -hsdontdebounce
    605  27000				   -	       ldx	#1	; small tick sound
    606  27000				   -	       jsr	playhssfx
    607  27000				   -	       lda	hsswcha
    608  27000				   -	       and	#%00110000
    609  27000				   -	       ldx	hscursorx
    610  27000				   -	       cmp	#%00100000	; check down
    611  27000				   -	       bne	hsjoycheckup
    612  27000				   -	       ldy	hsinitialhold
    613  27000				   -	       cpx	#0
    614  27000				   -	       bne	skipavoid31_1
    615  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    616  27000				   -	       bne	skipavoid31_1
    617  27000				   -	       dey
    618  27000				   -skipavoid31_1
    619  27000				   -	       dey
    620  27000				   -	       jmp	hssetdebounce
    621  27000				   -hsjoycheckup
    622  27000				   -	       cmp	#%00010000	; check up
    623  27000				   -	       bne	hsjoystickskipped
    624  27000				   -	       ldy	hsinitialhold
    625  27000				   -	       cpx	#0
    626  27000				   -	       bne	skipavoid31_2
    627  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    628  27000				   -	       bne	skipavoid31_2
    629  27000				   -	       iny
    630  27000				   -skipavoid31_2
    631  27000				   -	       iny
    632  27000				   -hssetdebounce
    633  27000				   -	       tya
    634  27000				   -	       and	#31
    635  27000				   -	       sta	hsinitialhold
    636  27000				   -	       lda	#15
    637  27000				   -	       sta	hsjoydebounce
    638  27000				   -	       bne	hspostjoystick
    639  27000				   -hsjoystickskipped
    640  27000				   -			; check the fire button only when the stick isn't engaged
    641  27000				   -	       lda	hsinpt1
    642  27000				   -	       bpl	hsbuttonskipped
    643  27000				   -	       lda	hsjoydebounce
    644  27000				   -	       bne	hspostjoystick
    645  27000				   -hsfiredontdebounce
    646  27000				   -	       lda	hsinitialhold
    647  27000				   -	       cmp	#31
    648  27000				   -	       beq	hsmovecursorback
    649  27000				   -	       inc	hscursorx
    650  27000				   -	       inc	hsinitialpos
    651  27000				   -	       lda	hscursorx
    652  27000				   -	       cmp	#3
    653  27000				   -	       bne	skiphsentryisdone
    654  27000				   -	       lda	#0
    655  27000				   -	       sta	framecounter
    656  27000				   -	       lda	#$ff
    657  27000				   -	       sta	hsnewscoreline
    658  27000				   -	       dec	hsinitialpos
    659  27000				   -	       bne	skiphsentryisdone
    660  27000				   -hsmovecursorback
    661  27000				   -	       lda	hscursorx
    662  27000				   -	       beq	skiphsmovecursorback
    663  27000				   -	       lda	#29
    664  27000				   -	       ldx	hsinitialpos
    665  27000				   -	       sta	HSRAMInitials,x
    666  27000				   -	       dec	hsinitialpos
    667  27000				   -	       dec	hscursorx
    668  27000				   -	       dex
    669  27000				   -	       lda	HSRAMInitials,x
    670  27000				   -	       sta	hsinitialhold
    671  27000				   -skiphsmovecursorback
    672  27000				   -skiphsentryisdone
    673  27000				   -	       ldx	#0
    674  27000				   -	       jsr	playhssfx
    675  27000				   -	       lda	#20
    676  27000				   -	       sta	hsjoydebounce
    677  27000				   -	       bne	hspostjoystick
    678  27000				   -
    679  27000				   -hsbuttonskipped
    680  27000				   -	       lda	#0
    681  27000				   -	       sta	hsjoydebounce
    682  27000				   -hspostjoystick
    683  27000				   -
    684  27000				   -	       ldx	hsinitialpos
    685  27000				   -	       lda	hsinitialhold
    686  27000				   -	       sta	HSRAMInitials,x
    687  27000				   -
    688  27000				   -	       jmp	skiphschasecolors
    689  27000				   -
    690  27000				   -skipenterscorecontrol
    691  27000				   -	       jsr	hschasecolors
    692  27000				   -	       jsr	setuphsinpt1
    693  27000				   -	       lda	hsjoydebounce
    694  27000				   -	       bne	skiphschasecolors
    695  27000				   -	       lda	hsinpt1
    696  27000				   -	       bmi	returnfromhs
    697  27000				   -skiphschasecolors
    698  27000				   -
    699  27000				   -	       jsr	drawscreen
    700  27000				   -
    701  27000				   -	       lda	countdownseconds
    702  27000				   -	       beq	returnfromhs
    703  27000				   -	       jmp	keepdisplayinghs
    704  27000				   -returnfromhs
    705  27000				   -
    706  27000				   -	       ifconst	songdatastart_song_highscore
    707  27000				   -	       lda	hsdisplaymode
    708  27000				   -	       beq	skipclearHSCsong
    709  27000				   -	       lda	#0
    710  27000				   -	       sta	songtempo
    711  27000				   -skipclearHSCsong
    712  27000				   -	       endif
    713  27000				   -	       jsr	drawwait
    714  27000				   -	       jsr	clearscreen
    715  27000				   -	       lda	#0
    716  27000				   -	       ldy	#7
    717  27000				   -	       jsr	blacken320colors
    718  27000				   -			;lda ssCHARBASE
    719  27000				   -	       pla
    720  27000				   -	       sta	sCHARBASE
    721  27000				   -			;lda ssCTRL
    722  27000				   -	       pla
    723  27000				   -	       sta	sCTRL
    724  27000				   -	       rts
    725  27000				   -
    726  27000				   -setuphsinpt1
    727  27000				   -	       lda	#$ff
    728  27000				   -	       sta	hsinpt1
    729  27000				   -	       lda	hsjoydebounce
    730  27000				   -	       beq	skipdebounceadjust
    731  27000				   -	       dec	hsjoydebounce
    732  27000				   -	       bne	skipstorefirebuttonstatus
    733  27000				   -skipdebounceadjust
    734  27000				   -	       lda	SWCHB
    735  27000				   -	       and	#%00000001
    736  27000				   -	       bne	hscheckresetover
    737  27000				   -	       lda	#$ff
    738  27000				   -	       sta	hsinpt1
    739  27000				   -	       rts
    740  27000				   -hscheckresetover
    741  27000				   -	       ifnconst	.HSup
    742  27000				   -	       ldx	hsdisplaymode
    743  27000				   -	       cpx	#3
    744  27000				   -	       bne	hsskipadjustjoyfire1
    745  27000				   -	       lda	sINPT3
    746  27000				   -	       jmp	hsskipadjustjoyfire1done
    747  27000				   -hsskipadjustjoyfire1
    748  27000				   -	       lda	sINPT1
    749  27000				   -hsskipadjustjoyfire1done
    750  27000				   -	       sta	hsinpt1
    751  27000				   -	       else		; there are user-defined routines!
    752  27000				   -	       jsr	.HSselect
    753  27000				   -	       lda	hsreturn
    754  27000				   -	       ror		; carry
    755  27000				   -	       ror		; b7
    756  27000				   -	       sta	hsinpt1
    757  27000				   -	       endif	.HSup
    758  27000				   -skipstorefirebuttonstatus
    759  27000				   -	       rts
    760  27000				   -
    761  27000				   -blacken320colors
    762  27000				   -	       ldy	#7
    763  27000				   -blacken320colorsloop
    764  27000				   -	       sta	P0C2,y
    765  27000				   -	       dey
    766  27000				   -	       bpl	blacken320colorsloop
    767  27000				   -	       rts
    768  27000				   -
    769  27000				   -hschasecolors
    770  27000				   -	       lda	framecounter
    771  27000				   -	       and	#3
    772  27000				   -	       bne	hschasecolorsreturn
    773  27000				   -	       inc	hscolorchaseindex
    774  27000				   -	       lda	hscolorchaseindex
    775  27000				   -
    776  27000				   -	       sta	P5C2
    777  27000				   -	       sbc	#$02
    778  27000				   -	       sta	P4C2
    779  27000				   -	       sbc	#$02
    780  27000				   -	       sta	P3C2
    781  27000				   -	       sbc	#$02
    782  27000				   -	       sta	P2C2
    783  27000				   -	       sbc	#$02
    784  27000				   -	       sta	P1C2
    785  27000				   -hschasecolorsreturn
    786  27000				   -	       rts
    787  27000				   -
    788  27000				   -playhssfx
    789  27000				   -	       lda	hssfx_lo,x
    790  27000				   -	       sta	temp1
    791  27000				   -	       lda	hssfx_hi,x
    792  27000				   -	       sta	temp2
    793  27000				   -	       lda	#0
    794  27000				   -	       sta	temp3
    795  27000				   -	       jmp	schedulesfx
    796  27000				   -
    797  27000				   -hssfx_lo
    798  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    799  27000				   -hssfx_hi
    800  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    801  27000				   -
    802  27000				   -sfx_hsletterpositionchange
    803  27000				   -	       .byte	$10,$18,$00
    804  27000				   -	       .byte	$02,$06,$08
    805  27000				   -	       .byte	$02,$06,$04
    806  27000				   -	       .byte	$00,$00,$00
    807  27000				   -sfx_hslettertick
    808  27000				   -	       .byte	$10,$18,$00
    809  27000				   -	       .byte	$00,$00,$0a
    810  27000				   -	       .byte	$00,$00,$00
    811  27000				   -
    812  27000				   -highscorelabeladjust1
    813  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    814  27000				   -highscorelabeladjust2
    815  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    816  27000				   -
    817  27000				   -scorevarlo
    818  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    819  27000				   -scorevarhi
    820  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    821  27000				   -
    822  27000				   -	       endif		; !isBANKSETBANK
    823  27000				   -
    824  27000				   -	       ifnconst	HSNOLEVELNAMES
    825  27000				   -	       ifnconst	isBANKSETBANK
    826  27000				   -highscoredifficultytextlo
    827  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    828  27000				   -highscoredifficultytexthi
    829  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    830  27000				   -	       endif		; !isBANKSETBANK
    831  27000				   -
    832  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    833  27000				   -	       ifnconst	isBANKSETBANK
    834  27000				   -highscoredifficultytextlen
    835  27000				   -	       .byte	22, 30, 26, 24
    836  27000				   -	       endif		; !isBANKSETBANK
    837  27000				   -
    838  27000				   -	       ifconst	HSCHARSHERE
    839  27000				   -
    840  27000				   -easylevelname
    841  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    842  27000				   -mediumlevelname
    843  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    844  27000				   -hardlevelname
    845  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    846  27000				   -expertlevelname
    847  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    848  27000				   -	       endif		; HSCHARSHERE
    849  27000				   -	       else		; HSCUSTOMLEVELNAMES
    850  27000				   -	       include	"7800hsgamediffnames.asm"
    851  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    852  27000				   -	       else		; HSNOLEVELNAMES
    853  27000				   -	       ifconst	HSCHARSHERE
    854  27000				   -HSHIGHSCOREStext
    855  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    856  27000				   -	       endif		; HSCHARSHERE
    857  27000				   -	       endif		; HSNOLEVELNAMES
    858  27000				   -
    859  27000				   -	       ifnconst	isBANKSETBANK
    860  27000				   -highscorelabeltextlo
    861  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    862  27000				   -highscorelabeltexthi
    863  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    864  27000				   -	       endif		; !isBANKSETBANK
    865  27000				   -
    866  27000				   -	       ifconst	HSCHARSHERE
    867  27000				   -player0label
    868  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    869  27000				   -
    870  27000				   -player1label
    871  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    872  27000				   -
    873  27000				   -player2label
    874  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    875  27000				   -	       endif		; HSCHARSHERE
    876  27000				   -
    877  27000				   -
    878  27000				   -	       ifconst	HSGAMENAMELEN
    879  27000				   -	       ifconst	HSCHARSHERE
    880  27000				   -HSGAMENAMEtable
    881  27000				   -	       include	"7800hsgamename.asm"
    882  27000				   -	       endif		; HSCHARSHERE
    883  27000				   -	       endif		; HSGAMENAMELEN
    884  27000				   -	       ifconst	HSGAMERANKS
    885  27000				   -	       include	"7800hsgameranks.asm"
    886  27000				   -	       ifconst	HSCHARSHERE
    887  27000				   -highscoreranklabel
    888  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    889  27000				   -	       endif		; HSCHARSHERE
    890  27000				   -	       endif		; HSGAMERANKS
    891  27000				   -
    892  27000				   -			;ensure our table doesn't wrap a page...
    893  27000				   -	       if	((<*)>251)
    894  27000				   -	       align	256
    895  27000				   -	       endif
    896  27000				   -hsgameslotnumbers
    897  27000				   -	       .byte	33,34,35,36,37
    898  27000				   -	       endif		; hiscorefont
    899  27000				   -
    900  27000				   -
    901  27000				   -	       ifnconst	isBANKSETBANK
    902  27000				   -loaddifficultytable
    903  27000				   -	       lda	gamedifficulty
    904  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    905  27000				   -	       sta	gamedifficulty
    906  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    907  27000				   -	       bne	loaddifficultytablecontinue1
    908  27000				   -	       rts		; this high score difficulty table is already loaded
    909  27000				   -loaddifficultytablecontinue1
    910  27000				   -	       lda	gamedifficulty
    911  27000				   -	       sta	hsdifficulty
    912  27000				   -			;we need to check the device for the table
    913  27000				   -	       lda	hsdevice
    914  27000				   -	       bne	loaddifficultytablecontinue2
    915  27000				   -			; there's no save device. clear out this table.
    916  27000				   -	       jmp	cleardifficultytablemem
    917  27000				   -loaddifficultytablecontinue2
    918  27000				   -	       lda	hsdevice
    919  27000				   -	       and	#1
    920  27000				   -	       beq	memdeviceisntHSC
    921  27000				   -	       jmp	loaddifficultytableHSC
    922  27000				   -memdeviceisntHSC
    923  27000				   -	       jmp	loaddifficultytableAVOX
    924  27000				   -
    925  27000				   -savedifficultytable
    926  27000				   -			;*** we need to check which device we should use...
    927  27000				   -	       lda	hsdevice
    928  27000				   -	       bne	savedifficultytablerealdevice
    929  27000				   -	       rts		; its a ram device
    930  27000				   -savedifficultytablerealdevice
    931  27000				   -	       and	#1
    932  27000				   -	       beq	savememdeviceisntHSC
    933  27000				   -	       jmp	savedifficultytableHSC
    934  27000				   -savememdeviceisntHSC
    935  27000				   -	       jmp	savedifficultytableAVOX
    936  27000				   -
    937  27000				   -savedifficultytableAVOX
    938  27000				   -			; the load call already setup the memory structure and atarivox memory location
    939  27000				   -	       jsr	savealoadedHSCtablecontinue
    940  27000				   -savedifficultytableAVOXskipconvert
    941  27000				   -	       lda	#HSIDHI
    942  27000				   -	       sta	eeprombuffer
    943  27000				   -	       lda	#HSIDLO
    944  27000				   -	       sta	eeprombuffer+1
    945  27000				   -	       lda	hsdifficulty
    946  27000				   -	       sta	eeprombuffer+2
    947  27000				   -	       lda	#32
    948  27000				   -	       jsr	AVoxWriteBytes
    949  27000				   -	       rts
    950  27000				   -
    951  27000				   -savedifficultytableHSC
    952  27000				   -			;we always load a table before reaching here, so the
    953  27000				   -			;memory structures from the load should be intact...
    954  27000				   -	       ldy	hsgameslot
    955  27000				   -	       bpl	savealoadedHSCtable
    956  27000				   -	       rts
    957  27000				   -savealoadedHSCtable
    958  27000				   -	       lda	HSCGameDifficulty,y
    959  27000				   -	       cmp	#$7F
    960  27000				   -	       bne	savealoadedHSCtablecontinue
    961  27000				   -	       jsr	initializeHSCtableentry
    962  27000				   -savealoadedHSCtablecontinue
    963  27000				   -			;convert our RAM table to HSC format and write it out...
    964  27000				   -	       ldy	#0
    965  27000				   -	       ldx	#0
    966  27000				   -savedifficultytableScores
    967  27000				   -
    968  27000				   -	       lda	HSRAMInitials,x
    969  27000				   -	       sta	temp3
    970  27000				   -	       lda	HSRAMInitials+1,x
    971  27000				   -	       sta	temp4
    972  27000				   -	       lda	HSRAMInitials+2,x
    973  27000				   -	       sta	temp5
    974  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    975  27000				   -
    976  27000				   -	       lda	temp1
    977  27000				   -	       sta	(HSGameTableLo),y
    978  27000				   -	       iny
    979  27000				   -	       lda	temp2
    980  27000				   -	       sta	(HSGameTableLo),y
    981  27000				   -	       iny
    982  27000				   -
    983  27000				   -	       lda	HSRAMScores,x
    984  27000				   -	       sta	(HSGameTableLo),y
    985  27000				   -	       iny
    986  27000				   -	       lda	HSRAMScores+1,x
    987  27000				   -	       sta	(HSGameTableLo),y
    988  27000				   -	       iny
    989  27000				   -	       lda	HSRAMScores+2,x
    990  27000				   -	       sta	(HSGameTableLo),y
    991  27000				   -	       iny
    992  27000				   -	       inx
    993  27000				   -	       inx
    994  27000				   -	       inx		; +3
    995  27000				   -	       cpx	#15
    996  27000				   -	       bne	savedifficultytableScores
    997  27000				   -	       rts
    998  27000				   -
    999  27000				   -loaddifficultytableHSC
   1000  27000				   -			; routine responsible for loading the difficulty table from HSC
   1001  27000				   -	       jsr	findindexHSC
   1002  27000				   -	       ldy	hsgameslot
   1003  27000				   -	       lda	HSCGameDifficulty,y
   1004  27000				   -	       cmp	#$7F
   1005  27000				   -	       bne	loaddifficultytableHSCcontinue
   1006  27000				   -			;there was an error. use a new RAM table instead...
   1007  27000				   -	       jsr	initializeHSCtableentry
   1008  27000				   -	       jmp	cleardifficultytablemem
   1009  27000				   -loaddifficultytableHSCcontinue
   1010  27000				   -			; parse the data into the HS memory...
   1011  27000				   -	       ldy	#0
   1012  27000				   -	       ldx	#0
   1013  27000				   -loaddifficultytableScores
   1014  27000				   -	       lda	(HSGameTableLo),y
   1015  27000				   -	       sta	temp1
   1016  27000				   -	       iny
   1017  27000				   -	       lda	(HSGameTableLo),y
   1018  27000				   -	       sta	temp2
   1019  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1020  27000				   -	       iny
   1021  27000				   -	       lda	(HSGameTableLo),y
   1022  27000				   -	       sta	HSRAMScores,x
   1023  27000				   -	       lda	temp3
   1024  27000				   -	       sta	HSRAMInitials,x
   1025  27000				   -	       inx
   1026  27000				   -	       iny
   1027  27000				   -	       lda	(HSGameTableLo),y
   1028  27000				   -	       sta	HSRAMScores,x
   1029  27000				   -	       lda	temp4
   1030  27000				   -	       sta	HSRAMInitials,x
   1031  27000				   -	       inx
   1032  27000				   -	       iny
   1033  27000				   -	       lda	(HSGameTableLo),y
   1034  27000				   -	       sta	HSRAMScores,x
   1035  27000				   -	       lda	temp5
   1036  27000				   -	       sta	HSRAMInitials,x
   1037  27000				   -	       inx
   1038  27000				   -	       iny
   1039  27000				   -	       cpx	#15
   1040  27000				   -	       bne	loaddifficultytableScores
   1041  27000				   -	       rts
   1042  27000				   -
   1043  27000				   -decodeHSCInitials
   1044  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1045  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1046  27000				   -	       lda	#0
   1047  27000				   -	       sta	temp4
   1048  27000				   -	       lda	temp1
   1049  27000				   -	       and	#%00011111
   1050  27000				   -	       sta	temp3
   1051  27000				   -
   1052  27000				   -	       lda	temp2
   1053  27000				   -	       and	#%00011111
   1054  27000				   -	       sta	temp5
   1055  27000				   -
   1056  27000				   -	       lda	temp1
   1057  27000				   -	       asl
   1058  27000				   -	       rol	temp4
   1059  27000				   -	       asl
   1060  27000				   -	       rol	temp4
   1061  27000				   -	       asl
   1062  27000				   -	       rol	temp4
   1063  27000				   -	       lda	temp2
   1064  27000				   -	       asl
   1065  27000				   -	       rol	temp4
   1066  27000				   -	       asl
   1067  27000				   -	       rol	temp4
   1068  27000				   -	       rts
   1069  27000				   -encodeHSCInitials
   1070  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1071  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1072  27000				   -			; start with packing temp1...
   1073  27000				   -	       lda	temp4
   1074  27000				   -	       and	#%00011100
   1075  27000				   -	       sta	temp1
   1076  27000				   -	       asl	temp1
   1077  27000				   -	       asl	temp1
   1078  27000				   -	       asl	temp1
   1079  27000				   -	       lda	temp3
   1080  27000				   -	       and	#%00011111
   1081  27000				   -	       ora	temp1
   1082  27000				   -	       sta	temp1
   1083  27000				   -			; ...temp1 is now packed, on to temp2...
   1084  27000				   -	       lda	temp5
   1085  27000				   -	       asl
   1086  27000				   -	       asl
   1087  27000				   -	       ror	temp4
   1088  27000				   -	       ror
   1089  27000				   -	       ror	temp4
   1090  27000				   -	       ror
   1091  27000				   -	       sta	temp2
   1092  27000				   -	       rts
   1093  27000				   -
   1094  27000				   -findindexHSCerror
   1095  27000				   -			;the HSC is stuffed. return the bad slot flag
   1096  27000				   -	       ldy	#$ff
   1097  27000				   -	       sty	hsgameslot
   1098  27000				   -	       rts
   1099  27000				   -
   1100  27000				   -findindexHSC
   1101  27000				   -HSCGameID1 =	$1029
   1102  27000				   -HSCGameID2 =	$106E
   1103  27000				   -HSCGameDifficulty =	$10B3
   1104  27000				   -HSCGameIndex =	$10F8
   1105  27000				   -			; routine responsible for finding the game index from HSC
   1106  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1107  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1108  27000				   -	       ldy	#69	; start +1 to account for the dey
   1109  27000				   -findindexHSCloop
   1110  27000				   -	       dey
   1111  27000				   -	       bmi	findindexHSCerror
   1112  27000				   -	       lda	HSCGameDifficulty,y
   1113  27000				   -	       cmp	#$7F
   1114  27000				   -	       beq	findourindexHSC
   1115  27000				   -	       cmp	gamedifficulty
   1116  27000				   -	       bne	findindexHSCloop
   1117  27000				   -	       lda	HSCGameID1,y
   1118  27000				   -	       cmp	#HSIDHI
   1119  27000				   -	       bne	findindexHSCloop
   1120  27000				   -	       lda	HSCGameID2,y
   1121  27000				   -	       cmp	#HSIDLO
   1122  27000				   -	       bne	findindexHSCloop
   1123  27000				   -findourindexHSC
   1124  27000				   -			; if we're here we found our index in the table
   1125  27000				   -			; or we found the first empty one
   1126  27000				   -	       sty	hsgameslot
   1127  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1128  27000				   -	       rts
   1129  27000				   -
   1130  27000				   -
   1131  27000				   -initializeHSCtableentry
   1132  27000				   -	       ldy	hsgameslot
   1133  27000				   -			; we need to make a new entry...
   1134  27000				   -	       lda	#HSIDHI
   1135  27000				   -	       sta	HSCGameID1,y
   1136  27000				   -	       lda	#HSIDLO
   1137  27000				   -	       sta	HSCGameID2,y
   1138  27000				   -	       lda	gamedifficulty
   1139  27000				   -	       sta	HSCGameDifficulty,y
   1140  27000				   -	       ldx	#0
   1141  27000				   -fixHSDGameDifficultylistLoop
   1142  27000				   -	       inx
   1143  27000				   -	       txa
   1144  27000				   -	       sta	HSCGameIndex,y
   1145  27000				   -	       iny
   1146  27000				   -	       cpy	#69
   1147  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1148  27000				   -	       rts
   1149  27000				   -
   1150  27000				   -setupHSCGamepointer
   1151  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1152  27000				   -	       lda	#$17
   1153  27000				   -	       sta	HSGameTableHi
   1154  27000				   -	       lda	#$FA
   1155  27000				   -	       sta	HSGameTableLo
   1156  27000				   -setupHSCGamepointerLoop
   1157  27000				   -	       lda	HSGameTableLo
   1158  27000				   -	       sec
   1159  27000				   -	       sbc	#25
   1160  27000				   -	       sta	HSGameTableLo
   1161  27000				   -	       lda	HSGameTableHi
   1162  27000				   -	       sbc	#0
   1163  27000				   -	       sta	HSGameTableHi
   1164  27000				   -	       iny
   1165  27000				   -	       cpy	#69
   1166  27000				   -	       bne	setupHSCGamepointerLoop
   1167  27000				   -	       rts
   1168  27000				   -
   1169  27000				   -loaddifficultytableAVOX
   1170  27000				   -			; routine responsible for loading the difficulty table from Avox
   1171  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1172  27000				   -	       lda	#>(eeprombuffer+3)
   1173  27000				   -	       sta	HSGameTableHi
   1174  27000				   -	       lda	#<(eeprombuffer+3)
   1175  27000				   -	       sta	HSGameTableLo
   1176  27000				   -
   1177  27000				   -			; the start location in EEPROM, subtract 32...
   1178  27000				   -	       lda	#$5F
   1179  27000				   -	       sta	HSVoxHi
   1180  27000				   -	       lda	#$E0
   1181  27000				   -	       sta	HSVoxLo
   1182  27000				   -	       lda	#0
   1183  27000				   -	       sta	temp1
   1184  27000				   -loaddifficultytableAVOXloop
   1185  27000				   -	       inc	temp1
   1186  27000				   -	       beq	loaddifficultytableAVOXfull
   1187  27000				   -	       clc
   1188  27000				   -	       lda	HSVoxLo
   1189  27000				   -	       adc	#32
   1190  27000				   -	       sta	HSVoxLo
   1191  27000				   -	       lda	HSVoxHi
   1192  27000				   -	       adc	#0
   1193  27000				   -	       sta	HSVoxHi
   1194  27000				   -	       lda	#3
   1195  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1196  27000				   -	       lda	eeprombuffer
   1197  27000				   -	       cmp	#$FF
   1198  27000				   -	       beq	loaddifficultytableAVOXempty
   1199  27000				   -	       cmp	#HSIDHI
   1200  27000				   -	       bne	loaddifficultytableAVOXloop
   1201  27000				   -	       lda	eeprombuffer+1
   1202  27000				   -	       cmp	#HSIDLO
   1203  27000				   -	       bne	loaddifficultytableAVOXloop
   1204  27000				   -	       lda	eeprombuffer+2
   1205  27000				   -	       cmp	gamedifficulty
   1206  27000				   -	       bne	loaddifficultytableAVOXloop
   1207  27000				   -loaddifficultytableAVOXdone
   1208  27000				   -	       lda	#32
   1209  27000				   -	       jsr	AVoxReadBytes
   1210  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1211  27000				   -	       rts
   1212  27000				   -loaddifficultytableAVOXfull
   1213  27000				   -	       lda	#0
   1214  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1215  27000				   -loaddifficultytableAVOXempty
   1216  27000				   -	       jmp	cleardifficultytablemem
   1217  27000				   -	       rts
   1218  27000				   -
   1219  27000				   -cleardifficultytablemem
   1220  27000				   -	       ldy	#29
   1221  27000				   -	       lda	#0
   1222  27000				   -cleardifficultytablememloop
   1223  27000				   -	       sta	HSRAMTable,y
   1224  27000				   -	       dey
   1225  27000				   -	       bpl	cleardifficultytablememloop
   1226  27000				   -	       rts
   1227  27000				   -hiscoremoduleend
   1228  27000				   -
   1229  27000				   -	       ifconst	DOUBLEWIDE
   1230  27000				   -plotvaluedw
   1231  27000				   -plotdigitcount =	temp6
   1232  27000				   -	       lda	#0
   1233  27000				   -	       tay
   1234  27000				   -	       ldx	valbufend
   1235  27000				   -
   1236  27000				   -	       lda	plotdigitcount
   1237  27000				   -	       and	#1
   1238  27000				   -	       beq	pvnibble2chardw
   1239  27000				   -	       lda	#0
   1240  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1241  27000				   -	       beq	pvnibble2char_skipnibbledw
   1242  27000				   -
   1243  27000				   -pvnibble2chardw
   1244  27000				   -			; high nibble...
   1245  27000				   -	       lda	(temp7),y
   1246  27000				   -	       and	#$f0
   1247  27000				   -	       lsr
   1248  27000				   -	       lsr
   1249  27000				   -	       lsr
   1250  27000				   -	       lsr
   1251  27000				   -
   1252  27000				   -	       clc
   1253  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1254  27000				   -	       sta	VALBUFFER,x
   1255  27000				   -	       inx
   1256  27000				   -	       dec	plotdigitcount
   1257  27000				   -pvnibble2char_skipnibbledw
   1258  27000				   -			; low nibble...
   1259  27000				   -	       lda	(temp7),y
   1260  27000				   -	       and	#$0f
   1261  27000				   -	       clc
   1262  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1263  27000				   -	       sta	VALBUFFER,x
   1264  27000				   -	       inx
   1265  27000				   -	       iny
   1266  27000				   -
   1267  27000				   -	       dec	plotdigitcount
   1268  27000				   -	       bne	pvnibble2chardw
   1269  27000				   -			;point to the start of our valuebuffer
   1270  27000				   -	       clc
   1271  27000				   -	       lda	#<VALBUFFER
   1272  27000				   -	       adc	valbufend
   1273  27000				   -	       sta	temp1
   1274  27000				   -	       lda	#>VALBUFFER
   1275  27000				   -	       adc	#0
   1276  27000				   -	       sta	temp2
   1277  27000				   -
   1278  27000				   -			;advance valbufend to the end of our value buffer
   1279  27000				   -	       stx	valbufend
   1280  27000				   -
   1281  27000				   -	       ifnconst	plotvalueonscreen
   1282  27000				   -	       jmp	plotcharacters
   1283  27000				   -	       else
   1284  27000				   -	       jmp	plotcharacterslive
   1285  27000				   -	       endif
   1286  27000				   -	       endif		; DOUBLEWIDE
   1287  27000				   -
   1288  27000				   -hiscoreend
   1289  27000				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1290  27000				   -	       endif		; !isBANKSETBANK
   1291  27000					       endif		; HSSUPPORT
   1292  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1779  27000					       endif
   1780  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes of rom)"
     58  27000				   -
     59  27000					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_4.78b.asm
   1782  27000					       endif
   1783  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1784  27000
   1785  27000							;standard routimes needed for pretty much all games
   1786  27000
   1787  27000							; some definitions used with "set debug color"
   1788  27000			00 91	    DEBUGCALC  =	$91
   1789  27000			00 41	    DEBUGWASTE =	$41
   1790  27000			00 c1	    DEBUGDRAW  =	$C1
   1791  27000
   1792  27000							;NMI and IRQ handlers
   1793  27000				    NMI
   1794  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   1795  27000			48		       pha		; save A
   1796  27001			d8		       cld
   1797  27002			a5 4d		       lda	visibleover
   1798  27004			49 ff		       eor	#255
   1799  27006			85 4d		       sta	visibleover
   1800  27008				   -	       ifconst	DEBUGINTERRUPT
   1801  27008				   -	       and	#$93
   1802  27008				   -	       sta	BACKGRND
   1803  27008					       endif
   1804  27008			8a		       txa		; save X
   1805  27009			48		       pha
   1806  2700a			98		       tya		; save Y
   1807  2700b			48		       pha
   1808  2700c			ce b2 01	       dec	interruptindex
   1809  2700f			d0 03		       bne	skipreallyoffvisible
   1810  27011			4c 73 f0	       jmp	reallyoffvisible
   1811  27014				    skipreallyoffvisible
   1812  27014			a5 4d		       lda	visibleover
   1813  27016			d0 03		       bne	carryontopscreenroutine
   1814  27018				   -	       ifconst	.bottomscreenroutine
   1815  27018				   -	       lda	interrupthold
   1816  27018				   -	       beq	skipbottomroutine
   1817  27018				   -	       jsr	.bottomscreenroutine
   1818  27018				   -skipbottomroutine
   1819  27018					       endif
   1820  27018			4c 81 f0	       jmp	NMIexit
   1821  2701b				    carryontopscreenroutine
   1822  2701b				   -	       ifconst	.topscreenroutine
   1823  2701b				   -	       lda	interrupthold
   1824  2701b				   -	       beq	skiptoproutine
   1825  2701b				   -	       jsr	.topscreenroutine
   1826  2701b				   -skiptoproutine
   1827  2701b					       endif
   1828  2701b					       ifnconst	CANARYOFF
   1829  2701b			ad c4 01	       lda	canary
   1830  2701e			f0 07		       beq	skipcanarytriggered
   1831  27020			a9 45		       lda	#$45
   1832  27022			85 20		       sta	BACKGRND
   1833  27024			4c 6b f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   1834  27027				    skipcanarytriggered
   1835  27027					       endif
   1836  27027
   1837  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   1838  2702a
   1839  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   1840  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   1841  2702a
   1842  2702a				   -	       ifconst	LONGCONTROLLERREAD
   1843  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   1844  2702a				   -	       ldy	port1control
   1845  2702a				   -	       lda	longreadtype,y
   1846  2702a				   -	       beq	LLRET1
   1847  2702a				   -	       tay
   1848  2702a				   -	       lda	longreadroutinehiP1,y
   1849  2702a				   -	       sta	inttemp4
   1850  2702a				   -	       lda	longreadroutineloP1,y
   1851  2702a				   -	       sta	inttemp3
   1852  2702a				   -	       jmp	(inttemp3)
   1853  2702a				   -LLRET1
   1854  2702a				   -	       ldy	port0control
   1855  2702a				   -	       lda	longreadtype,y
   1856  2702a				   -	       beq	LLRET0
   1857  2702a				   -	       tay
   1858  2702a				   -	       lda	longreadroutinehiP0,y
   1859  2702a				   -	       sta	inttemp4
   1860  2702a				   -	       lda	longreadroutineloP0,y
   1861  2702a				   -	       sta	inttemp3
   1862  2702a				   -	       jmp	(inttemp3)
   1863  2702a				   -LLRET0
   1864  2702a				   -
   1865  2702a				   -
   1866  2702a				   -	       ifconst	PADDLERANGE
   1867  2702a				   -TIMEVAL    =	PADDLERANGE
   1868  2702a				   -	       else
   1869  2702a				   -TIMEVAL    =	160
   1870  2702a				   -	       endif
   1871  2702a				   -TIMEOFFSET =	10
   1872  2702a				   -
   1873  2702a					       endif		; LONGCONTROLLERREAD
   1874  2702a
   1875  2702a
   1876  2702a			20 18 f2	       jsr	servicesfxchannels
   1877  2702d				   -	       ifconst	MUSICTRACKER
   1878  2702d				   -	       jsr	servicesong
   1879  2702d					       endif		; MUSICTRACKER
   1880  2702d				   -	       ifconst	RMT
   1881  2702d				   -	       ifnconst	RMTOFFSPEED
   1882  2702d				   -	       ifconst	RMTPALSPEED
   1883  2702d				   -	       lda	ntscslowframe
   1884  2702d				   -	       bne	skiprasterupdate
   1885  2702d				   -	       endif
   1886  2702d				   -	       endif
   1887  2702d				   -	       lda	rasterpause
   1888  2702d				   -	       beq	skiprasterupdate
   1889  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   1890  2702d				   -skiprasterupdate
   1891  2702d				   -RMT_Iend
   1892  2702d					       endif
   1893  2702d
   1894  2702d			ee a4 01	       inc	framecounter
   1895  27030			ad a4 01	       lda	framecounter
   1896  27033			29 3f		       and	#63
   1897  27035			d0 08		       bne	skipcountdownseconds
   1898  27037			ad a5 01	       lda	countdownseconds
   1899  2703a			f0 03		       beq	skipcountdownseconds
   1900  2703c			ce a5 01	       dec	countdownseconds
   1901  2703f				    skipcountdownseconds
   1902  2703f
   1903  2703f			a2 01		       ldx	#1
   1904  27041				    buttonreadloop
   1905  27041			8a		       txa
   1906  27042			48		       pha
   1907  27043			bc ba 01	       ldy	port0control,x
   1908  27046			b9 f4 f1	       lda	buttonhandlerlo,y
   1909  27049			85 da		       sta	inttemp3
   1910  2704b			b9 e7 f1	       lda	buttonhandlerhi,y
   1911  2704e			85 db		       sta	inttemp4
   1912  27050			05 da		       ora	inttemp3
   1913  27052			f0 03		       beq	buttonreadloopreturn
   1914  27054			6c da 00	       jmp	(inttemp3)
   1915  27057				    buttonreadloopreturn
   1916  27057			68		       pla
   1917  27058			aa		       tax
   1918  27059			ca		       dex
   1919  2705a			10 e5		       bpl	buttonreadloop
   1920  2705c
   1921  2705c					       ifconst	DOUBLEBUFFER
   1922  2705c			ad b4 01	       lda	doublebufferminimumframeindex
   1923  2705f			f0 03		       beq	skipdoublebufferminimumframeindexadjust
   1924  27061			ce b4 01	       dec	doublebufferminimumframeindex
   1925  27064				    skipdoublebufferminimumframeindexadjust
   1926  27064					       endif
   1927  27064
   1928  27064			4c 81 f0	       jmp	NMIexit
   1929  27067
   1930  27067				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   1931  27067					       ifnconst	BREAKPROTECTOFF
   1932  27067			a9 1a		       lda	#$1A
   1933  27069			85 20		       sta	BACKGRND
   1934  2706b				    skipbrkolorset
   1935  2706b				    skipbrkdetected
   1936  2706b			a9 60		       lda	#$60
   1937  2706d			8d 07 21	       sta	sCTRL
   1938  27070			85 3c		       sta	CTRL
   1939  27072					       ifnconst	hiscorefont
   1940  27072			02		       .byte.b	$02	; KIL/JAM
   1941  27073				   -	       else		; hiscorefont is present
   1942  27073				   -	       ifconst	CRASHDUMP
   1943  27073				   -	       bit	MSTAT
   1944  27073				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   1945  27073				   -
   1946  27073				   -	       ifconst	dumpbankswitch
   1947  27073				   -	       lda	dumpbankswitch
   1948  27073				   -	       pha
   1949  27073				   -	       endif
   1950  27073				   -
   1951  27073				   -			; bankswitch if needed, to get to the hiscore font
   1952  27073				   -	       ifconst	bankswitchmode
   1953  27073				   -	       ifconst	included.hiscore.asm.bank
   1954  27073				   -	       ifconst	MCPDEVCART
   1955  27073				   -	       lda	#($18 | included.hiscore.asm.bank)
   1956  27073				   -	       sta	$3000
   1957  27073				   -	       else
   1958  27073				   -	       lda	#(included.hiscore.asm.bank)
   1959  27073				   -	       sta	$8000
   1960  27073				   -	       endif
   1961  27073				   -	       endif		; included.hiscore.asm.bank
   1962  27073				   -	       endif		; bankswitchmode
   1963  27073				   -
   1964  27073				   -	       ifconst	DOUBLEBUFFER
   1965  27073				   -			;turn off double-buffering, if on...
   1966  27073				   -	       lda	#>DLLMEM
   1967  27073				   -	       sta	DPPH
   1968  27073				   -	       lda	#<DLLMEM
   1969  27073				   -	       sta	DPPL
   1970  27073				   -	       endif
   1971  27073				   -
   1972  27073				   -	       lda	#$00
   1973  27073				   -	       sta	P0C2
   1974  27073				   -
   1975  27073				   -			;update the second-from-top DL...
   1976  27073				   -	       ldy	#8
   1977  27073				   -NMIupdatetopDL
   1978  27073				   -	       lda	show2700,y
   1979  27073				   -	       sta	ZONE1ADDRESS,y
   1980  27073				   -	       dey
   1981  27073				   -	       bpl	NMIupdatetopDL
   1982  27073				   -
   1983  27073				   -			; the hiscore font is present, so we try to output the stack
   1984  27073				   -	       ldy	#0
   1985  27073				   -copystackloop
   1986  27073				   -	       pla
   1987  27073				   -	       pha
   1988  27073				   -	       lsr
   1989  27073				   -	       lsr
   1990  27073				   -	       lsr
   1991  27073				   -	       lsr
   1992  27073				   -	       tax
   1993  27073				   -	       lda	hiscorehexlut,x
   1994  27073				   -	       sta	$2700,y
   1995  27073				   -	       iny
   1996  27073				   -
   1997  27073				   -	       pla
   1998  27073				   -	       and	#$0F
   1999  27073				   -	       tax
   2000  27073				   -	       lda	hiscorehexlut,x
   2001  27073				   -	       sta	$2700,y
   2002  27073				   -	       iny
   2003  27073				   -
   2004  27073				   -	       lda	#27	; period
   2005  27073				   -	       sta	$2700,y
   2006  27073				   -	       iny
   2007  27073				   -
   2008  27073				   -	       cpy	#30
   2009  27073				   -	       bne	copystackloop
   2010  27073				   -
   2011  27073				   -	       lda	#>hiscorefont
   2012  27073				   -	       sta	CHARBASE
   2013  27073				   -	       sta	sCHARBASE
   2014  27073				   -	       lda	#%01000011	;Enable DMA, mode=320A
   2015  27073				   -	       sta	CTRL
   2016  27073				   -	       sta	sCTRL
   2017  27073				   -	       .byte	$02	; KIL/JAM
   2018  27073				   -hiscorehexlut
   2019  27073				   -			; 0 1 2 3 4 5 6 7 8 9 A B C D E F
   2020  27073				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   2021  27073				   -show2700
   2022  27073				   -			; lo mode hi width=29 x EODL
   2023  27073				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   2024  27073				   -	       else		; CRASHDUMP
   2025  27073				   -	       .byte	$02	; KIL/JAM
   2026  27073				   -	       endif		; crashdump
   2027  27073					       endif		; hiscorefont
   2028  27073				   -	       else
   2029  27073				   -	       RTI
   2030  27073					       endif
   2031  27073
   2032  27073				   -	       ifconst	LONGCONTROLLERREAD
   2033  27073				   -
   2034  27073				   -longreadtype
   2035  27073				   -	       .byte	0, 0, 0, 1	; NONE PROLINE LIGHTGUN PADDLE
   2036  27073				   -	       .byte	2, 0, 3, 0	; TRKBALL VCSSTICK DRIVING KEYPAD
   2037  27073				   -	       .byte	3, 3, 0, 0	; STMOUSE AMOUSE ATARIVOX SNES
   2038  27073				   -
   2039  27073				   -longreadroutineloP0
   2040  27073				   -	       .byte	<LLRET0	; 0 = no routine
   2041  27073				   -	       .byte	<paddleport0update	; 1 = paddle
   2042  27073				   -	       .byte	<trakball0update	; 2 = trakball
   2043  27073				   -	       .byte	<mouse0update	; 3 = mouse
   2044  27073				   -
   2045  27073				   -longreadroutinehiP0
   2046  27073				   -	       .byte	>LLRET0	; 0 = no routine
   2047  27073				   -	       .byte	>paddleport0update	; 1 = paddle
   2048  27073				   -	       .byte	>trakball0update	; 2 = trackball
   2049  27073				   -	       .byte	>mouse0update	; 3 = mouse
   2050  27073				   -
   2051  27073				   -longreadroutineloP1
   2052  27073				   -	       .byte	<LLRET1	; 0 = no routine
   2053  27073				   -	       .byte	<paddleport1update	; 1 = paddle
   2054  27073				   -	       .byte	<trakball1update	; 2 = trakball
   2055  27073				   -	       .byte	<mouse1update	; 3 = mouse
   2056  27073				   -
   2057  27073				   -longreadroutinehiP1
   2058  27073				   -	       .byte	>LLRET1	; 0 = no routine
   2059  27073				   -	       .byte	>paddleport1update	; 1 = paddle
   2060  27073				   -	       .byte	>trakball1update	; 2 = trackball
   2061  27073				   -	       .byte	>mouse1update	; 3 = mouse
   2062  27073				   -
   2063  27073				   -
   2064  27073				   -SETTIM64T
   2065  27073				   -	       bne	skipdefaulttime
   2066  27073				   -	       ifnconst	PADDLESMOOTHINGOFF
   2067  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   2068  27073				   -	       else
   2069  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   2070  27073				   -	       endif
   2071  27073				   -skipdefaulttime
   2072  27073				   -	       tay
   2073  27073				   -	       dey
   2074  27073				   -.setTIM64Tloop
   2075  27073				   -	       sta	TIM64T
   2076  27073				   -	       cpy	INTIM
   2077  27073				   -	       bne	.setTIM64Tloop
   2078  27073				   -	       rts
   2079  27073					       endif		; LONGCONTROLLERREAD
   2080  27073
   2081  27073				    reallyoffvisible
   2082  27073			85 24		       sta	WSYNC
   2083  27075
   2084  27075			a9 00		       lda	#0
   2085  27077			85 4d		       sta	visibleover
   2086  27079				   -	       ifconst	DEBUGINTERRUPT
   2087  27079				   -	       sta	BACKGRND
   2088  27079					       endif
   2089  27079
   2090  27079			a9 03		       lda	#3
   2091  2707b			8d b2 01	       sta	interruptindex
   2092  2707e
   2093  2707e			20 65 f1	       jsr	uninterruptableroutines
   2094  27081
   2095  27081				   -	       ifconst	.userinterrupt
   2096  27081				   -	       lda	interrupthold
   2097  27081				   -	       beq	skipuserintroutine
   2098  27081				   -	       jsr	.userinterrupt
   2099  27081				   -skipuserintroutine
   2100  27081					       endif
   2101  27081
   2102  27081				   -	       ifconst	KEYPADSUPPORT
   2103  27081				   -	       jsr	keypadcolumnread
   2104  27081				   -	       jsr	keypadrowselect
   2105  27081					       endif
   2106  27081
   2107  27081				    NMIexit
   2108  27081			68		       pla
   2109  27082			a8		       tay
   2110  27083			68		       pla
   2111  27084			aa		       tax
   2112  27085			68		       pla
   2113  27086			40		       RTI
   2114  27087
   2115  27087				    clearscreen
   2116  27087			a2 0b		       ldx	#(WZONECOUNT-1)
   2117  27089			a9 00		       lda	#0
   2118  2708b				    clearscreenloop
   2119  2708b			95 65		       sta	dlend,x
   2120  2708d			ca		       dex
   2121  2708e			10 fb		       bpl	clearscreenloop
   2122  27090			a9 00		       lda	#0
   2123  27092			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   2124  27095			8d ae 01	       sta	valbufendsave
   2125  27098			60		       rts
   2126  27099
   2127  27099				    restorescreen
   2128  27099			a2 0b		       ldx	#(WZONECOUNT-1)
   2129  2709b			a9 00		       lda	#0
   2130  2709d				    restorescreenloop
   2131  2709d			b5 82		       lda	dlendsave,x
   2132  2709f			95 65		       sta	dlend,x
   2133  270a1			ca		       dex
   2134  270a2			10 f9		       bpl	restorescreenloop
   2135  270a4			ad ae 01	       lda	valbufendsave
   2136  270a7			8d ad 01	       sta	valbufend
   2137  270aa			60		       rts
   2138  270ab
   2139  270ab				    savescreen
   2140  270ab			a2 0b		       ldx	#(WZONECOUNT-1)
   2141  270ad				    savescreenloop
   2142  270ad			b5 65		       lda	dlend,x
   2143  270af			95 82		       sta	dlendsave,x
   2144  270b1			ca		       dex
   2145  270b2			10 f9		       bpl	savescreenloop
   2146  270b4			ad ad 01	       lda	valbufend
   2147  270b7			8d ae 01	       sta	valbufendsave
   2148  270ba					       ifconst	DOUBLEBUFFER
   2149  270ba			a5 d5		       lda	doublebufferstate
   2150  270bc			f0 04		       beq	savescreenrts
   2151  270be			a9 01		       lda	#1
   2152  270c0			85 d7		       sta	doublebufferbufferdirty
   2153  270c2				    savescreenrts
   2154  270c2					       endif		; DOUBLEBUFFER
   2155  270c2			60		       rts
   2156  270c3
   2157  270c3				    drawscreen
   2158  270c3
   2159  270c3				   -	       ifconst	interrupthold
   2160  270c3				   -	       lda	#$FF
   2161  270c3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   2162  270c3					       endif
   2163  270c3
   2164  270c3			a9 00		       lda	#0
   2165  270c5			85 42		       sta	temp1	; not B&W if we're here...
   2166  270c7
   2167  270c7				    drawscreenwait
   2168  270c7			a5 4d		       lda	visibleover
   2169  270c9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2170  270cb
   2171  270cb							;restore some registers in case the game changed them mid-screen...
   2172  270cb			ad 07 21	       lda	sCTRL
   2173  270ce			05 42		       ora	temp1
   2174  270d0			85 3c		       sta	CTRL
   2175  270d2			ad 0b 21	       lda	sCHARBASE
   2176  270d5			85 34		       sta	CHARBASE
   2177  270d7
   2178  270d7							;ensure all of the display list is terminated...
   2179  270d7			20 42 f1	       jsr	terminatedisplaylist
   2180  270da
   2181  270da					       ifnconst	pauseroutineoff
   2182  270da			20 e5 f0	       jsr	pauseroutine
   2183  270dd					       endif		; pauseroutineoff
   2184  270dd
   2185  270dd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2186  270dd							; delaying a full frame, but still allowing time for basic calculations.
   2187  270dd				    visiblescreenstartedwait
   2188  270dd			a5 4d		       lda	visibleover
   2189  270df			f0 fc		       beq	visiblescreenstartedwait
   2190  270e1				    visiblescreenstartedwaitdone
   2191  270e1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2192  270e4			60		       rts
   2193  270e5
   2194  270e5					       ifnconst	pauseroutineoff
   2195  270e5							; check to see if pause was pressed and released
   2196  270e5				    pauseroutine
   2197  270e5			ad b5 01	       lda	pausedisable
   2198  270e8			d0 47		       bne	leavepauseroutine
   2199  270ea			a9 08		       lda	#8
   2200  270ec			2c 82 02	       bit	SWCHB
   2201  270ef			f0 22		       beq	pausepressed
   2202  270f1
   2203  270f1				   -	       ifconst	SNES0PAUSE
   2204  270f1				   -	       lda	port0control
   2205  270f1				   -	       cmp	#11
   2206  270f1				   -	       bne	skipsnes0pause
   2207  270f1				   -	       lda	snesdetected0
   2208  270f1				   -	       beq	skipsnes0pause
   2209  270f1				   -	       lda	snes2atari0hi
   2210  270f1				   -	       and	#%00010000
   2211  270f1				   -	       beq	pausepressed
   2212  270f1				   -skipsnes0pause
   2213  270f1					       endif
   2214  270f1				   -	       ifconst	SNES1PAUSE
   2215  270f1				   -
   2216  270f1				   -	       lda	port1control
   2217  270f1				   -	       cmp	#11
   2218  270f1				   -	       bne	skipsnes1pause
   2219  270f1				   -	       lda	snesdetected1
   2220  270f1				   -	       beq	skipsnes1pause
   2221  270f1				   -	       lda	snes2atari1hi
   2222  270f1				   -	       and	#%00010000
   2223  270f1				   -	       beq	pausepressed
   2224  270f1				   -skipsnes1pause
   2225  270f1					       endif
   2226  270f1				   -	       ifconst	SNESNPAUSE
   2227  270f1				   -	       ldx	snesport
   2228  270f1				   -	       lda	port0control,x
   2229  270f1				   -	       cmp	#11
   2230  270f1				   -	       bne	skipsnesNpause
   2231  270f1				   -	       lda	snesdetected0,x
   2232  270f1				   -	       beq	skipsnesNpause
   2233  270f1				   -	       lda	snes2atari0hi,x
   2234  270f1				   -	       and	#%00010000
   2235  270f1				   -	       beq	pausepressed
   2236  270f1				   -skipsnesNpause
   2237  270f1					       endif
   2238  270f1				   -	       ifconst	MULTIBUTTONPAUSE
   2239  270f1				   -	       ldx	#1
   2240  270f1				   -multibuttonpauseloop
   2241  270f1				   -	       lda	port0control,x
   2242  270f1				   -	       cmp	#11
   2243  270f1				   -	       bcc	multibuttonpauseloopbottom
   2244  270f1				   -	       lda	sINPT1,x
   2245  270f1				   -	       and	#1
   2246  270f1				   -	       beq	pausepressed
   2247  270f1				   -multibuttonpauseloopbottom
   2248  270f1				   -	       dex
   2249  270f1				   -	       bpl	multibuttonpauseloop
   2250  270f1					       endif		; MULTIBUTTONPAUSE
   2251  270f1
   2252  270f1							;pause isn't pressed
   2253  270f1			a9 00		       lda	#0
   2254  270f3			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2255  270f6
   2256  270f6							;check if we're in an already paused state
   2257  270f6			ad 00 21	       lda	pausestate
   2258  270f9			f0 36		       beq	leavepauseroutine	; nope, leave
   2259  270fb
   2260  270fb			c9 01		       cmp	#1	; last frame was the start of pausing
   2261  270fd			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   2262  270ff
   2263  270ff			c9 02		       cmp	#2
   2264  27101			f0 34		       beq	carryonpausing
   2265  27103
   2266  27103							;pausestate must be >2, which means we're ending an unpause 
   2267  27103			a9 00		       lda	#0
   2268  27105			8d ac 01	       sta	pausebuttonflag
   2269  27108			8d 00 21	       sta	pausestate
   2270  2710b			ad 07 21	       lda	sCTRL
   2271  2710e			85 3c		       sta	CTRL
   2272  27110			4c 31 f1	       jmp	leavepauseroutine
   2273  27113
   2274  27113				    pausepressed
   2275  27113							;pause is pressed
   2276  27113			ad ac 01	       lda	pausebuttonflag
   2277  27116			c9 ff		       cmp	#$ff
   2278  27118			f0 1d		       beq	carryonpausing
   2279  2711a
   2280  2711a							;its a new press, increment the state
   2281  2711a			ee 00 21	       inc	pausestate
   2282  2711d
   2283  2711d							;silence volume at the start and end of pausing
   2284  2711d			a9 00		       lda	#0
   2285  2711f			85 19		       sta	AUDV0
   2286  27121			85 1a		       sta	AUDV1
   2287  27123
   2288  27123				   -	       ifconst	pokeysupport
   2289  27123				   -	       ldy	#7
   2290  27123				   -pausesilencepokeyaudioloop
   2291  27123				   -	       sta	(pokeybase),y
   2292  27123				   -	       dey
   2293  27123				   -	       bpl	pausesilencepokeyaudioloop
   2294  27123					       endif		; pokeysupport
   2295  27123
   2296  27123			a9 ff		       lda	#$ff
   2297  27125			8d ac 01	       sta	pausebuttonflag
   2298  27128			d0 0d		       bne	carryonpausing
   2299  2712a
   2300  2712a				    enterpausestate2
   2301  2712a			a9 02		       lda	#2
   2302  2712c			8d 00 21	       sta	pausestate
   2303  2712f			d0 06		       bne	carryonpausing
   2304  27131				    leavepauseroutine
   2305  27131			ad 07 21	       lda	sCTRL
   2306  27134			85 3c		       sta	CTRL
   2307  27136			60		       rts
   2308  27137				    carryonpausing
   2309  27137				   -	       ifconst	.pause
   2310  27137				   -	       jsr	.pause
   2311  27137					       endif		; .pause
   2312  27137			ad 07 21	       lda	sCTRL
   2313  2713a			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2314  2713c			85 3c		       sta	CTRL
   2315  2713e			4c e5 f0	       jmp	pauseroutine
   2316  27141					       endif		; pauseroutineoff
   2317  27141
   2318  27141
   2319  27141					       ifconst	DOUBLEBUFFER
   2320  27141				    skipterminatedisplaylistreturn
   2321  27141			60		       rts
   2322  27142					       endif		; DOUBLEBUFFER
   2323  27142				    terminatedisplaylist
   2324  27142					       ifconst	DOUBLEBUFFER
   2325  27142			a5 d5		       lda	doublebufferstate
   2326  27144			d0 fb		       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2327  27146					       endif		; DOUBLEBUFFER
   2328  27146				    terminatedisplaybuffer
   2329  27146							;add DL end entry on each DL
   2330  27146			a2 0b		       ldx	#(WZONECOUNT-1)
   2331  27148				    dlendloop
   2332  27148			bd 64 f6	       lda	DLPOINTL,x
   2333  2714b					       ifconst	DOUBLEBUFFER
   2334  2714b			18		       clc
   2335  2714c			65 d6		       adc	doublebufferdloffset
   2336  2714e					       endif		; DOUBLEBUFFER
   2337  2714e			85 63		       sta	dlpnt
   2338  27150			bd 58 f6	       lda	DLPOINTH,x
   2339  27153					       ifconst	DOUBLEBUFFER
   2340  27153			69 00		       adc	#0
   2341  27155					       endif		; DOUBLEBUFFER
   2342  27155			85 64		       sta	dlpnt+1
   2343  27157			b4 65		       ldy	dlend,x
   2344  27159			a9 00		       lda	#$00
   2345  2715b				    dlendmoreloops
   2346  2715b			c8		       iny
   2347  2715c			91 63		       sta	(dlpnt),y
   2348  2715e				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2349  2715e				   -	       cpy	#DLLASTOBJ+1
   2350  2715e				   -	       beq	dlendthiszonedone
   2351  2715e				   -	       iny
   2352  2715e				   -	       iny
   2353  2715e				   -	       iny
   2354  2715e				   -	       iny
   2355  2715e				   -	       iny
   2356  2715e				   -	       sta	(dlpnt),y
   2357  2715e				   -dlendthiszonedone
   2358  2715e					       endif	FRAMESKIPGLITCHFIXWEAK
   2359  2715e				   -	       ifconst	FRAMESKIPGLITCHFIX
   2360  2715e				   -	       iny
   2361  2715e				   -	       iny
   2362  2715e				   -	       iny
   2363  2715e				   -	       iny
   2364  2715e				   -	       cpy	#DLLASTOBJ-1
   2365  2715e				   -	       bcc	dlendmoreloops
   2366  2715e					       endif		; FRAMESKIPGLITCHFIX
   2367  2715e			ca		       dex
   2368  2715f			10 e7		       bpl	dlendloop
   2369  27161
   2370  27161					       ifnconst	pauseroutineoff
   2371  27161			20 e5 f0	       jsr	pauseroutine
   2372  27164					       endif		; pauseroutineoff
   2373  27164			60		       rts
   2374  27165
   2375  27165				    uninterruptableroutines
   2376  27165							; this is for routines that must happen off the visible screen, each frame.
   2377  27165
   2378  27165				   -	       ifconst	AVOXVOICE
   2379  27165				   -	       jsr	serviceatarivoxqueue
   2380  27165					       endif
   2381  27165				   -	       ifconst	MEGA7800SUPPORT
   2382  27165				   -	       ldx	#1
   2383  27165				   -mega7800polling
   2384  27165				   -	       lda	port0control,x
   2385  27165				   -	       cmp	#12	; mega7800
   2386  27165				   -	       bne	mega7800handlercheck2
   2387  27165				   -	       jsr	mega7800handler
   2388  27165				   -	       jmp	mega7800handlerdone
   2389  27165				   -mega7800handlercheck2
   2390  27165				   -	       ifconst	MULTIBUTTON
   2391  27165				   -	       cmp	#1	; proline
   2392  27165				   -	       bne	mega7800handlerdone
   2393  27165				   -	       lda	framecounter
   2394  27165				   -	       eor	#7	; avoid the same frame as the snes2atari probe
   2395  27165				   -	       and	#63
   2396  27165				   -	       bne	mega7800handlerdone
   2397  27165				   -	       lda	#12
   2398  27165				   -	       sta	port0control,x
   2399  27165				   -	       jsr	mega7800handler
   2400  27165				   -	       endif		; MULTIBUTTON
   2401  27165				   -mega7800handlerdone
   2402  27165				   -	       dex
   2403  27165				   -	       bpl	mega7800polling
   2404  27165					       endif		; MEGA7800SUPPORT
   2405  27165
   2406  27165			a9 00		       lda	#0
   2407  27167			8d b9 01	       sta	palfastframe
   2408  2716a			8d b8 01	       sta	ntscslowframe
   2409  2716d			ae 09 21	       ldx	paldetected	; 0=ntsc 1=pal
   2410  27170			ac b7 01	       ldy	palframes
   2411  27173			c8		       iny
   2412  27174			c0 05		       cpy	#5
   2413  27176			d0 08		       bne	palframeskipdone
   2414  27178			ad 09 21	       lda	paldetected
   2415  2717b			fe b8 01	       inc	ntscslowframe,x
   2416  2717e			a0 00		       ldy	#0
   2417  27180				    palframeskipdone
   2418  27180			8c b7 01	       sty	palframes
   2419  27183				    skippalframeadjusting
   2420  27183
   2421  27183				   -	       ifconst	MUSICTRACKER
   2422  27183				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2423  27183				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2424  27183				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   2425  27183				   -			; problem twice, and if we do, we just drop a musical note or two.
   2426  27183				   -	       lda	sfxschedulemissed
   2427  27183				   -	       beq	servicesongwasnotmissed
   2428  27183				   -	       jsr	servicesong
   2429  27183				   -servicesongwasnotmissed
   2430  27183					       endif		; MUSICTRACKER
   2431  27183
   2432  27183				   -	       ifconst	RMT
   2433  27183				   -	       ifnconst	RMTPALSPEED
   2434  27183				   -	       ifnconst	RMTOFFSPEED
   2435  27183				   -	       lda	palfastframe
   2436  27183				   -	       beq	skiprasterupdate2
   2437  27183				   -	       lda	rasterpause
   2438  27183				   -	       beq	skiprasterupdate2
   2439  27183				   -	       jsr	RASTERMUSICTRACKER+3
   2440  27183				   -skiprasterupdate2
   2441  27183				   -	       endif
   2442  27183				   -	       endif
   2443  27183					       endif
   2444  27183
   2445  27183			60		       rts
   2446  27184
   2447  27184				    serviceatarivoxqueue
   2448  27184				   -	       ifconst	AVOXVOICE
   2449  27184				   -	       lda	voxlock
   2450  27184				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2451  27184				   -skipvoxqueuesizedec
   2452  27184				   -	       jmp	processavoxvoice
   2453  27184				   -skipvoxprocessing
   2454  27184				   -	       rts
   2455  27184				   -
   2456  27184				   -processavoxvoice
   2457  27184				   -	       ifconst	HSSUPPORT
   2458  27184				   -			; ** we skip speech if hi-score is on and no vox was detected
   2459  27184				   -			; ** this is to avoid later collision with snes pads.
   2460  27184				   -	       lda	hsdevice
   2461  27184				   -	       and	#2
   2462  27184				   -	       beq	processavoxvoicereturn
   2463  27184				   -	       endif		; HSSUPPORT
   2464  27184				   -	       lda	avoxenable
   2465  27184				   -	       bne	avoxfixport
   2466  27184				   -	       SPKOUT	tempavox
   2467  27184				   -	       rts
   2468  27184				   -avoxfixport
   2469  27184				   -	       lda	#0	; restore the port to all bits as inputs...
   2470  27184				   -	       sta	CTLSWA
   2471  27184				   -	       rts
   2472  27184				   -silenceavoxvoice
   2473  27184				   -	       SPEAK	avoxsilentdata
   2474  27184				   -processavoxvoicereturn
   2475  27184				   -	       rts
   2476  27184				   -avoxsilentdata
   2477  27184				   -	       .byte	31,255
   2478  27184					       else
   2479  27184			60		       rts
   2480  27185					       endif		; AVOXVOICE
   2481  27185
   2482  27185				    prolinebuttonpadhandler
   2483  27185				   -	       ifconst	MULTIBUTTON
   2484  27185				   -	       lda	framecounter
   2485  27185				   -	       and	#63
   2486  27185				   -	       bne	jbhandlercont1
   2487  27185				   -	       jsr	setonebuttonmode
   2488  27185				   -	       lda	#11
   2489  27185				   -	       sta	port0control,x
   2490  27185				   -	       jsr	snes2atari_signal_go
   2491  27185				   -	       lda	port0control,x
   2492  27185				   -	       cmp	#1	; check if it's still a proline 
   2493  27185				   -	       beq	jbhandlercont1
   2494  27185				   -	       jmp	buttonreadloopreturn
   2495  27185				   -jbhandlercont1
   2496  27185				   -	       lda	#2
   2497  27185				   -	       sta	multibuttoncount0,x
   2498  27185					       endif		; MULTIBUTTON
   2499  27185				    joybuttonpadhandler
   2500  27185			ad 31 21	       lda	sSWCHA	; clear previous dirs for this pad, from
   2501  27188			1d d7 f1	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
   2502  2718b			8d 31 21	       sta	sSWCHA
   2503  2718e			ad 80 02	       lda	SWCHA	; load th actual joystick dirs, ensuring
   2504  27191			1d d8 f1	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
   2505  27194			2d 31 21	       and	sSWCHA
   2506  27197			8d 31 21	       sta	sSWCHA
   2507  2719a				    joybuttonhandler
   2508  2719a			8a		       txa
   2509  2719b			0a		       asl
   2510  2719c			a8		       tay
   2511  2719d			b9 08 00	       lda	INPT0,y
   2512  271a0			4a		       lsr
   2513  271a1							;ora #%00111111
   2514  271a1			9d 02 21	       sta	sINPT1,x
   2515  271a4			b9 09 00	       lda	INPT1,y
   2516  271a7			29 80		       and	#%10000000
   2517  271a9			1d 02 21	       ora	sINPT1,x
   2518  271ac			9d 02 21	       sta	sINPT1,x
   2519  271af
   2520  271af			b5 0c		       lda	INPT4,x
   2521  271b1			30 19		       bmi	.skip1bjoyfirecheck
   2522  271b3							;one button joystick is down
   2523  271b3			49 80		       eor	#%10000000
   2524  271b5			9d 02 21	       sta	sINPT1,x
   2525  271b8
   2526  271b8			ad b1 01	       lda	joybuttonmode
   2527  271bb			3d d2 f5	       and	thisjoy2buttonbit,x
   2528  271be			f0 0c		       beq	.skip1bjoyfirecheck
   2529  271c0			ad b1 01	       lda	joybuttonmode
   2530  271c3			1d d2 f5	       ora	thisjoy2buttonbit,x
   2531  271c6			8d b1 01	       sta	joybuttonmode
   2532  271c9			8d 82 02	       sta	SWCHB
   2533  271cc				    .skip1bjoyfirecheck
   2534  271cc			a9 3f		       lda	#%00111111
   2535  271ce			1d 02 21	       ora	sINPT1,x
   2536  271d1			9d 02 21	       sta	sINPT1,x	; ensure multibutton bits are hi
   2537  271d4			4c 57 f0	       jmp	buttonreadloopreturn
   2538  271d7
   2539  271d7				    SWCHA_DIRMASK
   2540  271d7							;  p0	p1  p0
   2541  271d7			f0 0f f0	       .byte.b	$F0,$0F,$F0
   2542  271da
   2543  271da				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2544  271da				   -	       ifconst	LIGHTGUNSUPPORT
   2545  271da				   -	       cpx	#0
   2546  271da				   -	       bne	secondportgunhandler
   2547  271da				   -firstportgunhandler
   2548  271da				   -	       lda	SWCHA
   2549  271da				   -	       asl
   2550  271da				   -	       asl
   2551  271da				   -	       asl		; shift D4 to D7
   2552  271da				   -	       and	#%10000000
   2553  271da				   -	       eor	#%10000000
   2554  271da				   -	       sta	sINPT1
   2555  271da				   -	       jmp	buttonreadloopreturn
   2556  271da				   -secondportgunhandler
   2557  271da				   -	       lda	SWCHA
   2558  271da				   -	       lsr		; shift D0 into carry
   2559  271da				   -	       lsr		; shift carry into D7
   2560  271da				   -	       and	#%10000000
   2561  271da				   -	       eor	#%10000000
   2562  271da				   -	       sta	sINPT3
   2563  271da				   -	       jmp	buttonreadloopreturn
   2564  271da					       endif		; LIGHTGUNSUPPORT
   2565  271da
   2566  271da				    controlsusing2buttoncode
   2567  271da			00		       .byte.b	0	; 00=no controller plugged in
   2568  271db			01		       .byte.b	1	; 01=proline joystick
   2569  271dc			00		       .byte.b	0	; 02=lightgun
   2570  271dd			00		       .byte.b	0	; 03=paddle
   2571  271de			01		       .byte.b	1	; 04=trakball
   2572  271df			01		       .byte.b	1	; 05=vcs joystick
   2573  271e0			01		       .byte.b	1	; 06=driving control
   2574  271e1			00		       .byte.b	0	; 07=keypad control
   2575  271e2			00		       .byte.b	0	; 08=st mouse/cx80
   2576  271e3			00		       .byte.b	0	; 09=amiga mouse
   2577  271e4			01		       .byte.b	1	; 10=atarivox
   2578  271e5			00		       .byte.b	0	; 11=snes2atari
   2579  271e6			00		       .byte.b	0	; 12=mega7800
   2580  271e7
   2581  271e7				    buttonhandlerhi
   2582  271e7			00		       .byte.b	0	; 00=no controller plugged in
   2583  271e8			f1		       .byte.b	>prolinebuttonpadhandler	; 01=proline joystick
   2584  271e9			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   2585  271ea			f5		       .byte.b	>paddlebuttonhandler	; 03=paddle
   2586  271eb			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   2587  271ec			f1		       .byte.b	>joybuttonpadhandler	; 05=vcs joystick
   2588  271ed			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   2589  271ee			00		       .byte.b	0	; 07=keypad
   2590  271ef			f5		       .byte.b	>mousebuttonhandler	; 08=st mouse
   2591  271f0			f5		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2592  271f1			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   2593  271f2			f0		       .byte.b	>snes2atarihandler	; 11=snes
   2594  271f3			00		       .byte.b	0	; 12=mega7800
   2595  271f4				    buttonhandlerlo
   2596  271f4			00		       .byte.b	0	; 00=no controller plugged in
   2597  271f5			85		       .byte.b	<prolinebuttonpadhandler	; 01=proline joystick
   2598  271f6			da		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   2599  271f7			a2		       .byte.b	<paddlebuttonhandler	; 03=paddle
   2600  271f8			9a		       .byte.b	<joybuttonhandler	; 04=trakball
   2601  271f9			85		       .byte.b	<joybuttonpadhandler	; 05=vcs joystick
   2602  271fa			9a		       .byte.b	<joybuttonhandler	; 06=driving control
   2603  271fb			00		       .byte.b	0	; 07=keypad
   2604  271fc			a2		       .byte.b	<mousebuttonhandler	; 08=st mouse
   2605  271fd			a2		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2606  271fe			9a		       .byte.b	<joybuttonhandler	; 10=atarivox
   2607  271ff			00		       .byte.b	<snes2atarihandler	; 11=snes
   2608  27200			00		       .byte.b	0	; 12=mega7800
   2609  27201
   2610  27201				    drawwait
   2611  27201			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2612  27203			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   2613  27205			60		       rts
   2614  27206
   2615  27206				    drawoverwait
   2616  27206			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2617  27208			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   2618  2720a			60		       rts
   2619  2720b
   2620  2720b
   2621  2720b				    mutetia
   2622  2720b			a9 00		       lda	#0
   2623  2720d			a2 03		       ldx	#3
   2624  2720f				    mutetialoop
   2625  2720f			95 4e		       sta	sfx1pointlo,x
   2626  27211			95 17		       sta	AUDF0,x
   2627  27213			ca		       dex
   2628  27214			10 f9		       bpl	mutetialoop
   2629  27216			60		       rts
   2630  27217
   2631  27217				    servicesfxchannelsdone
   2632  27217					       ifnconst	pokeysupport
   2633  27217			60		       rts
   2634  27218				   -	       else
   2635  27218				   -	       jmp	checkpokeyplaying
   2636  27218					       endif
   2637  27218				    servicesfxchannels
   2638  27218			a2 ff		       ldx	#255
   2639  2721a				    servicesfxchannelsloop
   2640  2721a			e8		       inx
   2641  2721b					       ifnconst	TIASFXMONO
   2642  2721b			e0 02		       cpx	#2
   2643  2721d				   -	       else
   2644  2721d				   -	       cpx	#1
   2645  2721d					       endif
   2646  2721d			f0 f8		       beq	servicesfxchannelsdone
   2647  2721f
   2648  2721f			a5 de		       lda	sfxschedulelock	; =1 if locked
   2649  27221			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   2650  27223
   2651  27223			b5 4e		       lda	sfx1pointlo,x
   2652  27225			85 dc		       sta	inttemp5
   2653  27227			15 50		       ora	sfx1pointhi,x
   2654  27229			f0 ef		       beq	servicesfxchannelsloop
   2655  2722b			b5 50		       lda	sfx1pointhi,x
   2656  2722d			85 dd		       sta	inttemp6
   2657  2722f
   2658  2722f			b5 58		       lda	sfx1tick,x
   2659  27231			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   2660  27233			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2661  27235			4c 1a f2	       jmp	servicesfxchannelsloop
   2662  27238				    servicesfx_cont1
   2663  27238
   2664  27238			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   2665  2723a			b1 dc		       lda	(inttemp5),y
   2666  2723c			c9 10		       cmp	#$10
   2667  2723e			d0 1b		       bne	servicesfx_cont1a
   2668  27240			a0 02		       ldy	#2
   2669  27242			b1 dc		       lda	(inttemp5),y
   2670  27244			95 56		       sta	sfx1frames,x	; change the frame countdown
   2671  27246			a9 00		       lda	#0
   2672  27248			95 58		       sta	sfx1tick,x
   2673  2724a							; advance the sound pointer by 3...
   2674  2724a			b5 4e		       lda	sfx1pointlo,x
   2675  2724c			18		       clc
   2676  2724d			69 03		       adc	#3
   2677  2724f			95 4e		       sta	sfx1pointlo,x
   2678  27251			b5 50		       lda	sfx1pointhi,x
   2679  27253			69 00		       adc	#0
   2680  27255			95 50		       sta	sfx1pointhi,x
   2681  27257							; and then fetch another sample for this channel...
   2682  27257			ca		       dex
   2683  27258			4c 1a f2	       jmp	servicesfxchannelsloop
   2684  2725b				    servicesfx_cont1a
   2685  2725b
   2686  2725b			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2687  2725d			95 58		       sta	sfx1tick,x
   2688  2725f
   2689  2725f			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2690  27261			f0 02		       beq	servicesfx_cont2
   2691  27263			d6 52		       dec	sfx1priority,x
   2692  27265				    servicesfx_cont2
   2693  27265
   2694  27265			a0 00		       ldy	#0	; play the sound
   2695  27267			b1 dc		       lda	(inttemp5),y
   2696  27269			85 d8		       sta	inttemp1
   2697  2726b
   2698  2726b				   -	       ifconst	MUSICTRACKER
   2699  2726b				   -	       lda	sfx1notedata,x
   2700  2726b				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   2701  2726b				   -	       ldy	#0
   2702  2726b				   -	       sty	inttemp2
   2703  2726b				   -	       clc
   2704  2726b				   -	       adc	(inttemp5),y
   2705  2726b				   -	       asl		; x2
   2706  2726b				   -	       tay
   2707  2726b				   -	       lda	tiatrackeroctavenotes,y
   2708  2726b				   -	       sta	AUDC0,x
   2709  2726b				   -	       iny
   2710  2726b				   -	       lda	tiatrackeroctavenotes,y
   2711  2726b				   -	       sta	AUDF0,x
   2712  2726b				   -	       ldy	#1
   2713  2726b				   -	       jmp	sfxvolumeentrypt
   2714  2726b				   -exitmusictracker
   2715  2726b				   -	       lda	inttemp1
   2716  2726b					       endif		; MUSICTRACKER
   2717  2726b
   2718  2726b			18		       clc
   2719  2726c			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   2720  2726e			95 17		       sta	AUDF0,x
   2721  27270			c8		       iny
   2722  27271			b1 dc		       lda	(inttemp5),y
   2723  27273			95 15		       sta	AUDC0,x
   2724  27275			85 d9		       sta	inttemp2
   2725  27277			c8		       iny
   2726  27278				    sfxvolumeentrypt
   2727  27278				   -	       ifconst	TIAVOLUME
   2728  27278				   -	       lda	tiavolume
   2729  27278				   -	       asl
   2730  27278				   -	       asl
   2731  27278				   -	       asl
   2732  27278				   -	       asl
   2733  27278				   -	       sta	fourbitfadevalueint
   2734  27278					       endif		; TIAVOLUME
   2735  27278			b1 dc		       lda	(inttemp5),y
   2736  2727a				   -	       ifconst	TIAVOLUME
   2737  2727a				   -	       jsr	fourbitfadeint
   2738  2727a					       endif		; TIAVOLUME
   2739  2727a			95 19		       sta	AUDV0,x
   2740  2727c			c9 10		       cmp	#$10
   2741  2727e			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2742  27280
   2743  27280			05 d9		       ora	inttemp2
   2744  27282			05 d8		       ora	inttemp1	; check if F|C|V=0
   2745  27284			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   2746  27286
   2747  27286				    advancesfxpointer
   2748  27286							; advance the pointer to the next sound chunk
   2749  27286			c8		       iny
   2750  27287			84 da		       sty	inttemp3
   2751  27289			18		       clc
   2752  2728a			b5 4e		       lda	sfx1pointlo,x
   2753  2728c			65 da		       adc	inttemp3
   2754  2728e			95 4e		       sta	sfx1pointlo,x
   2755  27290			b5 50		       lda	sfx1pointhi,x
   2756  27292			69 00		       adc	#0
   2757  27294			95 50		       sta	sfx1pointhi,x
   2758  27296			4c 1a f2	       jmp	servicesfxchannelsloop
   2759  27299
   2760  27299				    sfxsoundloop
   2761  27299			48		       pha
   2762  2729a			b5 52		       lda	sfx1priority,x
   2763  2729c			d0 04		       bne	sfxsoundloop_carryon
   2764  2729e			68		       pla		; fix the stack before we go
   2765  2729f			4c 86 f2	       jmp	advancesfxpointer
   2766  272a2				    sfxsoundloop_carryon
   2767  272a2			68		       pla
   2768  272a3			29 f0		       and	#$F0
   2769  272a5			4a		       lsr
   2770  272a6			4a		       lsr
   2771  272a7			4a		       lsr
   2772  272a8			4a		       lsr
   2773  272a9
   2774  272a9				    zerosfx
   2775  272a9			95 4e		       sta	sfx1pointlo,x
   2776  272ab			95 50		       sta	sfx1pointhi,x
   2777  272ad			95 52		       sta	sfx1priority,x
   2778  272af			4c 1a f2	       jmp	servicesfxchannelsloop
   2779  272b2
   2780  272b2
   2781  272b2				    schedulesfx
   2782  272b2							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2783  272b2			a0 00		       ldy	#0
   2784  272b4			b1 e0		       lda	(sfxinstrumentlo),y
   2785  272b6				   -	       ifconst	pokeysupport
   2786  272b6				   -	       cmp	#$20	; POKEY?
   2787  272b6				   -	       bne	scheduletiasfx
   2788  272b6				   -	       jmp	schedulepokeysfx
   2789  272b6					       endif
   2790  272b6				    scheduletiasfx
   2791  272b6							;cmp #$10 ; TIA?
   2792  272b6							;beq continuescheduletiasfx
   2793  272b6							; rts ; unhandled!!! 
   2794  272b6				    continuescheduletiasfx
   2795  272b6					       ifnconst	TIASFXMONO
   2796  272b6			a5 4e		       lda	sfx1pointlo
   2797  272b8			05 50		       ora	sfx1pointhi
   2798  272ba			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   2799  272bc			a5 4f		       lda	sfx2pointlo
   2800  272be			05 51		       ora	sfx2pointhi
   2801  272c0			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   2802  272c2							; Both channels are scheduled. 
   2803  272c2			a0 01		       ldy	#1
   2804  272c4			b1 e0		       lda	(sfxinstrumentlo),y
   2805  272c6			d0 01		       bne	interruptsfx
   2806  272c8			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2807  272c9				    interruptsfx
   2808  272c9							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2809  272c9			a5 52		       lda	sfx1priority
   2810  272cb			c5 53		       cmp	sfx2priority
   2811  272cd			b0 04		       bcs	schedulesfx2
   2812  272cf					       endif		; !TIASFXMONO
   2813  272cf
   2814  272cf				    schedulesfx1
   2815  272cf			a2 00		       ldx	#0	; channel 1
   2816  272d1					       ifnconst	TIASFXMONO
   2817  272d1			f0 02		       beq	skipschedulesfx2
   2818  272d3				    schedulesfx2
   2819  272d3			a2 01		       ldx	#1	; channel 2
   2820  272d5				    skipschedulesfx2
   2821  272d5					       endif		; !TIASFXMONO
   2822  272d5
   2823  272d5				   -	       ifconst	MUSICTRACKER
   2824  272d5				   -	       lda	sfxnoteindex
   2825  272d5				   -	       bpl	skipdrumkitoverride
   2826  272d5				   -	       and	#$7F	; subtract 128
   2827  272d5				   -	       sec
   2828  272d5				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   2829  272d5				   -	       asl
   2830  272d5				   -	       tay
   2831  272d5				   -	       lda	tiadrumkitdefinition,y
   2832  272d5				   -	       sta	sfxinstrumentlo
   2833  272d5				   -	       iny
   2834  272d5				   -	       lda	tiadrumkitdefinition,y
   2835  272d5				   -	       sta	sfxinstrumenthi
   2836  272d5				   -	       lda	#0
   2837  272d5				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2838  272d5				   -skipdrumkitoverride
   2839  272d5					       endif		; MUSICTRACKER
   2840  272d5			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   2841  272d7			b1 e0		       lda	(sfxinstrumentlo),y
   2842  272d9			95 52		       sta	sfx1priority,x
   2843  272db			c8		       iny
   2844  272dc			b1 e0		       lda	(sfxinstrumentlo),y
   2845  272de			95 56		       sta	sfx1frames,x
   2846  272e0			a5 e0		       lda	sfxinstrumentlo
   2847  272e2			18		       clc
   2848  272e3			69 03		       adc	#3
   2849  272e5			95 4e		       sta	sfx1pointlo,x
   2850  272e7			a5 e1		       lda	sfxinstrumenthi
   2851  272e9			69 00		       adc	#0
   2852  272eb			95 50		       sta	sfx1pointhi,x
   2853  272ed			a5 e2		       lda	sfxpitchoffset
   2854  272ef			95 54		       sta	sfx1poffset,x
   2855  272f1			a9 00		       lda	#0
   2856  272f3			95 58		       sta	sfx1tick,x
   2857  272f5			a5 e3		       lda	sfxnoteindex
   2858  272f7			95 cd		       sta	sfx1notedata,x
   2859  272f9			60		       rts
   2860  272fa
   2861  272fa				    plotsprite
   2862  272fa					       ifnconst	NODRAWWAIT
   2863  272fa					       ifconst	DOUBLEBUFFER
   2864  272fa			a5 d5		       lda	doublebufferstate
   2865  272fc			d0 04		       bne	skipplotspritewait
   2866  272fe					       endif		; DOUBLEBUFFER
   2867  272fe				   -	       ifconst	DEBUGWAITCOLOR
   2868  272fe				   -	       lda	#$41
   2869  272fe				   -	       sta	BACKGRND
   2870  272fe					       endif
   2871  272fe				    plotspritewait
   2872  272fe			a5 4d		       lda	visibleover
   2873  27300			d0 fc		       bne	plotspritewait
   2874  27302				    skipplotspritewait
   2875  27302				   -	       ifconst	DEBUGWAITCOLOR
   2876  27302				   -	       lda	#$0
   2877  27302				   -	       sta	BACKGRND
   2878  27302					       endif
   2879  27302					       endif
   2880  27302
   2881  27302							;arguments: 
   2882  27302							; temp1=lo graphicdata 
   2883  27302							; temp2=hi graphicdata 
   2884  27302							; temp3=palette | width byte
   2885  27302							; temp4=x
   2886  27302							; temp5=y
   2887  27302							; temp6=mode
   2888  27302			a5 46		       lda	temp5	;Y position
   2889  27304			4a		       lsr		; 2 - Divide by 8 or 16
   2890  27305			4a		       lsr		; 2
   2891  27306			4a		       lsr		; 2
   2892  27307					       if	WZONEHEIGHT = 16
   2893  27307			4a		       lsr		; 2
   2894  27308					       endif
   2895  27308
   2896  27308			aa		       tax
   2897  27309
   2898  27309					       ifnconst	NOLIMITCHECKING
   2899  27309
   2900  27309							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   2901  27309
   2902  27309			c9 0c		       cmp	#WZONECOUNT
   2903  2730b
   2904  2730b			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   2905  2730d							; otherwise, check to see if the bottom half is in zone 0...
   2906  2730d
   2907  2730d					       if	WZONEHEIGHT = 16
   2908  2730d			c9 0f		       cmp	#15
   2909  2730f				   -	       else
   2910  2730f				   -	       cmp	#31
   2911  2730f					       endif
   2912  2730f
   2913  2730f			d0 05		       bne	exitplotsprite1
   2914  27311			a2 00		       ldx	#0
   2915  27313			4c 51 f3	       jmp	continueplotsprite2
   2916  27316				    exitplotsprite1
   2917  27316			60		       rts
   2918  27317
   2919  27317				    continueplotsprite1
   2920  27317					       endif
   2921  27317
   2922  27317			bd 64 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2923  2731a					       ifconst	DOUBLEBUFFER
   2924  2731a			18		       clc
   2925  2731b			65 d6		       adc	doublebufferdloffset
   2926  2731d					       endif		; DOUBLEBUFFER
   2927  2731d			85 63		       sta	dlpnt
   2928  2731f			bd 58 f6	       lda	DLPOINTH,x
   2929  27322					       ifconst	DOUBLEBUFFER
   2930  27322			69 00		       adc	#0
   2931  27324					       endif		; DOUBLEBUFFER
   2932  27324			85 64		       sta	dlpnt+1
   2933  27326
   2934  27326							;Create DL entry for upper part of sprite
   2935  27326
   2936  27326			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   2937  27328
   2938  27328				   -	       ifconst	CHECKOVERWRITE
   2939  27328				   -	       cpy	#DLLASTOBJ
   2940  27328				   -	       beq	checkcontinueplotsprite2
   2941  27328				   -continueplotsprite1a
   2942  27328					       endif
   2943  27328
   2944  27328			a5 42		       lda	temp1	; graphic data, lo byte
   2945  2732a			91 63		       sta	(dlpnt),y	;Low byte of data address
   2946  2732c
   2947  2732c					       ifnconst	ATOMICSPRITEUPDATE
   2948  2732c			c8		       iny
   2949  2732d			a5 47		       lda	temp6
   2950  2732f			91 63		       sta	(dlpnt),y
   2951  27331				   -	       else
   2952  27331				   -	       iny
   2953  27331				   -	       sty	temp8
   2954  27331					       endif
   2955  27331
   2956  27331			c8		       iny
   2957  27332
   2958  27332			a5 46		       lda	temp5	;Y position
   2959  27334			29 0f		       and	#(WZONEHEIGHT - 1)
   2960  27336			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   2961  27338			05 43		       ora	temp2	; graphic data, hi byte
   2962  2733a			91 63		       sta	(dlpnt),y
   2963  2733c
   2964  2733c
   2965  2733c			c8		       iny
   2966  2733d			a5 44		       lda	temp3	;palette|width
   2967  2733f			91 63		       sta	(dlpnt),y
   2968  27341
   2969  27341			c8		       iny
   2970  27342			a5 45		       lda	temp4	;Horizontal position
   2971  27344			91 63		       sta	(dlpnt),y
   2972  27346
   2973  27346			c8		       iny
   2974  27347			94 65		       sty	dlend,x
   2975  27349
   2976  27349				   -	       ifconst	ALWAYSTERMINATE
   2977  27349				   -	       iny
   2978  27349				   -	       lda	#0
   2979  27349				   -	       sta	(dlpnt),y
   2980  27349					       endif
   2981  27349
   2982  27349				   -	       ifconst	ATOMICSPRITEUPDATE
   2983  27349				   -	       ldy	temp8
   2984  27349				   -	       lda	temp6
   2985  27349				   -	       sta	(dlpnt),y
   2986  27349					       endif
   2987  27349
   2988  27349				    checkcontinueplotsprite2
   2989  27349
   2990  27349			90 38		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   2991  2734b
   2992  2734b							;Create DL entry for lower part of sprite
   2993  2734b
   2994  2734b			e8		       inx		;Next region
   2995  2734c
   2996  2734c					       ifnconst	NOLIMITCHECKING
   2997  2734c			e0 0c		       cpx	#WZONECOUNT
   2998  2734e
   2999  2734e			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3000  27350			60		       rts
   3001  27351				    continueplotsprite2
   3002  27351					       endif
   3003  27351
   3004  27351			bd 64 f6	       lda	DLPOINTL,x	;Get pointer to next DL
   3005  27354					       ifconst	DOUBLEBUFFER
   3006  27354			18		       clc
   3007  27355			65 d6		       adc	doublebufferdloffset
   3008  27357					       endif		; DOUBLEBUFFER
   3009  27357			85 63		       sta	dlpnt
   3010  27359			bd 58 f6	       lda	DLPOINTH,x
   3011  2735c					       ifconst	DOUBLEBUFFER
   3012  2735c			69 00		       adc	#0
   3013  2735e					       endif		; DOUBLEBUFFER
   3014  2735e			85 64		       sta	dlpnt+1
   3015  27360			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3016  27362
   3017  27362				   -	       ifconst	CHECKOVERWRITE
   3018  27362				   -	       cpy	#DLLASTOBJ
   3019  27362				   -	       bne	continueplotsprite2a
   3020  27362				   -	       rts
   3021  27362				   -continueplotsprite2a
   3022  27362					       endif
   3023  27362
   3024  27362			a5 42		       lda	temp1	; graphic data, lo byte
   3025  27364			91 63		       sta	(dlpnt),y
   3026  27366
   3027  27366					       ifnconst	ATOMICSPRITEUPDATE
   3028  27366			c8		       iny
   3029  27367			a5 47		       lda	temp6
   3030  27369			91 63		       sta	(dlpnt),y
   3031  2736b				   -	       else
   3032  2736b				   -	       iny
   3033  2736b				   -	       sty	temp8
   3034  2736b					       endif
   3035  2736b
   3036  2736b			c8		       iny
   3037  2736c
   3038  2736c			a5 46		       lda	temp5	;Y position
   3039  2736e			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   3040  27370			05 43		       ora	temp2	; graphic data, hi byte
   3041  27372			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   3042  27374			91 63		       sta	(dlpnt),y
   3043  27376
   3044  27376			c8		       iny
   3045  27377
   3046  27377			a5 44		       lda	temp3	;palette|width
   3047  27379			91 63		       sta	(dlpnt),y
   3048  2737b
   3049  2737b			c8		       iny
   3050  2737c
   3051  2737c			a5 45		       lda	temp4	;Horizontal position
   3052  2737e			91 63		       sta	(dlpnt),y
   3053  27380
   3054  27380			c8		       iny
   3055  27381			94 65		       sty	dlend,x
   3056  27383
   3057  27383				   -	       ifconst	ALWAYSTERMINATE
   3058  27383				   -	       iny
   3059  27383				   -	       lda	#0
   3060  27383				   -	       sta	(dlpnt),y
   3061  27383					       endif
   3062  27383
   3063  27383				   -	       ifconst	ATOMICSPRITEUPDATE
   3064  27383				   -	       ldy	temp8
   3065  27383				   -	       lda	temp6
   3066  27383				   -	       sta	(dlpnt),y
   3067  27383					       endif
   3068  27383
   3069  27383				    doneSPDL
   3070  27383			60		       rts
   3071  27384
   3072  27384
   3073  27384				    lockzonex
   3074  27384				   -	       ifconst	ZONELOCKS
   3075  27384				   -	       ldy	dlend,x
   3076  27384				   -	       cpy	#DLLASTOBJ
   3077  27384				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3078  27384				   -	       lda	DLPOINTL,x
   3079  27384				   -	       ifconst	DOUBLEBUFFER
   3080  27384				   -	       clc
   3081  27384				   -	       adc	doublebufferdloffset
   3082  27384				   -	       endif		; DOUBLEBUFFER
   3083  27384				   -	       sta	dlpnt
   3084  27384				   -	       lda	DLPOINTH,x
   3085  27384				   -	       ifconst	DOUBLEBUFFER
   3086  27384				   -	       adc	#0
   3087  27384				   -	       endif		; DOUBLEBUFFER
   3088  27384				   -	       sta	dlpnt+1
   3089  27384				   -	       iny
   3090  27384				   -	       lda	#0
   3091  27384				   -	       sta	(dlpnt),y
   3092  27384				   -	       dey
   3093  27384				   -	       tya
   3094  27384				   -	       ldy	#(DLLASTOBJ-1)
   3095  27384				   -	       sta	(dlpnt),y
   3096  27384				   -	       iny
   3097  27384				   -	       sty	dlend,x
   3098  27384				   -lockzonexreturn
   3099  27384				   -	       rts
   3100  27384					       endif		; ZONELOCKS
   3101  27384				    unlockzonex
   3102  27384				   -	       ifconst	ZONELOCKS
   3103  27384				   -	       ldy	dlend,x
   3104  27384				   -	       cpy	#DLLASTOBJ
   3105  27384				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3106  27384				   -	       lda	DLPOINTL,x
   3107  27384				   -	       ifconst	DOUBLEBUFFER
   3108  27384				   -	       clc
   3109  27384				   -	       adc	doublebufferdloffset
   3110  27384				   -	       endif		; DOUBLEBUFFER
   3111  27384				   -	       sta	dlpnt
   3112  27384				   -	       lda	DLPOINTH,x
   3113  27384				   -	       ifconst	DOUBLEBUFFER
   3114  27384				   -	       adc	#0
   3115  27384				   -	       endif		; DOUBLEBUFFER
   3116  27384				   -	       sta	dlpnt+1
   3117  27384				   -	       dey
   3118  27384				   -			;ldy #(DLLASTOBJ-1)
   3119  27384				   -	       lda	(dlpnt),y
   3120  27384				   -	       tay
   3121  27384				   -	       sty	dlend,x
   3122  27384				   -unlockzonexreturn
   3123  27384					       endif		; ZONELOCKS
   3124  27384			60		       rts
   3125  27385
   3126  27385				    plotcharloop
   3127  27385							; ** read from a data indirectly pointed to from temp8,temp9
   3128  27385							; ** format is: lo_data, hi_data, palette|width, x, y
   3129  27385							; ** format ends with lo_data | hi_data = 0
   3130  27385
   3131  27385					       ifconst	DOUBLEBUFFER
   3132  27385			a5 d5		       lda	doublebufferstate
   3133  27387			d0 04		       bne	skipplotcharloopwait
   3134  27389					       endif		; DOUBLEBUFFER
   3135  27389				   -	       ifconst	DEBUGWAITCOLOR
   3136  27389				   -	       lda	#$61
   3137  27389				   -	       sta	BACKGRND
   3138  27389					       endif
   3139  27389				    plotcharloopwait
   3140  27389			a5 4d		       lda	visibleover
   3141  2738b			d0 fc		       bne	plotcharloopwait
   3142  2738d				   -	       ifconst	DEBUGWAITCOLOR
   3143  2738d				   -	       lda	#0
   3144  2738d				   -	       sta	BACKGRND
   3145  2738d					       endif
   3146  2738d				    skipplotcharloopwait
   3147  2738d				    plotcharlooploop
   3148  2738d			a0 00		       ldy	#0
   3149  2738f			b1 49		       lda	(temp8),y
   3150  27391			85 42		       sta	temp1
   3151  27393			c8		       iny
   3152  27394			b1 49		       lda	(temp8),y
   3153  27396			85 43		       sta	temp2
   3154  27398			05 42		       ora	temp1
   3155  2739a			d0 01		       bne	plotcharloopcontinue
   3156  2739c							;the pointer=0, so return
   3157  2739c			60		       rts
   3158  2739d				    plotcharloopcontinue
   3159  2739d			c8		       iny
   3160  2739e			b1 49		       lda	(temp8),y
   3161  273a0			85 44		       sta	temp3
   3162  273a2			c8		       iny
   3163  273a3			b1 49		       lda	(temp8),y
   3164  273a5			85 45		       sta	temp4
   3165  273a7			c8		       iny
   3166  273a8			b1 49		       lda	(temp8),y
   3167  273aa							;sta temp5 ; not needed with our late entry.
   3168  273aa			20 c7 f3	       jsr	plotcharactersskipentry
   3169  273ad			a5 49		       lda	temp8
   3170  273af			18		       clc
   3171  273b0			69 05		       adc	#5
   3172  273b2			85 49		       sta	temp8
   3173  273b4			a5 4a		       lda	temp9
   3174  273b6			69 00		       adc	#0
   3175  273b8			85 4a		       sta	temp9
   3176  273ba			4c 8d f3	       jmp	plotcharlooploop
   3177  273bd
   3178  273bd				    plotcharacters
   3179  273bd					       ifconst	DOUBLEBUFFER
   3180  273bd			a5 d5		       lda	doublebufferstate
   3181  273bf			d0 04		       bne	skipplotcharacterswait
   3182  273c1					       endif		; DOUBLEBUFFER
   3183  273c1				   -	       ifconst	DEBUGWAITCOLOR
   3184  273c1				   -	       lda	#$41
   3185  273c1				   -	       sta	BACKGRND
   3186  273c1					       endif
   3187  273c1				    plotcharacterswait
   3188  273c1			a5 4d		       lda	visibleover
   3189  273c3			d0 fc		       bne	plotcharacterswait
   3190  273c5				   -	       ifconst	DEBUGWAITCOLOR
   3191  273c5				   -	       sta	BACKGRND
   3192  273c5					       endif
   3193  273c5				    skipplotcharacterswait
   3194  273c5							;arguments: 
   3195  273c5							; temp1=lo charactermap
   3196  273c5							; temp2=hi charactermap
   3197  273c5							; temp3=palette | width byte
   3198  273c5							; temp4=x
   3199  273c5							; temp5=y
   3200  273c5
   3201  273c5			a5 46		       lda	temp5	;Y position
   3202  273c7
   3203  273c7				    plotcharactersskipentry
   3204  273c7
   3205  273c7							;ifconst ZONEHEIGHT
   3206  273c7							; if ZONEHEIGHT = 16
   3207  273c7							; and #$0F
   3208  273c7							; endif
   3209  273c7							; if ZONEHEIGHT = 8
   3210  273c7							; and #$1F
   3211  273c7							; endif
   3212  273c7							;else
   3213  273c7							; and #$0F
   3214  273c7							;endif
   3215  273c7
   3216  273c7			aa		       tax
   3217  273c8			bd 64 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3218  273cb					       ifconst	DOUBLEBUFFER
   3219  273cb			18		       clc
   3220  273cc			65 d6		       adc	doublebufferdloffset
   3221  273ce					       endif		; DOUBLEBUFFER
   3222  273ce			85 63		       sta	dlpnt
   3223  273d0			bd 58 f6	       lda	DLPOINTH,x
   3224  273d3					       ifconst	DOUBLEBUFFER
   3225  273d3			69 00		       adc	#0
   3226  273d5					       endif		; DOUBLEBUFFER
   3227  273d5			85 64		       sta	dlpnt+1
   3228  273d7
   3229  273d7							;Create DL entry for the characters
   3230  273d7
   3231  273d7			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3232  273d9
   3233  273d9				   -	       ifconst	CHECKOVERWRITE
   3234  273d9				   -	       cpy	#DLLASTOBJ
   3235  273d9				   -	       bne	continueplotcharacters
   3236  273d9				   -	       rts
   3237  273d9				   -continueplotcharacters
   3238  273d9					       endif
   3239  273d9
   3240  273d9			a5 42		       lda	temp1	; character map data, lo byte
   3241  273db			91 63		       sta	(dlpnt),y	;(1) store low address
   3242  273dd
   3243  273dd			c8		       iny
   3244  273de			ad 06 21	       lda	charactermode
   3245  273e1			91 63		       sta	(dlpnt),y	;(2) store mode
   3246  273e3
   3247  273e3			c8		       iny
   3248  273e4			a5 43		       lda	temp2	; character map, hi byte
   3249  273e6			91 63		       sta	(dlpnt),y	;(3) store high address
   3250  273e8
   3251  273e8			c8		       iny
   3252  273e9			a5 44		       lda	temp3	;palette|width
   3253  273eb			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3254  273ed
   3255  273ed			c8		       iny
   3256  273ee			a5 45		       lda	temp4	;Horizontal position
   3257  273f0			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3258  273f2
   3259  273f2			c8		       iny
   3260  273f3			94 65		       sty	dlend,x	; save display list end byte
   3261  273f5			60		       rts
   3262  273f6
   3263  273f6
   3264  273f6					       ifconst	plotvalueonscreen
   3265  273f6				    plotcharacterslive
   3266  273f6							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3267  273f6
   3268  273f6							;arguments: 
   3269  273f6							; temp1=lo charactermap
   3270  273f6							; temp2=hi charactermap
   3271  273f6							; temp3=palette | width byte
   3272  273f6							; temp4=x
   3273  273f6							; temp5=y
   3274  273f6
   3275  273f6			a5 46		       lda	temp5	;Y position
   3276  273f8
   3277  273f8			aa		       tax
   3278  273f9			bd 64 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3279  273fc					       ifconst	DOUBLEBUFFER
   3280  273fc			18		       clc
   3281  273fd			65 d6		       adc	doublebufferdloffset
   3282  273ff					       endif		; DOUBLEBUFFER
   3283  273ff			85 63		       sta	dlpnt
   3284  27401			bd 58 f6	       lda	DLPOINTH,x
   3285  27404					       ifconst	DOUBLEBUFFER
   3286  27404			69 00		       adc	#0
   3287  27406					       endif		; DOUBLEBUFFER
   3288  27406			85 64		       sta	dlpnt+1
   3289  27408
   3290  27408							;Create DL entry for the characters
   3291  27408
   3292  27408			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3293  2740a
   3294  2740a				   -	       ifconst	CHECKOVERWRITE
   3295  2740a				   -	       cpy	#DLLASTOBJ
   3296  2740a				   -	       bne	continueplotcharacterslive
   3297  2740a				   -	       rts
   3298  2740a				   -continueplotcharacterslive
   3299  2740a					       endif
   3300  2740a
   3301  2740a			a5 42		       lda	temp1	; character map data, lo byte
   3302  2740c			91 63		       sta	(dlpnt),y	;(1) store low address
   3303  2740e
   3304  2740e			c8		       iny
   3305  2740f							; we don't add the second byte yet, since the charmap could briefly
   3306  2740f							; render without a proper character map address, width, or position.
   3307  2740f			ad 06 21	       lda	charactermode
   3308  27412			91 63		       sta	(dlpnt),y	;(2) store mode
   3309  27414
   3310  27414			c8		       iny
   3311  27415			a5 43		       lda	temp2	; character map, hi byte
   3312  27417			91 63		       sta	(dlpnt),y	;(3) store high address
   3313  27419
   3314  27419			c8		       iny
   3315  2741a			a5 44		       lda	temp3	;palette|width
   3316  2741c			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3317  2741e
   3318  2741e			c8		       iny
   3319  2741f			a5 45		       lda	temp4	;Horizontal position
   3320  27421			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3321  27423
   3322  27423			c8		       iny
   3323  27424			94 65		       sty	dlend,x	; save display list end byte
   3324  27426
   3325  27426			60		       rts
   3326  27427					       endif		;plotcharacterslive
   3327  27427
   3328  27427				   -	       ifconst	USED_PLOTVALUE
   3329  27427				   -plotvalue
   3330  27427				   -			; calling 7800basic command:
   3331  27427				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3332  27427				   -			; ...displays the variable as BCD digits
   3333  27427				   -			;
   3334  27427				   -			; asm sub arguments: 
   3335  27427				   -			; temp1=lo charactermap
   3336  27427				   -			; temp2=hi charactermap
   3337  27427				   -			; temp3=palette | width byte
   3338  27427				   -			; temp4=x
   3339  27427				   -			; temp5=y
   3340  27427				   -			; temp6=number of digits
   3341  27427				   -			; temp7=lo variable
   3342  27427				   -			; temp8=hi variable
   3343  27427				   -			; temp9=character mode
   3344  27427				   -
   3345  27427				   -plotdigitcount =	temp6
   3346  27427				   -
   3347  27427				   -	       ifconst	ZONELOCKS
   3348  27427				   -	       ldx	temp5
   3349  27427				   -	       ldy	dlend,x
   3350  27427				   -	       cpy	#DLLASTOBJ
   3351  27427				   -	       bne	carryonplotvalue
   3352  27427				   -	       rts
   3353  27427				   -carryonplotvalue
   3354  27427				   -	       endif
   3355  27427				   -
   3356  27427				   -	       lda	#0
   3357  27427				   -	       tay
   3358  27427				   -	       ldx	valbufend
   3359  27427				   -
   3360  27427				   -	       lda	plotdigitcount
   3361  27427				   -	       and	#1
   3362  27427				   -	       beq	pvnibble2char
   3363  27427				   -	       lda	#0
   3364  27427				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   3365  27427				   -	       beq	pvnibble2char_skipnibble
   3366  27427				   -
   3367  27427				   -pvnibble2char
   3368  27427				   -			; high nibble...
   3369  27427				   -	       lda	(temp7),y
   3370  27427				   -	       and	#$f0
   3371  27427				   -	       lsr
   3372  27427				   -	       lsr
   3373  27427				   -	       lsr
   3374  27427				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3375  27427				   -	       lsr
   3376  27427				   -	       endif
   3377  27427				   -
   3378  27427				   -	       clc
   3379  27427				   -	       adc	temp1	; add the offset to character graphics to our value
   3380  27427				   -	       sta	VALBUFFER,x
   3381  27427				   -	       inx
   3382  27427				   -	       dec	plotdigitcount
   3383  27427				   -
   3384  27427				   -pvnibble2char_skipnibble
   3385  27427				   -			; low nibble...
   3386  27427				   -	       lda	(temp7),y
   3387  27427				   -	       and	#$0f
   3388  27427				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3389  27427				   -	       asl
   3390  27427				   -	       endif
   3391  27427				   -	       clc
   3392  27427				   -	       adc	temp1	; add the offset to character graphics to our value
   3393  27427				   -	       sta	VALBUFFER,x
   3394  27427				   -	       inx
   3395  27427				   -	       iny
   3396  27427				   -
   3397  27427				   -	       dec	plotdigitcount
   3398  27427				   -	       bne	pvnibble2char
   3399  27427				   -
   3400  27427				   -			;point to the start of our valuebuffer
   3401  27427				   -	       clc
   3402  27427				   -	       lda	#<VALBUFFER
   3403  27427				   -	       adc	valbufend
   3404  27427				   -	       sta	temp1
   3405  27427				   -	       lda	#>VALBUFFER
   3406  27427				   -	       adc	#0
   3407  27427				   -	       sta	temp2
   3408  27427				   -
   3409  27427				   -			;advance valbufend to the end of our value buffer
   3410  27427				   -	       stx	valbufend
   3411  27427				   -
   3412  27427				   -	       ifnconst	plotvalueonscreen
   3413  27427				   -	       jmp	plotcharacters
   3414  27427				   -	       else
   3415  27427				   -	       jmp	plotcharacterslive
   3416  27427				   -	       endif
   3417  27427				   -
   3418  27427					       endif		; USED_PLOTVALUE
   3419  27427
   3420  27427
   3421  27427				   -	       ifconst	USED_PLOTVALUEEXTRA
   3422  27427				   -plotdigitcount =	temp6
   3423  27427				   -plotvalueextra
   3424  27427				   -			; calling 7800basic command:
   3425  27427				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3426  27427				   -			; ...displays the variable as BCD digits
   3427  27427				   -			;
   3428  27427				   -			; asm sub arguments: 
   3429  27427				   -			; temp1=lo charactermap
   3430  27427				   -			; temp2=hi charactermap
   3431  27427				   -			; temp3=palette | width byte
   3432  27427				   -			; temp4=x
   3433  27427				   -			; temp5=y
   3434  27427				   -			; temp6=number of digits
   3435  27427				   -			; temp7=lo variable
   3436  27427				   -			; temp8=hi variable
   3437  27427				   -
   3438  27427				   -	       lda	#0
   3439  27427				   -	       tay
   3440  27427				   -	       ldx	valbufend
   3441  27427				   -	       ifnconst	plotvalueonscreen
   3442  27427				   -	       sta	VALBUFFER,x
   3443  27427				   -	       endif
   3444  27427				   -
   3445  27427				   -	       lda	plotdigitcount
   3446  27427				   -	       and	#1
   3447  27427				   -
   3448  27427				   -	       bne	pvnibble2char_skipnibbleextra
   3449  27427				   -
   3450  27427				   -pvnibble2charextra
   3451  27427				   -			; high nibble...
   3452  27427				   -	       lda	(temp7),y
   3453  27427				   -	       and	#$f0
   3454  27427				   -	       lsr
   3455  27427				   -	       lsr
   3456  27427				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3457  27427				   -	       lsr
   3458  27427				   -	       endif
   3459  27427				   -	       clc
   3460  27427				   -	       adc	temp1	; add the offset to character graphics to our value
   3461  27427				   -	       sta	VALBUFFER,x
   3462  27427				   -	       inx
   3463  27427				   -
   3464  27427				   -			; second half of the digit
   3465  27427				   -	       clc
   3466  27427				   -	       adc	#1
   3467  27427				   -	       sta	VALBUFFER,x
   3468  27427				   -	       inx
   3469  27427				   -
   3470  27427				   -pvnibble2char_skipnibbleextra
   3471  27427				   -			; low nibble...
   3472  27427				   -	       lda	(temp7),y
   3473  27427				   -	       and	#$0f
   3474  27427				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3475  27427				   -	       asl
   3476  27427				   -	       endif
   3477  27427				   -	       asl
   3478  27427				   -
   3479  27427				   -	       clc
   3480  27427				   -	       adc	temp1	; add the offset to character graphics to our value
   3481  27427				   -	       sta	VALBUFFER,x
   3482  27427				   -	       inx
   3483  27427				   -
   3484  27427				   -	       clc
   3485  27427				   -	       adc	#1
   3486  27427				   -	       sta	VALBUFFER,x
   3487  27427				   -	       inx
   3488  27427				   -	       iny
   3489  27427				   -
   3490  27427				   -	       dec	plotdigitcount
   3491  27427				   -	       bne	pvnibble2charextra
   3492  27427				   -
   3493  27427				   -			;point to the start of our valuebuffer
   3494  27427				   -	       clc
   3495  27427				   -	       lda	#<VALBUFFER
   3496  27427				   -	       adc	valbufend
   3497  27427				   -	       sta	temp1
   3498  27427				   -	       lda	#>VALBUFFER
   3499  27427				   -	       adc	#0
   3500  27427				   -	       sta	temp2
   3501  27427				   -
   3502  27427				   -			;advance valbufend to the end of our value buffer
   3503  27427				   -	       stx	valbufend
   3504  27427				   -
   3505  27427				   -	       ifnconst	plotvalueonscreen
   3506  27427				   -	       jmp	plotcharacters
   3507  27427				   -	       else
   3508  27427				   -	       jmp	plotcharacterslive
   3509  27427				   -	       endif
   3510  27427					       endif		; USED_PLOTVALUEEXTRA
   3511  27427
   3512  27427				    boxcollision
   3513  27427				   -	       ifconst	BOXCOLLISION
   3514  27427				   -			; the worst case cycle-time for the code below is 43 cycles.
   3515  27427				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3516  27427				   -
   3517  27427				   -			;__boxx1 = accumulator
   3518  27427				   -			;__boxy1 = y
   3519  27427				   -__boxw1    =	temp3
   3520  27427				   -__boxh1    =	temp4
   3521  27427				   -
   3522  27427				   -__boxx2    =	temp5
   3523  27427				   -__boxy2    =	temp6
   3524  27427				   -__boxw2    =	temp7
   3525  27427				   -__boxh2    =	temp8
   3526  27427				   -
   3527  27427				   -DoXCollisionCheck
   3528  27427				   -			;lda __boxx1 ; skipped. already in the accumulator
   3529  27427				   -	       cmp	__boxx2	;3
   3530  27427				   -	       bcs	X1isbiggerthanX2	;2/3
   3531  27427				   -X2isbiggerthanX1
   3532  27427				   -			; carry is clear
   3533  27427				   -	       adc	__boxw1	;3
   3534  27427				   -	       cmp	__boxx2	;3
   3535  27427				   -	       bcs	DoYCollisionCheck	;3/2
   3536  27427				   -	       rts		;6 - carry clear, no collision
   3537  27427				   -X1isbiggerthanX2
   3538  27427				   -	       clc		;2
   3539  27427				   -	       sbc	__boxw2	;3
   3540  27427				   -	       cmp	__boxx2	;3
   3541  27427				   -	       bcs	noboxcollision	;3/2
   3542  27427				   -DoYCollisionCheck
   3543  27427				   -	       tya		; 2 ; use to be "lda __boxy1"
   3544  27427				   -	       cmp	__boxy2	;3
   3545  27427				   -	       bcs	Y1isbiggerthanY2	;3/2
   3546  27427				   -Y2isbiggerthanY1
   3547  27427				   -			; carry is clear
   3548  27427				   -	       adc	__boxh1	;3
   3549  27427				   -	       cmp	__boxy2	;3
   3550  27427				   -	       rts		;6 
   3551  27427				   -Y1isbiggerthanY2
   3552  27427				   -	       clc		;2
   3553  27427				   -	       sbc	__boxh2	;3
   3554  27427				   -	       cmp	__boxy2	;3
   3555  27427				   -	       bcs	noboxcollision	;3/2
   3556  27427				   -yesboxcollision
   3557  27427				   -	       sec		;2
   3558  27427				   -	       rts		;6
   3559  27427				   -noboxcollision
   3560  27427				   -	       clc		;2
   3561  27427				   -	       rts		;6
   3562  27427					       endif		; BOXCOLLISION
   3563  27427
   3564  27427				    randomize
   3565  27427			a5 40		       lda	rand
   3566  27429			4a		       lsr
   3567  2742a			26 41		       rol	rand16
   3568  2742c			90 02		       bcc	noeor
   3569  2742e			49 b4		       eor	#$B4
   3570  27430				    noeor
   3571  27430			85 40		       sta	rand
   3572  27432			45 41		       eor	rand16
   3573  27434			60		       rts
   3574  27435
   3575  27435							; *** bcd conversion routine courtesy Omegamatrix
   3576  27435							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3577  27435				   -	       ifconst	.calledfunction_converttobcd
   3578  27435				   -converttobcd
   3579  27435				   -			;value to convert is in the accumulator
   3580  27435				   -	       sta	temp1
   3581  27435				   -	       lsr
   3582  27435				   -	       adc	temp1
   3583  27435				   -	       ror
   3584  27435				   -	       lsr
   3585  27435				   -	       lsr
   3586  27435				   -	       adc	temp1
   3587  27435				   -	       ror
   3588  27435				   -	       adc	temp1
   3589  27435				   -	       ror
   3590  27435				   -	       lsr
   3591  27435				   -	       and	#$3C
   3592  27435				   -	       sta	temp2
   3593  27435				   -	       lsr
   3594  27435				   -	       adc	temp2
   3595  27435				   -	       adc	temp1
   3596  27435				   -	       rts		; return the result in the accumulator
   3597  27435					       endif		; .calledfunction_converttobcd
   3598  27435
   3599  27435				   -	       ifconst	.calledfunction_mul8
   3600  27435				   -			; Y and A contain multiplicands, result in A
   3601  27435				   -mul8
   3602  27435				   -	       sty	temp1
   3603  27435				   -	       sta	temp2
   3604  27435				   -	       lda	#0
   3605  27435				   -reptmul8
   3606  27435				   -	       lsr	temp2
   3607  27435				   -	       bcc	skipmul8
   3608  27435				   -	       clc
   3609  27435				   -	       adc	temp1
   3610  27435				   -			;bcs donemul8 might save cycles?
   3611  27435				   -skipmul8
   3612  27435				   -			;beq donemul8 might save cycles?
   3613  27435				   -	       asl	temp1
   3614  27435				   -	       bne	reptmul8
   3615  27435				   -donemul8
   3616  27435				   -	       rts
   3617  27435					       endif		; .calledfunction_mul8
   3618  27435
   3619  27435				   -	       ifconst	.calledfunction_div8
   3620  27435				   -div8
   3621  27435				   -			; A=numerator Y=denominator, result in A
   3622  27435				   -	       cpy	#2
   3623  27435				   -	       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3624  27435				   -	       sty	temp1
   3625  27435				   -	       ldy	#$ff
   3626  27435				   -div8loop
   3627  27435				   -	       sbc	temp1
   3628  27435				   -	       iny
   3629  27435				   -	       bcs	div8loop
   3630  27435				   -div8end
   3631  27435				   -	       tya
   3632  27435				   -			; result in A
   3633  27435				   -	       rts
   3634  27435					       endif		; .calledfunction_div8
   3635  27435
   3636  27435				   -	       ifconst	.calledfunction_mul16
   3637  27435				   -			; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3638  27435				   -mul16
   3639  27435				   -	       sty	temp1
   3640  27435				   -	       sta	temp2
   3641  27435				   -
   3642  27435				   -	       lda	#0
   3643  27435				   -	       ldx	#8
   3644  27435				   -	       lsr	temp1
   3645  27435				   -mul16_1
   3646  27435				   -	       bcc	mul16_2
   3647  27435				   -	       clc
   3648  27435				   -	       adc	temp2
   3649  27435				   -mul16_2
   3650  27435				   -	       ror
   3651  27435				   -	       ror	temp1
   3652  27435				   -	       dex
   3653  27435				   -	       bne	mul16_1
   3654  27435				   -	       sta	temp2
   3655  27435				   -	       rts
   3656  27435					       endif		; .calledfunction_mul16
   3657  27435
   3658  27435				   -	       ifconst	.calledfunction_div16
   3659  27435				   -			; div int/int
   3660  27435				   -			; numerator in A, denom in temp1
   3661  27435				   -			; returns with quotient in A, remainder in temp1
   3662  27435				   -div16
   3663  27435				   -	       sta	temp2
   3664  27435				   -	       sty	temp1
   3665  27435				   -	       lda	#0
   3666  27435				   -	       ldx	#8
   3667  27435				   -	       asl	temp2
   3668  27435				   -div16_1
   3669  27435				   -	       rol
   3670  27435				   -	       cmp	temp1
   3671  27435				   -	       bcc	div16_2
   3672  27435				   -	       sbc	temp1
   3673  27435				   -div16_2
   3674  27435				   -	       rol	temp2
   3675  27435				   -	       dex
   3676  27435				   -	       bne	div16_1
   3677  27435				   -	       sta	temp1
   3678  27435				   -	       lda	temp2
   3679  27435				   -	       rts
   3680  27435					       endif		; .calledfunction_div16
   3681  27435
   3682  27435					       ifconst	bankswitchmode
   3683  27435				    BS_jsr
   3684  27435				   -	       ifconst	dumpbankswitch
   3685  27435				   -	       sta	dumpbankswitch
   3686  27435					       endif
   3687  27435				   -	       ifconst	MCPDEVCART
   3688  27435				   -	       ora	#$18
   3689  27435				   -	       sta	$3000
   3690  27435					       else
   3691  27435			8d 00 80	       sta	$8000
   3692  27438					       endif
   3693  27438			68		       pla
   3694  27439			aa		       tax
   3695  2743a			68		       pla
   3696  2743b			60		       rts
   3697  2743c
   3698  2743c				    BS_return
   3699  2743c			68		       pla		; bankswitch bank
   3700  2743d				   -	       ifconst	dumpbankswitch
   3701  2743d				   -	       sta	dumpbankswitch
   3702  2743d					       endif
   3703  2743d				   -	       ifconst	BANKRAM
   3704  2743d				   -	       sta	currentbank
   3705  2743d				   -	       ora	currentrambank
   3706  2743d					       endif
   3707  2743d				   -	       ifconst	MCPDEVCART
   3708  2743d				   -	       ora	#$18
   3709  2743d				   -	       sta	$3000
   3710  2743d					       else
   3711  2743d			8d 00 80	       sta	$8000
   3712  27440					       endif
   3713  27440			68		       pla		; bankswitch $0 flag
   3714  27441			60		       rts
   3715  27442					       endif
   3716  27442
   3717  27442				    checkselectswitch
   3718  27442			ad 82 02	       lda	SWCHB	; check the real select switch...
   3719  27445			29 02		       and	#%00000010
   3720  27447				    checkselectswitchreturn
   3721  27447			60		       rts
   3722  27448
   3723  27448				    checkresetswitch
   3724  27448			ad 82 02	       lda	SWCHB	; check the real reset switch...
   3725  2744b			29 01		       and	#%00000001
   3726  2744d			60		       rts
   3727  2744e
   3728  2744e				   -	       ifconst	FINESCROLLENABLED
   3729  2744e				   -finescrolldlls
   3730  2744e				   -	       ldx	temp1	; first DLL index x3
   3731  2744e				   -	       lda	DLLMEM,x
   3732  2744e				   -	       and	#%11110000
   3733  2744e				   -	       ora	finescrolly
   3734  2744e				   -	       sta	DLLMEM,x
   3735  2744e				   -
   3736  2744e				   -	       ldx	temp2	; last DLL index x3
   3737  2744e				   -	       lda	DLLMEM,x
   3738  2744e				   -	       and	#%11110000
   3739  2744e				   -	       ora	finescrolly
   3740  2744e				   -	       eor	#(WZONEHEIGHT-1)
   3741  2744e				   -	       sta	DLLMEM,x
   3742  2744e				   -	       rts
   3743  2744e					       endif		; FINESCROLLENABLED
   3744  2744e
   3745  2744e				   -	       ifconst	USED_ADJUSTVISIBLE
   3746  2744e				   -adjustvisible
   3747  2744e				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3748  2744e				   -	       jsr	waitforvblankstart	; ensure vblank just started
   3749  2744e				   -	       ldx	visibleDLLstart
   3750  2744e				   -findfirstinterrupt
   3751  2744e				   -	       lda	DLLMEM,x
   3752  2744e				   -	       bmi	foundfirstinterrupt
   3753  2744e				   -	       inx
   3754  2744e				   -	       inx
   3755  2744e				   -	       inx
   3756  2744e				   -	       bne	findfirstinterrupt
   3757  2744e				   -foundfirstinterrupt
   3758  2744e				   -	       and	#%01111111	; clear the interrupt bit
   3759  2744e				   -	       sta	DLLMEM,x
   3760  2744e				   -	       ifconst	DOUBLEBUFFER
   3761  2744e				   -	       sta	DLLMEM+DBOFFSET,x
   3762  2744e				   -	       endif		; DOUBLEBUFFER
   3763  2744e				   -	       ldx	overscanDLLstart
   3764  2744e				   -findlastinterrupt
   3765  2744e				   -	       lda	DLLMEM,x
   3766  2744e				   -	       bmi	foundlastinterrupt
   3767  2744e				   -	       dex
   3768  2744e				   -	       dex
   3769  2744e				   -	       dex
   3770  2744e				   -	       bne	findlastinterrupt
   3771  2744e				   -foundlastinterrupt
   3772  2744e				   -	       and	#%01111111	; clear the interrupt bit
   3773  2744e				   -	       sta	DLLMEM,x
   3774  2744e				   -	       ifconst	DOUBLEBUFFER
   3775  2744e				   -	       sta	DLLMEM+DBOFFSET,x
   3776  2744e				   -	       endif		; DOUBLEBUFFER
   3777  2744e				   -			;now we need to set the new interrupts
   3778  2744e				   -	       clc
   3779  2744e				   -	       lda	temp1
   3780  2744e				   -	       adc	visibleDLLstart
   3781  2744e				   -	       tax
   3782  2744e				   -	       lda	DLLMEM,x
   3783  2744e				   -	       ora	#%10000000
   3784  2744e				   -	       sta	DLLMEM,x
   3785  2744e				   -	       ifconst	DOUBLEBUFFER
   3786  2744e				   -	       sta	DLLMEM+DBOFFSET,x
   3787  2744e				   -	       endif		; DOUBLEBUFFER
   3788  2744e				   -	       clc
   3789  2744e				   -	       lda	temp2
   3790  2744e				   -	       adc	visibleDLLstart
   3791  2744e				   -	       tax
   3792  2744e				   -	       lda	DLLMEM,x
   3793  2744e				   -	       ora	#%10000000
   3794  2744e				   -	       sta	DLLMEM,x
   3795  2744e				   -	       ifconst	DOUBLEBUFFER
   3796  2744e				   -	       sta	DLLMEM+DBOFFSET,x
   3797  2744e				   -	       endif		; DOUBLEBUFFER
   3798  2744e				   -	       jsr	vblankresync
   3799  2744e				   -	       rts
   3800  2744e					       endif		; USED_ADJUSTVISIBLE
   3801  2744e
   3802  2744e				    vblankresync
   3803  2744e			20 0f f5	       jsr	waitforvblankstart	; ensure vblank just started
   3804  27451			a9 00		       lda	#0
   3805  27453			85 4d		       sta	visibleover
   3806  27455			a9 03		       lda	#3
   3807  27457			8d b2 01	       sta	interruptindex
   3808  2745a			60		       rts
   3809  2745b
   3810  2745b				    createallgamedlls
   3811  2745b			a2 00		       ldx	#0
   3812  2745d			a9 19		       lda	#NVLINES
   3813  2745f			ac 09 21	       ldy	paldetected
   3814  27462			f0 03		       beq	skipcreatePALpadding
   3815  27464			18		       clc
   3816  27465			69 15		       adc	#21
   3817  27467				    skipcreatePALpadding
   3818  27467			20 a5 f4	       jsr	createnonvisibledlls
   3819  2746a			8e 3c 21	       stx	visibleDLLstart
   3820  2746d			20 df f4	       jsr	createvisiblezones
   3821  27470			8e 3d 21	       stx	overscanDLLstart
   3822  27473				    createallgamedllscontinue
   3823  27473			a9 50		       lda	#(NVLINES+55)	; extras for PAL
   3824  27475			20 a5 f4	       jsr	createnonvisibledlls
   3825  27478
   3826  27478			ae 3c 21	       ldx	visibleDLLstart
   3827  2747b			bd 00 18	       lda	DLLMEM,x
   3828  2747e			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   3829  27480			9d 00 18	       sta	DLLMEM,x
   3830  27483					       ifconst	DOUBLEBUFFER
   3831  27483			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3832  27486					       endif		; DOUBLEBUFFER
   3833  27486
   3834  27486			ae 3d 21	       ldx	overscanDLLstart
   3835  27489			bd 00 18	       lda	DLLMEM,x
   3836  2748c			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   3837  2748e			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3838  27490			9d 00 18	       sta	DLLMEM,x
   3839  27493					       ifconst	DOUBLEBUFFER
   3840  27493			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3841  27496					       endif		; DOUBLEBUFFER
   3842  27496
   3843  27496			e8		       inx
   3844  27497			e8		       inx
   3845  27498			e8		       inx
   3846  27499
   3847  27499			bd 00 18	       lda	DLLMEM,x
   3848  2749c			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   3849  2749e			9d 00 18	       sta	DLLMEM,x
   3850  274a1					       ifconst	DOUBLEBUFFER
   3851  274a1			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3852  274a4					       endif		; DOUBLEBUFFER
   3853  274a4
   3854  274a4			60		       rts
   3855  274a5
   3856  274a5				    createnonvisibledlls
   3857  274a5			85 42		       sta	temp1
   3858  274a7			4a		       lsr
   3859  274a8			4a		       lsr
   3860  274a9			4a		       lsr
   3861  274aa			4a		       lsr		; /16
   3862  274ab			f0 09		       beq	skipcreatenonvisibledlls1loop
   3863  274ad			a8		       tay
   3864  274ae				    createnonvisibledlls1loop
   3865  274ae			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3866  274b0			20 c5 f4	       jsr	createblankdllentry
   3867  274b3			88		       dey
   3868  274b4			d0 f8		       bne	createnonvisibledlls1loop
   3869  274b6				    skipcreatenonvisibledlls1loop
   3870  274b6			a5 42		       lda	temp1
   3871  274b8			29 0f		       and	#%00001111
   3872  274ba			f0 08		       beq	createnonvisibledllsreturn
   3873  274bc			38		       sec
   3874  274bd			e9 01		       sbc	#1
   3875  274bf			09 40		       ora	#%01000000
   3876  274c1			20 c5 f4	       jsr	createblankdllentry
   3877  274c4				    createnonvisibledllsreturn
   3878  274c4			60		       rts
   3879  274c5
   3880  274c5				    createblankdllentry
   3881  274c5			9d 00 18	       sta	DLLMEM,x
   3882  274c8					       ifconst	DOUBLEBUFFER
   3883  274c8			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3884  274cb					       endif		; DOUBLEBUFFER
   3885  274cb			e8		       inx
   3886  274cc			a9 21		       lda	#$21	; blank
   3887  274ce			9d 00 18	       sta	DLLMEM,x
   3888  274d1					       ifconst	DOUBLEBUFFER
   3889  274d1			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3890  274d4					       endif		; DOUBLEBUFFER
   3891  274d4			e8		       inx
   3892  274d5			a9 00		       lda	#$00
   3893  274d7			9d 00 18	       sta	DLLMEM,x
   3894  274da					       ifconst	DOUBLEBUFFER
   3895  274da			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3896  274dd					       endif		; DOUBLEBUFFER
   3897  274dd			e8		       inx
   3898  274de			60		       rts
   3899  274df
   3900  274df				    createvisiblezones
   3901  274df			a0 00		       ldy	#0
   3902  274e1				    createvisiblezonesloop
   3903  274e1			b9 70 f6	       lda.w	DLHEIGHT,y
   3904  274e4			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   3905  274e6			9d 00 18	       sta	DLLMEM,x
   3906  274e9					       ifconst	DOUBLEBUFFER
   3907  274e9			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3908  274ec					       endif		; DOUBLEBUFFER
   3909  274ec			e8		       inx
   3910  274ed			b9 58 f6	       lda	DLPOINTH,y
   3911  274f0				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   3912  274f0				   -			; with bankset cart ram, we added $8000 to the DL address so plot functions would hit the write-address
   3913  274f0				   -			; but now we need to subtract that $8000 location to give Maria the normal address
   3914  274f0				   -	       sec
   3915  274f0				   -	       sbc	#$80
   3916  274f0					       endif		; BANKSET_DL_IN_CARTRAM
   3917  274f0			9d 00 18	       sta	DLLMEM,x
   3918  274f3					       ifconst	DOUBLEBUFFER
   3919  274f3			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3920  274f6					       endif		; DOUBLEBUFFER
   3921  274f6			e8		       inx
   3922  274f7			b9 64 f6	       lda	DLPOINTL,y
   3923  274fa			9d 00 18	       sta	DLLMEM,x
   3924  274fd					       ifconst	DOUBLEBUFFER
   3925  274fd			18		       clc
   3926  274fe			69 ff		       adc	#DOUBLEBUFFEROFFSET
   3927  27500			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3928  27503			90 03		       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   3929  27505			fe 6f 18	       inc	DLLMEM+DBOFFSET-1,x
   3930  27508				    skiphidoublebufferadjust
   3931  27508					       endif		; DOUBLEBUFFER
   3932  27508			e8		       inx
   3933  27509			c8		       iny
   3934  2750a			c0 0c		       cpy	#WZONECOUNT
   3935  2750c			d0 d3		       bne	createvisiblezonesloop
   3936  2750e			60		       rts
   3937  2750f
   3938  2750f				    waitforvblankstart
   3939  2750f				    vblankendwait
   3940  2750f			24 28		       BIT	MSTAT
   3941  27511			30 fc		       bmi	vblankendwait
   3942  27513				    vblankstartwait
   3943  27513			24 28		       BIT	MSTAT
   3944  27515			10 fc		       bpl	vblankstartwait
   3945  27517			60		       rts
   3946  27518
   3947  27518					       ifconst	DOUBLEBUFFER
   3948  27518				    flipdisplaybufferreturn
   3949  27518			60		       rts
   3950  27519				    flipdisplaybuffer
   3951  27519				   -	       ifconst	interrupthold
   3952  27519				   -	       lda	#$FF
   3953  27519				   -	       sta	interrupthold
   3954  27519					       endif
   3955  27519			a5 d5		       lda	doublebufferstate
   3956  2751b			f0 fb		       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   3957  2751d
   3958  2751d			20 46 f1	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   3959  27520
   3960  27520			a5 d5		       lda	doublebufferstate
   3961  27522			4a		       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   3962  27523			aa		       tax
   3963  27524
   3964  27524							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   3965  27524
   3966  27524				    flipdisplaybufferwait1
   3967  27524			a5 4d		       lda	visibleover
   3968  27526			f0 fc		       beq	flipdisplaybufferwait1
   3969  27528
   3970  27528				    flipdisplaybufferwait
   3971  27528			a5 4d		       lda	visibleover
   3972  2752a			d0 fc		       bne	flipdisplaybufferwait
   3973  2752c
   3974  2752c			ad b3 01	       lda	doublebufferminimumframetarget
   3975  2752f			f0 0b		       beq	skipminimumframecode
   3976  27531			ad b4 01	       lda	doublebufferminimumframeindex
   3977  27534			d0 ee		       bne	flipdisplaybufferwait1
   3978  27536			ad b3 01	       lda	doublebufferminimumframetarget
   3979  27539			8d b4 01	       sta	doublebufferminimumframeindex
   3980  2753c				    skipminimumframecode
   3981  2753c
   3982  2753c			bd 9c f5	       lda	DLLMEMLutHi,x
   3983  2753f			85 2c		       sta	DPPH
   3984  27541			bd 9a f5	       lda	DLLMEMLutLo,x
   3985  27544			85 30		       sta	DPPL
   3986  27546
   3987  27546			bd 9e f5	       lda	NewPageflipstate,x
   3988  27549			85 d5		       sta	doublebufferstate
   3989  2754b			bd a0 f5	       lda	NewPageflipoffset,x
   3990  2754e			85 d6		       sta	doublebufferdloffset
   3991  27550
   3992  27550					       ifnconst	BANKSET_DL_IN_CARTRAM
   3993  27550			a5 d7		       lda	doublebufferbufferdirty
   3994  27552			f0 c4		       beq	flipdisplaybufferreturn
   3995  27554
   3996  27554							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   3997  27554							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   3998  27554							; from the displayed buffer to the working buffer...
   3999  27554
   4000  27554			a5 d6		       lda	doublebufferdloffset
   4001  27556			49 ff		       eor	#DOUBLEBUFFEROFFSET
   4002  27558			85 47		       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4003  2755a
   4004  2755a			a2 0b		       ldx	#(WZONECOUNT-1)
   4005  2755c				    copybufferzoneloop
   4006  2755c
   4007  2755c			bd 64 f6	       lda	DLPOINTL,x
   4008  2755f			18		       clc
   4009  27560			65 d6		       adc	doublebufferdloffset
   4010  27562			85 42		       sta	temp1
   4011  27564			bd 58 f6	       lda	DLPOINTH,x
   4012  27567			69 00		       adc	#0
   4013  27569			85 43		       sta	temp2
   4014  2756b
   4015  2756b			bd 64 f6	       lda	DLPOINTL,x
   4016  2756e			18		       clc
   4017  2756f			65 47		       adc	temp6
   4018  27571			85 44		       sta	temp3
   4019  27573			bd 58 f6	       lda	DLPOINTH,x
   4020  27576			69 00		       adc	#0
   4021  27578			85 45		       sta	temp4
   4022  2757a
   4023  2757a			b5 82		       lda	dlendsave,x
   4024  2757c			a8		       tay
   4025  2757d				    copybuffercharsloop
   4026  2757d			b1 44		       lda	(temp3),y
   4027  2757f			91 42		       sta	(temp1),y
   4028  27581			88		       dey
   4029  27582			10 f9		       bpl	copybuffercharsloop
   4030  27584			ca		       dex
   4031  27585			10 d5		       bpl	copybufferzoneloop
   4032  27587			a9 00		       lda	#0
   4033  27589			85 d7		       sta	doublebufferbufferdirty
   4034  2758b					       endif		; ! BANKSET_DL_IN_CARTRAM
   4035  2758b			60		       rts
   4036  2758c
   4037  2758c				    doublebufferoff
   4038  2758c			a9 01		       lda	#1
   4039  2758e			85 d5		       sta	doublebufferstate
   4040  27590			20 19 f5	       jsr	flipdisplaybuffer
   4041  27593			a9 00		       lda	#0
   4042  27595			85 d5		       sta	doublebufferstate
   4043  27597			85 d6		       sta	doublebufferdloffset
   4044  27599			60		       rts
   4045  2759a
   4046  2759a				    DLLMEMLutLo
   4047  2759a			00 70		       .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   4048  2759c				    DLLMEMLutHi
   4049  2759c			18 18		       .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   4050  2759e				    NewPageflipstate
   4051  2759e			03 01		       .byte.b	3,1
   4052  275a0				    NewPageflipoffset
   4053  275a0			ff 00		       .byte.b	DOUBLEBUFFEROFFSET,0
   4054  275a2
   4055  275a2					       endif		; DOUBLEBUFFER
   4056  275a2
   4057  275a2				   -	       ifconst	MOUSESUPPORT
   4058  275a2				   -
   4059  275a2				   -rotationalcompare
   4060  275a2				   -			; old = 00 01 10 11
   4061  275a2				   -	       .byte	$00, $01, $ff, $00	; new=00
   4062  275a2				   -	       .byte	$ff, $00, $00, $01	; new=01
   4063  275a2				   -	       .byte	$01, $00, $00, $ff	; new=10
   4064  275a2				   -	       .byte	$00, $ff, $01, $00	; new=11
   4065  275a2				   -
   4066  275a2				   -			; 0000YyXx st mouse
   4067  275a2				   -
   4068  275a2				   -			; 0000xyXY amiga mouse
   4069  275a2				   -
   4070  275a2				   -	       ifconst	MOUSEXONLY
   4071  275a2				   -amigatoataribits		; swap bits 1 and 4...
   4072  275a2				   -	       .byte	%0000, %0000, %0010, %0010
   4073  275a2				   -	       .byte	%0000, %0000, %0010, %0010
   4074  275a2				   -	       .byte	%0001, %0001, %0011, %0011
   4075  275a2				   -	       .byte	%0001, %0001, %0011, %0011
   4076  275a2				   -
   4077  275a2				   -			; null change bits
   4078  275a2				   -	       .byte	%0000, %0001, %0010, %0011
   4079  275a2				   -	       .byte	%0000, %0001, %0010, %0011
   4080  275a2				   -	       .byte	%0000, %0001, %0010, %0011
   4081  275a2				   -	       .byte	%0000, %0001, %0010, %0011
   4082  275a2				   -
   4083  275a2				   -	       else		; !MOUSEXONLY
   4084  275a2				   -
   4085  275a2				   -amigatoataribits		; swap bits 1 and 4...
   4086  275a2				   -	       .byte	%0000, %1000, %0010, %1010
   4087  275a2				   -	       .byte	%0100, %1100, %0110, %1110
   4088  275a2				   -	       .byte	%0001, %1001, %0011, %1011
   4089  275a2				   -	       .byte	%0101, %1101, %0111, %1111
   4090  275a2				   -			; null change bits
   4091  275a2				   -	       .byte	%0000, %0001, %0010, %0011
   4092  275a2				   -	       .byte	%0100, %0101, %0110, %0111
   4093  275a2				   -	       .byte	%1000, %1001, %1010, %1011
   4094  275a2				   -	       .byte	%1100, %1101, %1110, %1111
   4095  275a2				   -	       endif		; !MOUSEXONLY
   4096  275a2				   -
   4097  275a2					       endif		; MOUSESUPPORT
   4098  275a2
   4099  275a2				    mouse0update
   4100  275a2				   -	       ifconst	MOUSE0SUPPORT
   4101  275a2				   -
   4102  275a2				   -mousetableselect =	inttemp2
   4103  275a2				   -mousexdelta =	inttemp3
   4104  275a2				   -mouseydelta =	inttemp4
   4105  275a2				   -lastSWCHA  =	inttemp6
   4106  275a2				   -
   4107  275a2				   -			; 0000YyXx st mouse
   4108  275a2				   -			; 0000xyXY amiga mouse
   4109  275a2				   -
   4110  275a2				   -	       lda	#$ff
   4111  275a2				   -	       sta	lastSWCHA
   4112  275a2				   -
   4113  275a2				   -	       ldy	port0control
   4114  275a2				   -
   4115  275a2				   -	       lda	#%00010000
   4116  275a2				   -	       cpy	#9	; AMIGA?
   4117  275a2				   -	       bne	skipamigabitsfix0
   4118  275a2				   -	       lda	#0
   4119  275a2				   -skipamigabitsfix0
   4120  275a2				   -	       sta	mousetableselect
   4121  275a2				   -	       ifconst	DRIVINGBOOST
   4122  275a2				   -	       cpy	#6	; DRIVING?
   4123  275a2				   -	       bne	skipdriving0setup
   4124  275a2				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   4125  275a2				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   4126  275a2				   -			; the actual position. This actual position is stored in mousey0 
   4127  275a2				   -			; after the driver has run.
   4128  275a2				   -	       ldx	mousex0
   4129  275a2				   -	       lda	mousey0
   4130  275a2				   -	       stx	mousey0
   4131  275a2				   -	       sta	mousex0
   4132  275a2				   -skipdriving0setup
   4133  275a2				   -	       endif		; DRIVINGBOOST
   4134  275a2				   -
   4135  275a2				   -	       lda	#0
   4136  275a2				   -	       sta	mousexdelta
   4137  275a2				   -	       sta	mouseydelta
   4138  275a2				   -
   4139  275a2				   -	       ifnconst	MOUSETIME
   4140  275a2				   -	       ifnconst	MOUSEXONLY
   4141  275a2				   -	       lda	#180	; minimum for x+y
   4142  275a2				   -	       else
   4143  275a2				   -	       lda	#100	; minimum for just x
   4144  275a2				   -	       endif
   4145  275a2				   -	       else
   4146  275a2				   -	       lda	#MOUSETIME
   4147  275a2				   -	       endif
   4148  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4149  275a2				   -
   4150  275a2				   -mouse0updateloop
   4151  275a2				   -	       lda	SWCHA
   4152  275a2				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4153  275a2				   -	       cmp	lastSWCHA
   4154  275a2				   -	       beq	mouse0loopcondition
   4155  275a2				   -	       sta	lastSWCHA
   4156  275a2				   -	       lsr
   4157  275a2				   -	       lsr
   4158  275a2				   -	       lsr
   4159  275a2				   -
   4160  275a2				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4161  275a2				   -
   4162  275a2				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4163  275a2				   -			; 0000YyXx st mouse
   4164  275a2				   -			; 0000xyXY amiga mouse
   4165  275a2				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4166  275a2				   -	       tay
   4167  275a2				   -	       lax	amigatoataribits,y
   4168  275a2				   -
   4169  275a2				   -	       ifnconst	MOUSEXONLY
   4170  275a2				   -			; first the Y...
   4171  275a2				   -	       and	#%00001100
   4172  275a2				   -	       ora	mousecodey0
   4173  275a2				   -	       tay
   4174  275a2				   -	       lda	rotationalcompare,y
   4175  275a2				   -	       clc
   4176  275a2				   -	       adc	mouseydelta
   4177  275a2				   -	       sta	mouseydelta
   4178  275a2				   -	       tya
   4179  275a2				   -	       lsr
   4180  275a2				   -	       lsr
   4181  275a2				   -	       sta	mousecodey0
   4182  275a2				   -	       txa
   4183  275a2				   -			; ...then the X...
   4184  275a2				   -	       and	#%00000011
   4185  275a2				   -	       tax
   4186  275a2				   -	       endif		; !MOUSEXONLY
   4187  275a2				   -
   4188  275a2				   -	       asl
   4189  275a2				   -	       asl
   4190  275a2				   -	       ora	mousecodex0
   4191  275a2				   -	       tay
   4192  275a2				   -	       lda	rotationalcompare,y
   4193  275a2				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4194  275a2				   -	       sta	mousexdelta
   4195  275a2				   -	       stx	mousecodex0
   4196  275a2				   -mouse0loopcondition
   4197  275a2				   -	       lda	TIMINT
   4198  275a2				   -	       bpl	mouse0updateloop
   4199  275a2				   -
   4200  275a2				   -			; *** adapt to selected device resolution. 
   4201  275a2				   -	       ldx	port0control
   4202  275a2				   -
   4203  275a2				   -	       ifconst	PRECISIONMOUSING
   4204  275a2				   -	       ldy	port0resolution
   4205  275a2				   -	       bne	mouse0halveddone
   4206  275a2				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4207  275a2				   -	       beq	mouse0halveddone
   4208  275a2				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4209  275a2				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4210  275a2				   -
   4211  275a2				   -	       lda	mousexdelta
   4212  275a2				   -	       cmp	#$80
   4213  275a2				   -	       ror		; do a signed divide by 2.
   4214  275a2				   -	       clc
   4215  275a2				   -	       adc	mousex0
   4216  275a2				   -	       sta	mousex0
   4217  275a2				   -	       ifnconst	MOUSEXONLY
   4218  275a2				   -	       lda	mouseydelta
   4219  275a2				   -	       clc
   4220  275a2				   -	       adc	mousey0
   4221  275a2				   -	       sta	mousey0
   4222  275a2				   -	       endif
   4223  275a2				   -			; at half resolution we just exit after updating x and y
   4224  275a2				   -	       jmp	LLRET0
   4225  275a2				   -mouse0halveddone
   4226  275a2				   -	       endif		; PRECISIONMOUSING
   4227  275a2				   -
   4228  275a2				   -	       ifnconst	MOUSEXONLY
   4229  275a2				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4230  275a2				   -	       ldy	port0resolution
   4231  275a2				   -	       dey
   4232  275a2				   -	       lda	#0
   4233  275a2				   -mousey0resolutionfix
   4234  275a2				   -	       clc
   4235  275a2				   -	       adc	mouseydelta
   4236  275a2				   -	       dey
   4237  275a2				   -	       bpl	mousey0resolutionfix
   4238  275a2				   -	       clc
   4239  275a2				   -	       adc	mousey0
   4240  275a2				   -	       sta	mousey0
   4241  275a2				   -	       endif		; MOUSEXONLY
   4242  275a2				   -
   4243  275a2				   -	       ldy	port0resolution
   4244  275a2				   -	       dey
   4245  275a2				   -	       lda	#0
   4246  275a2				   -mousex0resolutionfix
   4247  275a2				   -	       clc
   4248  275a2				   -	       adc	mousexdelta
   4249  275a2				   -	       dey
   4250  275a2				   -	       bpl	mousex0resolutionfix
   4251  275a2				   -	       ifnconst	DRIVINGBOOST
   4252  275a2				   -	       clc
   4253  275a2				   -	       adc	mousex0
   4254  275a2				   -	       sta	mousex0
   4255  275a2				   -	       else
   4256  275a2				   -	       cpx	#6
   4257  275a2				   -	       beq	carryonmouse0boost
   4258  275a2				   -	       clc
   4259  275a2				   -	       adc	mousex0
   4260  275a2				   -	       sta	mousex0
   4261  275a2				   -	       jmp	LLRET0
   4262  275a2				   -carryonmouse0boost
   4263  275a2				   -	       sta	mousexdelta
   4264  275a2				   -	       clc
   4265  275a2				   -	       adc	mousecodey0
   4266  275a2				   -	       sta	mousecodey0
   4267  275a2				   -	       clc
   4268  275a2				   -	       adc	mousex0
   4269  275a2				   -	       tay		; save the target X
   4270  275a2				   -	       adc	mousey0	; average in the smoothly-trailing X
   4271  275a2				   -	       ror
   4272  275a2				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   4273  275a2				   -	       sty	mousey0	; and mousey0 has the the target X
   4274  275a2				   -
   4275  275a2				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4276  275a2				   -			; A has mousex0, the smoothly trailing X
   4277  275a2				   -	       sbc	mousey0	; less the target X
   4278  275a2				   -	       bpl	skipabsolutedrive0
   4279  275a2				   -	       eor	#$ff
   4280  275a2				   -skipabsolutedrive0
   4281  275a2				   -	       cmp	#64	; just an unreasonably large change
   4282  275a2				   -	       bcc	skipdrivewrapfix0
   4283  275a2				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   4284  275a2				   -skipdrivewrapfix0
   4285  275a2				   -
   4286  275a2				   -			; get rid of the tweening if the distance travelled was very small
   4287  275a2				   -	       lda	mousexdelta
   4288  275a2				   -	       cmp	port0resolution
   4289  275a2				   -	       bcs	skipbetweenfix0
   4290  275a2				   -	       lda	mousex0
   4291  275a2				   -	       sta	mousey0
   4292  275a2				   -skipbetweenfix0
   4293  275a2				   -
   4294  275a2				   -drivingboostreductioncheck0
   4295  275a2				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4296  275a2				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4297  275a2				   -			; negated again because truncation during BCD math results in 
   4298  275a2				   -			; differing magnitudes, depending if the value is +ve or -ve.
   4299  275a2				   -driving0fix
   4300  275a2				   -	       lax	mousecodey0
   4301  275a2				   -	       cmp	#$80
   4302  275a2				   -	       bcs	driving0skipnegate1
   4303  275a2				   -	       eor	#$FF
   4304  275a2				   -	       adc	#1
   4305  275a2				   -	       sta	mousecodey0
   4306  275a2				   -driving0skipnegate1
   4307  275a2				   -	       cmp	#$80
   4308  275a2				   -	       ror
   4309  275a2				   -	       cmp	#$80
   4310  275a2				   -	       ror
   4311  275a2				   -	       cmp	#$80
   4312  275a2				   -	       ror
   4313  275a2				   -	       sta	inttemp1
   4314  275a2				   -	       lda	mousecodey0
   4315  275a2				   -	       sec
   4316  275a2				   -	       sbc	inttemp1
   4317  275a2				   -	       cpx	#$80
   4318  275a2				   -	       bcs	driving0skipnegate2
   4319  275a2				   -	       eor	#$FF
   4320  275a2				   -	       adc	#1
   4321  275a2				   -driving0skipnegate2
   4322  275a2				   -	       sta	mousecodey0
   4323  275a2				   -drivingboostdone0
   4324  275a2				   -	       endif		; DRIVINGBOOST
   4325  275a2				   -
   4326  275a2				   -	       jmp	LLRET0
   4327  275a2				   -
   4328  275a2					       endif		; MOUSE0SUPPORT
   4329  275a2
   4330  275a2				    mouse1update
   4331  275a2				   -	       ifconst	MOUSE1SUPPORT
   4332  275a2				   -
   4333  275a2				   -mousetableselect =	inttemp2
   4334  275a2				   -mousexdelta =	inttemp3
   4335  275a2				   -mouseydelta =	inttemp4
   4336  275a2				   -lastSWCHA  =	inttemp6
   4337  275a2				   -
   4338  275a2				   -			; 0000YyXx st mouse
   4339  275a2				   -			; 0000xyXY amiga mouse
   4340  275a2				   -
   4341  275a2				   -	       lda	#$ff
   4342  275a2				   -	       sta	lastSWCHA
   4343  275a2				   -
   4344  275a2				   -	       ldy	port1control
   4345  275a2				   -
   4346  275a2				   -	       lda	#%00010000
   4347  275a2				   -	       cpy	#9	; AMIGA?
   4348  275a2				   -	       bne	skipamigabitsfix1
   4349  275a2				   -	       lda	#0
   4350  275a2				   -skipamigabitsfix1
   4351  275a2				   -	       sta	mousetableselect
   4352  275a2				   -	       ifconst	DRIVINGBOOST
   4353  275a2				   -	       cpy	#6	; DRIVING?
   4354  275a2				   -	       bne	skipdriving1setup
   4355  275a2				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   4356  275a2				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   4357  275a2				   -			; the actual position. This actual position is stored in mousey1 
   4358  275a2				   -			; after the driver has run.
   4359  275a2				   -	       ldx	mousex1
   4360  275a2				   -	       lda	mousey1
   4361  275a2				   -	       stx	mousey1
   4362  275a2				   -	       sta	mousex1
   4363  275a2				   -skipdriving1setup
   4364  275a2				   -	       endif		; DRIVINGBOOST
   4365  275a2				   -
   4366  275a2				   -	       lda	#0
   4367  275a2				   -	       sta	mousexdelta
   4368  275a2				   -	       sta	mouseydelta
   4369  275a2				   -
   4370  275a2				   -	       ifnconst	MOUSETIME
   4371  275a2				   -	       ifnconst	MOUSEXONLY
   4372  275a2				   -	       lda	#180	; minimum for x+y
   4373  275a2				   -	       else
   4374  275a2				   -	       lda	#100	; minimum for just x
   4375  275a2				   -	       endif
   4376  275a2				   -	       else
   4377  275a2				   -	       lda	#MOUSETIME
   4378  275a2				   -	       endif
   4379  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4380  275a2				   -
   4381  275a2				   -mouse1updateloop
   4382  275a2				   -	       lda	SWCHA
   4383  275a2				   -	       and	#%00001111
   4384  275a2				   -	       cmp	lastSWCHA
   4385  275a2				   -	       beq	mouse1loopcondition
   4386  275a2				   -	       sta	lastSWCHA
   4387  275a2				   -
   4388  275a2				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4389  275a2				   -
   4390  275a2				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4391  275a2				   -			; 0000YyXx st mouse
   4392  275a2				   -			; 0000xyXY amiga mouse
   4393  275a2				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4394  275a2				   -	       tay
   4395  275a2				   -	       lax	amigatoataribits,y
   4396  275a2				   -
   4397  275a2				   -	       ifnconst	MOUSEXONLY
   4398  275a2				   -			; first the Y...
   4399  275a2				   -	       and	#%00001100
   4400  275a2				   -	       ora	mousecodey1
   4401  275a2				   -	       tay
   4402  275a2				   -	       lda	rotationalcompare,y
   4403  275a2				   -	       clc
   4404  275a2				   -	       adc	mouseydelta
   4405  275a2				   -	       sta	mouseydelta
   4406  275a2				   -	       tya
   4407  275a2				   -	       lsr
   4408  275a2				   -	       lsr
   4409  275a2				   -	       sta	mousecodey1
   4410  275a2				   -	       txa
   4411  275a2				   -			; ...then the X...
   4412  275a2				   -	       and	#%00000011
   4413  275a2				   -	       tax
   4414  275a2				   -	       endif		; !MOUSEXONLY
   4415  275a2				   -
   4416  275a2				   -	       asl
   4417  275a2				   -	       asl
   4418  275a2				   -	       ora	mousecodex1
   4419  275a2				   -	       tay
   4420  275a2				   -	       lda	rotationalcompare,y
   4421  275a2				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4422  275a2				   -	       sta	mousexdelta
   4423  275a2				   -	       stx	mousecodex1
   4424  275a2				   -mouse1loopcondition
   4425  275a2				   -	       lda	TIMINT
   4426  275a2				   -	       bpl	mouse1updateloop
   4427  275a2				   -
   4428  275a2				   -			; *** adapt to selected device resolution. 
   4429  275a2				   -	       ldx	port1control
   4430  275a2				   -
   4431  275a2				   -	       ifconst	PRECISIONMOUSING
   4432  275a2				   -	       ldy	port1resolution
   4433  275a2				   -	       bne	mouse1halveddone
   4434  275a2				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4435  275a2				   -	       beq	mouse1halveddone
   4436  275a2				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4437  275a2				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4438  275a2				   -
   4439  275a2				   -	       lda	mousexdelta
   4440  275a2				   -	       cmp	#$80
   4441  275a2				   -	       ror		; do a signed divide by 2.
   4442  275a2				   -	       clc
   4443  275a2				   -	       adc	mousex1
   4444  275a2				   -	       sta	mousex1
   4445  275a2				   -	       ifnconst	MOUSEXONLY
   4446  275a2				   -	       lda	mouseydelta
   4447  275a2				   -	       clc
   4448  275a2				   -	       adc	mousey1
   4449  275a2				   -	       sta	mousey1
   4450  275a2				   -	       endif
   4451  275a2				   -			; at half resolution we just exit after updating x and y
   4452  275a2				   -	       jmp	LLRET1
   4453  275a2				   -mouse1halveddone
   4454  275a2				   -	       endif		; PRECISIONMOUSING
   4455  275a2				   -
   4456  275a2				   -	       ifnconst	MOUSEXONLY
   4457  275a2				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4458  275a2				   -	       ldy	port1resolution
   4459  275a2				   -	       dey
   4460  275a2				   -	       lda	#0
   4461  275a2				   -mousey1resolutionfix
   4462  275a2				   -	       clc
   4463  275a2				   -	       adc	mouseydelta
   4464  275a2				   -	       dey
   4465  275a2				   -	       bpl	mousey1resolutionfix
   4466  275a2				   -	       clc
   4467  275a2				   -	       adc	mousey1
   4468  275a2				   -	       sta	mousey1
   4469  275a2				   -	       endif		; MOUSEXONLY
   4470  275a2				   -
   4471  275a2				   -	       ldy	port1resolution
   4472  275a2				   -	       dey
   4473  275a2				   -	       lda	#0
   4474  275a2				   -mousex1resolutionfix
   4475  275a2				   -	       clc
   4476  275a2				   -	       adc	mousexdelta
   4477  275a2				   -	       dey
   4478  275a2				   -	       bpl	mousex1resolutionfix
   4479  275a2				   -	       ifnconst	DRIVINGBOOST
   4480  275a2				   -	       clc
   4481  275a2				   -	       adc	mousex1
   4482  275a2				   -	       sta	mousex1
   4483  275a2				   -	       else
   4484  275a2				   -	       cpx	#6
   4485  275a2				   -	       beq	carryonmouse1boost
   4486  275a2				   -	       clc
   4487  275a2				   -	       adc	mousex1
   4488  275a2				   -	       sta	mousex1
   4489  275a2				   -	       jmp	LLRET1
   4490  275a2				   -carryonmouse1boost
   4491  275a2				   -	       sta	mousexdelta
   4492  275a2				   -	       clc
   4493  275a2				   -	       adc	mousecodey1
   4494  275a2				   -	       sta	mousecodey1
   4495  275a2				   -	       clc
   4496  275a2				   -	       adc	mousex1
   4497  275a2				   -	       tay		; save the target X
   4498  275a2				   -	       adc	mousey1	; average in the smoothly-trailing X
   4499  275a2				   -	       ror
   4500  275a2				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   4501  275a2				   -	       sty	mousey1	; and mousey0 has the the target X
   4502  275a2				   -
   4503  275a2				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4504  275a2				   -			; A has mousex1, the smoothly trailing X
   4505  275a2				   -	       sbc	mousey1	; less the target X
   4506  275a2				   -	       bpl	skipabsolutedrive1
   4507  275a2				   -	       eor	#$ff
   4508  275a2				   -skipabsolutedrive1
   4509  275a2				   -	       cmp	#64	; just an unreasonably large change
   4510  275a2				   -	       bcc	skipdrivewrapfix1
   4511  275a2				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   4512  275a2				   -skipdrivewrapfix1
   4513  275a2				   -
   4514  275a2				   -			; get rid of the tweening if the distance travelled was very small
   4515  275a2				   -	       lda	mousexdelta
   4516  275a2				   -	       cmp	port1resolution
   4517  275a2				   -	       bcs	skipbetweenfix1
   4518  275a2				   -	       lda	mousex1
   4519  275a2				   -	       sta	mousey1
   4520  275a2				   -skipbetweenfix1
   4521  275a2				   -
   4522  275a2				   -drivingboostreductioncheck1
   4523  275a2				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4524  275a2				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4525  275a2				   -			; negated again because truncation during BCD math results in 
   4526  275a2				   -			; differing magnitudes, depending if the value is +ve or -ve.
   4527  275a2				   -driving1fix
   4528  275a2				   -	       lax	mousecodey1
   4529  275a2				   -	       cmp	#$80
   4530  275a2				   -	       bcs	driving0skipnegate1
   4531  275a2				   -	       eor	#$FF
   4532  275a2				   -	       adc	#1
   4533  275a2				   -	       sta	mousecodey1
   4534  275a2				   -driving0skipnegate1
   4535  275a2				   -	       cmp	#$80
   4536  275a2				   -	       ror
   4537  275a2				   -	       cmp	#$80
   4538  275a2				   -	       ror
   4539  275a2				   -	       cmp	#$80
   4540  275a2				   -	       ror
   4541  275a2				   -	       sta	inttemp1
   4542  275a2				   -	       lda	mousecodey1
   4543  275a2				   -	       sec
   4544  275a2				   -	       sbc	inttemp1
   4545  275a2				   -	       cpx	#$80
   4546  275a2				   -	       bcs	driving1skipnegate2
   4547  275a2				   -	       eor	#$FF
   4548  275a2				   -	       adc	#1
   4549  275a2				   -driving1skipnegate2
   4550  275a2				   -	       sta	mousecodey1
   4551  275a2				   -drivingboostdone1
   4552  275a2				   -	       endif		; DRIVINGBOOST
   4553  275a2				   -
   4554  275a2				   -	       jmp	LLRET1
   4555  275a2				   -
   4556  275a2					       endif		; MOUSE1SUPPORT
   4557  275a2
   4558  275a2
   4559  275a2				    trakball0update
   4560  275a2				   -	       ifconst	TRAKBALL0SUPPORT
   4561  275a2				   -	       ifnconst	TRAKTIME
   4562  275a2				   -	       ifnconst	TRAKXONLY
   4563  275a2				   -	       lda	#180	; minimum for x+y
   4564  275a2				   -	       else		; !TRAKXONLY
   4565  275a2				   -	       lda	#100	; minimum for just x
   4566  275a2				   -	       endif		; !TRAKXONLY
   4567  275a2				   -	       else		; !TRAKTIME
   4568  275a2				   -	       lda	#TRAKTIME
   4569  275a2				   -	       endif		; !TRAKTIME
   4570  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4571  275a2				   -	       ldx	#0
   4572  275a2				   -	       ifnconst	TRAKXONLY
   4573  275a2				   -	       ldy	#0
   4574  275a2				   -	       endif		; TRAKXONLY
   4575  275a2				   -trakball0updateloop
   4576  275a2				   -	       lda	SWCHA
   4577  275a2				   -	       and	#%00110000
   4578  275a2				   -	       cmp	trakballcodex0
   4579  275a2				   -	       sta	trakballcodex0
   4580  275a2				   -	       beq	trakball0movementXdone
   4581  275a2				   -	       and	#%00010000
   4582  275a2				   -	       beq	trakball0negativeX
   4583  275a2				   -trakball0positiveX
   4584  275a2				   -			;(2 from beq)
   4585  275a2				   -	       inx		; 2
   4586  275a2				   -	       jmp	trakball0movementXdone	; 3
   4587  275a2				   -trakball0negativeX
   4588  275a2				   -			;(3 from beq)
   4589  275a2				   -	       dex		; 2
   4590  275a2				   -	       nop		; 2
   4591  275a2				   -trakball0movementXdone
   4592  275a2				   -
   4593  275a2				   -	       ifnconst	TRAKXONLY
   4594  275a2				   -	       lda	SWCHA
   4595  275a2				   -	       and	#%11000000
   4596  275a2				   -	       cmp	trakballcodey0
   4597  275a2				   -	       sta	trakballcodey0
   4598  275a2				   -	       beq	trakball0movementYdone
   4599  275a2				   -	       and	#%01000000
   4600  275a2				   -	       beq	trakball0negativeY
   4601  275a2				   -trakball0positiveY
   4602  275a2				   -			;(2 from beq)
   4603  275a2				   -	       iny		; 2
   4604  275a2				   -	       jmp	trakball0movementYdone	; 3
   4605  275a2				   -trakball0negativeY
   4606  275a2				   -			;(3 from beq)
   4607  275a2				   -	       dey		; 2
   4608  275a2				   -	       nop		; 2
   4609  275a2				   -trakball0movementYdone
   4610  275a2				   -	       endif		; !TRAKXONLY
   4611  275a2				   -
   4612  275a2				   -	       lda	TIMINT
   4613  275a2				   -	       bpl	trakball0updateloop
   4614  275a2				   -	       lda	#0
   4615  275a2				   -	       cpx	#0
   4616  275a2				   -	       beq	trakball0skipXadjust
   4617  275a2				   -	       clc
   4618  275a2				   -trakball0Xloop
   4619  275a2				   -	       adc	port0resolution
   4620  275a2				   -	       dex
   4621  275a2				   -	       bne	trakball0Xloop
   4622  275a2				   -	       clc
   4623  275a2				   -	       adc	trakballx0
   4624  275a2				   -	       sta	trakballx0
   4625  275a2				   -trakball0skipXadjust
   4626  275a2				   -	       ifnconst	TRAKXONLY
   4627  275a2				   -	       lda	#0
   4628  275a2				   -	       cpy	#0
   4629  275a2				   -	       beq	trakball0skipYadjust
   4630  275a2				   -	       clc
   4631  275a2				   -trakball0yloop
   4632  275a2				   -	       adc	port0resolution
   4633  275a2				   -	       dey
   4634  275a2				   -	       bne	trakball0yloop
   4635  275a2				   -	       clc
   4636  275a2				   -	       adc	trakbally0
   4637  275a2				   -	       sta	trakbally0
   4638  275a2				   -trakball0skipYadjust
   4639  275a2				   -	       endif		; !TRAKXONLY
   4640  275a2				   -
   4641  275a2				   -	       jmp	LLRET0
   4642  275a2					       endif
   4643  275a2
   4644  275a2
   4645  275a2
   4646  275a2				    trakball1update
   4647  275a2				   -	       ifconst	TRAKBALL1SUPPORT
   4648  275a2				   -	       ifnconst	TRAKTIME
   4649  275a2				   -	       ifnconst	TRAKXONLY
   4650  275a2				   -	       lda	#180	; minimum for x+y
   4651  275a2				   -	       else		; !TRAKXONLY
   4652  275a2				   -	       lda	#100	; minimum for just x
   4653  275a2				   -	       endif		; !TRAKXONLY
   4654  275a2				   -	       else		; !TRAKTIME
   4655  275a2				   -	       lda	#TRAKTIME
   4656  275a2				   -	       endif		; !TRAKTIME
   4657  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4658  275a2				   -	       ldx	#0
   4659  275a2				   -	       ifnconst	TRAKXONLY
   4660  275a2				   -	       ldy	#0
   4661  275a2				   -	       endif		; TRAKXONLY
   4662  275a2				   -trakball1updateloop
   4663  275a2				   -	       lda	SWCHA
   4664  275a2				   -	       and	#%00000011
   4665  275a2				   -	       cmp	trakballcodex1
   4666  275a2				   -	       sta	trakballcodex1
   4667  275a2				   -	       beq	trakball1movementXdone
   4668  275a2				   -	       and	#%00000001
   4669  275a2				   -	       beq	trakball1negativeX
   4670  275a2				   -trakball1positiveX
   4671  275a2				   -			;(2 from beq)
   4672  275a2				   -	       inx		; 2
   4673  275a2				   -	       jmp	trakball1movementXdone	; 3
   4674  275a2				   -trakball1negativeX
   4675  275a2				   -			;(3 from beq)
   4676  275a2				   -	       dex		; 2
   4677  275a2				   -	       nop		; 2
   4678  275a2				   -trakball1movementXdone
   4679  275a2				   -
   4680  275a2				   -	       ifnconst	TRAKXONLY
   4681  275a2				   -	       lda	SWCHA
   4682  275a2				   -	       and	#%00001100
   4683  275a2				   -	       cmp	trakballcodey1
   4684  275a2				   -	       sta	trakballcodey1
   4685  275a2				   -	       beq	trakball1movementYdone
   4686  275a2				   -	       and	#%00000100
   4687  275a2				   -	       beq	trakball1negativeY
   4688  275a2				   -trakball1positiveY
   4689  275a2				   -			;(2 from beq)
   4690  275a2				   -	       iny		; 2
   4691  275a2				   -	       jmp	trakball1movementYdone	; 3
   4692  275a2				   -trakball1negativeY
   4693  275a2				   -			;(3 from beq)
   4694  275a2				   -	       dey		; 2
   4695  275a2				   -	       nop		; 2
   4696  275a2				   -trakball1movementYdone
   4697  275a2				   -	       endif		; !TRAKXONLY
   4698  275a2				   -
   4699  275a2				   -	       lda	TIMINT
   4700  275a2				   -	       bpl	trakball1updateloop
   4701  275a2				   -	       lda	#0
   4702  275a2				   -	       cpx	#0
   4703  275a2				   -	       beq	trakball1skipXadjust
   4704  275a2				   -	       clc
   4705  275a2				   -trakball1Xloop
   4706  275a2				   -	       adc	port1resolution
   4707  275a2				   -	       dex
   4708  275a2				   -	       bne	trakball1Xloop
   4709  275a2				   -	       clc
   4710  275a2				   -	       adc	trakballx1
   4711  275a2				   -	       sta	trakballx1
   4712  275a2				   -trakball1skipXadjust
   4713  275a2				   -	       ifnconst	TRAKXONLY
   4714  275a2				   -	       lda	#0
   4715  275a2				   -	       cpy	#0
   4716  275a2				   -	       beq	trakball1skipYadjust
   4717  275a2				   -	       clc
   4718  275a2				   -trakball1yloop
   4719  275a2				   -	       adc	port1resolution
   4720  275a2				   -	       dey
   4721  275a2				   -	       bne	trakball1yloop
   4722  275a2				   -	       clc
   4723  275a2				   -	       adc	trakbally1
   4724  275a2				   -	       sta	trakbally1
   4725  275a2				   -trakball1skipYadjust
   4726  275a2				   -	       endif		; !TRAKXONLY
   4727  275a2				   -
   4728  275a2				   -	       jmp	LLRET1
   4729  275a2					       endif
   4730  275a2
   4731  275a2
   4732  275a2				    paddleport0update
   4733  275a2				   -	       ifconst	PADDLE0SUPPORT
   4734  275a2				   -	       lda	#6
   4735  275a2				   -	       sta	VBLANK	; start charging the paddle caps
   4736  275a2				   -	       lda	#0	; use PADDLE timing
   4737  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4738  275a2				   -
   4739  275a2				   -paddleport0updateloop
   4740  275a2				   -	       lda	INPT0
   4741  275a2				   -	       bmi	skippaddle0setposition
   4742  275a2				   -	       sty	paddleposition0
   4743  275a2				   -skippaddle0setposition
   4744  275a2				   -	       ifconst	TWOPADDLESUPPORT
   4745  275a2				   -	       lda	INPT1
   4746  275a2				   -	       bmi	skippaddle1setposition
   4747  275a2				   -	       sty	paddleposition1
   4748  275a2				   -skippaddle1setposition
   4749  275a2				   -	       endif
   4750  275a2				   -	       ldy	INTIM
   4751  275a2				   -	       cpy	#TIMEOFFSET
   4752  275a2				   -	       bcs	paddleport0updateloop
   4753  275a2				   -
   4754  275a2				   -	       lda	#%10000110
   4755  275a2				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4756  275a2				   -	       sec
   4757  275a2				   -	       lda	paddleposition0
   4758  275a2				   -	       sbc	#TIMEOFFSET
   4759  275a2				   -	       ifconst	PADDLESCALEX2
   4760  275a2				   -	       asl
   4761  275a2				   -	       endif
   4762  275a2				   -
   4763  275a2				   -	       ifnconst	PADDLESMOOTHINGOFF
   4764  275a2				   -	       clc
   4765  275a2				   -	       adc	paddleprevious0
   4766  275a2				   -	       ror
   4767  275a2				   -	       sta	paddleprevious0
   4768  275a2				   -	       endif
   4769  275a2				   -
   4770  275a2				   -	       sta	paddleposition0
   4771  275a2				   -
   4772  275a2				   -	       ifconst	TWOPADDLESUPPORT
   4773  275a2				   -	       sec
   4774  275a2				   -	       lda	paddleposition1
   4775  275a2				   -	       sbc	#TIMEOFFSET
   4776  275a2				   -	       ifconst	PADDLESCALEX2
   4777  275a2				   -	       asl
   4778  275a2				   -	       endif
   4779  275a2				   -
   4780  275a2				   -	       ifnconst	PADDLESMOOTHINGOFF
   4781  275a2				   -	       clc
   4782  275a2				   -	       adc	paddleprevious1
   4783  275a2				   -	       ror
   4784  275a2				   -	       sta	paddleprevious1
   4785  275a2				   -	       endif
   4786  275a2				   -	       sta	paddleposition1
   4787  275a2				   -	       endif		; TWOPADDLESUPPORT
   4788  275a2				   -
   4789  275a2				   -	       jmp	LLRET0
   4790  275a2					       endif
   4791  275a2
   4792  275a2				    paddleport1update
   4793  275a2				   -	       ifconst	PADDLE1SUPPORT
   4794  275a2				   -	       lda	#6
   4795  275a2				   -	       sta	VBLANK	; start charging the paddle caps
   4796  275a2				   -
   4797  275a2				   -	       lda	#0	; use PADDLE timing
   4798  275a2				   -	       jsr	SETTIM64T	; INTIM is in Y
   4799  275a2				   -
   4800  275a2				   -paddleport1updateloop
   4801  275a2				   -	       lda	INPT2
   4802  275a2				   -	       bmi	skippaddle2setposition
   4803  275a2				   -	       sty	paddleposition2
   4804  275a2				   -skippaddle2setposition
   4805  275a2				   -	       ifconst	TWOPADDLESUPPORT
   4806  275a2				   -	       lda	INPT3
   4807  275a2				   -	       bmi	skippaddle3setposition
   4808  275a2				   -	       sty	paddleposition3
   4809  275a2				   -skippaddle3setposition
   4810  275a2				   -	       endif
   4811  275a2				   -	       ldy	INTIM
   4812  275a2				   -	       cpy	#TIMEOFFSET
   4813  275a2				   -	       bcs	paddleport1updateloop
   4814  275a2				   -
   4815  275a2				   -	       lda	#%10000110
   4816  275a2				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4817  275a2				   -	       sec
   4818  275a2				   -	       lda	paddleposition2
   4819  275a2				   -	       sbc	#TIMEOFFSET
   4820  275a2				   -	       ifconst	PADDLESCALEX2
   4821  275a2				   -	       asl
   4822  275a2				   -	       endif
   4823  275a2				   -
   4824  275a2				   -	       ifnconst	PADDLESMOOTHINGOFF
   4825  275a2				   -	       clc
   4826  275a2				   -	       adc	paddleprevious2
   4827  275a2				   -	       ror
   4828  275a2				   -	       sta	paddleprevious2
   4829  275a2				   -	       endif
   4830  275a2				   -
   4831  275a2				   -	       sta	paddleposition2
   4832  275a2				   -
   4833  275a2				   -	       ifconst	TWOPADDLESUPPORT
   4834  275a2				   -	       sec
   4835  275a2				   -	       lda	paddleposition3
   4836  275a2				   -	       sbc	#TIMEOFFSET
   4837  275a2				   -	       ifconst	PADDLESCALEX2
   4838  275a2				   -	       asl
   4839  275a2				   -	       endif
   4840  275a2				   -
   4841  275a2				   -	       ifnconst	PADDLESMOOTHINGOFF
   4842  275a2				   -	       clc
   4843  275a2				   -	       adc	paddleprevious3
   4844  275a2				   -	       ror
   4845  275a2				   -	       sta	paddleprevious3
   4846  275a2				   -	       endif
   4847  275a2				   -	       sta	paddleposition3
   4848  275a2				   -	       endif		; TWOPADDLESUPPORT
   4849  275a2				   -
   4850  275a2				   -	       jmp	LLRET1
   4851  275a2					       endif
   4852  275a2
   4853  275a2
   4854  275a2				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   4855  275a2				   -	       ifconst	PADDLESUPPORT
   4856  275a2				   -			; x=0|1 for port, rather than paddle #. 
   4857  275a2				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   4858  275a2				   -			; game wants to support 2 paddles, up to the game to instead test the 
   4859  275a2				   -			; joystick right+left directions instead.
   4860  275a2				   -	       lda	SWCHA	; top of nibble is first paddle button
   4861  275a2				   -	       cpx	#0	; port 0?
   4862  275a2				   -	       beq	skippaddleport2shift
   4863  275a2				   -	       asl		; shift second port to upper nibble
   4864  275a2				   -	       asl
   4865  275a2				   -	       asl
   4866  275a2				   -	       asl
   4867  275a2				   -skippaddleport2shift
   4868  275a2				   -	       and	#%10000000
   4869  275a2				   -	       eor	#%10000000	; invert
   4870  275a2				   -	       sta	sINPT1,x
   4871  275a2				   -	       jmp	buttonreadloopreturn
   4872  275a2					       endif		; PADDLESUPPORT
   4873  275a2
   4874  275a2				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   4875  275a2				   -	       ifconst	MOUSESUPPORT
   4876  275a2				   -			; stick the mouse buttons in the correct shadow register...
   4877  275a2				   -	       txa
   4878  275a2				   -	       asl
   4879  275a2				   -	       tay		; y=x*2
   4880  275a2				   -	       lda	INPT4,x
   4881  275a2				   -	       eor	#%10000000
   4882  275a2				   -	       lsr
   4883  275a2				   -	       sta	sINPT1,x
   4884  275a2				   -
   4885  275a2				   -	       lda	INPT1,y
   4886  275a2				   -	       and	#%10000000
   4887  275a2				   -	       eor	#%10000000
   4888  275a2				   -	       ora	sINPT1,x
   4889  275a2				   -	       sta	sINPT1,x
   4890  275a2				   -	       jmp	buttonreadloopreturn
   4891  275a2					       endif		; MOUSESUPPORT
   4892  275a2
   4893  275a2				   -	       ifconst	KEYPADSUPPORT
   4894  275a2				   -			; ** select keypad rows 0 to 3 over 4 frames...
   4895  275a2				   -keypadrowselect
   4896  275a2				   -	       inc	keypadcounter
   4897  275a2				   -	       ldy	#0
   4898  275a2				   -	       lda	port0control
   4899  275a2				   -	       cmp	#7
   4900  275a2				   -	       bne	skipport0val
   4901  275a2				   -	       iny		; y=y+1
   4902  275a2				   -skipport0val
   4903  275a2				   -	       lda	port1control
   4904  275a2				   -	       cmp	#7
   4905  275a2				   -	       bne	skipport1val
   4906  275a2				   -	       iny
   4907  275a2				   -	       iny		; y=y+2
   4908  275a2				   -skipport1val
   4909  275a2				   -	       cpy	#0
   4910  275a2				   -	       beq	exitkeypadrowselect
   4911  275a2				   -	       lda	keyrowdirectionmask,y
   4912  275a2				   -	       sta	CTLSWA
   4913  275a2				   -	       tya
   4914  275a2				   -	       asl
   4915  275a2				   -	       asl
   4916  275a2				   -	       sta	inttemp1
   4917  275a2				   -	       lda	keypadcounter
   4918  275a2				   -	       and	#3
   4919  275a2				   -	       ora	inttemp1
   4920  275a2				   -	       tax
   4921  275a2				   -	       lda	keyrowselectvalue,x
   4922  275a2				   -	       sta	SWCHA
   4923  275a2				   -exitkeypadrowselect
   4924  275a2				   -	       rts
   4925  275a2				   -
   4926  275a2				   -keyrowdirectionmask
   4927  275a2				   -	       .byte	#%00000000	; 0 : port0=input port1=input
   4928  275a2				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   4929  275a2				   -	       .byte	#%00001111	; 2 : port0=input port1=output
   4930  275a2				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   4931  275a2				   -
   4932  275a2				   -keyrowselectvalue
   4933  275a2				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   4934  275a2				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   4935  275a2				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   4936  275a2				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   4937  275a2					       endif		; KEYPADSUPPORT
   4938  275a2
   4939  275a2				   -	       ifconst	KEYPADSUPPORT
   4940  275a2				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   4941  275a2				   -keypadcolumnread
   4942  275a2				   -	       lda	port0control
   4943  275a2				   -	       cmp	#7
   4944  275a2				   -	       bne	skipkeypadcolumnread0
   4945  275a2				   -	       lda	keypadcounter
   4946  275a2				   -	       and	#3
   4947  275a2				   -	       asl		; x2 because keypad variables are interleaved
   4948  275a2				   -	       tax
   4949  275a2				   -	       lda	#0
   4950  275a2				   -	       sta	keypadmatrix0a,x
   4951  275a2				   -	       lda	INPT0
   4952  275a2				   -	       cmp	#$80
   4953  275a2				   -	       rol	keypadmatrix0a,x
   4954  275a2				   -	       lda	INPT1
   4955  275a2				   -	       cmp	#$80
   4956  275a2				   -	       rol	keypadmatrix0a,x
   4957  275a2				   -	       lda	INPT4
   4958  275a2				   -	       cmp	#$80
   4959  275a2				   -	       rol	keypadmatrix0a,x
   4960  275a2				   -	       lda	keypadmatrix0a,x
   4961  275a2				   -	       eor	#%00000111
   4962  275a2				   -	       sta	keypadmatrix0a,x
   4963  275a2				   -skipkeypadcolumnread0
   4964  275a2				   -
   4965  275a2				   -	       lda	port1control
   4966  275a2				   -	       cmp	#7
   4967  275a2				   -	       bne	skipkeypadcolumnread1
   4968  275a2				   -	       lda	keypadcounter
   4969  275a2				   -	       and	#3
   4970  275a2				   -	       asl		; x2 because keypad variables are interleaved
   4971  275a2				   -	       tax
   4972  275a2				   -	       lda	#0
   4973  275a2				   -	       sta	keypadmatrix1a,x
   4974  275a2				   -	       rol	keypadmatrix1a,x
   4975  275a2				   -	       lda	INPT2
   4976  275a2				   -	       cmp	#$80
   4977  275a2				   -	       rol	keypadmatrix1a,x
   4978  275a2				   -	       lda	INPT3
   4979  275a2				   -	       cmp	#$80
   4980  275a2				   -	       rol	keypadmatrix1a,x
   4981  275a2				   -	       lda	INPT5
   4982  275a2				   -	       cmp	#$80
   4983  275a2				   -	       rol	keypadmatrix1a,x
   4984  275a2				   -	       lda	keypadmatrix1a,x
   4985  275a2				   -	       eor	#%00000111
   4986  275a2				   -	       sta	keypadmatrix1a,x
   4987  275a2				   -skipkeypadcolumnread1
   4988  275a2				   -	       rts
   4989  275a2					       endif		; KEYPADSUPPORT
   4990  275a2
   4991  275a2				    setportforinput
   4992  275a2			ad 81 02	       lda	CTLSWA
   4993  275a5			3d d7 f1	       and	SWCHA_DIRMASK,x
   4994  275a8			8d 81 02	       sta	CTLSWA
   4995  275ab			60		       rts
   4996  275ac
   4997  275ac				    setonebuttonmode
   4998  275ac			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   4999  275ae			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5000  275b0			a9 14		       lda	#$14
   5001  275b2			8d 83 02	       sta	CTLSWB
   5002  275b5			ad 82 02	       lda	SWCHB
   5003  275b8			1d d2 f5	       ora	thisjoy2buttonbit,x	; disable: write 1 to the 2-button bit
   5004  275bb			8d 82 02	       sta	SWCHB
   5005  275be			60		       rts
   5006  275bf
   5007  275bf				    settwobuttonmode
   5008  275bf			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5009  275c1			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5010  275c3			a9 14		       lda	#$14
   5011  275c5			8d 83 02	       sta	CTLSWB
   5012  275c8			ad 82 02	       lda	SWCHB
   5013  275cb			3d d3 f5	       and	thisjoy2buttonbit+1,x	; enable: write 0 to the 2-button bit
   5014  275ce			8d 82 02	       sta	SWCHB
   5015  275d1			60		       rts
   5016  275d2
   5017  275d2				    thisjoy2buttonbit
   5018  275d2							; p0	p1   p0
   5019  275d2			04 10 04	       .byte.b	$04, $10, $04
   5020  275d5
   5021  275d5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5022  275d5
   5023  275d5				    START
   5024  275d5				    start
   5025  275d5
   5026  275d5							;******** more or less the Atari recommended startup procedure
   5027  275d5
   5028  275d5			78		       sei
   5029  275d6			d8		       cld
   5030  275d7
   5031  275d7					       ifnconst	NOTIALOCK
   5032  275d7			a9 07		       lda	#$07
   5033  275d9				   -	       else
   5034  275d9				   -	       lda	#$06
   5035  275d9					       endif
   5036  275d9			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   5037  275db			a9 7f		       lda	#$7F
   5038  275dd			85 3c		       sta	CTRL	;disable DMA
   5039  275df			a9 00		       lda	#$00
   5040  275e1			85 38		       sta	OFFSET
   5041  275e3					       ifnconst	NOTIALOCK
   5042  275e3			85 01		       sta	INPTCTRL
   5043  275e5			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   5044  275e7					       endif
   5045  275e7			a2 ff		       ldx	#$FF
   5046  275e9			9a		       txs
   5047  275ea
   5048  275ea							;************** Clear Memory
   5049  275ea
   5050  275ea							; ** Clear 1800-27FF, pg0+pg1 memory.
   5051  275ea				    ClearMemPages
   5052  275ea			a9 00		       lda	#0
   5053  275ec			a8		       tay		; y=0
   5054  275ed			85 80		       sta	$80
   5055  275ef			a2 18		       ldx	#$18
   5056  275f1				    ClearMemPagesLoop
   5057  275f1			86 81		       stx	$81	; needed for when we step on ZP memory
   5058  275f3			91 80		       sta	($80),y	;Store data
   5059  275f5			c8		       iny		;Next byte
   5060  275f6			d0 f9		       bne	ClearMemPagesLoop
   5061  275f8			e8		       inx
   5062  275f9			e0 28		       cpx	#$28
   5063  275fb			d0 f4		       bne	ClearMemPagesLoop
   5064  275fd			85 81		       sta	$81
   5065  275ff
   5066  275ff							;seed random number with hopefully-random timer value
   5067  275ff			a9 01		       lda	#1
   5068  27601			0d 84 02	       ora	INTIM
   5069  27604			85 40		       sta	rand
   5070  27606
   5071  27606							; detect the console type...
   5072  27606				    pndetectvblankstart
   5073  27606			a5 28		       lda	MSTAT
   5074  27608			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5075  2760a				    pndetectvblankover
   5076  2760a			a5 28		       lda	MSTAT
   5077  2760c			30 fc		       bmi	pndetectvblankover	; then wait for it to be over
   5078  2760e			a0 00		       ldy	#$00
   5079  27610			a2 00		       ldx	#$00
   5080  27612				    pndetectvblankhappening
   5081  27612			a5 28		       lda	MSTAT
   5082  27614			30 07		       bmi	pndetectinvblank	; if VBLANK starts, exit our counting loop 
   5083  27616			85 24		       sta	WSYNC
   5084  27618			85 24		       sta	WSYNC
   5085  2761a			e8		       inx
   5086  2761b			d0 f5		       bne	pndetectvblankhappening
   5087  2761d				    pndetectinvblank
   5088  2761d			e0 7d		       cpx	#125
   5089  2761f			90 02		       bcc	pndetecispal
   5090  27621			a0 01		       ldy	#$01
   5091  27623				    pndetecispal
   5092  27623			8c 09 21	       sty	paldetected
   5093  27626
   5094  27626			20 5b f4	       jsr	createallgamedlls
   5095  27629
   5096  27629			a9 18		       lda	#>DLLMEM
   5097  2762b			85 2c		       sta	DPPH
   5098  2762d			a9 00		       lda	#<DLLMEM
   5099  2762f			85 30		       sta	DPPL
   5100  27631
   5101  27631				   -	       ifconst	pokeysupport
   5102  27631				   -			; pokey support is compiled in, so try to detect it...
   5103  27631				   -	       jsr	detectpokeylocation
   5104  27631					       endif
   5105  27631
   5106  27631			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   5107  27633			8d ba 01	       sta	port0control
   5108  27636			8d bb 01	       sta	port1control
   5109  27639
   5110  27639							;Setup port A to read mode
   5111  27639							;lda #$00
   5112  27639							;sta SWCHA
   5113  27639							;sta CTLSWA
   5114  27639
   5115  27639				   -	       ifconst	HSSUPPORT
   5116  27639				   -	       ifconst	bankswitchmode
   5117  27639				   -	       ifconst	included.hiscore.asm.bank
   5118  27639				   -	       ifconst	MCPDEVCART
   5119  27639				   -	       lda	#($18 | included.hiscore.asm.bank)
   5120  27639				   -	       ifconst	dumpbankswitch
   5121  27639				   -	       sta	dumpbankswitch
   5122  27639				   -	       endif
   5123  27639				   -	       sta	$3000
   5124  27639				   -	       else
   5125  27639				   -	       lda	#(included.hiscore.asm.bank)
   5126  27639				   -	       ifconst	dumpbankswitch
   5127  27639				   -	       sta	dumpbankswitch
   5128  27639				   -	       endif
   5129  27639				   -	       sta	$8000
   5130  27639				   -	       endif
   5131  27639				   -	       endif		; included.hiscore.asm.bank
   5132  27639				   -	       endif		; bankswitchmode
   5133  27639				   -			; try to detect HSC
   5134  27639				   -	       jsr	detecthsc
   5135  27639				   -	       and	#1
   5136  27639				   -	       sta	hsdevice
   5137  27639				   -skipHSCdetect
   5138  27639				   -			; try to detect AtariVox eeprom
   5139  27639				   -	       jsr	detectatarivoxeeprom
   5140  27639				   -	       and	#2
   5141  27639				   -	       ora	hsdevice
   5142  27639				   -	       cmp	#3
   5143  27639				   -	       bne	storeAinhsdevice
   5144  27639				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5145  27639				   -			; Later we should check each device's priority byte if set, instead, 
   5146  27639				   -	       lda	#2
   5147  27639				   -storeAinhsdevice
   5148  27639				   -	       sta	hsdevice
   5149  27639				   -	       lda	#$ff
   5150  27639				   -	       sta	hsdifficulty
   5151  27639				   -	       sta	hsgameslot
   5152  27639				   -	       sta	hsnewscoreline
   5153  27639					       endif		; HSSUPPORT
   5154  27639
   5155  27639				   -	       ifconst	AVOXVOICE
   5156  27639				   -	       jsr	silenceavoxvoice
   5157  27639					       endif
   5158  27639
   5159  27639				   -	       ifconst	RMT
   5160  27639				   -	       ifconst	RMTVOLUME
   5161  27639				   -	       lda	#$F0	; default to full RMT volume
   5162  27639				   -	       sta	rmtvolume
   5163  27639				   -	       ifconst	TIAVOLUME
   5164  27639				   -	       sta	tiavolume
   5165  27639				   -	       endif		; TIAVOLUME
   5166  27639				   -	       endif		; RMTVOLUME
   5167  27639					       else		; !RMT
   5168  27639				   -	       ifconst	TIAVOLUME
   5169  27639				   -	       lda	#$F0	; default to full TIA volume
   5170  27639				   -	       sta	tiavolume
   5171  27639					       endif		; TIAVOLUME
   5172  27639					       endif		; RMT
   5173  27639
   5174  27639					       ifconst	bankswitchmode
   5175  27639							; we need to switch to the first bank as a default. this needs to
   5176  27639							; happen before DMA, in case there's a topscreenroutine in bank 0
   5177  27639				   -	       ifconst	MCPDEVCART
   5178  27639				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5179  27639				   -	       ifconst	dumpbankswitch
   5180  27639				   -	       sta	dumpbankswitch
   5181  27639				   -	       endif
   5182  27639				   -	       sta	$3000
   5183  27639					       else
   5184  27639			a9 00		       lda	#0
   5185  2763b				   -	       ifconst	dumpbankswitch
   5186  2763b				   -	       sta	dumpbankswitch
   5187  2763b					       endif
   5188  2763b			8d 00 80	       sta	$8000
   5189  2763e					       endif
   5190  2763e					       endif
   5191  2763e
   5192  2763e							; CTRL 76543210
   5193  2763e							; 7 colorburst kill
   5194  2763e							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5195  2763e							; 4 character width 1=2 byte chars, 0=1 byte chars
   5196  2763e							; 3 border control 0=background color border, 1=black border
   5197  2763e							; 2 kangaroo mode 0=transparency, 1=kangaroo
   5198  2763e							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5199  2763e
   5200  2763e				   -	       ifconst	DOUBLEWIDE
   5201  2763e				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5202  2763e					       else
   5203  2763e			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5204  27640					       endif
   5205  27640
   5206  27640			20 0f f5	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   5207  27643
   5208  27643			85 3c		       sta	CTRL
   5209  27645			8d 07 21	       sta	sCTRL
   5210  27648
   5211  27648			20 4e f4	       jsr	vblankresync
   5212  2764b
   5213  2764b			a2 01		       ldx	#1
   5214  2764d			20 bf f5	       jsr	settwobuttonmode
   5215  27650			a2 00		       ldx	#0
   5216  27652			20 bf f5	       jsr	settwobuttonmode
   5217  27655
   5218  27655					       ifnconst	.altgamestart
   5219  27655			4c 00 80	       jmp	game
   5220  27658				   -	       else
   5221  27658				   -	       jmp	.altgamestart
   5222  27658					       endif
   5223  27658
   5224  27658							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5225  27658
   5226  27658							;************** Setup DLL entries
   5227  27658
   5228  27658							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5229  27658					       ifnconst	SCREENHEIGHT
   5230  27658			00 c0	    WSCREENHEIGHT =	192
   5231  27658				   -	       else
   5232  27658				   -WSCREENHEIGHT =	SCREENHEIGHT
   5233  27658					       endif
   5234  27658
   5235  27658				   -	       ifnconst	ZONEHEIGHT
   5236  27658				   -WZONEHEIGHT =	16
   5237  27658					       else
   5238  27658			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   5239  27658					       endif
   5240  27658
   5241  27658					       ifnconst	ZONECOUNT
   5242  27658			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5243  27658				   -	       else
   5244  27658				   -WZONECOUNT =	ZONECOUNT
   5245  27658					       endif
   5246  27658
   5247  27658							; top of the frame, non-visible lines. this is based on NTSC,
   5248  27658							; but we add in extra NV lines at the end of the display to ensure
   5249  27658							; our PAL friends can play the game without it crashing.
   5250  27658			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   5251  27658
   5252  27658				   -	       ifnconst	DLMEMSTART
   5253  27658				   -	       ifnconst	DOUBLEBUFFER
   5254  27658				   -WDLMEMSTART =	$1880
   5255  27658				   -	       else
   5256  27658				   -WDLMEMSTART =	$18E0
   5257  27658				   -	       endif		; DOUBLEBUFFER
   5258  27658					       else
   5259  27658			40 00	    WDLMEMSTART =	DLMEMSTART
   5260  27658					       endif
   5261  27658
   5262  27658				   -	       ifnconst	DLMEMEND
   5263  27658				   -	       ifconst	EXTRADLMEMORY
   5264  27658				   -WDLMEMEND  =	$23FF
   5265  27658				   -	       else
   5266  27658				   -WDLMEMEND  =	$1FFF
   5267  27658				   -	       endif
   5268  27658					       else
   5269  27658			7f ff	    WDLMEMEND  =	DLMEMEND
   5270  27658					       endif
   5271  27658
   5272  27658
   5273  27658			40 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   5274  27658
   5275  27658				   -	       ifnconst	DOUBLEBUFFER
   5276  27658				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5277  27658					       else
   5278  27658			02 a8	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5279  27658					       endif
   5280  27658
   5281  27658			02 aa	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5282  27658					       if	TDOUBLEBUFFEROFFSET > 255
   5283  27658			00 ff	    DOUBLEBUFFEROFFSET =	255
   5284  27658				   -	       else
   5285  27658				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5286  27658					       endif
   5287  27658
   5288  27658				   -	       ifconst	EXTRADLMEMORY
   5289  27658				   -SECONDDLHALFSTART SET	$2300
   5290  27658					       endif
   5291  27658
   5292  27658				    DLPOINTH
   5293  27658				    DLINDEX    SET	0
   5294  27658					       REPEAT	WZONECOUNT
   5295  27658				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27658				   -	       ifconst	EXTRADLMEMORY
   5297  27658				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27658				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27658				   -	       else
   5300  27658				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27658				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27658				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27658				   -	       endif
   5304  27658				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27658					       endif		; EXTRADLMEMORY
   5306  27658							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27658			40		       .byte.b	>TMPMEMADDRESS
   5308  27658				    DLINDEX    SET	DLINDEX + 1
   5294  27658					       REPEND
   5295  27658				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27659				   -	       ifconst	EXTRADLMEMORY
   5297  27659				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27659				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27659				   -	       else
   5300  27659				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27659				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27659				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27659				   -	       endif
   5304  27659				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27659					       endif		; EXTRADLMEMORY
   5306  27659							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27659			45		       .byte.b	>TMPMEMADDRESS
   5308  27659				    DLINDEX    SET	DLINDEX + 1
   5294  27659					       REPEND
   5295  27659				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765a				   -	       ifconst	EXTRADLMEMORY
   5297  2765a				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765a				   -	       else
   5300  2765a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765a				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765a				   -	       endif
   5304  2765a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765a					       endif		; EXTRADLMEMORY
   5306  2765a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765a			4a		       .byte.b	>TMPMEMADDRESS
   5308  2765a				    DLINDEX    SET	DLINDEX + 1
   5294  2765a					       REPEND
   5295  2765a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765b				   -	       ifconst	EXTRADLMEMORY
   5297  2765b				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765b				   -	       else
   5300  2765b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765b				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765b				   -	       endif
   5304  2765b				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765b					       endif		; EXTRADLMEMORY
   5306  2765b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765b			50		       .byte.b	>TMPMEMADDRESS
   5308  2765b				    DLINDEX    SET	DLINDEX + 1
   5294  2765b					       REPEND
   5295  2765b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765c				   -	       ifconst	EXTRADLMEMORY
   5297  2765c				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765c				   -	       else
   5300  2765c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765c				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765c				   -	       endif
   5304  2765c				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765c					       endif		; EXTRADLMEMORY
   5306  2765c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765c			55		       .byte.b	>TMPMEMADDRESS
   5308  2765c				    DLINDEX    SET	DLINDEX + 1
   5294  2765c					       REPEND
   5295  2765c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765d				   -	       ifconst	EXTRADLMEMORY
   5297  2765d				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765d				   -	       else
   5300  2765d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765d				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765d				   -	       endif
   5304  2765d				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765d					       endif		; EXTRADLMEMORY
   5306  2765d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765d			5a		       .byte.b	>TMPMEMADDRESS
   5308  2765d				    DLINDEX    SET	DLINDEX + 1
   5294  2765d					       REPEND
   5295  2765d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765e				   -	       ifconst	EXTRADLMEMORY
   5297  2765e				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765e				   -	       else
   5300  2765e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765e				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765e				   -	       endif
   5304  2765e				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765e					       endif		; EXTRADLMEMORY
   5306  2765e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765e			60		       .byte.b	>TMPMEMADDRESS
   5308  2765e				    DLINDEX    SET	DLINDEX + 1
   5294  2765e					       REPEND
   5295  2765e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  2765f				   -	       ifconst	EXTRADLMEMORY
   5297  2765f				   -	       if	TMPMEMADDRESS > $1FFF
   5298  2765f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  2765f				   -	       else
   5300  2765f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  2765f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  2765f				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  2765f				   -	       endif
   5304  2765f				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  2765f					       endif		; EXTRADLMEMORY
   5306  2765f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  2765f			65		       .byte.b	>TMPMEMADDRESS
   5308  2765f				    DLINDEX    SET	DLINDEX + 1
   5294  2765f					       REPEND
   5295  2765f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27660				   -	       ifconst	EXTRADLMEMORY
   5297  27660				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27660				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27660				   -	       else
   5300  27660				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27660				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27660				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27660				   -	       endif
   5304  27660				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27660					       endif		; EXTRADLMEMORY
   5306  27660							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27660			6a		       .byte.b	>TMPMEMADDRESS
   5308  27660				    DLINDEX    SET	DLINDEX + 1
   5294  27660					       REPEND
   5295  27660				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27661				   -	       ifconst	EXTRADLMEMORY
   5297  27661				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27661				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27661				   -	       else
   5300  27661				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27661				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27661				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27661				   -	       endif
   5304  27661				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27661					       endif		; EXTRADLMEMORY
   5306  27661							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27661			70		       .byte.b	>TMPMEMADDRESS
   5308  27661				    DLINDEX    SET	DLINDEX + 1
   5294  27661					       REPEND
   5295  27661				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27662				   -	       ifconst	EXTRADLMEMORY
   5297  27662				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27662				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27662				   -	       else
   5300  27662				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27662				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27662				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27662				   -	       endif
   5304  27662				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27662					       endif		; EXTRADLMEMORY
   5306  27662							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27662			75		       .byte.b	>TMPMEMADDRESS
   5308  27662				    DLINDEX    SET	DLINDEX + 1
   5294  27662					       REPEND
   5295  27662				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5296  27663				   -	       ifconst	EXTRADLMEMORY
   5297  27663				   -	       if	TMPMEMADDRESS > $1FFF
   5298  27663				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5299  27663				   -	       else
   5300  27663				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5301  27663				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5302  27663				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5303  27663				   -	       endif
   5304  27663				   -	       endif		; TMPMEMADDRESS > $1FFF
   5305  27663					       endif		; EXTRADLMEMORY
   5306  27663							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5307  27663			7a		       .byte.b	>TMPMEMADDRESS
   5308  27663				    DLINDEX    SET	DLINDEX + 1
   5309  27664					       REPEND
   5310  27664
   5311  27664				   -	       ifconst	EXTRADLMEMORY
   5312  27664				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5313  27664					       endif
   5314  27664
   5315  27664
   5316  27664				    DLPOINTL
   5317  27664				    DLINDEX    SET	0
   5318  27664					       REPEAT	WZONECOUNT
   5319  27664				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27664				   -	       ifconst	EXTRADLMEMORY
   5321  27664				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27664				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27664				   -	       else
   5324  27664				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27664				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27664				   -	       endif
   5327  27664				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27664					       endif		; EXTRADLMEMORY
   5329  27664			00		       .byte.b	<TMPMEMADDRESS
   5330  27664				    DLINDEX    SET	DLINDEX + 1
   5318  27664					       REPEND
   5319  27664				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27665				   -	       ifconst	EXTRADLMEMORY
   5321  27665				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27665				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27665				   -	       else
   5324  27665				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27665				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27665				   -	       endif
   5327  27665				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27665					       endif		; EXTRADLMEMORY
   5329  27665			55		       .byte.b	<TMPMEMADDRESS
   5330  27665				    DLINDEX    SET	DLINDEX + 1
   5318  27665					       REPEND
   5319  27665				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27666				   -	       ifconst	EXTRADLMEMORY
   5321  27666				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27666				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27666				   -	       else
   5324  27666				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27666				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27666				   -	       endif
   5327  27666				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27666					       endif		; EXTRADLMEMORY
   5329  27666			aa		       .byte.b	<TMPMEMADDRESS
   5330  27666				    DLINDEX    SET	DLINDEX + 1
   5318  27666					       REPEND
   5319  27666				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27667				   -	       ifconst	EXTRADLMEMORY
   5321  27667				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27667				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27667				   -	       else
   5324  27667				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27667				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27667				   -	       endif
   5327  27667				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27667					       endif		; EXTRADLMEMORY
   5329  27667			00		       .byte.b	<TMPMEMADDRESS
   5330  27667				    DLINDEX    SET	DLINDEX + 1
   5318  27667					       REPEND
   5319  27667				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27668				   -	       ifconst	EXTRADLMEMORY
   5321  27668				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27668				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27668				   -	       else
   5324  27668				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27668				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27668				   -	       endif
   5327  27668				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27668					       endif		; EXTRADLMEMORY
   5329  27668			55		       .byte.b	<TMPMEMADDRESS
   5330  27668				    DLINDEX    SET	DLINDEX + 1
   5318  27668					       REPEND
   5319  27668				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  27669				   -	       ifconst	EXTRADLMEMORY
   5321  27669				   -	       if	TMPMEMADDRESS > $1FFF
   5322  27669				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  27669				   -	       else
   5324  27669				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  27669				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  27669				   -	       endif
   5327  27669				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  27669					       endif		; EXTRADLMEMORY
   5329  27669			aa		       .byte.b	<TMPMEMADDRESS
   5330  27669				    DLINDEX    SET	DLINDEX + 1
   5318  27669					       REPEND
   5319  27669				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766a				   -	       ifconst	EXTRADLMEMORY
   5321  2766a				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766a				   -	       else
   5324  2766a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766a				   -	       endif
   5327  2766a				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766a					       endif		; EXTRADLMEMORY
   5329  2766a			00		       .byte.b	<TMPMEMADDRESS
   5330  2766a				    DLINDEX    SET	DLINDEX + 1
   5318  2766a					       REPEND
   5319  2766a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766b				   -	       ifconst	EXTRADLMEMORY
   5321  2766b				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766b				   -	       else
   5324  2766b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766b				   -	       endif
   5327  2766b				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766b					       endif		; EXTRADLMEMORY
   5329  2766b			55		       .byte.b	<TMPMEMADDRESS
   5330  2766b				    DLINDEX    SET	DLINDEX + 1
   5318  2766b					       REPEND
   5319  2766b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766c				   -	       ifconst	EXTRADLMEMORY
   5321  2766c				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766c				   -	       else
   5324  2766c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766c				   -	       endif
   5327  2766c				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766c					       endif		; EXTRADLMEMORY
   5329  2766c			aa		       .byte.b	<TMPMEMADDRESS
   5330  2766c				    DLINDEX    SET	DLINDEX + 1
   5318  2766c					       REPEND
   5319  2766c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766d				   -	       ifconst	EXTRADLMEMORY
   5321  2766d				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766d				   -	       else
   5324  2766d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766d				   -	       endif
   5327  2766d				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766d					       endif		; EXTRADLMEMORY
   5329  2766d			00		       .byte.b	<TMPMEMADDRESS
   5330  2766d				    DLINDEX    SET	DLINDEX + 1
   5318  2766d					       REPEND
   5319  2766d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766e				   -	       ifconst	EXTRADLMEMORY
   5321  2766e				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766e				   -	       else
   5324  2766e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766e				   -	       endif
   5327  2766e				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766e					       endif		; EXTRADLMEMORY
   5329  2766e			55		       .byte.b	<TMPMEMADDRESS
   5330  2766e				    DLINDEX    SET	DLINDEX + 1
   5318  2766e					       REPEND
   5319  2766e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5320  2766f				   -	       ifconst	EXTRADLMEMORY
   5321  2766f				   -	       if	TMPMEMADDRESS > $1FFF
   5322  2766f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5323  2766f				   -	       else
   5324  2766f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5325  2766f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5326  2766f				   -	       endif
   5327  2766f				   -	       endif		; TMPMEMADDRESS > $1FFF
   5328  2766f					       endif		; EXTRADLMEMORY
   5329  2766f			aa		       .byte.b	<TMPMEMADDRESS
   5330  2766f				    DLINDEX    SET	DLINDEX + 1
   5331  27670					       REPEND
   5332  27670
   5333  27670
   5334  27670				    DLINDEX    SET	0
   5335  27670					       REPEAT	WZONECOUNT
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5335  27670					       REPEND
   5336  27670				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5337  27670				   -	       ifconst	EXTRADLMEMORY
   5338  27670				   -	       if	TMPMEMADDRESS > $1FFF
   5339  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5340  27670				   -	       else
   5341  27670				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5342  27670				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5343  27670				   -	       endif
   5344  27670				   -	       endif		; TMPMEMADDRESS > $1FFF
   5345  27670					       endif		; EXTRADLMEMORY
   5346  27670
   5347  27670			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   5348  27670
   5349  27670				    DLINDEX    SET	DLINDEX + 1
   5350  27670					       REPEND
   5351  27670
   5352  27670
     $4000 to $7fff used as zone memory, allowing 136 display objects per zone.
   5353  27670					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5354  27670
   5355  27670				    DLHEIGHT
   5356  27670					       REPEAT	WZONECOUNT
   5357  27670			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27670					       REPEND
   5357  27671			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27671					       REPEND
   5357  27672			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27672					       REPEND
   5357  27673			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27673					       REPEND
   5357  27674			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27674					       REPEND
   5357  27675			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27675					       REPEND
   5357  27676			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27676					       REPEND
   5357  27677			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27677					       REPEND
   5357  27678			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27678					       REPEND
   5357  27679			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  27679					       REPEND
   5357  2767a			0f		       .byte.b	(WZONEHEIGHT-1)
   5356  2767a					       REPEND
   5357  2767b			0f		       .byte.b	(WZONEHEIGHT-1)
   5358  2767c					       REPEND
   5359  2767c
   5360  2767c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5361  2767c
   5362  2767c							; a simple guard, than ensures the 7800basic code hasn't
   5363  2767c							; spilled into the encryption area...
     2306 bytes left in the 7800basic reserved area.
   5364  2767c					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5365  2767c				   -	       if	(*>$FF7D)
   5366  2767c				   -	       echo
   5367  2767c				   -	       echo	"***************************"
   5368  2767c				   -	       echo	"*** Abort: ROM Overflow ***"
   5369  2767c				   -	       echo	"***************************"
   5370  2767c				   -	       ERR		; abort the assembly
   5371  2767c					       endif
   5372  2767c
   5373  2767c							; throw a compile
   5374  2767c				   -	       ifconst	RMT
   5375  2767c				   -	       ifnconst	pokeysupport
   5376  2767c				   -	       echo
   5377  2767c				   -	       echo	"************************************************************"
   5378  2767c				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   5379  2767c				   -	       echo	"************************************************************"
   5380  2767c				   -	       ERR		; abort
   5381  2767c				   -	       endif		; pokeysupport
   5382  2767c				   -	       ifnconst	pokeyaddress
   5383  2767c				   -	       echo
   5384  2767c				   -	       echo	"************************************************************"
   5385  2767c				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   5386  2767c				   -	       echo	"************************************************************"
   5387  2767c				   -	       ERR		; abort
   5388  2767c				   -	       endif		; pokeyaddress
   5389  2767c					       endif
   5390  2767c
   5391  2767c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5392  2767c
   5393  2767c				   -	       ifconst	DEV
   5394  2767c				   -	       ifnconst	ZONEHEIGHT
   5395  2767c				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5396  2767c				   -	       else
   5397  2767c				   -	       if	ZONEHEIGHT = 8
   5398  2767c				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5399  2767c				   -	       else
   5400  2767c				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5401  2767c				   -	       endif
   5402  2767c				   -	       endif
   5403  2767c					       endif
   5404  2767c
   5405  2767c				   -	       if	START_OF_ROM = .
   5406  2767c				   -	       .byte	0
   5407  2767c					       endif
   5408  2767c				    START_OF_ROM SET	0
   5409  2767c
   5410  2767c							; FF7E/FF7F contains the 7800basic crc checksum word
   5411  2767c
   5412  2767c							; FF80 - FFF7 contains the 7800 encryption key 
   5413  2767c
   5414  2767c				   -	       ifnconst	bankswitchmode
   5415  2767c				   -	       ORG	$FFF8
   5416  2767c					       else
   5417  2767c					       ifconst	ROM128K
   5418  27ff8					       ORG	$27FF8
   5419  27ff8					       RORG	$FFF8
   5420  27ff8					       endif
   5421  27ff8				   -	       ifconst	ROM144K
   5422  27ff8				   -	       ORG	$27FF8
   5423  27ff8				   -	       RORG	$FFF8
   5424  27ff8					       endif
   5425  27ff8				   -	       ifconst	ROM256K
   5426  27ff8				   -	       ORG	$47FF8
   5427  27ff8				   -	       RORG	$FFF8
   5428  27ff8					       endif
   5429  27ff8				   -	       ifconst	ROM272K
   5430  27ff8				   -	       ORG	$47FF8
   5431  27ff8				   -	       RORG	$FFF8
   5432  27ff8					       endif
   5433  27ff8				   -	       ifconst	ROM512K
   5434  27ff8				   -	       ORG	$87FF8
   5435  27ff8				   -	       RORG	$FFF8
   5436  27ff8					       endif
   5437  27ff8				   -	       ifconst	ROM528K
   5438  27ff8				   -	       ORG	$87FF8
   5439  27ff8				   -	       RORG	$FFF8
   5440  27ff8					       endif
   5441  27ff8					       endif
   5442  27ff8
   5443  27ff8
   5444  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   5445  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5446  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5447  27ffa
   5448  27ffa							;Vectors
   5449  27ffa			00 f0		       .word.w	NMI
   5450  27ffc			d5 f5		       .word.w	START
   5451  27ffe			67 f0		       .word.w	IRQ
   5452  28000
