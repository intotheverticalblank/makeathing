------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}
    273  28000 ????			    .Palette   SET	{2}	; constant
    274  28000 ????			    .SpriteX   SET	{3}	; variable
    275  28000 ????			    .SpriteY   SET	{4}	; variable
    276  28000 ????			    .ByteOffset SET	{5}	; variable 
    277  28000 ????
    278  28000 ????				       lda	.SpriteY
    279  28000 ????				       lsr
    280  28000 ????				       lsr
    281  28000 ????				       asr	#%11111110	; ensure carry is clear
    282  28000 ????				       if	WZONEHEIGHT = 16
    283  28000 ????				       asr	#%11111110	; ensure carry is clear
    284  28000 ????				       endif
    285  28000 ????
    286  28000 ????				       tax
    287  28000 ????
    288  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  28000 ????				       sta	dlpnt
    290  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  28000 ????				       sta	dlpnt+1
    292  28000 ????
    293  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  28000 ????
    295  28000 ????				       lda	.ByteOffset
    296  28000 ????				       if	{1}_width = 2
    297  28000 ????				       asl
    298  28000 ????				       endif
    299  28000 ????				       if	{1}_width = 3
    300  28000 ????				       asl
    301  28000 ????				       adc	.ByteOffset
    302  28000 ????				       endif
    303  28000 ????				       if	{1}_width = 4
    304  28000 ????				       asl
    305  28000 ????				       asl
    306  28000 ????				       endif
    307  28000 ????				       if	{1}_width = 5
    308  28000 ????				       asl
    309  28000 ????				       asl
    310  28000 ????				       adc	.ByteOffset
    311  28000 ????				       endif
    312  28000 ????				       if	{1}_width = 6
    313  28000 ????				       asl
    314  28000 ????				       adc	.ByteOffset
    315  28000 ????				       asl
    316  28000 ????				       endif
    317  28000 ????				       if	{1}_width = 7
    318  28000 ????				       asl
    319  28000 ????				       adc	.ByteOffset
    320  28000 ????				       asl
    321  28000 ????				       adc	.ByteOffset
    322  28000 ????				       endif
    323  28000 ????				       if	{1}_width = 8
    324  28000 ????				       asl
    325  28000 ????				       asl
    326  28000 ????				       asl
    327  28000 ????				       endif
    328  28000 ????				       if	{1}_width = 9
    329  28000 ????				       asl
    330  28000 ????				       asl
    331  28000 ????				       asl
    332  28000 ????				       adc	.ByteOffset
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 10
    335  28000 ????				       asl
    336  28000 ????				       asl
    337  28000 ????				       adc	.ByteOffset
    338  28000 ????				       asl
    339  28000 ????				       endif
    340  28000 ????				       if	{1}_width = 11
    341  28000 ????				       asl
    342  28000 ????				       asl
    343  28000 ????				       adc	.ByteOffset
    344  28000 ????				       asl
    345  28000 ????				       adc	.ByteOffset
    346  28000 ????				       endif
    347  28000 ????				       if	{1}_width = 12
    348  28000 ????				       asl
    349  28000 ????				       adc	.ByteOffset
    350  28000 ????				       asl
    351  28000 ????				       asl
    352  28000 ????				       endif
    353  28000 ????				       if	{1}_width = 13
    354  28000 ????				       asl
    355  28000 ????				       adc	.ByteOffset
    356  28000 ????				       asl
    357  28000 ????				       asl
    358  28000 ????				       adc	.ByteOffset
    359  28000 ????				       endif
    360  28000 ????				       if	{1}_width = 14
    361  28000 ????				       asl
    362  28000 ????				       adc	.ByteOffset
    363  28000 ????				       asl
    364  28000 ????				       adc	.ByteOffset
    365  28000 ????				       asl
    366  28000 ????				       endif
    367  28000 ????
    368  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  28000 ????
    371  28000 ????				       iny
    372  28000 ????
    373  28000 ????				       lda	#({1}_mode | %01000000)
    374  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  28000 ????
    376  28000 ????				       iny
    377  28000 ????
    378  28000 ????				       lda	.SpriteY
    379  28000 ????				       and	#(WZONEHEIGHT - 1)
    380  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  28000 ????				       ora	#>.GFXLabel
    382  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  28000 ????
    384  28000 ????				       iny
    385  28000 ????
    386  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  28000 ????
    389  28000 ????				       iny
    390  28000 ????
    391  28000 ????				       lda	.SpriteX
    392  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  28000 ????
    394  28000 ????				       iny
    395  28000 ????				       sty	dlend,x
    396  28000 ????
    397  28000 ????				       ifconst	ALWAYSTERMINATE
    398  28000 ????				       iny
    399  28000 ????				       lda	#0
    400  28000 ????				       sta	(dlpnt),y
    401  28000 ????				       endif
    402  28000 ????
    403  28000 ????				       bcc	.PLOTSPRITEend
    404  28000 ????
    405  28000 ????				       inx		; next zone
    406  28000 ????
    407  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  28000 ????				       sta	dlpnt
    409  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  28000 ????				       sta	dlpnt+1
    411  28000 ????
    412  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  28000 ????
    414  28000 ????				       lda	.ByteOffset
    415  28000 ????				       if	{1}_width = 1
    416  28000 ????				       clc
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 2
    419  28000 ????				       asl		; carry clear
    420  28000 ????				       endif
    421  28000 ????				       if	{1}_width = 3
    422  28000 ????				       asl		; carry clear
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       if	{1}_width = 4
    426  28000 ????				       asl		; carry clear
    427  28000 ????				       asl
    428  28000 ????				       endif
    429  28000 ????				       if	{1}_width = 5
    430  28000 ????				       asl		; carry clear
    431  28000 ????				       asl
    432  28000 ????				       adc	.ByteOffset
    433  28000 ????				       endif
    434  28000 ????				       if	{1}_width = 6
    435  28000 ????				       asl		; carry clear
    436  28000 ????				       adc	.ByteOffset
    437  28000 ????				       asl
    438  28000 ????				       endif
    439  28000 ????				       if	{1}_width = 7
    440  28000 ????				       asl		; carry clear
    441  28000 ????				       adc	.ByteOffset
    442  28000 ????				       asl
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 8
    445  28000 ????				       asl		; carry clear
    446  28000 ????				       asl
    447  28000 ????				       asl
    448  28000 ????				       endif
    449  28000 ????				       if	{1}_width = 9
    450  28000 ????				       asl		; carry clear
    451  28000 ????				       asl
    452  28000 ????				       asl
    453  28000 ????				       adc	.ByteOffset
    454  28000 ????				       endif
    455  28000 ????				       if	{1}_width = 10
    456  28000 ????				       asl		; carry clear
    457  28000 ????				       asl
    458  28000 ????				       adc	.ByteOffset
    459  28000 ????				       asl
    460  28000 ????				       endif
    461  28000 ????				       if	{1}_width = 11
    462  28000 ????				       asl		; carry clear
    463  28000 ????				       asl
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       asl
    466  28000 ????				       adc	.ByteOffset
    467  28000 ????				       endif
    468  28000 ????				       if	{1}_width = 12
    469  28000 ????				       asl		; carry clear
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       asl
    472  28000 ????				       asl
    473  28000 ????				       endif
    474  28000 ????				       if	{1}_width = 13
    475  28000 ????				       asl		; carry clear
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       asl
    478  28000 ????				       asl
    479  28000 ????				       adc	.ByteOffset
    480  28000 ????				       endif
    481  28000 ????				       if	{1}_width = 14
    482  28000 ????				       asl		; carry clear
    483  28000 ????				       adc	.ByteOffset
    484  28000 ????				       asl
    485  28000 ????				       adc	.ByteOffset
    486  28000 ????				       asl
    487  28000 ????				       endif
    488  28000 ????
    489  28000 ????				       adc	#<.GFXLabel
    490  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  28000 ????
    492  28000 ????				       iny
    493  28000 ????
    494  28000 ????				       lda	#({1}_mode | %01000000)
    495  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  28000 ????
    497  28000 ????				       iny
    498  28000 ????
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       and	#(WZONEHEIGHT - 1)
    501  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  28000 ????
    504  28000 ????				       iny
    505  28000 ????
    506  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  28000 ????
    509  28000 ????				       iny
    510  28000 ????
    511  28000 ????				       lda	.SpriteX
    512  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  28000 ????
    514  28000 ????				       iny
    515  28000 ????				       sty	dlend,x
    516  28000 ????
    517  28000 ????				       ifconst	ALWAYSTERMINATE
    518  28000 ????				       iny
    519  28000 ????				       lda	#0
    520  28000 ????				       sta	(dlpnt),y
    521  28000 ????				       endif
    522  28000 ????
    523  28000 ????			    .PLOTSPRITEend
    524  28000 ????				       ENDM
    525  28000 ????
    526  28000 ????				       MAC	sizeof
    527  28000 ????
    528  28000 ????						; echo's the size difference between the current address and the
    529  28000 ????						; a label that was passed as an argument. This is a quick way to
    530  28000 ????						; determine the size of a structure.
    531  28000 ????
    532  28000 ????			    .NAME      SETSTR	{1}
    533  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  28000 ????				       ENDM
    535  28000 ????
    536  28000 ????						;
    537  28000 ????						; speakjet.inc
    538  28000 ????						;
    539  28000 ????						;
    540  28000 ????						; AtariVox Speech Synth Driver
    541  28000 ????						;
    542  28000 ????						; By Alex Herbert, 2004
    543  28000 ????						;
    544  28000 ????
    545  28000 ????
    546  28000 ????
    547  28000 ????
    548  28000 ????						; Constants
    549  28000 ????
    550  28000 ????
    551  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  28000 ????
    554  28000 ????
    555  28000 ????
    556  28000 ????						; Macros
    557  28000 ????
    558  28000 ????				       mac	spkout
    559  28000 ????
    560  28000 ????						; check buffer-full status
    561  28000 ????				       lda	SWCHA
    562  28000 ????				       and	#SERIAL_RDYMASK
    563  28000 ????				       beq	.speech_done
    564  28000 ????
    565  28000 ????						; get next speech byte
    566  28000 ????				       ldy	#$00
    567  28000 ????				       lda	(speech_addr),y
    568  28000 ????
    569  28000 ????						; invert data and check for end of string
    570  28000 ????				       eor	#$ff
    571  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  28000 ????				       beq	.speech_done
    573  28000 ????				       sta	{1}
    574  28000 ????
    575  28000 ????						; increment speech pointer
    576  28000 ????				       inc	speech_addr
    577  28000 ????				       bne	.incaddr_skip
    578  28000 ????				       inc	speech_addr+1
    579  28000 ????			    .incaddr_skip
    580  28000 ????
    581  28000 ????						; output byte as serial data
    582  28000 ????
    583  28000 ????				       sec		; start bit
    584  28000 ????			    .byteout_loop
    585  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  28000 ????				       lda	SWACNT	; 4
    587  28000 ????				       and	#$fe	; 2 6
    588  28000 ????				       adc	#$00	; 2 8
    589  28000 ????				       sta	SWACNT	; 4 12
    590  28000 ????
    591  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  28000 ????				       cpy	#$09	; 2 14
    593  28000 ????				       beq	.speech_done	; 2 16
    594  28000 ????				       iny		; 2 18
    595  28000 ????
    596  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  28000 ????						; to match the original baud rate...
    598  28000 ????						;ldx	  #$07 ; 2600
    599  28000 ????				       ldx	#$0D
    600  28000 ????
    601  28000 ????			    .delay_loop
    602  28000 ????				       dex		; 
    603  28000 ????				       bne	.delay_loop	; 36 54
    604  28000 ????
    605  28000 ????						; shift next data bit into carry
    606  28000 ????				       lsr	{1}	; 5 59
    607  28000 ????
    608  28000 ????						; and loop (branch always taken)
    609  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  28000 ????
    611  28000 ????			    .speech_done
    612  28000 ????
    613  28000 ????				       endm
    614  28000 ????
    615  28000 ????
    616  28000 ????				       mac	speak
    617  28000 ????
    618  28000 ????				       lda	#<{1}
    619  28000 ????				       sta	speech_addr
    620  28000 ????				       lda	#>{1}
    621  28000 ????				       sta	speech_addr+1
    622  28000 ????
    623  28000 ????				       endm
    624  28000 ????
    625  28000 ????
    626  28000 ????
    627  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  28000 ????
    629  28000 ????				       processor	6502
    630  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????
    123  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    player4_mode =	$00
      4  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
      5  28000 ????		00 04	    player4_width =	$04
      6  28000 ????		00 00	    player3_mode =	$00
      7  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
      8  28000 ????		00 04	    player3_width =	$04
      9  28000 ????		00 00	    player2_mode =	$00
     10  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     11  28000 ????		00 04	    player2_width =	$04
     12  28000 ????		00 00	    player1_mode =	$00
     13  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     14  28000 ????		00 04	    player1_width =	$04
     15  28000 ????		00 00	    font_mode  =	$00
     16  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     17  28000 ????		00 35	    font_width =	$35
     18  28000 ????		01 48	    playerAnimWait =	var8
     19  28000 ????
     20  28000 ????		01 47	    playerAnimFrame =	var7
     21  28000 ????
     22  28000 ????		01 46	    playerY    =	var6
     23  28000 ????
     24  28000 ????		01 45	    playerX    =	var5
     25  28000 ????
     26  28000 ????		01 44	    score      =	var4
     27  28000 ????
     28  28000 ????		01 43	    lives      =	var3
     29  28000 ????
     30  28000 ????		01 42	    wait       =	var2
     31  28000 ????
     32  28000 ????		01 41	    bgColor    =	var1
     33  28000 ????
     34  28000 ????		00 00	    player4_color3 =	0
     35  28000 ????		00 44	    player4_color2 =	$44
     36  28000 ????		00 0d	    player4_color1 =	$0d
     37  28000 ????		00 00	    player4_color0 =	$00
     38  28000 ????		00 07	    player3_color3 =	$07
     39  28000 ????		00 44	    player3_color2 =	$44
     40  28000 ????		00 0d	    player3_color1 =	$0d
     41  28000 ????		00 00	    player3_color0 =	$00
     42  28000 ????		00 07	    player2_color3 =	$07
     43  28000 ????		00 44	    player2_color2 =	$44
     44  28000 ????		00 0d	    player2_color1 =	$0d
     45  28000 ????		00 00	    player2_color0 =	$00
     46  28000 ????		00 07	    player1_color3 =	$07
     47  28000 ????		00 44	    player1_color2 =	$44
     48  28000 ????		00 0d	    player1_color1 =	$0d
     49  28000 ????		00 00	    player1_color0 =	$00
     50  28000 ????		00 0f	    font_color1 =	$0f
     51  28000 ????		00 00	    font_color0 =	$00
     52  28000 ????		00 01	    DOUBLEBUFFER =	1
     53  28000 ????		00 01	    SGRAM      =	1
     54  28000 ????		00 08	    bankswitchmode =	8
     55  28000 ????		00 01	    ROM128K    =	1
     56  28000 ????		00 01	    plotvalueonscreen =	1
     57  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    ssCTRL     =	$2131
     63  28000 ????		21 32	    ssCHARBASE =	$2132
     64  28000 ????		21 33	    hsdisplaymode =	$2133
     65  28000 ????		21 34	    gamedifficulty =	$2134
     66  28000 ????		21 35	    hsinitialpos =	$2135
     67  28000 ????		21 36	    hsinitialhold =	$2136
     68  28000 ????		21 37	    hscursorx  =	$2137
     69  28000 ????		21 38	    hsjoydebounce =	$2138
     70  28000 ????		21 39	    hsswcha    =	$2139
     71  28000 ????		21 3a	    hsinpt1    =	$213A
     72  28000 ????		21 3b	    hscolorchaseindex =	$213B
     73  28000 ????		21 3c	    visibleDLLstart =	$213C
     74  28000 ????		21 3d	    overscanDLLstart =	$213D
     75  28000 ????		21 3e	    frameslost =	$213E
     76  28000 ????		21 3f	    hsreturn   =	$213F
     77  28000 ????
     78  28000 ????
     79  28000 ????		00 40	    rand       =	$40
     80  28000 ????		00 41	    rand16     =	$41
     81  28000 ????		00 42	    temp1      =	$42
     82  28000 ????		00 43	    temp2      =	$43
     83  28000 ????		00 44	    temp3      =	$44
     84  28000 ????		00 45	    temp4      =	$45
     85  28000 ????		00 46	    temp5      =	$46
     86  28000 ????		00 47	    temp6      =	$47
     87  28000 ????		00 48	    temp7      =	$48
     88  28000 ????		00 49	    temp8      =	$49
     89  28000 ????		00 4a	    temp9      =	$4a
     90  28000 ????
     91  28000 ????		00 4b	    pokeybase  =	$4b
     92  28000 ????		00 4b	    pokeybaselo =	$4b
     93  28000 ????		00 4c	    pokeybasehi =	$4c
     94  28000 ????
     95  28000 ????		00 4d	    visibleover =	$4d
     96  28000 ????
     97  28000 ????		00 4e	    sfx1pointlo =	$4e
     98  28000 ????		00 4f	    sfx2pointlo =	$4f
     99  28000 ????		00 50	    sfx1pointhi =	$50
    100  28000 ????		00 51	    sfx2pointhi =	$51
    101  28000 ????
    102  28000 ????		00 52	    sfx1priority =	$52
    103  28000 ????		00 53	    sfx2priority =	$53
    104  28000 ????		00 54	    sfx1poffset =	$54
    105  28000 ????		00 55	    sfx2poffset =	$55
    106  28000 ????
    107  28000 ????		00 56	    sfx1frames =	$56
    108  28000 ????		00 57	    sfx2frames =	$57
    109  28000 ????		00 58	    sfx1tick   =	$58
    110  28000 ????		00 59	    sfx2tick   =	$59
    111  28000 ????
    112  28000 ????		00 5a	    tempmath   =	$5a
    113  28000 ????
    114  28000 ????		00 5b	    pokey1pointlo =	$5b
    115  28000 ????		00 5c	    pokey1pointhi =	$5c
    116  28000 ????		00 5d	    pokey2pointlo =	$5d
    117  28000 ????		00 5e	    pokey2pointhi =	$5e
    118  28000 ????		00 5f	    pokey3pointlo =	$5f
    119  28000 ????		00 60	    pokey3pointhi =	$60
    120  28000 ????		00 61	    pokey4pointlo =	$61
    121  28000 ????		00 62	    pokey4pointhi =	$62
    122  28000 ????
    123  28000 ????		00 63	    dlpnt      =	$63	; to $64
    124  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    125  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    126  28000 ????
    127  28000 ????		00 9f	    speech_addr =	$9f
    128  28000 ????		00 a0	    speech_addr_hi =	$a0
    129  28000 ????
    130  28000 ????		00 a1	    HSGameTableLo =	$a1
    131  28000 ????		00 a2	    HSGameTableHi =	$a2
    132  28000 ????		00 a3	    HSVoxHi    =	$a3
    133  28000 ????		00 a4	    HSVoxLo    =	$a4
    134  28000 ????
    135  28000 ????						;channel pointers
    136  28000 ????
    137  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    138  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    139  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    140  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    141  28000 ????
    142  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    143  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    144  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    145  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    146  28000 ????
    147  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    148  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    149  28000 ????		00 af	    songchannel3layer3lo =	$aF
    150  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    151  28000 ????
    152  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    153  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    154  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    155  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    156  28000 ????
    157  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    158  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    159  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    160  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    161  28000 ????
    162  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    163  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    164  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    165  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    166  28000 ????
    167  28000 ????		00 bd	    songdatalo =	$bd
    168  28000 ????		00 be	    songdatahi =	$be
    169  28000 ????
    170  28000 ????		00 bf	    inactivechannelcount =	$bf
    171  28000 ????
    172  28000 ????		00 c0	    songchannel1transpose =	$c0
    173  28000 ????		00 c1	    songchannel2transpose =	$c1
    174  28000 ????		00 c2	    songchannel3transpose =	$c2
    175  28000 ????		00 c3	    songchannel4transpose =	$c3
    176  28000 ????
    177  28000 ????		00 c4	    songstackindex =	$c4
    178  28000 ????
    179  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  28000 ????
    184  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  28000 ????
    189  28000 ????		00 cd	    sfx1notedata =	$cd
    190  28000 ????		00 ce	    sfx2notedata =	$ce
    191  28000 ????
    192  28000 ????		00 cf	    songloops  =	$cf
    193  28000 ????
    194  28000 ????		00 d0	    songpointerlo =	$D0
    195  28000 ????		00 d1	    songpointerhi =	$D1
    196  28000 ????
    197  28000 ????		00 d2	    voxlock    =	$D2
    198  28000 ????		00 d3	    voxqueuesize =	$D3
    199  28000 ????
    200  28000 ????		00 d4	    vblankroutines =	$D4
    201  28000 ????
    202  28000 ????		00 d5	    doublebufferstate =	$D5
    203  28000 ????		00 d6	    doublebufferdloffset =	$D6
    204  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  28000 ????
    206  28000 ????		00 d8	    inttemp1   =	$D8
    207  28000 ????		00 d9	    inttemp2   =	$D9
    208  28000 ????		00 da	    inttemp3   =	$DA
    209  28000 ????		00 db	    inttemp4   =	$DB
    210  28000 ????		00 dc	    inttemp5   =	$DC
    211  28000 ????		00 dd	    inttemp6   =	$DD
    212  28000 ????
    213  28000 ????		00 de	    sfxschedulelock =	$DE
    214  28000 ????		00 df	    sfxschedulemissed =	$DF
    215  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  28000 ????		00 e2	    sfxpitchoffset =	$E2
    218  28000 ????		00 e3	    sfxnoteindex =	$E3
    219  28000 ????
    220  28000 ????		00 e4	    CTLSWAs    =	$E4
    221  28000 ????		00 e5	    CTLSWBs    =	$E5
    222  28000 ????
    223  28000 ????		00 e6	    A	       =	$e6
    224  28000 ????		00 e6	    a	       =	$e6
    225  28000 ????		00 e7	    B	       =	$e7
    226  28000 ????		00 e7	    b	       =	$e7
    227  28000 ????		00 e8	    C	       =	$e8
    228  28000 ????		00 e8	    c	       =	$e8
    229  28000 ????		00 e9	    D	       =	$e9
    230  28000 ????		00 e9	    d	       =	$e9
    231  28000 ????		00 ea	    E	       =	$ea
    232  28000 ????		00 ea	    e	       =	$ea
    233  28000 ????		00 eb	    F	       =	$eb
    234  28000 ????		00 eb	    f	       =	$eb
    235  28000 ????		00 ec	    G	       =	$ec
    236  28000 ????		00 ec	    g	       =	$ec
    237  28000 ????		00 ed	    H	       =	$ed
    238  28000 ????		00 ed	    h	       =	$ed
    239  28000 ????		00 ee	    I	       =	$ee
    240  28000 ????		00 ee	    i	       =	$ee
    241  28000 ????		00 ef	    J	       =	$ef
    242  28000 ????		00 ef	    j	       =	$ef
    243  28000 ????		00 f0	    K	       =	$f0
    244  28000 ????		00 f0	    k	       =	$f0
    245  28000 ????		00 f1	    L	       =	$f1
    246  28000 ????		00 f1	    l	       =	$f1
    247  28000 ????		00 f2	    M	       =	$f2
    248  28000 ????		00 f2	    m	       =	$f2
    249  28000 ????		00 f3	    N	       =	$f3
    250  28000 ????		00 f3	    n	       =	$f3
    251  28000 ????		00 f4	    O	       =	$f4
    252  28000 ????		00 f4	    o	       =	$f4
    253  28000 ????		00 f5	    P	       =	$f5
    254  28000 ????		00 f5	    p	       =	$f5
    255  28000 ????		00 f6	    Q	       =	$f6
    256  28000 ????		00 f6	    q	       =	$f6
    257  28000 ????		00 f7	    R	       =	$f7
    258  28000 ????		00 f7	    r	       =	$f7
    259  28000 ????		00 f8	    S	       =	$f8
    260  28000 ????		00 f8	    s	       =	$f8
    261  28000 ????		00 f9	    T	       =	$f9
    262  28000 ????		00 f9	    t	       =	$f9
    263  28000 ????		00 fa	    U	       =	$fa
    264  28000 ????		00 fa	    u	       =	$fa
    265  28000 ????		00 fb	    V	       =	$fb
    266  28000 ????		00 fb	    v	       =	$fb
    267  28000 ????		00 fc	    W	       =	$fc
    268  28000 ????		00 fc	    w	       =	$fc
    269  28000 ????		00 fd	    X	       =	$fd
    270  28000 ????		00 fd	    x	       =	$fd
    271  28000 ????		00 fe	    Y	       =	$fe
    272  28000 ????		00 fe	    y	       =	$fe
    273  28000 ????		00 ff	    Z	       =	$ff
    274  28000 ????		00 ff	    z	       =	$ff
    275  28000 ????
    276  28000 ????						; var0-var99 variables use the top of the stack
    277  28000 ????		01 40	    var0       =	$140
    278  28000 ????		01 41	    var1       =	$141
    279  28000 ????		01 42	    var2       =	$142
    280  28000 ????		01 43	    var3       =	$143
    281  28000 ????		01 44	    var4       =	$144
    282  28000 ????		01 45	    var5       =	$145
    283  28000 ????		01 46	    var6       =	$146
    284  28000 ????		01 47	    var7       =	$147
    285  28000 ????		01 48	    var8       =	$148
    286  28000 ????		01 49	    var9       =	$149
    287  28000 ????		01 4a	    var10      =	$14a
    288  28000 ????		01 4b	    var11      =	$14b
    289  28000 ????		01 4c	    var12      =	$14c
    290  28000 ????		01 4d	    var13      =	$14d
    291  28000 ????		01 4e	    var14      =	$14e
    292  28000 ????		01 4f	    var15      =	$14f
    293  28000 ????		01 50	    var16      =	$150
    294  28000 ????		01 51	    var17      =	$151
    295  28000 ????		01 52	    var18      =	$152
    296  28000 ????		01 53	    var19      =	$153
    297  28000 ????		01 54	    var20      =	$154
    298  28000 ????		01 55	    var21      =	$155
    299  28000 ????		01 56	    var22      =	$156
    300  28000 ????		01 57	    var23      =	$157
    301  28000 ????		01 58	    var24      =	$158
    302  28000 ????		01 59	    var25      =	$159
    303  28000 ????		01 5a	    var26      =	$15a
    304  28000 ????		01 5b	    var27      =	$15b
    305  28000 ????		01 5c	    var28      =	$15c
    306  28000 ????		01 5d	    var29      =	$15d
    307  28000 ????		01 5e	    var30      =	$15e
    308  28000 ????		01 5f	    var31      =	$15f
    309  28000 ????		01 60	    var32      =	$160
    310  28000 ????		01 61	    var33      =	$161
    311  28000 ????		01 62	    var34      =	$162
    312  28000 ????		01 63	    var35      =	$163
    313  28000 ????		01 64	    var36      =	$164
    314  28000 ????		01 65	    var37      =	$165
    315  28000 ????		01 66	    var38      =	$166
    316  28000 ????		01 67	    var39      =	$167
    317  28000 ????		01 68	    var40      =	$168
    318  28000 ????		01 69	    var41      =	$169
    319  28000 ????		01 6a	    var42      =	$16a
    320  28000 ????		01 6b	    var43      =	$16b
    321  28000 ????		01 6c	    var44      =	$16c
    322  28000 ????		01 6d	    var45      =	$16d
    323  28000 ????		01 6e	    var46      =	$16e
    324  28000 ????		01 6f	    var47      =	$16f
    325  28000 ????		01 70	    var48      =	$170
    326  28000 ????		01 71	    var49      =	$171
    327  28000 ????		01 72	    var50      =	$172
    328  28000 ????		01 73	    var51      =	$173
    329  28000 ????		01 74	    var52      =	$174
    330  28000 ????		01 75	    var53      =	$175
    331  28000 ????		01 76	    var54      =	$176
    332  28000 ????		01 77	    var55      =	$177
    333  28000 ????		01 78	    var56      =	$178
    334  28000 ????		01 79	    var57      =	$179
    335  28000 ????		01 7a	    var58      =	$17a
    336  28000 ????		01 7b	    var59      =	$17b
    337  28000 ????		01 7c	    var60      =	$17c
    338  28000 ????		01 7d	    var61      =	$17d
    339  28000 ????		01 7e	    var62      =	$17e
    340  28000 ????		01 7f	    var63      =	$17f
    341  28000 ????		01 80	    var64      =	$180
    342  28000 ????		01 81	    var65      =	$181
    343  28000 ????		01 82	    var66      =	$182
    344  28000 ????		01 83	    var67      =	$183
    345  28000 ????		01 84	    var68      =	$184
    346  28000 ????		01 85	    var69      =	$185
    347  28000 ????		01 86	    var70      =	$186
    348  28000 ????		01 87	    var71      =	$187
    349  28000 ????		01 88	    var72      =	$188
    350  28000 ????		01 89	    var73      =	$189
    351  28000 ????		01 8a	    var74      =	$18a
    352  28000 ????		01 8b	    var75      =	$18b
    353  28000 ????		01 8c	    var76      =	$18c
    354  28000 ????		01 8d	    var77      =	$18d
    355  28000 ????		01 8e	    var78      =	$18e
    356  28000 ????		01 8f	    var79      =	$18f
    357  28000 ????		01 90	    var80      =	$190
    358  28000 ????		01 91	    var81      =	$191
    359  28000 ????		01 92	    var82      =	$192
    360  28000 ????		01 93	    var83      =	$193
    361  28000 ????		01 94	    var84      =	$194
    362  28000 ????		01 95	    var85      =	$195
    363  28000 ????		01 96	    var86      =	$196
    364  28000 ????		01 97	    var87      =	$197
    365  28000 ????		01 98	    var88      =	$198
    366  28000 ????		01 99	    var89      =	$199
    367  28000 ????		01 9a	    var90      =	$19a
    368  28000 ????		01 9b	    var91      =	$19b
    369  28000 ????		01 9c	    var92      =	$19c
    370  28000 ????		01 9d	    var93      =	$19d
    371  28000 ????		01 9e	    var94      =	$19e
    372  28000 ????		01 9f	    var95      =	$19f
    373  28000 ????		01 a0	    var96      =	$1a0
    374  28000 ????		01 a1	    var97      =	$1a1
    375  28000 ????		01 a2	    var98      =	$1a2
    376  28000 ????		01 a3	    var99      =	$1a3
    377  28000 ????
    378 U01c4 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3					      ifconst	DOUBLEBUFFER
    395 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    396 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    397 U01b5					      endif
    398 U01b5
    399 U01b5		       00	   pausedisable DS	1	; $1B5
    400 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b7
    402 U01b7				  -	      ifconst	AVOXVOICE
    403 U01b7				  -avoxenable DS	1	; $1B7
    404 U01b7				  -tempavox   DS	1	; $1B8
    405 U01b7					      endif
    406 U01b7
    407 U01b7				  -	      ifconst	MUSICTRACKER
    408 U01b7				  -songtempo  DS	1	; $1B9
    409 U01b7				  -songtick   DS	1	; $1BA
    410 U01b7				  -
    411 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b7				  -
    416 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b7				  -
    421 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b7				  -
    426 U01b7				  -songchannel1busywait DS	1	; $1C7
    427 U01b7				  -songchannel2busywait DS	1	; $1C8
    428 U01b7				  -songchannel3busywait DS	1	; $1C9
    429 U01b7				  -songchannel4busywait DS	1	; $1CA
    430 U01b7				  -
    431 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b7					      endif
    436 U01b7
    437 U01b7		       00	   palframes  DS	1	; $1CF
    438 U01b8		       00	   palfastframe DS	1	; $1D0
    439 U01b9
    440 U01b9				  -	      ifconst	MOUSESUPPORT
    441 U01b9				  -port0resolution DS	1	; $1D1
    442 U01b9				  -port1resolution DS	1	; $1D2
    443 U01b9					      else
    444 U01b9				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b9				  -port0resolution DS	1	; $1D1
    446 U01b9				  -port1resolution DS	1	; $1D2
    447 U01b9					      endif
    448 U01b9					      endif
    449 U01b9
    450 U01b9		       00	   port0control DS	1	; $1D3
    451 U01ba		       00	   port1control DS	1	; $1D4
    452 U01bb
    453 U01bb							; port#control values...
    454 U01bb							;	1 = proline
    455 U01bb							;	2 = lightgun
    456 U01bb							;	3 = paddle
    457 U01bb							;	4 = trakball
    458 U01bb							;	5 = vcs joystick
    459 U01bb							;	6 = driving
    460 U01bb							;	7 = keypad
    461 U01bb							;	8 = st mouse/cx80
    462 U01bb							;	9 = amiga mouse
    463 U01bb							;     10 = atarivox
    464 U01bb
    465 U01bb							; controller 0 data...
    466 U01bb		       00	   paddleposition0 DS	1	; $1D5
    467 U01bb		       01 bb	   keypadmatrix0a =	paddleposition0
    468 U01bb		       01 bb	   drivingposition0 =	paddleposition0
    469 U01bb		       01 bb	   trakballx0 =	paddleposition0
    470 U01bb		       01 bb	   mousex0    =	paddleposition0
    471 U01bb		       01 bb	   lighttgunx0 =	paddleposition0
    472 U01bb		       01 bb	   snes2atari0lo =	paddleposition0
    473 U01bc
    474 U01bc							; controller 1 data...
    475 U01bc		       00	   paddleposition2 DS	1	; $1D6
    476 U01bc		       01 bc	   keypadmatrix1a =	paddleposition2
    477 U01bc		       01 bc	   drivingposition1 =	paddleposition2
    478 U01bc		       01 bc	   trakballx1 =	paddleposition2
    479 U01bc		       01 bc	   mousex1    =	paddleposition2
    480 U01bc		       01 bc	   lightgunx1 =	paddleposition2
    481 U01bc		       01 bc	   snes2atari1lo =	paddleposition2
    482 U01bd
    483 U01bd							; controller 0 altdata...
    484 U01bd		       00	   paddleposition1 DS	1	; $1D7
    485 U01bd		       01 bd	   keypadmatrix0b =	paddleposition1
    486 U01bd		       01 bd	   trakbally0 =	paddleposition1
    487 U01bd		       01 bd	   mousey0    =	paddleposition1
    488 U01bd		       01 bd	   lightguny0 =	paddleposition1
    489 U01bd		       01 bd	   snes2atari0hi =	paddleposition1
    490 U01be
    491 U01be							; controller 1 altdata...
    492 U01be		       00	   paddleposition3 DS	1	; $1D8
    493 U01be		       01 be	   keypadmatrix1b =	paddleposition3
    494 U01be		       01 be	   trakbally1 =	paddleposition3
    495 U01be		       01 be	   mousey1    =	paddleposition3
    496 U01be		       01 be	   lightguny1 =	paddleposition3
    497 U01be		       01 be	   snes2atari1hi =	paddleposition3
    498 U01bf
    499 U01bf							; controller state save. for trakball state+dir codes, rotary position codes
    500 U01bf		       00	   controller0statesave DS	1	; $1D9
    501 U01bf		       01 bf	   paddleprevious0 =	controller0statesave
    502 U01bf		       01 bf	   mousecodex0 =	controller0statesave
    503 U01bf		       01 bf	   trakballcodex0 =	controller0statesave
    504 U01bf		       01 bf	   keypadmatrix0c =	controller0statesave
    505 U01bf		       01 bf	   snesdetected0 =	controller0statesave
    506 U01c0
    507 U01c0		       00	   controller1statesave DS	1	; $1DA
    508 U01c0		       01 c0	   paddleprevious2 =	controller1statesave
    509 U01c0		       01 c0	   mousecodex1 =	controller1statesave
    510 U01c0		       01 c0	   trakballcodex1 =	controller1statesave
    511 U01c0		       01 c0	   keypadmatrix1c =	controller1statesave
    512 U01c0		       01 c0	   snesdetected1 =	controller1statesave
    513 U01c1
    514 U01c1		       00	   paddleprevious1 DS	1	; $1DB
    515 U01c1		       01 c1	   keypadmatrix0d =	paddleprevious1
    516 U01c1		       01 c1	   mousecodey0 =	paddleprevious1
    517 U01c1		       01 c1	   trakballcodey0 =	paddleprevious1
    518 U01c2
    519 U01c2		       00	   paddleprevious3 DS	1	; $1DC
    520 U01c2		       01 c2	   keypadmatrix1d =	paddleprevious3
    521 U01c2		       01 c2	   mousecodey1 =	paddleprevious3
    522 U01c2		       01 c2	   trakballcodey1 =	paddleprevious3
    523 U01c3
    524 U01c3				  -	      ifconst	pokeysupport
    525 U01c3				  -pokey1frames DS	1	; $1DD
    526 U01c3				  -pokey1tick DS	1	; $1DE
    527 U01c3				  -pokey2frames DS	1	; $1DF
    528 U01c3				  -pokey2tick DS	1	; $1E0
    529 U01c3				  -pokey3frames DS	1	; $1E1
    530 U01c3				  -pokey3tick DS	1	; $1E2
    531 U01c3				  -pokey4frames DS	1	; $1E3
    532 U01c3				  -pokey4tick DS	1	; $1E4
    533 U01c3				  -pokey1priority DS	1	; $1E5
    534 U01c3				  -pokey1offset DS	1	; $1E6
    535 U01c3				  -pokey2priority DS	1	; $1E7
    536 U01c3				  -pokey2offset DS	1	; $1E8
    537 U01c3				  -pokey3priority DS	1	; $1E9
    538 U01c3				  -pokey3offset DS	1	; $1EA
    539 U01c3				  -pokey4priority DS	1	; $1EB
    540 U01c3				  -pokey4offset DS	1	; $1EC
    541 U01c3					      endif
    542 U01c3
    543 U01c3				  -	      ifconst	pokeykeysupport
    544 U01c3				  -pokeylastkeycode DS	1
    545 U01c3				  -pokeykeycode DS	1
    546 U01c3				  -pokeykeydebounce DS	1
    547 U01c3					      endif
    548 U01c3
    549 U01c3				  -	      ifconst	RMT
    550 U01c3				  -rasterpause DS	1
    551 U01c3					      endif		; RMT
    552 U01c3				  -	      ifconst	RMTVOLUME
    553 U01c3				  -rmtvolume  DS	1
    554 U01c3					      endif		; RMTVOLUME
    555 U01c3				  -	      ifconst	TIAVOLUME
    556 U01c3				  -tiavolume  DS	1
    557 U01c3					      endif		; TIAVOLUME
    558 U01c3
    559 U01c3				  -	      ifconst	FOURBITFADE
    560 U01c3				  -fourbittemp1 DS	1
    561 U01c3				  -fourbitfadevalue DS	1
    562 U01c3				  -fourbittemp1int DS	1
    563 U01c3				  -fourbitfadevalueint DS	1
    564 U01c3					      endif		; FOURBITFADE
    565 U01c3
    566 U01c3				  -	      ifconst	SNES2ATARISUPPORT
    567 U01c3				  -snesport   DS	1
    568 U01c3					      endif
    569 U01c3
    570 U01c3				  -	      ifconst	KEYPADSUPPORT
    571 U01c3				  -keypadcounter DS	1
    572 U01c3					      endif
    573 U01c3
    574 U01c3							; see if we need an interrupthold byte...
    575 U01c3				   INTERRUPTNEEDED SET	0
    576 U01c3				  -	      ifconst	.topscreenroutine
    577 U01c3				  -INTERRUPTNEEDED SET	1
    578 U01c3					      endif
    579 U01c3				  -	      ifconst	.bottomscreenroutine
    580 U01c3				  -INTERRUPTNEEDED SET	1
    581 U01c3					      endif
    582 U01c3				  -	      ifconst	.userinterrupt
    583 U01c3				  -INTERRUPTNEEDED SET	1
    584 U01c3					      endif
    585 U01c3				  -	      if	INTERRUPTNEEDED = 1
    586 U01c3				  -interrupthold DS	1	; $1ED
    587 U01c3					      endif
    588 U01c3
    589 U01c3					      ifnconst	CANARYOFF
    590 U01c3		       00	   canary     DS	1	; $1EF
    591 U01c4					      endif
    592 U01c4
    593 U01c4
    594 U01c4				  -	      ifnconst	bankswitchmode
    595 U01c4				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    596 U01c4					      else
   stack allowance: 19 nested subroutines.
    597 U01c4					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    598 U01c4					      endif
    599 U01c4					      ifnconst	CANARYOFF
   the canary is situated at: $1c3
    600 U01c4					      echo	"  the canary is situated at:",[canary]
    601 U01c4				  -	      else
    602 U01c4				  -	      echo	"  the canary is disabled."
    603 U01c4					      endif
    604 U01c4
    605 U01c4							; $1EE - $1FF reserved for stack
    606 U01c4
    607  28000 ????				       SEG	"GAME"
    608  28000 ????
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    player4_mode =	$00
      4  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
      5  28000 ????		00 04	    player4_width =	$04
      6  28000 ????		00 00	    player3_mode =	$00
      7  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
      8  28000 ????		00 04	    player3_width =	$04
      9  28000 ????		00 00	    player2_mode =	$00
     10  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     11  28000 ????		00 04	    player2_width =	$04
     12  28000 ????		00 00	    player1_mode =	$00
     13  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     14  28000 ????		00 04	    player1_width =	$04
     15  28000 ????		00 00	    font_mode  =	$00
     16  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     17  28000 ????		00 35	    font_width =	$35
     18  28000 ????		01 48	    playerAnimWait =	var8
     19  28000 ????
     20  28000 ????		01 47	    playerAnimFrame =	var7
     21  28000 ????
     22  28000 ????		01 46	    playerY    =	var6
     23  28000 ????
     24  28000 ????		01 45	    playerX    =	var5
     25  28000 ????
     26  28000 ????		01 44	    score      =	var4
     27  28000 ????
     28  28000 ????		01 43	    lives      =	var3
     29  28000 ????
     30  28000 ????		01 42	    wait       =	var2
     31  28000 ????
     32  28000 ????		01 41	    bgColor    =	var1
     33  28000 ????
     34  28000 ????		00 00	    player4_color3 =	0
     35  28000 ????		00 44	    player4_color2 =	$44
     36  28000 ????		00 0d	    player4_color1 =	$0d
     37  28000 ????		00 00	    player4_color0 =	$00
     38  28000 ????		00 07	    player3_color3 =	$07
     39  28000 ????		00 44	    player3_color2 =	$44
     40  28000 ????		00 0d	    player3_color1 =	$0d
     41  28000 ????		00 00	    player3_color0 =	$00
     42  28000 ????		00 07	    player2_color3 =	$07
     43  28000 ????		00 44	    player2_color2 =	$44
     44  28000 ????		00 0d	    player2_color1 =	$0d
     45  28000 ????		00 00	    player2_color0 =	$00
     46  28000 ????		00 07	    player1_color3 =	$07
     47  28000 ????		00 44	    player1_color2 =	$44
     48  28000 ????		00 0d	    player1_color1 =	$0d
     49  28000 ????		00 00	    player1_color0 =	$00
     50  28000 ????		00 0f	    font_color1 =	$0f
     51  28000 ????		00 00	    font_color0 =	$00
     52  28000 ????		00 01	    DOUBLEBUFFER =	1
     53  28000 ????		00 01	    SGRAM      =	1
     54  28000 ????		00 08	    bankswitchmode =	8
     55  28000 ????		00 01	    ROM128K    =	1
     56  28000 ????		00 01	    plotvalueonscreen =	1
     57  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
    633  28000 ????
    634  28000 ????						; BEADHEADER... disabled for now
    635  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    636  28000 ????						; For more BEAD executable info, check out the spec...
    637  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  28000 ????
    639  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  28000 ????
    642  28000 ????
    643  28000 ????		00 40	    BDHSC      =	%01000000
    644  28000 ????		00 20	    BDYM       =	%00100000
    645  28000 ????		00 10	    BDPOKEY    =	%00010000
    646  28000 ????		00 08	    BDROF      =	%00001000
    647  28000 ????		00 00	    BD16K      =	%00000000
    648  28000 ????		00 01	    BD32K      =	%00000001
    649  28000 ????		00 02	    BD48K      =	%00000010
    650  28000 ????		00 05	    BD1800     =	%00000101
    651  28000 ????		00 06	    BD4000     =	%00000110
    652  28000 ????
    653  28000 ????			   -	       ifconst	BEADHEADER
    654  28000 ????			   -BEADHARDWARE SET	0
    655  28000 ????			   -	       ifconst	ROM16K
    656  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  28000 ????			   -	       endif
    658  28000 ????			   -	       ifconst	ROM32K
    659  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  28000 ????			   -	       endif
    661  28000 ????			   -	       ifconst	ROM48K
    662  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  28000 ????			   -	       endif
    664  28000 ????			   -	       ifconst	pokeysupport
    665  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  28000 ????			   -	       endif
    667  28000 ????			   -	       ifconst	HSSUPPORT
    668  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  28000 ????			   -	       endif
    670  28000 ????				       endif
    671  28000 ????
    672  28000 ????						;start address of cart...
    673  28000 ????
    674  28000 ????			    BANK_WAS_SET SET	0
    675  28000 ????
    676  28000 ????			   -	       ifconst	ROM8K
    677  28000 ????			   -	       ORG	$E000,0
    678  28000 ????			   -BANK_WAS_SET SET	1
    679  28000 ????				       endif		; ROM8K
    680  28000 ????
    681  28000 ????			   -	       ifconst	ROM16K
    682  28000 ????			   -	       ORG	$C000,0
    683  28000 ????			   -BANK_WAS_SET SET	1
    684  28000 ????			   -	       ifconst	BEADHEADER
    685  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  28000 ????			   -	       CLC
    688  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  28000 ????			   -_SKIPDESCRIPTION
    691  28000 ????			   -	       endif		; GAMEDESCRIPTION
    692  28000 ????			   -	       jmp	($FFFC)
    693  28000 ????			   -	       endif		; BEADHEADER
    694  28000 ????				       endif		; ROM16K
    695  28000 ????
    696  28000 ????			   -	       ifconst	ROM32K
    697  28000 ????			   -	       ORG	$8000,0
    698  28000 ????			   -BANK_WAS_SET SET	1
    699  28000 ????			   -	       ifconst	BEADHEADER
    700  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    701  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    702  28000 ????			   -	       CLC
    703  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    704  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    705  28000 ????			   -_SKIPDESCRIPTION
    706  28000 ????			   -	       endif		; GAMEDESCRIPTION
    707  28000 ????			   -	       jmp	($FFFC)
    708  28000 ????			   -	       endif		; BEADHEADER
    709  28000 ????				       endif		; ROM32K
    710  28000 ????
    711  28000 ????			   -	       ifconst	ROM48K
    712  28000 ????			   -	       ORG	$4000,0
    713  28000 ????			   -BANK_WAS_SET SET	1
    714  28000 ????			   -	       ifconst	BEADHEADER
    715  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    716  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    717  28000 ????			   -	       CLC
    718  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    719  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    720  28000 ????			   -_SKIPDESCRIPTION
    721  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
    722  28000 ????			   -	       jmp	($FFFC)
    723  28000 ????			   -	       endif		; BEADHEADER
    724  28000 ????				       endif		; ROM48K
    725  28000 ????
    726  28000 ????			   -	       ifconst	ROM52K
    727  28000 ????			   -BANK_WAS_SET SET	1
    728  28000 ????			   -	       ORG	$3000,0
    729  28000 ????				       endif		; ROM52K
    730  28000 ????
    731  28000 ????				       ifconst	bankswitchmode
    732  28000 ????			   -	       ifconst	ROMAT4K
    733  28000 ????			   -BANK_WAS_SET SET	1
    734  28000 ????			   -	       ORG	$4000,0
    735  28000 ????			   -	       RORG	$4000
    736  28000 ????				       else		; ROMAT4K
    737  28000 ????			    BANK_WAS_SET SET	1
    738  8000					      ORG	$8000,0
    739  8000					      RORG	$8000
    740  8000					      endif
    741  8000					      endif
    742  8000
    743  8000				  -	      if	BANK_WAS_SET = 0
    744  8000				  -	      ORG	$8000,0	; default is 32K
    745  8000					      endif
    746  8000
    747  8000				   START_OF_ROM SET	.
    748  8000							;7800basic v0.24 Mar  2 2023 18:16:13
    749  8000				   SPACEOVERFLOW SET	0
    750  8000				   game
    751  8000				   .L00 		;;  set zoneheight 16
    752  8000
    753  8000				   .L01 		;;  displaymode 160A
    754  8000
    755  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    756  8002		       85 3c		      sta	CTRL
    757  8004
    758  8004		       8d 07 21 	      sta	sCTRL
    759  8007
    760  8007				   .L02 		;;  set plotvalueonscreen on
    761  8007
    762  8007				   .L03 		;;  set romsize 128kRAM
    763  8007
    764  8007				   .L04 		;;  set dlmemory $4000 $7FFF
    765  8007
    766  8007		       40 00	   DLMEMSTART =	$4000
    767  8007		       7f ff	   DLMEMEND   =	$7FFF
    768  8007				   .L05 		;;  doublebuffer on
    769  8007
    770  8007		       a9 01		      lda	#1
    771  8009		       85 d5		      sta	doublebufferstate
    772  800b				   .
    773  800b							;; 
    774  800b
    775  800b				   .L06 		;;  incgraphic font.png 160A 
    776  800b
    777  800b				   .L07 		;;  characterset font
    778  800b
    779  800b		       a9 a0		      lda	#>font
    780  800d		       8d 0b 21 	      sta	sCHARBASE
    781  8010
    782  8010		       85 34		      sta	CHARBASE
    783  8012		       a9 60		      lda	#(font_mode | %01100000)
    784  8014		       8d 06 21 	      sta	charactermode
    785  8017
    786  8017				   .L08 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    787  8017
    788  8017				   .
    789  8017							;; 
    790  8017
    791  8017				   .L09 		;;  rem sprites
    792  8017
    793  8017				   .L010		;;  incgraphic images/player1.png 160A 0 1 3 2
    794  8017
    795  8017				   .L011		;;  incgraphic images/player2.png 160A 0 1 3 2
    796  8017
    797  8017				   .L012		;;  incgraphic images/player3.png 160A 0 1 3 2
    798  8017
    799  8017				   .L013		;;  incgraphic images/player4.png 160A 0 1 3 2
    800  8017
    801  8017				   .
    802  8017							;; 
    803  8017
    804  8017				   .
    805  8017							;; 
    806  8017
    807  8017				   .L014		;;  BACKGRND = $00
    808  8017
    809  8017		       a9 00		      LDA	#$00
    810  8019		       85 20		      STA	BACKGRND
    811  801b				   .
    812  801b							;; 
    813  801b
    814  801b				   .L015		;;  rem pallette 0 text
    815  801b
    816  801b				   .L016		;;  P0C1 = $0F
    817  801b
    818  801b		       a9 0f		      LDA	#$0F
    819  801d		       85 21		      STA	P0C1
    820  801f				   .L017		;;  P0C2 = $0C
    821  801f
    822  801f		       a9 0c		      LDA	#$0C
    823  8021		       85 22		      STA	P0C2
    824  8023				   .L018		;;  P0C3 = $0A
    825  8023
    826  8023		       a9 0a		      LDA	#$0A
    827  8025		       85 23		      STA	P0C3
    828  8027				   .
    829  8027							;; 
    830  8027
    831  8027				   .L019		;;  rem pallette 1 player
    832  8027
    833  8027				   .L020		;;  P1C1  =  $0D
    834  8027
    835  8027		       a9 0d		      LDA	#$0D
    836  8029		       85 25		      STA	P1C1
    837  802b				   .L021		;;  P1C2  =  $08
    838  802b
    839  802b		       a9 08		      LDA	#$08
    840  802d		       85 26		      STA	P1C2
    841  802f				   .L022		;;  P1C3  =  $33
    842  802f
    843  802f		       a9 33		      LDA	#$33
    844  8031		       85 27		      STA	P1C3
    845  8033				   .
    846  8033							;; 
    847  8033
    848  8033				   .L023		;;  dim bgColor  =  var1
    849  8033
    850  8033				   .L024		;;  dim wait  =  var2
    851  8033
    852  8033				   .L025		;;  dim lives	=  var3
    853  8033
    854  8033				   .L026		;;  dim score	=  var4
    855  8033
    856  8033				   .L027		;;  dim playerX  = var5
    857  8033
    858  8033				   .L028		;;  dim playerY  =  var6
    859  8033
    860  8033				   .L029		;;  dim playerAnimFrame  =  var7
    861  8033
    862  8033				   .L030		;;  dim playerAnimWait  =  var8
    863  8033
    864  8033				   .
    865  8033							;; 
    866  8033
    867  8033				   .L031		;;  bgColor  =  $
    868  8033
    869  8033		       a9 00		      LDA	#$
    870  8035		       8d 41 01 	      STA	bgColor
    871  8038				   .L032		;;  wait  =  0
    872  8038
    873  8038		       a9 00		      LDA	#0
    874  803a		       8d 42 01 	      STA	wait
    875  803d				   .L033		;;  lives  =  0
    876  803d
    877  803d		       a9 00		      LDA	#0
    878  803f		       8d 43 01 	      STA	lives
    879  8042				   .L034		;;  score  =  0
    880  8042
    881  8042		       a9 00		      LDA	#0
    882  8044		       8d 44 01 	      STA	score
    883  8047				   .L035		;;  playerY  =  0
    884  8047
    885  8047		       a9 00		      LDA	#0
    886  8049		       8d 46 01 	      STA	playerY
    887  804c				   .L036		;;  playerX  =  0
    888  804c
    889  804c		       a9 00		      LDA	#0
    890  804e		       8d 45 01 	      STA	playerX
    891  8051				   .L037		;;  playerAnimFrame  =  0
    892  8051
    893  8051		       a9 00		      LDA	#0
    894  8053		       8d 47 01 	      STA	playerAnimFrame
    895  8056				   .L038		;;  playerAnimWait  =	0
    896  8056
    897  8056		       a9 00		      LDA	#0
    898  8058		       8d 48 01 	      STA	playerAnimWait
    899  805b				   .
    900  805b							;; 
    901  805b
    902  805b				   .L039		;;  BACKGRND  =  $00
    903  805b
    904  805b		       a9 00		      LDA	#$00
    905  805d		       85 20		      STA	BACKGRND
    906  805f				   .
    907  805f							;; 
    908  805f
    909  805f				   ._titleLoop
    910  805f							;; _titleLoop
    911  805f
    912  805f				   .L040		;;  clearscreen
    913  805f
    914  805f		       20 87 f0 	      jsr	clearscreen
    915  8062				   .L041		;;  wait  =  wait  +  1
    916  8062
    917  8062		       ad 42 01 	      LDA	wait
    918  8065		       18		      CLC
    919  8066		       69 01		      ADC	#1
    920  8068		       8d 42 01 	      STA	wait
    921  806b				   .L042		;;  if wait  >  10 then wait  =  0  :	bgColor  =  bgColor  +	1
    922  806b
    923  806b		       a9 0a		      LDA	#10
    924  806d		       cd 42 01 	      CMP	wait
    925  8070		       b0 0e		      BCS	.skipL042
    926  8072				   .condpart0
    927  8072		       a9 00		      LDA	#0
    928  8074		       8d 42 01 	      STA	wait
    929  8077		       ad 41 01 	      LDA	bgColor
    930  807a		       18		      CLC
    931  807b		       69 01		      ADC	#1
    932  807d		       8d 41 01 	      STA	bgColor
    933  8080				   .skipL042
    934  8080				   .L043		;;  if bgColor  >  127 then bgColor  =  0
    935  8080
    936  8080		       a9 7f		      LDA	#127
    937  8082		       cd 41 01 	      CMP	bgColor
    938  8085		       b0 05		      BCS	.skipL043
    939  8087				   .condpart1
    940  8087		       a9 00		      LDA	#0
    941  8089		       8d 41 01 	      STA	bgColor
    942  808c				   .skipL043
    943  808c				   .L044		;;  BACKGRND  =  bgColor
    944  808c
    945  808c		       ad 41 01 	      LDA	bgColor
    946  808f		       85 20		      STA	BACKGRND
    947  8091				   .
    948  8091							;; 
    949  8091
    950  8091				   .L045		;;  plotchars 'u.a.p.' 0 68 5
    951  8091
    952  8091		       4c 9a 80 	      JMP	skipalphadata0
    953  8094				   alphadata0
    954  8094		       1e		      .byte.b	(<font + $1e)
    955  8095		       29		      .byte.b	(<font + $29)
    956  8096		       0a		      .byte.b	(<font + $0a)
    957  8097		       29		      .byte.b	(<font + $29)
    958  8098		       19		      .byte.b	(<font + $19)
    959  8099		       29		      .byte.b	(<font + $29)
    960  809a				   skipalphadata0
    961  809a		       a9 94		      lda	#<alphadata0
    962  809c		       85 42		      sta	temp1
    963  809e
    964  809e		       a9 80		      lda	#>alphadata0
    965  80a0		       85 43		      sta	temp2
    966  80a2
    967  80a2		       a9 1a		      lda	#26	; width in two's complement
    968  80a4		       09 00		      ora	#0	; palette left shifted 5 bits
    969  80a6		       85 44		      sta	temp3
    970  80a8		       a9 44		      lda	#68
    971  80aa		       85 45		      sta	temp4
    972  80ac
    973  80ac		       a9 05		      lda	#5
    974  80ae
    975  80ae		       85 46		      sta	temp5
    976  80b0
    977  80b0		       20 a6 f3 	      jsr	plotcharacters
    978  80b3				   .L046		;;  if joy0fire0  ||  joy0fire1 then goto _initGame
    979  80b3
    980  80b3		       2c 02 21 	      bit	sINPT1
    981  80b6		       50 03		      BVC	.skipL046
    982  80b8				   .condpart2
    983  80b8		       4c c0 80 	      jmp	.condpart3
    984  80bb				   .skipL046
    985  80bb		       2c 02 21 	      bit	sINPT1
    986  80be		       10 03		      BPL	.skip0OR
    987  80c0				   .condpart3
    988  80c0		       4c c9 80 	      jmp	._initGame
    989  80c3
    990  80c3				   .skip0OR
    991  80c3				   .
    992  80c3							;; 
    993  80c3
    994  80c3				   .L047		;;  drawscreen
    995  80c3
    996  80c3		       20 c3 f0 	      jsr	drawscreen
    997  80c6				   .
    998  80c6							;; 
    999  80c6
   1000  80c6				   .L048		;;  goto _titleLoop
   1001  80c6
   1002  80c6		       4c 5f 80 	      jmp	._titleLoop
   1003  80c9
   1004  80c9				   .
   1005  80c9							;; 
   1006  80c9
   1007  80c9				   .
   1008  80c9							;; 
   1009  80c9
   1010  80c9				   ._initGame
   1011  80c9							;; _initGame
   1012  80c9
   1013  80c9				   .L049		;;  lives  =  3
   1014  80c9
   1015  80c9		       a9 03		      LDA	#3
   1016  80cb		       8d 43 01 	      STA	lives
   1017  80ce				   .L050		;;  score  =  0
   1018  80ce
   1019  80ce		       a9 00		      LDA	#0
   1020  80d0		       8d 44 01 	      STA	score
   1021  80d3				   .L051		;;  BACKGRND = $00
   1022  80d3
   1023  80d3		       a9 00		      LDA	#$00
   1024  80d5		       85 20		      STA	BACKGRND
   1025  80d7				   .L052		;;  playerX  =  70
   1026  80d7
   1027  80d7		       a9 46		      LDA	#70
   1028  80d9		       8d 45 01 	      STA	playerX
   1029  80dc				   .L053		;;  playerY  =  90
   1030  80dc
   1031  80dc		       a9 5a		      LDA	#90
   1032  80de		       8d 46 01 	      STA	playerY
   1033  80e1				   .L054		;;  playerAnimFrame  =  0
   1034  80e1
   1035  80e1		       a9 00		      LDA	#0
   1036  80e3		       8d 47 01 	      STA	playerAnimFrame
   1037  80e6				   .L055		;;  playerAnimWait  =	0
   1038  80e6
   1039  80e6		       a9 00		      LDA	#0
   1040  80e8		       8d 48 01 	      STA	playerAnimWait
   1041  80eb				   .
   1042  80eb							;; 
   1043  80eb
   1044  80eb				   .
   1045  80eb							;; 
   1046  80eb
   1047  80eb				   .
   1048  80eb							;; 
   1049  80eb
   1050  80eb				   ._gameLoop
   1051  80eb							;; _gameLoop
   1052  80eb
   1053  80eb				   .
   1054  80eb							;; 
   1055  80eb
   1056  80eb				   .L056		;;  clearscreen
   1057  80eb
   1058  80eb		       20 87 f0 	      jsr	clearscreen
   1059  80ee				   .
   1060  80ee							;; 
   1061  80ee
   1062  80ee				   .L057		;;  rem plotchars 'game'  0 68 5
   1063  80ee
   1064  80ee				   .L058		;;  plotsprite player1 1 playerX playerY playerAnimFrame
   1065  80ee
   1066  80ee		       a9 35		      lda	#<player1
   1067  80f0		       a0 04		      ldy	#player1_width
   1068  80f2		       18		      clc
   1069  80f3		       f0 06		      beq	plotspritewidthskip1
   1070  80f5				   plotspritewidthloop1
   1071  80f5		       6d 47 01 	      adc	playerAnimFrame
   1072  80f8		       88		      dey
   1073  80f9		       d0 fa		      bne	plotspritewidthloop1
   1074  80fb				   plotspritewidthskip1
   1075  80fb		       85 42		      sta	temp1
   1076  80fd
   1077  80fd		       a9 a0		      lda	#>player1
   1078  80ff		       85 43		      sta	temp2
   1079  8101
   1080  8101		       a9 3c		      lda	#(32|player1_width_twoscompliment)
   1081  8103		       85 44		      sta	temp3
   1082  8105
   1083  8105		       ad 45 01 	      lda	playerX
   1084  8108		       85 45		      sta	temp4
   1085  810a
   1086  810a		       ad 46 01 	      lda	playerY
   1087  810d		       85 46		      sta	temp5
   1088  810f
   1089  810f		       a9 40		      lda	#(player1_mode|%01000000)
   1090  8111		       85 47		      sta	temp6
   1091  8113
   1092  8113		       20 e3 f2 	      jsr	plotsprite
   1093  8116				   .L059		;;  playerAnimWait  =	playerAnimWait	+ 1
   1094  8116
   1095  8116		       ad 48 01 	      LDA	playerAnimWait
   1096  8119		       18		      CLC
   1097  811a		       69 01		      ADC	#1
   1098  811c		       8d 48 01 	      STA	playerAnimWait
   1099  811f				   .L060		;;  if playerAnimWait	>  2 then playerAnimFrame  =  playerAnimFrame  +  1  :	playerAnimWait	=  0
   1100  811f
   1101  811f		       a9 02		      LDA	#2
   1102  8121		       cd 48 01 	      CMP	playerAnimWait
   1103  8124		       b0 0e		      BCS	.skipL060
   1104  8126				   .condpart4
   1105  8126		       ad 47 01 	      LDA	playerAnimFrame
   1106  8129		       18		      CLC
   1107  812a		       69 01		      ADC	#1
   1108  812c		       8d 47 01 	      STA	playerAnimFrame
   1109  812f		       a9 00		      LDA	#0
   1110  8131		       8d 48 01 	      STA	playerAnimWait
   1111  8134				   .skipL060
   1112  8134				   .L061		;;  if playerAnimFrame  >  3 then playerAnimFrame  =  0
   1113  8134
   1114  8134		       a9 03		      LDA	#3
   1115  8136		       cd 47 01 	      CMP	playerAnimFrame
   1116  8139		       b0 05		      BCS	.skipL061
   1117  813b				   .condpart5
   1118  813b		       a9 00		      LDA	#0
   1119  813d		       8d 47 01 	      STA	playerAnimFrame
   1120  8140				   .skipL061
   1121  8140				   .
   1122  8140							;; 
   1123  8140
   1124  8140				   .L062		;;  if joy0left then playerX = playerX  -  1
   1125  8140
   1126  8140		       2c 80 02 	      bit	SWCHA
   1127  8143		       70 09		      BVS	.skipL062
   1128  8145				   .condpart6
   1129  8145		       ad 45 01 	      LDA	playerX
   1130  8148		       38		      SEC
   1131  8149		       e9 01		      SBC	#1
   1132  814b		       8d 45 01 	      STA	playerX
   1133  814e				   .skipL062
   1134  814e				   .L063		;;  if joy0right then playerX = playerX  +  1
   1135  814e
   1136  814e		       2c 80 02 	      bit	SWCHA
   1137  8151		       30 09		      BMI	.skipL063
   1138  8153				   .condpart7
   1139  8153		       ad 45 01 	      LDA	playerX
   1140  8156		       18		      CLC
   1141  8157		       69 01		      ADC	#1
   1142  8159		       8d 45 01 	      STA	playerX
   1143  815c				   .skipL063
   1144  815c				   .L064		;;  if joy0up then playerY = playerY  -  1
   1145  815c
   1146  815c		       a9 10		      lda	#$10
   1147  815e		       2c 80 02 	      bit	SWCHA
   1148  8161		       d0 09		      BNE	.skipL064
   1149  8163				   .condpart8
   1150  8163		       ad 46 01 	      LDA	playerY
   1151  8166		       38		      SEC
   1152  8167		       e9 01		      SBC	#1
   1153  8169		       8d 46 01 	      STA	playerY
   1154  816c				   .skipL064
   1155  816c				   .L065		;;  if joy0down then playerY = playerY  +  1
   1156  816c
   1157  816c		       a9 20		      lda	#$20
   1158  816e		       2c 80 02 	      bit	SWCHA
   1159  8171		       d0 09		      BNE	.skipL065
   1160  8173				   .condpart9
   1161  8173		       ad 46 01 	      LDA	playerY
   1162  8176		       18		      CLC
   1163  8177		       69 01		      ADC	#1
   1164  8179		       8d 46 01 	      STA	playerY
   1165  817c				   .skipL065
   1166  817c				   .
   1167  817c							;; 
   1168  817c
   1169  817c				   .L066		;;  doublebuffer flip 2
   1170  817c
   1171  817c		       20 91 f5 	      jsr	flipdisplaybuffer
   1172  817f		       a9 02		      lda	#2
   1173  8181		       8d b3 01 	      sta	doublebufferminimumframetarget
   1174  8184				   .
   1175  8184							;; 
   1176  8184
   1177  8184				   .L067		;;  goto _gameLoop
   1178  8184		       4c eb 80 	      jmp	._gameLoop
   1179  8184				   DMAHOLEEND0 SET	.
   1180  8187				   gameend
   1181  8187				   DMAHOLEEND0 SET	.
   7801 bytes of ROM space left in the main area of bank 1.
   1182  8187					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   1183  8187				  -	      if	($A000 - .) < 0
   1184  8187				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   1185  8187					      endif
   1186  8187				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   1187  8187				  -	      .byte	0
   1188  8187					      endif
   1189  8187				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   1190  8187
   1191  a000					      ORG	$A000,0	; *************
   1192  a000
   1193  a000					      RORG	$A000	; *************
   1194  a000
   1195  a000		       a0 00	   font       =	$A000
   1196  a000
   1197  a000				   font
   1198  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1199  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1200  a020		       a0 35	   player1    =	$A035
   1201  a035
   1202  a035				   player1
   1203  a035		       00 00 00 00	      HEX	00000000
   1204  a035		       a0 39	   player2    =	$A039
   1205  a039
   1206  a039				   player2
   1207  a039		       00 00 00 00	      HEX	00000000
   1208  a039		       a0 3d	   player3    =	$A03D
   1209  a03d
   1210  a03d				   player3
   1211  a03d		       00 00 00 00	      HEX	00000000
   1212  a03d		       a0 41	   player4    =	$A041
   1213  a041
   1214  a041				   player4
   1215  a041		       00 00 00 00	      HEX	00000000
   1216  a045
   1217  a100					      ORG	$A100,0	; *************
   1218  a100
   1219  a100					      RORG	$A100	; *************
   1220  a100
   1221  a100							;font
   1222  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1223  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1224  a135							;player1
   1225  a135		       00 00 00 00	      HEX	00000000
   1226  a139							;player2
   1227  a139		       00 00 00 00	      HEX	00000000
   1228  a13d							;player3
   1229  a13d		       00 00 00 00	      HEX	00000000
   1230  a141							;player4
   1231  a141		       00 00 00 00	      HEX	00000000
   1232  a145
   1233  a200					      ORG	$A200,0	; *************
   1234  a200
   1235  a200					      RORG	$A200	; *************
   1236  a200
   1237  a200							;font
   1238  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1239  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1240  a235							;player1
   1241  a235		       00 00 00 00	      HEX	00000000
   1242  a239							;player2
   1243  a239		       00 00 00 00	      HEX	00000000
   1244  a23d							;player3
   1245  a23d		       00 00 00 00	      HEX	00000000
   1246  a241							;player4
   1247  a241		       00 00 00 00	      HEX	00000000
   1248  a245
   1249  a300					      ORG	$A300,0	; *************
   1250  a300
   1251  a300					      RORG	$A300	; *************
   1252  a300
   1253  a300							;font
   1254  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1255  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1256  a335							;player1
   1257  a335		       00 00 00 00	      HEX	00000000
   1258  a339							;player2
   1259  a339		       00 00 00 00	      HEX	00000000
   1260  a33d							;player3
   1261  a33d		       00 00 00 00	      HEX	00000000
   1262  a341							;player4
   1263  a341		       00 00 00 00	      HEX	00000000
   1264  a345
   1265  a400					      ORG	$A400,0	; *************
   1266  a400
   1267  a400					      RORG	$A400	; *************
   1268  a400
   1269  a400							;font
   1270  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1271  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1272  a435							;player1
   1273  a435		       00 00 00 00	      HEX	00000000
   1274  a439							;player2
   1275  a439		       00 00 00 00	      HEX	00000000
   1276  a43d							;player3
   1277  a43d		       00 00 00 00	      HEX	00000000
   1278  a441							;player4
   1279  a441		       00 00 00 00	      HEX	00000000
   1280  a445
   1281  a500					      ORG	$A500,0	; *************
   1282  a500
   1283  a500					      RORG	$A500	; *************
   1284  a500
   1285  a500							;font
   1286  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1287  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1288  a535							;player1
   1289  a535		       00 00 00 00	      HEX	00000000
   1290  a539							;player2
   1291  a539		       00 00 00 00	      HEX	00000000
   1292  a53d							;player3
   1293  a53d		       00 00 00 00	      HEX	00000000
   1294  a541							;player4
   1295  a541		       00 00 00 00	      HEX	00000000
   1296  a545
   1297  a600					      ORG	$A600,0	; *************
   1298  a600
   1299  a600					      RORG	$A600	; *************
   1300  a600
   1301  a600							;font
   1302  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1303  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1304  a635							;player1
   1305  a635		       00 00 00 00	      HEX	00000000
   1306  a639							;player2
   1307  a639		       00 00 00 00	      HEX	00000000
   1308  a63d							;player3
   1309  a63d		       00 00 00 00	      HEX	00000000
   1310  a641							;player4
   1311  a641		       00 00 00 00	      HEX	00000000
   1312  a645
   1313  a700					      ORG	$A700,0	; *************
   1314  a700
   1315  a700					      RORG	$A700	; *************
   1316  a700
   1317  a700							;font
   1318  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1319  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1320  a735							;player1
   1321  a735		       0f 57 d4 00	      HEX	0f57d400
   1322  a739							;player2
   1323  a739		       07 d5 f4 00	      HEX	07d5f400
   1324  a73d							;player3
   1325  a73d		       05 f5 7c 00	      HEX	05f57c00
   1326  a741							;player4
   1327  a741		       0d 7d 5c 00	      HEX	0d7d5c00
   1328  a745
   1329  a800					      ORG	$A800,0	; *************
   1330  a800
   1331  a800					      RORG	$A800	; *************
   1332  a800
   1333  a800							;font
   1334  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1335  a820		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   1336  a835							;player1
   1337  a835		       15 55 55 00	      HEX	15555500
   1338  a839							;player2
   1339  a839		       15 55 55 00	      HEX	15555500
   1340  a83d							;player3
   1341  a83d		       15 55 55 00	      HEX	15555500
   1342  a841							;player4
   1343  a841		       15 55 55 00	      HEX	15555500
   1344  a845
   1345  a900					      ORG	$A900,0	; *************
   1346  a900
   1347  a900					      RORG	$A900	; *************
   1348  a900
   1349  a900							;font
   1350  a900		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   1351  a920		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   1352  a935							;player1
   1353  a935		       55 55 55 40	      HEX	55555540
   1354  a939							;player2
   1355  a939		       55 55 55 40	      HEX	55555540
   1356  a93d							;player3
   1357  a93d		       55 55 55 40	      HEX	55555540
   1358  a941							;player4
   1359  a941		       55 55 55 40	      HEX	55555540
   1360  a945
   1361  aa00					      ORG	$AA00,0	; *************
   1362  aa00
   1363  aa00					      RORG	$AA00	; *************
   1364  aa00
   1365  aa00							;font
   1366  aa00		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   1367  aa20		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   1368  aa35							;player1
   1369  aa35		       00 00 00 00	      HEX	00000000
   1370  aa39							;player2
   1371  aa39		       00 00 00 00	      HEX	00000000
   1372  aa3d							;player3
   1373  aa3d		       a8 2a 0a 80	      HEX	a82a0a80
   1374  aa41							;player4
   1375  aa41		       00 00 00 00	      HEX	00000000
   1376  aa45
   1377  ab00					      ORG	$AB00,0	; *************
   1378  ab00
   1379  ab00					      RORG	$AB00	; *************
   1380  ab00
   1381  ab00							;font
   1382  ab00		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   1383  ab20		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   1384  ab35							;player1
   1385  ab35		       ff ff ff c0	      HEX	ffffffc0
   1386  ab39							;player2
   1387  ab39		       ab ea fa 80	      HEX	abeafa80
   1388  ab3d							;player3
   1389  ab3d		       ff ff ff c0	      HEX	ffffffc0
   1390  ab41							;player4
   1391  ab41		       ff ff ff c0	      HEX	ffffffc0
   1392  ab45
   1393  ac00					      ORG	$AC00,0	; *************
   1394  ac00
   1395  ac00					      RORG	$AC00	; *************
   1396  ac00
   1397  ac00							;font
   1398  ac00		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   1399  ac20		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   1400  ac35							;player1
   1401  ac35		       a8 2a 0a 80	      HEX	a82a0a80
   1402  ac39							;player2
   1403  ac39		       00 00 00 00	      HEX	00000000
   1404  ac3d							;player3
   1405  ac3d		       00 00 00 00	      HEX	00000000
   1406  ac41							;player4
   1407  ac41		       00 00 00 00	      HEX	00000000
   1408  ac45
   1409  ad00					      ORG	$AD00,0	; *************
   1410  ad00
   1411  ad00					      RORG	$AD00	; *************
   1412  ad00
   1413  ad00							;font
   1414  ad00		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   1415  ad20		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   1416  ad35							;player1
   1417  ad35		       55 55 55 40	      HEX	55555540
   1418  ad39							;player2
   1419  ad39		       55 55 55 40	      HEX	55555540
   1420  ad3d							;player3
   1421  ad3d		       55 55 55 40	      HEX	55555540
   1422  ad41							;player4
   1423  ad41		       55 55 55 40	      HEX	55555540
   1424  ad45
   1425  ae00					      ORG	$AE00,0	; *************
   1426  ae00
   1427  ae00					      RORG	$AE00	; *************
   1428  ae00
   1429  ae00							;font
   1430  ae00		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   1431  ae20		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   1432  ae35							;player1
   1433  ae35		       15 55 55 00	      HEX	15555500
   1434  ae39							;player2
   1435  ae39		       15 55 55 00	      HEX	15555500
   1436  ae3d							;player3
   1437  ae3d		       15 55 55 00	      HEX	15555500
   1438  ae41							;player4
   1439  ae41		       15 55 55 00	      HEX	15555500
   1440  ae45
   1441  af00					      ORG	$AF00,0	; *************
   1442  af00
   1443  af00					      RORG	$AF00	; *************
   1444  af00
   1445  af00							;font
   1446  af00		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   1447  af20		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   1448  af35							;player1
   1449  af35		       05 f5 7c 00	      HEX	05f57c00
   1450  af39							;player2
   1451  af39		       07 d5 f4 00	      HEX	07d5f400
   1452  af3d							;player3
   1453  af3d		       0f 57 d4 00	      HEX	0f57d400
   1454  af41							;player4
   1455  af41		       0d 5f 5c 00	      HEX	0d5f5c00
   1456  af45
   1457  b000					      ORG	$B000,0	; *************
   1458  b000
   1459  b000					      RORG	$B000	; *************
   1460  b000				  -	      if	SPACEOVERFLOW > 0
   1461  b000				  -	      echo	""
   1462  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   1463  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   1464  b000				  -	      echo	"######## Aborting assembly."
   1465  b000				  -	      ERR
   1466  b000					      endif
   1467  b000
   1468  b000
   1469  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1470  b000
   1471  b000				  -	      ifnconst	bankswitchmode
   1472  b000				  -	      if	( * < $f000 )
   1473  b000				  -	      ORG	$F000
   1474  b000				  -	      endif
   1475  b000					      else
   1476  b000					      ifconst	ROM128K
   1477  b000					      if	( * < $f000 )
   1478  27000					       ORG	$27000
   1479  27000					       RORG	$F000
   1480  27000					       endif
   1481  27000					       endif
   1482  27000				   -	       ifconst	ROM144K
   1483  27000				   -	       if	( * < $f000 )
   1484  27000				   -	       ORG	$27000
   1485  27000				   -	       RORG	$F000
   1486  27000				   -	       endif
   1487  27000					       endif
   1488  27000				   -	       ifconst	ROM256K
   1489  27000				   -	       if	( * < $f000 )
   1490  27000				   -	       ORG	$47000
   1491  27000				   -	       RORG	$F000
   1492  27000				   -	       endif
   1493  27000					       endif
   1494  27000				   -	       ifconst	ROM272K
   1495  27000				   -	       if	( * < $f000 )
   1496  27000				   -	       ORG	$47000
   1497  27000				   -	       RORG	$F000
   1498  27000				   -	       endif
   1499  27000					       endif
   1500  27000				   -	       ifconst	ROM512K
   1501  27000				   -	       if	( * < $f000 )
   1502  27000				   -	       ORG	$87000
   1503  27000				   -	       RORG	$F000
   1504  27000				   -	       endif
   1505  27000					       endif
   1506  27000				   -	       ifconst	ROM528K
   1507  27000				   -	       if	( * < $f000 )
   1508  27000				   -	       ORG	$87000
   1509  27000				   -	       RORG	$F000
   1510  27000				   -	       endif
   1511  27000					       endif
   1512  27000					       endif
   1513  27000
   1514  27000							; all of these "modules" have conditional clauses in them, so even though
   1515  27000							; they're always included here, they don't take up rom unless the user
   1516  27000							; explicitly enables support for the feature.
   1517  27000
   1518  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or Atari 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* Warnings:
     15  27000				   -			;*
     16  27000				   -			;* 1. RMT player routine needs 19 itself reserved bytes in zero page (no accessed
     17  27000				   -			;*    from any other routines) as well as cca 1KB of memory before the "PLAYER"
     18  27000				   -			;*    address for frequency tables and functionary variables. It's:
     19  27000				   -			;*	  a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     20  27000				   -			;*    b) from PLAYER-$380 to PLAYER for mono RMTplayer
     21  27000				   -			;*
     22  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER points
     23  27000				   -			;*	  to the start of the frequency tables. The player routines follows after
     24  27000				   -			;*	  that. The variables are now independent and can be located with
     25  27000				   -			;*	  PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     26  27000				   -			;*
     27  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled from the begin of the memory page.
     28  27000				   -			;*    i.e. "PLAYER" address can be $..00 only!
     29  27000				   -			;*
     30  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of CPU time.
     31  27000				   -			;*
     32  27000				   -			;*
     33  27000				   -			;* Define the following equates here or in your main code file.
     34  27000				   -			;* Set the values according to the system you compile for.
     35  27000				   -			;*
     36  27000				   -
     37  27000				   -POKEY_BASE equ	pokeyaddress
     38  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	; player routine needs 19 bytes of zero page RAM
     39  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;variables in main RAM - 173 bytes mono - 337 stereo
     40  27000				   -ROM_BASED  equ	1	;using a ROM based system - no self modifying code
     41  27000				   -STEREO8T   equ	0	;0 => compile RMTplayer for mono 4 tracks
     42  27000				   -			;				    ;1 => compile RMTplayer for stereo 8 tracks
     43  27000				   -
     44  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     45  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     46  27000				   -
     47  27000				   -			;*
     48  27000				   -
     49  27000				   -	       IF	STEREO8T
     50  27000				   -TRACKS     equ	8
     51  27000				   -	       ELSE
     52  27000				   -TRACKS     equ	4
     53  27000				   -	       EIF
     54  27000				   -
     55  27000				   -			;*
     56  27000				   -			;* RMT FEATures definitions
     57  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     58  27000				   -			;* --------BEGIN--------
     59  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     60  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
     61  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     62  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     63  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     64  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     65  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     66  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     67  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     68  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     69  27000				   -			;* PORTAMENTO
     70  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     71  27000				   -			;* FILTER
     72  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     73  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     74  27000				   -FEAT_FILTERG1L equ	1
     75  27000				   -FEAT_FILTERG0R equ	1
     76  27000				   -FEAT_FILTERG1R equ	1
     77  27000				   -			;* BASS16B (i.e. distortion value 6)
     78  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and quicker whole RMT routine
     79  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     80  27000				   -FEAT_BASS16G3L equ	1
     81  27000				   -FEAT_BASS16G1R equ	1
     82  27000				   -FEAT_BASS16G3R equ	1
     83  27000				   -			;* VOLUME ONLY for particular generators
     84  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     85  27000				   -FEAT_VOLUMEONLYG2L equ	1
     86  27000				   -FEAT_VOLUMEONLYG3L equ	1
     87  27000				   -FEAT_VOLUMEONLYG0R equ	1
     88  27000				   -FEAT_VOLUMEONLYG2R equ	1
     89  27000				   -FEAT_VOLUMEONLYG3R equ	1
     90  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
     91  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
     92  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
     93  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
     94  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
     95  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
     96  27000				   -			;* --------END--------
     97  27000				   -			;*
     98  27000				   -			;*
     99  27000				   -			;* RMT ZeroPage addresses
    100  27000				   -
    101  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    102  27000				   -p_tis      =	MEMLOC
    103  27000				   -p_instrstable =	MEMLOC
    104  27000				   -MEMLOC     SET	(MEMLOC+2)
    105  27000				   -p_trackslbstable =	MEMLOC
    106  27000				   -MEMLOC     SET	(MEMLOC+2)
    107  27000				   -p_trackshbstable =	MEMLOC
    108  27000				   -MEMLOC     SET	(MEMLOC+2)
    109  27000				   -p_song     =	MEMLOC
    110  27000				   -MEMLOC     SET	(MEMLOC+2)
    111  27000				   -
    112  27000				   -_ns        =	MEMLOC
    113  27000				   -MEMLOC     SET	(MEMLOC+2)
    114  27000				   -_nr        =	MEMLOC
    115  27000				   -MEMLOC     SET	(MEMLOC+2)
    116  27000				   -_nt        =	MEMLOC
    117  27000				   -MEMLOC     SET	(MEMLOC+2)
    118  27000				   -
    119  27000				   -rmtreg1    =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+1)
    121  27000				   -rmtreg2    =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+1)
    123  27000				   -rmtreg3    =	MEMLOC
    124  27000				   -MEMLOC     SET	(MEMLOC+1)
    125  27000				   -_tmp       =	MEMLOC
    126  27000				   -MEMLOC     SET	(MEMLOC+1)
    127  27000				   -	       IF	FEAT_COMMAND2
    128  27000				   -frqaddcmd2 =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+1)
    130  27000				   -	       EIF
    131  27000				   -
    132  27000				   -			;*
    133  27000				   -			;* Variables in main RAM used by player routine.
    134  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    135  27000				   -			;*
    136  27000				   -
    137  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    138  27000				   -track_variables =	MEMLOC
    139  27000				   -
    140  27000				   -trackn_db  =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    142  27000				   -trackn_hb  =	MEMLOC
    143  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    144  27000				   -trackn_idx =	MEMLOC
    145  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    146  27000				   -trackn_pause =	MEMLOC
    147  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    148  27000				   -trackn_note =	MEMLOC
    149  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    150  27000				   -trackn_volume =	MEMLOC
    151  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    152  27000				   -trackn_distor =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_shiftfrq =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -
    157  27000				   -	       IF	FEAT_PORTAMENTO
    158  27000				   -trackn_portafrqc =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_portafrqa =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_portaspeed =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_portaspeeda =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_portadepth =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -	       EIF
    169  27000				   -
    170  27000				   -trackn_instrx2 =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_instrdb =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_instrhb =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_instridx =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_instrlen =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -trackn_instrlop =	MEMLOC
    181  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    182  27000				   -trackn_instrreachend =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_volumeslidedepth =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_volumeslidevalue =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_volumemin =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_effdelay =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_effvibratoa =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_effvibratobeg =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_effvibratoend =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_effshift =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_tabletypespeed =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -
    203  27000				   -	       IF	FEAT_TABLEMODE
    204  27000				   -trackn_tablemode =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -	       EIF
    207  27000				   -
    208  27000				   -trackn_tablenote =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -
    211  27000				   -trackn_tablea =	MEMLOC
    212  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    213  27000				   -trackn_tableend =	MEMLOC
    214  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    215  27000				   -trackn_tablelop =	MEMLOC
    216  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    217  27000				   -trackn_tablespeeda =	MEMLOC
    218  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    219  27000				   -trackn_command =	MEMLOC
    220  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    221  27000				   -
    222  27000				   -	       IF	FEAT_BASS16
    223  27000				   -trackn_outnote =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -	       EIF
    226  27000				   -	       IF	FEAT_FILTER
    227  27000				   -trackn_filter =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -	       EIF
    230  27000				   -
    231  27000				   -trackn_audf =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -trackn_audc =	MEMLOC
    234  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    235  27000				   -
    236  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    237  27000				   -trackn_audctl =	MEMLOC
    238  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    239  27000				   -	       EIF
    240  27000				   -
    241  27000				   -v_audctl   =	MEMLOC
    242  27000				   -MEMLOC     SET	(MEMLOC+1)
    243  27000				   -v_audctl2  =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+1)
    245  27000				   -v_speed    =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+1)
    247  27000				   -v_aspeed   =	MEMLOC
    248  27000				   -MEMLOC     SET	(MEMLOC+1)
    249  27000				   -v_bspeed   =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+1)
    251  27000				   -v_instrspeed =	MEMLOC
    252  27000				   -MEMLOC     SET	(MEMLOC+1)
    253  27000				   -v_ainstrspeed =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_maxtracklen =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_abeat    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -
    260  27000				   -track_endvariables =	MEMLOC
    261  27000				   -
    262  27000				   -			;*
    263  27000				   -			;* Data tables used by player routine.
    264  27000				   -			;*
    265  27000				   -	       ALIGN	256
    266  27000				   -PLAYER     =	.
    267  27000				   -
    268  27000				   -volumetab
    269  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    270  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    271  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    272  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    273  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    274  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    275  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    276  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    277  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    278  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    279  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    280  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    281  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    282  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    283  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    284  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    285  27000				   -
    286  27000				   -frqtab
    287  27000				   -			;	ERT [<frqtab]!=0	;* frqtab must begin at the memory page bound! (i.e. $..00 address)
    288  27000				   -frqtabbass1
    289  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    290  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    291  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    292  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    293  27000				   -frqtabbass2
    294  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    295  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    296  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    297  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    298  27000				   -frqtabpure
    299  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    300  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    301  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    302  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    303  27000				   -	       IF	FEAT_BASS16
    304  27000				   -frqtabbasshi
    305  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    306  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    307  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    308  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    309  27000				   -	       EIF
    310  27000				   -
    311  27000				   -	       IF	FEAT_BASS16
    312  27000				   -frqtabbasslo
    313  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    314  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    315  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    316  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    317  27000				   -	       EIF
    318  27000				   -
    319  27000				   -	       IF	ROM_BASED
    320  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    321  27000				   -	       EIF
    322  27000				   -INSTRPAR   equ	12
    323  27000				   -tabbeganddistor
    324  27000				   -	       dc.b	frqtabpure-frqtab,$00
    325  27000				   -	       dc.b	frqtabpure-frqtab,$20
    326  27000				   -	       dc.b	frqtabpure-frqtab,$40
    327  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    328  27000				   -	       dc.b	frqtabpure-frqtab,$80
    329  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    330  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    331  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    332  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    333  27000				   -vib0       dc.b	0
    334  27000				   -vib1       dc.b	1,-1,-1,1
    335  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    336  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    337  27000				   -vibx
    338  27000				   -emptytrack
    339  27000				   -	       dc.b	62,0
    340  27000				   -
    341  27000				   -			;*
    342  27000				   -			;* Set of RMT main vectors:
    343  27000				   -			;*
    344  27000				   -RASTERMUSICTRACKER
    345  27000				   -	       jmp	rmt_init
    346  27000				   -	       jmp	rmt_play
    347  27000				   -	       jmp	rmt_p3
    348  27000				   -	       jmp	rmt_silence
    349  27000				   -	       jmp	SetPokey
    350  27000				   -rmt_init
    351  27000				   -	       stx	_ns
    352  27000				   -	       sty	_ns+1
    353  27000				   -	       pha
    354  27000				   -	       IF	track_endvariables-track_variables>255
    355  27000				   -	       ldy	#0
    356  27000				   -	       tya
    357  27000				   -rmtri0     sta	track_variables,y
    358  27000				   -	       sta	track_endvariables-$100,y
    359  27000				   -	       iny
    360  27000				   -	       bne	rmtri0
    361  27000				   -	       ELSE
    362  27000				   -	       ldy	#track_endvariables-track_variables
    363  27000				   -	       lda	#0
    364  27000				   -rmtri0     sta	track_variables-1,y
    365  27000				   -	       dey
    366  27000				   -	       bne	rmtri0
    367  27000				   -	       EIF
    368  27000				   -	       ldy	#4
    369  27000				   -	       lda	(_ns),y
    370  27000				   -	       sta	v_maxtracklen
    371  27000				   -	       iny
    372  27000				   -	       lda	(_ns),y
    373  27000				   -	       sta	v_speed
    374  27000				   -	       iny
    375  27000				   -	       lda	(_ns),y
    376  27000				   -	       sta	v_instrspeed
    377  27000				   -	       sta	v_ainstrspeed
    378  27000				   -	       ldy	#8
    379  27000				   -rmtri1     lda	(_ns),y
    380  27000				   -	       sta	p_tis-8,y
    381  27000				   -	       iny
    382  27000				   -	       cpy	#8+8
    383  27000				   -	       bne	rmtri1
    384  27000				   -	       pla
    385  27000				   -	       pha
    386  27000				   -	       IF	STEREO8T
    387  27000				   -	       asl
    388  27000				   -	       asl
    389  27000				   -	       asl
    390  27000				   -	       clc
    391  27000				   -	       adc	p_song
    392  27000				   -	       sta	p_song
    393  27000				   -	       pla
    394  27000				   -	       and	#$e0
    395  27000				   -	       asl
    396  27000				   -	       rol
    397  27000				   -	       rol
    398  27000				   -	       rol
    399  27000				   -	       ELSE
    400  27000				   -	       asl
    401  27000				   -	       asl
    402  27000				   -	       clc
    403  27000				   -	       adc	p_song
    404  27000				   -	       sta	p_song
    405  27000				   -	       pla
    406  27000				   -	       and	#$c0
    407  27000				   -	       asl
    408  27000				   -	       rol
    409  27000				   -	       rol
    410  27000				   -	       EIF
    411  27000				   -	       adc	p_song+1
    412  27000				   -	       sta	p_song+1
    413  27000				   -	       jsr	GetSongLine
    414  27000				   -	       jsr	GetTrackLine
    415  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    416  27000				   -	       jsr	rmt_silence
    417  27000				   -	       lda	v_instrspeed
    418  27000				   -	       rts
    419  27000				   -rmt_silence
    420  27000				   -	       IF	STEREO8T
    421  27000				   -	       lda	#0
    422  27000				   -	       sta	POKEY_BASE+$08
    423  27000				   -	       sta	POKEY_BASE_S+$08
    424  27000				   -	       ldy	#3
    425  27000				   -	       sty	POKEY_BASE+$0f
    426  27000				   -	       sty	POKEY_BASE_S+$0f
    427  27000				   -	       ldy	#8
    428  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    429  27000				   -	       sta	POKEY_BASE_S+$00,y
    430  27000				   -	       dey
    431  27000				   -	       bpl	rmtsi1
    432  27000				   -	       ELSE
    433  27000				   -	       lda	#0
    434  27000				   -	       sta	POKEY_BASE+$08
    435  27000				   -	       ldy	#3
    436  27000				   -	       sty	POKEY_BASE+$0f
    437  27000				   -	       ldy	#8
    438  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    439  27000				   -	       dey
    440  27000				   -	       bpl	rmtsi1
    441  27000				   -	       EIF
    442  27000				   -	       rts
    443  27000				   -GetSongLine
    444  27000				   -	       ldx	#0
    445  27000				   -	       stx	v_abeat
    446  27000				   -rmtnn0
    447  27000				   -	       ldx	#0
    448  27000				   -rmtnn1     txa
    449  27000				   -	       tay
    450  27000				   -	       lda	(p_song),y
    451  27000				   -	       cmp	#$fe
    452  27000				   -	       bcs	rmtnn2
    453  27000				   -	       tay
    454  27000				   -	       lda	(p_trackslbstable),y
    455  27000				   -	       sta	trackn_db,x
    456  27000				   -	       lda	(p_trackshbstable),y
    457  27000				   -rmtnn1a    sta	trackn_hb,x
    458  27000				   -	       lda	#0
    459  27000				   -	       sta	trackn_idx,x
    460  27000				   -	       lda	#1
    461  27000				   -	       sta	trackn_pause,x
    462  27000				   -	       lda	#$80
    463  27000				   -	       sta	trackn_instrx2,x
    464  27000				   -	       inx
    465  27000				   -	       cpx	#TRACKS
    466  27000				   -	       bne	rmtnn1
    467  27000				   -	       lda	p_song
    468  27000				   -	       clc
    469  27000				   -	       adc	#TRACKS
    470  27000				   -	       sta	p_song
    471  27000				   -	       bcc	rmtnn1b
    472  27000				   -	       inc	p_song+1
    473  27000				   -rmtnn1b
    474  27000				   -	       rts
    475  27000				   -rmtnn2
    476  27000				   -	       beq	rmtnn3
    477  27000				   -rmtnn2a    lda	#<emptytrack
    478  27000				   -	       sta	trackn_db,x
    479  27000				   -	       lda	#>emptytrack
    480  27000				   -	       jmp	rmtnn1a
    481  27000				   -rmtnn3
    482  27000				   -	       ldy	#2
    483  27000				   -	       lda	(p_song),y
    484  27000				   -	       tax
    485  27000				   -	       iny
    486  27000				   -	       lda	(p_song),y
    487  27000				   -	       sta	p_song+1
    488  27000				   -	       stx	p_song
    489  27000				   -	       jmp	rmtnn0
    490  27000				   -GetTrackLine
    491  27000				   -rmtoo0
    492  27000				   -rmtoo0a
    493  27000				   -	       lda	v_speed
    494  27000				   -	       sta	v_bspeed
    495  27000				   -	       ldx	#0
    496  27000				   -rmtoo1
    497  27000				   -	       lda	trackn_pause,x
    498  27000				   -	       beq	rmtoo1x
    499  27000				   -	       dec	trackn_pause,x
    500  27000				   -	       bne	rmtoo1x
    501  27000				   -	       inc	trackn_pause,x
    502  27000				   -rmtoo1b
    503  27000				   -	       lda	trackn_db,x
    504  27000				   -	       sta	_ns
    505  27000				   -	       lda	trackn_hb,x
    506  27000				   -	       sta	_ns+1
    507  27000				   -rmtoo1i
    508  27000				   -	       ldy	trackn_idx,x
    509  27000				   -	       lda	(_ns),y
    510  27000				   -	       sta	rmtreg1
    511  27000				   -	       iny
    512  27000				   -	       lda	(_ns),y
    513  27000				   -	       sta	rmtreg2
    514  27000				   -	       iny
    515  27000				   -	       tya
    516  27000				   -	       sta	trackn_idx,x
    517  27000				   -	       lda	rmtreg1
    518  27000				   -	       and	#$3f
    519  27000				   -	       cmp	#61
    520  27000				   -	       beq	rmtoo1a
    521  27000				   -	       bcs	rmtoo2
    522  27000				   -	       sta	trackn_note,x
    523  27000				   -	       IF	FEAT_BASS16
    524  27000				   -	       sta	trackn_outnote,x
    525  27000				   -	       EIF
    526  27000				   -	       lda	rmtreg2
    527  27000				   -	       lsr
    528  27000				   -	       and	#$3f*2
    529  27000				   -	       sta	trackn_instrx2,x
    530  27000				   -rmtoo1a    lda	rmtreg2
    531  27000				   -	       lsr
    532  27000				   -	       ror	rmtreg1
    533  27000				   -	       lsr
    534  27000				   -	       ror	rmtreg1
    535  27000				   -	       lda	rmtreg1
    536  27000				   -	       and	#$f0
    537  27000				   -	       sta	trackn_volume,x
    538  27000				   -rmtoo1x
    539  27000				   -	       inx
    540  27000				   -	       cpx	#TRACKS
    541  27000				   -	       bne	rmtoo1
    542  27000				   -	       lda	v_bspeed
    543  27000				   -	       sta	v_speed
    544  27000				   -	       sta	v_aspeed
    545  27000				   -	       rts
    546  27000				   -rmtoo2
    547  27000				   -	       cmp	#63
    548  27000				   -	       beq	rmtoo63
    549  27000				   -	       lda	rmtreg1
    550  27000				   -	       and	#$c0
    551  27000				   -	       beq	rmtoo62_b
    552  27000				   -	       asl
    553  27000				   -	       rol
    554  27000				   -	       rol
    555  27000				   -	       sta	trackn_pause,x
    556  27000				   -	       dec	trackn_idx,x
    557  27000				   -	       jmp	rmtoo1x
    558  27000				   -rmtoo62_b
    559  27000				   -	       lda	rmtreg2
    560  27000				   -	       sta	trackn_pause,x
    561  27000				   -	       jmp	rmtoo1x
    562  27000				   -rmtoo63
    563  27000				   -	       lda	rmtreg1
    564  27000				   -	       bmi	rmtoo63_1X
    565  27000				   -	       lda	rmtreg2
    566  27000				   -	       sta	v_bspeed
    567  27000				   -	       jmp	rmtoo1i
    568  27000				   -rmtoo63_1X
    569  27000				   -	       cmp	#255
    570  27000				   -	       beq	rmtoo63_11
    571  27000				   -	       lda	rmtreg2
    572  27000				   -	       sta	trackn_idx,x
    573  27000				   -	       jmp	rmtoo1i
    574  27000				   -rmtoo63_11
    575  27000				   -	       jsr	GetSongLine
    576  27000				   -	       jmp	rmtoo0
    577  27000				   -InitOfNewSetInstrumentsOnly
    578  27000				   -	       ldx	#0
    579  27000				   -p2x1       ldy	trackn_instrx2,x
    580  27000				   -	       bmi	p2x2
    581  27000				   -	       jsr	SetUpInstrumentY2
    582  27000				   -	       lda	#$80
    583  27000				   -	       sta	trackn_instrx2,x
    584  27000				   -p2x2
    585  27000				   -	       inx
    586  27000				   -	       cpx	#TRACKS
    587  27000				   -	       bne	p2x1
    588  27000				   -	       rts
    589  27000				   -rmt_play
    590  27000				   -rmt_p0
    591  27000				   -	       jsr	SetPokey
    592  27000				   -rmt_p1
    593  27000				   -	       dec	v_ainstrspeed
    594  27000				   -	       beq	rmtp1a
    595  27000				   -	       jmp	rmt_p3
    596  27000				   -rmtp1a
    597  27000				   -	       lda	v_instrspeed
    598  27000				   -	       sta	v_ainstrspeed
    599  27000				   -rmt_p2
    600  27000				   -	       dec	v_aspeed
    601  27000				   -	       bne	rmt_p3
    602  27000				   -	       inc	v_abeat
    603  27000				   -	       lda	v_abeat
    604  27000				   -	       cmp	v_maxtracklen
    605  27000				   -	       bne	rmtp2o2
    606  27000				   -	       jsr	GetSongLine
    607  27000				   -rmtp2o2
    608  27000				   -	       jsr	GetTrackLine
    609  27000				   -	       jmp	rmt_p2X
    610  27000				   -go_ppnext  jmp	ppnext
    611  27000				   -rmt_p2X
    612  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    613  27000				   -rmt_p3
    614  27000				   -	       lda	#>frqtab
    615  27000				   -	       sta	_nr+1
    616  27000				   -	       ldx	#0
    617  27000				   -rmtpp1
    618  27000				   -	       lda	trackn_instrhb,x
    619  27000				   -	       beq	go_ppnext
    620  27000				   -	       sta	_ns+1
    621  27000				   -	       lda	trackn_instrdb,x
    622  27000				   -	       sta	_ns
    623  27000				   -	       ldy	trackn_instridx,x
    624  27000				   -	       lda	(_ns),y
    625  27000				   -	       sta	rmtreg1
    626  27000				   -	       iny
    627  27000				   -	       lda	(_ns),y
    628  27000				   -	       sta	rmtreg2
    629  27000				   -	       iny
    630  27000				   -	       lda	(_ns),y
    631  27000				   -	       sta	rmtreg3
    632  27000				   -	       iny
    633  27000				   -	       tya
    634  27000				   -	       cmp	trackn_instrlen,x
    635  27000				   -	       bcc	rmtpp2
    636  27000				   -	       beq	rmtpp2
    637  27000				   -	       lda	#$80
    638  27000				   -	       sta	trackn_instrreachend,x
    639  27000				   -rmtpp1b
    640  27000				   -	       lda	trackn_instrlop,x
    641  27000				   -rmtpp2     sta	trackn_instridx,x
    642  27000				   -	       lda	rmtreg1
    643  27000				   -	       IF	STEREO8T
    644  27000				   -	       cpx	#4
    645  27000				   -	       bcc	rmtpp2s
    646  27000				   -	       lsr
    647  27000				   -	       lsr
    648  27000				   -	       lsr
    649  27000				   -	       lsr
    650  27000				   -rmtpp2s
    651  27000				   -	       EIF
    652  27000				   -	       and	#$0f
    653  27000				   -	       ora	trackn_volume,x
    654  27000				   -	       tay
    655  27000				   -	       lda	volumetab,y
    656  27000				   -	       pha
    657  27000				   -	       lda	rmtreg2
    658  27000				   -	       and	#$0e
    659  27000				   -	       tay
    660  27000				   -	       lda	tabbeganddistor,y
    661  27000				   -	       sta	_nr
    662  27000				   -	       pla
    663  27000				   -	       ora	tabbeganddistor+1,y
    664  27000				   -	       sta	trackn_audc,x
    665  27000				   -	       jmp	InstrumentsEffects
    666  27000				   -returnfromInstrumentsEffects
    667  27000				   -	       IF	FEAT_COMMAND2
    668  27000				   -	       lda	#0
    669  27000				   -	       sta	frqaddcmd2
    670  27000				   -	       EIF
    671  27000				   -	       lda	rmtreg2
    672  27000				   -	       sta	trackn_command,x
    673  27000				   -	       and	#$70
    674  27000				   -	       lsr
    675  27000				   -	       lsr
    676  27000				   -	       IF	ROM_BASED
    677  27000				   -	       lsr
    678  27000				   -	       tay
    679  27000				   -	       lda	rts_tab+1,y
    680  27000				   -	       pha
    681  27000				   -	       lda	rts_tab,y
    682  27000				   -	       pha
    683  27000				   -	       rts
    684  27000				   -	       ELSE
    685  27000				   -	       sta	jmx+1
    686  27000				   -jmx        bcc	*
    687  27000				   -	       jmp	cmd0
    688  27000				   -	       nop
    689  27000				   -	       jmp	cmd1
    690  27000				   -	       nop
    691  27000				   -	       jmp	cmd2
    692  27000				   -	       nop
    693  27000				   -	       jmp	cmd3
    694  27000				   -	       nop
    695  27000				   -	       jmp	cmd4
    696  27000				   -	       nop
    697  27000				   -	       jmp	cmd5
    698  27000				   -	       nop
    699  27000				   -	       jmp	cmd6
    700  27000				   -	       nop
    701  27000				   -	       jmp	cmd7
    702  27000				   -	       EIF
    703  27000				   -cmd0
    704  27000				   -	       lda	trackn_note,x
    705  27000				   -	       clc
    706  27000				   -	       adc	rmtreg3
    707  27000				   -cmd0a
    708  27000				   -	       IF	FEAT_TABLETYPE
    709  27000				   -	       ldy	trackn_tabletypespeed,x
    710  27000				   -	       bmi	cmd0b
    711  27000				   -	       EIF
    712  27000				   -	       clc
    713  27000				   -	       adc	trackn_tablenote,x
    714  27000				   -	       cmp	#61
    715  27000				   -	       bcc	cmd0a1
    716  27000				   -	       lda	#0
    717  27000				   -	       sta	trackn_audc,x
    718  27000				   -	       lda	#63
    719  27000				   -cmd0a1
    720  27000				   -	       IF	FEAT_BASS16
    721  27000				   -	       sta	trackn_outnote,x
    722  27000				   -	       EIF
    723  27000				   -	       tay
    724  27000				   -	       lda	(_nr),y
    725  27000				   -	       clc
    726  27000				   -	       adc	trackn_shiftfrq,x
    727  27000				   -	       IF	FEAT_COMMAND2
    728  27000				   -	       clc
    729  27000				   -	       adc	frqaddcmd2
    730  27000				   -	       EIF
    731  27000				   -	       sta	trackn_audf,x
    732  27000				   -	       jmp	rmtpp9
    733  27000				   -	       IF	FEAT_TABLETYPE
    734  27000				   -cmd0b
    735  27000				   -	       cmp	#61
    736  27000				   -	       bcc	cmd0b1
    737  27000				   -	       lda	#0
    738  27000				   -	       sta	trackn_audc,x
    739  27000				   -	       lda	#63
    740  27000				   -cmd0b1
    741  27000				   -	       tay
    742  27000				   -	       lda	trackn_shiftfrq,x
    743  27000				   -	       clc
    744  27000				   -	       adc	trackn_tablenote,x
    745  27000				   -	       clc
    746  27000				   -	       adc	(_nr),y
    747  27000				   -	       IF	FEAT_COMMAND2
    748  27000				   -	       clc
    749  27000				   -	       adc	frqaddcmd2
    750  27000				   -	       EIF
    751  27000				   -	       sta	trackn_audf,x
    752  27000				   -	       jmp	rmtpp9
    753  27000				   -	       EIF
    754  27000				   -cmd1
    755  27000				   -	       IF	FEAT_COMMAND1
    756  27000				   -	       lda	rmtreg3
    757  27000				   -	       sta	trackn_audf,x
    758  27000				   -	       jmp	rmtpp9
    759  27000				   -	       EIF
    760  27000				   -cmd2
    761  27000				   -	       IF	FEAT_COMMAND2
    762  27000				   -	       lda	rmtreg3
    763  27000				   -	       sta	frqaddcmd2
    764  27000				   -	       lda	trackn_note,x
    765  27000				   -	       jmp	cmd0a
    766  27000				   -	       EIF
    767  27000				   -cmd3
    768  27000				   -	       IF	FEAT_COMMAND3
    769  27000				   -	       lda	trackn_note,x
    770  27000				   -	       clc
    771  27000				   -	       adc	rmtreg3
    772  27000				   -	       sta	trackn_note,x
    773  27000				   -	       jmp	cmd0a
    774  27000				   -	       EIF
    775  27000				   -cmd4
    776  27000				   -	       IF	FEAT_COMMAND4
    777  27000				   -	       lda	trackn_shiftfrq,x
    778  27000				   -	       clc
    779  27000				   -	       adc	rmtreg3
    780  27000				   -	       sta	trackn_shiftfrq,x
    781  27000				   -	       lda	trackn_note,x
    782  27000				   -	       jmp	cmd0a
    783  27000				   -	       EIF
    784  27000				   -cmd5
    785  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    786  27000				   -	       IF	FEAT_TABLETYPE
    787  27000				   -	       lda	trackn_tabletypespeed,x
    788  27000				   -	       bpl	cmd5a1
    789  27000				   -	       ldy	trackn_note,x
    790  27000				   -	       lda	(_nr),y
    791  27000				   -	       clc
    792  27000				   -	       adc	trackn_tablenote,x
    793  27000				   -	       jmp	cmd5ax
    794  27000				   -	       EIF
    795  27000				   -cmd5a1
    796  27000				   -	       lda	trackn_note,x
    797  27000				   -	       clc
    798  27000				   -	       adc	trackn_tablenote,x
    799  27000				   -	       cmp	#61
    800  27000				   -	       bcc	cmd5a2
    801  27000				   -	       lda	#63
    802  27000				   -cmd5a2
    803  27000				   -	       tay
    804  27000				   -	       lda	(_nr),y
    805  27000				   -cmd5ax
    806  27000				   -	       sta	trackn_portafrqc,x
    807  27000				   -	       ldy	rmtreg3
    808  27000				   -	       bne	cmd5a
    809  27000				   -	       sta	trackn_portafrqa,x
    810  27000				   -cmd5a
    811  27000				   -	       tya
    812  27000				   -	       lsr
    813  27000				   -	       lsr
    814  27000				   -	       lsr
    815  27000				   -	       lsr
    816  27000				   -	       sta	trackn_portaspeed,x
    817  27000				   -	       sta	trackn_portaspeeda,x
    818  27000				   -	       lda	rmtreg3
    819  27000				   -	       and	#$0f
    820  27000				   -	       sta	trackn_portadepth,x
    821  27000				   -	       lda	trackn_note,x
    822  27000				   -	       jmp	cmd0a
    823  27000				   -	       ELSE
    824  27000				   -	       IF	FEAT_COMMAND5
    825  27000				   -	       jmp	rmtpp9
    826  27000				   -	       EIF
    827  27000				   -	       EIF
    828  27000				   -cmd6
    829  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    830  27000				   -	       lda	rmtreg3
    831  27000				   -	       clc
    832  27000				   -	       adc	trackn_filter,x
    833  27000				   -	       sta	trackn_filter,x
    834  27000				   -	       lda	trackn_note,x
    835  27000				   -	       jmp	cmd0a
    836  27000				   -	       ELSE
    837  27000				   -	       IF	FEAT_COMMAND6
    838  27000				   -	       jmp	rmtpp9
    839  27000				   -	       EIF
    840  27000				   -	       EIF
    841  27000				   -cmd7
    842  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    843  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    844  27000				   -	       lda	rmtreg3
    845  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    846  27000				   -	       cmp	#$80
    847  27000				   -	       beq	cmd7a
    848  27000				   -	       EIF
    849  27000				   -	       sta	trackn_note,x
    850  27000				   -	       jmp	cmd0a
    851  27000				   -	       EIF
    852  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    853  27000				   -cmd7a
    854  27000				   -	       lda	trackn_audc,x
    855  27000				   -	       ora	#$f0
    856  27000				   -	       sta	trackn_audc,x
    857  27000				   -	       lda	trackn_note,x
    858  27000				   -	       jmp	cmd0a
    859  27000				   -	       EIF
    860  27000				   -	       EIF
    861  27000				   -rmtpp9
    862  27000				   -	       IF	FEAT_PORTAMENTO
    863  27000				   -	       lda	trackn_portaspeeda,x
    864  27000				   -	       beq	rmtpp10
    865  27000				   -	       sec
    866  27000				   -	       sbc	#1
    867  27000				   -	       sta	trackn_portaspeeda,x
    868  27000				   -	       bne	rmtpp10
    869  27000				   -	       lda	trackn_portaspeed,x
    870  27000				   -	       sta	trackn_portaspeeda,x
    871  27000				   -	       lda	trackn_portafrqa,x
    872  27000				   -	       cmp	trackn_portafrqc,x
    873  27000				   -	       beq	rmtpp10
    874  27000				   -	       bcs	pps1
    875  27000				   -	       adc	trackn_portadepth,x
    876  27000				   -	       bcs	pps8
    877  27000				   -	       cmp	trackn_portafrqc,x
    878  27000				   -	       bcs	pps8
    879  27000				   -	       jmp	pps9
    880  27000				   -pps1
    881  27000				   -	       sbc	trackn_portadepth,x
    882  27000				   -	       bcc	pps8
    883  27000				   -	       cmp	trackn_portafrqc,x
    884  27000				   -	       bcs	pps9
    885  27000				   -pps8
    886  27000				   -	       lda	trackn_portafrqc,x
    887  27000				   -pps9
    888  27000				   -	       sta	trackn_portafrqa,x
    889  27000				   -rmtpp10
    890  27000				   -	       lda	rmtreg2
    891  27000				   -	       and	#$01
    892  27000				   -	       beq	rmtpp11
    893  27000				   -	       lda	trackn_portafrqa,x
    894  27000				   -	       clc
    895  27000				   -	       adc	trackn_shiftfrq,x
    896  27000				   -	       sta	trackn_audf,x
    897  27000				   -rmtpp11
    898  27000				   -	       EIF
    899  27000				   -ppnext
    900  27000				   -	       inx
    901  27000				   -	       cpx	#TRACKS
    902  27000				   -	       beq	rmt_p4
    903  27000				   -	       jmp	rmtpp1
    904  27000				   -rmt_p4
    905  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    906  27000				   -	       ldx	#3
    907  27000				   -	       lda	#0
    908  27000				   -qq0        ora	trackn_audctl,x
    909  27000				   -	       dex
    910  27000				   -	       bpl	qq0
    911  27000				   -	       sta	v_audctl
    912  27000				   -qq1
    913  27000				   -	       ldx	v_audctl
    914  27000				   -	       ELSE
    915  27000				   -	       ldx	#0
    916  27000				   -	       stx	v_audctl
    917  27000				   -	       EIF
    918  27000				   -	       IF	FEAT_FILTER
    919  27000				   -	       IF	FEAT_FILTERG0L
    920  27000				   -	       lda	trackn_command+0
    921  27000				   -	       bpl	qq2
    922  27000				   -	       lda	trackn_audc+0
    923  27000				   -	       and	#$0f
    924  27000				   -	       beq	qq2
    925  27000				   -	       lda	trackn_audf+0
    926  27000				   -	       clc
    927  27000				   -	       adc	trackn_filter+0
    928  27000				   -	       sta	trackn_audf+2
    929  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
    930  27000				   -	       lda	trackn_audc+2
    931  27000				   -	       and	#$10
    932  27000				   -	       bne	qq1a
    933  27000				   -	       EIF
    934  27000				   -	       lda	#0
    935  27000				   -	       sta	trackn_audc+2
    936  27000				   -qq1a
    937  27000				   -	       txa
    938  27000				   -	       ora	#4
    939  27000				   -	       tax
    940  27000				   -	       EIF
    941  27000				   -qq2
    942  27000				   -	       IF	FEAT_FILTERG1L
    943  27000				   -	       lda	trackn_command+1
    944  27000				   -	       bpl	qq3
    945  27000				   -	       lda	trackn_audc+1
    946  27000				   -	       and	#$0f
    947  27000				   -	       beq	qq3
    948  27000				   -	       lda	trackn_audf+1
    949  27000				   -	       clc
    950  27000				   -	       adc	trackn_filter+1
    951  27000				   -	       sta	trackn_audf+3
    952  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
    953  27000				   -	       lda	trackn_audc+3
    954  27000				   -	       and	#$10
    955  27000				   -	       bne	qq2a
    956  27000				   -	       EIF
    957  27000				   -	       lda	#0
    958  27000				   -	       sta	trackn_audc+3
    959  27000				   -qq2a
    960  27000				   -	       txa
    961  27000				   -	       ora	#2
    962  27000				   -	       tax
    963  27000				   -	       EIF
    964  27000				   -qq3
    965  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
    966  27000				   -	       cpx	v_audctl
    967  27000				   -	       bne	qq5
    968  27000				   -	       EIF
    969  27000				   -	       EIF
    970  27000				   -	       IF	FEAT_BASS16
    971  27000				   -	       IF	FEAT_BASS16G1L
    972  27000				   -	       lda	trackn_command+1
    973  27000				   -	       and	#$0e
    974  27000				   -	       cmp	#6
    975  27000				   -	       bne	qq4
    976  27000				   -	       lda	trackn_audc+1
    977  27000				   -	       and	#$0f
    978  27000				   -	       beq	qq4
    979  27000				   -	       ldy	trackn_outnote+1
    980  27000				   -	       lda	frqtabbasslo,y
    981  27000				   -	       sta	trackn_audf+0
    982  27000				   -	       lda	frqtabbasshi,y
    983  27000				   -	       sta	trackn_audf+1
    984  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
    985  27000				   -	       lda	trackn_audc+0
    986  27000				   -	       and	#$10
    987  27000				   -	       bne	qq3a
    988  27000				   -	       EIF
    989  27000				   -	       lda	#0
    990  27000				   -	       sta	trackn_audc+0
    991  27000				   -qq3a
    992  27000				   -	       txa
    993  27000				   -	       ora	#$50
    994  27000				   -	       tax
    995  27000				   -	       EIF
    996  27000				   -qq4
    997  27000				   -	       IF	FEAT_BASS16G3L
    998  27000				   -	       lda	trackn_command+3
    999  27000				   -	       and	#$0e
   1000  27000				   -	       cmp	#6
   1001  27000				   -	       bne	qq5
   1002  27000				   -	       lda	trackn_audc+3
   1003  27000				   -	       and	#$0f
   1004  27000				   -	       beq	qq5
   1005  27000				   -	       ldy	trackn_outnote+3
   1006  27000				   -	       lda	frqtabbasslo,y
   1007  27000				   -	       sta	trackn_audf+2
   1008  27000				   -	       lda	frqtabbasshi,y
   1009  27000				   -	       sta	trackn_audf+3
   1010  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1011  27000				   -	       lda	trackn_audc+2
   1012  27000				   -	       and	#$10
   1013  27000				   -	       bne	qq4a
   1014  27000				   -	       EIF
   1015  27000				   -	       lda	#0
   1016  27000				   -	       sta	trackn_audc+2
   1017  27000				   -qq4a
   1018  27000				   -	       txa
   1019  27000				   -	       ora	#$28
   1020  27000				   -	       tax
   1021  27000				   -	       EIF
   1022  27000				   -	       EIF
   1023  27000				   -qq5
   1024  27000				   -	       stx	v_audctl
   1025  27000				   -	       IF	STEREO8T
   1026  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1027  27000				   -	       ldx	#3
   1028  27000				   -	       lda	#0
   1029  27000				   -qs0        ora	trackn_audctl+4,x
   1030  27000				   -	       dex
   1031  27000				   -	       bpl	qs0
   1032  27000				   -	       sta	v_audctl2
   1033  27000				   -qs1
   1034  27000				   -	       ldx	v_audctl2
   1035  27000				   -	       ELSE
   1036  27000				   -	       ldx	#0
   1037  27000				   -	       stx	v_audctl2
   1038  27000				   -	       EIF
   1039  27000				   -	       IF	FEAT_FILTER
   1040  27000				   -	       IF	FEAT_FILTERG0R
   1041  27000				   -	       lda	trackn_command+0+4
   1042  27000				   -	       bpl	qs2
   1043  27000				   -	       lda	trackn_audc+0+4
   1044  27000				   -	       and	#$0f
   1045  27000				   -	       beq	qs2
   1046  27000				   -	       lda	trackn_audf+0+4
   1047  27000				   -	       clc
   1048  27000				   -	       adc	trackn_filter+0+4
   1049  27000				   -	       sta	trackn_audf+2+4
   1050  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1051  27000				   -	       lda	trackn_audc+2+4
   1052  27000				   -	       and	#$10
   1053  27000				   -	       bne	qs1a
   1054  27000				   -	       EIF
   1055  27000				   -	       lda	#0
   1056  27000				   -	       sta	trackn_audc+2+4
   1057  27000				   -qs1a
   1058  27000				   -	       txa
   1059  27000				   -	       ora	#4
   1060  27000				   -	       tax
   1061  27000				   -	       EIF
   1062  27000				   -qs2
   1063  27000				   -	       IF	FEAT_FILTERG1R
   1064  27000				   -	       lda	trackn_command+1+4
   1065  27000				   -	       bpl	qs3
   1066  27000				   -	       lda	trackn_audc+1+4
   1067  27000				   -	       and	#$0f
   1068  27000				   -	       beq	qs3
   1069  27000				   -	       lda	trackn_audf+1+4
   1070  27000				   -	       clc
   1071  27000				   -	       adc	trackn_filter+1+4
   1072  27000				   -	       sta	trackn_audf+3+4
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1074  27000				   -	       lda	trackn_audc+3+4
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qs2a
   1077  27000				   -	       EIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+3+4
   1080  27000				   -qs2a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#2
   1083  27000				   -	       tax
   1084  27000				   -	       EIF
   1085  27000				   -qs3
   1086  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1087  27000				   -	       cpx	v_audctl2
   1088  27000				   -	       bne	qs5
   1089  27000				   -	       EIF
   1090  27000				   -	       EIF
   1091  27000				   -	       IF	FEAT_BASS16
   1092  27000				   -	       IF	FEAT_BASS16G1R
   1093  27000				   -	       lda	trackn_command+1+4
   1094  27000				   -	       and	#$0e
   1095  27000				   -	       cmp	#6
   1096  27000				   -	       bne	qs4
   1097  27000				   -	       lda	trackn_audc+1+4
   1098  27000				   -	       and	#$0f
   1099  27000				   -	       beq	qs4
   1100  27000				   -	       ldy	trackn_outnote+1+4
   1101  27000				   -	       lda	frqtabbasslo,y
   1102  27000				   -	       sta	trackn_audf+0+4
   1103  27000				   -	       lda	frqtabbasshi,y
   1104  27000				   -	       sta	trackn_audf+1+4
   1105  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1106  27000				   -	       lda	trackn_audc+0+4
   1107  27000				   -	       and	#$10
   1108  27000				   -	       bne	qs3a
   1109  27000				   -	       EIF
   1110  27000				   -	       lda	#0
   1111  27000				   -	       sta	trackn_audc+0+4
   1112  27000				   -qs3a
   1113  27000				   -	       txa
   1114  27000				   -	       ora	#$50
   1115  27000				   -	       tax
   1116  27000				   -	       EIF
   1117  27000				   -qs4
   1118  27000				   -	       IF	FEAT_BASS16G3R
   1119  27000				   -	       lda	trackn_command+3+4
   1120  27000				   -	       and	#$0e
   1121  27000				   -	       cmp	#6
   1122  27000				   -	       bne	qs5
   1123  27000				   -	       lda	trackn_audc+3+4
   1124  27000				   -	       and	#$0f
   1125  27000				   -	       beq	qs5
   1126  27000				   -	       ldy	trackn_outnote+3+4
   1127  27000				   -	       lda	frqtabbasslo,y
   1128  27000				   -	       sta	trackn_audf+2+4
   1129  27000				   -	       lda	frqtabbasshi,y
   1130  27000				   -	       sta	trackn_audf+3+4
   1131  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1132  27000				   -	       lda	trackn_audc+2+4
   1133  27000				   -	       and	#$10
   1134  27000				   -	       bne	qs4a
   1135  27000				   -	       EIF
   1136  27000				   -	       lda	#0
   1137  27000				   -	       sta	trackn_audc+2+4
   1138  27000				   -qs4a
   1139  27000				   -	       txa
   1140  27000				   -	       ora	#$28
   1141  27000				   -	       tax
   1142  27000				   -	       EIF
   1143  27000				   -	       EIF
   1144  27000				   -qs5
   1145  27000				   -	       stx	v_audctl2
   1146  27000				   -	       EIF
   1147  27000				   -rmt_p5
   1148  27000				   -	       lda	v_ainstrspeed
   1149  27000				   -	       rts
   1150  27000				   -SetPokey
   1151  27000				   -	       IF	STEREO8T
   1152  27000				   -	       ldy	v_audctl2
   1153  27000				   -	       lda	trackn_audf+0+4
   1154  27000				   -	       ldx	trackn_audf+0
   1155  27000				   -	       sta	POKEY_BASE_S+$00
   1156  27000				   -	       stx	POKEY_BASE+$00
   1157  27000				   -	       lda	trackn_audc+0+4
   1158  27000				   -	       ldx	trackn_audc+0
   1159  27000				   -	       sta	POKEY_BASE_S+$01
   1160  27000				   -	       stx	POKEY_BASE+$01
   1161  27000				   -	       lda	trackn_audf+1+4
   1162  27000				   -	       ldx	trackn_audf+1
   1163  27000				   -	       sta	POKEY_BASE_S+$02
   1164  27000				   -	       stx	POKEY_BASE+$02
   1165  27000				   -	       lda	trackn_audc+1+4
   1166  27000				   -	       ldx	trackn_audc+1
   1167  27000				   -	       sta	POKEY_BASE_S+$03
   1168  27000				   -	       stx	POKEY_BASE+$03
   1169  27000				   -	       lda	trackn_audf+2+4
   1170  27000				   -	       ldx	trackn_audf+2
   1171  27000				   -	       sta	POKEY_BASE_S+$04
   1172  27000				   -	       stx	POKEY_BASE+$04
   1173  27000				   -	       lda	trackn_audc+2+4
   1174  27000				   -	       ldx	trackn_audc+2
   1175  27000				   -	       sta	POKEY_BASE_S+$05
   1176  27000				   -	       stx	POKEY_BASE+$05
   1177  27000				   -	       lda	trackn_audf+3+4
   1178  27000				   -	       ldx	trackn_audf+3
   1179  27000				   -	       sta	POKEY_BASE_S+$06
   1180  27000				   -	       stx	POKEY_BASE+$06
   1181  27000				   -	       lda	trackn_audc+3+4
   1182  27000				   -	       ldx	trackn_audc+3
   1183  27000				   -	       sta	POKEY_BASE_S+$07
   1184  27000				   -	       stx	POKEY_BASE+$07
   1185  27000				   -	       lda	v_audctl
   1186  27000				   -	       sty	POKEY_BASE_S+$08
   1187  27000				   -	       sta	POKEY_BASE+$08
   1188  27000				   -	       ELSE
   1189  27000				   -
   1190  27000				   -	       ifconst	RMTVOLUME
   1191  27000				   -	       lda	rmtvolume
   1192  27000				   -	       sta	fourbitfadevalueint
   1193  27000				   -	       endif
   1194  27000				   -	       ldy	v_audctl
   1195  27000				   -	       ldx	trackn_audf+0
   1196  27000				   -	       lda	trackn_audc+0
   1197  27000				   -	       ifconst	RMTVOLUME
   1198  27000				   -	       jsr	fourbitfadeint
   1199  27000				   -	       endif
   1200  27000				   -	       stx	POKEY_BASE+$00+0
   1201  27000				   -	       stx	POKEY_BASE+$00+0
   1202  27000				   -	       sta	POKEY_BASE+$01+0
   1203  27000				   -	       sta	POKEY_BASE+$01+0
   1204  27000				   -
   1205  27000				   -	       ldx	trackn_audf+1
   1206  27000				   -	       lda	trackn_audc+1
   1207  27000				   -	       ifconst	RMTVOLUME
   1208  27000				   -	       jsr	fourbitfadeint
   1209  27000				   -	       endif
   1210  27000				   -	       stx	POKEY_BASE+$00+2
   1211  27000				   -	       stx	POKEY_BASE+$00+2
   1212  27000				   -	       sta	POKEY_BASE+$01+2
   1213  27000				   -	       sta	POKEY_BASE+$01+2
   1214  27000				   -
   1215  27000				   -	       ldx	trackn_audf+2
   1216  27000				   -	       lda	trackn_audc+2
   1217  27000				   -	       ifconst	RMTVOLUME
   1218  27000				   -	       jsr	fourbitfadeint
   1219  27000				   -	       endif
   1220  27000				   -	       stx	POKEY_BASE+$00+4
   1221  27000				   -	       stx	POKEY_BASE+$00+4
   1222  27000				   -	       sta	POKEY_BASE+$01+4
   1223  27000				   -	       sta	POKEY_BASE+$01+4
   1224  27000				   -
   1225  27000				   -	       ldx	trackn_audf+3
   1226  27000				   -	       lda	trackn_audc+3
   1227  27000				   -	       ifconst	RMTVOLUME
   1228  27000				   -	       jsr	fourbitfadeint
   1229  27000				   -	       endif
   1230  27000				   -	       stx	POKEY_BASE+$00+6
   1231  27000				   -	       stx	POKEY_BASE+$00+6
   1232  27000				   -	       sta	POKEY_BASE+$01+6
   1233  27000				   -	       sta	POKEY_BASE+$01+6
   1234  27000				   -
   1235  27000				   -	       sty	POKEY_BASE+$08
   1236  27000				   -	       sty	POKEY_BASE+$08
   1237  27000				   -
   1238  27000				   -	       EIF
   1239  27000				   -	       rts
   1240  27000				   -SetUpInstrumentY2
   1241  27000				   -	       lda	(p_instrstable),y
   1242  27000				   -	       sta	trackn_instrdb,x
   1243  27000				   -	       sta	_nt
   1244  27000				   -	       iny
   1245  27000				   -	       lda	(p_instrstable),y
   1246  27000				   -	       sta	trackn_instrhb,x
   1247  27000				   -	       sta	_nt+1
   1248  27000				   -	       ldy	#0
   1249  27000				   -	       lda	(_nt),y
   1250  27000				   -	       sta	trackn_tableend,x
   1251  27000				   -	       clc
   1252  27000				   -	       adc	#1
   1253  27000				   -	       sta	trackn_instridx,x
   1254  27000				   -	       iny
   1255  27000				   -	       lda	(_nt),y
   1256  27000				   -	       sta	trackn_tablelop,x
   1257  27000				   -	       iny
   1258  27000				   -	       lda	(_nt),y
   1259  27000				   -	       sta	trackn_instrlen,x
   1260  27000				   -	       iny
   1261  27000				   -	       lda	(_nt),y
   1262  27000				   -	       sta	trackn_instrlop,x
   1263  27000				   -	       iny
   1264  27000				   -	       lda	(_nt),y
   1265  27000				   -	       sta	trackn_tabletypespeed,x
   1266  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1267  27000				   -	       and	#$3f
   1268  27000				   -	       EIF
   1269  27000				   -	       sta	trackn_tablespeeda,x
   1270  27000				   -	       IF	FEAT_TABLEMODE
   1271  27000				   -	       lda	(_nt),y
   1272  27000				   -	       and	#$40
   1273  27000				   -	       sta	trackn_tablemode,x
   1274  27000				   -	       EIF
   1275  27000				   -	       iny
   1276  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1277  27000				   -	       lda	(_nt),y
   1278  27000				   -	       sta	trackn_audctl,x
   1279  27000				   -	       EIF
   1280  27000				   -	       iny
   1281  27000				   -	       lda	(_nt),y
   1282  27000				   -	       sta	trackn_volumeslidedepth,x
   1283  27000				   -	       iny
   1284  27000				   -	       lda	(_nt),y
   1285  27000				   -	       sta	trackn_volumemin,x
   1286  27000				   -	       iny
   1287  27000				   -	       lda	(_nt),y
   1288  27000				   -	       sta	trackn_effdelay,x
   1289  27000				   -	       iny
   1290  27000				   -	       lda	(_nt),y
   1291  27000				   -	       tay
   1292  27000				   -	       lda	vibtabbeg,y
   1293  27000				   -	       sta	trackn_effvibratoa,x
   1294  27000				   -	       sta	trackn_effvibratobeg,x
   1295  27000				   -	       lda	vibtabbeg+1,y
   1296  27000				   -	       sta	trackn_effvibratoend,x
   1297  27000				   -	       ldy	#10
   1298  27000				   -	       lda	(_nt),y
   1299  27000				   -	       sta	trackn_effshift,x
   1300  27000				   -	       lda	#128
   1301  27000				   -	       sta	trackn_volumeslidevalue,x
   1302  27000				   -	       lda	#0
   1303  27000				   -	       sta	trackn_instrreachend,x
   1304  27000				   -	       sta	trackn_shiftfrq,x
   1305  27000				   -	       lda	#INSTRPAR
   1306  27000				   -	       sta	trackn_tablea,x
   1307  27000				   -	       tay
   1308  27000				   -	       lda	(_nt),y
   1309  27000				   -	       sta	trackn_tablenote,x
   1310  27000				   -	       IF	FEAT_FILTER
   1311  27000				   -	       lda	#1
   1312  27000				   -	       sta	trackn_filter,x
   1313  27000				   -	       EIF
   1314  27000				   -	       rts
   1315  27000				   -InstrumentsEffects
   1316  27000				   -	       lda	trackn_effdelay,x
   1317  27000				   -	       beq	ei2
   1318  27000				   -	       tay
   1319  27000				   -	       dey
   1320  27000				   -	       bne	ei1
   1321  27000				   -	       lda	trackn_shiftfrq,x
   1322  27000				   -	       clc
   1323  27000				   -	       adc	trackn_effshift,x
   1324  27000				   -	       clc
   1325  27000				   -	       ldy	trackn_effvibratoa,x
   1326  27000				   -	       adc	vib0,y
   1327  27000				   -	       sta	trackn_shiftfrq,x
   1328  27000				   -	       iny
   1329  27000				   -	       tya
   1330  27000				   -	       cmp	trackn_effvibratoend,x
   1331  27000				   -	       bne	ei1a
   1332  27000				   -	       lda	trackn_effvibratobeg,x
   1333  27000				   -ei1a
   1334  27000				   -	       sta	trackn_effvibratoa,x
   1335  27000				   -	       jmp	ei2
   1336  27000				   -ei1
   1337  27000				   -	       tya
   1338  27000				   -	       sta	trackn_effdelay,x
   1339  27000				   -ei2
   1340  27000				   -	       lda	trackn_tableend,x
   1341  27000				   -	       cmp	#INSTRPAR
   1342  27000				   -	       beq	ei3
   1343  27000				   -	       lda	trackn_tablespeeda,x
   1344  27000				   -	       bpl	ei2f
   1345  27000				   -ei2c
   1346  27000				   -	       lda	trackn_tablea,x
   1347  27000				   -	       clc
   1348  27000				   -	       adc	#1
   1349  27000				   -	       cmp	trackn_tableend,x
   1350  27000				   -	       bcc	ei2a
   1351  27000				   -	       beq	ei2a
   1352  27000				   -	       lda	trackn_tablelop,x
   1353  27000				   -ei2a
   1354  27000				   -	       sta	trackn_tablea,x
   1355  27000				   -	       lda	trackn_instrdb,x
   1356  27000				   -	       sta	_nt
   1357  27000				   -	       lda	trackn_instrhb,x
   1358  27000				   -	       sta	_nt+1
   1359  27000				   -	       ldy	trackn_tablea,x
   1360  27000				   -	       lda	(_nt),y
   1361  27000				   -	       IF	FEAT_TABLEMODE
   1362  27000				   -	       ldy	trackn_tablemode,x
   1363  27000				   -	       beq	ei2e
   1364  27000				   -	       clc
   1365  27000				   -	       adc	trackn_tablenote,x
   1366  27000				   -ei2e
   1367  27000				   -	       EIF
   1368  27000				   -	       sta	trackn_tablenote,x
   1369  27000				   -	       lda	trackn_tabletypespeed,x
   1370  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1371  27000				   -	       and	#$3f
   1372  27000				   -	       EIF
   1373  27000				   -ei2f
   1374  27000				   -	       sec
   1375  27000				   -	       sbc	#1
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -ei3
   1378  27000				   -	       lda	trackn_instrreachend,x
   1379  27000				   -	       bpl	ei4
   1380  27000				   -	       lda	trackn_volume,x
   1381  27000				   -	       beq	ei4
   1382  27000				   -	       cmp	trackn_volumemin,x
   1383  27000				   -	       beq	ei4
   1384  27000				   -	       bcc	ei4
   1385  27000				   -	       tay
   1386  27000				   -	       lda	trackn_volumeslidevalue,x
   1387  27000				   -	       clc
   1388  27000				   -	       adc	trackn_volumeslidedepth,x
   1389  27000				   -	       sta	trackn_volumeslidevalue,x
   1390  27000				   -	       bcc	ei4
   1391  27000				   -	       tya
   1392  27000				   -	       sbc	#16
   1393  27000				   -	       sta	trackn_volume,x
   1394  27000				   -ei4
   1395  27000				   -	       jmp	returnfromInstrumentsEffects
   1396  27000				   -
   1397  27000				   -rmtmoduleend
   1398  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1399  27000				   -	       echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1400  27000				   -
   1401  27000					       endif		; RMT
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1520  27000					       endif
   1521  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1523  27000					       endif
   1524  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -checkpokeyplaying
     19  27000				   -	       ldx	#6
     20  27000				   -checkpokeyplayingloop
     21  27000				   -	       lda	pokey1pointlo,x
     22  27000				   -	       ora	pokey1pointhi,x
     23  27000				   -	       beq	pokeychannelinactive
     24  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     25  27000				   -pokeychannelinactive
     26  27000				   -	       dex
     27  27000				   -	       dex
     28  27000				   -	       bpl	checkpokeyplayingloop
     29  27000				   -	       rts
     30  27000				   -
     31  27000				   -playpokeysfxA
     32  27000				   -	       txa
     33  27000				   -	       tay
     34  27000				   -	       lda	pokey1tick,x
     35  27000				   -	       beq	playpokeysfxAcont
     36  27000				   -	       sec
     37  27000				   -	       sbc	#1
     38  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  27000				   -	       rts
     40  27000				   -
     41  27000				   -playpokeysfxAcont
     42  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  27000				   -	       sta	pokey1tick,x
     44  27000				   -
     45  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  27000				   -	       beq	playpokeysfxAcont2
     47  27000				   -	       sec
     48  27000				   -	       sbc	#1
     49  27000				   -	       sta	pokey1priority,x
     50  27000				   -playpokeysfxAcont2
     51  27000				   -
     52  27000				   -			; *** FREQUENCY
     53  27000				   -	       lda	(pokey1pointlo,x)
     54  27000				   -	       sta	inttemp1
     55  27000				   -	       clc
     56  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     57  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     58  27000				   -
     59  27000				   -			;advance the data pointer +1
     60  27000				   -	       inc	pokey1pointlo,x
     61  27000				   -	       bne	skippokeyhiinc1
     62  27000				   -	       inc	pokey1pointhi,x
     63  27000				   -skippokeyhiinc1
     64  27000				   -
     65  27000				   -			; *** WAVE
     66  27000				   -	       lda	(pokey1pointlo,x)
     67  27000				   -	       asl
     68  27000				   -	       asl
     69  27000				   -	       asl
     70  27000				   -	       asl		; x16
     71  27000				   -
     72  27000				   -			;advance the data pointer +1
     73  27000				   -	       inc	pokey1pointlo,x
     74  27000				   -	       bne	skippokeyhiinc2
     75  27000				   -	       inc	pokey1pointhi,x
     76  27000				   -skippokeyhiinc2
     77  27000				   -
     78  27000				   -	       ora	(pokey1pointlo,x)
     79  27000				   -	       iny
     80  27000				   -	       sta	(pokeybaselo),y
     81  27000				   -
     82  27000				   -	       ora	inttemp1	; check if F|C|V=0
     83  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  27000				   -
     85  27000				   -			; advance the pointer +1, on to the next sound chunk
     86  27000				   -	       inc	pokey1pointlo,x
     87  27000				   -	       bne	skippokeyhiinc3
     88  27000				   -	       inc	pokey1pointhi,x
     89  27000				   -skippokeyhiinc3
     90  27000				   -	       rts
     91  27000				   -
     92  27000				   -zeropokeypoint
     93  27000				   -	       sta	pokey1pointlo,x
     94  27000				   -	       sta	pokey1pointhi,x
     95  27000				   -	       sta	pokey1priority,x
     96  27000				   -	       rts
     97  27000				   -
     98  27000				   -schedulepokeysfx
     99  27000				   -	       ldx	#6
    100  27000				   -schedulepokeysfxloop
    101  27000				   -	       lda	pokey1pointlo,x
    102  27000				   -	       ora	pokey1pointhi,x
    103  27000				   -	       bne	schedulespokeysearch
    104  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  27000				   -schedulespokeysearch
    106  27000				   -	       dex
    107  27000				   -	       dex
    108  27000				   -	       bpl	schedulepokeysfxloop
    109  27000				   -
    110  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    111  27000				   -	       ldy	#1
    112  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  27000				   -	       bne	schedulepokeysfxcont1
    114  27000				   -	       rts		; ...and skip it if it's 0 priority
    115  27000				   -schedulepokeysfxcont1
    116  27000				   -
    117  27000				   -			; figure out which current sound has the lowest priority...
    118  27000				   -	       lda	#0
    119  27000				   -	       sta	temp8
    120  27000				   -	       lda	pokey1priority
    121  27000				   -	       sta	temp9
    122  27000				   -	       ldx	#6
    123  27000				   -findlowprioritypokeyloop
    124  27000				   -	       lda	pokey1priority,x
    125  27000				   -	       cmp	temp9
    126  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    127  27000				   -	       sta	temp9
    128  27000				   -	       stx	temp8
    129  27000				   -findlowprioritypokeyloopcontinue
    130  27000				   -	       dex
    131  27000				   -	       dex
    132  27000				   -	       bne	findlowprioritypokeyloop
    133  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    134  27000				   -
    135  27000				   -schedulepokeyX
    136  27000				   -			;called with X=2*pokey channel to play on...
    137  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    138  27000				   -	       lda	(sfxinstrumentlo),y
    139  27000				   -	       sta	pokey1priority,x
    140  27000				   -	       iny
    141  27000				   -	       lda	(sfxinstrumentlo),y
    142  27000				   -	       sta	pokey1frames,x
    143  27000				   -
    144  27000				   -	       lda	sfxinstrumentlo
    145  27000				   -	       clc
    146  27000				   -	       adc	#3
    147  27000				   -	       sta	pokey1pointlo,x
    148  27000				   -	       lda	sfxinstrumenthi
    149  27000				   -	       adc	#0
    150  27000				   -	       sta	pokey1pointhi,x
    151  27000				   -	       lda	sfxpitchoffset
    152  27000				   -	       sta	pokey1offset,x
    153  27000				   -	       lda	#0
    154  27000				   -	       sta	pokey1tick,x
    155  27000				   -	       rts
    156  27000				   -
    157  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  27000				   -			; and the standard $4000 location.
    159  27000				   -			; if pokey the pokey is present, this routine will reset it.
    160  27000				   -	       ifconst	pokeyaddress
    161  27000				   -detectpokeylocation
    162  27000				   -	       lda	#<pokeyaddress
    163  27000				   -	       sta	pokeybaselo
    164  27000				   -	       lda	#>pokeyaddress
    165  27000				   -	       sta	pokeybasehi
    166  27000				   -	       lda	#$ff
    167  27000				   -	       sta	pokeydetected
    168  27000				   -
    169  27000				   -	       if	pokeyaddress = $450
    170  27000				   -	       lda	XCTRL1s
    171  27000				   -	       ora	#%00010100
    172  27000				   -	       sta	XCTRL1s
    173  27000				   -	       sta	XCTRL1
    174  27000				   -	       endif
    175  27000				   -
    176  27000				   -
    177  27000				   -	       lda	#0
    178  27000				   -	       ldy	#15
    179  27000				   -clearpokeyloop
    180  27000				   -	       sta	(pokeybase),y
    181  27000				   -	       dey
    182  27000				   -	       bpl	clearpokeyloop
    183  27000				   -			; take pokey out of reset...
    184  27000				   -	       ldy	#PSKCTL
    185  27000				   -	       lda	#3
    186  27000				   -	       sta	(pokeybase),y
    187  27000				   -	       ldy	#PAUDCTL
    188  27000				   -	       lda	#0
    189  27000				   -	       sta	(pokeybase),y
    190  27000				   -	       rts
    191  27000				   -	       else		; !pokeyaddress
    192  27000				   -detectpokeylocation
    193  27000				   -			;XBoard/XM...
    194  27000				   -	       ldx	#2
    195  27000				   -detectpokeyloop
    196  27000				   -	       lda	XCTRL1s
    197  27000				   -	       ora	#%00010100
    198  27000				   -	       and	POKEYXMMASK,x
    199  27000				   -	       sta	XCTRL1s
    200  27000				   -	       sta	XCTRL1
    201  27000				   -
    202  27000				   -	       lda	POKEYCHECKLO,x
    203  27000				   -	       sta	pokeybaselo
    204  27000				   -	       lda	POKEYCHECKHI,x
    205  27000				   -	       sta	pokeybasehi
    206  27000				   -	       jsr	checkforpokey
    207  27000				   -	       lda	pokeydetected
    208  27000				   -	       beq	foundpokeychip
    209  27000				   -	       dex
    210  27000				   -	       bpl	detectpokeyloop
    211  27000				   -foundpokeychip
    212  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    213  27000				   -	       sta	pokeydetected
    214  27000				   -	       rts
    215  27000				   -
    216  27000				   -POKEYXMMASK
    217  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    218  27000				   -	       .byte	%11111111, %11101111, %11101111
    219  27000				   -
    220  27000				   -POKEYCHECKLO
    221  27000				   -	       .byte	<$0450, <$0450, <$4000
    222  27000				   -POKEYCHECKHI
    223  27000				   -	       .byte	>$0450, >$0450, >$4000
    224  27000				   -
    225  27000				   -checkforpokey
    226  27000				   -	       ldy	#$0f
    227  27000				   -	       lda	#$00
    228  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    229  27000				   -resetpokeyregistersloop
    230  27000				   -	       sta	(pokeybase),y
    231  27000				   -	       dey
    232  27000				   -	       bpl	resetpokeyregistersloop
    233  27000				   -
    234  27000				   -	       ldy	#PAUDCTL
    235  27000				   -	       sta	(pokeybase),y
    236  27000				   -	       ldy	#PSKCTL
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -
    239  27000				   -			; let the dust settle...
    240  27000				   -	       nop
    241  27000				   -	       nop
    242  27000				   -	       nop
    243  27000				   -
    244  27000				   -	       lda	#4
    245  27000				   -	       sta	temp9
    246  27000				   -pokeycheckloop1
    247  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    248  27000				   -	       ldy	#PRANDOM
    249  27000				   -	       lda	(pokeybase),y
    250  27000				   -	       cmp	#$ff
    251  27000				   -	       bne	nopokeydetected
    252  27000				   -	       dec	temp9
    253  27000				   -	       bne	pokeycheckloop1
    254  27000				   -
    255  27000				   -			; take pokey out of reset...
    256  27000				   -	       ldy	#PSKCTL
    257  27000				   -	       lda	#3
    258  27000				   -	       sta	(pokeybase),y
    259  27000				   -	       ldy	#PAUDCTL
    260  27000				   -	       lda	#0
    261  27000				   -	       sta	(pokeybase),y
    262  27000				   -
    263  27000				   -			; let the dust settle again...
    264  27000				   -	       nop
    265  27000				   -	       nop
    266  27000				   -	       nop
    267  27000				   -
    268  27000				   -	       lda	#4
    269  27000				   -	       sta	temp9
    270  27000				   -pokeycheckloop2
    271  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    272  27000				   -	       ldy	#PRANDOM
    273  27000				   -	       lda	(pokeybase),y
    274  27000				   -	       cmp	#$ff
    275  27000				   -	       beq	skippokeycheckreturn
    276  27000				   -	       rts
    277  27000				   -skippokeycheckreturn
    278  27000				   -	       dec	temp9
    279  27000				   -	       bne	pokeycheckloop2
    280  27000				   -nopokeydetected
    281  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    282  27000				   -	       rts
    283  27000				   -
    284  27000				   -	       endif		; !pokeyaddress
    285  27000				   -
    286  27000				   -pokeysoundmoduleend
    287  27000				   -
    288  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes)"
    289  27000				   -
    290  27000					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1526  27000					       endif
   1527  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       lda	songtempo
     15  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     16  27000				   -servicesongcontinue
     17  27000				   -	       lda	sfxschedulelock
     18  27000				   -	       sta	sfxschedulemissed
     19  27000				   -	       bne	servicesongover
     20  27000				   -	       lda	songtempo
     21  27000				   -	       clc
     22  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     23  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     24  27000				   -	       bcc	servicesongover
     25  27000				   -			; ** if we're here a new 16th note has passed
     26  27000				   -			; ** check if a new note is due on any of the 4 channels
     27  27000				   -servicesongredo
     28  27000				   -	       ldx	#3
     29  27000				   -checkchannelloop
     30  27000				   -	       dec	songchannel1busywait,x
     31  27000				   -	       bpl	carryoncheckingchannel
     32  27000				   -	       txa
     33  27000				   -	       pha		; save X for the loop
     34  27000				   -	       jsr	processsongdata
     35  27000				   -	       pla		; restore X for the loop
     36  27000				   -	       tax
     37  27000				   -carryoncheckingchannel
     38  27000				   -	       dex
     39  27000				   -	       bpl	checkchannelloop
     40  27000				   -	       lda	inactivechannelcount
     41  27000				   -	       cmp	#15
     42  27000				   -	       bne	skipstopsong
     43  27000				   -	       lda	songloops
     44  27000				   -	       bne	doasongloop
     45  27000				   -			;lda #0
     46  27000				   -	       sta	songtempo	; all channels are done. stop the song
     47  27000				   -	       rts
     48  27000				   -doasongloop
     49  27000				   -	       bmi	skipsongloopadjust
     50  27000				   -	       dec	songloops
     51  27000				   -skipsongloopadjust
     52  27000				   -	       jsr	setsongchannels
     53  27000				   -	       jmp	servicesongredo
     54  27000				   -skipstopsong
     55  27000				   -	       rts
     56  27000				   -
     57  27000				   -processsongdata
     58  27000				   -			; channel needs processing
     59  27000				   -			; X=channel #
     60  27000				   -
     61  27000				   -	       txa
     62  27000				   -	       clc
     63  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  27000				   -	       tay
     65  27000				   -
     66  27000				   -
     67  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     68  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     69  27000				   -	       lda	songchannel1layer1lo,y
     70  27000				   -	       sta	songdatalo
     71  27000				   -	       lda	songchannel1layer1hi,y
     72  27000				   -	       sta	songdatahi
     73  27000				   -	       ora	songdatalo
     74  27000				   -	       bne	channelhasdata
     75  27000				   -			;channel data is pointing at $0000
     76  27000				   -	       lda	#$7F
     77  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     78  27000				   -setchannelcountbits
     79  27000				   -	       lda	channel2bits,x
     80  27000				   -	       ora	inactivechannelcount
     81  27000				   -	       sta	inactivechannelcount
     82  27000				   -	       rts
     83  27000				   -channelhasdata
     84  27000				   -
     85  27000				   -	       sty	songstackindex
     86  27000				   -	       ldy	#0
     87  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  27000				   -	       cmp	#$ff
     89  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  27000				   -	       jmp	handlechannelEOD
     91  27000				   -
     92  27000				   -carryoncheckingdatatype
     93  27000				   -	       and	#$F0
     94  27000				   -	       cmp	#$C0
     95  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
     96  27000				   -	       cmp	#$F0
     97  27000				   -	       beq	handlemultibytecommand
     98  27000				   -	       cmp	#$D0
     99  27000				   -	       beq	handlesemiup
    100  27000				   -	       cmp	#$E0
    101  27000				   -	       beq	handlesemidown
    102  27000				   -handlenotedata
    103  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    104  27000				   -
    105  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    106  27000				   -
    107  27000				   -			; ** set the note length
    108  27000				   -	       lda	(songdatalo),y
    109  27000				   -	       and	#$0F
    110  27000				   -	       sta	songchannel1busywait,x
    111  27000				   -
    112  27000				   -			; ** load the instrument
    113  27000				   -	       lda	songchannel1instrumentlo,x
    114  27000				   -	       sta	sfxinstrumentlo
    115  27000				   -	       lda	songchannel1instrumenthi,x
    116  27000				   -	       sta	sfxinstrumenthi
    117  27000				   -
    118  27000				   -			; ** get the note, and transpose
    119  27000				   -	       lda	(songdatalo),y
    120  27000				   -	       lsr
    121  27000				   -	       lsr
    122  27000				   -	       lsr
    123  27000				   -	       lsr
    124  27000				   -	       clc
    125  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    126  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    127  27000				   -	       sta	sfxnoteindex
    128  27000				   -
    129  27000				   -	       lda	#0
    130  27000				   -	       sta	sfxpitchoffset
    131  27000				   -
    132  27000				   -	       jsr	schedulesfx
    133  27000				   -
    134  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  27000				   -
    136  27000				   -handlechannelrest
    137  27000				   -			; ** set the note length
    138  27000				   -	       lda	(songdatalo),y
    139  27000				   -	       and	#$0F
    140  27000				   -	       sta	songchannel1busywait,x
    141  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  27000				   -
    143  27000				   -handlesemiup
    144  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  27000				   -	       clc
    147  27000				   -handlesemidownentry
    148  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    149  27000				   -	       sta	songchannel1transpose,x
    150  27000				   -	       jsr	advancethesongpointer1byte
    151  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  27000				   -
    153  27000				   -handlesemidown
    154  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  27000				   -	       sec
    158  27000				   -	       jmp	handlesemidownentry
    159  27000				   -
    160  27000				   -handlemultibytecommand
    161  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  27000				   -	       cmp	#$08	; ** load new instrument?
    164  27000				   -	       bne	nothandleinstrumentchange
    165  27000				   -handleinstrumentchange
    166  27000				   -	       iny
    167  27000				   -	       lda	(songdatalo),y
    168  27000				   -	       sta	songchannel1instrumentlo,x
    169  27000				   -	       iny
    170  27000				   -	       lda	(songdatalo),y
    171  27000				   -	       sta	songchannel1instrumenthi,x
    172  27000				   -	       lda	#3
    173  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  27000				   -	       jmp	processsongdata
    175  27000				   -
    176  27000				   -nothandleinstrumentchange
    177  27000				   -	       cmp	#$09	; ** absolute tempo change?
    178  27000				   -	       bne	nothandletempochange
    179  27000				   -	       lda	#0
    180  27000				   -	       sta	songtempo
    181  27000				   -handlerelativetempochange
    182  27000				   -	       iny
    183  27000				   -	       lda	(songdatalo),y
    184  27000				   -	       clc
    185  27000				   -	       adc	songtempo
    186  27000				   -	       sta	songtempo
    187  27000				   -	       lda	#2
    188  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  27000				   -	       jmp	processsongdata
    190  27000				   -
    191  27000				   -nothandletempochange
    192  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    193  27000				   -	       beq	handlerelativetempochange
    194  27000				   -	       cmp	#$0B	; ** octave/semi change?
    195  27000				   -	       beq	handleoctavesemichange
    196  27000				   -handlepatterndata
    197  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    198  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    199  27000				   -
    200  27000				   -	       lda	#4
    201  27000				   -	       clc
    202  27000				   -	       adc	songchannel1stackdepth,x
    203  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  27000				   -
    205  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    206  27000				   -	       lda	songstackindex
    207  27000				   -	       adc	#4
    208  27000				   -	       tax
    209  27000				   -
    210  27000				   -	       lda	(songdatalo),y
    211  27000				   -	       and	#$7
    212  27000				   -	       sta	songchannel1layer1loops,x
    213  27000				   -	       iny
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       sta	songchannel1layer1lo,x
    216  27000				   -	       iny
    217  27000				   -	       lda	(songdatalo),y
    218  27000				   -	       sta	songchannel1layer1hi,x
    219  27000				   -
    220  27000				   -	       ldx	inttemp6	; restore x with the channel #
    221  27000				   -
    222  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  27000				   -	       lda	#3
    224  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  27000				   -
    226  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  27000				   -	       jmp	processsongdata
    228  27000				   -
    229  27000				   -handlechannelEOD
    230  27000				   -			; ** check if there are loops remaining on the pattern
    231  27000				   -	       stx	inttemp6
    232  27000				   -	       ldx	songstackindex
    233  27000				   -	       dec	songchannel1layer1loops,x
    234  27000				   -	       bmi	handlechannelEODnoloop
    235  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  27000				   -	       iny
    237  27000				   -	       lda	(songdatalo),y
    238  27000				   -	       sta	songchannel1layer1lo,x
    239  27000				   -	       iny
    240  27000				   -	       lda	(songdatalo),y
    241  27000				   -	       sta	songchannel1layer1hi,x
    242  27000				   -	       ldx	inttemp6
    243  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  27000				   -
    245  27000				   -handlechannelEODnoloop
    246  27000				   -			; this pattern/loop is done playing. "pop" the stack
    247  27000				   -	       ldx	inttemp6
    248  27000				   -	       lda	songchannel1stackdepth,x
    249  27000				   -	       beq	handlerootchannelEOD
    250  27000				   -	       sec
    251  27000				   -	       sbc	#4
    252  27000				   -	       sta	songchannel1stackdepth,x
    253  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  27000				   -
    255  27000				   -handlerootchannelEOD
    256  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  27000				   -	       lda	#0
    258  27000				   -	       sta	songchannel1layer1lo,x
    259  27000				   -	       sta	songchannel1layer1hi,x
    260  27000				   -	       sta	songchannel1busywait,x
    261  27000				   -	       jmp	setchannelcountbits
    262  27000				   -	       rts
    263  27000				   -
    264  27000				   -nothandlepatternchange
    265  27000				   -handleoctavesemichange
    266  27000				   -	       iny
    267  27000				   -	       lda	(songdatalo),y
    268  27000				   -	       sta	songchannel1transpose,x
    269  27000				   -	       lda	#2
    270  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  27000				   -	       jmp	processsongdata
    272  27000				   -
    273  27000				   -advancethesongpointer1byte
    274  27000				   -	       txa
    275  27000				   -	       ldx	songstackindex
    276  27000				   -	       inc	songchannel1layer1lo,x
    277  27000				   -	       bne	skiphiadvancethesongpointer1byte
    278  27000				   -	       inc	songchannel1layer1hi,x
    279  27000				   -skiphiadvancethesongpointer1byte
    280  27000				   -	       tax
    281  27000				   -	       rts
    282  27000				   -
    283  27000				   -advancethesongpointerNbytes
    284  27000				   -			; entered with A=# of byte to advance
    285  27000				   -	       stx	inttemp6
    286  27000				   -	       ldx	songstackindex
    287  27000				   -	       clc
    288  27000				   -	       adc	songchannel1layer1lo,x
    289  27000				   -	       sta	songchannel1layer1lo,x
    290  27000				   -	       lda	#0
    291  27000				   -	       adc	songchannel1layer1hi,x
    292  27000				   -	       sta	songchannel1layer1hi,x
    293  27000				   -	       ldx	inttemp6
    294  27000				   -	       rts
    295  27000				   -
    296  27000				   -clearsongmemory
    297  27000				   -	       lda	#0
    298  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  27000				   -clearsongmemoryloop1
    300  27000				   -	       sta	songchannel1layer1lo,x
    301  27000				   -	       dex
    302  27000				   -	       bpl	clearsongmemoryloop1
    303  27000				   -
    304  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  27000				   -clearsongmemoryloop2
    306  27000				   -	       sta	songchannel1layer1loops,x
    307  27000				   -	       dex
    308  27000				   -	       bpl	clearsongmemoryloop2
    309  27000				   -
    310  27000				   -	       lda	#$ff
    311  27000				   -	       ldx	#3
    312  27000				   -clearsongmemoryloop3
    313  27000				   -	       sta	songchannel1busywait,x
    314  27000				   -	       dex
    315  27000				   -	       bpl	clearsongmemoryloop3
    316  27000				   -	       rts
    317  27000				   -
    318  27000				   -setsongchannels
    319  27000				   -	       jsr	clearsongmemory
    320  27000				   -	       ldy	#7
    321  27000				   -	       ldx	#3
    322  27000				   -setsongchannelsloop
    323  27000				   -	       lda	(songpointerlo),y
    324  27000				   -	       sta	songchannel1layer1hi,x
    325  27000				   -	       dey
    326  27000				   -	       lda	(songpointerlo),y
    327  27000				   -	       sta	songchannel1layer1lo,x
    328  27000				   -	       dex
    329  27000				   -	       dey
    330  27000				   -	       bpl	setsongchannelsloop
    331  27000				   -	       rts
    332  27000				   -
    333  27000				   -channel2bits
    334  27000				   -	       .byte	1,2,4,8
    335  27000				   -
    336  27000				   -tiatrackeroctavenotes
    337  27000				   -	       ifconst	BUZZBASS
    338  27000				   -LOWC       =	15
    339  27000				   -	       else
    340  27000				   -LOWC       =	14
    341  27000				   -	       endif
    342  27000				   -			; ****** ELECTRONIC (0 to 11)
    343  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    344  27000				   -	       .byte	LOWC,18	; c#0
    345  27000				   -	       .byte	LOWC,17	; d0
    346  27000				   -	       .byte	LOWC,16	; d#0
    347  27000				   -	       .byte	LOWC,15	; e0
    348  27000				   -	       .byte	LOWC,14	; f0  (very off)
    349  27000				   -	       .byte	LOWC,14	; f#0
    350  27000				   -	       .byte	LOWC,13	; g0
    351  27000				   -	       .byte	LOWC,12	; g#0
    352  27000				   -	       .byte	LOWC,11	; a0
    353  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    354  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    355  27000				   -
    356  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  27000				   -	       .byte	6,30	; c1	 32.7Hz
    358  27000				   -	       .byte	6,28	; c#1
    359  27000				   -	       .byte	6,27	; d1
    360  27000				   -	       .byte	6,25	; d#1
    361  27000				   -	       .byte	6,24	; e1
    362  27000				   -	       .byte	6,22	; f1
    363  27000				   -	       .byte	6,21	; f#1
    364  27000				   -	       .byte	6,20	; g1
    365  27000				   -	       .byte	6,18	; g#1
    366  27000				   -	       .byte	6,17	; a1
    367  27000				   -	       .byte	6,16	; a#1
    368  27000				   -	       .byte	6,15	; b1	 63.4Hz
    369  27000				   -
    370  27000				   -			; ****** BUZZY (24 to 39)
    371  27000				   -	       .byte	1,31	; c2	 65.5
    372  27000				   -	       .byte	1,30	; c#2	 67.6
    373  27000				   -	       .byte	1,27	; d2	 72.3
    374  27000				   -	       .byte	1,26	; d#2	 77.6
    375  27000				   -	       .byte	1,24	; e2
    376  27000				   -	       .byte	1,23	; f2
    377  27000				   -	       .byte	1,22	; f#2
    378  27000				   -	       .byte	1,20	; g2
    379  27000				   -	       .byte	1,19	; g#2
    380  27000				   -	       .byte	1,18	; a2
    381  27000				   -	       .byte	1,17	; a#2
    382  27000				   -	       .byte	1,16	; b2
    383  27000				   -	       .byte	1,15	; c3	126.8Hz
    384  27000				   -	       .byte	1,14	; c#3
    385  27000				   -	       .byte	1,13	; d3	149.7Hz
    386  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    387  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    388  27000				   -	       .byte	12,31	; e3	163.8Hz
    389  27000				   -	       .byte	12,29	; f3
    390  27000				   -	       .byte	12,28	; f#3
    391  27000				   -	       .byte	12,26	; g3
    392  27000				   -	       .byte	12,24	; g#3
    393  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  27000				   -	       .byte	12,22	; a#3
    395  27000				   -	       .byte	12,20	; b3
    396  27000				   -	       .byte	12,19	; c4  (middle C)
    397  27000				   -	       .byte	12,18	; c#4
    398  27000				   -	       .byte	12,17	; d4
    399  27000				   -	       .byte	12,16	; d#4
    400  27000				   -	       .byte	12,15	; e4
    401  27000				   -	       .byte	12,14	; f4
    402  27000				   -	       .byte	12,13	; f#4
    403  27000				   -	       .byte	12,12	; g4  (very off)
    404  27000				   -	       .byte	12,12	; g#4
    405  27000				   -	       .byte	12,11	; a4
    406  27000				   -	       .byte	12,10	; a#4
    407  27000				   -	       .byte	4,31	; b4
    408  27000				   -	       .byte	4,29	; c5
    409  27000				   -	       .byte	4,28	; c#5
    410  27000				   -	       .byte	4,26	; d5
    411  27000				   -	       .byte	4,24	; d#5
    412  27000				   -	       .byte	4,23	; e5
    413  27000				   -	       .byte	4,22	; f5
    414  27000				   -	       .byte	4,20	; f#5
    415  27000				   -	       .byte	4,19	; g5
    416  27000				   -	       .byte	4,18	; g#5
    417  27000				   -	       .byte	4,17	; a5
    418  27000				   -	       .byte	4,16	; a#5
    419  27000				   -	       .byte	4,15	; b5
    420  27000				   -
    421  27000				   -			; ****** TUNED WIND (72 to 83)
    422  27000				   -	       .byte	8,30	; c
    423  27000				   -	       .byte	8,28	; c#
    424  27000				   -	       .byte	8,27	; d
    425  27000				   -	       .byte	8,25	; d#
    426  27000				   -	       .byte	8,24	; e
    427  27000				   -	       .byte	8,22	; f
    428  27000				   -	       .byte	8,21	; f#
    429  27000				   -	       .byte	8,20	; g
    430  27000				   -	       .byte	8,18	; g#
    431  27000				   -	       .byte	8,17	; a
    432  27000				   -	       .byte	8,16	; a#
    433  27000				   -	       .byte	8,15	; b
    434  27000				   -
    435  27000				   -	       include	"tiadrumkit.asm"
    436  27000				   -
    437  27000				   -trackerend
    438  27000				   -
    439  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  27000				   -
    441  27000					       endif		;MUSICTRACKER
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1529  27000					       endif
   1530  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -	       ifconst	BANKSETROM
      6  27000				   -	       ifconst	isBANKSETBANK
      7  27000				   -HSCHARSHERE =	1
      8  27000				   -	       endif
      9  27000				   -	       else		; !BANKSETROM so embed the character strings
     10  27000				   -HSCHARSHERE =	1
     11  27000				   -	       endif
     12  27000				   -
     13  27000				   -	       ifnconst	isBANKSETBANK
     14  27000				   -hiscorestart
     15  27000				   -
     16  27000				   -detectatarivoxeeprom
     17  27000				   -hiscoremodulestart
     18  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  27000				   -	       jsr	AVoxDetect
     20  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  27000				   -	       sta	avoxdetected
     22  27000				   -	       lda	#$0
     23  27000				   -	       sta	SWACNT
     24  27000				   -	       lda	avoxdetected
     25  27000				   -	       rts
     26  27000				   -
     27  27000				   -detecthsc
     28  27000				   -			; check for the HSC ROM signature...
     29  27000				   -	       lda	XCTRL1s
     30  27000				   -	       ora	#%00001100
     31  27000				   -	       sta	XCTRL1s
     32  27000				   -	       sta	XCTRL1
     33  27000				   -	       lda	$3900
     34  27000				   -	       eor	#$C6
     35  27000				   -	       bne	detecthscfail
     36  27000				   -	       lda	$3904
     37  27000				   -	       eor	#$FE
     38  27000				   -	       bne	detecthscfail
     39  27000				   -			; check if it's initialized...
     40  27000				   -	       ldy	#0
     41  27000				   -	       lda	#$ff
     42  27000				   -checkhscinit
     43  27000				   -	       and	$1000,y
     44  27000				   -	       dey
     45  27000				   -	       bpl	checkhscinit
     46  27000				   -	       cmp	#$ff
     47  27000				   -	       bne	hscisalreadyinit
     48  27000				   -			; if we're here, we need to do a minimal HSC init...
     49  27000				   -	       ldy	#$28
     50  27000				   -hscinitloop1
     51  27000				   -	       lda	hscheader,y
     52  27000				   -	       sta	$1000,y
     53  27000				   -	       dey
     54  27000				   -	       bpl	hscinitloop1
     55  27000				   -	       ldy	#$89
     56  27000				   -	       lda	#$7F
     57  27000				   -hscinitloop2
     58  27000				   -	       sta	$10B3,y
     59  27000				   -	       dey
     60  27000				   -	       cpy	#$ff
     61  27000				   -	       bne	hscinitloop2
     62  27000				   -hscisalreadyinit
     63  27000				   -	       lda	#$ff
     64  27000				   -	       rts
     65  27000				   -hscheader
     66  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     67  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     68  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     69  27000				   -detecthscfail
     70  27000				   -	       lda	XCTRL1s
     71  27000				   -	       and	#%11110111
     72  27000				   -	       sta	XCTRL1s
     73  27000				   -	       lda	#0
     74  27000				   -	       rts
     75  27000				   -	       endif		; isBANKSETBANK
     76  27000				   -
     77  27000				   -	       ifnconst	hiscorefont
     78  27000				   -	       echo	""
     79  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     80  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     81  27000				   -	       echo	" has been omitted from this build."
     82  27000				   -	       echo	""
     83  27000				   -	       else		; hiscorefont
     84  27000				   -	       ifnconst	isBANKSETBANK
     85  27000				   -hscdrawscreen
     86  27000				   -
     87  27000				   -			; we use 20 lines on a 24 line display
     88  27000				   -			; HSSCOREY to dynamically centers based on
     89  27000				   -			;HSSCOREY = 0
     90  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     91  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     92  27000				   -
     93  27000				   -	       ifconst	HSSCORESIZE
     94  27000				   -SCORESIZE  =	HSSCORESIZE
     95  27000				   -	       else
     96  27000				   -SCORESIZE  =	6
     97  27000				   -	       endif
     98  27000				   -
     99  27000				   -			;save shadow registers for later return...
    100  27000				   -	       lda	sCTRL
    101  27000				   -	       sta	ssCTRL
    102  27000				   -	       lda	sCHARBASE
    103  27000				   -	       sta	ssCHARBASE
    104  27000				   -	       lda	#$60
    105  27000				   -	       sta	charactermode
    106  27000				   -	       jsr	drawwait
    107  27000				   -	       jsr	blacken320colors
    108  27000				   -	       jsr	clearscreen
    109  27000				   -
    110  27000				   -			;set the character base to the HSC font
    111  27000				   -	       lda	#>hiscorefont
    112  27000				   -	       sta	CHARBASE
    113  27000				   -	       sta	sCHARBASE
    114  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    115  27000				   -	       sta	CTRL
    116  27000				   -	       sta	sCTRL
    117  27000				   -
    118  27000				   -	       lda	#60
    119  27000				   -	       sta	hsjoydebounce
    120  27000				   -
    121  27000				   -	       lda	#0
    122  27000				   -	       sta	hscursorx
    123  27000				   -	       sta	framecounter
    124  27000				   -	       ifnconst	HSCOLORCHASESTART
    125  27000				   -	       lda	#$8D	; default is blue. why not?
    126  27000				   -	       else
    127  27000				   -	       lda	#HSCOLORCHASESTART
    128  27000				   -	       endif
    129  27000				   -	       sta	hscolorchaseindex
    130  27000				   -
    131  27000				   -	       lda	#$0F
    132  27000				   -	       sta	P0C2	; base text is white
    133  27000				   -
    134  27000				   -	       jsr	hschasecolors
    135  27000				   -			; ** plot all of the initials
    136  27000				   -	       lda	#<HSRAMInitials
    137  27000				   -	       sta	temp1	; charmaplo
    138  27000				   -	       lda	#>HSRAMInitials
    139  27000				   -	       sta	temp2	; charmaphi
    140  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    141  27000				   -	       sta	temp3	; palette/width
    142  27000				   -	       lda	#104
    143  27000				   -	       sta	temp4	; X
    144  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    145  27000				   -	       sta	temp5	; Y
    146  27000				   -plothsinitialsloop
    147  27000				   -	       jsr	plotcharacters
    148  27000				   -	       clc
    149  27000				   -	       lda	temp3
    150  27000				   -	       adc	#32
    151  27000				   -	       sta	temp3
    152  27000				   -	       inc	temp5
    153  27000				   -	       if	WZONEHEIGHT = 8
    154  27000				   -	       inc	temp5
    155  27000				   -	       endif
    156  27000				   -	       clc
    157  27000				   -	       lda	#3
    158  27000				   -	       adc	temp1
    159  27000				   -	       sta	temp1
    160  27000				   -	       cmp	#(<(HSRAMInitials+15))
    161  27000				   -	       bcc	plothsinitialsloop
    162  27000				   -
    163  27000				   -	       ifconst	HSGAMENAMELEN
    164  27000				   -			;plot the game name...
    165  27000				   -	       lda	#<HSGAMENAMEtable
    166  27000				   -	       sta	temp1	; charmaplo
    167  27000				   -	       lda	#>HSGAMENAMEtable
    168  27000				   -	       sta	temp2	; charmaphi
    169  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    170  27000				   -	       sta	temp3	; palette/width
    171  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    172  27000				   -	       sta	temp4	; X
    173  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    174  27000				   -	       sta	temp5	; Y
    175  27000				   -	       jsr	plotcharacters
    176  27000				   -	       endif		; HSGAMENAMELEN
    177  27000				   -
    178  27000				   -			;plot "difficulty"...
    179  27000				   -	       ldy	gamedifficulty
    180  27000				   -	       ifnconst	HSNOLEVELNAMES
    181  27000				   -	       lda	highscoredifficultytextlo,y
    182  27000				   -	       sta	temp1
    183  27000				   -	       lda	highscoredifficultytexthi,y
    184  27000				   -	       sta	temp2
    185  27000				   -	       sec
    186  27000				   -	       lda	#32
    187  27000				   -	       sbc	highscoredifficultytextlen,y
    188  27000				   -	       sta	temp3	; palette/width
    189  27000				   -	       sec
    190  27000				   -	       lda	#40
    191  27000				   -	       sbc	highscoredifficultytextlen,y
    192  27000				   -	       asl
    193  27000				   -	       sta	temp4	; X
    194  27000				   -	       else
    195  27000				   -	       lda	#<HSHIGHSCOREStext
    196  27000				   -	       sta	temp1	; charmaplo
    197  27000				   -	       lda	#>HSHIGHSCOREStext
    198  27000				   -	       sta	temp2	; charmaphi
    199  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    200  27000				   -	       sta	temp3	; palette/width
    201  27000				   -	       lda	#(80-(11*2))
    202  27000				   -	       sta	temp4	; X
    203  27000				   -	       endif		; HSNOLEVELNAMES
    204  27000				   -
    205  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    206  27000				   -	       sta	temp5	; Y
    207  27000				   -	       jsr	plotcharacters
    208  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    209  27000				   -	       bne	carronwithscoreevaluation
    210  27000				   -	       jmp	donoscoreevaluation
    211  27000				   -carronwithscoreevaluation
    212  27000				   -	       dey
    213  27000				   -	       lda	highscorelabeltextlo,y
    214  27000				   -	       sta	temp1
    215  27000				   -	       lda	highscorelabeltexthi,y
    216  27000				   -	       sta	temp2
    217  27000				   -	       sec
    218  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    219  27000				   -	       sta	temp3	; palette/width
    220  27000				   -	       lda	highscorelabeladjust1,y
    221  27000				   -	       sta	temp4	; X
    222  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    223  27000				   -	       sta	temp5	; Y
    224  27000				   -	       jsr	plotcharacters
    225  27000				   -
    226  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    227  27000				   -	       dey
    228  27000				   -			;plot the current player score...
    229  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    230  27000				   -	       sta	temp3	; palette/width
    231  27000				   -	       lda	highscorelabeladjust2,y
    232  27000				   -	       sta	temp4	; X
    233  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    234  27000				   -	       sta	temp5	; Y
    235  27000				   -
    236  27000				   -	       lda	scorevarlo,y
    237  27000				   -	       sta	temp7	; score variable lo
    238  27000				   -	       lda	scorevarhi,y
    239  27000				   -	       sta	temp8	; score variable hi
    240  27000				   -
    241  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    242  27000				   -	       sta	temp9
    243  27000				   -
    244  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    245  27000				   -	       sta	temp1	; charmaplo
    246  27000				   -	       lda	#>(hiscorefont+33)
    247  27000				   -	       sta	temp2	; charmaphi
    248  27000				   -	       lda	#SCORESIZE
    249  27000				   -	       sta	temp6
    250  27000				   -	       ifnconst	DOUBLEWIDE
    251  27000				   -	       jsr	plotvalue
    252  27000				   -	       else
    253  27000				   -	       jsr	plotvaluedw
    254  27000				   -	       endif
    255  27000				   -
    256  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    257  27000				   -
    258  27000				   -	       ifconst	HSGAMERANKS
    259  27000				   -
    260  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    261  27000				   -comparescore2rankloop
    262  27000				   -	       inx
    263  27000				   -	       ldy	#0
    264  27000				   -	       lda	rankvalue_0,x
    265  27000				   -	       cmp	(temp7),y
    266  27000				   -	       bcc	score2rankloopdone
    267  27000				   -	       bne	comparescore2rankloop
    268  27000				   -	       iny
    269  27000				   -	       lda	rankvalue_1,x
    270  27000				   -	       cmp	(temp7),y
    271  27000				   -	       bcc	score2rankloopdone
    272  27000				   -	       bne	comparescore2rankloop
    273  27000				   -	       iny
    274  27000				   -	       lda	(temp7),y
    275  27000				   -	       cmp	rankvalue_2,x
    276  27000				   -	       bcs	score2rankloopdone
    277  27000				   -	       jmp	comparescore2rankloop
    278  27000				   -score2rankloopdone
    279  27000				   -	       stx	hsnewscorerank
    280  27000				   -
    281  27000				   -	       lda	ranklabello,x
    282  27000				   -	       sta	temp1
    283  27000				   -	       lda	ranklabelhi,x
    284  27000				   -	       sta	temp2
    285  27000				   -	       sec
    286  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    287  27000				   -	       sbc	ranklabellengths,x
    288  27000				   -	       sta	temp3	; palette/width
    289  27000				   -	       sec
    290  27000				   -	       lda	#(40+6)
    291  27000				   -	       sbc	ranklabellengths,x
    292  27000				   -	       asl
    293  27000				   -	       sta	temp4	; X
    294  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    295  27000				   -	       sta	temp5	; Y
    296  27000				   -	       jsr	plotcharacters
    297  27000				   -
    298  27000				   -	       ldx	hsnewscorerank
    299  27000				   -
    300  27000				   -	       lda	#<highscoreranklabel
    301  27000				   -	       sta	temp1
    302  27000				   -	       lda	#>highscoreranklabel
    303  27000				   -	       sta	temp2
    304  27000				   -
    305  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    306  27000				   -	       sta	temp3	; palette/width
    307  27000				   -	       lda	#(40-6)
    308  27000				   -	       sec
    309  27000				   -	       sbc	ranklabellengths,x
    310  27000				   -	       asl
    311  27000				   -	       sta	temp4	; X
    312  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    313  27000				   -	       sta	temp5	; Y
    314  27000				   -	       jsr	plotcharacters
    315  27000				   -	       endif		; HSGAMERANKS
    316  27000				   -
    317  27000				   -
    318  27000				   -			; ** which line did this player beat?
    319  27000				   -	       lda	#$ff
    320  27000				   -	       sta	hsnewscoreline
    321  27000				   -	       ldx	#$fd
    322  27000				   -comparescoreadd2x
    323  27000				   -	       inx
    324  27000				   -comparescoreadd1x
    325  27000				   -	       inx
    326  27000				   -comparescore2lineloop
    327  27000				   -	       inc	hsnewscoreline
    328  27000				   -	       inx		; initialrun, x=0
    329  27000				   -	       cpx	#15
    330  27000				   -	       beq	nohighscoreforyou
    331  27000				   -	       ldy	#0
    332  27000				   -	       lda	HSRAMScores,x
    333  27000				   -	       cmp	(temp7),y	; first score digit
    334  27000				   -	       bcc	score2lineloopdonedel1x
    335  27000				   -	       bne	comparescoreadd2x
    336  27000				   -	       iny
    337  27000				   -	       inx
    338  27000				   -	       lda	HSRAMScores,x
    339  27000				   -	       cmp	(temp7),y
    340  27000				   -	       bcc	score2lineloopdonedel2x
    341  27000				   -	       bne	comparescoreadd1x
    342  27000				   -	       iny
    343  27000				   -	       inx
    344  27000				   -	       lda	(temp7),y
    345  27000				   -	       cmp	HSRAMScores,x
    346  27000				   -	       bcs	score2lineloopdonedel3x
    347  27000				   -	       jmp	comparescore2lineloop
    348  27000				   -nohighscoreforyou
    349  27000				   -	       lda	#$ff
    350  27000				   -	       sta	hsnewscoreline
    351  27000				   -	       sta	countdownseconds
    352  27000				   -	       jmp	donoscoreevaluation
    353  27000				   -score2lineloopdonedel3x
    354  27000				   -	       dex
    355  27000				   -score2lineloopdonedel2x
    356  27000				   -	       dex
    357  27000				   -score2lineloopdonedel1x
    358  27000				   -	       dex
    359  27000				   -
    360  27000				   -			; 0 1 2
    361  27000				   -			; 3 4 5
    362  27000				   -			; 6 7 8
    363  27000				   -			; 9 0 1
    364  27000				   -			; 2 3 4
    365  27000				   -
    366  27000				   -	       stx	temp9
    367  27000				   -	       cpx	#11
    368  27000				   -	       beq	postsortscoresuploop
    369  27000				   -	       ldx	#11
    370  27000				   -sortscoresuploop
    371  27000				   -	       lda	HSRAMScores,x
    372  27000				   -	       sta	HSRAMScores+3,x
    373  27000				   -	       lda	HSRAMInitials,x
    374  27000				   -	       sta	HSRAMInitials+3,x
    375  27000				   -	       dex
    376  27000				   -	       cpx	temp9
    377  27000				   -	       bne	sortscoresuploop
    378  27000				   -postsortscoresuploop
    379  27000				   -
    380  27000				   -			;stick the score and cleared initials in the slot...
    381  27000				   -	       inx
    382  27000				   -	       ldy	#0
    383  27000				   -	       sty	hsinitialhold
    384  27000				   -	       lda	(temp7),y
    385  27000				   -	       sta	HSRAMScores,x
    386  27000				   -	       iny
    387  27000				   -	       lda	(temp7),y
    388  27000				   -	       sta	HSRAMScores+1,x
    389  27000				   -	       iny
    390  27000				   -	       lda	(temp7),y
    391  27000				   -	       sta	HSRAMScores+2,x
    392  27000				   -	       lda	#0
    393  27000				   -	       sta	HSRAMInitials,x
    394  27000				   -	       lda	#29
    395  27000				   -	       sta	HSRAMInitials+1,x
    396  27000				   -	       sta	HSRAMInitials+2,x
    397  27000				   -
    398  27000				   -	       stx	hsinitialpos
    399  27000				   -
    400  27000				   -	       ifconst	vox_highscore
    401  27000				   -	       lda	<#vox_highscore
    402  27000				   -	       sta	speech_addr
    403  27000				   -	       lda	>#vox_highscore
    404  27000				   -	       sta	speech_addr+1
    405  27000				   -	       endif		; vox_highscore
    406  27000				   -	       ifconst	sfx_highscore
    407  27000				   -	       lda	<#sfx_highscore
    408  27000				   -	       sta	temp1
    409  27000				   -	       lda	>#sfx_highscore
    410  27000				   -	       sta	temp2
    411  27000				   -	       lda	#0
    412  27000				   -	       sta	temp3
    413  27000				   -	       jsr	schedulesfx
    414  27000				   -	       endif		; sfx_highscore
    415  27000				   -	       ifconst	songdatastart_song_highscore
    416  27000				   -	       lda	#<songchanneltable_song_highscore
    417  27000				   -	       sta	songpointerlo
    418  27000				   -	       lda	#>songchanneltable_song_highscore
    419  27000				   -	       sta	songpointerhi
    420  27000				   -	       lda	#73
    421  27000				   -	       sta	songtempo
    422  27000				   -	       jsr	setsongchannels
    423  27000				   -	       endif		; songdatastart_song_highscore
    424  27000				   -
    425  27000				   -
    426  27000				   -donoscoreevaluation
    427  27000				   -
    428  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    429  27000				   -	       sta	temp3	; palette/width
    430  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    431  27000				   -	       sta	temp4	; X
    432  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    433  27000				   -	       sta	temp5	; Y
    434  27000				   -	       lda	#<HSRAMScores
    435  27000				   -	       sta	temp7	; score variable lo
    436  27000				   -	       lda	#>HSRAMScores
    437  27000				   -	       sta	temp8	; score variable hi
    438  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    439  27000				   -	       sta	temp9
    440  27000				   -plothsscoresloop
    441  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    442  27000				   -	       sta	temp1	; charmaplo
    443  27000				   -	       lda	#>(hiscorefont+33)
    444  27000				   -	       sta	temp2	; charmaphi
    445  27000				   -	       lda	#6
    446  27000				   -	       sta	temp6
    447  27000				   -	       ifnconst	DOUBLEWIDE
    448  27000				   -	       jsr	plotvalue
    449  27000				   -	       else
    450  27000				   -	       jsr	plotvaluedw
    451  27000				   -	       endif
    452  27000				   -	       clc
    453  27000				   -	       lda	temp3
    454  27000				   -	       adc	#32
    455  27000				   -	       sta	temp3
    456  27000				   -	       inc	temp5
    457  27000				   -	       if	WZONEHEIGHT = 8
    458  27000				   -	       inc	temp5
    459  27000				   -	       endif
    460  27000				   -	       clc
    461  27000				   -	       lda	#3
    462  27000				   -	       adc	temp7
    463  27000				   -	       sta	temp7
    464  27000				   -	       cmp	#(<(HSRAMScores+15))
    465  27000				   -	       bcc	plothsscoresloop
    466  27000				   -plothsindex
    467  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    468  27000				   -	       sta	temp3	; palette/width
    469  27000				   -	       lda	#44
    470  27000				   -	       sta	temp4	; X
    471  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    472  27000				   -	       sta	temp5	; Y
    473  27000				   -	       lda	#<hsgameslotnumbers
    474  27000				   -	       sta	temp7	; score variable lo
    475  27000				   -	       lda	#>hsgameslotnumbers
    476  27000				   -	       sta	temp8	; score variable hi
    477  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    478  27000				   -	       sta	temp9
    479  27000				   -plothsindexloop
    480  27000				   -	       lda	#<(hiscorefont+33)
    481  27000				   -	       sta	temp1	; charmaplo
    482  27000				   -	       lda	#>(hiscorefont+33)
    483  27000				   -	       sta	temp2	; charmaphi
    484  27000				   -	       lda	#1
    485  27000				   -	       sta	temp6	; number of characters
    486  27000				   -	       ifnconst	DOUBLEWIDE
    487  27000				   -	       jsr	plotvalue
    488  27000				   -	       else
    489  27000				   -	       jsr	plotvaluedw
    490  27000				   -	       endif
    491  27000				   -	       clc
    492  27000				   -	       lda	temp3
    493  27000				   -	       adc	#32
    494  27000				   -	       sta	temp3
    495  27000				   -	       inc	temp5
    496  27000				   -	       if	WZONEHEIGHT = 8
    497  27000				   -	       inc	temp5
    498  27000				   -	       endif
    499  27000				   -	       inc	temp7
    500  27000				   -	       lda	temp7
    501  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    502  27000				   -	       bcc	plothsindexloop
    503  27000				   -
    504  27000				   -	       jsr	savescreen
    505  27000				   -	       ifnconst	HSSECONDS
    506  27000				   -	       lda	#6
    507  27000				   -	       else
    508  27000				   -	       lda	#HSSECONDS
    509  27000				   -	       endif
    510  27000				   -
    511  27000				   -	       sta	countdownseconds
    512  27000				   -
    513  27000				   -keepdisplayinghs
    514  27000				   -	       jsr	restorescreen
    515  27000				   -
    516  27000				   -	       jsr	setuphsinpt1
    517  27000				   -
    518  27000				   -	       lda	hsnewscoreline
    519  27000				   -	       bpl	carryonkeepdisplayinghs
    520  27000				   -	       jmp	skipenterscorecontrol
    521  27000				   -carryonkeepdisplayinghs
    522  27000				   -
    523  27000				   -
    524  27000				   -	       ifnconst	HSSECONDS
    525  27000				   -	       lda	#6
    526  27000				   -	       else
    527  27000				   -	       lda	#HSSECONDS
    528  27000				   -	       endif
    529  27000				   -
    530  27000				   -	       sta	countdownseconds
    531  27000				   -
    532  27000				   -			;plot the "cursor" initial sprite...
    533  27000				   -	       lda	hsinitialhold
    534  27000				   -
    535  27000				   -	       sta	temp1
    536  27000				   -	       lda	#>(hiscorefont+32)
    537  27000				   -	       sta	temp2
    538  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    539  27000				   -	       sta	temp3	; palette/width
    540  27000				   -	       lda	hscursorx
    541  27000				   -	       asl
    542  27000				   -	       asl
    543  27000				   -	       clc
    544  27000				   -	       adc	#104
    545  27000				   -	       sta	temp4	; X
    546  27000				   -	       lda	hsnewscoreline
    547  27000				   -	       asl
    548  27000				   -	       asl
    549  27000				   -	       asl
    550  27000				   -	       asl
    551  27000				   -	       adc	#((3*16)+HSCURSORY)
    552  27000				   -	       sta	temp5	; Y
    553  27000				   -	       lda	#%01000000
    554  27000				   -	       sta	temp6
    555  27000				   -	       jsr	plotsprite
    556  27000				   -
    557  27000				   -	       ldx	hscursorx
    558  27000				   -	       ldy	hsdisplaymode
    559  27000				   -	       ifnconst	.HSup
    560  27000				   -	       lda	SWCHA
    561  27000				   -	       cpy	#3
    562  27000				   -	       bne	hsskipadjustjoystick1
    563  27000				   -	       asl
    564  27000				   -	       asl
    565  27000				   -	       asl
    566  27000				   -	       asl
    567  27000				   -hsskipadjustjoystick1
    568  27000				   -	       sta	hsswcha
    569  27000				   -	       else		; there are user-defined routines!
    570  27000				   -	       jsr	.HSdown
    571  27000				   -	       lda	hsreturn	; b0
    572  27000				   -	       asl
    573  27000				   -	       pha
    574  27000				   -	       jsr	.HSup
    575  27000				   -	       pla
    576  27000				   -	       ora	hsreturn
    577  27000				   -	       asl
    578  27000				   -	       asl
    579  27000				   -	       asl
    580  27000				   -	       asl
    581  27000				   -	       eor	#$FF
    582  27000				   -	       sta	hsswcha
    583  27000				   -	       endif
    584  27000				   -	       lda	SWCHB
    585  27000				   -	       and	#%00000010
    586  27000				   -	       bne	hsskipselectswitch
    587  27000				   -	       lda	#%00010000
    588  27000				   -	       sta	hsswcha
    589  27000				   -	       bne	hsdodebouncecheck
    590  27000				   -hsskipselectswitch
    591  27000				   -	       lda	hsswcha
    592  27000				   -	       and	#%00110000
    593  27000				   -	       cmp	#%00110000
    594  27000				   -	       beq	hsjoystickskipped
    595  27000				   -hsdodebouncecheck
    596  27000				   -	       lda	hsjoydebounce
    597  27000				   -	       beq	hsdontdebounce
    598  27000				   -	       jmp	hspostjoystick
    599  27000				   -hsdontdebounce
    600  27000				   -	       ldx	#1	; small tick sound
    601  27000				   -	       jsr	playhssfx
    602  27000				   -	       lda	hsswcha
    603  27000				   -	       and	#%00110000
    604  27000				   -	       ldx	hscursorx
    605  27000				   -	       cmp	#%00100000	; check down
    606  27000				   -	       bne	hsjoycheckup
    607  27000				   -	       ldy	hsinitialhold
    608  27000				   -	       cpx	#0
    609  27000				   -	       bne	skipavoid31_1
    610  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    611  27000				   -	       bne	skipavoid31_1
    612  27000				   -	       dey
    613  27000				   -skipavoid31_1
    614  27000				   -	       dey
    615  27000				   -	       jmp	hssetdebounce
    616  27000				   -hsjoycheckup
    617  27000				   -	       cmp	#%00010000	; check up
    618  27000				   -	       bne	hsjoystickskipped
    619  27000				   -	       ldy	hsinitialhold
    620  27000				   -	       cpx	#0
    621  27000				   -	       bne	skipavoid31_2
    622  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    623  27000				   -	       bne	skipavoid31_2
    624  27000				   -	       iny
    625  27000				   -skipavoid31_2
    626  27000				   -	       iny
    627  27000				   -hssetdebounce
    628  27000				   -	       tya
    629  27000				   -	       and	#31
    630  27000				   -	       sta	hsinitialhold
    631  27000				   -	       lda	#15
    632  27000				   -	       sta	hsjoydebounce
    633  27000				   -	       bne	hspostjoystick
    634  27000				   -hsjoystickskipped
    635  27000				   -			; check the fire button only when the stick isn't engaged
    636  27000				   -	       lda	hsinpt1
    637  27000				   -	       bpl	hsbuttonskipped
    638  27000				   -	       lda	hsjoydebounce
    639  27000				   -	       bne	hspostjoystick
    640  27000				   -hsfiredontdebounce
    641  27000				   -	       lda	hsinitialhold
    642  27000				   -	       cmp	#31
    643  27000				   -	       beq	hsmovecursorback
    644  27000				   -	       inc	hscursorx
    645  27000				   -	       inc	hsinitialpos
    646  27000				   -	       lda	hscursorx
    647  27000				   -	       cmp	#3
    648  27000				   -	       bne	skiphsentryisdone
    649  27000				   -	       lda	#0
    650  27000				   -	       sta	framecounter
    651  27000				   -	       lda	#$ff
    652  27000				   -	       sta	hsnewscoreline
    653  27000				   -	       dec	hsinitialpos
    654  27000				   -	       bne	skiphsentryisdone
    655  27000				   -hsmovecursorback
    656  27000				   -	       lda	hscursorx
    657  27000				   -	       beq	skiphsmovecursorback
    658  27000				   -	       lda	#29
    659  27000				   -	       ldx	hsinitialpos
    660  27000				   -	       sta	HSRAMInitials,x
    661  27000				   -	       dec	hsinitialpos
    662  27000				   -	       dec	hscursorx
    663  27000				   -	       dex
    664  27000				   -	       lda	HSRAMInitials,x
    665  27000				   -	       sta	hsinitialhold
    666  27000				   -skiphsmovecursorback
    667  27000				   -skiphsentryisdone
    668  27000				   -	       ldx	#0
    669  27000				   -	       jsr	playhssfx
    670  27000				   -	       lda	#20
    671  27000				   -	       sta	hsjoydebounce
    672  27000				   -	       bne	hspostjoystick
    673  27000				   -
    674  27000				   -hsbuttonskipped
    675  27000				   -	       lda	#0
    676  27000				   -	       sta	hsjoydebounce
    677  27000				   -hspostjoystick
    678  27000				   -
    679  27000				   -	       ldx	hsinitialpos
    680  27000				   -	       lda	hsinitialhold
    681  27000				   -	       sta	HSRAMInitials,x
    682  27000				   -
    683  27000				   -	       jmp	skiphschasecolors
    684  27000				   -
    685  27000				   -skipenterscorecontrol
    686  27000				   -	       jsr	hschasecolors
    687  27000				   -	       jsr	setuphsinpt1
    688  27000				   -	       lda	hsjoydebounce
    689  27000				   -	       bne	skiphschasecolors
    690  27000				   -	       lda	hsinpt1
    691  27000				   -	       bmi	returnfromhs
    692  27000				   -skiphschasecolors
    693  27000				   -
    694  27000				   -	       jsr	drawscreen
    695  27000				   -
    696  27000				   -	       lda	countdownseconds
    697  27000				   -	       beq	returnfromhs
    698  27000				   -	       jmp	keepdisplayinghs
    699  27000				   -returnfromhs
    700  27000				   -
    701  27000				   -	       ifconst	songdatastart_song_highscore
    702  27000				   -	       lda	hsdisplaymode
    703  27000				   -	       beq	skipclearHSCsong
    704  27000				   -	       lda	#0
    705  27000				   -	       sta	songtempo
    706  27000				   -skipclearHSCsong
    707  27000				   -	       endif
    708  27000				   -	       jsr	drawwait
    709  27000				   -	       jsr	clearscreen
    710  27000				   -	       lda	#0
    711  27000				   -	       ldy	#7
    712  27000				   -	       jsr	blacken320colors
    713  27000				   -	       lda	ssCTRL
    714  27000				   -	       sta	sCTRL
    715  27000				   -	       lda	ssCHARBASE
    716  27000				   -	       sta	sCHARBASE
    717  27000				   -	       rts
    718  27000				   -
    719  27000				   -setuphsinpt1
    720  27000				   -	       lda	#$ff
    721  27000				   -	       sta	hsinpt1
    722  27000				   -	       lda	hsjoydebounce
    723  27000				   -	       beq	skipdebounceadjust
    724  27000				   -	       dec	hsjoydebounce
    725  27000				   -	       bne	skipstorefirebuttonstatus
    726  27000				   -skipdebounceadjust
    727  27000				   -	       lda	SWCHB
    728  27000				   -	       and	#%00000001
    729  27000				   -	       bne	hscheckresetover
    730  27000				   -	       lda	#$ff
    731  27000				   -	       sta	hsinpt1
    732  27000				   -	       rts
    733  27000				   -hscheckresetover
    734  27000				   -	       ifnconst	.HSup
    735  27000				   -	       ldx	hsdisplaymode
    736  27000				   -	       cpx	#3
    737  27000				   -	       bne	hsskipadjustjoyfire1
    738  27000				   -	       lda	sINPT3
    739  27000				   -	       jmp	hsskipadjustjoyfire1done
    740  27000				   -hsskipadjustjoyfire1
    741  27000				   -	       lda	sINPT1
    742  27000				   -hsskipadjustjoyfire1done
    743  27000				   -	       sta	hsinpt1
    744  27000				   -	       else		; there are user-defined routines!
    745  27000				   -	       jsr	.HSselect
    746  27000				   -	       lda	hsreturn
    747  27000				   -	       ror		; carry
    748  27000				   -	       ror		; b7
    749  27000				   -	       sta	hsinpt1
    750  27000				   -	       endif	.HSup
    751  27000				   -skipstorefirebuttonstatus
    752  27000				   -	       rts
    753  27000				   -
    754  27000				   -blacken320colors
    755  27000				   -	       ldy	#7
    756  27000				   -blacken320colorsloop
    757  27000				   -	       sta	P0C2,y
    758  27000				   -	       dey
    759  27000				   -	       bpl	blacken320colorsloop
    760  27000				   -	       rts
    761  27000				   -
    762  27000				   -hschasecolors
    763  27000				   -	       lda	framecounter
    764  27000				   -	       and	#3
    765  27000				   -	       bne	hschasecolorsreturn
    766  27000				   -	       inc	hscolorchaseindex
    767  27000				   -	       lda	hscolorchaseindex
    768  27000				   -
    769  27000				   -	       sta	P5C2
    770  27000				   -	       sbc	#$02
    771  27000				   -	       sta	P4C2
    772  27000				   -	       sbc	#$02
    773  27000				   -	       sta	P3C2
    774  27000				   -	       sbc	#$02
    775  27000				   -	       sta	P2C2
    776  27000				   -	       sbc	#$02
    777  27000				   -	       sta	P1C2
    778  27000				   -hschasecolorsreturn
    779  27000				   -	       rts
    780  27000				   -
    781  27000				   -playhssfx
    782  27000				   -	       lda	hssfx_lo,x
    783  27000				   -	       sta	temp1
    784  27000				   -	       lda	hssfx_hi,x
    785  27000				   -	       sta	temp2
    786  27000				   -	       lda	#0
    787  27000				   -	       sta	temp3
    788  27000				   -	       jmp	schedulesfx
    789  27000				   -
    790  27000				   -hssfx_lo
    791  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    792  27000				   -hssfx_hi
    793  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    794  27000				   -
    795  27000				   -sfx_hsletterpositionchange
    796  27000				   -	       .byte	$10,$18,$00
    797  27000				   -	       .byte	$02,$06,$08
    798  27000				   -	       .byte	$02,$06,$04
    799  27000				   -	       .byte	$00,$00,$00
    800  27000				   -sfx_hslettertick
    801  27000				   -	       .byte	$10,$18,$00
    802  27000				   -	       .byte	$00,$00,$0a
    803  27000				   -	       .byte	$00,$00,$00
    804  27000				   -
    805  27000				   -highscorelabeladjust1
    806  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    807  27000				   -highscorelabeladjust2
    808  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    809  27000				   -
    810  27000				   -scorevarlo
    811  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    812  27000				   -scorevarhi
    813  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    814  27000				   -
    815  27000				   -	       endif		; !isBANKSETBANK
    816  27000				   -
    817  27000				   -	       ifnconst	HSNOLEVELNAMES
    818  27000				   -	       ifnconst	isBANKSETBANK
    819  27000				   -highscoredifficultytextlo
    820  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    821  27000				   -highscoredifficultytexthi
    822  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    823  27000				   -	       endif		; !isBANKSETBANK
    824  27000				   -
    825  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    826  27000				   -	       ifnconst	isBANKSETBANK
    827  27000				   -highscoredifficultytextlen
    828  27000				   -	       .byte	22, 30, 26, 24
    829  27000				   -	       endif		; !isBANKSETBANK
    830  27000				   -
    831  27000				   -	       ifconst	HSCHARSHERE
    832  27000				   -
    833  27000				   -easylevelname
    834  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    835  27000				   -mediumlevelname
    836  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    837  27000				   -hardlevelname
    838  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    839  27000				   -expertlevelname
    840  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    841  27000				   -	       endif		; HSCHARSHERE
    842  27000				   -	       else		; HSCUSTOMLEVELNAMES
    843  27000				   -	       include	"7800hsgamediffnames.asm"
    844  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    845  27000				   -	       else		; HSNOLEVELNAMES
    846  27000				   -	       ifconst	HSCHARSHERE
    847  27000				   -HSHIGHSCOREStext
    848  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  27000				   -	       endif		; HSCHARSHERE
    850  27000				   -	       endif		; HSNOLEVELNAMES
    851  27000				   -
    852  27000				   -	       ifnconst	isBANKSETBANK
    853  27000				   -highscorelabeltextlo
    854  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    855  27000				   -highscorelabeltexthi
    856  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    857  27000				   -	       endif		; !isBANKSETBANK
    858  27000				   -
    859  27000				   -	       ifconst	HSCHARSHERE
    860  27000				   -player0label
    861  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    862  27000				   -
    863  27000				   -player1label
    864  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    865  27000				   -
    866  27000				   -player2label
    867  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    868  27000				   -	       endif		; HSCHARSHERE
    869  27000				   -
    870  27000				   -
    871  27000				   -	       ifconst	HSGAMENAMELEN
    872  27000				   -	       ifconst	HSCHARSHERE
    873  27000				   -HSGAMENAMEtable
    874  27000				   -	       include	"7800hsgamename.asm"
    875  27000				   -	       endif		; HSCHARSHERE
    876  27000				   -	       endif		; HSGAMENAMELEN
    877  27000				   -	       ifconst	HSGAMERANKS
    878  27000				   -	       include	"7800hsgameranks.asm"
    879  27000				   -	       ifconst	HSCHARSHERE
    880  27000				   -highscoreranklabel
    881  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    882  27000				   -	       endif		; HSCHARSHERE
    883  27000				   -	       endif		; HSGAMERANKS
    884  27000				   -
    885  27000				   -			;ensure our table doesn't wrap a page...
    886  27000				   -	       if	((<*)>251)
    887  27000				   -	       align	256
    888  27000				   -	       endif
    889  27000				   -hsgameslotnumbers
    890  27000				   -	       .byte	33,34,35,36,37
    891  27000				   -	       endif		; hiscorefont
    892  27000				   -
    893  27000				   -
    894  27000				   -	       ifnconst	isBANKSETBANK
    895  27000				   -loaddifficultytable
    896  27000				   -	       lda	gamedifficulty
    897  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    898  27000				   -	       sta	gamedifficulty
    899  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    900  27000				   -	       bne	loaddifficultytablecontinue1
    901  27000				   -	       rts		; this high score difficulty table is already loaded
    902  27000				   -loaddifficultytablecontinue1
    903  27000				   -	       lda	gamedifficulty
    904  27000				   -	       sta	hsdifficulty
    905  27000				   -			;we need to check the device for the table
    906  27000				   -	       lda	hsdevice
    907  27000				   -	       bne	loaddifficultytablecontinue2
    908  27000				   -			; there's no save device. clear out this table.
    909  27000				   -	       jmp	cleardifficultytablemem
    910  27000				   -loaddifficultytablecontinue2
    911  27000				   -	       lda	hsdevice
    912  27000				   -	       and	#1
    913  27000				   -	       beq	memdeviceisntHSC
    914  27000				   -	       jmp	loaddifficultytableHSC
    915  27000				   -memdeviceisntHSC
    916  27000				   -	       jmp	loaddifficultytableAVOX
    917  27000				   -
    918  27000				   -savedifficultytable
    919  27000				   -			;*** we need to check which device we should use...
    920  27000				   -	       lda	hsdevice
    921  27000				   -	       bne	savedifficultytablerealdevice
    922  27000				   -	       rts		; its a ram device
    923  27000				   -savedifficultytablerealdevice
    924  27000				   -	       and	#1
    925  27000				   -	       beq	savememdeviceisntHSC
    926  27000				   -	       jmp	savedifficultytableHSC
    927  27000				   -savememdeviceisntHSC
    928  27000				   -	       jmp	savedifficultytableAVOX
    929  27000				   -
    930  27000				   -savedifficultytableAVOX
    931  27000				   -			; the load call already setup the memory structure and atarivox memory location
    932  27000				   -	       jsr	savealoadedHSCtablecontinue
    933  27000				   -savedifficultytableAVOXskipconvert
    934  27000				   -	       lda	#HSIDHI
    935  27000				   -	       sta	eeprombuffer
    936  27000				   -	       lda	#HSIDLO
    937  27000				   -	       sta	eeprombuffer+1
    938  27000				   -	       lda	hsdifficulty
    939  27000				   -	       sta	eeprombuffer+2
    940  27000				   -	       lda	#32
    941  27000				   -	       jsr	AVoxWriteBytes
    942  27000				   -	       rts
    943  27000				   -
    944  27000				   -savedifficultytableHSC
    945  27000				   -			;we always load a table before reaching here, so the
    946  27000				   -			;memory structures from the load should be intact...
    947  27000				   -	       ldy	hsgameslot
    948  27000				   -	       bpl	savealoadedHSCtable
    949  27000				   -	       rts
    950  27000				   -savealoadedHSCtable
    951  27000				   -	       lda	HSCGameDifficulty,y
    952  27000				   -	       cmp	#$7F
    953  27000				   -	       bne	savealoadedHSCtablecontinue
    954  27000				   -	       jsr	initializeHSCtableentry
    955  27000				   -savealoadedHSCtablecontinue
    956  27000				   -			;convert our RAM table to HSC format and write it out...
    957  27000				   -	       ldy	#0
    958  27000				   -	       ldx	#0
    959  27000				   -savedifficultytableScores
    960  27000				   -
    961  27000				   -	       lda	HSRAMInitials,x
    962  27000				   -	       sta	temp3
    963  27000				   -	       lda	HSRAMInitials+1,x
    964  27000				   -	       sta	temp4
    965  27000				   -	       lda	HSRAMInitials+2,x
    966  27000				   -	       sta	temp5
    967  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    968  27000				   -
    969  27000				   -	       lda	temp1
    970  27000				   -	       sta	(HSGameTableLo),y
    971  27000				   -	       iny
    972  27000				   -	       lda	temp2
    973  27000				   -	       sta	(HSGameTableLo),y
    974  27000				   -	       iny
    975  27000				   -
    976  27000				   -	       lda	HSRAMScores,x
    977  27000				   -	       sta	(HSGameTableLo),y
    978  27000				   -	       iny
    979  27000				   -	       lda	HSRAMScores+1,x
    980  27000				   -	       sta	(HSGameTableLo),y
    981  27000				   -	       iny
    982  27000				   -	       lda	HSRAMScores+2,x
    983  27000				   -	       sta	(HSGameTableLo),y
    984  27000				   -	       iny
    985  27000				   -	       inx
    986  27000				   -	       inx
    987  27000				   -	       inx		; +3
    988  27000				   -	       cpx	#15
    989  27000				   -	       bne	savedifficultytableScores
    990  27000				   -	       rts
    991  27000				   -
    992  27000				   -loaddifficultytableHSC
    993  27000				   -			; routine responsible for loading the difficulty table from HSC
    994  27000				   -	       jsr	findindexHSC
    995  27000				   -	       ldy	hsgameslot
    996  27000				   -	       lda	HSCGameDifficulty,y
    997  27000				   -	       cmp	#$7F
    998  27000				   -	       bne	loaddifficultytableHSCcontinue
    999  27000				   -			;there was an error. use a new RAM table instead...
   1000  27000				   -	       jsr	initializeHSCtableentry
   1001  27000				   -	       jmp	cleardifficultytablemem
   1002  27000				   -loaddifficultytableHSCcontinue
   1003  27000				   -			; parse the data into the HS memory...
   1004  27000				   -	       ldy	#0
   1005  27000				   -	       ldx	#0
   1006  27000				   -loaddifficultytableScores
   1007  27000				   -	       lda	(HSGameTableLo),y
   1008  27000				   -	       sta	temp1
   1009  27000				   -	       iny
   1010  27000				   -	       lda	(HSGameTableLo),y
   1011  27000				   -	       sta	temp2
   1012  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1013  27000				   -	       iny
   1014  27000				   -	       lda	(HSGameTableLo),y
   1015  27000				   -	       sta	HSRAMScores,x
   1016  27000				   -	       lda	temp3
   1017  27000				   -	       sta	HSRAMInitials,x
   1018  27000				   -	       inx
   1019  27000				   -	       iny
   1020  27000				   -	       lda	(HSGameTableLo),y
   1021  27000				   -	       sta	HSRAMScores,x
   1022  27000				   -	       lda	temp4
   1023  27000				   -	       sta	HSRAMInitials,x
   1024  27000				   -	       inx
   1025  27000				   -	       iny
   1026  27000				   -	       lda	(HSGameTableLo),y
   1027  27000				   -	       sta	HSRAMScores,x
   1028  27000				   -	       lda	temp5
   1029  27000				   -	       sta	HSRAMInitials,x
   1030  27000				   -	       inx
   1031  27000				   -	       iny
   1032  27000				   -	       cpx	#15
   1033  27000				   -	       bne	loaddifficultytableScores
   1034  27000				   -	       rts
   1035  27000				   -
   1036  27000				   -decodeHSCInitials
   1037  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1038  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1039  27000				   -	       lda	#0
   1040  27000				   -	       sta	temp4
   1041  27000				   -	       lda	temp1
   1042  27000				   -	       and	#%00011111
   1043  27000				   -	       sta	temp3
   1044  27000				   -
   1045  27000				   -	       lda	temp2
   1046  27000				   -	       and	#%00011111
   1047  27000				   -	       sta	temp5
   1048  27000				   -
   1049  27000				   -	       lda	temp1
   1050  27000				   -	       asl
   1051  27000				   -	       rol	temp4
   1052  27000				   -	       asl
   1053  27000				   -	       rol	temp4
   1054  27000				   -	       asl
   1055  27000				   -	       rol	temp4
   1056  27000				   -	       lda	temp2
   1057  27000				   -	       asl
   1058  27000				   -	       rol	temp4
   1059  27000				   -	       asl
   1060  27000				   -	       rol	temp4
   1061  27000				   -	       rts
   1062  27000				   -encodeHSCInitials
   1063  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1064  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1065  27000				   -			; start with packing temp1...
   1066  27000				   -	       lda	temp4
   1067  27000				   -	       and	#%00011100
   1068  27000				   -	       sta	temp1
   1069  27000				   -	       asl	temp1
   1070  27000				   -	       asl	temp1
   1071  27000				   -	       asl	temp1
   1072  27000				   -	       lda	temp3
   1073  27000				   -	       and	#%00011111
   1074  27000				   -	       ora	temp1
   1075  27000				   -	       sta	temp1
   1076  27000				   -			; ...temp1 is now packed, on to temp2...
   1077  27000				   -	       lda	temp5
   1078  27000				   -	       asl
   1079  27000				   -	       asl
   1080  27000				   -	       ror	temp4
   1081  27000				   -	       ror
   1082  27000				   -	       ror	temp4
   1083  27000				   -	       ror
   1084  27000				   -	       sta	temp2
   1085  27000				   -	       rts
   1086  27000				   -
   1087  27000				   -findindexHSCerror
   1088  27000				   -			;the HSC is stuffed. return the bad slot flag
   1089  27000				   -	       ldy	#$ff
   1090  27000				   -	       sty	hsgameslot
   1091  27000				   -	       rts
   1092  27000				   -
   1093  27000				   -findindexHSC
   1094  27000				   -HSCGameID1 =	$1029
   1095  27000				   -HSCGameID2 =	$106E
   1096  27000				   -HSCGameDifficulty =	$10B3
   1097  27000				   -HSCGameIndex =	$10F8
   1098  27000				   -			; routine responsible for finding the game index from HSC
   1099  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1100  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1101  27000				   -	       ldy	#69	; start +1 to account for the dey
   1102  27000				   -findindexHSCloop
   1103  27000				   -	       dey
   1104  27000				   -	       bmi	findindexHSCerror
   1105  27000				   -	       lda	HSCGameDifficulty,y
   1106  27000				   -	       cmp	#$7F
   1107  27000				   -	       beq	findourindexHSC
   1108  27000				   -	       cmp	gamedifficulty
   1109  27000				   -	       bne	findindexHSCloop
   1110  27000				   -	       lda	HSCGameID1,y
   1111  27000				   -	       cmp	#HSIDHI
   1112  27000				   -	       bne	findindexHSCloop
   1113  27000				   -	       lda	HSCGameID2,y
   1114  27000				   -	       cmp	#HSIDLO
   1115  27000				   -	       bne	findindexHSCloop
   1116  27000				   -findourindexHSC
   1117  27000				   -			; if we're here we found our index in the table
   1118  27000				   -			; or we found the first empty one
   1119  27000				   -	       sty	hsgameslot
   1120  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1121  27000				   -	       rts
   1122  27000				   -
   1123  27000				   -
   1124  27000				   -initializeHSCtableentry
   1125  27000				   -	       ldy	hsgameslot
   1126  27000				   -			; we need to make a new entry...
   1127  27000				   -	       lda	#HSIDHI
   1128  27000				   -	       sta	HSCGameID1,y
   1129  27000				   -	       lda	#HSIDLO
   1130  27000				   -	       sta	HSCGameID2,y
   1131  27000				   -	       lda	gamedifficulty
   1132  27000				   -	       sta	HSCGameDifficulty,y
   1133  27000				   -	       ldx	#0
   1134  27000				   -fixHSDGameDifficultylistLoop
   1135  27000				   -	       inx
   1136  27000				   -	       txa
   1137  27000				   -	       sta	HSCGameIndex,y
   1138  27000				   -	       iny
   1139  27000				   -	       cpy	#69
   1140  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1141  27000				   -	       rts
   1142  27000				   -
   1143  27000				   -setupHSCGamepointer
   1144  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1145  27000				   -	       lda	#$17
   1146  27000				   -	       sta	HSGameTableHi
   1147  27000				   -	       lda	#$FA
   1148  27000				   -	       sta	HSGameTableLo
   1149  27000				   -setupHSCGamepointerLoop
   1150  27000				   -	       lda	HSGameTableLo
   1151  27000				   -	       sec
   1152  27000				   -	       sbc	#25
   1153  27000				   -	       sta	HSGameTableLo
   1154  27000				   -	       lda	HSGameTableHi
   1155  27000				   -	       sbc	#0
   1156  27000				   -	       sta	HSGameTableHi
   1157  27000				   -	       iny
   1158  27000				   -	       cpy	#69
   1159  27000				   -	       bne	setupHSCGamepointerLoop
   1160  27000				   -	       rts
   1161  27000				   -
   1162  27000				   -loaddifficultytableAVOX
   1163  27000				   -			; routine responsible for loading the difficulty table from Avox
   1164  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1165  27000				   -	       lda	#>(eeprombuffer+3)
   1166  27000				   -	       sta	HSGameTableHi
   1167  27000				   -	       lda	#<(eeprombuffer+3)
   1168  27000				   -	       sta	HSGameTableLo
   1169  27000				   -
   1170  27000				   -			; the start location in EEPROM, subtract 32...
   1171  27000				   -	       lda	#$5F
   1172  27000				   -	       sta	HSVoxHi
   1173  27000				   -	       lda	#$E0
   1174  27000				   -	       sta	HSVoxLo
   1175  27000				   -	       lda	#0
   1176  27000				   -	       sta	temp1
   1177  27000				   -loaddifficultytableAVOXloop
   1178  27000				   -	       inc	temp1
   1179  27000				   -	       beq	loaddifficultytableAVOXfull
   1180  27000				   -	       clc
   1181  27000				   -	       lda	HSVoxLo
   1182  27000				   -	       adc	#32
   1183  27000				   -	       sta	HSVoxLo
   1184  27000				   -	       lda	HSVoxHi
   1185  27000				   -	       adc	#0
   1186  27000				   -	       sta	HSVoxHi
   1187  27000				   -	       lda	#3
   1188  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1189  27000				   -	       lda	eeprombuffer
   1190  27000				   -	       cmp	#$FF
   1191  27000				   -	       beq	loaddifficultytableAVOXempty
   1192  27000				   -	       cmp	#HSIDHI
   1193  27000				   -	       bne	loaddifficultytableAVOXloop
   1194  27000				   -	       lda	eeprombuffer+1
   1195  27000				   -	       cmp	#HSIDLO
   1196  27000				   -	       bne	loaddifficultytableAVOXloop
   1197  27000				   -	       lda	eeprombuffer+2
   1198  27000				   -	       cmp	gamedifficulty
   1199  27000				   -	       bne	loaddifficultytableAVOXloop
   1200  27000				   -loaddifficultytableAVOXdone
   1201  27000				   -	       lda	#32
   1202  27000				   -	       jsr	AVoxReadBytes
   1203  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1204  27000				   -	       rts
   1205  27000				   -loaddifficultytableAVOXfull
   1206  27000				   -	       lda	#0
   1207  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1208  27000				   -loaddifficultytableAVOXempty
   1209  27000				   -	       jmp	cleardifficultytablemem
   1210  27000				   -	       rts
   1211  27000				   -
   1212  27000				   -cleardifficultytablemem
   1213  27000				   -	       ldy	#29
   1214  27000				   -	       lda	#0
   1215  27000				   -cleardifficultytablememloop
   1216  27000				   -	       sta	HSRAMTable,y
   1217  27000				   -	       dey
   1218  27000				   -	       bpl	cleardifficultytablememloop
   1219  27000				   -	       rts
   1220  27000				   -hiscoremoduleend
   1221  27000				   -
   1222  27000				   -	       ifconst	DOUBLEWIDE
   1223  27000				   -plotvaluedw
   1224  27000				   -plotdigitcount =	temp6
   1225  27000				   -	       lda	#0
   1226  27000				   -	       tay
   1227  27000				   -	       ldx	valbufend
   1228  27000				   -
   1229  27000				   -	       lda	plotdigitcount
   1230  27000				   -	       and	#1
   1231  27000				   -	       beq	pvnibble2chardw
   1232  27000				   -	       lda	#0
   1233  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1234  27000				   -	       beq	pvnibble2char_skipnibbledw
   1235  27000				   -
   1236  27000				   -pvnibble2chardw
   1237  27000				   -			; high nibble...
   1238  27000				   -	       lda	(temp7),y
   1239  27000				   -	       and	#$f0
   1240  27000				   -	       lsr
   1241  27000				   -	       lsr
   1242  27000				   -	       lsr
   1243  27000				   -	       lsr
   1244  27000				   -
   1245  27000				   -	       clc
   1246  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1247  27000				   -	       sta	VALBUFFER,x
   1248  27000				   -	       inx
   1249  27000				   -	       dec	plotdigitcount
   1250  27000				   -pvnibble2char_skipnibbledw
   1251  27000				   -			; low nibble...
   1252  27000				   -	       lda	(temp7),y
   1253  27000				   -	       and	#$0f
   1254  27000				   -	       clc
   1255  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1256  27000				   -	       sta	VALBUFFER,x
   1257  27000				   -	       inx
   1258  27000				   -	       iny
   1259  27000				   -
   1260  27000				   -	       dec	plotdigitcount
   1261  27000				   -	       bne	pvnibble2chardw
   1262  27000				   -			;point to the start of our valuebuffer
   1263  27000				   -	       clc
   1264  27000				   -	       lda	#<VALBUFFER
   1265  27000				   -	       adc	valbufend
   1266  27000				   -	       sta	temp1
   1267  27000				   -	       lda	#>VALBUFFER
   1268  27000				   -	       adc	#0
   1269  27000				   -	       sta	temp2
   1270  27000				   -
   1271  27000				   -			;advance valbufend to the end of our value buffer
   1272  27000				   -	       stx	valbufend
   1273  27000				   -
   1274  27000				   -	       ifnconst	plotvalueonscreen
   1275  27000				   -	       jmp	plotcharacters
   1276  27000				   -	       else
   1277  27000				   -	       jmp	plotcharacterslive
   1278  27000				   -	       endif
   1279  27000				   -	       endif		; DOUBLEWIDE
   1280  27000				   -
   1281  27000				   -hiscoreend
   1282  27000				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1283  27000				   -	       endif		; !isBANKSETBANK
   1284  27000					       endif		; HSSUPPORT
   1285  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1532  27000					       endif
   1533  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes)"
     58  27000				   -
     59  27000					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_1.78b.asm
   1535  27000					       endif
   1536  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1537  27000
   1538  27000							;standard routimes needed for pretty much all games
   1539  27000
   1540  27000							; some definitions used with "set debug color"
   1541  27000			00 91	    DEBUGCALC  =	$91
   1542  27000			00 41	    DEBUGWASTE =	$41
   1543  27000			00 c1	    DEBUGDRAW  =	$C1
   1544  27000
   1545  27000							;NMI and IRQ handlers
   1546  27000				    NMI
   1547  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   1548  27000			48		       pha		; save A
   1549  27001			d8		       cld
   1550  27002			a5 4d		       lda	visibleover
   1551  27004			49 ff		       eor	#255
   1552  27006			85 4d		       sta	visibleover
   1553  27008				   -	       ifconst	DEBUGINTERRUPT
   1554  27008				   -	       and	#$93
   1555  27008				   -	       sta	BACKGRND
   1556  27008					       endif
   1557  27008			8a		       txa		; save X
   1558  27009			48		       pha
   1559  2700a			98		       tya		; save Y
   1560  2700b			48		       pha
   1561  2700c			ce b2 01	       dec	interruptindex
   1562  2700f			d0 03		       bne	skipreallyoffvisible
   1563  27011			4c 73 f0	       jmp	reallyoffvisible
   1564  27014				    skipreallyoffvisible
   1565  27014			a5 4d		       lda	visibleover
   1566  27016			d0 03		       bne	carryontopscreenroutine
   1567  27018				   -	       ifconst	.bottomscreenroutine
   1568  27018				   -	       lda	interrupthold
   1569  27018				   -	       beq	skipbottomroutine
   1570  27018				   -	       jsr	.bottomscreenroutine
   1571  27018				   -skipbottomroutine
   1572  27018					       endif
   1573  27018			4c 81 f0	       jmp	NMIexit
   1574  2701b				    carryontopscreenroutine
   1575  2701b				   -	       ifconst	.topscreenroutine
   1576  2701b				   -	       lda	interrupthold
   1577  2701b				   -	       beq	skiptoproutine
   1578  2701b				   -	       jsr	.topscreenroutine
   1579  2701b				   -skiptoproutine
   1580  2701b					       endif
   1581  2701b					       ifnconst	CANARYOFF
   1582  2701b			ad c3 01	       lda	canary
   1583  2701e			f0 07		       beq	skipcanarytriggered
   1584  27020			a9 45		       lda	#$45
   1585  27022			85 20		       sta	BACKGRND
   1586  27024			4c 6b f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   1587  27027				    skipcanarytriggered
   1588  27027					       endif
   1589  27027
   1590  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   1591  2702a
   1592  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   1593  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   1594  2702a
   1595  2702a				   -	       ifconst	LONGCONTROLLERREAD
   1596  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   1597  2702a				   -	       ldy	port1control
   1598  2702a				   -	       lda	longreadtype,y
   1599  2702a				   -	       beq	LLRET1
   1600  2702a				   -	       tay
   1601  2702a				   -	       lda	longreadroutinehiP1,y
   1602  2702a				   -	       sta	inttemp4
   1603  2702a				   -	       lda	longreadroutineloP1,y
   1604  2702a				   -	       sta	inttemp3
   1605  2702a				   -	       jmp	(inttemp3)
   1606  2702a				   -LLRET1
   1607  2702a				   -	       ldy	port0control
   1608  2702a				   -	       lda	longreadtype,y
   1609  2702a				   -	       beq	LLRET0
   1610  2702a				   -	       tay
   1611  2702a				   -	       lda	longreadroutinehiP0,y
   1612  2702a				   -	       sta	inttemp4
   1613  2702a				   -	       lda	longreadroutineloP0,y
   1614  2702a				   -	       sta	inttemp3
   1615  2702a				   -	       jmp	(inttemp3)
   1616  2702a				   -LLRET0
   1617  2702a				   -
   1618  2702a				   -
   1619  2702a				   -	       ifconst	PADDLERANGE
   1620  2702a				   -TIMEVAL    =	PADDLERANGE
   1621  2702a				   -	       else
   1622  2702a				   -TIMEVAL    =	160
   1623  2702a				   -	       endif
   1624  2702a				   -TIMEOFFSET =	10
   1625  2702a				   -
   1626  2702a					       endif		; LONGCONTROLLERREAD
   1627  2702a
   1628  2702a
   1629  2702a			20 01 f2	       jsr	servicesfxchannels
   1630  2702d				   -	       ifconst	MUSICTRACKER
   1631  2702d				   -	       jsr	servicesong
   1632  2702d					       endif		; MUSICTRACKER
   1633  2702d				   -	       ifconst	RMT
   1634  2702d				   -	       lda	rasterpause
   1635  2702d				   -	       beq	skiprasterupdate
   1636  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   1637  2702d				   -skiprasterupdate
   1638  2702d				   -RMT_Iend
   1639  2702d					       endif
   1640  2702d
   1641  2702d			ee a4 01	       inc	framecounter
   1642  27030			ad a4 01	       lda	framecounter
   1643  27033			29 3f		       and	#63
   1644  27035			d0 08		       bne	skipcountdownseconds
   1645  27037			ad a5 01	       lda	countdownseconds
   1646  2703a			f0 03		       beq	skipcountdownseconds
   1647  2703c			ce a5 01	       dec	countdownseconds
   1648  2703f				    skipcountdownseconds
   1649  2703f
   1650  2703f			a2 01		       ldx	#1
   1651  27041				    buttonreadloop
   1652  27041			8a		       txa
   1653  27042			48		       pha
   1654  27043			bc b9 01	       ldy	port0control,x
   1655  27046			b9 de f1	       lda	buttonhandlerlo,y
   1656  27049			85 da		       sta	inttemp3
   1657  2704b			b9 d2 f1	       lda	buttonhandlerhi,y
   1658  2704e			85 db		       sta	inttemp4
   1659  27050			05 da		       ora	inttemp3
   1660  27052			f0 03		       beq	buttonreadloopreturn
   1661  27054			6c da 00	       jmp	(inttemp3)
   1662  27057				    buttonreadloopreturn
   1663  27057			68		       pla
   1664  27058			aa		       tax
   1665  27059			ca		       dex
   1666  2705a			10 e5		       bpl	buttonreadloop
   1667  2705c
   1668  2705c							;ifconst KEYPADSUPPORT
   1669  2705c							;  jsr keypadrowselect
   1670  2705c							;endif ; KEYPADSUPPORT
   1671  2705c
   1672  2705c
   1673  2705c					       ifconst	DOUBLEBUFFER
   1674  2705c			ad b4 01	       lda	doublebufferminimumframeindex
   1675  2705f			f0 03		       beq	skipdoublebufferminimumframeindexadjust
   1676  27061			ce b4 01	       dec	doublebufferminimumframeindex
   1677  27064				    skipdoublebufferminimumframeindexadjust
   1678  27064					       endif
   1679  27064
   1680  27064			4c 81 f0	       jmp	NMIexit
   1681  27067
   1682  27067				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   1683  27067					       ifnconst	BREAKPROTECTOFF
   1684  27067			a9 1a		       lda	#$1A
   1685  27069			85 20		       sta	BACKGRND
   1686  2706b				    skipbrkolorset
   1687  2706b				    skipbrkdetected
   1688  2706b			a9 60		       lda	#$60
   1689  2706d			8d 07 21	       sta	sCTRL
   1690  27070			85 3c		       sta	CTRL
   1691  27072					       ifnconst	hiscorefont
   1692  27072			02		       .byte.b	$02	; KIL/JAM
   1693  27073				   -	       else		; hiscorefont is present
   1694  27073				   -	       ifconst	CRASHDUMP
   1695  27073				   -	       bit	MSTAT
   1696  27073				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   1697  27073				   -
   1698  27073				   -	       ifconst	dumpbankswitch
   1699  27073				   -	       lda	dumpbankswitch
   1700  27073				   -	       pha
   1701  27073				   -	       endif
   1702  27073				   -
   1703  27073				   -			; bankswitch if needed, to get to the hiscore font
   1704  27073				   -	       ifconst	bankswitchmode
   1705  27073				   -	       ifconst	included.hiscore.asm.bank
   1706  27073				   -	       ifconst	MCPDEVCART
   1707  27073				   -	       lda	#($18 | included.hiscore.asm.bank)
   1708  27073				   -	       sta	$3000
   1709  27073				   -	       else
   1710  27073				   -	       lda	#(included.hiscore.asm.bank)
   1711  27073				   -	       sta	$8000
   1712  27073				   -	       endif
   1713  27073				   -	       endif		; included.hiscore.asm.bank
   1714  27073				   -	       endif		; bankswitchmode
   1715  27073				   -
   1716  27073				   -	       ifconst	DOUBLEBUFFER
   1717  27073				   -			;turn off double-buffering, if on...
   1718  27073				   -	       lda	#>DLLMEM
   1719  27073				   -	       sta	DPPH
   1720  27073				   -	       lda	#<DLLMEM
   1721  27073				   -	       sta	DPPL
   1722  27073				   -	       endif
   1723  27073				   -
   1724  27073				   -	       lda	#$00
   1725  27073				   -	       sta	P0C2
   1726  27073				   -
   1727  27073				   -			;update the second-from-top DL...
   1728  27073				   -	       ldy	#8
   1729  27073				   -NMIupdatetopDL
   1730  27073				   -	       lda	show2700,y
   1731  27073				   -	       sta	ZONE1ADDRESS,y
   1732  27073				   -	       dey
   1733  27073				   -	       bpl	NMIupdatetopDL
   1734  27073				   -
   1735  27073				   -			; the hiscore font is present, so we try to output the stack
   1736  27073				   -	       ldy	#0
   1737  27073				   -copystackloop
   1738  27073				   -	       pla
   1739  27073				   -	       pha
   1740  27073				   -	       lsr
   1741  27073				   -	       lsr
   1742  27073				   -	       lsr
   1743  27073				   -	       lsr
   1744  27073				   -	       tax
   1745  27073				   -	       lda	hiscorehexlut,x
   1746  27073				   -	       sta	$2700,y
   1747  27073				   -	       iny
   1748  27073				   -
   1749  27073				   -	       pla
   1750  27073				   -	       and	#$0F
   1751  27073				   -	       tax
   1752  27073				   -	       lda	hiscorehexlut,x
   1753  27073				   -	       sta	$2700,y
   1754  27073				   -	       iny
   1755  27073				   -
   1756  27073				   -	       lda	#27	; period
   1757  27073				   -	       sta	$2700,y
   1758  27073				   -	       iny
   1759  27073				   -
   1760  27073				   -	       cpy	#30
   1761  27073				   -	       bne	copystackloop
   1762  27073				   -
   1763  27073				   -	       lda	#>hiscorefont
   1764  27073				   -	       sta	CHARBASE
   1765  27073				   -	       sta	sCHARBASE
   1766  27073				   -	       lda	#%01000011	;Enable DMA, mode=320A
   1767  27073				   -	       sta	CTRL
   1768  27073				   -	       sta	sCTRL
   1769  27073				   -	       .byte	$02	; KIL/JAM
   1770  27073				   -hiscorehexlut
   1771  27073				   -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   1772  27073				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   1773  27073				   -show2700
   1774  27073				   -			;	 lo   mode	   hi	width=29  x   EODL
   1775  27073				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   1776  27073				   -	       else		; CRASHDUMP
   1777  27073				   -	       .byte	$02	; KIL/JAM
   1778  27073				   -	       endif		; crashdump
   1779  27073					       endif		; hiscorefont
   1780  27073				   -	       else
   1781  27073				   -	       RTI
   1782  27073					       endif
   1783  27073
   1784  27073				   -	       ifconst	LONGCONTROLLERREAD
   1785  27073				   -
   1786  27073				   -longreadtype
   1787  27073				   -	       .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   1788  27073				   -	       .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   1789  27073				   -	       .byte	3, 3, 0, 0	; STMOUSE  AMOUSE    ATARIVOX	SNES
   1790  27073				   -
   1791  27073				   -longreadroutineloP0
   1792  27073				   -	       .byte	<LLRET0	;  0 = no routine
   1793  27073				   -	       .byte	<paddleport0update	;  1 = paddle
   1794  27073				   -	       .byte	<trakball0update	;  2 = trakball
   1795  27073				   -	       .byte	<mouse0update	;  3 = mouse
   1796  27073				   -
   1797  27073				   -longreadroutinehiP0
   1798  27073				   -	       .byte	>LLRET0	;  0 = no routine
   1799  27073				   -	       .byte	>paddleport0update	;  1 = paddle
   1800  27073				   -	       .byte	>trakball0update	;  2 = trackball
   1801  27073				   -	       .byte	>mouse0update	;  3 = mouse
   1802  27073				   -
   1803  27073				   -longreadroutineloP1
   1804  27073				   -	       .byte	<LLRET1	;  0 = no routine
   1805  27073				   -	       .byte	<paddleport1update	;  1 = paddle
   1806  27073				   -	       .byte	<trakball1update	;  2 = trakball
   1807  27073				   -	       .byte	<mouse1update	;  3 = mouse
   1808  27073				   -
   1809  27073				   -longreadroutinehiP1
   1810  27073				   -	       .byte	>LLRET1	;  0 = no routine
   1811  27073				   -	       .byte	>paddleport1update	;  1 = paddle
   1812  27073				   -	       .byte	>trakball1update	;  2 = trackball
   1813  27073				   -	       .byte	>mouse1update	;  3 = mouse
   1814  27073				   -
   1815  27073				   -
   1816  27073				   -SETTIM64T
   1817  27073				   -	       bne	skipdefaulttime
   1818  27073				   -	       ifnconst	PADDLESMOOTHINGOFF
   1819  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   1820  27073				   -	       else
   1821  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   1822  27073				   -	       endif
   1823  27073				   -skipdefaulttime
   1824  27073				   -	       tay
   1825  27073				   -	       dey
   1826  27073				   -.setTIM64Tloop
   1827  27073				   -	       sta	TIM64T
   1828  27073				   -	       cpy	INTIM
   1829  27073				   -	       bne	.setTIM64Tloop
   1830  27073				   -	       rts
   1831  27073					       endif		; LONGCONTROLLERREAD
   1832  27073
   1833  27073				    reallyoffvisible
   1834  27073			85 24		       sta	WSYNC
   1835  27075
   1836  27075			a9 00		       lda	#0
   1837  27077			85 4d		       sta	visibleover
   1838  27079				   -	       ifconst	DEBUGINTERRUPT
   1839  27079				   -	       sta	BACKGRND
   1840  27079					       endif
   1841  27079
   1842  27079			a9 03		       lda	#3
   1843  2707b			8d b2 01	       sta	interruptindex
   1844  2707e
   1845  2707e			20 73 f1	       jsr	uninterruptableroutines
   1846  27081
   1847  27081				   -	       ifconst	.userinterrupt
   1848  27081				   -	       lda	interrupthold
   1849  27081				   -	       beq	skipuserintroutine
   1850  27081				   -	       jsr	.userinterrupt
   1851  27081				   -skipuserintroutine
   1852  27081					       endif
   1853  27081
   1854  27081				   -	       ifconst	KEYPADSUPPORT
   1855  27081				   -	       jsr	keypadcolumnread
   1856  27081				   -	       jsr	keypadrowselect
   1857  27081					       endif
   1858  27081
   1859  27081				    NMIexit
   1860  27081			68		       pla
   1861  27082			a8		       tay
   1862  27083			68		       pla
   1863  27084			aa		       tax
   1864  27085			68		       pla
   1865  27086			40		       RTI
   1866  27087
   1867  27087				    clearscreen
   1868  27087			a2 0b		       ldx	#(WZONECOUNT-1)
   1869  27089			a9 00		       lda	#0
   1870  2708b				    clearscreenloop
   1871  2708b			95 65		       sta	dlend,x
   1872  2708d			ca		       dex
   1873  2708e			10 fb		       bpl	clearscreenloop
   1874  27090			a9 00		       lda	#0
   1875  27092			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   1876  27095			8d ae 01	       sta	valbufendsave
   1877  27098			60		       rts
   1878  27099
   1879  27099				    restorescreen
   1880  27099			a2 0b		       ldx	#(WZONECOUNT-1)
   1881  2709b			a9 00		       lda	#0
   1882  2709d				    restorescreenloop
   1883  2709d			b5 82		       lda	dlendsave,x
   1884  2709f			95 65		       sta	dlend,x
   1885  270a1			ca		       dex
   1886  270a2			10 f9		       bpl	restorescreenloop
   1887  270a4			ad ae 01	       lda	valbufendsave
   1888  270a7			8d ad 01	       sta	valbufend
   1889  270aa			60		       rts
   1890  270ab
   1891  270ab				    savescreen
   1892  270ab			a2 0b		       ldx	#(WZONECOUNT-1)
   1893  270ad				    savescreenloop
   1894  270ad			b5 65		       lda	dlend,x
   1895  270af			95 82		       sta	dlendsave,x
   1896  270b1			ca		       dex
   1897  270b2			10 f9		       bpl	savescreenloop
   1898  270b4			ad ad 01	       lda	valbufend
   1899  270b7			8d ae 01	       sta	valbufendsave
   1900  270ba					       ifconst	DOUBLEBUFFER
   1901  270ba			a5 d5		       lda	doublebufferstate
   1902  270bc			f0 04		       beq	savescreenrts
   1903  270be			a9 01		       lda	#1
   1904  270c0			85 d7		       sta	doublebufferbufferdirty
   1905  270c2				    savescreenrts
   1906  270c2					       endif		; DOUBLEBUFFER
   1907  270c2			60		       rts
   1908  270c3
   1909  270c3				    drawscreen
   1910  270c3
   1911  270c3				   -	       ifconst	interrupthold
   1912  270c3				   -	       lda	#$FF
   1913  270c3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   1914  270c3					       endif
   1915  270c3
   1916  270c3			a9 00		       lda	#0
   1917  270c5			85 42		       sta	temp1	; not B&W if we're here...
   1918  270c7
   1919  270c7				    drawscreenwait
   1920  270c7			a5 4d		       lda	visibleover
   1921  270c9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   1922  270cb
   1923  270cb							;restore some registers in case the game changed them mid-screen...
   1924  270cb			ad 07 21	       lda	sCTRL
   1925  270ce			05 42		       ora	temp1
   1926  270d0			85 3c		       sta	CTRL
   1927  270d2			ad 0b 21	       lda	sCHARBASE
   1928  270d5			85 34		       sta	CHARBASE
   1929  270d7
   1930  270d7							;ensure all of the display list is terminated...
   1931  270d7			20 50 f1	       jsr	terminatedisplaylist
   1932  270da
   1933  270da					       ifnconst	pauseroutineoff
   1934  270da			20 e5 f0	       jsr	pauseroutine
   1935  270dd					       endif		; pauseroutineoff
   1936  270dd
   1937  270dd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   1938  270dd							; delaying a full frame, but still allowing time for basic calculations.
   1939  270dd				    visiblescreenstartedwait
   1940  270dd			a5 4d		       lda	visibleover
   1941  270df			f0 fc		       beq	visiblescreenstartedwait
   1942  270e1				    visiblescreenstartedwaitdone
   1943  270e1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   1944  270e4			60		       rts
   1945  270e5
   1946  270e5					       ifnconst	pauseroutineoff
   1947  270e5							; check to see if pause was pressed and released
   1948  270e5				    pauseroutine
   1949  270e5			ad b5 01	       lda	pausedisable
   1950  270e8			d0 55		       bne	leavepauseroutine
   1951  270ea			a9 08		       lda	#8
   1952  270ec			2c 82 02	       bit	SWCHB
   1953  270ef			f0 30		       beq	pausepressed
   1954  270f1
   1955  270f1					       ifnconst	SOFTPAUSEOFF
   1956  270f1					       ifnconst	SOFTRESETASPAUSEOFF
   1957  270f1					       ifnconst	MOUSESUPPORT
   1958  270f1					       ifnconst	TRAKBALLSUPPORT
   1959  270f1			ad b9 01	       lda	port0control
   1960  270f4			c9 0b		       cmp	#11
   1961  270f6			d0 07		       bne	skipsoftpause
   1962  270f8			ad 80 02	       lda	SWCHA	; then check the soft "RESET" joysick code...
   1963  270fb			29 70		       and	#%01110000	; _LDU
   1964  270fd			f0 22		       beq	pausepressed
   1965  270ff				    skipsoftpause
   1966  270ff					       endif
   1967  270ff					       endif
   1968  270ff					       endif
   1969  270ff					       endif
   1970  270ff				   -	       ifconst	SNES0PAUSE
   1971  270ff				   -	       lda	port0control
   1972  270ff				   -	       cmp	#11
   1973  270ff				   -	       bne	skipsnes0pause
   1974  270ff				   -	       lda	snesdetected0
   1975  270ff				   -	       beq	skipsnes0pause
   1976  270ff				   -	       lda	snes2atari0hi
   1977  270ff				   -	       and	#%00010000
   1978  270ff				   -	       beq	pausepressed
   1979  270ff				   -skipsnes0pause
   1980  270ff					       endif
   1981  270ff				   -	       ifconst	SNES1PAUSE
   1982  270ff				   -
   1983  270ff				   -	       lda	port1control
   1984  270ff				   -	       cmp	#11
   1985  270ff				   -	       bne	skipsnes1pause
   1986  270ff				   -	       lda	snesdetected1
   1987  270ff				   -	       beq	skipsnes1pause
   1988  270ff				   -	       lda	snes2atari1hi
   1989  270ff				   -	       and	#%00010000
   1990  270ff				   -	       beq	pausepressed
   1991  270ff				   -skipsnes1pause
   1992  270ff					       endif
   1993  270ff				   -	       ifconst	SNESNPAUSE
   1994  270ff				   -	       ldx	snesport
   1995  270ff				   -	       lda	port0control,x
   1996  270ff				   -	       cmp	#11
   1997  270ff				   -	       bne	skipsnesNpause
   1998  270ff				   -	       lda	snesdetected0,x
   1999  270ff				   -	       beq	skipsnesNpause
   2000  270ff				   -	       lda	snes2atari0hi,x
   2001  270ff				   -	       and	#%00010000
   2002  270ff				   -	       beq	pausepressed
   2003  270ff				   -skipsnesNpause
   2004  270ff					       endif
   2005  270ff
   2006  270ff							;pause isn't pressed
   2007  270ff			a9 00		       lda	#0
   2008  27101			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2009  27104
   2010  27104							;check if we're in an already paused state
   2011  27104			ad 00 21	       lda	pausestate
   2012  27107			f0 36		       beq	leavepauseroutine	; nope, leave
   2013  27109
   2014  27109			c9 01		       cmp	#1	; last frame was the start of pausing
   2015  2710b			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   2016  2710d
   2017  2710d			c9 02		       cmp	#2
   2018  2710f			f0 34		       beq	carryonpausing
   2019  27111
   2020  27111							;pausestate must be >2, which means we're ending an unpause 
   2021  27111			a9 00		       lda	#0
   2022  27113			8d ac 01	       sta	pausebuttonflag
   2023  27116			8d 00 21	       sta	pausestate
   2024  27119			ad 07 21	       lda	sCTRL
   2025  2711c			85 3c		       sta	CTRL
   2026  2711e			4c 3f f1	       jmp	leavepauseroutine
   2027  27121
   2028  27121				    pausepressed
   2029  27121							;pause is pressed
   2030  27121			ad ac 01	       lda	pausebuttonflag
   2031  27124			c9 ff		       cmp	#$ff
   2032  27126			f0 1d		       beq	carryonpausing
   2033  27128
   2034  27128							;its a new press, increment the state
   2035  27128			ee 00 21	       inc	pausestate
   2036  2712b
   2037  2712b							;silence volume at the start and end of pausing
   2038  2712b			a9 00		       lda	#0
   2039  2712d			85 19		       sta	AUDV0
   2040  2712f			85 1a		       sta	AUDV1
   2041  27131
   2042  27131				   -	       ifconst	pokeysupport
   2043  27131				   -	       ldy	#7
   2044  27131				   -pausesilencepokeyaudioloop
   2045  27131				   -	       sta	(pokeybase),y
   2046  27131				   -	       dey
   2047  27131				   -	       bpl	pausesilencepokeyaudioloop
   2048  27131					       endif		; pokeysupport
   2049  27131
   2050  27131			a9 ff		       lda	#$ff
   2051  27133			8d ac 01	       sta	pausebuttonflag
   2052  27136			d0 0d		       bne	carryonpausing
   2053  27138
   2054  27138				    enterpausestate2
   2055  27138			a9 02		       lda	#2
   2056  2713a			8d 00 21	       sta	pausestate
   2057  2713d			d0 06		       bne	carryonpausing
   2058  2713f				    leavepauseroutine
   2059  2713f			ad 07 21	       lda	sCTRL
   2060  27142			85 3c		       sta	CTRL
   2061  27144			60		       rts
   2062  27145				    carryonpausing
   2063  27145				   -	       ifconst	.pause
   2064  27145				   -	       jsr	.pause
   2065  27145					       endif		; .pause
   2066  27145			ad 07 21	       lda	sCTRL
   2067  27148			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2068  2714a			85 3c		       sta	CTRL
   2069  2714c			4c e5 f0	       jmp	pauseroutine
   2070  2714f					       endif		; pauseroutineoff
   2071  2714f
   2072  2714f
   2073  2714f					       ifconst	DOUBLEBUFFER
   2074  2714f				    skipterminatedisplaylistreturn
   2075  2714f			60		       rts
   2076  27150					       endif		; DOUBLEBUFFER
   2077  27150				    terminatedisplaylist
   2078  27150					       ifconst	DOUBLEBUFFER
   2079  27150			a5 d5		       lda	doublebufferstate
   2080  27152			d0 fb		       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2081  27154					       endif		; DOUBLEBUFFER
   2082  27154				    terminatedisplaybuffer
   2083  27154							;add DL end entry on each DL
   2084  27154			a2 0b		       ldx	#(WZONECOUNT-1)
   2085  27156				    dlendloop
   2086  27156			bd e2 f6	       lda	DLPOINTL,x
   2087  27159					       ifconst	DOUBLEBUFFER
   2088  27159			18		       clc
   2089  2715a			65 d6		       adc	doublebufferdloffset
   2090  2715c					       endif		; DOUBLEBUFFER
   2091  2715c			85 63		       sta	dlpnt
   2092  2715e			bd d6 f6	       lda	DLPOINTH,x
   2093  27161					       ifconst	DOUBLEBUFFER
   2094  27161			69 00		       adc	#0
   2095  27163					       endif		; DOUBLEBUFFER
   2096  27163			85 64		       sta	dlpnt+1
   2097  27165			b4 65		       ldy	dlend,x
   2098  27167			a9 00		       lda	#$00
   2099  27169				    dlendmoreloops
   2100  27169			c8		       iny
   2101  2716a			91 63		       sta	(dlpnt),y
   2102  2716c				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2103  2716c				   -	       cpy	#DLLASTOBJ+1
   2104  2716c				   -	       beq	dlendthiszonedone
   2105  2716c				   -	       iny
   2106  2716c				   -	       iny
   2107  2716c				   -	       iny
   2108  2716c				   -	       iny
   2109  2716c				   -	       iny
   2110  2716c				   -	       sta	(dlpnt),y
   2111  2716c				   -dlendthiszonedone
   2112  2716c					       endif	FRAMESKIPGLITCHFIXWEAK
   2113  2716c				   -	       ifconst	FRAMESKIPGLITCHFIX
   2114  2716c				   -	       iny
   2115  2716c				   -	       iny
   2116  2716c				   -	       iny
   2117  2716c				   -	       iny
   2118  2716c				   -	       cpy	#DLLASTOBJ-1
   2119  2716c				   -	       bcc	dlendmoreloops
   2120  2716c					       endif		; FRAMESKIPGLITCHFIX
   2121  2716c			ca		       dex
   2122  2716d			10 e7		       bpl	dlendloop
   2123  2716f
   2124  2716f					       ifnconst	pauseroutineoff
   2125  2716f			20 e5 f0	       jsr	pauseroutine
   2126  27172					       endif		; pauseroutineoff
   2127  27172			60		       rts
   2128  27173
   2129  27173				    uninterruptableroutines
   2130  27173							; this is for routines that must happen off the visible screen, each frame.
   2131  27173
   2132  27173				   -	       ifconst	AVOXVOICE
   2133  27173				   -	       jsr	serviceatarivoxqueue
   2134  27173					       endif
   2135  27173
   2136  27173			a9 00		       lda	#0
   2137  27175			8d b8 01	       sta	palfastframe
   2138  27178			ad 09 21	       lda	paldetected
   2139  2717b			f0 10		       beq	skippalframeadjusting
   2140  2717d							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   2141  2717d			ae b7 01	       ldx	palframes
   2142  27180			e8		       inx
   2143  27181			e0 05		       cpx	#5
   2144  27183			d0 05		       bne	palframeskipdone
   2145  27185			ee b8 01	       inc	palfastframe
   2146  27188			a2 00		       ldx	#0
   2147  2718a				    palframeskipdone
   2148  2718a			8e b7 01	       stx	palframes
   2149  2718d				    skippalframeadjusting
   2150  2718d
   2151  2718d				   -	       ifconst	MUSICTRACKER
   2152  2718d				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2153  2718d				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2154  2718d				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   2155  2718d				   -			; problem twice, and if we do, we just drop a musical note or two.
   2156  2718d				   -	       lda	sfxschedulemissed
   2157  2718d				   -	       beq	servicesongwasnotmissed
   2158  2718d				   -	       jsr	servicesong
   2159  2718d				   -servicesongwasnotmissed
   2160  2718d					       endif		; MUSICTRACKER
   2161  2718d
   2162  2718d				   -	       ifconst	RMT
   2163  2718d				   -	       lda	palfastframe
   2164  2718d				   -	       beq	skiprasterupdate2
   2165  2718d				   -	       lda	rasterpause
   2166  2718d				   -	       beq	skiprasterupdate2
   2167  2718d				   -	       jsr	RASTERMUSICTRACKER+3
   2168  2718d				   -skiprasterupdate2
   2169  2718d					       endif
   2170  2718d
   2171  2718d
   2172  2718d			60		       rts
   2173  2718e
   2174  2718e				    serviceatarivoxqueue
   2175  2718e				   -	       ifconst	AVOXVOICE
   2176  2718e				   -	       lda	voxlock
   2177  2718e				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2178  2718e				   -skipvoxqueuesizedec
   2179  2718e				   -	       jmp	processavoxvoice
   2180  2718e				   -skipvoxprocessing
   2181  2718e				   -	       rts
   2182  2718e				   -
   2183  2718e				   -processavoxvoice
   2184  2718e				   -	       ifconst	HSSUPPORT
   2185  2718e				   -			; ** we skip speech if hi-score is on and no vox was detected
   2186  2718e				   -			; ** this is to avoid later collision with snes pads.
   2187  2718e				   -	       lda	hsdevice
   2188  2718e				   -	       and	#2
   2189  2718e				   -	       beq	processavoxvoicereturn
   2190  2718e				   -	       endif		; HSSUPPORT
   2191  2718e				   -	       lda	avoxenable
   2192  2718e				   -	       bne	avoxfixport
   2193  2718e				   -	       SPKOUT	tempavox
   2194  2718e				   -	       rts
   2195  2718e				   -avoxfixport
   2196  2718e				   -	       lda	#0	; restore the port to all bits as inputs...
   2197  2718e				   -	       sta	CTLSWA
   2198  2718e				   -	       rts
   2199  2718e				   -silenceavoxvoice
   2200  2718e				   -	       SPEAK	avoxsilentdata
   2201  2718e				   -processavoxvoicereturn
   2202  2718e				   -	       rts
   2203  2718e				   -avoxsilentdata
   2204  2718e				   -	       .byte	31,255
   2205  2718e					       else
   2206  2718e			60		       rts
   2207  2718f					       endif		; AVOXVOICE
   2208  2718f
   2209  2718f				    joybuttonhandler
   2210  2718f			8a		       txa
   2211  27190			0a		       asl
   2212  27191			a8		       tay
   2213  27192			b9 08 00	       lda	INPT0,y
   2214  27195			4a		       lsr
   2215  27196			9d 02 21	       sta	sINPT1,x
   2216  27199			b9 09 00	       lda	INPT1,y
   2217  2719c			29 80		       and	#%10000000
   2218  2719e			1d 02 21	       ora	sINPT1,x
   2219  271a1			9d 02 21	       sta	sINPT1,x
   2220  271a4
   2221  271a4			b5 0c		       lda	INPT4,x
   2222  271a6			30 19		       bmi	.skip1bjoyfirecheck
   2223  271a8							;one button joystick is down
   2224  271a8			49 80		       eor	#%10000000
   2225  271aa			9d 02 21	       sta	sINPT1,x
   2226  271ad
   2227  271ad			ad b1 01	       lda	joybuttonmode
   2228  271b0			3d c4 f1	       and	twobuttonmask,x
   2229  271b3			f0 0c		       beq	.skip1bjoyfirecheck
   2230  271b5			ad b1 01	       lda	joybuttonmode
   2231  271b8			1d c4 f1	       ora	twobuttonmask,x
   2232  271bb			8d b1 01	       sta	joybuttonmode
   2233  271be			8d 82 02	       sta	SWCHB
   2234  271c1				    .skip1bjoyfirecheck
   2235  271c1			4c 57 f0	       jmp	buttonreadloopreturn
   2236  271c4
   2237  271c4				    twobuttonmask
   2238  271c4			04 10		       .byte.b	%00000100,%00010000
   2239  271c6
   2240  271c6				   -	       ifconst	SNES2ATARISUPPORT
   2241  271c6				   -
   2242  271c6				   -SNES_CLOCK_PORT_BIT
   2243  271c6				   -	       .byte	$10,$01
   2244  271c6				   -SNES_CTLSWA_MASK
   2245  271c6				   -	       .byte	$30,$03
   2246  271c6				   -SNES_CTLSWA_SIGNAL
   2247  271c6				   -	       .byte	$C0,$0C
   2248  271c6				   -SWCHA_DIRMASK
   2249  271c6				   -	       .byte	$F0,$0F
   2250  271c6				   -SWCHA_INVDIRMASK
   2251  271c6				   -	       .byte	$0F,$F0
   2252  271c6				   -
   2253  271c6				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
   2254  271c6				   -SNES_AUTODETECT
   2255  271c6				   -	       ifconst	HSSUPPORT
   2256  271c6				   -			; ** an atarivox might be plugged in, so we skip scanning the second
   2257  271c6				   -			; ** port for a snes if vox was detected...
   2258  271c6				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
   2259  271c6				   -	       lsr
   2260  271c6				   -	       and	#1
   2261  271c6				   -	       eor	#1
   2262  271c6				   -	       tax
   2263  271c6				   -	       else
   2264  271c6				   -	       ldx	#1
   2265  271c6				   -	       endif		; HSSUPPORT
   2266  271c6				   -
   2267  271c6				   -SNES_AUTODETECT_LOOP
   2268  271c6				   -	       lda	#1	; proline
   2269  271c6				   -	       sta	port0control,x
   2270  271c6				   -	       jsr	setportforinput
   2271  271c6				   -	       jsr	setonebuttonmode
   2272  271c6				   -	       jsr	SNES_READ
   2273  271c6				   -	       lda	snesdetected0,x
   2274  271c6				   -	       bne	SNES_AUTODETECT_FOUND
   2275  271c6				   -			; detection failed
   2276  271c6				   -	       jsr	setportforinput
   2277  271c6				   -	       jsr	settwobuttonmode
   2278  271c6				   -	       dex
   2279  271c6				   -	       bpl	SNES_AUTODETECT_LOOP
   2280  271c6				   -	       rts
   2281  271c6				   -SNES_AUTODETECT_FOUND
   2282  271c6				   -	       lda	#11	; formally set the snes controller
   2283  271c6				   -	       sta	port0control,x
   2284  271c6				   -	       stx	snesport
   2285  271c6				   -	       rts
   2286  271c6					       endif		; SNES2ATARISUPPORT
   2287  271c6
   2288  271c6				    snes2atarihandler
   2289  271c6				   -	       ifconst	SNES2ATARISUPPORT
   2290  271c6				   -SNES2ATARI
   2291  271c6				   -	       jsr	SNES_READ
   2292  271c6				   -	       jmp	buttonreadloopreturn
   2293  271c6				   -
   2294  271c6				   -SNES_READ
   2295  271c6				   -			; x=0 for left port, x=1 for right
   2296  271c6				   -
   2297  271c6				   -			; Start by checking if any port directions are pressed. 
   2298  271c6				   -			; Abort the autodetect for this port if so, as snes2atari doesn't ground any 
   2299  271c6				   -			; direction pins. if directions are pressed and the port is changed to output,
   2300  271c6				   -			; that means the output is direct-shorted, and nobody seems to know if riot's
   2301  271c6				   -			; output mode has current protection.
   2302  271c6				   -
   2303  271c6				   -	       lda	SWCHA
   2304  271c6				   -	       ora	SWCHA_INVDIRMASK,x
   2305  271c6				   -	       eor	SWCHA_DIRMASK,x
   2306  271c6				   -	       bne	SNES_READ_cont1
   2307  271c6				   -	       jmp	SNES_ABORT
   2308  271c6				   -SNES_READ_cont1
   2309  271c6				   -
   2310  271c6				   -	       lda	port0control,x
   2311  271c6				   -	       cmp	#11	; snes
   2312  271c6				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
   2313  271c6				   -	       lda	snesdetected0,x
   2314  271c6				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
   2315  271c6				   -snes2atari_signal_go
   2316  271c6				   -	       jsr	SNES2ATARI_SIGNAL
   2317  271c6				   -snes2atari_signal_skip
   2318  271c6				   -
   2319  271c6				   -			;lda SNES_CTLSWA_MASK,x
   2320  271c6				   -
   2321  271c6				   -	       lda	CTLSWA
   2322  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2323  271c6				   -	       ora	SNES_CTLSWA_MASK,x
   2324  271c6				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
   2325  271c6				   -
   2326  271c6				   -	       lda	SWCHA
   2327  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2328  271c6				   -	       ora	SNES_CTLSWA_MASK,x
   2329  271c6				   -
   2330  271c6				   -	       sta	SWCHA	; latch+clock high
   2331  271c6				   -	       nop
   2332  271c6				   -	       nop
   2333  271c6				   -	       nop
   2334  271c6				   -	       nop
   2335  271c6				   -	       nop
   2336  271c6				   -	       nop
   2337  271c6				   -	       nop
   2338  271c6				   -	       lda	SWCHA
   2339  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2340  271c6				   -	       sta	SWCHA	; latch and clock low
   2341  271c6				   -	       ldy	#16	; 16 bits 
   2342  271c6				   -SNES2ATARILOOP
   2343  271c6				   -	       rol	INPT4,x	; sample data into carry
   2344  271c6				   -	       lda	SWCHA
   2345  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2346  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2347  271c6				   -	       sta	SWCHA	; clock low
   2348  271c6				   -	       rol	snes2atari0lo,x
   2349  271c6				   -	       rol	snes2atari0hi,x
   2350  271c6				   -	       lda	SWCHA
   2351  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2352  271c6				   -	       sta	SWCHA	; latch and clock low
   2353  271c6				   -	       dey		; next bit
   2354  271c6				   -	       bne	SNES2ATARILOOP
   2355  271c6				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
   2356  271c6				   -	       rol		; 17th snes bit into A low bit
   2357  271c6				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
   2358  271c6				   -	       and	#1
   2359  271c6				   -	       sta	snesdetected0,x
   2360  271c6				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
   2361  271c6				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
   2362  271c6				   -	       lda	SWCHA
   2363  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2364  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2365  271c6				   -SNES_STOP_CLOCK
   2366  271c6				   -	       sta	SWCHA	; clock low
   2367  271c6				   -	       lda	CTLSWA
   2368  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2369  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2370  271c6				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
   2371  271c6				   -	       rts
   2372  271c6				   -SNES_ABORT
   2373  271c6				   -	       sta	snesdetected0,x
   2374  271c6				   -	       rts
   2375  271c6				   -SNES2ATARI_SIGNAL
   2376  271c6				   -			; signal to SNES2ATARI++ that we want SNES mode...
   2377  271c6				   -	       lda	CTLSWA
   2378  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2379  271c6				   -	       ora	SNES_CTLSWA_SIGNAL,x
   2380  271c6				   -	       sta	CTLSWA
   2381  271c6				   -	       lda	CTLSWA
   2382  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2383  271c6				   -	       sta	SWCHA
   2384  271c6				   -	       ldy	#0
   2385  271c6				   -SNES_SIGNAL_LOOP
   2386  271c6				   -	       dey
   2387  271c6				   -	       bne	SNES_SIGNAL_LOOP
   2388  271c6				   -	       lda	SWCHA
   2389  271c6				   -	       ora	SWCHA_DIRMASK,x
   2390  271c6				   -	       sta	SWCHA
   2391  271c6				   -	       rts
   2392  271c6					       endif
   2393  271c6
   2394  271c6				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2395  271c6				   -	       ifconst	LIGHTGUNSUPPORT
   2396  271c6				   -	       cpx	#0
   2397  271c6				   -	       bne	secondportgunhandler
   2398  271c6				   -firstportgunhandler
   2399  271c6				   -	       lda	SWCHA
   2400  271c6				   -	       asl
   2401  271c6				   -	       asl
   2402  271c6				   -	       asl		; shift D4 to D7
   2403  271c6				   -	       and	#%10000000
   2404  271c6				   -	       eor	#%10000000
   2405  271c6				   -	       sta	sINPT1
   2406  271c6				   -	       jmp	buttonreadloopreturn
   2407  271c6				   -secondportgunhandler
   2408  271c6				   -	       lda	SWCHA
   2409  271c6				   -	       lsr		; shift D0 into carry
   2410  271c6				   -	       lsr		; shift carry into D7
   2411  271c6				   -	       and	#%10000000
   2412  271c6				   -	       eor	#%10000000
   2413  271c6				   -	       sta	sINPT3
   2414  271c6				   -	       jmp	buttonreadloopreturn
   2415  271c6					       endif		; LIGHTGUNSUPPORT
   2416  271c6
   2417  271c6				    controlsusing2buttoncode
   2418  271c6			00		       .byte.b	0	; 00=no controller plugged in
   2419  271c7			01		       .byte.b	1	; 01=proline joystick
   2420  271c8			00		       .byte.b	0	; 02=lightgun
   2421  271c9			00		       .byte.b	0	; 03=paddle
   2422  271ca			01		       .byte.b	1	; 04=trakball
   2423  271cb			01		       .byte.b	1	; 05=vcs joystick
   2424  271cc			01		       .byte.b	1	; 06=driving control
   2425  271cd			00		       .byte.b	0	; 07=keypad control
   2426  271ce			00		       .byte.b	0	; 08=st mouse/cx80
   2427  271cf			00		       .byte.b	0	; 09=amiga mouse
   2428  271d0			01		       .byte.b	1	; 10=atarivox
   2429  271d1			00		       .byte.b	0	; 11=snes2atari
   2430  271d2
   2431  271d2				    buttonhandlerhi
   2432  271d2			00		       .byte.b	0	; 00=no controller plugged in
   2433  271d3			f1		       .byte.b	>joybuttonhandler	; 01=proline joystick
   2434  271d4			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   2435  271d5			f6		       .byte.b	>paddlebuttonhandler	; 03=paddle
   2436  271d6			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   2437  271d7			f1		       .byte.b	>joybuttonhandler	; 05=vcs joystick
   2438  271d8			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   2439  271d9			00		       .byte.b	0	; 07=keypad
   2440  271da			f6		       .byte.b	>mousebuttonhandler	; 08=st mouse
   2441  271db			f6		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2442  271dc			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   2443  271dd			f1		       .byte.b	>snes2atarihandler	; 11=snes
   2444  271de				    buttonhandlerlo
   2445  271de			00		       .byte.b	0	; 00=no controller plugged in
   2446  271df			8f		       .byte.b	<joybuttonhandler	; 01=proline joystick
   2447  271e0			c6		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   2448  271e1			1a		       .byte.b	<paddlebuttonhandler	; 03=paddle
   2449  271e2			8f		       .byte.b	<joybuttonhandler	; 04=trakball
   2450  271e3			8f		       .byte.b	<joybuttonhandler	; 05=vcs joystick
   2451  271e4			8f		       .byte.b	<joybuttonhandler	; 06=driving control
   2452  271e5			00		       .byte.b	0	; 07=keypad
   2453  271e6			1a		       .byte.b	<mousebuttonhandler	; 08=st mouse
   2454  271e7			1a		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2455  271e8			8f		       .byte.b	<joybuttonhandler	; 10=atarivox
   2456  271e9			c6		       .byte.b	<snes2atarihandler	; 11=snes
   2457  271ea
   2458  271ea				    drawwait
   2459  271ea			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2460  271ec			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   2461  271ee			60		       rts
   2462  271ef
   2463  271ef				    drawoverwait
   2464  271ef			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2465  271f1			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   2466  271f3			60		       rts
   2467  271f4
   2468  271f4
   2469  271f4				    mutetia
   2470  271f4			a9 00		       lda	#0
   2471  271f6			a2 03		       ldx	#3
   2472  271f8				    mutetialoop
   2473  271f8			95 4e		       sta	sfx1pointlo,x
   2474  271fa			95 17		       sta	AUDF0,x
   2475  271fc			ca		       dex
   2476  271fd			10 f9		       bpl	mutetialoop
   2477  271ff			60		       rts
   2478  27200
   2479  27200				    servicesfxchannelsdone
   2480  27200					       ifnconst	pokeysupport
   2481  27200			60		       rts
   2482  27201				   -	       else
   2483  27201				   -	       jmp	checkpokeyplaying
   2484  27201					       endif
   2485  27201				    servicesfxchannels
   2486  27201			a2 ff		       ldx	#255
   2487  27203				    servicesfxchannelsloop
   2488  27203			e8		       inx
   2489  27204					       ifnconst	TIASFXMONO
   2490  27204			e0 02		       cpx	#2
   2491  27206				   -	       else
   2492  27206				   -	       cpx	#1
   2493  27206					       endif
   2494  27206			f0 f8		       beq	servicesfxchannelsdone
   2495  27208
   2496  27208			a5 de		       lda	sfxschedulelock	; =1 if locked
   2497  2720a			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   2498  2720c
   2499  2720c			b5 4e		       lda	sfx1pointlo,x
   2500  2720e			85 dc		       sta	inttemp5
   2501  27210			15 50		       ora	sfx1pointhi,x
   2502  27212			f0 ef		       beq	servicesfxchannelsloop
   2503  27214			b5 50		       lda	sfx1pointhi,x
   2504  27216			85 dd		       sta	inttemp6
   2505  27218
   2506  27218			b5 58		       lda	sfx1tick,x
   2507  2721a			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   2508  2721c			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2509  2721e			4c 03 f2	       jmp	servicesfxchannelsloop
   2510  27221				    servicesfx_cont1
   2511  27221
   2512  27221			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   2513  27223			b1 dc		       lda	(inttemp5),y
   2514  27225			c9 10		       cmp	#$10
   2515  27227			d0 1b		       bne	servicesfx_cont1a
   2516  27229			a0 02		       ldy	#2
   2517  2722b			b1 dc		       lda	(inttemp5),y
   2518  2722d			95 56		       sta	sfx1frames,x	; change the frame countdown
   2519  2722f			a9 00		       lda	#0
   2520  27231			95 58		       sta	sfx1tick,x
   2521  27233							; advance the sound pointer by 3...
   2522  27233			b5 4e		       lda	sfx1pointlo,x
   2523  27235			18		       clc
   2524  27236			69 03		       adc	#3
   2525  27238			95 4e		       sta	sfx1pointlo,x
   2526  2723a			b5 50		       lda	sfx1pointhi,x
   2527  2723c			69 00		       adc	#0
   2528  2723e			95 50		       sta	sfx1pointhi,x
   2529  27240							; and then fetch another sample for this channel...
   2530  27240			ca		       dex
   2531  27241			4c 03 f2	       jmp	servicesfxchannelsloop
   2532  27244				    servicesfx_cont1a
   2533  27244
   2534  27244			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2535  27246			95 58		       sta	sfx1tick,x
   2536  27248
   2537  27248			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2538  2724a			f0 02		       beq	servicesfx_cont2
   2539  2724c			d6 52		       dec	sfx1priority,x
   2540  2724e				    servicesfx_cont2
   2541  2724e
   2542  2724e			a0 00		       ldy	#0	; play the sound
   2543  27250			b1 dc		       lda	(inttemp5),y
   2544  27252			85 d8		       sta	inttemp1
   2545  27254
   2546  27254				   -	       ifconst	MUSICTRACKER
   2547  27254				   -	       lda	sfx1notedata,x
   2548  27254				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   2549  27254				   -	       ldy	#0
   2550  27254				   -	       sty	inttemp2
   2551  27254				   -	       clc
   2552  27254				   -	       adc	(inttemp5),y
   2553  27254				   -	       asl		; x2
   2554  27254				   -	       tay
   2555  27254				   -	       lda	tiatrackeroctavenotes,y
   2556  27254				   -	       sta	AUDC0,x
   2557  27254				   -	       iny
   2558  27254				   -	       lda	tiatrackeroctavenotes,y
   2559  27254				   -	       sta	AUDF0,x
   2560  27254				   -	       ldy	#1
   2561  27254				   -	       jmp	sfxvolumeentrypt
   2562  27254				   -exitmusictracker
   2563  27254				   -	       lda	inttemp1
   2564  27254					       endif		; MUSICTRACKER
   2565  27254
   2566  27254			18		       clc
   2567  27255			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   2568  27257			95 17		       sta	AUDF0,x
   2569  27259			c8		       iny
   2570  2725a			b1 dc		       lda	(inttemp5),y
   2571  2725c			95 15		       sta	AUDC0,x
   2572  2725e			85 d9		       sta	inttemp2
   2573  27260			c8		       iny
   2574  27261				    sfxvolumeentrypt
   2575  27261				   -	       ifconst	TIAVOLUME
   2576  27261				   -	       lda	tiavolume
   2577  27261				   -	       asl
   2578  27261				   -	       asl
   2579  27261				   -	       asl
   2580  27261				   -	       asl
   2581  27261				   -	       sta	fourbitfadevalueint
   2582  27261					       endif		; TIAVOLUME
   2583  27261			b1 dc		       lda	(inttemp5),y
   2584  27263				   -	       ifconst	TIAVOLUME
   2585  27263				   -	       jsr	fourbitfadeint
   2586  27263					       endif		; TIAVOLUME
   2587  27263			95 19		       sta	AUDV0,x
   2588  27265			c9 10		       cmp	#$10
   2589  27267			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2590  27269
   2591  27269			05 d9		       ora	inttemp2
   2592  2726b			05 d8		       ora	inttemp1	; check if F|C|V=0
   2593  2726d			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   2594  2726f
   2595  2726f				    advancesfxpointer
   2596  2726f							; advance the pointer to the next sound chunk
   2597  2726f			c8		       iny
   2598  27270			84 da		       sty	inttemp3
   2599  27272			18		       clc
   2600  27273			b5 4e		       lda	sfx1pointlo,x
   2601  27275			65 da		       adc	inttemp3
   2602  27277			95 4e		       sta	sfx1pointlo,x
   2603  27279			b5 50		       lda	sfx1pointhi,x
   2604  2727b			69 00		       adc	#0
   2605  2727d			95 50		       sta	sfx1pointhi,x
   2606  2727f			4c 03 f2	       jmp	servicesfxchannelsloop
   2607  27282
   2608  27282				    sfxsoundloop
   2609  27282			48		       pha
   2610  27283			b5 52		       lda	sfx1priority,x
   2611  27285			d0 04		       bne	sfxsoundloop_carryon
   2612  27287			68		       pla		; fix the stack before we go
   2613  27288			4c 6f f2	       jmp	advancesfxpointer
   2614  2728b				    sfxsoundloop_carryon
   2615  2728b			68		       pla
   2616  2728c			29 f0		       and	#$F0
   2617  2728e			4a		       lsr
   2618  2728f			4a		       lsr
   2619  27290			4a		       lsr
   2620  27291			4a		       lsr
   2621  27292
   2622  27292				    zerosfx
   2623  27292			95 4e		       sta	sfx1pointlo,x
   2624  27294			95 50		       sta	sfx1pointhi,x
   2625  27296			95 52		       sta	sfx1priority,x
   2626  27298			4c 03 f2	       jmp	servicesfxchannelsloop
   2627  2729b
   2628  2729b
   2629  2729b				    schedulesfx
   2630  2729b							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2631  2729b			a0 00		       ldy	#0
   2632  2729d			b1 e0		       lda	(sfxinstrumentlo),y
   2633  2729f				   -	       ifconst	pokeysupport
   2634  2729f				   -	       cmp	#$20	; POKEY?
   2635  2729f				   -	       bne	scheduletiasfx
   2636  2729f				   -	       jmp	schedulepokeysfx
   2637  2729f					       endif
   2638  2729f				    scheduletiasfx
   2639  2729f							;cmp #$10 ; TIA?
   2640  2729f							;beq continuescheduletiasfx
   2641  2729f							; rts ; unhandled!!! 
   2642  2729f				    continuescheduletiasfx
   2643  2729f					       ifnconst	TIASFXMONO
   2644  2729f			a5 4e		       lda	sfx1pointlo
   2645  272a1			05 50		       ora	sfx1pointhi
   2646  272a3			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   2647  272a5			a5 4f		       lda	sfx2pointlo
   2648  272a7			05 51		       ora	sfx2pointhi
   2649  272a9			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   2650  272ab							; Both channels are scheduled. 
   2651  272ab			a0 01		       ldy	#1
   2652  272ad			b1 e0		       lda	(sfxinstrumentlo),y
   2653  272af			d0 01		       bne	interruptsfx
   2654  272b1			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2655  272b2				    interruptsfx
   2656  272b2							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2657  272b2			a5 52		       lda	sfx1priority
   2658  272b4			c5 53		       cmp	sfx2priority
   2659  272b6			b0 04		       bcs	schedulesfx2
   2660  272b8					       endif		; !TIASFXMONO
   2661  272b8
   2662  272b8				    schedulesfx1
   2663  272b8			a2 00		       ldx	#0	; channel 1
   2664  272ba					       ifnconst	TIASFXMONO
   2665  272ba			f0 02		       beq	skipschedulesfx2
   2666  272bc				    schedulesfx2
   2667  272bc			a2 01		       ldx	#1	; channel 2
   2668  272be				    skipschedulesfx2
   2669  272be					       endif		; !TIASFXMONO
   2670  272be
   2671  272be				   -	       ifconst	MUSICTRACKER
   2672  272be				   -	       lda	sfxnoteindex
   2673  272be				   -	       bpl	skipdrumkitoverride
   2674  272be				   -	       and	#$7F	; subtract 128
   2675  272be				   -	       sec
   2676  272be				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   2677  272be				   -	       asl
   2678  272be				   -	       tay
   2679  272be				   -	       lda	tiadrumkitdefinition,y
   2680  272be				   -	       sta	sfxinstrumentlo
   2681  272be				   -	       iny
   2682  272be				   -	       lda	tiadrumkitdefinition,y
   2683  272be				   -	       sta	sfxinstrumenthi
   2684  272be				   -	       lda	#0
   2685  272be				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2686  272be				   -skipdrumkitoverride
   2687  272be					       endif		; MUSICTRACKER
   2688  272be			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   2689  272c0			b1 e0		       lda	(sfxinstrumentlo),y
   2690  272c2			95 52		       sta	sfx1priority,x
   2691  272c4			c8		       iny
   2692  272c5			b1 e0		       lda	(sfxinstrumentlo),y
   2693  272c7			95 56		       sta	sfx1frames,x
   2694  272c9			a5 e0		       lda	sfxinstrumentlo
   2695  272cb			18		       clc
   2696  272cc			69 03		       adc	#3
   2697  272ce			95 4e		       sta	sfx1pointlo,x
   2698  272d0			a5 e1		       lda	sfxinstrumenthi
   2699  272d2			69 00		       adc	#0
   2700  272d4			95 50		       sta	sfx1pointhi,x
   2701  272d6			a5 e2		       lda	sfxpitchoffset
   2702  272d8			95 54		       sta	sfx1poffset,x
   2703  272da			a9 00		       lda	#0
   2704  272dc			95 58		       sta	sfx1tick,x
   2705  272de			a5 e3		       lda	sfxnoteindex
   2706  272e0			95 cd		       sta	sfx1notedata,x
   2707  272e2			60		       rts
   2708  272e3
   2709  272e3				    plotsprite
   2710  272e3					       ifnconst	NODRAWWAIT
   2711  272e3					       ifconst	DOUBLEBUFFER
   2712  272e3			a5 d5		       lda	doublebufferstate
   2713  272e5			d0 04		       bne	skipplotspritewait
   2714  272e7					       endif		; DOUBLEBUFFER
   2715  272e7				   -	       ifconst	DEBUGWAITCOLOR
   2716  272e7				   -	       lda	#$41
   2717  272e7				   -	       sta	BACKGRND
   2718  272e7					       endif
   2719  272e7				    plotspritewait
   2720  272e7			a5 4d		       lda	visibleover
   2721  272e9			d0 fc		       bne	plotspritewait
   2722  272eb				    skipplotspritewait
   2723  272eb				   -	       ifconst	DEBUGWAITCOLOR
   2724  272eb				   -	       lda	#$0
   2725  272eb				   -	       sta	BACKGRND
   2726  272eb					       endif
   2727  272eb					       endif
   2728  272eb
   2729  272eb							;arguments: 
   2730  272eb							; temp1=lo graphicdata 
   2731  272eb							; temp2=hi graphicdata 
   2732  272eb							; temp3=palette | width byte
   2733  272eb							; temp4=x
   2734  272eb							; temp5=y
   2735  272eb							; temp6=mode
   2736  272eb			a5 46		       lda	temp5	;Y position
   2737  272ed			4a		       lsr		; 2 - Divide by 8 or 16
   2738  272ee			4a		       lsr		; 2
   2739  272ef			4a		       lsr		; 2
   2740  272f0					       if	WZONEHEIGHT = 16
   2741  272f0			4a		       lsr		; 2
   2742  272f1					       endif
   2743  272f1
   2744  272f1			aa		       tax
   2745  272f2
   2746  272f2					       ifnconst	NOLIMITCHECKING
   2747  272f2
   2748  272f2							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   2749  272f2
   2750  272f2			c9 0c		       cmp	#WZONECOUNT
   2751  272f4
   2752  272f4			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   2753  272f6							; otherwise, check to see if the bottom half is in zone 0...
   2754  272f6
   2755  272f6					       if	WZONEHEIGHT = 16
   2756  272f6			c9 0f		       cmp	#15
   2757  272f8				   -	       else
   2758  272f8				   -	       cmp	#31
   2759  272f8					       endif
   2760  272f8
   2761  272f8			d0 05		       bne	exitplotsprite1
   2762  272fa			a2 00		       ldx	#0
   2763  272fc			4c 3a f3	       jmp	continueplotsprite2
   2764  272ff				    exitplotsprite1
   2765  272ff			60		       rts
   2766  27300
   2767  27300				    continueplotsprite1
   2768  27300					       endif
   2769  27300
   2770  27300			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2771  27303					       ifconst	DOUBLEBUFFER
   2772  27303			18		       clc
   2773  27304			65 d6		       adc	doublebufferdloffset
   2774  27306					       endif		; DOUBLEBUFFER
   2775  27306			85 63		       sta	dlpnt
   2776  27308			bd d6 f6	       lda	DLPOINTH,x
   2777  2730b					       ifconst	DOUBLEBUFFER
   2778  2730b			69 00		       adc	#0
   2779  2730d					       endif		; DOUBLEBUFFER
   2780  2730d			85 64		       sta	dlpnt+1
   2781  2730f
   2782  2730f							;Create DL entry for upper part of sprite
   2783  2730f
   2784  2730f			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   2785  27311
   2786  27311				   -	       ifconst	CHECKOVERWRITE
   2787  27311				   -	       cpy	#DLLASTOBJ
   2788  27311				   -	       beq	checkcontinueplotsprite2
   2789  27311				   -continueplotsprite1a
   2790  27311					       endif
   2791  27311
   2792  27311			a5 42		       lda	temp1	; graphic data, lo byte
   2793  27313			91 63		       sta	(dlpnt),y	;Low byte of data address
   2794  27315
   2795  27315					       ifnconst	ATOMICSPRITEUPDATE
   2796  27315			c8		       iny
   2797  27316			a5 47		       lda	temp6
   2798  27318			91 63		       sta	(dlpnt),y
   2799  2731a				   -	       else
   2800  2731a				   -	       iny
   2801  2731a				   -	       sty	temp8
   2802  2731a					       endif
   2803  2731a
   2804  2731a			c8		       iny
   2805  2731b
   2806  2731b			a5 46		       lda	temp5	;Y position
   2807  2731d			29 0f		       and	#(WZONEHEIGHT - 1)
   2808  2731f			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   2809  27321			05 43		       ora	temp2	; graphic data, hi byte
   2810  27323			91 63		       sta	(dlpnt),y
   2811  27325
   2812  27325
   2813  27325			c8		       iny
   2814  27326			a5 44		       lda	temp3	;palette|width
   2815  27328			91 63		       sta	(dlpnt),y
   2816  2732a
   2817  2732a			c8		       iny
   2818  2732b			a5 45		       lda	temp4	;Horizontal position
   2819  2732d			91 63		       sta	(dlpnt),y
   2820  2732f
   2821  2732f			c8		       iny
   2822  27330			94 65		       sty	dlend,x
   2823  27332
   2824  27332				   -	       ifconst	ALWAYSTERMINATE
   2825  27332				   -	       iny
   2826  27332				   -	       lda	#0
   2827  27332				   -	       sta	(dlpnt),y
   2828  27332					       endif
   2829  27332
   2830  27332				   -	       ifconst	ATOMICSPRITEUPDATE
   2831  27332				   -	       ldy	temp8
   2832  27332				   -	       lda	temp6
   2833  27332				   -	       sta	(dlpnt),y
   2834  27332					       endif
   2835  27332
   2836  27332				    checkcontinueplotsprite2
   2837  27332
   2838  27332			90 38		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   2839  27334
   2840  27334							;Create DL entry for lower part of sprite
   2841  27334
   2842  27334			e8		       inx		;Next region
   2843  27335
   2844  27335					       ifnconst	NOLIMITCHECKING
   2845  27335			e0 0c		       cpx	#WZONECOUNT
   2846  27337
   2847  27337			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   2848  27339			60		       rts
   2849  2733a				    continueplotsprite2
   2850  2733a					       endif
   2851  2733a
   2852  2733a			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to next DL
   2853  2733d					       ifconst	DOUBLEBUFFER
   2854  2733d			18		       clc
   2855  2733e			65 d6		       adc	doublebufferdloffset
   2856  27340					       endif		; DOUBLEBUFFER
   2857  27340			85 63		       sta	dlpnt
   2858  27342			bd d6 f6	       lda	DLPOINTH,x
   2859  27345					       ifconst	DOUBLEBUFFER
   2860  27345			69 00		       adc	#0
   2861  27347					       endif		; DOUBLEBUFFER
   2862  27347			85 64		       sta	dlpnt+1
   2863  27349			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   2864  2734b
   2865  2734b				   -	       ifconst	CHECKOVERWRITE
   2866  2734b				   -	       cpy	#DLLASTOBJ
   2867  2734b				   -	       bne	continueplotsprite2a
   2868  2734b				   -	       rts
   2869  2734b				   -continueplotsprite2a
   2870  2734b					       endif
   2871  2734b
   2872  2734b			a5 42		       lda	temp1	; graphic data, lo byte
   2873  2734d			91 63		       sta	(dlpnt),y
   2874  2734f
   2875  2734f					       ifnconst	ATOMICSPRITEUPDATE
   2876  2734f			c8		       iny
   2877  27350			a5 47		       lda	temp6
   2878  27352			91 63		       sta	(dlpnt),y
   2879  27354				   -	       else
   2880  27354				   -	       iny
   2881  27354				   -	       sty	temp8
   2882  27354					       endif
   2883  27354
   2884  27354			c8		       iny
   2885  27355
   2886  27355			a5 46		       lda	temp5	;Y position
   2887  27357			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   2888  27359			05 43		       ora	temp2	; graphic data, hi byte
   2889  2735b			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   2890  2735d			91 63		       sta	(dlpnt),y
   2891  2735f
   2892  2735f			c8		       iny
   2893  27360
   2894  27360			a5 44		       lda	temp3	;palette|width
   2895  27362			91 63		       sta	(dlpnt),y
   2896  27364
   2897  27364			c8		       iny
   2898  27365
   2899  27365			a5 45		       lda	temp4	;Horizontal position
   2900  27367			91 63		       sta	(dlpnt),y
   2901  27369
   2902  27369			c8		       iny
   2903  2736a			94 65		       sty	dlend,x
   2904  2736c
   2905  2736c				   -	       ifconst	ALWAYSTERMINATE
   2906  2736c				   -	       iny
   2907  2736c				   -	       lda	#0
   2908  2736c				   -	       sta	(dlpnt),y
   2909  2736c					       endif
   2910  2736c
   2911  2736c				   -	       ifconst	ATOMICSPRITEUPDATE
   2912  2736c				   -	       ldy	temp8
   2913  2736c				   -	       lda	temp6
   2914  2736c				   -	       sta	(dlpnt),y
   2915  2736c					       endif
   2916  2736c
   2917  2736c				    doneSPDL
   2918  2736c			60		       rts
   2919  2736d
   2920  2736d
   2921  2736d				    lockzonex
   2922  2736d				   -	       ifconst	ZONELOCKS
   2923  2736d				   -	       ldy	dlend,x
   2924  2736d				   -	       cpy	#DLLASTOBJ
   2925  2736d				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   2926  2736d				   -	       lda	DLPOINTL,x
   2927  2736d				   -	       ifconst	DOUBLEBUFFER
   2928  2736d				   -	       clc
   2929  2736d				   -	       adc	doublebufferdloffset
   2930  2736d				   -	       endif		; DOUBLEBUFFER
   2931  2736d				   -	       sta	dlpnt
   2932  2736d				   -	       lda	DLPOINTH,x
   2933  2736d				   -	       ifconst	DOUBLEBUFFER
   2934  2736d				   -	       adc	#0
   2935  2736d				   -	       endif		; DOUBLEBUFFER
   2936  2736d				   -	       sta	dlpnt+1
   2937  2736d				   -	       iny
   2938  2736d				   -	       lda	#0
   2939  2736d				   -	       sta	(dlpnt),y
   2940  2736d				   -	       dey
   2941  2736d				   -	       tya
   2942  2736d				   -	       ldy	#(DLLASTOBJ-1)
   2943  2736d				   -	       sta	(dlpnt),y
   2944  2736d				   -	       iny
   2945  2736d				   -	       sty	dlend,x
   2946  2736d				   -lockzonexreturn
   2947  2736d				   -	       rts
   2948  2736d					       endif		; ZONELOCKS
   2949  2736d				    unlockzonex
   2950  2736d				   -	       ifconst	ZONELOCKS
   2951  2736d				   -	       ldy	dlend,x
   2952  2736d				   -	       cpy	#DLLASTOBJ
   2953  2736d				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   2954  2736d				   -	       lda	DLPOINTL,x
   2955  2736d				   -	       ifconst	DOUBLEBUFFER
   2956  2736d				   -	       clc
   2957  2736d				   -	       adc	doublebufferdloffset
   2958  2736d				   -	       endif		; DOUBLEBUFFER
   2959  2736d				   -	       sta	dlpnt
   2960  2736d				   -	       lda	DLPOINTH,x
   2961  2736d				   -	       ifconst	DOUBLEBUFFER
   2962  2736d				   -	       adc	#0
   2963  2736d				   -	       endif		; DOUBLEBUFFER
   2964  2736d				   -	       sta	dlpnt+1
   2965  2736d				   -	       dey
   2966  2736d				   -			;ldy #(DLLASTOBJ-1)
   2967  2736d				   -	       lda	(dlpnt),y
   2968  2736d				   -	       tay
   2969  2736d				   -	       sty	dlend,x
   2970  2736d				   -unlockzonexreturn
   2971  2736d					       endif		; ZONELOCKS
   2972  2736d			60		       rts
   2973  2736e
   2974  2736e				    plotcharloop
   2975  2736e							; ** read from a data indirectly pointed to from temp8,temp9
   2976  2736e							; ** format is: lo_data, hi_data, palette|width, x, y
   2977  2736e							; ** format ends with lo_data | hi_data = 0
   2978  2736e
   2979  2736e					       ifconst	DOUBLEBUFFER
   2980  2736e			a5 d5		       lda	doublebufferstate
   2981  27370			d0 04		       bne	skipplotcharloopwait
   2982  27372					       endif		; DOUBLEBUFFER
   2983  27372				   -	       ifconst	DEBUGWAITCOLOR
   2984  27372				   -	       lda	#$61
   2985  27372				   -	       sta	BACKGRND
   2986  27372					       endif
   2987  27372				    plotcharloopwait
   2988  27372			a5 4d		       lda	visibleover
   2989  27374			d0 fc		       bne	plotcharloopwait
   2990  27376				   -	       ifconst	DEBUGWAITCOLOR
   2991  27376				   -	       lda	#0
   2992  27376				   -	       sta	BACKGRND
   2993  27376					       endif
   2994  27376				    skipplotcharloopwait
   2995  27376				    plotcharlooploop
   2996  27376			a0 00		       ldy	#0
   2997  27378			b1 49		       lda	(temp8),y
   2998  2737a			85 42		       sta	temp1
   2999  2737c			c8		       iny
   3000  2737d			b1 49		       lda	(temp8),y
   3001  2737f			85 43		       sta	temp2
   3002  27381			05 42		       ora	temp1
   3003  27383			d0 01		       bne	plotcharloopcontinue
   3004  27385							;the pointer=0, so return
   3005  27385			60		       rts
   3006  27386				    plotcharloopcontinue
   3007  27386			c8		       iny
   3008  27387			b1 49		       lda	(temp8),y
   3009  27389			85 44		       sta	temp3
   3010  2738b			c8		       iny
   3011  2738c			b1 49		       lda	(temp8),y
   3012  2738e			85 45		       sta	temp4
   3013  27390			c8		       iny
   3014  27391			b1 49		       lda	(temp8),y
   3015  27393							;sta temp5 ; not needed with our late entry.
   3016  27393			20 b0 f3	       jsr	plotcharactersskipentry
   3017  27396			a5 49		       lda	temp8
   3018  27398			18		       clc
   3019  27399			69 05		       adc	#5
   3020  2739b			85 49		       sta	temp8
   3021  2739d			a5 4a		       lda	temp9
   3022  2739f			69 00		       adc	#0
   3023  273a1			85 4a		       sta	temp9
   3024  273a3			4c 76 f3	       jmp	plotcharlooploop
   3025  273a6
   3026  273a6				    plotcharacters
   3027  273a6					       ifconst	DOUBLEBUFFER
   3028  273a6			a5 d5		       lda	doublebufferstate
   3029  273a8			d0 04		       bne	skipplotcharacterswait
   3030  273aa					       endif		; DOUBLEBUFFER
   3031  273aa				   -	       ifconst	DEBUGWAITCOLOR
   3032  273aa				   -	       lda	#$41
   3033  273aa				   -	       sta	BACKGRND
   3034  273aa					       endif
   3035  273aa				    plotcharacterswait
   3036  273aa			a5 4d		       lda	visibleover
   3037  273ac			d0 fc		       bne	plotcharacterswait
   3038  273ae				   -	       ifconst	DEBUGWAITCOLOR
   3039  273ae				   -	       sta	BACKGRND
   3040  273ae					       endif
   3041  273ae				    skipplotcharacterswait
   3042  273ae							;arguments: 
   3043  273ae							; temp1=lo charactermap
   3044  273ae							; temp2=hi charactermap
   3045  273ae							; temp3=palette | width byte
   3046  273ae							; temp4=x
   3047  273ae							; temp5=y
   3048  273ae
   3049  273ae			a5 46		       lda	temp5	;Y position
   3050  273b0
   3051  273b0				    plotcharactersskipentry
   3052  273b0
   3053  273b0							;ifconst ZONEHEIGHT
   3054  273b0							; if ZONEHEIGHT = 16
   3055  273b0							; and #$0F
   3056  273b0							; endif
   3057  273b0							; if ZONEHEIGHT = 8
   3058  273b0							; and #$1F
   3059  273b0							; endif
   3060  273b0							;else
   3061  273b0							; and #$0F
   3062  273b0							;endif
   3063  273b0
   3064  273b0			aa		       tax
   3065  273b1			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3066  273b4					       ifconst	DOUBLEBUFFER
   3067  273b4			18		       clc
   3068  273b5			65 d6		       adc	doublebufferdloffset
   3069  273b7					       endif		; DOUBLEBUFFER
   3070  273b7			85 63		       sta	dlpnt
   3071  273b9			bd d6 f6	       lda	DLPOINTH,x
   3072  273bc					       ifconst	DOUBLEBUFFER
   3073  273bc			69 00		       adc	#0
   3074  273be					       endif		; DOUBLEBUFFER
   3075  273be			85 64		       sta	dlpnt+1
   3076  273c0
   3077  273c0							;Create DL entry for the characters
   3078  273c0
   3079  273c0			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3080  273c2
   3081  273c2				   -	       ifconst	CHECKOVERWRITE
   3082  273c2				   -	       cpy	#DLLASTOBJ
   3083  273c2				   -	       bne	continueplotcharacters
   3084  273c2				   -	       rts
   3085  273c2				   -continueplotcharacters
   3086  273c2					       endif
   3087  273c2
   3088  273c2			a5 42		       lda	temp1	; character map data, lo byte
   3089  273c4			91 63		       sta	(dlpnt),y	;(1) store low address
   3090  273c6
   3091  273c6			c8		       iny
   3092  273c7			ad 06 21	       lda	charactermode
   3093  273ca			91 63		       sta	(dlpnt),y	;(2) store mode
   3094  273cc
   3095  273cc			c8		       iny
   3096  273cd			a5 43		       lda	temp2	; character map, hi byte
   3097  273cf			91 63		       sta	(dlpnt),y	;(3) store high address
   3098  273d1
   3099  273d1			c8		       iny
   3100  273d2			a5 44		       lda	temp3	;palette|width
   3101  273d4			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3102  273d6
   3103  273d6			c8		       iny
   3104  273d7			a5 45		       lda	temp4	;Horizontal position
   3105  273d9			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3106  273db
   3107  273db			c8		       iny
   3108  273dc			94 65		       sty	dlend,x	; save display list end byte
   3109  273de			60		       rts
   3110  273df
   3111  273df
   3112  273df					       ifconst	plotvalueonscreen
   3113  273df				    plotcharacterslive
   3114  273df							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3115  273df
   3116  273df							;arguments: 
   3117  273df							; temp1=lo charactermap
   3118  273df							; temp2=hi charactermap
   3119  273df							; temp3=palette | width byte
   3120  273df							; temp4=x
   3121  273df							; temp5=y
   3122  273df
   3123  273df			a5 46		       lda	temp5	;Y position
   3124  273e1
   3125  273e1			aa		       tax
   3126  273e2			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3127  273e5					       ifconst	DOUBLEBUFFER
   3128  273e5			18		       clc
   3129  273e6			65 d6		       adc	doublebufferdloffset
   3130  273e8					       endif		; DOUBLEBUFFER
   3131  273e8			85 63		       sta	dlpnt
   3132  273ea			bd d6 f6	       lda	DLPOINTH,x
   3133  273ed					       ifconst	DOUBLEBUFFER
   3134  273ed			69 00		       adc	#0
   3135  273ef					       endif		; DOUBLEBUFFER
   3136  273ef			85 64		       sta	dlpnt+1
   3137  273f1
   3138  273f1							;Create DL entry for the characters
   3139  273f1
   3140  273f1			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3141  273f3
   3142  273f3				   -	       ifconst	CHECKOVERWRITE
   3143  273f3				   -	       cpy	#DLLASTOBJ
   3144  273f3				   -	       bne	continueplotcharacterslive
   3145  273f3				   -	       rts
   3146  273f3				   -continueplotcharacterslive
   3147  273f3					       endif
   3148  273f3
   3149  273f3			a5 42		       lda	temp1	; character map data, lo byte
   3150  273f5			91 63		       sta	(dlpnt),y	;(1) store low address
   3151  273f7
   3152  273f7			c8		       iny
   3153  273f8							; we don't add the second byte yet, since the charmap could briefly
   3154  273f8							; render without a proper character map address, width, or position.
   3155  273f8			ad 06 21	       lda	charactermode
   3156  273fb			91 63		       sta	(dlpnt),y	;(2) store mode
   3157  273fd
   3158  273fd			c8		       iny
   3159  273fe			a5 43		       lda	temp2	; character map, hi byte
   3160  27400			91 63		       sta	(dlpnt),y	;(3) store high address
   3161  27402
   3162  27402			c8		       iny
   3163  27403			a5 44		       lda	temp3	;palette|width
   3164  27405			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3165  27407
   3166  27407			c8		       iny
   3167  27408			a5 45		       lda	temp4	;Horizontal position
   3168  2740a			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3169  2740c
   3170  2740c			c8		       iny
   3171  2740d			94 65		       sty	dlend,x	; save display list end byte
   3172  2740f
   3173  2740f			60		       rts
   3174  27410					       endif		;plotcharacterslive
   3175  27410
   3176  27410				   -	       ifconst	USED_PLOTVALUE
   3177  27410				   -plotvalue
   3178  27410				   -			; calling 7800basic command:
   3179  27410				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3180  27410				   -			; ...displays the variable as BCD digits
   3181  27410				   -			;
   3182  27410				   -			; asm sub arguments: 
   3183  27410				   -			; temp1=lo charactermap
   3184  27410				   -			; temp2=hi charactermap
   3185  27410				   -			; temp3=palette | width byte
   3186  27410				   -			; temp4=x
   3187  27410				   -			; temp5=y
   3188  27410				   -			; temp6=number of digits
   3189  27410				   -			; temp7=lo variable
   3190  27410				   -			; temp8=hi variable
   3191  27410				   -			; temp9=character mode
   3192  27410				   -
   3193  27410				   -plotdigitcount =	temp6
   3194  27410				   -
   3195  27410				   -	       ifconst	ZONELOCKS
   3196  27410				   -	       ldx	temp5
   3197  27410				   -	       ldy	dlend,x
   3198  27410				   -	       cpy	#DLLASTOBJ
   3199  27410				   -	       bne	carryonplotvalue
   3200  27410				   -	       rts
   3201  27410				   -carryonplotvalue
   3202  27410				   -	       endif
   3203  27410				   -
   3204  27410				   -	       lda	#0
   3205  27410				   -	       tay
   3206  27410				   -	       ldx	valbufend
   3207  27410				   -
   3208  27410				   -	       lda	plotdigitcount
   3209  27410				   -	       and	#1
   3210  27410				   -	       beq	pvnibble2char
   3211  27410				   -	       lda	#0
   3212  27410				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   3213  27410				   -	       beq	pvnibble2char_skipnibble
   3214  27410				   -
   3215  27410				   -pvnibble2char
   3216  27410				   -			; high nibble...
   3217  27410				   -	       lda	(temp7),y
   3218  27410				   -	       and	#$f0
   3219  27410				   -	       lsr
   3220  27410				   -	       lsr
   3221  27410				   -	       lsr
   3222  27410				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3223  27410				   -	       lsr
   3224  27410				   -	       endif
   3225  27410				   -
   3226  27410				   -	       clc
   3227  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3228  27410				   -	       sta	VALBUFFER,x
   3229  27410				   -	       inx
   3230  27410				   -	       dec	plotdigitcount
   3231  27410				   -
   3232  27410				   -pvnibble2char_skipnibble
   3233  27410				   -			; low nibble...
   3234  27410				   -	       lda	(temp7),y
   3235  27410				   -	       and	#$0f
   3236  27410				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3237  27410				   -	       asl
   3238  27410				   -	       endif
   3239  27410				   -	       clc
   3240  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3241  27410				   -	       sta	VALBUFFER,x
   3242  27410				   -	       inx
   3243  27410				   -	       iny
   3244  27410				   -
   3245  27410				   -	       dec	plotdigitcount
   3246  27410				   -	       bne	pvnibble2char
   3247  27410				   -
   3248  27410				   -			;point to the start of our valuebuffer
   3249  27410				   -	       clc
   3250  27410				   -	       lda	#<VALBUFFER
   3251  27410				   -	       adc	valbufend
   3252  27410				   -	       sta	temp1
   3253  27410				   -	       lda	#>VALBUFFER
   3254  27410				   -	       adc	#0
   3255  27410				   -	       sta	temp2
   3256  27410				   -
   3257  27410				   -			;advance valbufend to the end of our value buffer
   3258  27410				   -	       stx	valbufend
   3259  27410				   -
   3260  27410				   -	       ifnconst	plotvalueonscreen
   3261  27410				   -	       jmp	plotcharacters
   3262  27410				   -	       else
   3263  27410				   -	       jmp	plotcharacterslive
   3264  27410				   -	       endif
   3265  27410				   -
   3266  27410					       endif		; USED_PLOTVALUE
   3267  27410
   3268  27410
   3269  27410				   -	       ifconst	USED_PLOTVALUEEXTRA
   3270  27410				   -plotdigitcount =	temp6
   3271  27410				   -plotvalueextra
   3272  27410				   -			; calling 7800basic command:
   3273  27410				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3274  27410				   -			; ...displays the variable as BCD digits
   3275  27410				   -			;
   3276  27410				   -			; asm sub arguments: 
   3277  27410				   -			; temp1=lo charactermap
   3278  27410				   -			; temp2=hi charactermap
   3279  27410				   -			; temp3=palette | width byte
   3280  27410				   -			; temp4=x
   3281  27410				   -			; temp5=y
   3282  27410				   -			; temp6=number of digits
   3283  27410				   -			; temp7=lo variable
   3284  27410				   -			; temp8=hi variable
   3285  27410				   -
   3286  27410				   -	       lda	#0
   3287  27410				   -	       tay
   3288  27410				   -	       ldx	valbufend
   3289  27410				   -	       ifnconst	plotvalueonscreen
   3290  27410				   -	       sta	VALBUFFER,x
   3291  27410				   -	       endif
   3292  27410				   -
   3293  27410				   -	       lda	plotdigitcount
   3294  27410				   -	       and	#1
   3295  27410				   -
   3296  27410				   -	       bne	pvnibble2char_skipnibbleextra
   3297  27410				   -
   3298  27410				   -pvnibble2charextra
   3299  27410				   -			; high nibble...
   3300  27410				   -	       lda	(temp7),y
   3301  27410				   -	       and	#$f0
   3302  27410				   -	       lsr
   3303  27410				   -	       lsr
   3304  27410				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3305  27410				   -	       lsr
   3306  27410				   -	       endif
   3307  27410				   -	       clc
   3308  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3309  27410				   -	       sta	VALBUFFER,x
   3310  27410				   -	       inx
   3311  27410				   -
   3312  27410				   -			; second half of the digit
   3313  27410				   -	       clc
   3314  27410				   -	       adc	#1
   3315  27410				   -	       sta	VALBUFFER,x
   3316  27410				   -	       inx
   3317  27410				   -
   3318  27410				   -pvnibble2char_skipnibbleextra
   3319  27410				   -			; low nibble...
   3320  27410				   -	       lda	(temp7),y
   3321  27410				   -	       and	#$0f
   3322  27410				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3323  27410				   -	       asl
   3324  27410				   -	       endif
   3325  27410				   -	       asl
   3326  27410				   -
   3327  27410				   -	       clc
   3328  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3329  27410				   -	       sta	VALBUFFER,x
   3330  27410				   -	       inx
   3331  27410				   -
   3332  27410				   -	       clc
   3333  27410				   -	       adc	#1
   3334  27410				   -	       sta	VALBUFFER,x
   3335  27410				   -	       inx
   3336  27410				   -	       iny
   3337  27410				   -
   3338  27410				   -	       dec	plotdigitcount
   3339  27410				   -	       bne	pvnibble2charextra
   3340  27410				   -
   3341  27410				   -			;point to the start of our valuebuffer
   3342  27410				   -	       clc
   3343  27410				   -	       lda	#<VALBUFFER
   3344  27410				   -	       adc	valbufend
   3345  27410				   -	       sta	temp1
   3346  27410				   -	       lda	#>VALBUFFER
   3347  27410				   -	       adc	#0
   3348  27410				   -	       sta	temp2
   3349  27410				   -
   3350  27410				   -			;advance valbufend to the end of our value buffer
   3351  27410				   -	       stx	valbufend
   3352  27410				   -
   3353  27410				   -	       ifnconst	plotvalueonscreen
   3354  27410				   -	       jmp	plotcharacters
   3355  27410				   -	       else
   3356  27410				   -	       jmp	plotcharacterslive
   3357  27410				   -	       endif
   3358  27410					       endif		; USED_PLOTVALUEEXTRA
   3359  27410
   3360  27410				    boxcollision
   3361  27410				   -	       ifconst	BOXCOLLISION
   3362  27410				   -			; the worst case cycle-time for the code below is 43 cycles.
   3363  27410				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3364  27410				   -
   3365  27410				   -			;__boxx1 = accumulator
   3366  27410				   -			;__boxy1 = y
   3367  27410				   -__boxw1    =	temp3
   3368  27410				   -__boxh1    =	temp4
   3369  27410				   -
   3370  27410				   -__boxx2    =	temp5
   3371  27410				   -__boxy2    =	temp6
   3372  27410				   -__boxw2    =	temp7
   3373  27410				   -__boxh2    =	temp8
   3374  27410				   -
   3375  27410				   -DoXCollisionCheck
   3376  27410				   -			;lda __boxx1 ; skipped. already in the accumulator
   3377  27410				   -	       cmp	__boxx2	;3
   3378  27410				   -	       bcs	X1isbiggerthanX2	;2/3
   3379  27410				   -X2isbiggerthanX1
   3380  27410				   -			; carry is clear
   3381  27410				   -	       adc	__boxw1	;3
   3382  27410				   -	       cmp	__boxx2	;3
   3383  27410				   -	       bcs	DoYCollisionCheck	;3/2
   3384  27410				   -	       rts		;6 - carry clear, no collision
   3385  27410				   -X1isbiggerthanX2
   3386  27410				   -	       clc		;2
   3387  27410				   -	       sbc	__boxw2	;3
   3388  27410				   -	       cmp	__boxx2	;3
   3389  27410				   -	       bcs	noboxcollision	;3/2
   3390  27410				   -DoYCollisionCheck
   3391  27410				   -	       tya		; 2 ; use to be "lda __boxy1"
   3392  27410				   -	       cmp	__boxy2	;3
   3393  27410				   -	       bcs	Y1isbiggerthanY2	;3/2
   3394  27410				   -Y2isbiggerthanY1
   3395  27410				   -			; carry is clear
   3396  27410				   -	       adc	__boxh1	;3
   3397  27410				   -	       cmp	__boxy2	;3
   3398  27410				   -	       rts		;6 
   3399  27410				   -Y1isbiggerthanY2
   3400  27410				   -	       clc		;2
   3401  27410				   -	       sbc	__boxh2	;3
   3402  27410				   -	       cmp	__boxy2	;3
   3403  27410				   -	       bcs	noboxcollision	;3/2
   3404  27410				   -yesboxcollision
   3405  27410				   -	       sec		;2
   3406  27410				   -	       rts		;6
   3407  27410				   -noboxcollision
   3408  27410				   -	       clc		;2
   3409  27410				   -	       rts		;6
   3410  27410					       endif		; BOXCOLLISION
   3411  27410
   3412  27410				    randomize
   3413  27410			a5 40		       lda	rand
   3414  27412			4a		       lsr
   3415  27413			26 41		       rol	rand16
   3416  27415			90 02		       bcc	noeor
   3417  27417			49 b4		       eor	#$B4
   3418  27419				    noeor
   3419  27419			85 40		       sta	rand
   3420  2741b			45 41		       eor	rand16
   3421  2741d			60		       rts
   3422  2741e
   3423  2741e							; *** bcd conversion routine courtesy Omegamatrix
   3424  2741e							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3425  2741e				    converttobcd
   3426  2741e							;value to convert is in the accumulator
   3427  2741e			85 42		       sta	temp1
   3428  27420			4a		       lsr
   3429  27421			65 42		       adc	temp1
   3430  27423			6a		       ror
   3431  27424			4a		       lsr
   3432  27425			4a		       lsr
   3433  27426			65 42		       adc	temp1
   3434  27428			6a		       ror
   3435  27429			65 42		       adc	temp1
   3436  2742b			6a		       ror
   3437  2742c			4a		       lsr
   3438  2742d			29 3c		       and	#$3C
   3439  2742f			85 43		       sta	temp2
   3440  27431			4a		       lsr
   3441  27432			65 43		       adc	temp2
   3442  27434			65 42		       adc	temp1
   3443  27436			60		       rts		; return the result in the accumulator
   3444  27437
   3445  27437							; Y and A contain multiplicands, result in A
   3446  27437				    mul8
   3447  27437			84 42		       sty	temp1
   3448  27439			85 43		       sta	temp2
   3449  2743b			a9 00		       lda	#0
   3450  2743d				    reptmul8
   3451  2743d			46 43		       lsr	temp2
   3452  2743f			90 03		       bcc	skipmul8
   3453  27441			18		       clc
   3454  27442			65 42		       adc	temp1
   3455  27444							;bcs donemul8 might save cycles?
   3456  27444				    skipmul8
   3457  27444							;beq donemul8 might save cycles?
   3458  27444			06 42		       asl	temp1
   3459  27446			d0 f5		       bne	reptmul8
   3460  27448				    donemul8
   3461  27448			60		       rts
   3462  27449
   3463  27449				    div8
   3464  27449							; A=numerator Y=denominator, result in A
   3465  27449			c0 02		       cpy	#2
   3466  2744b			90 0a		       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3467  2744d			84 42		       sty	temp1
   3468  2744f			a0 ff		       ldy	#$ff
   3469  27451				    div8loop
   3470  27451			e5 42		       sbc	temp1
   3471  27453			c8		       iny
   3472  27454			b0 fb		       bcs	div8loop
   3473  27456				    div8end
   3474  27456			98		       tya
   3475  27457							; result in A
   3476  27457			60		       rts
   3477  27458
   3478  27458							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3479  27458				    mul16
   3480  27458			84 42		       sty	temp1
   3481  2745a			85 43		       sta	temp2
   3482  2745c
   3483  2745c			a9 00		       lda	#0
   3484  2745e			a2 08		       ldx	#8
   3485  27460			46 42		       lsr	temp1
   3486  27462				    mul16_1
   3487  27462			90 03		       bcc	mul16_2
   3488  27464			18		       clc
   3489  27465			65 43		       adc	temp2
   3490  27467				    mul16_2
   3491  27467			6a		       ror
   3492  27468			66 42		       ror	temp1
   3493  2746a			ca		       dex
   3494  2746b			d0 f5		       bne	mul16_1
   3495  2746d			85 43		       sta	temp2
   3496  2746f			60		       rts
   3497  27470
   3498  27470							; div int/int
   3499  27470							; numerator in A, denom in temp1
   3500  27470							; returns with quotient in A, remainder in temp1
   3501  27470				    div16
   3502  27470			85 43		       sta	temp2
   3503  27472			84 42		       sty	temp1
   3504  27474			a9 00		       lda	#0
   3505  27476			a2 08		       ldx	#8
   3506  27478			06 43		       asl	temp2
   3507  2747a				    div16_1
   3508  2747a			2a		       rol
   3509  2747b			c5 42		       cmp	temp1
   3510  2747d			90 02		       bcc	div16_2
   3511  2747f			e5 42		       sbc	temp1
   3512  27481				    div16_2
   3513  27481			26 43		       rol	temp2
   3514  27483			ca		       dex
   3515  27484			d0 f4		       bne	div16_1
   3516  27486			85 42		       sta	temp1
   3517  27488			a5 43		       lda	temp2
   3518  2748a			60		       rts
   3519  2748b
   3520  2748b					       ifconst	bankswitchmode
   3521  2748b				    BS_jsr
   3522  2748b				   -	       ifconst	dumpbankswitch
   3523  2748b				   -	       sta	dumpbankswitch
   3524  2748b					       endif
   3525  2748b				   -	       ifconst	MCPDEVCART
   3526  2748b				   -	       ora	#$18
   3527  2748b				   -	       sta	$3000
   3528  2748b					       else
   3529  2748b			8d 00 80	       sta	$8000
   3530  2748e					       endif
   3531  2748e			68		       pla
   3532  2748f			aa		       tax
   3533  27490			68		       pla
   3534  27491			60		       rts
   3535  27492
   3536  27492				    BS_return
   3537  27492			68		       pla		; bankswitch bank
   3538  27493				   -	       ifconst	dumpbankswitch
   3539  27493				   -	       sta	dumpbankswitch
   3540  27493					       endif
   3541  27493				   -	       ifconst	BANKRAM
   3542  27493				   -	       sta	currentbank
   3543  27493				   -	       ora	currentrambank
   3544  27493					       endif
   3545  27493				   -	       ifconst	MCPDEVCART
   3546  27493				   -	       ora	#$18
   3547  27493				   -	       sta	$3000
   3548  27493					       else
   3549  27493			8d 00 80	       sta	$8000
   3550  27496					       endif
   3551  27496			68		       pla		; bankswitch $0 flag
   3552  27497			60		       rts
   3553  27498					       endif
   3554  27498
   3555  27498				    checkselectswitch
   3556  27498			ad 82 02	       lda	SWCHB	; first check the real select switch...
   3557  2749b			29 02		       and	#%00000010
   3558  2749d					       ifnconst	SOFTPAUSEOFF
   3559  2749d					       ifnconst	MOUSESUPPORT
   3560  2749d					       ifnconst	TRAKBALLSUPPORT
   3561  2749d			f0 0f		       beq	checkselectswitchreturn	; switch is pressed
   3562  2749f			ad b9 01	       lda	port0control
   3563  274a2			c9 0b		       cmp	#11
   3564  274a4			d0 03		       bne	checkselectsoftswitch
   3565  274a6			a9 ff		       lda	#$ff
   3566  274a8			60		       rts
   3567  274a9				    checkselectsoftswitch
   3568  274a9			ad 80 02	       lda	SWCHA	; then check the soft "select" joysick code...
   3569  274ac			29 b0		       and	#%10110000	; R_DU
   3570  274ae					       endif		; TRAKBALLSUPPORT
   3571  274ae					       endif		; MOUSESUPPORT
   3572  274ae					       endif		; SOFTPAUSEOFF
   3573  274ae				    checkselectswitchreturn
   3574  274ae			60		       rts
   3575  274af
   3576  274af				    checkresetswitch
   3577  274af			ad 82 02	       lda	SWCHB	; first check the real reset switch...
   3578  274b2			29 01		       and	#%00000001
   3579  274b4					       ifnconst	SOFTPAUSEOFF
   3580  274b4					       ifnconst	MOUSESUPPORT
   3581  274b4					       ifnconst	TRAKBALLSUPPORT
   3582  274b4			f0 0f		       beq	checkresetswitchreturn	; switch is pressed
   3583  274b6			ad b9 01	       lda	port0control
   3584  274b9			c9 0b		       cmp	#11
   3585  274bb			d0 03		       bne	checkresetsoftswitch
   3586  274bd			a9 ff		       lda	#$ff
   3587  274bf			60		       rts
   3588  274c0				    checkresetsoftswitch
   3589  274c0			ad 80 02	       lda	SWCHA	; then check the soft "reset" joysick code...
   3590  274c3			29 70		       and	#%01110000	; _LDU
   3591  274c5					       endif		; TRAKBALLSUPPORT
   3592  274c5					       endif		; MOUSESUPPORT
   3593  274c5					       endif		; SOFTPAUSEOFF
   3594  274c5				    checkresetswitchreturn
   3595  274c5			60		       rts
   3596  274c6
   3597  274c6				   -	       ifconst	FINESCROLLENABLED
   3598  274c6				   -finescrolldlls
   3599  274c6				   -	       ldx	temp1	; first DLL index x3
   3600  274c6				   -	       lda	DLLMEM,x
   3601  274c6				   -	       and	#%11110000
   3602  274c6				   -	       ora	finescrolly
   3603  274c6				   -	       sta	DLLMEM,x
   3604  274c6				   -
   3605  274c6				   -	       ldx	temp2	; last DLL index x3
   3606  274c6				   -	       lda	DLLMEM,x
   3607  274c6				   -	       and	#%11110000
   3608  274c6				   -	       ora	finescrolly
   3609  274c6				   -	       eor	#(WZONEHEIGHT-1)
   3610  274c6				   -	       sta	DLLMEM,x
   3611  274c6				   -	       rts
   3612  274c6					       endif		; FINESCROLLENABLED
   3613  274c6
   3614  274c6				   -	       ifconst	USED_ADJUSTVISIBLE
   3615  274c6				   -adjustvisible
   3616  274c6				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3617  274c6				   -	       jsr	waitforvblankstart	; ensure vblank just started
   3618  274c6				   -	       ldx	visibleDLLstart
   3619  274c6				   -findfirstinterrupt
   3620  274c6				   -	       lda	DLLMEM,x
   3621  274c6				   -	       bmi	foundfirstinterrupt
   3622  274c6				   -	       inx
   3623  274c6				   -	       inx
   3624  274c6				   -	       inx
   3625  274c6				   -	       bne	findfirstinterrupt
   3626  274c6				   -foundfirstinterrupt
   3627  274c6				   -	       and	#%01111111	; clear the interrupt bit
   3628  274c6				   -	       sta	DLLMEM,x
   3629  274c6				   -	       ifconst	DOUBLEBUFFER
   3630  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3631  274c6				   -	       endif		; DOUBLEBUFFER
   3632  274c6				   -	       ldx	overscanDLLstart
   3633  274c6				   -findlastinterrupt
   3634  274c6				   -	       lda	DLLMEM,x
   3635  274c6				   -	       bmi	foundlastinterrupt
   3636  274c6				   -	       dex
   3637  274c6				   -	       dex
   3638  274c6				   -	       dex
   3639  274c6				   -	       bne	findlastinterrupt
   3640  274c6				   -foundlastinterrupt
   3641  274c6				   -	       and	#%01111111	; clear the interrupt bit
   3642  274c6				   -	       sta	DLLMEM,x
   3643  274c6				   -	       ifconst	DOUBLEBUFFER
   3644  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3645  274c6				   -	       endif		; DOUBLEBUFFER
   3646  274c6				   -			;now we need to set the new interrupts
   3647  274c6				   -	       clc
   3648  274c6				   -	       lda	temp1
   3649  274c6				   -	       adc	visibleDLLstart
   3650  274c6				   -	       tax
   3651  274c6				   -	       lda	DLLMEM,x
   3652  274c6				   -	       ora	#%10000000
   3653  274c6				   -	       sta	DLLMEM,x
   3654  274c6				   -	       ifconst	DOUBLEBUFFER
   3655  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3656  274c6				   -	       endif		; DOUBLEBUFFER
   3657  274c6				   -	       clc
   3658  274c6				   -	       lda	temp2
   3659  274c6				   -	       adc	visibleDLLstart
   3660  274c6				   -	       tax
   3661  274c6				   -	       lda	DLLMEM,x
   3662  274c6				   -	       ora	#%10000000
   3663  274c6				   -	       sta	DLLMEM,x
   3664  274c6				   -	       ifconst	DOUBLEBUFFER
   3665  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3666  274c6				   -	       endif		; DOUBLEBUFFER
   3667  274c6				   -	       jsr	vblankresync
   3668  274c6				   -	       rts
   3669  274c6					       endif		; USED_ADJUSTVISIBLE
   3670  274c6
   3671  274c6				    vblankresync
   3672  274c6			20 87 f5	       jsr	waitforvblankstart	; ensure vblank just started
   3673  274c9			a9 00		       lda	#0
   3674  274cb			85 4d		       sta	visibleover
   3675  274cd			a9 03		       lda	#3
   3676  274cf			8d b2 01	       sta	interruptindex
   3677  274d2			60		       rts
   3678  274d3
   3679  274d3				    createallgamedlls
   3680  274d3			a2 00		       ldx	#0
   3681  274d5			a9 19		       lda	#NVLINES
   3682  274d7			ac 09 21	       ldy	paldetected
   3683  274da			f0 03		       beq	skipcreatePALpadding
   3684  274dc			18		       clc
   3685  274dd			69 15		       adc	#21
   3686  274df				    skipcreatePALpadding
   3687  274df			20 1d f5	       jsr	createnonvisibledlls
   3688  274e2			8e 3c 21	       stx	visibleDLLstart
   3689  274e5			20 57 f5	       jsr	createvisiblezones
   3690  274e8			8e 3d 21	       stx	overscanDLLstart
   3691  274eb				    createallgamedllscontinue
   3692  274eb			a9 50		       lda	#(NVLINES+55)	; extras for PAL
   3693  274ed			20 1d f5	       jsr	createnonvisibledlls
   3694  274f0
   3695  274f0			ae 3c 21	       ldx	visibleDLLstart
   3696  274f3			bd 00 18	       lda	DLLMEM,x
   3697  274f6			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   3698  274f8			9d 00 18	       sta	DLLMEM,x
   3699  274fb					       ifconst	DOUBLEBUFFER
   3700  274fb			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3701  274fe					       endif		; DOUBLEBUFFER
   3702  274fe
   3703  274fe			ae 3d 21	       ldx	overscanDLLstart
   3704  27501			bd 00 18	       lda	DLLMEM,x
   3705  27504			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   3706  27506			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3707  27508			9d 00 18	       sta	DLLMEM,x
   3708  2750b					       ifconst	DOUBLEBUFFER
   3709  2750b			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3710  2750e					       endif		; DOUBLEBUFFER
   3711  2750e
   3712  2750e			e8		       inx
   3713  2750f			e8		       inx
   3714  27510			e8		       inx
   3715  27511
   3716  27511			bd 00 18	       lda	DLLMEM,x
   3717  27514			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   3718  27516			9d 00 18	       sta	DLLMEM,x
   3719  27519					       ifconst	DOUBLEBUFFER
   3720  27519			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3721  2751c					       endif		; DOUBLEBUFFER
   3722  2751c
   3723  2751c			60		       rts
   3724  2751d
   3725  2751d				    createnonvisibledlls
   3726  2751d			85 42		       sta	temp1
   3727  2751f			4a		       lsr
   3728  27520			4a		       lsr
   3729  27521			4a		       lsr
   3730  27522			4a		       lsr		; /16
   3731  27523			f0 09		       beq	skipcreatenonvisibledlls1loop
   3732  27525			a8		       tay
   3733  27526				    createnonvisibledlls1loop
   3734  27526			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3735  27528			20 3d f5	       jsr	createblankdllentry
   3736  2752b			88		       dey
   3737  2752c			d0 f8		       bne	createnonvisibledlls1loop
   3738  2752e				    skipcreatenonvisibledlls1loop
   3739  2752e			a5 42		       lda	temp1
   3740  27530			29 0f		       and	#%00001111
   3741  27532			f0 08		       beq	createnonvisibledllsreturn
   3742  27534			38		       sec
   3743  27535			e9 01		       sbc	#1
   3744  27537			09 40		       ora	#%01000000
   3745  27539			20 3d f5	       jsr	createblankdllentry
   3746  2753c				    createnonvisibledllsreturn
   3747  2753c			60		       rts
   3748  2753d
   3749  2753d				    createblankdllentry
   3750  2753d			9d 00 18	       sta	DLLMEM,x
   3751  27540					       ifconst	DOUBLEBUFFER
   3752  27540			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3753  27543					       endif		; DOUBLEBUFFER
   3754  27543			e8		       inx
   3755  27544			a9 21		       lda	#$21	; blank
   3756  27546			9d 00 18	       sta	DLLMEM,x
   3757  27549					       ifconst	DOUBLEBUFFER
   3758  27549			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3759  2754c					       endif		; DOUBLEBUFFER
   3760  2754c			e8		       inx
   3761  2754d			a9 00		       lda	#$00
   3762  2754f			9d 00 18	       sta	DLLMEM,x
   3763  27552					       ifconst	DOUBLEBUFFER
   3764  27552			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3765  27555					       endif		; DOUBLEBUFFER
   3766  27555			e8		       inx
   3767  27556			60		       rts
   3768  27557
   3769  27557				    createvisiblezones
   3770  27557			a0 00		       ldy	#0
   3771  27559				    createvisiblezonesloop
   3772  27559			b9 ee f6	       lda.w	DLHEIGHT,y
   3773  2755c			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   3774  2755e			9d 00 18	       sta	DLLMEM,x
   3775  27561					       ifconst	DOUBLEBUFFER
   3776  27561			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3777  27564					       endif		; DOUBLEBUFFER
   3778  27564			e8		       inx
   3779  27565			b9 d6 f6	       lda	DLPOINTH,y
   3780  27568				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   3781  27568				   -			; with bankset cart ram, we added $8000 to the DL address so plot functions would hit the write-address
   3782  27568				   -			; but now we need to subtract that $8000 location to give Maria the normal address
   3783  27568				   -	       sec
   3784  27568				   -	       sbc	#$80
   3785  27568					       endif		; BANKSET_DL_IN_CARTRAM
   3786  27568			9d 00 18	       sta	DLLMEM,x
   3787  2756b					       ifconst	DOUBLEBUFFER
   3788  2756b			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3789  2756e					       endif		; DOUBLEBUFFER
   3790  2756e			e8		       inx
   3791  2756f			b9 e2 f6	       lda	DLPOINTL,y
   3792  27572			9d 00 18	       sta	DLLMEM,x
   3793  27575					       ifconst	DOUBLEBUFFER
   3794  27575			18		       clc
   3795  27576			69 ff		       adc	#DOUBLEBUFFEROFFSET
   3796  27578			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3797  2757b			90 03		       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   3798  2757d			fe 6f 18	       inc	DLLMEM+DBOFFSET-1,x
   3799  27580				    skiphidoublebufferadjust
   3800  27580					       endif		; DOUBLEBUFFER
   3801  27580			e8		       inx
   3802  27581			c8		       iny
   3803  27582			c0 0c		       cpy	#WZONECOUNT
   3804  27584			d0 d3		       bne	createvisiblezonesloop
   3805  27586			60		       rts
   3806  27587
   3807  27587				    waitforvblankstart
   3808  27587				    vblankendwait
   3809  27587			24 28		       BIT	MSTAT
   3810  27589			30 fc		       bmi	vblankendwait
   3811  2758b				    vblankstartwait
   3812  2758b			24 28		       BIT	MSTAT
   3813  2758d			10 fc		       bpl	vblankstartwait
   3814  2758f			60		       rts
   3815  27590
   3816  27590					       ifconst	DOUBLEBUFFER
   3817  27590				    flipdisplaybufferreturn
   3818  27590			60		       rts
   3819  27591				    flipdisplaybuffer
   3820  27591				   -	       ifconst	interrupthold
   3821  27591				   -	       lda	#$FF
   3822  27591				   -	       sta	interrupthold
   3823  27591					       endif
   3824  27591			a5 d5		       lda	doublebufferstate
   3825  27593			f0 fb		       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   3826  27595
   3827  27595			20 54 f1	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   3828  27598
   3829  27598			a5 d5		       lda	doublebufferstate
   3830  2759a			4a		       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   3831  2759b			aa		       tax
   3832  2759c
   3833  2759c							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   3834  2759c
   3835  2759c				    flipdisplaybufferwait1
   3836  2759c			a5 4d		       lda	visibleover
   3837  2759e			f0 fc		       beq	flipdisplaybufferwait1
   3838  275a0
   3839  275a0				    flipdisplaybufferwait
   3840  275a0			a5 4d		       lda	visibleover
   3841  275a2			d0 fc		       bne	flipdisplaybufferwait
   3842  275a4
   3843  275a4			ad b3 01	       lda	doublebufferminimumframetarget
   3844  275a7			f0 0b		       beq	skipminimumframecode
   3845  275a9			ad b4 01	       lda	doublebufferminimumframeindex
   3846  275ac			d0 ee		       bne	flipdisplaybufferwait1
   3847  275ae			ad b3 01	       lda	doublebufferminimumframetarget
   3848  275b1			8d b4 01	       sta	doublebufferminimumframeindex
   3849  275b4				    skipminimumframecode
   3850  275b4
   3851  275b4			bd 14 f6	       lda	DLLMEMLutHi,x
   3852  275b7			85 2c		       sta	DPPH
   3853  275b9			bd 12 f6	       lda	DLLMEMLutLo,x
   3854  275bc			85 30		       sta	DPPL
   3855  275be
   3856  275be			bd 16 f6	       lda	NewPageflipstate,x
   3857  275c1			85 d5		       sta	doublebufferstate
   3858  275c3			bd 18 f6	       lda	NewPageflipoffset,x
   3859  275c6			85 d6		       sta	doublebufferdloffset
   3860  275c8
   3861  275c8					       ifnconst	BANKSET_DL_IN_CARTRAM
   3862  275c8			a5 d7		       lda	doublebufferbufferdirty
   3863  275ca			f0 c4		       beq	flipdisplaybufferreturn
   3864  275cc
   3865  275cc							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   3866  275cc							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   3867  275cc							; from the displayed buffer to the working buffer...
   3868  275cc
   3869  275cc			a5 d6		       lda	doublebufferdloffset
   3870  275ce			49 ff		       eor	#DOUBLEBUFFEROFFSET
   3871  275d0			85 47		       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   3872  275d2
   3873  275d2			a2 0b		       ldx	#(WZONECOUNT-1)
   3874  275d4				    copybufferzoneloop
   3875  275d4
   3876  275d4			bd e2 f6	       lda	DLPOINTL,x
   3877  275d7			18		       clc
   3878  275d8			65 d6		       adc	doublebufferdloffset
   3879  275da			85 42		       sta	temp1
   3880  275dc			bd d6 f6	       lda	DLPOINTH,x
   3881  275df			69 00		       adc	#0
   3882  275e1			85 43		       sta	temp2
   3883  275e3
   3884  275e3			bd e2 f6	       lda	DLPOINTL,x
   3885  275e6			18		       clc
   3886  275e7			65 47		       adc	temp6
   3887  275e9			85 44		       sta	temp3
   3888  275eb			bd d6 f6	       lda	DLPOINTH,x
   3889  275ee			69 00		       adc	#0
   3890  275f0			85 45		       sta	temp4
   3891  275f2
   3892  275f2			b5 82		       lda	dlendsave,x
   3893  275f4			a8		       tay
   3894  275f5				    copybuffercharsloop
   3895  275f5			b1 44		       lda	(temp3),y
   3896  275f7			91 42		       sta	(temp1),y
   3897  275f9			88		       dey
   3898  275fa			10 f9		       bpl	copybuffercharsloop
   3899  275fc			ca		       dex
   3900  275fd			10 d5		       bpl	copybufferzoneloop
   3901  275ff			a9 00		       lda	#0
   3902  27601			85 d7		       sta	doublebufferbufferdirty
   3903  27603					       endif		; ! BANKSET_DL_IN_CARTRAM
   3904  27603			60		       rts
   3905  27604
   3906  27604				    doublebufferoff
   3907  27604			a9 01		       lda	#1
   3908  27606			85 d5		       sta	doublebufferstate
   3909  27608			20 91 f5	       jsr	flipdisplaybuffer
   3910  2760b			a9 00		       lda	#0
   3911  2760d			85 d5		       sta	doublebufferstate
   3912  2760f			85 d6		       sta	doublebufferdloffset
   3913  27611			60		       rts
   3914  27612
   3915  27612				    DLLMEMLutLo
   3916  27612			00 70		       .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   3917  27614				    DLLMEMLutHi
   3918  27614			18 18		       .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   3919  27616				    NewPageflipstate
   3920  27616			03 01		       .byte.b	3,1
   3921  27618				    NewPageflipoffset
   3922  27618			ff 00		       .byte.b	DOUBLEBUFFEROFFSET,0
   3923  2761a
   3924  2761a					       endif		; DOUBLEBUFFER
   3925  2761a
   3926  2761a				   -	       ifconst	MOUSESUPPORT
   3927  2761a				   -
   3928  2761a				   -rotationalcompare
   3929  2761a				   -			; old =   00	  01	  10	 11
   3930  2761a				   -	       .byte	$00, $01, $ff, $00	; new=00
   3931  2761a				   -	       .byte	$ff, $00, $00, $01	; new=01
   3932  2761a				   -	       .byte	$01, $00, $00, $ff	; new=10
   3933  2761a				   -	       .byte	$00, $ff, $01, $00	; new=11
   3934  2761a				   -
   3935  2761a				   -			;  0000YyXx st mouse
   3936  2761a				   -
   3937  2761a				   -			;  0000xyXY amiga mouse
   3938  2761a				   -
   3939  2761a				   -	       ifconst	MOUSEXONLY
   3940  2761a				   -amigatoataribits		; swap bits 1 and 4...
   3941  2761a				   -	       .byte	%0000, %0000, %0010, %0010
   3942  2761a				   -	       .byte	%0000, %0000, %0010, %0010
   3943  2761a				   -	       .byte	%0001, %0001, %0011, %0011
   3944  2761a				   -	       .byte	%0001, %0001, %0011, %0011
   3945  2761a				   -
   3946  2761a				   -			; null change bits
   3947  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   3948  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   3949  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   3950  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   3951  2761a				   -
   3952  2761a				   -	       else		; !MOUSEXONLY
   3953  2761a				   -
   3954  2761a				   -amigatoataribits		; swap bits 1 and 4...
   3955  2761a				   -	       .byte	%0000, %1000, %0010, %1010
   3956  2761a				   -	       .byte	%0100, %1100, %0110, %1110
   3957  2761a				   -	       .byte	%0001, %1001, %0011, %1011
   3958  2761a				   -	       .byte	%0101, %1101, %0111, %1111
   3959  2761a				   -			; null change bits
   3960  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   3961  2761a				   -	       .byte	%0100, %0101, %0110, %0111
   3962  2761a				   -	       .byte	%1000, %1001, %1010, %1011
   3963  2761a				   -	       .byte	%1100, %1101, %1110, %1111
   3964  2761a				   -	       endif		; !MOUSEXONLY
   3965  2761a				   -
   3966  2761a					       endif		; MOUSESUPPORT
   3967  2761a
   3968  2761a				    mouse0update
   3969  2761a				   -	       ifconst	MOUSE0SUPPORT
   3970  2761a				   -
   3971  2761a				   -mousetableselect =	inttemp2
   3972  2761a				   -mousexdelta =	inttemp3
   3973  2761a				   -mouseydelta =	inttemp4
   3974  2761a				   -lastSWCHA  =	inttemp6
   3975  2761a				   -
   3976  2761a				   -			;  0000YyXx st mouse
   3977  2761a				   -			;  0000xyXY amiga mouse
   3978  2761a				   -
   3979  2761a				   -	       lda	#$ff
   3980  2761a				   -	       sta	lastSWCHA
   3981  2761a				   -
   3982  2761a				   -	       ldy	port0control
   3983  2761a				   -
   3984  2761a				   -	       lda	#%00010000
   3985  2761a				   -	       cpy	#9	; AMIGA?
   3986  2761a				   -	       bne	skipamigabitsfix0
   3987  2761a				   -	       lda	#0
   3988  2761a				   -skipamigabitsfix0
   3989  2761a				   -	       sta	mousetableselect
   3990  2761a				   -	       ifconst	DRIVINGBOOST
   3991  2761a				   -	       cpy	#6	; DRIVING?
   3992  2761a				   -	       bne	skipdriving0setup
   3993  2761a				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   3994  2761a				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   3995  2761a				   -			; the actual position. This actual position is stored in mousey0 
   3996  2761a				   -			; after the driver has run.
   3997  2761a				   -	       ldx	mousex0
   3998  2761a				   -	       lda	mousey0
   3999  2761a				   -	       stx	mousey0
   4000  2761a				   -	       sta	mousex0
   4001  2761a				   -skipdriving0setup
   4002  2761a				   -	       endif		; DRIVINGBOOST
   4003  2761a				   -
   4004  2761a				   -	       lda	#0
   4005  2761a				   -	       sta	mousexdelta
   4006  2761a				   -	       sta	mouseydelta
   4007  2761a				   -
   4008  2761a				   -	       ifnconst	MOUSETIME
   4009  2761a				   -	       ifnconst	MOUSEXONLY
   4010  2761a				   -	       lda	#180	; minimum for x+y
   4011  2761a				   -	       else
   4012  2761a				   -	       lda	#100	; minimum for just x
   4013  2761a				   -	       endif
   4014  2761a				   -	       else
   4015  2761a				   -	       lda	#MOUSETIME
   4016  2761a				   -	       endif
   4017  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4018  2761a				   -
   4019  2761a				   -mouse0updateloop
   4020  2761a				   -	       lda	SWCHA
   4021  2761a				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4022  2761a				   -	       cmp	lastSWCHA
   4023  2761a				   -	       beq	mouse0loopcondition
   4024  2761a				   -	       sta	lastSWCHA
   4025  2761a				   -	       lsr
   4026  2761a				   -	       lsr
   4027  2761a				   -	       lsr
   4028  2761a				   -
   4029  2761a				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4030  2761a				   -
   4031  2761a				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4032  2761a				   -			;  0000YyXx st mouse
   4033  2761a				   -			;  0000xyXY amiga mouse
   4034  2761a				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4035  2761a				   -	       tay
   4036  2761a				   -	       lax	amigatoataribits,y
   4037  2761a				   -
   4038  2761a				   -	       ifnconst	MOUSEXONLY
   4039  2761a				   -			; first the Y...
   4040  2761a				   -	       and	#%00001100
   4041  2761a				   -	       ora	mousecodey0
   4042  2761a				   -	       tay
   4043  2761a				   -	       lda	rotationalcompare,y
   4044  2761a				   -	       clc
   4045  2761a				   -	       adc	mouseydelta
   4046  2761a				   -	       sta	mouseydelta
   4047  2761a				   -	       tya
   4048  2761a				   -	       lsr
   4049  2761a				   -	       lsr
   4050  2761a				   -	       sta	mousecodey0
   4051  2761a				   -	       txa
   4052  2761a				   -			; ...then the X...
   4053  2761a				   -	       and	#%00000011
   4054  2761a				   -	       tax
   4055  2761a				   -	       endif		; !MOUSEXONLY
   4056  2761a				   -
   4057  2761a				   -	       asl
   4058  2761a				   -	       asl
   4059  2761a				   -	       ora	mousecodex0
   4060  2761a				   -	       tay
   4061  2761a				   -	       lda	rotationalcompare,y
   4062  2761a				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4063  2761a				   -	       sta	mousexdelta
   4064  2761a				   -	       stx	mousecodex0
   4065  2761a				   -mouse0loopcondition
   4066  2761a				   -	       lda	TIMINT
   4067  2761a				   -	       bpl	mouse0updateloop
   4068  2761a				   -
   4069  2761a				   -			; *** adapt to selected device resolution. 
   4070  2761a				   -	       ldx	port0control
   4071  2761a				   -
   4072  2761a				   -	       ifconst	PRECISIONMOUSING
   4073  2761a				   -	       ldy	port0resolution
   4074  2761a				   -	       bne	mouse0halveddone
   4075  2761a				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4076  2761a				   -	       beq	mouse0halveddone
   4077  2761a				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4078  2761a				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4079  2761a				   -
   4080  2761a				   -	       lda	mousexdelta
   4081  2761a				   -	       cmp	#$80
   4082  2761a				   -	       ror		; do a signed divide by 2.
   4083  2761a				   -	       clc
   4084  2761a				   -	       adc	mousex0
   4085  2761a				   -	       sta	mousex0
   4086  2761a				   -	       ifnconst	MOUSEXONLY
   4087  2761a				   -	       lda	mouseydelta
   4088  2761a				   -	       clc
   4089  2761a				   -	       adc	mousey0
   4090  2761a				   -	       sta	mousey0
   4091  2761a				   -	       endif
   4092  2761a				   -			; at half resolution we just exit after updating x and y
   4093  2761a				   -	       jmp	LLRET0
   4094  2761a				   -mouse0halveddone
   4095  2761a				   -	       endif		; PRECISIONMOUSING
   4096  2761a				   -
   4097  2761a				   -	       ifnconst	MOUSEXONLY
   4098  2761a				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4099  2761a				   -	       ldy	port0resolution
   4100  2761a				   -	       dey
   4101  2761a				   -	       lda	#0
   4102  2761a				   -mousey0resolutionfix
   4103  2761a				   -	       clc
   4104  2761a				   -	       adc	mouseydelta
   4105  2761a				   -	       dey
   4106  2761a				   -	       bpl	mousey0resolutionfix
   4107  2761a				   -	       clc
   4108  2761a				   -	       adc	mousey0
   4109  2761a				   -	       sta	mousey0
   4110  2761a				   -	       endif		; MOUSEXONLY
   4111  2761a				   -
   4112  2761a				   -	       ldy	port0resolution
   4113  2761a				   -	       dey
   4114  2761a				   -	       lda	#0
   4115  2761a				   -mousex0resolutionfix
   4116  2761a				   -	       clc
   4117  2761a				   -	       adc	mousexdelta
   4118  2761a				   -	       dey
   4119  2761a				   -	       bpl	mousex0resolutionfix
   4120  2761a				   -	       ifnconst	DRIVINGBOOST
   4121  2761a				   -	       clc
   4122  2761a				   -	       adc	mousex0
   4123  2761a				   -	       sta	mousex0
   4124  2761a				   -	       else
   4125  2761a				   -	       cpx	#6
   4126  2761a				   -	       beq	carryonmouse0boost
   4127  2761a				   -	       clc
   4128  2761a				   -	       adc	mousex0
   4129  2761a				   -	       sta	mousex0
   4130  2761a				   -	       jmp	LLRET0
   4131  2761a				   -carryonmouse0boost
   4132  2761a				   -	       sta	mousexdelta
   4133  2761a				   -	       clc
   4134  2761a				   -	       adc	mousecodey0
   4135  2761a				   -	       sta	mousecodey0
   4136  2761a				   -	       clc
   4137  2761a				   -	       adc	mousex0
   4138  2761a				   -	       tay		; save the target X
   4139  2761a				   -	       adc	mousey0	; average in the smoothly-trailing X
   4140  2761a				   -	       ror
   4141  2761a				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   4142  2761a				   -	       sty	mousey0	; and mousey0 has the the target X
   4143  2761a				   -
   4144  2761a				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4145  2761a				   -			; A has mousex0, the smoothly trailing X
   4146  2761a				   -	       sbc	mousey0	; less the target X
   4147  2761a				   -	       bpl	skipabsolutedrive0
   4148  2761a				   -	       eor	#$ff
   4149  2761a				   -skipabsolutedrive0
   4150  2761a				   -	       cmp	#64	; just an unreasonably large change
   4151  2761a				   -	       bcc	skipdrivewrapfix0
   4152  2761a				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   4153  2761a				   -skipdrivewrapfix0
   4154  2761a				   -
   4155  2761a				   -			; get rid of the tweening if the distance travelled was very small
   4156  2761a				   -	       lda	mousexdelta
   4157  2761a				   -	       cmp	port0resolution
   4158  2761a				   -	       bcs	skipbetweenfix0
   4159  2761a				   -	       lda	mousex0
   4160  2761a				   -	       sta	mousey0
   4161  2761a				   -skipbetweenfix0
   4162  2761a				   -
   4163  2761a				   -drivingboostreductioncheck0
   4164  2761a				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4165  2761a				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4166  2761a				   -			; negated again because truncation during BCD math results in 
   4167  2761a				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4168  2761a				   -driving0fix
   4169  2761a				   -	       lax	mousecodey0
   4170  2761a				   -	       cmp	#$80
   4171  2761a				   -	       bcs	driving0skipnegate1
   4172  2761a				   -	       eor	#$FF
   4173  2761a				   -	       adc	#1
   4174  2761a				   -	       sta	mousecodey0
   4175  2761a				   -driving0skipnegate1
   4176  2761a				   -	       cmp	#$80
   4177  2761a				   -	       ror
   4178  2761a				   -	       cmp	#$80
   4179  2761a				   -	       ror
   4180  2761a				   -	       cmp	#$80
   4181  2761a				   -	       ror
   4182  2761a				   -	       sta	inttemp1
   4183  2761a				   -	       lda	mousecodey0
   4184  2761a				   -	       sec
   4185  2761a				   -	       sbc	inttemp1
   4186  2761a				   -	       cpx	#$80
   4187  2761a				   -	       bcs	driving0skipnegate2
   4188  2761a				   -	       eor	#$FF
   4189  2761a				   -	       adc	#1
   4190  2761a				   -driving0skipnegate2
   4191  2761a				   -	       sta	mousecodey0
   4192  2761a				   -drivingboostdone0
   4193  2761a				   -	       endif		; DRIVINGBOOST
   4194  2761a				   -
   4195  2761a				   -	       jmp	LLRET0
   4196  2761a				   -
   4197  2761a					       endif		; MOUSE0SUPPORT
   4198  2761a
   4199  2761a				    mouse1update
   4200  2761a				   -	       ifconst	MOUSE1SUPPORT
   4201  2761a				   -
   4202  2761a				   -mousetableselect =	inttemp2
   4203  2761a				   -mousexdelta =	inttemp3
   4204  2761a				   -mouseydelta =	inttemp4
   4205  2761a				   -lastSWCHA  =	inttemp6
   4206  2761a				   -
   4207  2761a				   -			;  0000YyXx st mouse
   4208  2761a				   -			;  0000xyXY amiga mouse
   4209  2761a				   -
   4210  2761a				   -	       lda	#$ff
   4211  2761a				   -	       sta	lastSWCHA
   4212  2761a				   -
   4213  2761a				   -	       ldy	port1control
   4214  2761a				   -
   4215  2761a				   -	       lda	#%00010000
   4216  2761a				   -	       cpy	#9	; AMIGA?
   4217  2761a				   -	       bne	skipamigabitsfix1
   4218  2761a				   -	       lda	#0
   4219  2761a				   -skipamigabitsfix1
   4220  2761a				   -	       sta	mousetableselect
   4221  2761a				   -	       ifconst	DRIVINGBOOST
   4222  2761a				   -	       cpy	#6	; DRIVING?
   4223  2761a				   -	       bne	skipdriving1setup
   4224  2761a				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   4225  2761a				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   4226  2761a				   -			; the actual position. This actual position is stored in mousey1 
   4227  2761a				   -			; after the driver has run.
   4228  2761a				   -	       ldx	mousex1
   4229  2761a				   -	       lda	mousey1
   4230  2761a				   -	       stx	mousey1
   4231  2761a				   -	       sta	mousex1
   4232  2761a				   -skipdriving1setup
   4233  2761a				   -	       endif		; DRIVINGBOOST
   4234  2761a				   -
   4235  2761a				   -	       lda	#0
   4236  2761a				   -	       sta	mousexdelta
   4237  2761a				   -	       sta	mouseydelta
   4238  2761a				   -
   4239  2761a				   -	       ifnconst	MOUSETIME
   4240  2761a				   -	       ifnconst	MOUSEXONLY
   4241  2761a				   -	       lda	#180	; minimum for x+y
   4242  2761a				   -	       else
   4243  2761a				   -	       lda	#100	; minimum for just x
   4244  2761a				   -	       endif
   4245  2761a				   -	       else
   4246  2761a				   -	       lda	#MOUSETIME
   4247  2761a				   -	       endif
   4248  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4249  2761a				   -
   4250  2761a				   -mouse1updateloop
   4251  2761a				   -	       lda	SWCHA
   4252  2761a				   -	       and	#%00001111
   4253  2761a				   -	       cmp	lastSWCHA
   4254  2761a				   -	       beq	mouse1loopcondition
   4255  2761a				   -	       sta	lastSWCHA
   4256  2761a				   -
   4257  2761a				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4258  2761a				   -
   4259  2761a				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4260  2761a				   -			;  0000YyXx st mouse
   4261  2761a				   -			;  0000xyXY amiga mouse
   4262  2761a				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4263  2761a				   -	       tay
   4264  2761a				   -	       lax	amigatoataribits,y
   4265  2761a				   -
   4266  2761a				   -	       ifnconst	MOUSEXONLY
   4267  2761a				   -			; first the Y...
   4268  2761a				   -	       and	#%00001100
   4269  2761a				   -	       ora	mousecodey1
   4270  2761a				   -	       tay
   4271  2761a				   -	       lda	rotationalcompare,y
   4272  2761a				   -	       clc
   4273  2761a				   -	       adc	mouseydelta
   4274  2761a				   -	       sta	mouseydelta
   4275  2761a				   -	       tya
   4276  2761a				   -	       lsr
   4277  2761a				   -	       lsr
   4278  2761a				   -	       sta	mousecodey1
   4279  2761a				   -	       txa
   4280  2761a				   -			; ...then the X...
   4281  2761a				   -	       and	#%00000011
   4282  2761a				   -	       tax
   4283  2761a				   -	       endif		; !MOUSEXONLY
   4284  2761a				   -
   4285  2761a				   -	       asl
   4286  2761a				   -	       asl
   4287  2761a				   -	       ora	mousecodex1
   4288  2761a				   -	       tay
   4289  2761a				   -	       lda	rotationalcompare,y
   4290  2761a				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4291  2761a				   -	       sta	mousexdelta
   4292  2761a				   -	       stx	mousecodex1
   4293  2761a				   -mouse1loopcondition
   4294  2761a				   -	       lda	TIMINT
   4295  2761a				   -	       bpl	mouse1updateloop
   4296  2761a				   -
   4297  2761a				   -			; *** adapt to selected device resolution. 
   4298  2761a				   -	       ldx	port1control
   4299  2761a				   -
   4300  2761a				   -	       ifconst	PRECISIONMOUSING
   4301  2761a				   -	       ldy	port1resolution
   4302  2761a				   -	       bne	mouse1halveddone
   4303  2761a				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4304  2761a				   -	       beq	mouse1halveddone
   4305  2761a				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4306  2761a				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4307  2761a				   -
   4308  2761a				   -	       lda	mousexdelta
   4309  2761a				   -	       cmp	#$80
   4310  2761a				   -	       ror		; do a signed divide by 2.
   4311  2761a				   -	       clc
   4312  2761a				   -	       adc	mousex1
   4313  2761a				   -	       sta	mousex1
   4314  2761a				   -	       ifnconst	MOUSEXONLY
   4315  2761a				   -	       lda	mouseydelta
   4316  2761a				   -	       clc
   4317  2761a				   -	       adc	mousey1
   4318  2761a				   -	       sta	mousey1
   4319  2761a				   -	       endif
   4320  2761a				   -			; at half resolution we just exit after updating x and y
   4321  2761a				   -	       jmp	LLRET1
   4322  2761a				   -mouse1halveddone
   4323  2761a				   -	       endif		; PRECISIONMOUSING
   4324  2761a				   -
   4325  2761a				   -	       ifnconst	MOUSEXONLY
   4326  2761a				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4327  2761a				   -	       ldy	port1resolution
   4328  2761a				   -	       dey
   4329  2761a				   -	       lda	#0
   4330  2761a				   -mousey1resolutionfix
   4331  2761a				   -	       clc
   4332  2761a				   -	       adc	mouseydelta
   4333  2761a				   -	       dey
   4334  2761a				   -	       bpl	mousey1resolutionfix
   4335  2761a				   -	       clc
   4336  2761a				   -	       adc	mousey1
   4337  2761a				   -	       sta	mousey1
   4338  2761a				   -	       endif		; MOUSEXONLY
   4339  2761a				   -
   4340  2761a				   -	       ldy	port1resolution
   4341  2761a				   -	       dey
   4342  2761a				   -	       lda	#0
   4343  2761a				   -mousex1resolutionfix
   4344  2761a				   -	       clc
   4345  2761a				   -	       adc	mousexdelta
   4346  2761a				   -	       dey
   4347  2761a				   -	       bpl	mousex1resolutionfix
   4348  2761a				   -	       ifnconst	DRIVINGBOOST
   4349  2761a				   -	       clc
   4350  2761a				   -	       adc	mousex1
   4351  2761a				   -	       sta	mousex1
   4352  2761a				   -	       else
   4353  2761a				   -	       cpx	#6
   4354  2761a				   -	       beq	carryonmouse1boost
   4355  2761a				   -	       clc
   4356  2761a				   -	       adc	mousex1
   4357  2761a				   -	       sta	mousex1
   4358  2761a				   -	       jmp	LLRET1
   4359  2761a				   -carryonmouse1boost
   4360  2761a				   -	       sta	mousexdelta
   4361  2761a				   -	       clc
   4362  2761a				   -	       adc	mousecodey1
   4363  2761a				   -	       sta	mousecodey1
   4364  2761a				   -	       clc
   4365  2761a				   -	       adc	mousex1
   4366  2761a				   -	       tay		; save the target X
   4367  2761a				   -	       adc	mousey1	; average in the smoothly-trailing X
   4368  2761a				   -	       ror
   4369  2761a				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   4370  2761a				   -	       sty	mousey1	; and mousey0 has the the target X
   4371  2761a				   -
   4372  2761a				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4373  2761a				   -			; A has mousex1, the smoothly trailing X
   4374  2761a				   -	       sbc	mousey1	; less the target X
   4375  2761a				   -	       bpl	skipabsolutedrive1
   4376  2761a				   -	       eor	#$ff
   4377  2761a				   -skipabsolutedrive1
   4378  2761a				   -	       cmp	#64	; just an unreasonably large change
   4379  2761a				   -	       bcc	skipdrivewrapfix1
   4380  2761a				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   4381  2761a				   -skipdrivewrapfix1
   4382  2761a				   -
   4383  2761a				   -			; get rid of the tweening if the distance travelled was very small
   4384  2761a				   -	       lda	mousexdelta
   4385  2761a				   -	       cmp	port1resolution
   4386  2761a				   -	       bcs	skipbetweenfix1
   4387  2761a				   -	       lda	mousex1
   4388  2761a				   -	       sta	mousey1
   4389  2761a				   -skipbetweenfix1
   4390  2761a				   -
   4391  2761a				   -drivingboostreductioncheck1
   4392  2761a				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4393  2761a				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4394  2761a				   -			; negated again because truncation during BCD math results in 
   4395  2761a				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4396  2761a				   -driving1fix
   4397  2761a				   -	       lax	mousecodey1
   4398  2761a				   -	       cmp	#$80
   4399  2761a				   -	       bcs	driving0skipnegate1
   4400  2761a				   -	       eor	#$FF
   4401  2761a				   -	       adc	#1
   4402  2761a				   -	       sta	mousecodey1
   4403  2761a				   -driving0skipnegate1
   4404  2761a				   -	       cmp	#$80
   4405  2761a				   -	       ror
   4406  2761a				   -	       cmp	#$80
   4407  2761a				   -	       ror
   4408  2761a				   -	       cmp	#$80
   4409  2761a				   -	       ror
   4410  2761a				   -	       sta	inttemp1
   4411  2761a				   -	       lda	mousecodey1
   4412  2761a				   -	       sec
   4413  2761a				   -	       sbc	inttemp1
   4414  2761a				   -	       cpx	#$80
   4415  2761a				   -	       bcs	driving1skipnegate2
   4416  2761a				   -	       eor	#$FF
   4417  2761a				   -	       adc	#1
   4418  2761a				   -driving1skipnegate2
   4419  2761a				   -	       sta	mousecodey1
   4420  2761a				   -drivingboostdone1
   4421  2761a				   -	       endif		; DRIVINGBOOST
   4422  2761a				   -
   4423  2761a				   -	       jmp	LLRET1
   4424  2761a				   -
   4425  2761a					       endif		; MOUSE1SUPPORT
   4426  2761a
   4427  2761a
   4428  2761a				    trakball0update
   4429  2761a				   -	       ifconst	TRAKBALL0SUPPORT
   4430  2761a				   -	       ifnconst	TRAKTIME
   4431  2761a				   -	       ifnconst	TRAKXONLY
   4432  2761a				   -	       lda	#180	; minimum for x+y
   4433  2761a				   -	       else		;  !TRAKXONLY
   4434  2761a				   -	       lda	#100	; minimum for just x
   4435  2761a				   -	       endif		; !TRAKXONLY
   4436  2761a				   -	       else		; !TRAKTIME
   4437  2761a				   -	       lda	#TRAKTIME
   4438  2761a				   -	       endif		; !TRAKTIME
   4439  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4440  2761a				   -	       ldx	#0
   4441  2761a				   -	       ifnconst	TRAKXONLY
   4442  2761a				   -	       ldy	#0
   4443  2761a				   -	       endif		;  TRAKXONLY
   4444  2761a				   -trakball0updateloop
   4445  2761a				   -	       lda	SWCHA
   4446  2761a				   -	       and	#%00110000
   4447  2761a				   -	       cmp	trakballcodex0
   4448  2761a				   -	       sta	trakballcodex0
   4449  2761a				   -	       beq	trakball0movementXdone
   4450  2761a				   -	       and	#%00010000
   4451  2761a				   -	       beq	trakball0negativeX
   4452  2761a				   -trakball0positiveX
   4453  2761a				   -			;(2 from beq)
   4454  2761a				   -	       inx		; 2
   4455  2761a				   -	       jmp	trakball0movementXdone	; 3
   4456  2761a				   -trakball0negativeX
   4457  2761a				   -			;(3 from beq)
   4458  2761a				   -	       dex		; 2
   4459  2761a				   -	       nop		; 2
   4460  2761a				   -trakball0movementXdone
   4461  2761a				   -
   4462  2761a				   -	       ifnconst	TRAKXONLY
   4463  2761a				   -	       lda	SWCHA
   4464  2761a				   -	       and	#%11000000
   4465  2761a				   -	       cmp	trakballcodey0
   4466  2761a				   -	       sta	trakballcodey0
   4467  2761a				   -	       beq	trakball0movementYdone
   4468  2761a				   -	       and	#%01000000
   4469  2761a				   -	       beq	trakball0negativeY
   4470  2761a				   -trakball0positiveY
   4471  2761a				   -			;(2 from beq)
   4472  2761a				   -	       iny		; 2
   4473  2761a				   -	       jmp	trakball0movementYdone	; 3
   4474  2761a				   -trakball0negativeY
   4475  2761a				   -			;(3 from beq)
   4476  2761a				   -	       dey		; 2
   4477  2761a				   -	       nop		; 2
   4478  2761a				   -trakball0movementYdone
   4479  2761a				   -	       endif		; !TRAKXONLY
   4480  2761a				   -
   4481  2761a				   -	       lda	TIMINT
   4482  2761a				   -	       bpl	trakball0updateloop
   4483  2761a				   -	       lda	#0
   4484  2761a				   -	       cpx	#0
   4485  2761a				   -	       beq	trakball0skipXadjust
   4486  2761a				   -	       clc
   4487  2761a				   -trakball0Xloop
   4488  2761a				   -	       adc	port0resolution
   4489  2761a				   -	       dex
   4490  2761a				   -	       bne	trakball0Xloop
   4491  2761a				   -	       clc
   4492  2761a				   -	       adc	trakballx0
   4493  2761a				   -	       sta	trakballx0
   4494  2761a				   -trakball0skipXadjust
   4495  2761a				   -	       ifnconst	TRAKXONLY
   4496  2761a				   -	       lda	#0
   4497  2761a				   -	       cpy	#0
   4498  2761a				   -	       beq	trakball0skipYadjust
   4499  2761a				   -	       clc
   4500  2761a				   -trakball0yloop
   4501  2761a				   -	       adc	port0resolution
   4502  2761a				   -	       dey
   4503  2761a				   -	       bne	trakball0yloop
   4504  2761a				   -	       clc
   4505  2761a				   -	       adc	trakbally0
   4506  2761a				   -	       sta	trakbally0
   4507  2761a				   -trakball0skipYadjust
   4508  2761a				   -	       endif		; !TRAKXONLY
   4509  2761a				   -
   4510  2761a				   -	       jmp	LLRET0
   4511  2761a					       endif
   4512  2761a
   4513  2761a
   4514  2761a
   4515  2761a				    trakball1update
   4516  2761a				   -	       ifconst	TRAKBALL1SUPPORT
   4517  2761a				   -	       ifnconst	TRAKTIME
   4518  2761a				   -	       ifnconst	TRAKXONLY
   4519  2761a				   -	       lda	#180	; minimum for x+y
   4520  2761a				   -	       else		;  !TRAKXONLY
   4521  2761a				   -	       lda	#100	; minimum for just x
   4522  2761a				   -	       endif		; !TRAKXONLY
   4523  2761a				   -	       else		; !TRAKTIME
   4524  2761a				   -	       lda	#TRAKTIME
   4525  2761a				   -	       endif		; !TRAKTIME
   4526  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4527  2761a				   -	       ldx	#0
   4528  2761a				   -	       ifnconst	TRAKXONLY
   4529  2761a				   -	       ldy	#0
   4530  2761a				   -	       endif		;  TRAKXONLY
   4531  2761a				   -trakball1updateloop
   4532  2761a				   -	       lda	SWCHA
   4533  2761a				   -	       and	#%00000011
   4534  2761a				   -	       cmp	trakballcodex1
   4535  2761a				   -	       sta	trakballcodex1
   4536  2761a				   -	       beq	trakball1movementXdone
   4537  2761a				   -	       and	#%00000001
   4538  2761a				   -	       beq	trakball1negativeX
   4539  2761a				   -trakball1positiveX
   4540  2761a				   -			;(2 from beq)
   4541  2761a				   -	       inx		; 2
   4542  2761a				   -	       jmp	trakball1movementXdone	; 3
   4543  2761a				   -trakball1negativeX
   4544  2761a				   -			;(3 from beq)
   4545  2761a				   -	       dex		; 2
   4546  2761a				   -	       nop		; 2
   4547  2761a				   -trakball1movementXdone
   4548  2761a				   -
   4549  2761a				   -	       ifnconst	TRAKXONLY
   4550  2761a				   -	       lda	SWCHA
   4551  2761a				   -	       and	#%00001100
   4552  2761a				   -	       cmp	trakballcodey1
   4553  2761a				   -	       sta	trakballcodey1
   4554  2761a				   -	       beq	trakball1movementYdone
   4555  2761a				   -	       and	#%00000100
   4556  2761a				   -	       beq	trakball1negativeY
   4557  2761a				   -trakball1positiveY
   4558  2761a				   -			;(2 from beq)
   4559  2761a				   -	       iny		; 2
   4560  2761a				   -	       jmp	trakball1movementYdone	; 3
   4561  2761a				   -trakball1negativeY
   4562  2761a				   -			;(3 from beq)
   4563  2761a				   -	       dey		; 2
   4564  2761a				   -	       nop		; 2
   4565  2761a				   -trakball1movementYdone
   4566  2761a				   -	       endif		; !TRAKXONLY
   4567  2761a				   -
   4568  2761a				   -	       lda	TIMINT
   4569  2761a				   -	       bpl	trakball1updateloop
   4570  2761a				   -	       lda	#0
   4571  2761a				   -	       cpx	#0
   4572  2761a				   -	       beq	trakball1skipXadjust
   4573  2761a				   -	       clc
   4574  2761a				   -trakball1Xloop
   4575  2761a				   -	       adc	port1resolution
   4576  2761a				   -	       dex
   4577  2761a				   -	       bne	trakball1Xloop
   4578  2761a				   -	       clc
   4579  2761a				   -	       adc	trakballx1
   4580  2761a				   -	       sta	trakballx1
   4581  2761a				   -trakball1skipXadjust
   4582  2761a				   -	       ifnconst	TRAKXONLY
   4583  2761a				   -	       lda	#0
   4584  2761a				   -	       cpy	#0
   4585  2761a				   -	       beq	trakball1skipYadjust
   4586  2761a				   -	       clc
   4587  2761a				   -trakball1yloop
   4588  2761a				   -	       adc	port1resolution
   4589  2761a				   -	       dey
   4590  2761a				   -	       bne	trakball1yloop
   4591  2761a				   -	       clc
   4592  2761a				   -	       adc	trakbally1
   4593  2761a				   -	       sta	trakbally1
   4594  2761a				   -trakball1skipYadjust
   4595  2761a				   -	       endif		; !TRAKXONLY
   4596  2761a				   -
   4597  2761a				   -	       jmp	LLRET1
   4598  2761a					       endif
   4599  2761a
   4600  2761a
   4601  2761a				    paddleport0update
   4602  2761a				   -	       ifconst	PADDLE0SUPPORT
   4603  2761a				   -	       lda	#6
   4604  2761a				   -	       sta	VBLANK	; start charging the paddle caps
   4605  2761a				   -	       lda	#0	; use PADDLE timing
   4606  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4607  2761a				   -
   4608  2761a				   -paddleport0updateloop
   4609  2761a				   -	       lda	INPT0
   4610  2761a				   -	       bmi	skippaddle0setposition
   4611  2761a				   -	       sty	paddleposition0
   4612  2761a				   -skippaddle0setposition
   4613  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4614  2761a				   -	       lda	INPT1
   4615  2761a				   -	       bmi	skippaddle1setposition
   4616  2761a				   -	       sty	paddleposition1
   4617  2761a				   -skippaddle1setposition
   4618  2761a				   -	       endif
   4619  2761a				   -	       ldy	INTIM
   4620  2761a				   -	       cpy	#TIMEOFFSET
   4621  2761a				   -	       bcs	paddleport0updateloop
   4622  2761a				   -
   4623  2761a				   -	       lda	#%10000110
   4624  2761a				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4625  2761a				   -	       sec
   4626  2761a				   -	       lda	paddleposition0
   4627  2761a				   -	       sbc	#TIMEOFFSET
   4628  2761a				   -	       ifconst	PADDLESCALEX2
   4629  2761a				   -	       asl
   4630  2761a				   -	       endif
   4631  2761a				   -
   4632  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4633  2761a				   -	       clc
   4634  2761a				   -	       adc	paddleprevious0
   4635  2761a				   -	       ror
   4636  2761a				   -	       sta	paddleprevious0
   4637  2761a				   -	       endif
   4638  2761a				   -
   4639  2761a				   -	       sta	paddleposition0
   4640  2761a				   -
   4641  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4642  2761a				   -	       sec
   4643  2761a				   -	       lda	paddleposition1
   4644  2761a				   -	       sbc	#TIMEOFFSET
   4645  2761a				   -	       ifconst	PADDLESCALEX2
   4646  2761a				   -	       asl
   4647  2761a				   -	       endif
   4648  2761a				   -
   4649  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4650  2761a				   -	       clc
   4651  2761a				   -	       adc	paddleprevious1
   4652  2761a				   -	       ror
   4653  2761a				   -	       sta	paddleprevious1
   4654  2761a				   -	       endif
   4655  2761a				   -	       sta	paddleposition1
   4656  2761a				   -	       endif		; TWOPADDLESUPPORT
   4657  2761a				   -
   4658  2761a				   -	       jmp	LLRET0
   4659  2761a					       endif
   4660  2761a
   4661  2761a				    paddleport1update
   4662  2761a				   -	       ifconst	PADDLE1SUPPORT
   4663  2761a				   -	       lda	#6
   4664  2761a				   -	       sta	VBLANK	; start charging the paddle caps
   4665  2761a				   -
   4666  2761a				   -	       lda	#0	; use PADDLE timing
   4667  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4668  2761a				   -
   4669  2761a				   -paddleport1updateloop
   4670  2761a				   -	       lda	INPT2
   4671  2761a				   -	       bmi	skippaddle2setposition
   4672  2761a				   -	       sty	paddleposition2
   4673  2761a				   -skippaddle2setposition
   4674  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4675  2761a				   -	       lda	INPT3
   4676  2761a				   -	       bmi	skippaddle3setposition
   4677  2761a				   -	       sty	paddleposition3
   4678  2761a				   -skippaddle3setposition
   4679  2761a				   -	       endif
   4680  2761a				   -	       ldy	INTIM
   4681  2761a				   -	       cpy	#TIMEOFFSET
   4682  2761a				   -	       bcs	paddleport1updateloop
   4683  2761a				   -
   4684  2761a				   -	       lda	#%10000110
   4685  2761a				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4686  2761a				   -	       sec
   4687  2761a				   -	       lda	paddleposition2
   4688  2761a				   -	       sbc	#TIMEOFFSET
   4689  2761a				   -	       ifconst	PADDLESCALEX2
   4690  2761a				   -	       asl
   4691  2761a				   -	       endif
   4692  2761a				   -
   4693  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4694  2761a				   -	       clc
   4695  2761a				   -	       adc	paddleprevious2
   4696  2761a				   -	       ror
   4697  2761a				   -	       sta	paddleprevious2
   4698  2761a				   -	       endif
   4699  2761a				   -
   4700  2761a				   -	       sta	paddleposition2
   4701  2761a				   -
   4702  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4703  2761a				   -	       sec
   4704  2761a				   -	       lda	paddleposition3
   4705  2761a				   -	       sbc	#TIMEOFFSET
   4706  2761a				   -	       ifconst	PADDLESCALEX2
   4707  2761a				   -	       asl
   4708  2761a				   -	       endif
   4709  2761a				   -
   4710  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4711  2761a				   -	       clc
   4712  2761a				   -	       adc	paddleprevious3
   4713  2761a				   -	       ror
   4714  2761a				   -	       sta	paddleprevious3
   4715  2761a				   -	       endif
   4716  2761a				   -	       sta	paddleposition3
   4717  2761a				   -	       endif		; TWOPADDLESUPPORT
   4718  2761a				   -
   4719  2761a				   -	       jmp	LLRET1
   4720  2761a					       endif
   4721  2761a
   4722  2761a
   4723  2761a				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   4724  2761a				   -	       ifconst	PADDLESUPPORT
   4725  2761a				   -			; x=0|1 for port, rather than paddle #. 
   4726  2761a				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   4727  2761a				   -			; game wants to support 2 paddles, up to the game to instead test the 
   4728  2761a				   -			; joystick right+left directions instead.
   4729  2761a				   -	       lda	SWCHA	; top of nibble is first paddle button
   4730  2761a				   -	       cpx	#0	; port 0?
   4731  2761a				   -	       beq	skippaddleport2shift
   4732  2761a				   -	       asl		; shift second port to upper nibble
   4733  2761a				   -	       asl
   4734  2761a				   -	       asl
   4735  2761a				   -	       asl
   4736  2761a				   -skippaddleport2shift
   4737  2761a				   -	       and	#%10000000
   4738  2761a				   -	       eor	#%10000000	; invert
   4739  2761a				   -	       sta	sINPT1,x
   4740  2761a				   -	       jmp	buttonreadloopreturn
   4741  2761a					       endif		; PADDLESUPPORT
   4742  2761a
   4743  2761a				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   4744  2761a				   -	       ifconst	MOUSESUPPORT
   4745  2761a				   -			; stick the mouse buttons in the correct shadow register...
   4746  2761a				   -	       txa
   4747  2761a				   -	       asl
   4748  2761a				   -	       tay		; y=x*2
   4749  2761a				   -	       lda	INPT4,x
   4750  2761a				   -	       eor	#%10000000
   4751  2761a				   -	       lsr
   4752  2761a				   -	       sta	sINPT1,x
   4753  2761a				   -
   4754  2761a				   -	       lda	INPT1,y
   4755  2761a				   -	       and	#%10000000
   4756  2761a				   -	       eor	#%10000000
   4757  2761a				   -	       ora	sINPT1,x
   4758  2761a				   -	       sta	sINPT1,x
   4759  2761a				   -	       jmp	buttonreadloopreturn
   4760  2761a					       endif		; MOUSESUPPORT
   4761  2761a
   4762  2761a				   -	       ifconst	KEYPADSUPPORT
   4763  2761a				   -			; ** select keypad rows 0 to 3 over 4 frames...
   4764  2761a				   -keypadrowselect
   4765  2761a				   -	       inc	keypadcounter
   4766  2761a				   -	       ldy	#0
   4767  2761a				   -	       lda	port0control
   4768  2761a				   -	       cmp	#7
   4769  2761a				   -	       bne	skipport0val
   4770  2761a				   -	       iny		; y=y+1
   4771  2761a				   -skipport0val
   4772  2761a				   -	       lda	port1control
   4773  2761a				   -	       cmp	#7
   4774  2761a				   -	       bne	skipport1val
   4775  2761a				   -	       iny
   4776  2761a				   -	       iny		; y=y+2
   4777  2761a				   -skipport1val
   4778  2761a				   -	       cpy	#0
   4779  2761a				   -	       beq	exitkeypadrowselect
   4780  2761a				   -	       lda	keyrowdirectionmask,y
   4781  2761a				   -	       sta	CTLSWA
   4782  2761a				   -	       tya
   4783  2761a				   -	       asl
   4784  2761a				   -	       asl
   4785  2761a				   -	       sta	inttemp1
   4786  2761a				   -	       lda	keypadcounter
   4787  2761a				   -	       and	#3
   4788  2761a				   -	       ora	inttemp1
   4789  2761a				   -	       tax
   4790  2761a				   -	       lda	keyrowselectvalue,x
   4791  2761a				   -	       sta	SWCHA
   4792  2761a				   -exitkeypadrowselect
   4793  2761a				   -	       rts
   4794  2761a				   -
   4795  2761a				   -keyrowdirectionmask
   4796  2761a				   -	       .byte	#%00000000	; 0 : port0=input  port1=input
   4797  2761a				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   4798  2761a				   -	       .byte	#%00001111	; 2 : port0=input  port1=output
   4799  2761a				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   4800  2761a				   -
   4801  2761a				   -keyrowselectvalue
   4802  2761a				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   4803  2761a				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   4804  2761a				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   4805  2761a				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   4806  2761a					       endif		;  KEYPADSUPPORT
   4807  2761a
   4808  2761a				   -	       ifconst	KEYPADSUPPORT
   4809  2761a				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   4810  2761a				   -keypadcolumnread
   4811  2761a				   -	       lda	port0control
   4812  2761a				   -	       cmp	#7
   4813  2761a				   -	       bne	skipkeypadcolumnread0
   4814  2761a				   -	       lda	keypadcounter
   4815  2761a				   -	       and	#3
   4816  2761a				   -	       asl		; x2 because keypad variables are interleaved
   4817  2761a				   -	       tax
   4818  2761a				   -	       lda	#0
   4819  2761a				   -	       sta	keypadmatrix0a,x
   4820  2761a				   -	       lda	INPT0
   4821  2761a				   -	       cmp	#$80
   4822  2761a				   -	       rol	keypadmatrix0a,x
   4823  2761a				   -	       lda	INPT1
   4824  2761a				   -	       cmp	#$80
   4825  2761a				   -	       rol	keypadmatrix0a,x
   4826  2761a				   -	       lda	INPT4
   4827  2761a				   -	       cmp	#$80
   4828  2761a				   -	       rol	keypadmatrix0a,x
   4829  2761a				   -	       lda	keypadmatrix0a,x
   4830  2761a				   -	       eor	#%00000111
   4831  2761a				   -	       sta	keypadmatrix0a,x
   4832  2761a				   -skipkeypadcolumnread0
   4833  2761a				   -
   4834  2761a				   -	       lda	port1control
   4835  2761a				   -	       cmp	#7
   4836  2761a				   -	       bne	skipkeypadcolumnread1
   4837  2761a				   -	       lda	keypadcounter
   4838  2761a				   -	       and	#3
   4839  2761a				   -	       asl		; x2 because keypad variables are interleaved
   4840  2761a				   -	       tax
   4841  2761a				   -	       lda	#0
   4842  2761a				   -	       sta	keypadmatrix1a,x
   4843  2761a				   -	       rol	keypadmatrix1a,x
   4844  2761a				   -	       lda	INPT2
   4845  2761a				   -	       cmp	#$80
   4846  2761a				   -	       rol	keypadmatrix1a,x
   4847  2761a				   -	       lda	INPT3
   4848  2761a				   -	       cmp	#$80
   4849  2761a				   -	       rol	keypadmatrix1a,x
   4850  2761a				   -	       lda	INPT5
   4851  2761a				   -	       cmp	#$80
   4852  2761a				   -	       rol	keypadmatrix1a,x
   4853  2761a				   -	       lda	keypadmatrix1a,x
   4854  2761a				   -	       eor	#%00000111
   4855  2761a				   -	       sta	keypadmatrix1a,x
   4856  2761a				   -skipkeypadcolumnread1
   4857  2761a				   -	       rts
   4858  2761a					       endif		; KEYPADSUPPORT
   4859  2761a
   4860  2761a				    setportforinput
   4861  2761a			a5 e4		       lda	CTLSWAs
   4862  2761c			3d 25 f6	       and	allpinsinputlut,x
   4863  2761f			85 e4		       sta	CTLSWAs
   4864  27621			8d 81 02	       sta	CTLSWA
   4865  27624			60		       rts
   4866  27625
   4867  27625				    allpinsinputlut
   4868  27625			0f f0		       .byte.b	$0F, $F0
   4869  27627
   4870  27627				    setonebuttonmode
   4871  27627			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   4872  27629			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   4873  2762b			a9 14		       lda	#$14
   4874  2762d			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   4875  27630			a5 e5		       lda	CTLSWBs
   4876  27632			1d 3b f6	       ora	thisjoy2buttonbit,x
   4877  27635			85 e5		       sta	CTLSWBs
   4878  27637			8d 82 02	       sta	SWCHB	; turn off the 2-button disable bits
   4879  2763a			60		       rts
   4880  2763b
   4881  2763b				    thisjoy2buttonbit
   4882  2763b			04 10		       .byte.b	$04, $10
   4883  2763d
   4884  2763d				    settwobuttonmode
   4885  2763d			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   4886  2763f			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   4887  27641			a9 14		       lda	#$14
   4888  27643			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   4889  27646			a5 e5		       lda	CTLSWBs
   4890  27648			3d 51 f6	       and	thisjoy2buttonmask,x
   4891  2764b			85 e5		       sta	CTLSWBs
   4892  2764d			8d 82 02	       sta	SWCHB
   4893  27650			60		       rts
   4894  27651
   4895  27651				    thisjoy2buttonmask
   4896  27651			fb ef		       .byte.b	$fb, $ef
   4897  27653
   4898  27653							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4899  27653
   4900  27653				    START
   4901  27653				    start
   4902  27653
   4903  27653							;******** more or less the Atari recommended startup procedure
   4904  27653
   4905  27653			78		       sei
   4906  27654			d8		       cld
   4907  27655
   4908  27655					       ifnconst	NOTIALOCK
   4909  27655			a9 07		       lda	#$07
   4910  27657				   -	       else
   4911  27657				   -	       lda	#$06
   4912  27657					       endif
   4913  27657			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   4914  27659			a9 7f		       lda	#$7F
   4915  2765b			85 3c		       sta	CTRL	;disable DMA
   4916  2765d			a9 00		       lda	#$00
   4917  2765f			85 38		       sta	OFFSET
   4918  27661					       ifnconst	NOTIALOCK
   4919  27661			85 01		       sta	INPTCTRL
   4920  27663			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   4921  27665					       endif
   4922  27665			a2 ff		       ldx	#$FF
   4923  27667			9a		       txs
   4924  27668
   4925  27668							;************** Clear Memory
   4926  27668
   4927  27668							; ** Clear 1800-27FF, pg0+pg1 memory.
   4928  27668				    ClearMemPages
   4929  27668			a9 00		       lda	#0
   4930  2766a			a8		       tay		; y=0
   4931  2766b			85 80		       sta	$80
   4932  2766d			a2 18		       ldx	#$18
   4933  2766f				    ClearMemPagesLoop
   4934  2766f			86 81		       stx	$81	; needed for when we step on ZP memory
   4935  27671			91 80		       sta	($80),y	;Store data
   4936  27673			c8		       iny		;Next byte
   4937  27674			d0 f9		       bne	ClearMemPagesLoop
   4938  27676			e8		       inx
   4939  27677			e0 28		       cpx	#$28
   4940  27679			d0 f4		       bne	ClearMemPagesLoop
   4941  2767b			85 81		       sta	$81
   4942  2767d
   4943  2767d							;seed random number with hopefully-random timer value
   4944  2767d			a9 01		       lda	#1
   4945  2767f			0d 84 02	       ora	INTIM
   4946  27682			85 40		       sta	rand
   4947  27684
   4948  27684							; detect the console type...
   4949  27684				    pndetectvblankstart
   4950  27684			a5 28		       lda	MSTAT
   4951  27686			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   4952  27688				    pndetectvblankover
   4953  27688			a5 28		       lda	MSTAT
   4954  2768a			30 fc		       bmi	pndetectvblankover	;  then wait for it to be over
   4955  2768c			a0 00		       ldy	#$00
   4956  2768e			a2 00		       ldx	#$00
   4957  27690				    pndetectvblankhappening
   4958  27690			a5 28		       lda	MSTAT
   4959  27692			30 07		       bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   4960  27694			85 24		       sta	WSYNC
   4961  27696			85 24		       sta	WSYNC
   4962  27698			e8		       inx
   4963  27699			d0 f5		       bne	pndetectvblankhappening
   4964  2769b				    pndetectinvblank
   4965  2769b			e0 7d		       cpx	#125
   4966  2769d			90 02		       bcc	pndetecispal
   4967  2769f			a0 01		       ldy	#$01
   4968  276a1				    pndetecispal
   4969  276a1			8c 09 21	       sty	paldetected
   4970  276a4
   4971  276a4			20 d3 f4	       jsr	createallgamedlls
   4972  276a7
   4973  276a7			a9 18		       lda	#>DLLMEM
   4974  276a9			85 2c		       sta	DPPH
   4975  276ab			a9 00		       lda	#<DLLMEM
   4976  276ad			85 30		       sta	DPPL
   4977  276af
   4978  276af				   -	       ifconst	pokeysupport
   4979  276af				   -			; pokey support is compiled in, so try to detect it...
   4980  276af				   -	       jsr	detectpokeylocation
   4981  276af					       endif
   4982  276af
   4983  276af			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   4984  276b1			8d b9 01	       sta	port0control
   4985  276b4			8d ba 01	       sta	port1control
   4986  276b7
   4987  276b7							;Setup port A to read mode
   4988  276b7							;lda #$00
   4989  276b7							;sta SWCHA
   4990  276b7							;sta CTLSWA
   4991  276b7
   4992  276b7				   -	       ifconst	HSSUPPORT
   4993  276b7				   -	       ifconst	bankswitchmode
   4994  276b7				   -	       ifconst	included.hiscore.asm.bank
   4995  276b7				   -	       ifconst	MCPDEVCART
   4996  276b7				   -	       lda	#($18 | included.hiscore.asm.bank)
   4997  276b7				   -	       ifconst	dumpbankswitch
   4998  276b7				   -	       sta	dumpbankswitch
   4999  276b7				   -	       endif
   5000  276b7				   -	       sta	$3000
   5001  276b7				   -	       else
   5002  276b7				   -	       lda	#(included.hiscore.asm.bank)
   5003  276b7				   -	       ifconst	dumpbankswitch
   5004  276b7				   -	       sta	dumpbankswitch
   5005  276b7				   -	       endif
   5006  276b7				   -	       sta	$8000
   5007  276b7				   -	       endif
   5008  276b7				   -	       endif		; included.hiscore.asm.bank
   5009  276b7				   -	       endif		; bankswitchmode
   5010  276b7				   -			; try to detect HSC
   5011  276b7				   -	       jsr	detecthsc
   5012  276b7				   -	       and	#1
   5013  276b7				   -	       sta	hsdevice
   5014  276b7				   -skipHSCdetect
   5015  276b7				   -			; try to detect AtariVox eeprom
   5016  276b7				   -	       jsr	detectatarivoxeeprom
   5017  276b7				   -	       and	#2
   5018  276b7				   -	       ora	hsdevice
   5019  276b7				   -	       cmp	#3
   5020  276b7				   -	       bne	storeAinhsdevice
   5021  276b7				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5022  276b7				   -			; Later we should check each device's priority byte if set, instead, 
   5023  276b7				   -	       lda	#2
   5024  276b7				   -storeAinhsdevice
   5025  276b7				   -	       sta	hsdevice
   5026  276b7				   -	       lda	#$ff
   5027  276b7				   -	       sta	hsdifficulty
   5028  276b7				   -	       sta	hsgameslot
   5029  276b7				   -	       sta	hsnewscoreline
   5030  276b7					       endif		; HSSUPPORT
   5031  276b7
   5032  276b7				   -	       ifconst	AVOXVOICE
   5033  276b7				   -	       jsr	silenceavoxvoice
   5034  276b7					       endif
   5035  276b7
   5036  276b7				   -	       ifconst	RMT
   5037  276b7				   -	       ifconst	RMTVOLUME
   5038  276b7				   -	       lda	#$F0	; default to full RMT volume
   5039  276b7				   -	       sta	rmtvolume
   5040  276b7				   -	       ifconst	TIAVOLUME
   5041  276b7				   -	       sta	tiavolume
   5042  276b7				   -	       endif		; TIAVOLUME
   5043  276b7				   -	       endif		; RMTVOLUME
   5044  276b7					       else		; !RMT
   5045  276b7				   -	       ifconst	TIAVOLUME
   5046  276b7				   -	       lda	#$F0	; default to full TIA volume
   5047  276b7				   -	       sta	tiavolume
   5048  276b7					       endif		; TIAVOLUME
   5049  276b7					       endif		; RMT
   5050  276b7
   5051  276b7					       ifconst	bankswitchmode
   5052  276b7							; we need to switch to the first bank as a default. this needs to
   5053  276b7							; happen before DMA, in case there's a topscreenroutine in bank 0
   5054  276b7				   -	       ifconst	MCPDEVCART
   5055  276b7				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5056  276b7				   -	       ifconst	dumpbankswitch
   5057  276b7				   -	       sta	dumpbankswitch
   5058  276b7				   -	       endif
   5059  276b7				   -	       sta	$3000
   5060  276b7					       else
   5061  276b7			a9 00		       lda	#0
   5062  276b9				   -	       ifconst	dumpbankswitch
   5063  276b9				   -	       sta	dumpbankswitch
   5064  276b9					       endif
   5065  276b9			8d 00 80	       sta	$8000
   5066  276bc					       endif
   5067  276bc					       endif
   5068  276bc
   5069  276bc							; CTRL 76543210
   5070  276bc							; 7 colorburst kill
   5071  276bc							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5072  276bc							; 4 character width 1=2 byte chars, 0=1 byte chars
   5073  276bc							; 3 border control 0=background color border, 1=black border
   5074  276bc							; 2 kangaroo mode 0=transparency, 1=kangaroo
   5075  276bc							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5076  276bc
   5077  276bc				   -	       ifconst	DOUBLEWIDE
   5078  276bc				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5079  276bc					       else
   5080  276bc			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5081  276be					       endif
   5082  276be
   5083  276be			20 87 f5	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   5084  276c1
   5085  276c1			85 3c		       sta	CTRL
   5086  276c3			8d 07 21	       sta	sCTRL
   5087  276c6
   5088  276c6			20 c6 f4	       jsr	vblankresync
   5089  276c9
   5090  276c9			a2 01		       ldx	#1
   5091  276cb			20 3d f6	       jsr	settwobuttonmode
   5092  276ce			a2 00		       ldx	#0
   5093  276d0			20 3d f6	       jsr	settwobuttonmode
   5094  276d3
   5095  276d3					       ifnconst	.altgamestart
   5096  276d3			4c 00 80	       jmp	game
   5097  276d6				   -	       else
   5098  276d6				   -	       jmp	.altgamestart
   5099  276d6					       endif
   5100  276d6
   5101  276d6							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5102  276d6
   5103  276d6							;************** Setup DLL entries
   5104  276d6
   5105  276d6							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5106  276d6					       ifnconst	SCREENHEIGHT
   5107  276d6			00 c0	    WSCREENHEIGHT =	192
   5108  276d6				   -	       else
   5109  276d6				   -WSCREENHEIGHT =	SCREENHEIGHT
   5110  276d6					       endif
   5111  276d6
   5112  276d6				   -	       ifnconst	ZONEHEIGHT
   5113  276d6				   -WZONEHEIGHT =	16
   5114  276d6					       else
   5115  276d6			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   5116  276d6					       endif
   5117  276d6
   5118  276d6					       ifnconst	ZONECOUNT
   5119  276d6			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5120  276d6				   -	       else
   5121  276d6				   -WZONECOUNT =	ZONECOUNT
   5122  276d6					       endif
   5123  276d6
   5124  276d6							; top of the frame, non-visible lines. this is based on NTSC,
   5125  276d6							; but we add in extra NV lines at the end of the display to ensure
   5126  276d6							; our PAL friends can play the game without it crashing.
   5127  276d6			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   5128  276d6
   5129  276d6				   -	       ifnconst	DLMEMSTART
   5130  276d6				   -	       ifnconst	DOUBLEBUFFER
   5131  276d6				   -WDLMEMSTART =	$1880
   5132  276d6				   -	       else
   5133  276d6				   -WDLMEMSTART =	$18E0
   5134  276d6				   -	       endif		; DOUBLEBUFFER
   5135  276d6					       else
   5136  276d6			40 00	    WDLMEMSTART =	DLMEMSTART
   5137  276d6					       endif
   5138  276d6
   5139  276d6				   -	       ifnconst	DLMEMEND
   5140  276d6				   -	       ifconst	EXTRADLMEMORY
   5141  276d6				   -WDLMEMEND  =	$23FF
   5142  276d6				   -	       else
   5143  276d6				   -WDLMEMEND  =	$1FFF
   5144  276d6				   -	       endif
   5145  276d6					       else
   5146  276d6			7f ff	    WDLMEMEND  =	DLMEMEND
   5147  276d6					       endif
   5148  276d6
   5149  276d6
   5150  276d6			40 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   5151  276d6
   5152  276d6				   -	       ifnconst	DOUBLEBUFFER
   5153  276d6				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5154  276d6					       else
   5155  276d6			02 a8	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5156  276d6					       endif
   5157  276d6
   5158  276d6			02 aa	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5159  276d6					       if	TDOUBLEBUFFEROFFSET > 255
   5160  276d6			00 ff	    DOUBLEBUFFEROFFSET =	255
   5161  276d6				   -	       else
   5162  276d6				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5163  276d6					       endif
   5164  276d6
   5165  276d6				   -	       ifconst	EXTRADLMEMORY
   5166  276d6				   -SECONDDLHALFSTART SET	$2300
   5167  276d6					       endif
   5168  276d6
   5169  276d6				    DLPOINTH
   5170  276d6				    DLINDEX    SET	0
   5171  276d6					       REPEAT	WZONECOUNT
   5172  276d6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276d6				   -	       ifconst	EXTRADLMEMORY
   5174  276d6				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276d6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276d6				   -	       else
   5177  276d6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276d6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276d6				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276d6				   -	       endif
   5181  276d6				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276d6					       endif		; EXTRADLMEMORY
   5183  276d6							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276d6			40		       .byte.b	>TMPMEMADDRESS
   5185  276d6				    DLINDEX    SET	DLINDEX + 1
   5171  276d6					       REPEND
   5172  276d6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276d7				   -	       ifconst	EXTRADLMEMORY
   5174  276d7				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276d7				   -	       else
   5177  276d7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276d7				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276d7				   -	       endif
   5181  276d7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276d7					       endif		; EXTRADLMEMORY
   5183  276d7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276d7			45		       .byte.b	>TMPMEMADDRESS
   5185  276d7				    DLINDEX    SET	DLINDEX + 1
   5171  276d7					       REPEND
   5172  276d7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276d8				   -	       ifconst	EXTRADLMEMORY
   5174  276d8				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276d8				   -	       else
   5177  276d8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276d8				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276d8				   -	       endif
   5181  276d8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276d8					       endif		; EXTRADLMEMORY
   5183  276d8							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276d8			4a		       .byte.b	>TMPMEMADDRESS
   5185  276d8				    DLINDEX    SET	DLINDEX + 1
   5171  276d8					       REPEND
   5172  276d8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276d9				   -	       ifconst	EXTRADLMEMORY
   5174  276d9				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276d9				   -	       else
   5177  276d9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276d9				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276d9				   -	       endif
   5181  276d9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276d9					       endif		; EXTRADLMEMORY
   5183  276d9							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276d9			50		       .byte.b	>TMPMEMADDRESS
   5185  276d9				    DLINDEX    SET	DLINDEX + 1
   5171  276d9					       REPEND
   5172  276d9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276da				   -	       ifconst	EXTRADLMEMORY
   5174  276da				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276da				   -	       else
   5177  276da				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276da				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276da				   -	       endif
   5181  276da				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276da					       endif		; EXTRADLMEMORY
   5183  276da							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276da			55		       .byte.b	>TMPMEMADDRESS
   5185  276da				    DLINDEX    SET	DLINDEX + 1
   5171  276da					       REPEND
   5172  276da				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276db				   -	       ifconst	EXTRADLMEMORY
   5174  276db				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276db				   -	       else
   5177  276db				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276db				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276db				   -	       endif
   5181  276db				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276db					       endif		; EXTRADLMEMORY
   5183  276db							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276db			5a		       .byte.b	>TMPMEMADDRESS
   5185  276db				    DLINDEX    SET	DLINDEX + 1
   5171  276db					       REPEND
   5172  276db				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276dc				   -	       ifconst	EXTRADLMEMORY
   5174  276dc				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276dc				   -	       else
   5177  276dc				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276dc				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276dc				   -	       endif
   5181  276dc				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276dc					       endif		; EXTRADLMEMORY
   5183  276dc							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276dc			60		       .byte.b	>TMPMEMADDRESS
   5185  276dc				    DLINDEX    SET	DLINDEX + 1
   5171  276dc					       REPEND
   5172  276dc				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276dd				   -	       ifconst	EXTRADLMEMORY
   5174  276dd				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276dd				   -	       else
   5177  276dd				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276dd				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276dd				   -	       endif
   5181  276dd				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276dd					       endif		; EXTRADLMEMORY
   5183  276dd							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276dd			65		       .byte.b	>TMPMEMADDRESS
   5185  276dd				    DLINDEX    SET	DLINDEX + 1
   5171  276dd					       REPEND
   5172  276dd				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276de				   -	       ifconst	EXTRADLMEMORY
   5174  276de				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276de				   -	       else
   5177  276de				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276de				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276de				   -	       endif
   5181  276de				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276de					       endif		; EXTRADLMEMORY
   5183  276de							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276de			6a		       .byte.b	>TMPMEMADDRESS
   5185  276de				    DLINDEX    SET	DLINDEX + 1
   5171  276de					       REPEND
   5172  276de				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276df				   -	       ifconst	EXTRADLMEMORY
   5174  276df				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276df				   -	       else
   5177  276df				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276df				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276df				   -	       endif
   5181  276df				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276df					       endif		; EXTRADLMEMORY
   5183  276df							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276df			70		       .byte.b	>TMPMEMADDRESS
   5185  276df				    DLINDEX    SET	DLINDEX + 1
   5171  276df					       REPEND
   5172  276df				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276e0				   -	       ifconst	EXTRADLMEMORY
   5174  276e0				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276e0				   -	       else
   5177  276e0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276e0				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276e0				   -	       endif
   5181  276e0				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276e0					       endif		; EXTRADLMEMORY
   5183  276e0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276e0			75		       .byte.b	>TMPMEMADDRESS
   5185  276e0				    DLINDEX    SET	DLINDEX + 1
   5171  276e0					       REPEND
   5172  276e0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5173  276e1				   -	       ifconst	EXTRADLMEMORY
   5174  276e1				   -	       if	TMPMEMADDRESS > $1FFF
   5175  276e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5176  276e1				   -	       else
   5177  276e1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5178  276e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5179  276e1				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5180  276e1				   -	       endif
   5181  276e1				   -	       endif		; TMPMEMADDRESS > $1FFF
   5182  276e1					       endif		; EXTRADLMEMORY
   5183  276e1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5184  276e1			7a		       .byte.b	>TMPMEMADDRESS
   5185  276e1				    DLINDEX    SET	DLINDEX + 1
   5186  276e2					       REPEND
   5187  276e2
   5188  276e2				   -	       ifconst	EXTRADLMEMORY
   5189  276e2				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5190  276e2					       endif
   5191  276e2
   5192  276e2
   5193  276e2				    DLPOINTL
   5194  276e2				    DLINDEX    SET	0
   5195  276e2					       REPEAT	WZONECOUNT
   5196  276e2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e2				   -	       ifconst	EXTRADLMEMORY
   5198  276e2				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e2				   -	       else
   5201  276e2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e2				   -	       endif
   5204  276e2				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e2					       endif		; EXTRADLMEMORY
   5206  276e2			00		       .byte.b	<TMPMEMADDRESS
   5207  276e2				    DLINDEX    SET	DLINDEX + 1
   5195  276e2					       REPEND
   5196  276e2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e3				   -	       ifconst	EXTRADLMEMORY
   5198  276e3				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e3				   -	       else
   5201  276e3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e3				   -	       endif
   5204  276e3				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e3					       endif		; EXTRADLMEMORY
   5206  276e3			55		       .byte.b	<TMPMEMADDRESS
   5207  276e3				    DLINDEX    SET	DLINDEX + 1
   5195  276e3					       REPEND
   5196  276e3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e4				   -	       ifconst	EXTRADLMEMORY
   5198  276e4				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e4				   -	       else
   5201  276e4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e4				   -	       endif
   5204  276e4				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e4					       endif		; EXTRADLMEMORY
   5206  276e4			aa		       .byte.b	<TMPMEMADDRESS
   5207  276e4				    DLINDEX    SET	DLINDEX + 1
   5195  276e4					       REPEND
   5196  276e4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e5				   -	       ifconst	EXTRADLMEMORY
   5198  276e5				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e5				   -	       else
   5201  276e5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e5				   -	       endif
   5204  276e5				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e5					       endif		; EXTRADLMEMORY
   5206  276e5			00		       .byte.b	<TMPMEMADDRESS
   5207  276e5				    DLINDEX    SET	DLINDEX + 1
   5195  276e5					       REPEND
   5196  276e5				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e6				   -	       ifconst	EXTRADLMEMORY
   5198  276e6				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e6				   -	       else
   5201  276e6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e6				   -	       endif
   5204  276e6				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e6					       endif		; EXTRADLMEMORY
   5206  276e6			55		       .byte.b	<TMPMEMADDRESS
   5207  276e6				    DLINDEX    SET	DLINDEX + 1
   5195  276e6					       REPEND
   5196  276e6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e7				   -	       ifconst	EXTRADLMEMORY
   5198  276e7				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e7				   -	       else
   5201  276e7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e7				   -	       endif
   5204  276e7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e7					       endif		; EXTRADLMEMORY
   5206  276e7			aa		       .byte.b	<TMPMEMADDRESS
   5207  276e7				    DLINDEX    SET	DLINDEX + 1
   5195  276e7					       REPEND
   5196  276e7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e8				   -	       ifconst	EXTRADLMEMORY
   5198  276e8				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e8				   -	       else
   5201  276e8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e8				   -	       endif
   5204  276e8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e8					       endif		; EXTRADLMEMORY
   5206  276e8			00		       .byte.b	<TMPMEMADDRESS
   5207  276e8				    DLINDEX    SET	DLINDEX + 1
   5195  276e8					       REPEND
   5196  276e8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276e9				   -	       ifconst	EXTRADLMEMORY
   5198  276e9				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276e9				   -	       else
   5201  276e9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276e9				   -	       endif
   5204  276e9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276e9					       endif		; EXTRADLMEMORY
   5206  276e9			55		       .byte.b	<TMPMEMADDRESS
   5207  276e9				    DLINDEX    SET	DLINDEX + 1
   5195  276e9					       REPEND
   5196  276e9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276ea				   -	       ifconst	EXTRADLMEMORY
   5198  276ea				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276ea				   -	       else
   5201  276ea				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276ea				   -	       endif
   5204  276ea				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276ea					       endif		; EXTRADLMEMORY
   5206  276ea			aa		       .byte.b	<TMPMEMADDRESS
   5207  276ea				    DLINDEX    SET	DLINDEX + 1
   5195  276ea					       REPEND
   5196  276ea				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276eb				   -	       ifconst	EXTRADLMEMORY
   5198  276eb				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276eb				   -	       else
   5201  276eb				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276eb				   -	       endif
   5204  276eb				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276eb					       endif		; EXTRADLMEMORY
   5206  276eb			00		       .byte.b	<TMPMEMADDRESS
   5207  276eb				    DLINDEX    SET	DLINDEX + 1
   5195  276eb					       REPEND
   5196  276eb				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276ec				   -	       ifconst	EXTRADLMEMORY
   5198  276ec				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276ec				   -	       else
   5201  276ec				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276ec				   -	       endif
   5204  276ec				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276ec					       endif		; EXTRADLMEMORY
   5206  276ec			55		       .byte.b	<TMPMEMADDRESS
   5207  276ec				    DLINDEX    SET	DLINDEX + 1
   5195  276ec					       REPEND
   5196  276ec				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5197  276ed				   -	       ifconst	EXTRADLMEMORY
   5198  276ed				   -	       if	TMPMEMADDRESS > $1FFF
   5199  276ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5200  276ed				   -	       else
   5201  276ed				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5202  276ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5203  276ed				   -	       endif
   5204  276ed				   -	       endif		; TMPMEMADDRESS > $1FFF
   5205  276ed					       endif		; EXTRADLMEMORY
   5206  276ed			aa		       .byte.b	<TMPMEMADDRESS
   5207  276ed				    DLINDEX    SET	DLINDEX + 1
   5208  276ee					       REPEND
   5209  276ee
   5210  276ee
   5211  276ee				    DLINDEX    SET	0
   5212  276ee					       REPEAT	WZONECOUNT
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5212  276ee					       REPEND
   5213  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5214  276ee				   -	       ifconst	EXTRADLMEMORY
   5215  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5216  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5217  276ee				   -	       else
   5218  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5219  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5220  276ee				   -	       endif
   5221  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5222  276ee					       endif		; EXTRADLMEMORY
   5223  276ee
   5224  276ee			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   5225  276ee
   5226  276ee				    DLINDEX    SET	DLINDEX + 1
   5227  276ee					       REPEND
   5228  276ee
   5229  276ee
     $4000 to $7fff used as zone memory, allowing 136 display objects per zone.
   5230  276ee					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5231  276ee
   5232  276ee				    DLHEIGHT
   5233  276ee					       REPEAT	WZONECOUNT
   5234  276ee			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276ee					       REPEND
   5234  276ef			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276ef					       REPEND
   5234  276f0			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f0					       REPEND
   5234  276f1			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f1					       REPEND
   5234  276f2			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f2					       REPEND
   5234  276f3			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f3					       REPEND
   5234  276f4			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f4					       REPEND
   5234  276f5			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f5					       REPEND
   5234  276f6			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f6					       REPEND
   5234  276f7			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f7					       REPEND
   5234  276f8			0f		       .byte.b	(WZONEHEIGHT-1)
   5233  276f8					       REPEND
   5234  276f9			0f		       .byte.b	(WZONEHEIGHT-1)
   5235  276fa					       REPEND
   5236  276fa
   5237  276fa							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5238  276fa
   5239  276fa							; a simple guard, than ensures the 7800basic code hasn't
   5240  276fa							; spilled into the encryption area...
     2180 bytes left in the 7800basic reserved area.
   5241  276fa					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5242  276fa				   -	       if	(*>$FF7D)
   5243  276fa				   -	       ERR		; abort the assembly
   5244  276fa					       endif
   5245  276fa							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5246  276fa
   5247  276fa				   -	       ifconst	DEV
   5248  276fa				   -	       ifnconst	ZONEHEIGHT
   5249  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5250  276fa				   -	       else
   5251  276fa				   -	       if	ZONEHEIGHT = 8
   5252  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5253  276fa				   -	       else
   5254  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5255  276fa				   -	       endif
   5256  276fa				   -	       endif
   5257  276fa					       endif
   5258  276fa
   5259  276fa				   -	       if	START_OF_ROM = .
   5260  276fa				   -	       .byte	0
   5261  276fa					       endif
   5262  276fa				    START_OF_ROM SET	0
   5263  276fa
   5264  276fa							; FF7E/FF7F contains the 7800basic crc checksum word
   5265  276fa
   5266  276fa							; FF80 - FFF7 contains the 7800 encryption key 
   5267  276fa
   5268  276fa				   -	       ifnconst	bankswitchmode
   5269  276fa				   -	       ORG	$FFF8
   5270  276fa					       else
   5271  276fa					       ifconst	ROM128K
   5272  27ff8					       ORG	$27FF8
   5273  27ff8					       RORG	$FFF8
   5274  27ff8					       endif
   5275  27ff8				   -	       ifconst	ROM144K
   5276  27ff8				   -	       ORG	$27FF8
   5277  27ff8				   -	       RORG	$FFF8
   5278  27ff8					       endif
   5279  27ff8				   -	       ifconst	ROM256K
   5280  27ff8				   -	       ORG	$47FF8
   5281  27ff8				   -	       RORG	$FFF8
   5282  27ff8					       endif
   5283  27ff8				   -	       ifconst	ROM272K
   5284  27ff8				   -	       ORG	$47FF8
   5285  27ff8				   -	       RORG	$FFF8
   5286  27ff8					       endif
   5287  27ff8				   -	       ifconst	ROM512K
   5288  27ff8				   -	       ORG	$87FF8
   5289  27ff8				   -	       RORG	$FFF8
   5290  27ff8					       endif
   5291  27ff8				   -	       ifconst	ROM528K
   5292  27ff8				   -	       ORG	$87FF8
   5293  27ff8				   -	       RORG	$FFF8
   5294  27ff8					       endif
   5295  27ff8					       endif
   5296  27ff8
   5297  27ff8
   5298  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   5299  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5300  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5301  27ffa
   5302  27ffa							;Vectors
   5303  27ffa			00 f0		       .word.w	NMI
   5304  27ffc			53 f6		       .word.w	START
   5305  27ffe			67 f0		       .word.w	IRQ
   5306  28000
