------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}
    273  28000 ????			    .Palette   SET	{2}	; constant
    274  28000 ????			    .SpriteX   SET	{3}	; variable
    275  28000 ????			    .SpriteY   SET	{4}	; variable
    276  28000 ????			    .ByteOffset SET	{5}	; variable 
    277  28000 ????
    278  28000 ????				       lda	.SpriteY
    279  28000 ????				       lsr
    280  28000 ????				       lsr
    281  28000 ????				       asr	#%11111110	; ensure carry is clear
    282  28000 ????				       if	WZONEHEIGHT = 16
    283  28000 ????				       asr	#%11111110	; ensure carry is clear
    284  28000 ????				       endif
    285  28000 ????
    286  28000 ????				       tax
    287  28000 ????
    288  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  28000 ????				       sta	dlpnt
    290  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  28000 ????				       sta	dlpnt+1
    292  28000 ????
    293  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  28000 ????
    295  28000 ????				       lda	.ByteOffset
    296  28000 ????				       if	{1}_width = 2
    297  28000 ????				       asl
    298  28000 ????				       endif
    299  28000 ????				       if	{1}_width = 3
    300  28000 ????				       asl
    301  28000 ????				       adc	.ByteOffset
    302  28000 ????				       endif
    303  28000 ????				       if	{1}_width = 4
    304  28000 ????				       asl
    305  28000 ????				       asl
    306  28000 ????				       endif
    307  28000 ????				       if	{1}_width = 5
    308  28000 ????				       asl
    309  28000 ????				       asl
    310  28000 ????				       adc	.ByteOffset
    311  28000 ????				       endif
    312  28000 ????				       if	{1}_width = 6
    313  28000 ????				       asl
    314  28000 ????				       adc	.ByteOffset
    315  28000 ????				       asl
    316  28000 ????				       endif
    317  28000 ????				       if	{1}_width = 7
    318  28000 ????				       asl
    319  28000 ????				       adc	.ByteOffset
    320  28000 ????				       asl
    321  28000 ????				       adc	.ByteOffset
    322  28000 ????				       endif
    323  28000 ????				       if	{1}_width = 8
    324  28000 ????				       asl
    325  28000 ????				       asl
    326  28000 ????				       asl
    327  28000 ????				       endif
    328  28000 ????				       if	{1}_width = 9
    329  28000 ????				       asl
    330  28000 ????				       asl
    331  28000 ????				       asl
    332  28000 ????				       adc	.ByteOffset
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 10
    335  28000 ????				       asl
    336  28000 ????				       asl
    337  28000 ????				       adc	.ByteOffset
    338  28000 ????				       asl
    339  28000 ????				       endif
    340  28000 ????				       if	{1}_width = 11
    341  28000 ????				       asl
    342  28000 ????				       asl
    343  28000 ????				       adc	.ByteOffset
    344  28000 ????				       asl
    345  28000 ????				       adc	.ByteOffset
    346  28000 ????				       endif
    347  28000 ????				       if	{1}_width = 12
    348  28000 ????				       asl
    349  28000 ????				       adc	.ByteOffset
    350  28000 ????				       asl
    351  28000 ????				       asl
    352  28000 ????				       endif
    353  28000 ????				       if	{1}_width = 13
    354  28000 ????				       asl
    355  28000 ????				       adc	.ByteOffset
    356  28000 ????				       asl
    357  28000 ????				       asl
    358  28000 ????				       adc	.ByteOffset
    359  28000 ????				       endif
    360  28000 ????				       if	{1}_width = 14
    361  28000 ????				       asl
    362  28000 ????				       adc	.ByteOffset
    363  28000 ????				       asl
    364  28000 ????				       adc	.ByteOffset
    365  28000 ????				       asl
    366  28000 ????				       endif
    367  28000 ????
    368  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  28000 ????
    371  28000 ????				       iny
    372  28000 ????
    373  28000 ????				       lda	#({1}_mode | %01000000)
    374  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  28000 ????
    376  28000 ????				       iny
    377  28000 ????
    378  28000 ????				       lda	.SpriteY
    379  28000 ????				       and	#(WZONEHEIGHT - 1)
    380  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  28000 ????				       ora	#>.GFXLabel
    382  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  28000 ????
    384  28000 ????				       iny
    385  28000 ????
    386  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  28000 ????
    389  28000 ????				       iny
    390  28000 ????
    391  28000 ????				       lda	.SpriteX
    392  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  28000 ????
    394  28000 ????				       iny
    395  28000 ????				       sty	dlend,x
    396  28000 ????
    397  28000 ????				       ifconst	ALWAYSTERMINATE
    398  28000 ????				       iny
    399  28000 ????				       lda	#0
    400  28000 ????				       sta	(dlpnt),y
    401  28000 ????				       endif
    402  28000 ????
    403  28000 ????				       bcc	.PLOTSPRITEend
    404  28000 ????
    405  28000 ????				       inx		; next zone
    406  28000 ????
    407  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  28000 ????				       sta	dlpnt
    409  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  28000 ????				       sta	dlpnt+1
    411  28000 ????
    412  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  28000 ????
    414  28000 ????				       lda	.ByteOffset
    415  28000 ????				       if	{1}_width = 1
    416  28000 ????				       clc
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 2
    419  28000 ????				       asl		; carry clear
    420  28000 ????				       endif
    421  28000 ????				       if	{1}_width = 3
    422  28000 ????				       asl		; carry clear
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       if	{1}_width = 4
    426  28000 ????				       asl		; carry clear
    427  28000 ????				       asl
    428  28000 ????				       endif
    429  28000 ????				       if	{1}_width = 5
    430  28000 ????				       asl		; carry clear
    431  28000 ????				       asl
    432  28000 ????				       adc	.ByteOffset
    433  28000 ????				       endif
    434  28000 ????				       if	{1}_width = 6
    435  28000 ????				       asl		; carry clear
    436  28000 ????				       adc	.ByteOffset
    437  28000 ????				       asl
    438  28000 ????				       endif
    439  28000 ????				       if	{1}_width = 7
    440  28000 ????				       asl		; carry clear
    441  28000 ????				       adc	.ByteOffset
    442  28000 ????				       asl
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 8
    445  28000 ????				       asl		; carry clear
    446  28000 ????				       asl
    447  28000 ????				       asl
    448  28000 ????				       endif
    449  28000 ????				       if	{1}_width = 9
    450  28000 ????				       asl		; carry clear
    451  28000 ????				       asl
    452  28000 ????				       asl
    453  28000 ????				       adc	.ByteOffset
    454  28000 ????				       endif
    455  28000 ????				       if	{1}_width = 10
    456  28000 ????				       asl		; carry clear
    457  28000 ????				       asl
    458  28000 ????				       adc	.ByteOffset
    459  28000 ????				       asl
    460  28000 ????				       endif
    461  28000 ????				       if	{1}_width = 11
    462  28000 ????				       asl		; carry clear
    463  28000 ????				       asl
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       asl
    466  28000 ????				       adc	.ByteOffset
    467  28000 ????				       endif
    468  28000 ????				       if	{1}_width = 12
    469  28000 ????				       asl		; carry clear
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       asl
    472  28000 ????				       asl
    473  28000 ????				       endif
    474  28000 ????				       if	{1}_width = 13
    475  28000 ????				       asl		; carry clear
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       asl
    478  28000 ????				       asl
    479  28000 ????				       adc	.ByteOffset
    480  28000 ????				       endif
    481  28000 ????				       if	{1}_width = 14
    482  28000 ????				       asl		; carry clear
    483  28000 ????				       adc	.ByteOffset
    484  28000 ????				       asl
    485  28000 ????				       adc	.ByteOffset
    486  28000 ????				       asl
    487  28000 ????				       endif
    488  28000 ????
    489  28000 ????				       adc	#<.GFXLabel
    490  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  28000 ????
    492  28000 ????				       iny
    493  28000 ????
    494  28000 ????				       lda	#({1}_mode | %01000000)
    495  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  28000 ????
    497  28000 ????				       iny
    498  28000 ????
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       and	#(WZONEHEIGHT - 1)
    501  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  28000 ????
    504  28000 ????				       iny
    505  28000 ????
    506  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  28000 ????
    509  28000 ????				       iny
    510  28000 ????
    511  28000 ????				       lda	.SpriteX
    512  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  28000 ????
    514  28000 ????				       iny
    515  28000 ????				       sty	dlend,x
    516  28000 ????
    517  28000 ????				       ifconst	ALWAYSTERMINATE
    518  28000 ????				       iny
    519  28000 ????				       lda	#0
    520  28000 ????				       sta	(dlpnt),y
    521  28000 ????				       endif
    522  28000 ????
    523  28000 ????			    .PLOTSPRITEend
    524  28000 ????				       ENDM
    525  28000 ????
    526  28000 ????				       MAC	sizeof
    527  28000 ????
    528  28000 ????						; echo's the size difference between the current address and the
    529  28000 ????						; a label that was passed as an argument. This is a quick way to
    530  28000 ????						; determine the size of a structure.
    531  28000 ????
    532  28000 ????			    .NAME      SETSTR	{1}
    533  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  28000 ????				       ENDM
    535  28000 ????
    536  28000 ????						;
    537  28000 ????						; speakjet.inc
    538  28000 ????						;
    539  28000 ????						;
    540  28000 ????						; AtariVox Speech Synth Driver
    541  28000 ????						;
    542  28000 ????						; By Alex Herbert, 2004
    543  28000 ????						;
    544  28000 ????
    545  28000 ????
    546  28000 ????
    547  28000 ????
    548  28000 ????						; Constants
    549  28000 ????
    550  28000 ????
    551  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  28000 ????
    554  28000 ????
    555  28000 ????
    556  28000 ????						; Macros
    557  28000 ????
    558  28000 ????				       mac	spkout
    559  28000 ????
    560  28000 ????						; check buffer-full status
    561  28000 ????				       lda	SWCHA
    562  28000 ????				       and	#SERIAL_RDYMASK
    563  28000 ????				       beq	.speech_done
    564  28000 ????
    565  28000 ????						; get next speech byte
    566  28000 ????				       ldy	#$00
    567  28000 ????				       lda	(speech_addr),y
    568  28000 ????
    569  28000 ????						; invert data and check for end of string
    570  28000 ????				       eor	#$ff
    571  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  28000 ????				       beq	.speech_done
    573  28000 ????				       sta	{1}
    574  28000 ????
    575  28000 ????						; increment speech pointer
    576  28000 ????				       inc	speech_addr
    577  28000 ????				       bne	.incaddr_skip
    578  28000 ????				       inc	speech_addr+1
    579  28000 ????			    .incaddr_skip
    580  28000 ????
    581  28000 ????						; output byte as serial data
    582  28000 ????
    583  28000 ????				       sec		; start bit
    584  28000 ????			    .byteout_loop
    585  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  28000 ????				       lda	SWACNT	; 4
    587  28000 ????				       and	#$fe	; 2 6
    588  28000 ????				       adc	#$00	; 2 8
    589  28000 ????				       sta	SWACNT	; 4 12
    590  28000 ????
    591  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  28000 ????				       cpy	#$09	; 2 14
    593  28000 ????				       beq	.speech_done	; 2 16
    594  28000 ????				       iny		; 2 18
    595  28000 ????
    596  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  28000 ????						; to match the original baud rate...
    598  28000 ????						;ldx	  #$07 ; 2600
    599  28000 ????				       ldx	#$0D
    600  28000 ????
    601  28000 ????			    .delay_loop
    602  28000 ????				       dex		; 
    603  28000 ????				       bne	.delay_loop	; 36 54
    604  28000 ????
    605  28000 ????						; shift next data bit into carry
    606  28000 ????				       lsr	{1}	; 5 59
    607  28000 ????
    608  28000 ????						; and loop (branch always taken)
    609  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  28000 ????
    611  28000 ????			    .speech_done
    612  28000 ????
    613  28000 ????				       endm
    614  28000 ????
    615  28000 ????
    616  28000 ????				       mac	speak
    617  28000 ????
    618  28000 ????				       lda	#<{1}
    619  28000 ????				       sta	speech_addr
    620  28000 ????				       lda	#>{1}
    621  28000 ????				       sta	speech_addr+1
    622  28000 ????
    623  28000 ????				       endm
    624  28000 ????
    625  28000 ????
    626  28000 ????
    627  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  28000 ????
    629  28000 ????				       processor	6502
    630  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????
    123  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 80	    title01_mode =	$80
      4  28000 ????		00 10	    title01_width_twoscompliment =	$10
      5  28000 ????		00 30	    title01_width =	$30
      6  28000 ????		00 80	    title00_mode =	$80
      7  28000 ????		00 10	    title00_width_twoscompliment =	$10
      8  28000 ????		00 30	    title00_width =	$30
      9  28000 ????		00 00	    player4_mode =	$00
     10  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
     11  28000 ????		00 04	    player4_width =	$04
     12  28000 ????		00 00	    player3_mode =	$00
     13  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
     14  28000 ????		00 04	    player3_width =	$04
     15  28000 ????		00 00	    player2_mode =	$00
     16  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     17  28000 ????		00 04	    player2_width =	$04
     18  28000 ????		00 00	    player1_mode =	$00
     19  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     20  28000 ????		00 04	    player1_width =	$04
     21  28000 ????		00 00	    font_mode  =	$00
     22  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     23  28000 ????		00 35	    font_width =	$35
     24  28000 ????		01 48	    playerAnimWait =	var8
     25  28000 ????
     26  28000 ????		01 47	    playerAnimFrame =	var7
     27  28000 ????
     28  28000 ????		01 46	    playerY    =	var6
     29  28000 ????
     30  28000 ????		01 45	    playerX    =	var5
     31  28000 ????
     32  28000 ????		01 44	    score      =	var4
     33  28000 ????
     34  28000 ????		01 43	    lives      =	var3
     35  28000 ????
     36  28000 ????		01 42	    wait       =	var2
     37  28000 ????
     38  28000 ????		01 41	    bgColor    =	var1
     39  28000 ????
     40  28000 ????		00 a8	    title_color12 =	title00_color12
     41  28000 ????		00 a9	    title_color11 =	title00_color11
     42  28000 ????		00 a7	    title_color10 =	title00_color10
     43  28000 ????		00 a4	    title_color9 =	title00_color9
     44  28000 ????		00 93	    title_color8 =	title00_color8
     45  28000 ????		00 ab	    title_color7 =	title00_color7
     46  28000 ????		00 92	    title_color6 =	title00_color6
     47  28000 ????		00 aa	    title_color5 =	title00_color5
     48  28000 ????		00 91	    title_color4 =	title00_color4
     49  28000 ????		00 a6	    title_color3 =	title00_color3
     50  28000 ????		00 a5	    title_color2 =	title00_color2
     51  28000 ????		00 91	    title_color1 =	title00_color1
     52  28000 ????		00 00	    title01_color15 =	0
     53  28000 ????		00 00	    title01_color14 =	0
     54  28000 ????		00 00	    title01_color13 =	0
     55  28000 ????		00 a8	    title01_color12 =	$a8
     56  28000 ????		00 a9	    title01_color11 =	$a9
     57  28000 ????		00 a7	    title01_color10 =	$a7
     58  28000 ????		00 a4	    title01_color9 =	$a4
     59  28000 ????		00 93	    title01_color8 =	$93
     60  28000 ????		00 ab	    title01_color7 =	$ab
     61  28000 ????		00 92	    title01_color6 =	$92
     62  28000 ????		00 aa	    title01_color5 =	$aa
     63  28000 ????		00 91	    title01_color4 =	$91
     64  28000 ????		00 a6	    title01_color3 =	$a6
     65  28000 ????		00 a5	    title01_color2 =	$a5
     66  28000 ????		00 91	    title01_color1 =	$91
     67  28000 ????		00 00	    title01_color0 =	$00
     68  28000 ????		00 00	    title00_color15 =	0
     69  28000 ????		00 00	    title00_color14 =	0
     70  28000 ????		00 00	    title00_color13 =	0
     71  28000 ????		00 a8	    title00_color12 =	$a8
     72  28000 ????		00 a9	    title00_color11 =	$a9
     73  28000 ????		00 a7	    title00_color10 =	$a7
     74  28000 ????		00 a4	    title00_color9 =	$a4
     75  28000 ????		00 93	    title00_color8 =	$93
     76  28000 ????		00 ab	    title00_color7 =	$ab
     77  28000 ????		00 92	    title00_color6 =	$92
     78  28000 ????		00 aa	    title00_color5 =	$aa
     79  28000 ????		00 91	    title00_color4 =	$91
     80  28000 ????		00 a6	    title00_color3 =	$a6
     81  28000 ????		00 a5	    title00_color2 =	$a5
     82  28000 ????		00 91	    title00_color1 =	$91
     83  28000 ????		00 00	    title00_color0 =	$00
     84  28000 ????		00 00	    player4_color3 =	0
     85  28000 ????		00 44	    player4_color2 =	$44
     86  28000 ????		00 0d	    player4_color1 =	$0d
     87  28000 ????		00 00	    player4_color0 =	$00
     88  28000 ????		00 07	    player3_color3 =	$07
     89  28000 ????		00 44	    player3_color2 =	$44
     90  28000 ????		00 0d	    player3_color1 =	$0d
     91  28000 ????		00 00	    player3_color0 =	$00
     92  28000 ????		00 07	    player2_color3 =	$07
     93  28000 ????		00 44	    player2_color2 =	$44
     94  28000 ????		00 0d	    player2_color1 =	$0d
     95  28000 ????		00 00	    player2_color0 =	$00
     96  28000 ????		00 07	    player1_color3 =	$07
     97  28000 ????		00 44	    player1_color2 =	$44
     98  28000 ????		00 0d	    player1_color1 =	$0d
     99  28000 ????		00 00	    player1_color0 =	$00
    100  28000 ????		00 0f	    font_color1 =	$0f
    101  28000 ????		00 00	    font_color0 =	$00
    102  28000 ????		00 01	    DOUBLEBUFFER =	1
    103  28000 ????		00 01	    SGRAM      =	1
    104  28000 ????		00 08	    bankswitchmode =	8
    105  28000 ????		00 01	    ROM128K    =	1
    106  28000 ????		00 01	    plotvalueonscreen =	1
    107  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    ssCTRL     =	$2131
     63  28000 ????		21 32	    ssCHARBASE =	$2132
     64  28000 ????		21 33	    hsdisplaymode =	$2133
     65  28000 ????		21 34	    gamedifficulty =	$2134
     66  28000 ????		21 35	    hsinitialpos =	$2135
     67  28000 ????		21 36	    hsinitialhold =	$2136
     68  28000 ????		21 37	    hscursorx  =	$2137
     69  28000 ????		21 38	    hsjoydebounce =	$2138
     70  28000 ????		21 39	    hsswcha    =	$2139
     71  28000 ????		21 3a	    hsinpt1    =	$213A
     72  28000 ????		21 3b	    hscolorchaseindex =	$213B
     73  28000 ????		21 3c	    visibleDLLstart =	$213C
     74  28000 ????		21 3d	    overscanDLLstart =	$213D
     75  28000 ????		21 3e	    frameslost =	$213E
     76  28000 ????		21 3f	    hsreturn   =	$213F
     77  28000 ????
     78  28000 ????
     79  28000 ????		00 40	    rand       =	$40
     80  28000 ????		00 41	    rand16     =	$41
     81  28000 ????		00 42	    temp1      =	$42
     82  28000 ????		00 43	    temp2      =	$43
     83  28000 ????		00 44	    temp3      =	$44
     84  28000 ????		00 45	    temp4      =	$45
     85  28000 ????		00 46	    temp5      =	$46
     86  28000 ????		00 47	    temp6      =	$47
     87  28000 ????		00 48	    temp7      =	$48
     88  28000 ????		00 49	    temp8      =	$49
     89  28000 ????		00 4a	    temp9      =	$4a
     90  28000 ????
     91  28000 ????		00 4b	    pokeybase  =	$4b
     92  28000 ????		00 4b	    pokeybaselo =	$4b
     93  28000 ????		00 4c	    pokeybasehi =	$4c
     94  28000 ????
     95  28000 ????		00 4d	    visibleover =	$4d
     96  28000 ????
     97  28000 ????		00 4e	    sfx1pointlo =	$4e
     98  28000 ????		00 4f	    sfx2pointlo =	$4f
     99  28000 ????		00 50	    sfx1pointhi =	$50
    100  28000 ????		00 51	    sfx2pointhi =	$51
    101  28000 ????
    102  28000 ????		00 52	    sfx1priority =	$52
    103  28000 ????		00 53	    sfx2priority =	$53
    104  28000 ????		00 54	    sfx1poffset =	$54
    105  28000 ????		00 55	    sfx2poffset =	$55
    106  28000 ????
    107  28000 ????		00 56	    sfx1frames =	$56
    108  28000 ????		00 57	    sfx2frames =	$57
    109  28000 ????		00 58	    sfx1tick   =	$58
    110  28000 ????		00 59	    sfx2tick   =	$59
    111  28000 ????
    112  28000 ????		00 5a	    tempmath   =	$5a
    113  28000 ????
    114  28000 ????		00 5b	    pokey1pointlo =	$5b
    115  28000 ????		00 5c	    pokey1pointhi =	$5c
    116  28000 ????		00 5d	    pokey2pointlo =	$5d
    117  28000 ????		00 5e	    pokey2pointhi =	$5e
    118  28000 ????		00 5f	    pokey3pointlo =	$5f
    119  28000 ????		00 60	    pokey3pointhi =	$60
    120  28000 ????		00 61	    pokey4pointlo =	$61
    121  28000 ????		00 62	    pokey4pointhi =	$62
    122  28000 ????
    123  28000 ????		00 63	    dlpnt      =	$63	; to $64
    124  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    125  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    126  28000 ????
    127  28000 ????		00 9f	    speech_addr =	$9f
    128  28000 ????		00 a0	    speech_addr_hi =	$a0
    129  28000 ????
    130  28000 ????		00 a1	    HSGameTableLo =	$a1
    131  28000 ????		00 a2	    HSGameTableHi =	$a2
    132  28000 ????		00 a3	    HSVoxHi    =	$a3
    133  28000 ????		00 a4	    HSVoxLo    =	$a4
    134  28000 ????
    135  28000 ????						;channel pointers
    136  28000 ????
    137  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    138  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    139  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    140  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    141  28000 ????
    142  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    143  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    144  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    145  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    146  28000 ????
    147  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    148  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    149  28000 ????		00 af	    songchannel3layer3lo =	$aF
    150  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    151  28000 ????
    152  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    153  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    154  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    155  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    156  28000 ????
    157  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    158  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    159  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    160  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    161  28000 ????
    162  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    163  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    164  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    165  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    166  28000 ????
    167  28000 ????		00 bd	    songdatalo =	$bd
    168  28000 ????		00 be	    songdatahi =	$be
    169  28000 ????
    170  28000 ????		00 bf	    inactivechannelcount =	$bf
    171  28000 ????
    172  28000 ????		00 c0	    songchannel1transpose =	$c0
    173  28000 ????		00 c1	    songchannel2transpose =	$c1
    174  28000 ????		00 c2	    songchannel3transpose =	$c2
    175  28000 ????		00 c3	    songchannel4transpose =	$c3
    176  28000 ????
    177  28000 ????		00 c4	    songstackindex =	$c4
    178  28000 ????
    179  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  28000 ????
    184  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  28000 ????
    189  28000 ????		00 cd	    sfx1notedata =	$cd
    190  28000 ????		00 ce	    sfx2notedata =	$ce
    191  28000 ????
    192  28000 ????		00 cf	    songloops  =	$cf
    193  28000 ????
    194  28000 ????		00 d0	    songpointerlo =	$D0
    195  28000 ????		00 d1	    songpointerhi =	$D1
    196  28000 ????
    197  28000 ????		00 d2	    voxlock    =	$D2
    198  28000 ????		00 d3	    voxqueuesize =	$D3
    199  28000 ????
    200  28000 ????		00 d4	    vblankroutines =	$D4
    201  28000 ????
    202  28000 ????		00 d5	    doublebufferstate =	$D5
    203  28000 ????		00 d6	    doublebufferdloffset =	$D6
    204  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  28000 ????
    206  28000 ????		00 d8	    inttemp1   =	$D8
    207  28000 ????		00 d9	    inttemp2   =	$D9
    208  28000 ????		00 da	    inttemp3   =	$DA
    209  28000 ????		00 db	    inttemp4   =	$DB
    210  28000 ????		00 dc	    inttemp5   =	$DC
    211  28000 ????		00 dd	    inttemp6   =	$DD
    212  28000 ????
    213  28000 ????		00 de	    sfxschedulelock =	$DE
    214  28000 ????		00 df	    sfxschedulemissed =	$DF
    215  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  28000 ????		00 e2	    sfxpitchoffset =	$E2
    218  28000 ????		00 e3	    sfxnoteindex =	$E3
    219  28000 ????
    220  28000 ????		00 e4	    CTLSWAs    =	$E4
    221  28000 ????		00 e5	    CTLSWBs    =	$E5
    222  28000 ????
    223  28000 ????		00 e6	    A	       =	$e6
    224  28000 ????		00 e6	    a	       =	$e6
    225  28000 ????		00 e7	    B	       =	$e7
    226  28000 ????		00 e7	    b	       =	$e7
    227  28000 ????		00 e8	    C	       =	$e8
    228  28000 ????		00 e8	    c	       =	$e8
    229  28000 ????		00 e9	    D	       =	$e9
    230  28000 ????		00 e9	    d	       =	$e9
    231  28000 ????		00 ea	    E	       =	$ea
    232  28000 ????		00 ea	    e	       =	$ea
    233  28000 ????		00 eb	    F	       =	$eb
    234  28000 ????		00 eb	    f	       =	$eb
    235  28000 ????		00 ec	    G	       =	$ec
    236  28000 ????		00 ec	    g	       =	$ec
    237  28000 ????		00 ed	    H	       =	$ed
    238  28000 ????		00 ed	    h	       =	$ed
    239  28000 ????		00 ee	    I	       =	$ee
    240  28000 ????		00 ee	    i	       =	$ee
    241  28000 ????		00 ef	    J	       =	$ef
    242  28000 ????		00 ef	    j	       =	$ef
    243  28000 ????		00 f0	    K	       =	$f0
    244  28000 ????		00 f0	    k	       =	$f0
    245  28000 ????		00 f1	    L	       =	$f1
    246  28000 ????		00 f1	    l	       =	$f1
    247  28000 ????		00 f2	    M	       =	$f2
    248  28000 ????		00 f2	    m	       =	$f2
    249  28000 ????		00 f3	    N	       =	$f3
    250  28000 ????		00 f3	    n	       =	$f3
    251  28000 ????		00 f4	    O	       =	$f4
    252  28000 ????		00 f4	    o	       =	$f4
    253  28000 ????		00 f5	    P	       =	$f5
    254  28000 ????		00 f5	    p	       =	$f5
    255  28000 ????		00 f6	    Q	       =	$f6
    256  28000 ????		00 f6	    q	       =	$f6
    257  28000 ????		00 f7	    R	       =	$f7
    258  28000 ????		00 f7	    r	       =	$f7
    259  28000 ????		00 f8	    S	       =	$f8
    260  28000 ????		00 f8	    s	       =	$f8
    261  28000 ????		00 f9	    T	       =	$f9
    262  28000 ????		00 f9	    t	       =	$f9
    263  28000 ????		00 fa	    U	       =	$fa
    264  28000 ????		00 fa	    u	       =	$fa
    265  28000 ????		00 fb	    V	       =	$fb
    266  28000 ????		00 fb	    v	       =	$fb
    267  28000 ????		00 fc	    W	       =	$fc
    268  28000 ????		00 fc	    w	       =	$fc
    269  28000 ????		00 fd	    X	       =	$fd
    270  28000 ????		00 fd	    x	       =	$fd
    271  28000 ????		00 fe	    Y	       =	$fe
    272  28000 ????		00 fe	    y	       =	$fe
    273  28000 ????		00 ff	    Z	       =	$ff
    274  28000 ????		00 ff	    z	       =	$ff
    275  28000 ????
    276  28000 ????						; var0-var99 variables use the top of the stack
    277  28000 ????		01 40	    var0       =	$140
    278  28000 ????		01 41	    var1       =	$141
    279  28000 ????		01 42	    var2       =	$142
    280  28000 ????		01 43	    var3       =	$143
    281  28000 ????		01 44	    var4       =	$144
    282  28000 ????		01 45	    var5       =	$145
    283  28000 ????		01 46	    var6       =	$146
    284  28000 ????		01 47	    var7       =	$147
    285  28000 ????		01 48	    var8       =	$148
    286  28000 ????		01 49	    var9       =	$149
    287  28000 ????		01 4a	    var10      =	$14a
    288  28000 ????		01 4b	    var11      =	$14b
    289  28000 ????		01 4c	    var12      =	$14c
    290  28000 ????		01 4d	    var13      =	$14d
    291  28000 ????		01 4e	    var14      =	$14e
    292  28000 ????		01 4f	    var15      =	$14f
    293  28000 ????		01 50	    var16      =	$150
    294  28000 ????		01 51	    var17      =	$151
    295  28000 ????		01 52	    var18      =	$152
    296  28000 ????		01 53	    var19      =	$153
    297  28000 ????		01 54	    var20      =	$154
    298  28000 ????		01 55	    var21      =	$155
    299  28000 ????		01 56	    var22      =	$156
    300  28000 ????		01 57	    var23      =	$157
    301  28000 ????		01 58	    var24      =	$158
    302  28000 ????		01 59	    var25      =	$159
    303  28000 ????		01 5a	    var26      =	$15a
    304  28000 ????		01 5b	    var27      =	$15b
    305  28000 ????		01 5c	    var28      =	$15c
    306  28000 ????		01 5d	    var29      =	$15d
    307  28000 ????		01 5e	    var30      =	$15e
    308  28000 ????		01 5f	    var31      =	$15f
    309  28000 ????		01 60	    var32      =	$160
    310  28000 ????		01 61	    var33      =	$161
    311  28000 ????		01 62	    var34      =	$162
    312  28000 ????		01 63	    var35      =	$163
    313  28000 ????		01 64	    var36      =	$164
    314  28000 ????		01 65	    var37      =	$165
    315  28000 ????		01 66	    var38      =	$166
    316  28000 ????		01 67	    var39      =	$167
    317  28000 ????		01 68	    var40      =	$168
    318  28000 ????		01 69	    var41      =	$169
    319  28000 ????		01 6a	    var42      =	$16a
    320  28000 ????		01 6b	    var43      =	$16b
    321  28000 ????		01 6c	    var44      =	$16c
    322  28000 ????		01 6d	    var45      =	$16d
    323  28000 ????		01 6e	    var46      =	$16e
    324  28000 ????		01 6f	    var47      =	$16f
    325  28000 ????		01 70	    var48      =	$170
    326  28000 ????		01 71	    var49      =	$171
    327  28000 ????		01 72	    var50      =	$172
    328  28000 ????		01 73	    var51      =	$173
    329  28000 ????		01 74	    var52      =	$174
    330  28000 ????		01 75	    var53      =	$175
    331  28000 ????		01 76	    var54      =	$176
    332  28000 ????		01 77	    var55      =	$177
    333  28000 ????		01 78	    var56      =	$178
    334  28000 ????		01 79	    var57      =	$179
    335  28000 ????		01 7a	    var58      =	$17a
    336  28000 ????		01 7b	    var59      =	$17b
    337  28000 ????		01 7c	    var60      =	$17c
    338  28000 ????		01 7d	    var61      =	$17d
    339  28000 ????		01 7e	    var62      =	$17e
    340  28000 ????		01 7f	    var63      =	$17f
    341  28000 ????		01 80	    var64      =	$180
    342  28000 ????		01 81	    var65      =	$181
    343  28000 ????		01 82	    var66      =	$182
    344  28000 ????		01 83	    var67      =	$183
    345  28000 ????		01 84	    var68      =	$184
    346  28000 ????		01 85	    var69      =	$185
    347  28000 ????		01 86	    var70      =	$186
    348  28000 ????		01 87	    var71      =	$187
    349  28000 ????		01 88	    var72      =	$188
    350  28000 ????		01 89	    var73      =	$189
    351  28000 ????		01 8a	    var74      =	$18a
    352  28000 ????		01 8b	    var75      =	$18b
    353  28000 ????		01 8c	    var76      =	$18c
    354  28000 ????		01 8d	    var77      =	$18d
    355  28000 ????		01 8e	    var78      =	$18e
    356  28000 ????		01 8f	    var79      =	$18f
    357  28000 ????		01 90	    var80      =	$190
    358  28000 ????		01 91	    var81      =	$191
    359  28000 ????		01 92	    var82      =	$192
    360  28000 ????		01 93	    var83      =	$193
    361  28000 ????		01 94	    var84      =	$194
    362  28000 ????		01 95	    var85      =	$195
    363  28000 ????		01 96	    var86      =	$196
    364  28000 ????		01 97	    var87      =	$197
    365  28000 ????		01 98	    var88      =	$198
    366  28000 ????		01 99	    var89      =	$199
    367  28000 ????		01 9a	    var90      =	$19a
    368  28000 ????		01 9b	    var91      =	$19b
    369  28000 ????		01 9c	    var92      =	$19c
    370  28000 ????		01 9d	    var93      =	$19d
    371  28000 ????		01 9e	    var94      =	$19e
    372  28000 ????		01 9f	    var95      =	$19f
    373  28000 ????		01 a0	    var96      =	$1a0
    374  28000 ????		01 a1	    var97      =	$1a1
    375  28000 ????		01 a2	    var98      =	$1a2
    376  28000 ????		01 a3	    var99      =	$1a3
    377  28000 ????
    378 U01c4 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3					      ifconst	DOUBLEBUFFER
    395 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    396 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    397 U01b5					      endif
    398 U01b5
    399 U01b5		       00	   pausedisable DS	1	; $1B5
    400 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b7
    402 U01b7				  -	      ifconst	AVOXVOICE
    403 U01b7				  -avoxenable DS	1	; $1B7
    404 U01b7				  -tempavox   DS	1	; $1B8
    405 U01b7					      endif
    406 U01b7
    407 U01b7				  -	      ifconst	MUSICTRACKER
    408 U01b7				  -songtempo  DS	1	; $1B9
    409 U01b7				  -songtick   DS	1	; $1BA
    410 U01b7				  -
    411 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b7				  -
    416 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b7				  -
    421 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b7				  -
    426 U01b7				  -songchannel1busywait DS	1	; $1C7
    427 U01b7				  -songchannel2busywait DS	1	; $1C8
    428 U01b7				  -songchannel3busywait DS	1	; $1C9
    429 U01b7				  -songchannel4busywait DS	1	; $1CA
    430 U01b7				  -
    431 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b7					      endif
    436 U01b7
    437 U01b7		       00	   palframes  DS	1	; $1CF
    438 U01b8		       00	   palfastframe DS	1	; $1D0
    439 U01b9
    440 U01b9				  -	      ifconst	MOUSESUPPORT
    441 U01b9				  -port0resolution DS	1	; $1D1
    442 U01b9				  -port1resolution DS	1	; $1D2
    443 U01b9					      else
    444 U01b9				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b9				  -port0resolution DS	1	; $1D1
    446 U01b9				  -port1resolution DS	1	; $1D2
    447 U01b9					      endif
    448 U01b9					      endif
    449 U01b9
    450 U01b9		       00	   port0control DS	1	; $1D3
    451 U01ba		       00	   port1control DS	1	; $1D4
    452 U01bb
    453 U01bb							; port#control values...
    454 U01bb							;	1 = proline
    455 U01bb							;	2 = lightgun
    456 U01bb							;	3 = paddle
    457 U01bb							;	4 = trakball
    458 U01bb							;	5 = vcs joystick
    459 U01bb							;	6 = driving
    460 U01bb							;	7 = keypad
    461 U01bb							;	8 = st mouse/cx80
    462 U01bb							;	9 = amiga mouse
    463 U01bb							;     10 = atarivox
    464 U01bb
    465 U01bb							; controller 0 data...
    466 U01bb		       00	   paddleposition0 DS	1	; $1D5
    467 U01bb		       01 bb	   keypadmatrix0a =	paddleposition0
    468 U01bb		       01 bb	   drivingposition0 =	paddleposition0
    469 U01bb		       01 bb	   trakballx0 =	paddleposition0
    470 U01bb		       01 bb	   mousex0    =	paddleposition0
    471 U01bb		       01 bb	   lighttgunx0 =	paddleposition0
    472 U01bb		       01 bb	   snes2atari0lo =	paddleposition0
    473 U01bc
    474 U01bc							; controller 1 data...
    475 U01bc		       00	   paddleposition2 DS	1	; $1D6
    476 U01bc		       01 bc	   keypadmatrix1a =	paddleposition2
    477 U01bc		       01 bc	   drivingposition1 =	paddleposition2
    478 U01bc		       01 bc	   trakballx1 =	paddleposition2
    479 U01bc		       01 bc	   mousex1    =	paddleposition2
    480 U01bc		       01 bc	   lightgunx1 =	paddleposition2
    481 U01bc		       01 bc	   snes2atari1lo =	paddleposition2
    482 U01bd
    483 U01bd							; controller 0 altdata...
    484 U01bd		       00	   paddleposition1 DS	1	; $1D7
    485 U01bd		       01 bd	   keypadmatrix0b =	paddleposition1
    486 U01bd		       01 bd	   trakbally0 =	paddleposition1
    487 U01bd		       01 bd	   mousey0    =	paddleposition1
    488 U01bd		       01 bd	   lightguny0 =	paddleposition1
    489 U01bd		       01 bd	   snes2atari0hi =	paddleposition1
    490 U01be
    491 U01be							; controller 1 altdata...
    492 U01be		       00	   paddleposition3 DS	1	; $1D8
    493 U01be		       01 be	   keypadmatrix1b =	paddleposition3
    494 U01be		       01 be	   trakbally1 =	paddleposition3
    495 U01be		       01 be	   mousey1    =	paddleposition3
    496 U01be		       01 be	   lightguny1 =	paddleposition3
    497 U01be		       01 be	   snes2atari1hi =	paddleposition3
    498 U01bf
    499 U01bf							; controller state save. for trakball state+dir codes, rotary position codes
    500 U01bf		       00	   controller0statesave DS	1	; $1D9
    501 U01bf		       01 bf	   paddleprevious0 =	controller0statesave
    502 U01bf		       01 bf	   mousecodex0 =	controller0statesave
    503 U01bf		       01 bf	   trakballcodex0 =	controller0statesave
    504 U01bf		       01 bf	   keypadmatrix0c =	controller0statesave
    505 U01bf		       01 bf	   snesdetected0 =	controller0statesave
    506 U01c0
    507 U01c0		       00	   controller1statesave DS	1	; $1DA
    508 U01c0		       01 c0	   paddleprevious2 =	controller1statesave
    509 U01c0		       01 c0	   mousecodex1 =	controller1statesave
    510 U01c0		       01 c0	   trakballcodex1 =	controller1statesave
    511 U01c0		       01 c0	   keypadmatrix1c =	controller1statesave
    512 U01c0		       01 c0	   snesdetected1 =	controller1statesave
    513 U01c1
    514 U01c1		       00	   paddleprevious1 DS	1	; $1DB
    515 U01c1		       01 c1	   keypadmatrix0d =	paddleprevious1
    516 U01c1		       01 c1	   mousecodey0 =	paddleprevious1
    517 U01c1		       01 c1	   trakballcodey0 =	paddleprevious1
    518 U01c2
    519 U01c2		       00	   paddleprevious3 DS	1	; $1DC
    520 U01c2		       01 c2	   keypadmatrix1d =	paddleprevious3
    521 U01c2		       01 c2	   mousecodey1 =	paddleprevious3
    522 U01c2		       01 c2	   trakballcodey1 =	paddleprevious3
    523 U01c3
    524 U01c3				  -	      ifconst	pokeysupport
    525 U01c3				  -pokey1frames DS	1	; $1DD
    526 U01c3				  -pokey1tick DS	1	; $1DE
    527 U01c3				  -pokey2frames DS	1	; $1DF
    528 U01c3				  -pokey2tick DS	1	; $1E0
    529 U01c3				  -pokey3frames DS	1	; $1E1
    530 U01c3				  -pokey3tick DS	1	; $1E2
    531 U01c3				  -pokey4frames DS	1	; $1E3
    532 U01c3				  -pokey4tick DS	1	; $1E4
    533 U01c3				  -pokey1priority DS	1	; $1E5
    534 U01c3				  -pokey1offset DS	1	; $1E6
    535 U01c3				  -pokey2priority DS	1	; $1E7
    536 U01c3				  -pokey2offset DS	1	; $1E8
    537 U01c3				  -pokey3priority DS	1	; $1E9
    538 U01c3				  -pokey3offset DS	1	; $1EA
    539 U01c3				  -pokey4priority DS	1	; $1EB
    540 U01c3				  -pokey4offset DS	1	; $1EC
    541 U01c3					      endif
    542 U01c3
    543 U01c3				  -	      ifconst	pokeykeysupport
    544 U01c3				  -pokeylastkeycode DS	1
    545 U01c3				  -pokeykeycode DS	1
    546 U01c3				  -pokeykeydebounce DS	1
    547 U01c3					      endif
    548 U01c3
    549 U01c3				  -	      ifconst	RMT
    550 U01c3				  -rasterpause DS	1
    551 U01c3					      endif		; RMT
    552 U01c3				  -	      ifconst	RMTVOLUME
    553 U01c3				  -rmtvolume  DS	1
    554 U01c3					      endif		; RMTVOLUME
    555 U01c3				  -	      ifconst	TIAVOLUME
    556 U01c3				  -tiavolume  DS	1
    557 U01c3					      endif		; TIAVOLUME
    558 U01c3
    559 U01c3				  -	      ifconst	FOURBITFADE
    560 U01c3				  -fourbittemp1 DS	1
    561 U01c3				  -fourbitfadevalue DS	1
    562 U01c3				  -fourbittemp1int DS	1
    563 U01c3				  -fourbitfadevalueint DS	1
    564 U01c3					      endif		; FOURBITFADE
    565 U01c3
    566 U01c3				  -	      ifconst	SNES2ATARISUPPORT
    567 U01c3				  -snesport   DS	1
    568 U01c3					      endif
    569 U01c3
    570 U01c3				  -	      ifconst	KEYPADSUPPORT
    571 U01c3				  -keypadcounter DS	1
    572 U01c3					      endif
    573 U01c3
    574 U01c3							; see if we need an interrupthold byte...
    575 U01c3				   INTERRUPTNEEDED SET	0
    576 U01c3				  -	      ifconst	.topscreenroutine
    577 U01c3				  -INTERRUPTNEEDED SET	1
    578 U01c3					      endif
    579 U01c3				  -	      ifconst	.bottomscreenroutine
    580 U01c3				  -INTERRUPTNEEDED SET	1
    581 U01c3					      endif
    582 U01c3				  -	      ifconst	.userinterrupt
    583 U01c3				  -INTERRUPTNEEDED SET	1
    584 U01c3					      endif
    585 U01c3				  -	      if	INTERRUPTNEEDED = 1
    586 U01c3				  -interrupthold DS	1	; $1ED
    587 U01c3					      endif
    588 U01c3
    589 U01c3					      ifnconst	CANARYOFF
    590 U01c3		       00	   canary     DS	1	; $1EF
    591 U01c4					      endif
    592 U01c4
    593 U01c4
    594 U01c4				  -	      ifnconst	bankswitchmode
    595 U01c4				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    596 U01c4					      else
   stack allowance: 19 nested subroutines.
    597 U01c4					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    598 U01c4					      endif
    599 U01c4					      ifnconst	CANARYOFF
   the canary is situated at: $1c3
    600 U01c4					      echo	"  the canary is situated at:",[canary]
    601 U01c4				  -	      else
    602 U01c4				  -	      echo	"  the canary is disabled."
    603 U01c4					      endif
    604 U01c4
    605 U01c4							; $1EE - $1FF reserved for stack
    606 U01c4
    607  28000 ????				       SEG	"GAME"
    608  28000 ????
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 80	    title01_mode =	$80
      4  28000 ????		00 10	    title01_width_twoscompliment =	$10
      5  28000 ????		00 30	    title01_width =	$30
      6  28000 ????		00 80	    title00_mode =	$80
      7  28000 ????		00 10	    title00_width_twoscompliment =	$10
      8  28000 ????		00 30	    title00_width =	$30
      9  28000 ????		00 00	    player4_mode =	$00
     10  28000 ????		00 1c	    player4_width_twoscompliment =	$1c
     11  28000 ????		00 04	    player4_width =	$04
     12  28000 ????		00 00	    player3_mode =	$00
     13  28000 ????		00 1c	    player3_width_twoscompliment =	$1c
     14  28000 ????		00 04	    player3_width =	$04
     15  28000 ????		00 00	    player2_mode =	$00
     16  28000 ????		00 1c	    player2_width_twoscompliment =	$1c
     17  28000 ????		00 04	    player2_width =	$04
     18  28000 ????		00 00	    player1_mode =	$00
     19  28000 ????		00 1c	    player1_width_twoscompliment =	$1c
     20  28000 ????		00 04	    player1_width =	$04
     21  28000 ????		00 00	    font_mode  =	$00
     22  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     23  28000 ????		00 35	    font_width =	$35
     24  28000 ????		01 48	    playerAnimWait =	var8
     25  28000 ????
     26  28000 ????		01 47	    playerAnimFrame =	var7
     27  28000 ????
     28  28000 ????		01 46	    playerY    =	var6
     29  28000 ????
     30  28000 ????		01 45	    playerX    =	var5
     31  28000 ????
     32  28000 ????		01 44	    score      =	var4
     33  28000 ????
     34  28000 ????		01 43	    lives      =	var3
     35  28000 ????
     36  28000 ????		01 42	    wait       =	var2
     37  28000 ????
     38  28000 ????		01 41	    bgColor    =	var1
     39  28000 ????
     40  28000 ????		00 a8	    title_color12 =	title00_color12
     41  28000 ????		00 a9	    title_color11 =	title00_color11
     42  28000 ????		00 a7	    title_color10 =	title00_color10
     43  28000 ????		00 a4	    title_color9 =	title00_color9
     44  28000 ????		00 93	    title_color8 =	title00_color8
     45  28000 ????		00 ab	    title_color7 =	title00_color7
     46  28000 ????		00 92	    title_color6 =	title00_color6
     47  28000 ????		00 aa	    title_color5 =	title00_color5
     48  28000 ????		00 91	    title_color4 =	title00_color4
     49  28000 ????		00 a6	    title_color3 =	title00_color3
     50  28000 ????		00 a5	    title_color2 =	title00_color2
     51  28000 ????		00 91	    title_color1 =	title00_color1
     52  28000 ????		00 00	    title01_color15 =	0
     53  28000 ????		00 00	    title01_color14 =	0
     54  28000 ????		00 00	    title01_color13 =	0
     55  28000 ????		00 a8	    title01_color12 =	$a8
     56  28000 ????		00 a9	    title01_color11 =	$a9
     57  28000 ????		00 a7	    title01_color10 =	$a7
     58  28000 ????		00 a4	    title01_color9 =	$a4
     59  28000 ????		00 93	    title01_color8 =	$93
     60  28000 ????		00 ab	    title01_color7 =	$ab
     61  28000 ????		00 92	    title01_color6 =	$92
     62  28000 ????		00 aa	    title01_color5 =	$aa
     63  28000 ????		00 91	    title01_color4 =	$91
     64  28000 ????		00 a6	    title01_color3 =	$a6
     65  28000 ????		00 a5	    title01_color2 =	$a5
     66  28000 ????		00 91	    title01_color1 =	$91
     67  28000 ????		00 00	    title01_color0 =	$00
     68  28000 ????		00 00	    title00_color15 =	0
     69  28000 ????		00 00	    title00_color14 =	0
     70  28000 ????		00 00	    title00_color13 =	0
     71  28000 ????		00 a8	    title00_color12 =	$a8
     72  28000 ????		00 a9	    title00_color11 =	$a9
     73  28000 ????		00 a7	    title00_color10 =	$a7
     74  28000 ????		00 a4	    title00_color9 =	$a4
     75  28000 ????		00 93	    title00_color8 =	$93
     76  28000 ????		00 ab	    title00_color7 =	$ab
     77  28000 ????		00 92	    title00_color6 =	$92
     78  28000 ????		00 aa	    title00_color5 =	$aa
     79  28000 ????		00 91	    title00_color4 =	$91
     80  28000 ????		00 a6	    title00_color3 =	$a6
     81  28000 ????		00 a5	    title00_color2 =	$a5
     82  28000 ????		00 91	    title00_color1 =	$91
     83  28000 ????		00 00	    title00_color0 =	$00
     84  28000 ????		00 00	    player4_color3 =	0
     85  28000 ????		00 44	    player4_color2 =	$44
     86  28000 ????		00 0d	    player4_color1 =	$0d
     87  28000 ????		00 00	    player4_color0 =	$00
     88  28000 ????		00 07	    player3_color3 =	$07
     89  28000 ????		00 44	    player3_color2 =	$44
     90  28000 ????		00 0d	    player3_color1 =	$0d
     91  28000 ????		00 00	    player3_color0 =	$00
     92  28000 ????		00 07	    player2_color3 =	$07
     93  28000 ????		00 44	    player2_color2 =	$44
     94  28000 ????		00 0d	    player2_color1 =	$0d
     95  28000 ????		00 00	    player2_color0 =	$00
     96  28000 ????		00 07	    player1_color3 =	$07
     97  28000 ????		00 44	    player1_color2 =	$44
     98  28000 ????		00 0d	    player1_color1 =	$0d
     99  28000 ????		00 00	    player1_color0 =	$00
    100  28000 ????		00 0f	    font_color1 =	$0f
    101  28000 ????		00 00	    font_color0 =	$00
    102  28000 ????		00 01	    DOUBLEBUFFER =	1
    103  28000 ????		00 01	    SGRAM      =	1
    104  28000 ????		00 08	    bankswitchmode =	8
    105  28000 ????		00 01	    ROM128K    =	1
    106  28000 ????		00 01	    plotvalueonscreen =	1
    107  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
    633  28000 ????
    634  28000 ????						; BEADHEADER... disabled for now
    635  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    636  28000 ????						; For more BEAD executable info, check out the spec...
    637  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  28000 ????
    639  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  28000 ????
    642  28000 ????
    643  28000 ????		00 40	    BDHSC      =	%01000000
    644  28000 ????		00 20	    BDYM       =	%00100000
    645  28000 ????		00 10	    BDPOKEY    =	%00010000
    646  28000 ????		00 08	    BDROF      =	%00001000
    647  28000 ????		00 00	    BD16K      =	%00000000
    648  28000 ????		00 01	    BD32K      =	%00000001
    649  28000 ????		00 02	    BD48K      =	%00000010
    650  28000 ????		00 05	    BD1800     =	%00000101
    651  28000 ????		00 06	    BD4000     =	%00000110
    652  28000 ????
    653  28000 ????			   -	       ifconst	BEADHEADER
    654  28000 ????			   -BEADHARDWARE SET	0
    655  28000 ????			   -	       ifconst	ROM16K
    656  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  28000 ????			   -	       endif
    658  28000 ????			   -	       ifconst	ROM32K
    659  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  28000 ????			   -	       endif
    661  28000 ????			   -	       ifconst	ROM48K
    662  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  28000 ????			   -	       endif
    664  28000 ????			   -	       ifconst	pokeysupport
    665  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  28000 ????			   -	       endif
    667  28000 ????			   -	       ifconst	HSSUPPORT
    668  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  28000 ????			   -	       endif
    670  28000 ????				       endif
    671  28000 ????
    672  28000 ????						;start address of cart...
    673  28000 ????
    674  28000 ????			    BANK_WAS_SET SET	0
    675  28000 ????
    676  28000 ????			   -	       ifconst	ROM8K
    677  28000 ????			   -	       ORG	$E000,0
    678  28000 ????			   -BANK_WAS_SET SET	1
    679  28000 ????				       endif		; ROM8K
    680  28000 ????
    681  28000 ????			   -	       ifconst	ROM16K
    682  28000 ????			   -	       ORG	$C000,0
    683  28000 ????			   -BANK_WAS_SET SET	1
    684  28000 ????			   -	       ifconst	BEADHEADER
    685  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  28000 ????			   -	       CLC
    688  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  28000 ????			   -_SKIPDESCRIPTION
    691  28000 ????			   -	       endif		; GAMEDESCRIPTION
    692  28000 ????			   -	       jmp	($FFFC)
    693  28000 ????			   -	       endif		; BEADHEADER
    694  28000 ????				       endif		; ROM16K
    695  28000 ????
    696  28000 ????			   -	       ifconst	ROM32K
    697  28000 ????			   -	       ORG	$8000,0
    698  28000 ????			   -BANK_WAS_SET SET	1
    699  28000 ????			   -	       ifconst	BEADHEADER
    700  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    701  28000 ????			   -	       ifconst	GAMEDESCRIPTION
    702  28000 ????			   -	       CLC
    703  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    704  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    705  28000 ????			   -_SKIPDESCRIPTION
    706  28000 ????			   -	       endif		; GAMEDESCRIPTION
    707  28000 ????			   -	       jmp	($FFFC)
    708  28000 ????			   -	       endif		; BEADHEADER
    709  28000 ????				       endif		; ROM32K
    710  28000 ????
    711  28000 ????			   -	       ifconst	ROM48K
    712  28000 ????			   -	       ORG	$4000,0
    713  28000 ????			   -BANK_WAS_SET SET	1
    714  28000 ????			   -	       ifconst	BEADHEADER
    715  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    716  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    717  28000 ????			   -	       CLC
    718  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    719  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    720  28000 ????			   -_SKIPDESCRIPTION
    721  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
    722  28000 ????			   -	       jmp	($FFFC)
    723  28000 ????			   -	       endif		; BEADHEADER
    724  28000 ????				       endif		; ROM48K
    725  28000 ????
    726  28000 ????			   -	       ifconst	ROM52K
    727  28000 ????			   -BANK_WAS_SET SET	1
    728  28000 ????			   -	       ORG	$3000,0
    729  28000 ????				       endif		; ROM52K
    730  28000 ????
    731  28000 ????				       ifconst	bankswitchmode
    732  28000 ????			   -	       ifconst	ROMAT4K
    733  28000 ????			   -BANK_WAS_SET SET	1
    734  28000 ????			   -	       ORG	$4000,0
    735  28000 ????			   -	       RORG	$4000
    736  28000 ????				       else		; ROMAT4K
    737  28000 ????			    BANK_WAS_SET SET	1
    738  8000					      ORG	$8000,0
    739  8000					      RORG	$8000
    740  8000					      endif
    741  8000					      endif
    742  8000
    743  8000				  -	      if	BANK_WAS_SET = 0
    744  8000				  -	      ORG	$8000,0	; default is 32K
    745  8000					      endif
    746  8000
    747  8000				   START_OF_ROM SET	.
    748  8000							;7800basic v0.24 Mar  2 2023 18:16:13
    749  8000				   SPACEOVERFLOW SET	0
    750  8000				   game
    751  8000				   .L00 		;;  set zoneheight 16
    752  8000
    753  8000				   .L01 		;;  displaymode 160A
    754  8000
    755  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    756  8002		       85 3c		      sta	CTRL
    757  8004
    758  8004		       8d 07 21 	      sta	sCTRL
    759  8007
    760  8007				   .L02 		;;  set plotvalueonscreen on
    761  8007
    762  8007				   .L03 		;;  set romsize 128kRAM
    763  8007
    764  8007				   .L04 		;;  set dlmemory $4000 $7FFF
    765  8007
    766  8007		       40 00	   DLMEMSTART =	$4000
    767  8007		       7f ff	   DLMEMEND   =	$7FFF
    768  8007				   .L05 		;;  doublebuffer on
    769  8007
    770  8007		       a9 01		      lda	#1
    771  8009		       85 d5		      sta	doublebufferstate
    772  800b				   .
    773  800b							;; 
    774  800b
    775  800b				   .L06 		;;  incgraphic font.png 160A 
    776  800b
    777  800b				   .L07 		;;  characterset font
    778  800b
    779  800b		       a9 a0		      lda	#>font
    780  800d		       8d 0b 21 	      sta	sCHARBASE
    781  8010
    782  8010		       85 34		      sta	CHARBASE
    783  8012		       a9 60		      lda	#(font_mode | %01100000)
    784  8014		       8d 06 21 	      sta	charactermode
    785  8017
    786  8017				   .L08 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    787  8017
    788  8017				   .
    789  8017							;; 
    790  8017
    791  8017				   .L09 		;;  rem sprites
    792  8017
    793  8017				   .L010		;;  incgraphic images/player1.png 160A 0 1 3 2
    794  8017
    795  8017				   .L011		;;  incgraphic images/player2.png 160A 0 1 3 2
    796  8017
    797  8017				   .L012		;;  incgraphic images/player3.png 160A 0 1 3 2
    798  8017
    799  8017				   .L013		;;  incgraphic images/player4.png 160A 0 1 3 2
    800  8017
    801  8017				   .L014		;;  incbanner	images/title.png 160B 
    802  8017
    803  8017				   .
    804  8017							;; 
    805  8017
    806  8017				   .L015		;;  BACKGRND = $00
    807  8017
    808  8017		       a9 00		      LDA	#$00
    809  8019		       85 20		      STA	BACKGRND
    810  801b				   .
    811  801b							;; 
    812  801b
    813  801b				   .
    814  801b							;; 
    815  801b
    816  801b				   .
    817  801b							;; 
    818  801b
    819  801b				   .L016		;;  dim bgColor  =  var1
    820  801b
    821  801b				   .L017		;;  dim wait  =  var2
    822  801b
    823  801b				   .L018		;;  dim lives	=  var3
    824  801b
    825  801b				   .L019		;;  dim score	=  var4
    826  801b
    827  801b				   .L020		;;  dim playerX  = var5
    828  801b
    829  801b				   .L021		;;  dim playerY  =  var6
    830  801b
    831  801b				   .L022		;;  dim playerAnimFrame  =  var7
    832  801b
    833  801b				   .L023		;;  dim playerAnimWait  =  var8
    834  801b
    835  801b				   .
    836  801b							;; 
    837  801b
    838  801b				   .L024		;;  bgColor  =  $
    839  801b
    840  801b		       a9 00		      LDA	#$
    841  801d		       8d 41 01 	      STA	bgColor
    842  8020				   .L025		;;  wait  =  0
    843  8020
    844  8020		       a9 00		      LDA	#0
    845  8022		       8d 42 01 	      STA	wait
    846  8025				   .L026		;;  lives  =  0
    847  8025
    848  8025		       a9 00		      LDA	#0
    849  8027		       8d 43 01 	      STA	lives
    850  802a				   .L027		;;  score  =  0
    851  802a
    852  802a		       a9 00		      LDA	#0
    853  802c		       8d 44 01 	      STA	score
    854  802f				   .L028		;;  playerY  =  0
    855  802f
    856  802f		       a9 00		      LDA	#0
    857  8031		       8d 46 01 	      STA	playerY
    858  8034				   .L029		;;  playerX  =  0
    859  8034
    860  8034		       a9 00		      LDA	#0
    861  8036		       8d 45 01 	      STA	playerX
    862  8039				   .L030		;;  playerAnimFrame  =  0
    863  8039
    864  8039		       a9 00		      LDA	#0
    865  803b		       8d 47 01 	      STA	playerAnimFrame
    866  803e				   .L031		;;  playerAnimWait  =	0
    867  803e
    868  803e		       a9 00		      LDA	#0
    869  8040		       8d 48 01 	      STA	playerAnimWait
    870  8043				   .
    871  8043							;; 
    872  8043
    873  8043				   .L032		;;  BACKGRND  =  $00
    874  8043
    875  8043		       a9 00		      LDA	#$00
    876  8045		       85 20		      STA	BACKGRND
    877  8047				   .
    878  8047							;; 
    879  8047
    880  8047				   ._setTitleColors
    881  8047							;; _setTitleColors
    882  8047
    883  8047				   .L033		;;  P0C1  =  title_color1
    884  8047
    885  8047		       a9 91		      LDA	#title_color1
    886  8049		       85 21		      STA	P0C1
    887  804b				   .L034		;;  P0C2  =  title_color2
    888  804b
    889  804b		       a9 a5		      LDA	#title_color2
    890  804d		       85 22		      STA	P0C2
    891  804f				   .L035		;;  P0C3  =  title_color3
    892  804f
    893  804f		       a9 a6		      LDA	#title_color3
    894  8051		       85 23		      STA	P0C3
    895  8053				   .L036		;;  P1C1  =  title_color4
    896  8053
    897  8053		       a9 91		      LDA	#title_color4
    898  8055		       85 25		      STA	P1C1
    899  8057				   .L037		;;  P1C2  =  title_color5
    900  8057
    901  8057		       a9 aa		      LDA	#title_color5
    902  8059		       85 26		      STA	P1C2
    903  805b				   .L038		;;  P1C3  =  title_color6
    904  805b
    905  805b		       a9 92		      LDA	#title_color6
    906  805d		       85 27		      STA	P1C3
    907  805f				   .L039		;;  P2C1  =  title_color7
    908  805f
    909  805f		       a9 ab		      LDA	#title_color7
    910  8061		       85 29		      STA	P2C1
    911  8063				   .L040		;;  P2C2  =  title_color8
    912  8063
    913  8063		       a9 93		      LDA	#title_color8
    914  8065		       85 2a		      STA	P2C2
    915  8067				   .L041		;;  P2C3  =  title_color9
    916  8067
    917  8067		       a9 a4		      LDA	#title_color9
    918  8069		       85 2b		      STA	P2C3
    919  806b				   .L042		;;  P3C1  =  title_color10
    920  806b
    921  806b		       a9 a7		      LDA	#title_color10
    922  806d		       85 2d		      STA	P3C1
    923  806f				   .L043		;;  P3C2  =  title_color11
    924  806f
    925  806f		       a9 a9		      LDA	#title_color11
    926  8071		       85 2e		      STA	P3C2
    927  8073				   .L044		;;  P3C3  =  title_color12
    928  8073
    929  8073		       a9 a8		      LDA	#title_color12
    930  8075		       85 2f		      STA	P3C3
    931  8077				   .
    932  8077							;; 
    933  8077
    934  8077				   .
    935  8077							;; 
    936  8077
    937  8077				   ._titleLoop
    938  8077							;; _titleLoop
    939  8077
    940  8077				   .L045		;;  clearscreen
    941  8077
    942  8077		       20 87 f0 	      jsr	clearscreen
    943  807a				   .L046		;;  plotbanner title 0 32 50
    944  807a
    945  807a		       a9 00		      lda	#(0)
    946  807c		       85 44		      sta	temp3
    947  807e
    948  807e		       a9 20		      lda	#32
    949  8080		       85 45		      sta	temp4
    950  8082
    951  8082		       a9 32		      lda	#50
    952  8084
    953  8084		       85 46		      sta	temp5
    954  8086
    955  8086		       a9 c0		      lda	#(title00_mode|%01000000)
    956  8088		       85 47		      sta	temp6
    957  808a
    958  808a		       a9 45		      lda	#<(title00 + 0)
    959  808c		       85 42		      sta	temp1
    960  808e
    961  808e		       a9 a0		      lda	#>(title00 + 0)
    962  8090		       85 43		      sta	temp2
    963  8092
    964  8092		       20 e3 f2 	      jsr	plotsprite
    965  8095		       18		      clc
    966  8096		       a9 10		      lda	#16
    967  8098		       65 46		      adc	temp5
    968  809a		       85 46		      sta	temp5
    969  809c		       a9 75		      lda	#<(title01 + 0)
    970  809e		       85 42		      sta	temp1
    971  80a0
    972  80a0		       a9 a0		      lda	#>(title01 + 0)
    973  80a2		       85 43		      sta	temp2
    974  80a4
    975  80a4		       20 e3 f2 	      jsr	plotsprite
    976  80a7		       a9 10		      lda	#(0|title00_width_twoscompliment)
    977  80a9		       85 44		      sta	temp3
    978  80ab
    979  80ab		       a9 20		      lda	#32
    980  80ad		       18		      clc
    981  80ae		       69 40		      adc	#64
    982  80b0		       85 45		      sta	temp4
    983  80b2
    984  80b2		       a9 32		      lda	#50
    985  80b4
    986  80b4		       85 46		      sta	temp5
    987  80b6
    988  80b6		       a9 c0		      lda	#(title00_mode|%01000000)
    989  80b8		       85 47		      sta	temp6
    990  80ba
    991  80ba		       a9 65		      lda	#<(title00 + 32)
    992  80bc		       85 42		      sta	temp1
    993  80be
    994  80be		       a9 a0		      lda	#>(title00 + 32)
    995  80c0		       85 43		      sta	temp2
    996  80c2
    997  80c2		       20 e3 f2 	      jsr	plotsprite
    998  80c5		       18		      clc
    999  80c6		       a9 10		      lda	#16
   1000  80c8		       65 46		      adc	temp5
   1001  80ca		       85 46		      sta	temp5
   1002  80cc		       a9 95		      lda	#<(title01 + 32)
   1003  80ce		       85 42		      sta	temp1
   1004  80d0
   1005  80d0		       a9 a0		      lda	#>(title01 + 32)
   1006  80d2		       85 43		      sta	temp2
   1007  80d4
   1008  80d4		       20 e3 f2 	      jsr	plotsprite
   1009  80d7				   .L047		;;  wait  =  wait  +  1
   1010  80d7
   1011  80d7		       ad 42 01 	      LDA	wait
   1012  80da		       18		      CLC
   1013  80db		       69 01		      ADC	#1
   1014  80dd		       8d 42 01 	      STA	wait
   1015  80e0				   .L048		;;  if wait  >  10 then wait  =  0  :	bgColor  =  bgColor  +	1
   1016  80e0
   1017  80e0		       a9 0a		      LDA	#10
   1018  80e2		       cd 42 01 	      CMP	wait
   1019  80e5		       b0 0e		      BCS	.skipL048
   1020  80e7				   .condpart0
   1021  80e7		       a9 00		      LDA	#0
   1022  80e9		       8d 42 01 	      STA	wait
   1023  80ec		       ad 41 01 	      LDA	bgColor
   1024  80ef		       18		      CLC
   1025  80f0		       69 01		      ADC	#1
   1026  80f2		       8d 41 01 	      STA	bgColor
   1027  80f5				   .skipL048
   1028  80f5				   .L049		;;  if bgColor  >  127 then bgColor  =  0
   1029  80f5
   1030  80f5		       a9 7f		      LDA	#127
   1031  80f7		       cd 41 01 	      CMP	bgColor
   1032  80fa		       b0 05		      BCS	.skipL049
   1033  80fc				   .condpart1
   1034  80fc		       a9 00		      LDA	#0
   1035  80fe		       8d 41 01 	      STA	bgColor
   1036  8101				   .skipL049
   1037  8101				   .L050		;;  BACKGRND  =  bgColor
   1038  8101
   1039  8101		       ad 41 01 	      LDA	bgColor
   1040  8104		       85 20		      STA	BACKGRND
   1041  8106				   .
   1042  8106							;; 
   1043  8106
   1044  8106				   .L051		;;  plotchars 'u.a.p.' 0 68 5
   1045  8106
   1046  8106		       4c 0f 81 	      JMP	skipalphadata0
   1047  8109				   alphadata0
   1048  8109		       1e		      .byte.b	(<font + $1e)
   1049  810a		       29		      .byte.b	(<font + $29)
   1050  810b		       0a		      .byte.b	(<font + $0a)
   1051  810c		       29		      .byte.b	(<font + $29)
   1052  810d		       19		      .byte.b	(<font + $19)
   1053  810e		       29		      .byte.b	(<font + $29)
   1054  810f				   skipalphadata0
   1055  810f		       a9 09		      lda	#<alphadata0
   1056  8111		       85 42		      sta	temp1
   1057  8113
   1058  8113		       a9 81		      lda	#>alphadata0
   1059  8115		       85 43		      sta	temp2
   1060  8117
   1061  8117		       a9 1a		      lda	#26	; width in two's complement
   1062  8119		       09 00		      ora	#0	; palette left shifted 5 bits
   1063  811b		       85 44		      sta	temp3
   1064  811d		       a9 44		      lda	#68
   1065  811f		       85 45		      sta	temp4
   1066  8121
   1067  8121		       a9 05		      lda	#5
   1068  8123
   1069  8123		       85 46		      sta	temp5
   1070  8125
   1071  8125		       20 a6 f3 	      jsr	plotcharacters
   1072  8128				   .L052		;;  if joy0fire0  ||  joy0fire1 then goto _initGame
   1073  8128
   1074  8128		       2c 02 21 	      bit	sINPT1
   1075  812b		       50 03		      BVC	.skipL052
   1076  812d				   .condpart2
   1077  812d		       4c 35 81 	      jmp	.condpart3
   1078  8130				   .skipL052
   1079  8130		       2c 02 21 	      bit	sINPT1
   1080  8133		       10 03		      BPL	.skip0OR
   1081  8135				   .condpart3
   1082  8135		       4c 3e 81 	      jmp	._initGame
   1083  8138
   1084  8138				   .skip0OR
   1085  8138				   .
   1086  8138							;; 
   1087  8138
   1088  8138				   .L053		;;  drawscreen
   1089  8138
   1090  8138		       20 c3 f0 	      jsr	drawscreen
   1091  813b				   .
   1092  813b							;; 
   1093  813b
   1094  813b				   .L054		;;  goto _titleLoop
   1095  813b
   1096  813b		       4c 77 80 	      jmp	._titleLoop
   1097  813e
   1098  813e				   .
   1099  813e							;; 
   1100  813e
   1101  813e				   .
   1102  813e							;; 
   1103  813e
   1104  813e				   ._initGame
   1105  813e							;; _initGame
   1106  813e
   1107  813e				   .L055		;;  lives  =  3
   1108  813e
   1109  813e		       a9 03		      LDA	#3
   1110  8140		       8d 43 01 	      STA	lives
   1111  8143				   .L056		;;  score  =  0
   1112  8143
   1113  8143		       a9 00		      LDA	#0
   1114  8145		       8d 44 01 	      STA	score
   1115  8148				   .L057		;;  BACKGRND = $00
   1116  8148
   1117  8148		       a9 00		      LDA	#$00
   1118  814a		       85 20		      STA	BACKGRND
   1119  814c				   .L058		;;  playerX  =  70
   1120  814c
   1121  814c		       a9 46		      LDA	#70
   1122  814e		       8d 45 01 	      STA	playerX
   1123  8151				   .L059		;;  playerY  =  90
   1124  8151
   1125  8151		       a9 5a		      LDA	#90
   1126  8153		       8d 46 01 	      STA	playerY
   1127  8156				   .L060		;;  playerAnimFrame  =  0
   1128  8156
   1129  8156		       a9 00		      LDA	#0
   1130  8158		       8d 47 01 	      STA	playerAnimFrame
   1131  815b				   .L061		;;  playerAnimWait  =	0
   1132  815b
   1133  815b		       a9 00		      LDA	#0
   1134  815d		       8d 48 01 	      STA	playerAnimWait
   1135  8160				   .L062		;;  rem pallette 0 text
   1136  8160
   1137  8160				   .L063		;;  P0C1 = $0F
   1138  8160
   1139  8160		       a9 0f		      LDA	#$0F
   1140  8162		       85 21		      STA	P0C1
   1141  8164				   .L064		;;  P0C2 = $0C
   1142  8164
   1143  8164		       a9 0c		      LDA	#$0C
   1144  8166		       85 22		      STA	P0C2
   1145  8168				   .L065		;;  P0C3 = $0A
   1146  8168
   1147  8168		       a9 0a		      LDA	#$0A
   1148  816a		       85 23		      STA	P0C3
   1149  816c				   .
   1150  816c							;; 
   1151  816c
   1152  816c				   .L066		;;  rem pallette 1 player
   1153  816c
   1154  816c				   .L067		;;  P1C1  =  $0D
   1155  816c
   1156  816c		       a9 0d		      LDA	#$0D
   1157  816e		       85 25		      STA	P1C1
   1158  8170				   .L068		;;  P1C2  =  $08
   1159  8170
   1160  8170		       a9 08		      LDA	#$08
   1161  8172		       85 26		      STA	P1C2
   1162  8174				   .L069		;;  P1C3  =  $33
   1163  8174
   1164  8174		       a9 33		      LDA	#$33
   1165  8176		       85 27		      STA	P1C3
   1166  8178				   .
   1167  8178							;; 
   1168  8178
   1169  8178				   .
   1170  8178							;; 
   1171  8178
   1172  8178				   ._gameLoop
   1173  8178							;; _gameLoop
   1174  8178
   1175  8178				   .
   1176  8178							;; 
   1177  8178
   1178  8178				   .L070		;;  clearscreen
   1179  8178
   1180  8178		       20 87 f0 	      jsr	clearscreen
   1181  817b				   .
   1182  817b							;; 
   1183  817b
   1184  817b				   .L071		;;  rem plotchars 'game'  0 68 5
   1185  817b
   1186  817b				   .L072		;;  plotsprite player1 1 playerX playerY playerAnimFrame
   1187  817b
   1188  817b		       a9 35		      lda	#<player1
   1189  817d		       a0 04		      ldy	#player1_width
   1190  817f		       18		      clc
   1191  8180		       f0 06		      beq	plotspritewidthskip1
   1192  8182				   plotspritewidthloop1
   1193  8182		       6d 47 01 	      adc	playerAnimFrame
   1194  8185		       88		      dey
   1195  8186		       d0 fa		      bne	plotspritewidthloop1
   1196  8188				   plotspritewidthskip1
   1197  8188		       85 42		      sta	temp1
   1198  818a
   1199  818a		       a9 a0		      lda	#>player1
   1200  818c		       85 43		      sta	temp2
   1201  818e
   1202  818e		       a9 3c		      lda	#(32|player1_width_twoscompliment)
   1203  8190		       85 44		      sta	temp3
   1204  8192
   1205  8192		       ad 45 01 	      lda	playerX
   1206  8195		       85 45		      sta	temp4
   1207  8197
   1208  8197		       ad 46 01 	      lda	playerY
   1209  819a		       85 46		      sta	temp5
   1210  819c
   1211  819c		       a9 40		      lda	#(player1_mode|%01000000)
   1212  819e		       85 47		      sta	temp6
   1213  81a0
   1214  81a0		       20 e3 f2 	      jsr	plotsprite
   1215  81a3				   .L073		;;  playerAnimWait  =	playerAnimWait	+ 1
   1216  81a3
   1217  81a3		       ad 48 01 	      LDA	playerAnimWait
   1218  81a6		       18		      CLC
   1219  81a7		       69 01		      ADC	#1
   1220  81a9		       8d 48 01 	      STA	playerAnimWait
   1221  81ac				   .L074		;;  if playerAnimWait	>  2 then playerAnimFrame  =  playerAnimFrame  +  1  :	playerAnimWait	=  0
   1222  81ac
   1223  81ac		       a9 02		      LDA	#2
   1224  81ae		       cd 48 01 	      CMP	playerAnimWait
   1225  81b1		       b0 0e		      BCS	.skipL074
   1226  81b3				   .condpart4
   1227  81b3		       ad 47 01 	      LDA	playerAnimFrame
   1228  81b6		       18		      CLC
   1229  81b7		       69 01		      ADC	#1
   1230  81b9		       8d 47 01 	      STA	playerAnimFrame
   1231  81bc		       a9 00		      LDA	#0
   1232  81be		       8d 48 01 	      STA	playerAnimWait
   1233  81c1				   .skipL074
   1234  81c1				   .L075		;;  if playerAnimFrame  >  3 then playerAnimFrame  =  0
   1235  81c1
   1236  81c1		       a9 03		      LDA	#3
   1237  81c3		       cd 47 01 	      CMP	playerAnimFrame
   1238  81c6		       b0 05		      BCS	.skipL075
   1239  81c8				   .condpart5
   1240  81c8		       a9 00		      LDA	#0
   1241  81ca		       8d 47 01 	      STA	playerAnimFrame
   1242  81cd				   .skipL075
   1243  81cd				   .
   1244  81cd							;; 
   1245  81cd
   1246  81cd				   .L076		;;  if joy0left then playerX = playerX  -  1
   1247  81cd
   1248  81cd		       2c 80 02 	      bit	SWCHA
   1249  81d0		       70 09		      BVS	.skipL076
   1250  81d2				   .condpart6
   1251  81d2		       ad 45 01 	      LDA	playerX
   1252  81d5		       38		      SEC
   1253  81d6		       e9 01		      SBC	#1
   1254  81d8		       8d 45 01 	      STA	playerX
   1255  81db				   .skipL076
   1256  81db				   .L077		;;  if joy0right then playerX = playerX  +  1
   1257  81db
   1258  81db		       2c 80 02 	      bit	SWCHA
   1259  81de		       30 09		      BMI	.skipL077
   1260  81e0				   .condpart7
   1261  81e0		       ad 45 01 	      LDA	playerX
   1262  81e3		       18		      CLC
   1263  81e4		       69 01		      ADC	#1
   1264  81e6		       8d 45 01 	      STA	playerX
   1265  81e9				   .skipL077
   1266  81e9				   .L078		;;  if joy0up then playerY = playerY  -  1
   1267  81e9
   1268  81e9		       a9 10		      lda	#$10
   1269  81eb		       2c 80 02 	      bit	SWCHA
   1270  81ee		       d0 09		      BNE	.skipL078
   1271  81f0				   .condpart8
   1272  81f0		       ad 46 01 	      LDA	playerY
   1273  81f3		       38		      SEC
   1274  81f4		       e9 01		      SBC	#1
   1275  81f6		       8d 46 01 	      STA	playerY
   1276  81f9				   .skipL078
   1277  81f9				   .L079		;;  if joy0down then playerY = playerY  +  1
   1278  81f9
   1279  81f9		       a9 20		      lda	#$20
   1280  81fb		       2c 80 02 	      bit	SWCHA
   1281  81fe		       d0 09		      BNE	.skipL079
   1282  8200				   .condpart9
   1283  8200		       ad 46 01 	      LDA	playerY
   1284  8203		       18		      CLC
   1285  8204		       69 01		      ADC	#1
   1286  8206		       8d 46 01 	      STA	playerY
   1287  8209				   .skipL079
   1288  8209				   .
   1289  8209							;; 
   1290  8209
   1291  8209				   .L080		;;  doublebuffer flip 2
   1292  8209
   1293  8209		       20 91 f5 	      jsr	flipdisplaybuffer
   1294  820c		       a9 02		      lda	#2
   1295  820e		       8d b3 01 	      sta	doublebufferminimumframetarget
   1296  8211				   .
   1297  8211							;; 
   1298  8211
   1299  8211				   .L081		;;  goto _gameLoop
   1300  8211		       4c 78 81 	      jmp	._gameLoop
   1301  8211				   DMAHOLEEND0 SET	.
   1302  8214				   gameend
   1303  8214				   DMAHOLEEND0 SET	.
   7660 bytes of ROM space left in the main area of bank 1.
   1304  8214					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   1305  8214				  -	      if	($A000 - .) < 0
   1306  8214				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   1307  8214					      endif
   1308  8214				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   1309  8214				  -	      .byte	0
   1310  8214					      endif
   1311  8214				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   1312  8214
   1313  a000					      ORG	$A000,0	; *************
   1314  a000
   1315  a000					      RORG	$A000	; *************
   1316  a000
   1317  a000		       a0 00	   font       =	$A000
   1318  a000
   1319  a000				   font
   1320  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1321  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1322  a020		       a0 35	   player1    =	$A035
   1323  a035
   1324  a035				   player1
   1325  a035		       00 00 00 00	      HEX	00000000
   1326  a035		       a0 39	   player2    =	$A039
   1327  a039
   1328  a039				   player2
   1329  a039		       00 00 00 00	      HEX	00000000
   1330  a039		       a0 3d	   player3    =	$A03D
   1331  a03d
   1332  a03d				   player3
   1333  a03d		       00 00 00 00	      HEX	00000000
   1334  a03d		       a0 41	   player4    =	$A041
   1335  a041
   1336  a041				   player4
   1337  a041		       00 00 00 00	      HEX	00000000
   1338  a041		       a0 45	   title00    =	$A045
   1339  a045
   1340  a045				   title00
   1341  a045		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0c0000030f0f0c0000000
   1342  a065		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f0c0
   1343  a065		       a0 75	   title01    =	$A075
   1344  a075
   1345  a075				   title01
   1346  a075		       00 00 55 55*	      HEX	0000555555555555555555550000115500555555440000000000001155555500
   1347  a095		       55 44 55 55*	      HEX	55445555554400000000000000005544
   1348  a0a5
   1349  a100					      ORG	$A100,0	; *************
   1350  a100
   1351  a100					      RORG	$A100	; *************
   1352  a100
   1353  a100							;font
   1354  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1355  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1356  a135							;player1
   1357  a135		       00 00 00 00	      HEX	00000000
   1358  a139							;player2
   1359  a139		       00 00 00 00	      HEX	00000000
   1360  a13d							;player3
   1361  a13d		       00 00 00 00	      HEX	00000000
   1362  a141							;player4
   1363  a141		       00 00 00 00	      HEX	00000000
   1364  a145							;title00
   1365  a145		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1366  a165		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1367  a175							;title01
   1368  a175		       00 55 55 55*	      HEX	0055555555555555555555550000115500555555550000000000005555555500
   1369  a195		       55 44 55 55*	      HEX	55445555554400000000000000005544
   1370  a1a5
   1371  a200					      ORG	$A200,0	; *************
   1372  a200
   1373  a200					      RORG	$A200	; *************
   1374  a200
   1375  a200							;font
   1376  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1377  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1378  a235							;player1
   1379  a235		       00 00 00 00	      HEX	00000000
   1380  a239							;player2
   1381  a239		       00 00 00 00	      HEX	00000000
   1382  a23d							;player3
   1383  a23d		       00 00 00 00	      HEX	00000000
   1384  a241							;player4
   1385  a241		       00 00 00 00	      HEX	00000000
   1386  a245							;title00
   1387  a245		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   1388  a265		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000135f5f5f
   1389  a275							;title01
   1390  a275		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1391  a295		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1392  a2a5
   1393  a300					      ORG	$A300,0	; *************
   1394  a300
   1395  a300					      RORG	$A300	; *************
   1396  a300
   1397  a300							;font
   1398  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1399  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1400  a335							;player1
   1401  a335		       00 00 00 00	      HEX	00000000
   1402  a339							;player2
   1403  a339		       00 00 00 00	      HEX	00000000
   1404  a33d							;player3
   1405  a33d		       00 00 00 00	      HEX	00000000
   1406  a341							;player4
   1407  a341		       00 00 00 00	      HEX	00000000
   1408  a345							;title00
   1409  a345		       5f 5f 5f 4c*	      HEX	5f5f5f4c000000000000135f5f5f0000000000005f5f5f00005f5f5f00000000
   1410  a365		       00 00 5f 5f*	      HEX	00005f5f5f4c000000000000005f5f5f
   1411  a375							;title01
   1412  a375		       31 f5 f5 f5*	      HEX	31f5f5f5f5f5f5f5f5f5f5f5f5c400000031f5f5f5c40000000031f5f5f5c400
   1413  a395		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   1414  a3a5
   1415  a400					      ORG	$A400,0	; *************
   1416  a400
   1417  a400					      RORG	$A400	; *************
   1418  a400
   1419  a400							;font
   1420  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1421  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1422  a435							;player1
   1423  a435		       00 00 00 00	      HEX	00000000
   1424  a439							;player2
   1425  a439		       00 00 00 00	      HEX	00000000
   1426  a43d							;player3
   1427  a43d		       00 00 00 00	      HEX	00000000
   1428  a441							;player4
   1429  a441		       00 00 00 00	      HEX	00000000
   1430  a445							;title00
   1431  a445		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1432  a465		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1433  a475							;title01
   1434  a475		       f5 f5 f5 f5*	      HEX	f5f5f5f5f5f5f5f5f5f5f5f5f5f500000031f5f5f5c40000000031f5f5f5c400
   1435  a495		       00 00 f5 f5*	      HEX	0000f5f5f5c400000000000000000000
   1436  a4a5
   1437  a500					      ORG	$A500,0	; *************
   1438  a500
   1439  a500					      RORG	$A500	; *************
   1440  a500
   1441  a500							;font
   1442  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1443  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1444  a535							;player1
   1445  a535		       00 00 00 00	      HEX	00000000
   1446  a539							;player2
   1447  a539		       00 00 00 00	      HEX	00000000
   1448  a53d							;player3
   1449  a53d		       00 00 00 00	      HEX	00000000
   1450  a541							;player4
   1451  a541		       00 00 00 00	      HEX	00000000
   1452  a545							;title00
   1453  a545		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffcc33ffffcc00000000
   1454  a565		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   1455  a575							;title01
   1456  a575		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1457  a595		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1458  a5a5
   1459  a600					      ORG	$A600,0	; *************
   1460  a600
   1461  a600					      RORG	$A600	; *************
   1462  a600
   1463  a600							;font
   1464  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1465  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1466  a635							;player1
   1467  a635		       00 00 00 00	      HEX	00000000
   1468  a639							;player2
   1469  a639		       00 00 00 00	      HEX	00000000
   1470  a63d							;player3
   1471  a63d		       00 00 00 00	      HEX	00000000
   1472  a641							;player4
   1473  a641		       00 00 00 00	      HEX	00000000
   1474  a645							;title00
   1475  a645		       ff ff ff cc*	      HEX	ffffffcc00000000000033ffffff00000000000033ffffffffffffcc00000000
   1476  a665		       00 00 ff ff*	      HEX	0000ffffffcc0000000000000033ffff
   1477  a675							;title01
   1478  a675		       aa aa aa aa*	      HEX	aaaaaaaaaa00000000aaaaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   1479  a695		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   1480  a6a5
   1481  a700					      ORG	$A700,0	; *************
   1482  a700
   1483  a700					      RORG	$A700	; *************
   1484  a700
   1485  a700							;font
   1486  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1487  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1488  a735							;player1
   1489  a735		       0f 57 d4 00	      HEX	0f57d400
   1490  a739							;player2
   1491  a739		       07 d5 f4 00	      HEX	07d5f400
   1492  a73d							;player3
   1493  a73d		       05 f5 7c 00	      HEX	05f57c00
   1494  a741							;player4
   1495  a741		       0d 7d 5c 00	      HEX	0d7d5c00
   1496  a745							;title00
   1497  a745		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1498  a765		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1499  a775							;title01
   1500  a775		       aa aa aa aa*	      HEX	aaaaaaaa000000000000aaaaaaaa00000000aaaaaaaa00000000aaaaaaaa0000
   1501  a795		       00 00 aa aa*	      HEX	0000aaaaaa8800000000000000000000
   1502  a7a5
   1503  a800					      ORG	$A800,0	; *************
   1504  a800
   1505  a800					      RORG	$A800	; *************
   1506  a800
   1507  a800							;font
   1508  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1509  a820		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   1510  a835							;player1
   1511  a835		       15 55 55 00	      HEX	15555500
   1512  a839							;player2
   1513  a839		       15 55 55 00	      HEX	15555500
   1514  a83d							;player3
   1515  a83d		       15 55 55 00	      HEX	15555500
   1516  a841							;player4
   1517  a841		       15 55 55 00	      HEX	15555500
   1518  a845							;title00
   1519  a845		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   1520  a865		       00 00 af af*	      HEX	0000afafaf8c00000000000000afafaf
   1521  a875							;title01
   1522  a875		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1523  a895		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1524  a8a5
   1525  a900					      ORG	$A900,0	; *************
   1526  a900
   1527  a900					      RORG	$A900	; *************
   1528  a900
   1529  a900							;font
   1530  a900		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   1531  a920		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   1532  a935							;player1
   1533  a935		       55 55 55 40	      HEX	55555540
   1534  a939							;player2
   1535  a939		       55 55 55 40	      HEX	55555540
   1536  a93d							;player3
   1537  a93d		       55 55 55 40	      HEX	55555540
   1538  a941							;player4
   1539  a941		       55 55 55 40	      HEX	55555540
   1540  a945							;title00
   1541  a945		       af af af 8c*	      HEX	afafaf8c00000000000023afafaf00000000000000afafafafafaf0000000000
   1542  a965		       00 00 af af*	      HEX	0000afafaf8c00000000000023afafaf
   1543  a975							;title01
   1544  a975		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafac8000032fafafac80000
   1545  a995		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   1546  a9a5
   1547  aa00					      ORG	$AA00,0	; *************
   1548  aa00
   1549  aa00					      RORG	$AA00	; *************
   1550  aa00
   1551  aa00							;font
   1552  aa00		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   1553  aa20		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   1554  aa35							;player1
   1555  aa35		       00 00 00 00	      HEX	00000000
   1556  aa39							;player2
   1557  aa39		       00 00 00 00	      HEX	00000000
   1558  aa3d							;player3
   1559  aa3d		       a8 2a 0a 80	      HEX	a82a0a80
   1560  aa41							;player4
   1561  aa41		       00 00 00 00	      HEX	00000000
   1562  aa45							;title00
   1563  aa45		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1564  aa65		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1565  aa75							;title01
   1566  aa75		       fa fa fa c8*	      HEX	fafafac800000000000032fafafa0000000032fafafafafafafafafafac80000
   1567  aa95		       00 00 fa fa*	      HEX	0000fafafac800000000000000000000
   1568  aaa5
   1569  ab00					      ORG	$AB00,0	; *************
   1570  ab00
   1571  ab00					      RORG	$AB00	; *************
   1572  ab00
   1573  ab00							;font
   1574  ab00		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   1575  ab20		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   1576  ab35							;player1
   1577  ab35		       ff ff ff c0	      HEX	ffffffc0
   1578  ab39							;player2
   1579  ab39		       ab ea fa 80	      HEX	abeafa80
   1580  ab3d							;player3
   1581  ab3d		       ff ff ff c0	      HEX	ffffffc0
   1582  ab41							;player4
   1583  ab41		       ff ff ff c0	      HEX	ffffffc0
   1584  ab45							;title00
   1585  ab45		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   1586  ab65		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a5a5
   1587  ab75							;title01
   1588  ab75		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1589  ab95		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1590  aba5
   1591  ac00					      ORG	$AC00,0	; *************
   1592  ac00
   1593  ac00					      RORG	$AC00	; *************
   1594  ac00
   1595  ac00							;font
   1596  ac00		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   1597  ac20		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   1598  ac35							;player1
   1599  ac35		       a8 2a 0a 80	      HEX	a82a0a80
   1600  ac39							;player2
   1601  ac39		       00 00 00 00	      HEX	00000000
   1602  ac3d							;player3
   1603  ac3d		       00 00 00 00	      HEX	00000000
   1604  ac41							;player4
   1605  ac41		       00 00 00 00	      HEX	00000000
   1606  ac45							;title00
   1607  ac45		       a5 a5 a5 84*	      HEX	a5a5a58400000000000021a5a5a50000000000000021a5a5a5a5840000000000
   1608  ac65		       00 00 a5 a5*	      HEX	0000a5a5a5a5a5a5a5a5a5a5a5a5a584
   1609  ac75							;title01
   1610  ac75		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   1611  ac95		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0800000
   1612  aca5
   1613  ad00					      ORG	$AD00,0	; *************
   1614  ad00
   1615  ad00					      RORG	$AD00	; *************
   1616  ad00
   1617  ad00							;font
   1618  ad00		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   1619  ad20		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   1620  ad35							;player1
   1621  ad35		       55 55 55 40	      HEX	55555540
   1622  ad39							;player2
   1623  ad39		       55 55 55 40	      HEX	55555540
   1624  ad3d							;player3
   1625  ad3d		       55 55 55 40	      HEX	55555540
   1626  ad41							;player4
   1627  ad41		       55 55 55 40	      HEX	55555540
   1628  ad45							;title00
   1629  ad45		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1630  ad65		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1631  ad75							;title01
   1632  ad75		       a0 a0 a0 80*	      HEX	a0a0a08000000000000020a0a0a00000000000a0a0a0a0a0a0a0a0a0a0000000
   1633  ad95		       00 00 a0 a0*	      HEX	0000a0a0a0a0a0a0a0a0a0a0a0a08000
   1634  ada5
   1635  ae00					      ORG	$AE00,0	; *************
   1636  ae00
   1637  ae00					      RORG	$AE00	; *************
   1638  ae00
   1639  ae00							;font
   1640  ae00		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   1641  ae20		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   1642  ae35							;player1
   1643  ae35		       15 55 55 00	      HEX	15555500
   1644  ae39							;player2
   1645  ae39		       15 55 55 00	      HEX	15555500
   1646  ae3d							;player3
   1647  ae3d		       15 55 55 00	      HEX	15555500
   1648  ae41							;player4
   1649  ae41		       15 55 55 00	      HEX	15555500
   1650  ae45							;title00
   1651  ae45		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a00000000000000005a5a5a5a000000000000
   1652  ae65		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a5a00
   1653  ae75							;title01
   1654  ae75		       50 50 50 50*	      HEX	5050505050505050505050505050505050505050505050505050505050505050
   1655  ae95		       50 50 50 50*	      HEX	50505050505050505050505050505050
   1656  aea5
   1657  af00					      ORG	$AF00,0	; *************
   1658  af00
   1659  af00					      RORG	$AF00	; *************
   1660  af00
   1661  af00							;font
   1662  af00		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   1663  af20		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   1664  af35							;player1
   1665  af35		       05 f5 7c 00	      HEX	05f57c00
   1666  af39							;player2
   1667  af39		       07 d5 f4 00	      HEX	07d5f400
   1668  af3d							;player3
   1669  af3d		       0f 57 d4 00	      HEX	0f57d400
   1670  af41							;player4
   1671  af41		       0d 5f 5c 00	      HEX	0d5f5c00
   1672  af45							;title00
   1673  af45		       5a 5a 5a 48*	      HEX	5a5a5a48000000000000125a5a5a0000000000000000125a5a48000000000000
   1674  af65		       00 00 5a 5a*	      HEX	00005a5a5a5a5a5a5a5a5a5a5a5a0000
   1675  af75							;title01
   1676  af75		       f0 f0 f0 c0*	      HEX	f0f0f0c000000000000030f0f0f0000000000030f0f0f0f0f0f0f0f0c0000000
   1677  af95		       00 00 f0 f0*	      HEX	0000f0f0f0f0f0f0f0f0f0f0f0f0f000
   1678  afa5
   1679  b000					      ORG	$B000,0	; *************
   1680  b000
   1681  b000					      RORG	$B000	; *************
   1682  b000				  -	      if	SPACEOVERFLOW > 0
   1683  b000				  -	      echo	""
   1684  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   1685  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   1686  b000				  -	      echo	"######## Aborting assembly."
   1687  b000				  -	      ERR
   1688  b000					      endif
   1689  b000
   1690  b000
   1691  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1692  b000
   1693  b000				  -	      ifnconst	bankswitchmode
   1694  b000				  -	      if	( * < $f000 )
   1695  b000				  -	      ORG	$F000
   1696  b000				  -	      endif
   1697  b000					      else
   1698  b000					      ifconst	ROM128K
   1699  b000					      if	( * < $f000 )
   1700  27000					       ORG	$27000
   1701  27000					       RORG	$F000
   1702  27000					       endif
   1703  27000					       endif
   1704  27000				   -	       ifconst	ROM144K
   1705  27000				   -	       if	( * < $f000 )
   1706  27000				   -	       ORG	$27000
   1707  27000				   -	       RORG	$F000
   1708  27000				   -	       endif
   1709  27000					       endif
   1710  27000				   -	       ifconst	ROM256K
   1711  27000				   -	       if	( * < $f000 )
   1712  27000				   -	       ORG	$47000
   1713  27000				   -	       RORG	$F000
   1714  27000				   -	       endif
   1715  27000					       endif
   1716  27000				   -	       ifconst	ROM272K
   1717  27000				   -	       if	( * < $f000 )
   1718  27000				   -	       ORG	$47000
   1719  27000				   -	       RORG	$F000
   1720  27000				   -	       endif
   1721  27000					       endif
   1722  27000				   -	       ifconst	ROM512K
   1723  27000				   -	       if	( * < $f000 )
   1724  27000				   -	       ORG	$87000
   1725  27000				   -	       RORG	$F000
   1726  27000				   -	       endif
   1727  27000					       endif
   1728  27000				   -	       ifconst	ROM528K
   1729  27000				   -	       if	( * < $f000 )
   1730  27000				   -	       ORG	$87000
   1731  27000				   -	       RORG	$F000
   1732  27000				   -	       endif
   1733  27000					       endif
   1734  27000					       endif
   1735  27000
   1736  27000							; all of these "modules" have conditional clauses in them, so even though
   1737  27000							; they're always included here, they don't take up rom unless the user
   1738  27000							; explicitly enables support for the feature.
   1739  27000
   1740  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or Atari 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* Warnings:
     15  27000				   -			;*
     16  27000				   -			;* 1. RMT player routine needs 19 itself reserved bytes in zero page (no accessed
     17  27000				   -			;*    from any other routines) as well as cca 1KB of memory before the "PLAYER"
     18  27000				   -			;*    address for frequency tables and functionary variables. It's:
     19  27000				   -			;*	  a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     20  27000				   -			;*    b) from PLAYER-$380 to PLAYER for mono RMTplayer
     21  27000				   -			;*
     22  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER points
     23  27000				   -			;*	  to the start of the frequency tables. The player routines follows after
     24  27000				   -			;*	  that. The variables are now independent and can be located with
     25  27000				   -			;*	  PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     26  27000				   -			;*
     27  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled from the begin of the memory page.
     28  27000				   -			;*    i.e. "PLAYER" address can be $..00 only!
     29  27000				   -			;*
     30  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of CPU time.
     31  27000				   -			;*
     32  27000				   -			;*
     33  27000				   -			;* Define the following equates here or in your main code file.
     34  27000				   -			;* Set the values according to the system you compile for.
     35  27000				   -			;*
     36  27000				   -
     37  27000				   -POKEY_BASE equ	pokeyaddress
     38  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	; player routine needs 19 bytes of zero page RAM
     39  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;variables in main RAM - 173 bytes mono - 337 stereo
     40  27000				   -ROM_BASED  equ	1	;using a ROM based system - no self modifying code
     41  27000				   -STEREO8T   equ	0	;0 => compile RMTplayer for mono 4 tracks
     42  27000				   -			;				    ;1 => compile RMTplayer for stereo 8 tracks
     43  27000				   -
     44  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     45  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     46  27000				   -
     47  27000				   -			;*
     48  27000				   -
     49  27000				   -	       IF	STEREO8T
     50  27000				   -TRACKS     equ	8
     51  27000				   -	       ELSE
     52  27000				   -TRACKS     equ	4
     53  27000				   -	       EIF
     54  27000				   -
     55  27000				   -			;*
     56  27000				   -			;* RMT FEATures definitions
     57  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     58  27000				   -			;* --------BEGIN--------
     59  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     60  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
     61  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     62  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     63  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     64  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     65  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     66  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     67  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     68  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     69  27000				   -			;* PORTAMENTO
     70  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     71  27000				   -			;* FILTER
     72  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     73  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     74  27000				   -FEAT_FILTERG1L equ	1
     75  27000				   -FEAT_FILTERG0R equ	1
     76  27000				   -FEAT_FILTERG1R equ	1
     77  27000				   -			;* BASS16B (i.e. distortion value 6)
     78  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and quicker whole RMT routine
     79  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     80  27000				   -FEAT_BASS16G3L equ	1
     81  27000				   -FEAT_BASS16G1R equ	1
     82  27000				   -FEAT_BASS16G3R equ	1
     83  27000				   -			;* VOLUME ONLY for particular generators
     84  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     85  27000				   -FEAT_VOLUMEONLYG2L equ	1
     86  27000				   -FEAT_VOLUMEONLYG3L equ	1
     87  27000				   -FEAT_VOLUMEONLYG0R equ	1
     88  27000				   -FEAT_VOLUMEONLYG2R equ	1
     89  27000				   -FEAT_VOLUMEONLYG3R equ	1
     90  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
     91  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
     92  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
     93  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
     94  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
     95  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
     96  27000				   -			;* --------END--------
     97  27000				   -			;*
     98  27000				   -			;*
     99  27000				   -			;* RMT ZeroPage addresses
    100  27000				   -
    101  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    102  27000				   -p_tis      =	MEMLOC
    103  27000				   -p_instrstable =	MEMLOC
    104  27000				   -MEMLOC     SET	(MEMLOC+2)
    105  27000				   -p_trackslbstable =	MEMLOC
    106  27000				   -MEMLOC     SET	(MEMLOC+2)
    107  27000				   -p_trackshbstable =	MEMLOC
    108  27000				   -MEMLOC     SET	(MEMLOC+2)
    109  27000				   -p_song     =	MEMLOC
    110  27000				   -MEMLOC     SET	(MEMLOC+2)
    111  27000				   -
    112  27000				   -_ns        =	MEMLOC
    113  27000				   -MEMLOC     SET	(MEMLOC+2)
    114  27000				   -_nr        =	MEMLOC
    115  27000				   -MEMLOC     SET	(MEMLOC+2)
    116  27000				   -_nt        =	MEMLOC
    117  27000				   -MEMLOC     SET	(MEMLOC+2)
    118  27000				   -
    119  27000				   -rmtreg1    =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+1)
    121  27000				   -rmtreg2    =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+1)
    123  27000				   -rmtreg3    =	MEMLOC
    124  27000				   -MEMLOC     SET	(MEMLOC+1)
    125  27000				   -_tmp       =	MEMLOC
    126  27000				   -MEMLOC     SET	(MEMLOC+1)
    127  27000				   -	       IF	FEAT_COMMAND2
    128  27000				   -frqaddcmd2 =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+1)
    130  27000				   -	       EIF
    131  27000				   -
    132  27000				   -			;*
    133  27000				   -			;* Variables in main RAM used by player routine.
    134  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    135  27000				   -			;*
    136  27000				   -
    137  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    138  27000				   -track_variables =	MEMLOC
    139  27000				   -
    140  27000				   -trackn_db  =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    142  27000				   -trackn_hb  =	MEMLOC
    143  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    144  27000				   -trackn_idx =	MEMLOC
    145  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    146  27000				   -trackn_pause =	MEMLOC
    147  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    148  27000				   -trackn_note =	MEMLOC
    149  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    150  27000				   -trackn_volume =	MEMLOC
    151  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    152  27000				   -trackn_distor =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_shiftfrq =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -
    157  27000				   -	       IF	FEAT_PORTAMENTO
    158  27000				   -trackn_portafrqc =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_portafrqa =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_portaspeed =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_portaspeeda =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_portadepth =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -	       EIF
    169  27000				   -
    170  27000				   -trackn_instrx2 =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_instrdb =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_instrhb =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_instridx =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_instrlen =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -trackn_instrlop =	MEMLOC
    181  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    182  27000				   -trackn_instrreachend =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_volumeslidedepth =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_volumeslidevalue =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_volumemin =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_effdelay =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_effvibratoa =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_effvibratobeg =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_effvibratoend =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_effshift =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_tabletypespeed =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -
    203  27000				   -	       IF	FEAT_TABLEMODE
    204  27000				   -trackn_tablemode =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -	       EIF
    207  27000				   -
    208  27000				   -trackn_tablenote =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -
    211  27000				   -trackn_tablea =	MEMLOC
    212  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    213  27000				   -trackn_tableend =	MEMLOC
    214  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    215  27000				   -trackn_tablelop =	MEMLOC
    216  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    217  27000				   -trackn_tablespeeda =	MEMLOC
    218  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    219  27000				   -trackn_command =	MEMLOC
    220  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    221  27000				   -
    222  27000				   -	       IF	FEAT_BASS16
    223  27000				   -trackn_outnote =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -	       EIF
    226  27000				   -	       IF	FEAT_FILTER
    227  27000				   -trackn_filter =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -	       EIF
    230  27000				   -
    231  27000				   -trackn_audf =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -trackn_audc =	MEMLOC
    234  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    235  27000				   -
    236  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    237  27000				   -trackn_audctl =	MEMLOC
    238  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    239  27000				   -	       EIF
    240  27000				   -
    241  27000				   -v_audctl   =	MEMLOC
    242  27000				   -MEMLOC     SET	(MEMLOC+1)
    243  27000				   -v_audctl2  =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+1)
    245  27000				   -v_speed    =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+1)
    247  27000				   -v_aspeed   =	MEMLOC
    248  27000				   -MEMLOC     SET	(MEMLOC+1)
    249  27000				   -v_bspeed   =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+1)
    251  27000				   -v_instrspeed =	MEMLOC
    252  27000				   -MEMLOC     SET	(MEMLOC+1)
    253  27000				   -v_ainstrspeed =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_maxtracklen =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_abeat    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -
    260  27000				   -track_endvariables =	MEMLOC
    261  27000				   -
    262  27000				   -			;*
    263  27000				   -			;* Data tables used by player routine.
    264  27000				   -			;*
    265  27000				   -	       ALIGN	256
    266  27000				   -PLAYER     =	.
    267  27000				   -
    268  27000				   -volumetab
    269  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    270  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    271  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    272  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    273  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    274  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    275  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    276  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    277  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    278  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    279  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    280  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    281  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    282  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    283  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    284  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    285  27000				   -
    286  27000				   -frqtab
    287  27000				   -			;	ERT [<frqtab]!=0	;* frqtab must begin at the memory page bound! (i.e. $..00 address)
    288  27000				   -frqtabbass1
    289  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    290  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    291  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    292  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    293  27000				   -frqtabbass2
    294  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    295  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    296  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    297  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    298  27000				   -frqtabpure
    299  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    300  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    301  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    302  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    303  27000				   -	       IF	FEAT_BASS16
    304  27000				   -frqtabbasshi
    305  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    306  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    307  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    308  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    309  27000				   -	       EIF
    310  27000				   -
    311  27000				   -	       IF	FEAT_BASS16
    312  27000				   -frqtabbasslo
    313  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    314  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    315  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    316  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    317  27000				   -	       EIF
    318  27000				   -
    319  27000				   -	       IF	ROM_BASED
    320  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    321  27000				   -	       EIF
    322  27000				   -INSTRPAR   equ	12
    323  27000				   -tabbeganddistor
    324  27000				   -	       dc.b	frqtabpure-frqtab,$00
    325  27000				   -	       dc.b	frqtabpure-frqtab,$20
    326  27000				   -	       dc.b	frqtabpure-frqtab,$40
    327  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    328  27000				   -	       dc.b	frqtabpure-frqtab,$80
    329  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    330  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    331  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    332  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    333  27000				   -vib0       dc.b	0
    334  27000				   -vib1       dc.b	1,-1,-1,1
    335  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    336  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    337  27000				   -vibx
    338  27000				   -emptytrack
    339  27000				   -	       dc.b	62,0
    340  27000				   -
    341  27000				   -			;*
    342  27000				   -			;* Set of RMT main vectors:
    343  27000				   -			;*
    344  27000				   -RASTERMUSICTRACKER
    345  27000				   -	       jmp	rmt_init
    346  27000				   -	       jmp	rmt_play
    347  27000				   -	       jmp	rmt_p3
    348  27000				   -	       jmp	rmt_silence
    349  27000				   -	       jmp	SetPokey
    350  27000				   -rmt_init
    351  27000				   -	       stx	_ns
    352  27000				   -	       sty	_ns+1
    353  27000				   -	       pha
    354  27000				   -	       IF	track_endvariables-track_variables>255
    355  27000				   -	       ldy	#0
    356  27000				   -	       tya
    357  27000				   -rmtri0     sta	track_variables,y
    358  27000				   -	       sta	track_endvariables-$100,y
    359  27000				   -	       iny
    360  27000				   -	       bne	rmtri0
    361  27000				   -	       ELSE
    362  27000				   -	       ldy	#track_endvariables-track_variables
    363  27000				   -	       lda	#0
    364  27000				   -rmtri0     sta	track_variables-1,y
    365  27000				   -	       dey
    366  27000				   -	       bne	rmtri0
    367  27000				   -	       EIF
    368  27000				   -	       ldy	#4
    369  27000				   -	       lda	(_ns),y
    370  27000				   -	       sta	v_maxtracklen
    371  27000				   -	       iny
    372  27000				   -	       lda	(_ns),y
    373  27000				   -	       sta	v_speed
    374  27000				   -	       iny
    375  27000				   -	       lda	(_ns),y
    376  27000				   -	       sta	v_instrspeed
    377  27000				   -	       sta	v_ainstrspeed
    378  27000				   -	       ldy	#8
    379  27000				   -rmtri1     lda	(_ns),y
    380  27000				   -	       sta	p_tis-8,y
    381  27000				   -	       iny
    382  27000				   -	       cpy	#8+8
    383  27000				   -	       bne	rmtri1
    384  27000				   -	       pla
    385  27000				   -	       pha
    386  27000				   -	       IF	STEREO8T
    387  27000				   -	       asl
    388  27000				   -	       asl
    389  27000				   -	       asl
    390  27000				   -	       clc
    391  27000				   -	       adc	p_song
    392  27000				   -	       sta	p_song
    393  27000				   -	       pla
    394  27000				   -	       and	#$e0
    395  27000				   -	       asl
    396  27000				   -	       rol
    397  27000				   -	       rol
    398  27000				   -	       rol
    399  27000				   -	       ELSE
    400  27000				   -	       asl
    401  27000				   -	       asl
    402  27000				   -	       clc
    403  27000				   -	       adc	p_song
    404  27000				   -	       sta	p_song
    405  27000				   -	       pla
    406  27000				   -	       and	#$c0
    407  27000				   -	       asl
    408  27000				   -	       rol
    409  27000				   -	       rol
    410  27000				   -	       EIF
    411  27000				   -	       adc	p_song+1
    412  27000				   -	       sta	p_song+1
    413  27000				   -	       jsr	GetSongLine
    414  27000				   -	       jsr	GetTrackLine
    415  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    416  27000				   -	       jsr	rmt_silence
    417  27000				   -	       lda	v_instrspeed
    418  27000				   -	       rts
    419  27000				   -rmt_silence
    420  27000				   -	       IF	STEREO8T
    421  27000				   -	       lda	#0
    422  27000				   -	       sta	POKEY_BASE+$08
    423  27000				   -	       sta	POKEY_BASE_S+$08
    424  27000				   -	       ldy	#3
    425  27000				   -	       sty	POKEY_BASE+$0f
    426  27000				   -	       sty	POKEY_BASE_S+$0f
    427  27000				   -	       ldy	#8
    428  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    429  27000				   -	       sta	POKEY_BASE_S+$00,y
    430  27000				   -	       dey
    431  27000				   -	       bpl	rmtsi1
    432  27000				   -	       ELSE
    433  27000				   -	       lda	#0
    434  27000				   -	       sta	POKEY_BASE+$08
    435  27000				   -	       ldy	#3
    436  27000				   -	       sty	POKEY_BASE+$0f
    437  27000				   -	       ldy	#8
    438  27000				   -rmtsi1     sta	POKEY_BASE+$00,y
    439  27000				   -	       dey
    440  27000				   -	       bpl	rmtsi1
    441  27000				   -	       EIF
    442  27000				   -	       rts
    443  27000				   -GetSongLine
    444  27000				   -	       ldx	#0
    445  27000				   -	       stx	v_abeat
    446  27000				   -rmtnn0
    447  27000				   -	       ldx	#0
    448  27000				   -rmtnn1     txa
    449  27000				   -	       tay
    450  27000				   -	       lda	(p_song),y
    451  27000				   -	       cmp	#$fe
    452  27000				   -	       bcs	rmtnn2
    453  27000				   -	       tay
    454  27000				   -	       lda	(p_trackslbstable),y
    455  27000				   -	       sta	trackn_db,x
    456  27000				   -	       lda	(p_trackshbstable),y
    457  27000				   -rmtnn1a    sta	trackn_hb,x
    458  27000				   -	       lda	#0
    459  27000				   -	       sta	trackn_idx,x
    460  27000				   -	       lda	#1
    461  27000				   -	       sta	trackn_pause,x
    462  27000				   -	       lda	#$80
    463  27000				   -	       sta	trackn_instrx2,x
    464  27000				   -	       inx
    465  27000				   -	       cpx	#TRACKS
    466  27000				   -	       bne	rmtnn1
    467  27000				   -	       lda	p_song
    468  27000				   -	       clc
    469  27000				   -	       adc	#TRACKS
    470  27000				   -	       sta	p_song
    471  27000				   -	       bcc	rmtnn1b
    472  27000				   -	       inc	p_song+1
    473  27000				   -rmtnn1b
    474  27000				   -	       rts
    475  27000				   -rmtnn2
    476  27000				   -	       beq	rmtnn3
    477  27000				   -rmtnn2a    lda	#<emptytrack
    478  27000				   -	       sta	trackn_db,x
    479  27000				   -	       lda	#>emptytrack
    480  27000				   -	       jmp	rmtnn1a
    481  27000				   -rmtnn3
    482  27000				   -	       ldy	#2
    483  27000				   -	       lda	(p_song),y
    484  27000				   -	       tax
    485  27000				   -	       iny
    486  27000				   -	       lda	(p_song),y
    487  27000				   -	       sta	p_song+1
    488  27000				   -	       stx	p_song
    489  27000				   -	       jmp	rmtnn0
    490  27000				   -GetTrackLine
    491  27000				   -rmtoo0
    492  27000				   -rmtoo0a
    493  27000				   -	       lda	v_speed
    494  27000				   -	       sta	v_bspeed
    495  27000				   -	       ldx	#0
    496  27000				   -rmtoo1
    497  27000				   -	       lda	trackn_pause,x
    498  27000				   -	       beq	rmtoo1x
    499  27000				   -	       dec	trackn_pause,x
    500  27000				   -	       bne	rmtoo1x
    501  27000				   -	       inc	trackn_pause,x
    502  27000				   -rmtoo1b
    503  27000				   -	       lda	trackn_db,x
    504  27000				   -	       sta	_ns
    505  27000				   -	       lda	trackn_hb,x
    506  27000				   -	       sta	_ns+1
    507  27000				   -rmtoo1i
    508  27000				   -	       ldy	trackn_idx,x
    509  27000				   -	       lda	(_ns),y
    510  27000				   -	       sta	rmtreg1
    511  27000				   -	       iny
    512  27000				   -	       lda	(_ns),y
    513  27000				   -	       sta	rmtreg2
    514  27000				   -	       iny
    515  27000				   -	       tya
    516  27000				   -	       sta	trackn_idx,x
    517  27000				   -	       lda	rmtreg1
    518  27000				   -	       and	#$3f
    519  27000				   -	       cmp	#61
    520  27000				   -	       beq	rmtoo1a
    521  27000				   -	       bcs	rmtoo2
    522  27000				   -	       sta	trackn_note,x
    523  27000				   -	       IF	FEAT_BASS16
    524  27000				   -	       sta	trackn_outnote,x
    525  27000				   -	       EIF
    526  27000				   -	       lda	rmtreg2
    527  27000				   -	       lsr
    528  27000				   -	       and	#$3f*2
    529  27000				   -	       sta	trackn_instrx2,x
    530  27000				   -rmtoo1a    lda	rmtreg2
    531  27000				   -	       lsr
    532  27000				   -	       ror	rmtreg1
    533  27000				   -	       lsr
    534  27000				   -	       ror	rmtreg1
    535  27000				   -	       lda	rmtreg1
    536  27000				   -	       and	#$f0
    537  27000				   -	       sta	trackn_volume,x
    538  27000				   -rmtoo1x
    539  27000				   -	       inx
    540  27000				   -	       cpx	#TRACKS
    541  27000				   -	       bne	rmtoo1
    542  27000				   -	       lda	v_bspeed
    543  27000				   -	       sta	v_speed
    544  27000				   -	       sta	v_aspeed
    545  27000				   -	       rts
    546  27000				   -rmtoo2
    547  27000				   -	       cmp	#63
    548  27000				   -	       beq	rmtoo63
    549  27000				   -	       lda	rmtreg1
    550  27000				   -	       and	#$c0
    551  27000				   -	       beq	rmtoo62_b
    552  27000				   -	       asl
    553  27000				   -	       rol
    554  27000				   -	       rol
    555  27000				   -	       sta	trackn_pause,x
    556  27000				   -	       dec	trackn_idx,x
    557  27000				   -	       jmp	rmtoo1x
    558  27000				   -rmtoo62_b
    559  27000				   -	       lda	rmtreg2
    560  27000				   -	       sta	trackn_pause,x
    561  27000				   -	       jmp	rmtoo1x
    562  27000				   -rmtoo63
    563  27000				   -	       lda	rmtreg1
    564  27000				   -	       bmi	rmtoo63_1X
    565  27000				   -	       lda	rmtreg2
    566  27000				   -	       sta	v_bspeed
    567  27000				   -	       jmp	rmtoo1i
    568  27000				   -rmtoo63_1X
    569  27000				   -	       cmp	#255
    570  27000				   -	       beq	rmtoo63_11
    571  27000				   -	       lda	rmtreg2
    572  27000				   -	       sta	trackn_idx,x
    573  27000				   -	       jmp	rmtoo1i
    574  27000				   -rmtoo63_11
    575  27000				   -	       jsr	GetSongLine
    576  27000				   -	       jmp	rmtoo0
    577  27000				   -InitOfNewSetInstrumentsOnly
    578  27000				   -	       ldx	#0
    579  27000				   -p2x1       ldy	trackn_instrx2,x
    580  27000				   -	       bmi	p2x2
    581  27000				   -	       jsr	SetUpInstrumentY2
    582  27000				   -	       lda	#$80
    583  27000				   -	       sta	trackn_instrx2,x
    584  27000				   -p2x2
    585  27000				   -	       inx
    586  27000				   -	       cpx	#TRACKS
    587  27000				   -	       bne	p2x1
    588  27000				   -	       rts
    589  27000				   -rmt_play
    590  27000				   -rmt_p0
    591  27000				   -	       jsr	SetPokey
    592  27000				   -rmt_p1
    593  27000				   -	       dec	v_ainstrspeed
    594  27000				   -	       beq	rmtp1a
    595  27000				   -	       jmp	rmt_p3
    596  27000				   -rmtp1a
    597  27000				   -	       lda	v_instrspeed
    598  27000				   -	       sta	v_ainstrspeed
    599  27000				   -rmt_p2
    600  27000				   -	       dec	v_aspeed
    601  27000				   -	       bne	rmt_p3
    602  27000				   -	       inc	v_abeat
    603  27000				   -	       lda	v_abeat
    604  27000				   -	       cmp	v_maxtracklen
    605  27000				   -	       bne	rmtp2o2
    606  27000				   -	       jsr	GetSongLine
    607  27000				   -rmtp2o2
    608  27000				   -	       jsr	GetTrackLine
    609  27000				   -	       jmp	rmt_p2X
    610  27000				   -go_ppnext  jmp	ppnext
    611  27000				   -rmt_p2X
    612  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    613  27000				   -rmt_p3
    614  27000				   -	       lda	#>frqtab
    615  27000				   -	       sta	_nr+1
    616  27000				   -	       ldx	#0
    617  27000				   -rmtpp1
    618  27000				   -	       lda	trackn_instrhb,x
    619  27000				   -	       beq	go_ppnext
    620  27000				   -	       sta	_ns+1
    621  27000				   -	       lda	trackn_instrdb,x
    622  27000				   -	       sta	_ns
    623  27000				   -	       ldy	trackn_instridx,x
    624  27000				   -	       lda	(_ns),y
    625  27000				   -	       sta	rmtreg1
    626  27000				   -	       iny
    627  27000				   -	       lda	(_ns),y
    628  27000				   -	       sta	rmtreg2
    629  27000				   -	       iny
    630  27000				   -	       lda	(_ns),y
    631  27000				   -	       sta	rmtreg3
    632  27000				   -	       iny
    633  27000				   -	       tya
    634  27000				   -	       cmp	trackn_instrlen,x
    635  27000				   -	       bcc	rmtpp2
    636  27000				   -	       beq	rmtpp2
    637  27000				   -	       lda	#$80
    638  27000				   -	       sta	trackn_instrreachend,x
    639  27000				   -rmtpp1b
    640  27000				   -	       lda	trackn_instrlop,x
    641  27000				   -rmtpp2     sta	trackn_instridx,x
    642  27000				   -	       lda	rmtreg1
    643  27000				   -	       IF	STEREO8T
    644  27000				   -	       cpx	#4
    645  27000				   -	       bcc	rmtpp2s
    646  27000				   -	       lsr
    647  27000				   -	       lsr
    648  27000				   -	       lsr
    649  27000				   -	       lsr
    650  27000				   -rmtpp2s
    651  27000				   -	       EIF
    652  27000				   -	       and	#$0f
    653  27000				   -	       ora	trackn_volume,x
    654  27000				   -	       tay
    655  27000				   -	       lda	volumetab,y
    656  27000				   -	       pha
    657  27000				   -	       lda	rmtreg2
    658  27000				   -	       and	#$0e
    659  27000				   -	       tay
    660  27000				   -	       lda	tabbeganddistor,y
    661  27000				   -	       sta	_nr
    662  27000				   -	       pla
    663  27000				   -	       ora	tabbeganddistor+1,y
    664  27000				   -	       sta	trackn_audc,x
    665  27000				   -	       jmp	InstrumentsEffects
    666  27000				   -returnfromInstrumentsEffects
    667  27000				   -	       IF	FEAT_COMMAND2
    668  27000				   -	       lda	#0
    669  27000				   -	       sta	frqaddcmd2
    670  27000				   -	       EIF
    671  27000				   -	       lda	rmtreg2
    672  27000				   -	       sta	trackn_command,x
    673  27000				   -	       and	#$70
    674  27000				   -	       lsr
    675  27000				   -	       lsr
    676  27000				   -	       IF	ROM_BASED
    677  27000				   -	       lsr
    678  27000				   -	       tay
    679  27000				   -	       lda	rts_tab+1,y
    680  27000				   -	       pha
    681  27000				   -	       lda	rts_tab,y
    682  27000				   -	       pha
    683  27000				   -	       rts
    684  27000				   -	       ELSE
    685  27000				   -	       sta	jmx+1
    686  27000				   -jmx        bcc	*
    687  27000				   -	       jmp	cmd0
    688  27000				   -	       nop
    689  27000				   -	       jmp	cmd1
    690  27000				   -	       nop
    691  27000				   -	       jmp	cmd2
    692  27000				   -	       nop
    693  27000				   -	       jmp	cmd3
    694  27000				   -	       nop
    695  27000				   -	       jmp	cmd4
    696  27000				   -	       nop
    697  27000				   -	       jmp	cmd5
    698  27000				   -	       nop
    699  27000				   -	       jmp	cmd6
    700  27000				   -	       nop
    701  27000				   -	       jmp	cmd7
    702  27000				   -	       EIF
    703  27000				   -cmd0
    704  27000				   -	       lda	trackn_note,x
    705  27000				   -	       clc
    706  27000				   -	       adc	rmtreg3
    707  27000				   -cmd0a
    708  27000				   -	       IF	FEAT_TABLETYPE
    709  27000				   -	       ldy	trackn_tabletypespeed,x
    710  27000				   -	       bmi	cmd0b
    711  27000				   -	       EIF
    712  27000				   -	       clc
    713  27000				   -	       adc	trackn_tablenote,x
    714  27000				   -	       cmp	#61
    715  27000				   -	       bcc	cmd0a1
    716  27000				   -	       lda	#0
    717  27000				   -	       sta	trackn_audc,x
    718  27000				   -	       lda	#63
    719  27000				   -cmd0a1
    720  27000				   -	       IF	FEAT_BASS16
    721  27000				   -	       sta	trackn_outnote,x
    722  27000				   -	       EIF
    723  27000				   -	       tay
    724  27000				   -	       lda	(_nr),y
    725  27000				   -	       clc
    726  27000				   -	       adc	trackn_shiftfrq,x
    727  27000				   -	       IF	FEAT_COMMAND2
    728  27000				   -	       clc
    729  27000				   -	       adc	frqaddcmd2
    730  27000				   -	       EIF
    731  27000				   -	       sta	trackn_audf,x
    732  27000				   -	       jmp	rmtpp9
    733  27000				   -	       IF	FEAT_TABLETYPE
    734  27000				   -cmd0b
    735  27000				   -	       cmp	#61
    736  27000				   -	       bcc	cmd0b1
    737  27000				   -	       lda	#0
    738  27000				   -	       sta	trackn_audc,x
    739  27000				   -	       lda	#63
    740  27000				   -cmd0b1
    741  27000				   -	       tay
    742  27000				   -	       lda	trackn_shiftfrq,x
    743  27000				   -	       clc
    744  27000				   -	       adc	trackn_tablenote,x
    745  27000				   -	       clc
    746  27000				   -	       adc	(_nr),y
    747  27000				   -	       IF	FEAT_COMMAND2
    748  27000				   -	       clc
    749  27000				   -	       adc	frqaddcmd2
    750  27000				   -	       EIF
    751  27000				   -	       sta	trackn_audf,x
    752  27000				   -	       jmp	rmtpp9
    753  27000				   -	       EIF
    754  27000				   -cmd1
    755  27000				   -	       IF	FEAT_COMMAND1
    756  27000				   -	       lda	rmtreg3
    757  27000				   -	       sta	trackn_audf,x
    758  27000				   -	       jmp	rmtpp9
    759  27000				   -	       EIF
    760  27000				   -cmd2
    761  27000				   -	       IF	FEAT_COMMAND2
    762  27000				   -	       lda	rmtreg3
    763  27000				   -	       sta	frqaddcmd2
    764  27000				   -	       lda	trackn_note,x
    765  27000				   -	       jmp	cmd0a
    766  27000				   -	       EIF
    767  27000				   -cmd3
    768  27000				   -	       IF	FEAT_COMMAND3
    769  27000				   -	       lda	trackn_note,x
    770  27000				   -	       clc
    771  27000				   -	       adc	rmtreg3
    772  27000				   -	       sta	trackn_note,x
    773  27000				   -	       jmp	cmd0a
    774  27000				   -	       EIF
    775  27000				   -cmd4
    776  27000				   -	       IF	FEAT_COMMAND4
    777  27000				   -	       lda	trackn_shiftfrq,x
    778  27000				   -	       clc
    779  27000				   -	       adc	rmtreg3
    780  27000				   -	       sta	trackn_shiftfrq,x
    781  27000				   -	       lda	trackn_note,x
    782  27000				   -	       jmp	cmd0a
    783  27000				   -	       EIF
    784  27000				   -cmd5
    785  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    786  27000				   -	       IF	FEAT_TABLETYPE
    787  27000				   -	       lda	trackn_tabletypespeed,x
    788  27000				   -	       bpl	cmd5a1
    789  27000				   -	       ldy	trackn_note,x
    790  27000				   -	       lda	(_nr),y
    791  27000				   -	       clc
    792  27000				   -	       adc	trackn_tablenote,x
    793  27000				   -	       jmp	cmd5ax
    794  27000				   -	       EIF
    795  27000				   -cmd5a1
    796  27000				   -	       lda	trackn_note,x
    797  27000				   -	       clc
    798  27000				   -	       adc	trackn_tablenote,x
    799  27000				   -	       cmp	#61
    800  27000				   -	       bcc	cmd5a2
    801  27000				   -	       lda	#63
    802  27000				   -cmd5a2
    803  27000				   -	       tay
    804  27000				   -	       lda	(_nr),y
    805  27000				   -cmd5ax
    806  27000				   -	       sta	trackn_portafrqc,x
    807  27000				   -	       ldy	rmtreg3
    808  27000				   -	       bne	cmd5a
    809  27000				   -	       sta	trackn_portafrqa,x
    810  27000				   -cmd5a
    811  27000				   -	       tya
    812  27000				   -	       lsr
    813  27000				   -	       lsr
    814  27000				   -	       lsr
    815  27000				   -	       lsr
    816  27000				   -	       sta	trackn_portaspeed,x
    817  27000				   -	       sta	trackn_portaspeeda,x
    818  27000				   -	       lda	rmtreg3
    819  27000				   -	       and	#$0f
    820  27000				   -	       sta	trackn_portadepth,x
    821  27000				   -	       lda	trackn_note,x
    822  27000				   -	       jmp	cmd0a
    823  27000				   -	       ELSE
    824  27000				   -	       IF	FEAT_COMMAND5
    825  27000				   -	       jmp	rmtpp9
    826  27000				   -	       EIF
    827  27000				   -	       EIF
    828  27000				   -cmd6
    829  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    830  27000				   -	       lda	rmtreg3
    831  27000				   -	       clc
    832  27000				   -	       adc	trackn_filter,x
    833  27000				   -	       sta	trackn_filter,x
    834  27000				   -	       lda	trackn_note,x
    835  27000				   -	       jmp	cmd0a
    836  27000				   -	       ELSE
    837  27000				   -	       IF	FEAT_COMMAND6
    838  27000				   -	       jmp	rmtpp9
    839  27000				   -	       EIF
    840  27000				   -	       EIF
    841  27000				   -cmd7
    842  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    843  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    844  27000				   -	       lda	rmtreg3
    845  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    846  27000				   -	       cmp	#$80
    847  27000				   -	       beq	cmd7a
    848  27000				   -	       EIF
    849  27000				   -	       sta	trackn_note,x
    850  27000				   -	       jmp	cmd0a
    851  27000				   -	       EIF
    852  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    853  27000				   -cmd7a
    854  27000				   -	       lda	trackn_audc,x
    855  27000				   -	       ora	#$f0
    856  27000				   -	       sta	trackn_audc,x
    857  27000				   -	       lda	trackn_note,x
    858  27000				   -	       jmp	cmd0a
    859  27000				   -	       EIF
    860  27000				   -	       EIF
    861  27000				   -rmtpp9
    862  27000				   -	       IF	FEAT_PORTAMENTO
    863  27000				   -	       lda	trackn_portaspeeda,x
    864  27000				   -	       beq	rmtpp10
    865  27000				   -	       sec
    866  27000				   -	       sbc	#1
    867  27000				   -	       sta	trackn_portaspeeda,x
    868  27000				   -	       bne	rmtpp10
    869  27000				   -	       lda	trackn_portaspeed,x
    870  27000				   -	       sta	trackn_portaspeeda,x
    871  27000				   -	       lda	trackn_portafrqa,x
    872  27000				   -	       cmp	trackn_portafrqc,x
    873  27000				   -	       beq	rmtpp10
    874  27000				   -	       bcs	pps1
    875  27000				   -	       adc	trackn_portadepth,x
    876  27000				   -	       bcs	pps8
    877  27000				   -	       cmp	trackn_portafrqc,x
    878  27000				   -	       bcs	pps8
    879  27000				   -	       jmp	pps9
    880  27000				   -pps1
    881  27000				   -	       sbc	trackn_portadepth,x
    882  27000				   -	       bcc	pps8
    883  27000				   -	       cmp	trackn_portafrqc,x
    884  27000				   -	       bcs	pps9
    885  27000				   -pps8
    886  27000				   -	       lda	trackn_portafrqc,x
    887  27000				   -pps9
    888  27000				   -	       sta	trackn_portafrqa,x
    889  27000				   -rmtpp10
    890  27000				   -	       lda	rmtreg2
    891  27000				   -	       and	#$01
    892  27000				   -	       beq	rmtpp11
    893  27000				   -	       lda	trackn_portafrqa,x
    894  27000				   -	       clc
    895  27000				   -	       adc	trackn_shiftfrq,x
    896  27000				   -	       sta	trackn_audf,x
    897  27000				   -rmtpp11
    898  27000				   -	       EIF
    899  27000				   -ppnext
    900  27000				   -	       inx
    901  27000				   -	       cpx	#TRACKS
    902  27000				   -	       beq	rmt_p4
    903  27000				   -	       jmp	rmtpp1
    904  27000				   -rmt_p4
    905  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    906  27000				   -	       ldx	#3
    907  27000				   -	       lda	#0
    908  27000				   -qq0        ora	trackn_audctl,x
    909  27000				   -	       dex
    910  27000				   -	       bpl	qq0
    911  27000				   -	       sta	v_audctl
    912  27000				   -qq1
    913  27000				   -	       ldx	v_audctl
    914  27000				   -	       ELSE
    915  27000				   -	       ldx	#0
    916  27000				   -	       stx	v_audctl
    917  27000				   -	       EIF
    918  27000				   -	       IF	FEAT_FILTER
    919  27000				   -	       IF	FEAT_FILTERG0L
    920  27000				   -	       lda	trackn_command+0
    921  27000				   -	       bpl	qq2
    922  27000				   -	       lda	trackn_audc+0
    923  27000				   -	       and	#$0f
    924  27000				   -	       beq	qq2
    925  27000				   -	       lda	trackn_audf+0
    926  27000				   -	       clc
    927  27000				   -	       adc	trackn_filter+0
    928  27000				   -	       sta	trackn_audf+2
    929  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
    930  27000				   -	       lda	trackn_audc+2
    931  27000				   -	       and	#$10
    932  27000				   -	       bne	qq1a
    933  27000				   -	       EIF
    934  27000				   -	       lda	#0
    935  27000				   -	       sta	trackn_audc+2
    936  27000				   -qq1a
    937  27000				   -	       txa
    938  27000				   -	       ora	#4
    939  27000				   -	       tax
    940  27000				   -	       EIF
    941  27000				   -qq2
    942  27000				   -	       IF	FEAT_FILTERG1L
    943  27000				   -	       lda	trackn_command+1
    944  27000				   -	       bpl	qq3
    945  27000				   -	       lda	trackn_audc+1
    946  27000				   -	       and	#$0f
    947  27000				   -	       beq	qq3
    948  27000				   -	       lda	trackn_audf+1
    949  27000				   -	       clc
    950  27000				   -	       adc	trackn_filter+1
    951  27000				   -	       sta	trackn_audf+3
    952  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
    953  27000				   -	       lda	trackn_audc+3
    954  27000				   -	       and	#$10
    955  27000				   -	       bne	qq2a
    956  27000				   -	       EIF
    957  27000				   -	       lda	#0
    958  27000				   -	       sta	trackn_audc+3
    959  27000				   -qq2a
    960  27000				   -	       txa
    961  27000				   -	       ora	#2
    962  27000				   -	       tax
    963  27000				   -	       EIF
    964  27000				   -qq3
    965  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
    966  27000				   -	       cpx	v_audctl
    967  27000				   -	       bne	qq5
    968  27000				   -	       EIF
    969  27000				   -	       EIF
    970  27000				   -	       IF	FEAT_BASS16
    971  27000				   -	       IF	FEAT_BASS16G1L
    972  27000				   -	       lda	trackn_command+1
    973  27000				   -	       and	#$0e
    974  27000				   -	       cmp	#6
    975  27000				   -	       bne	qq4
    976  27000				   -	       lda	trackn_audc+1
    977  27000				   -	       and	#$0f
    978  27000				   -	       beq	qq4
    979  27000				   -	       ldy	trackn_outnote+1
    980  27000				   -	       lda	frqtabbasslo,y
    981  27000				   -	       sta	trackn_audf+0
    982  27000				   -	       lda	frqtabbasshi,y
    983  27000				   -	       sta	trackn_audf+1
    984  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
    985  27000				   -	       lda	trackn_audc+0
    986  27000				   -	       and	#$10
    987  27000				   -	       bne	qq3a
    988  27000				   -	       EIF
    989  27000				   -	       lda	#0
    990  27000				   -	       sta	trackn_audc+0
    991  27000				   -qq3a
    992  27000				   -	       txa
    993  27000				   -	       ora	#$50
    994  27000				   -	       tax
    995  27000				   -	       EIF
    996  27000				   -qq4
    997  27000				   -	       IF	FEAT_BASS16G3L
    998  27000				   -	       lda	trackn_command+3
    999  27000				   -	       and	#$0e
   1000  27000				   -	       cmp	#6
   1001  27000				   -	       bne	qq5
   1002  27000				   -	       lda	trackn_audc+3
   1003  27000				   -	       and	#$0f
   1004  27000				   -	       beq	qq5
   1005  27000				   -	       ldy	trackn_outnote+3
   1006  27000				   -	       lda	frqtabbasslo,y
   1007  27000				   -	       sta	trackn_audf+2
   1008  27000				   -	       lda	frqtabbasshi,y
   1009  27000				   -	       sta	trackn_audf+3
   1010  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1011  27000				   -	       lda	trackn_audc+2
   1012  27000				   -	       and	#$10
   1013  27000				   -	       bne	qq4a
   1014  27000				   -	       EIF
   1015  27000				   -	       lda	#0
   1016  27000				   -	       sta	trackn_audc+2
   1017  27000				   -qq4a
   1018  27000				   -	       txa
   1019  27000				   -	       ora	#$28
   1020  27000				   -	       tax
   1021  27000				   -	       EIF
   1022  27000				   -	       EIF
   1023  27000				   -qq5
   1024  27000				   -	       stx	v_audctl
   1025  27000				   -	       IF	STEREO8T
   1026  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1027  27000				   -	       ldx	#3
   1028  27000				   -	       lda	#0
   1029  27000				   -qs0        ora	trackn_audctl+4,x
   1030  27000				   -	       dex
   1031  27000				   -	       bpl	qs0
   1032  27000				   -	       sta	v_audctl2
   1033  27000				   -qs1
   1034  27000				   -	       ldx	v_audctl2
   1035  27000				   -	       ELSE
   1036  27000				   -	       ldx	#0
   1037  27000				   -	       stx	v_audctl2
   1038  27000				   -	       EIF
   1039  27000				   -	       IF	FEAT_FILTER
   1040  27000				   -	       IF	FEAT_FILTERG0R
   1041  27000				   -	       lda	trackn_command+0+4
   1042  27000				   -	       bpl	qs2
   1043  27000				   -	       lda	trackn_audc+0+4
   1044  27000				   -	       and	#$0f
   1045  27000				   -	       beq	qs2
   1046  27000				   -	       lda	trackn_audf+0+4
   1047  27000				   -	       clc
   1048  27000				   -	       adc	trackn_filter+0+4
   1049  27000				   -	       sta	trackn_audf+2+4
   1050  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1051  27000				   -	       lda	trackn_audc+2+4
   1052  27000				   -	       and	#$10
   1053  27000				   -	       bne	qs1a
   1054  27000				   -	       EIF
   1055  27000				   -	       lda	#0
   1056  27000				   -	       sta	trackn_audc+2+4
   1057  27000				   -qs1a
   1058  27000				   -	       txa
   1059  27000				   -	       ora	#4
   1060  27000				   -	       tax
   1061  27000				   -	       EIF
   1062  27000				   -qs2
   1063  27000				   -	       IF	FEAT_FILTERG1R
   1064  27000				   -	       lda	trackn_command+1+4
   1065  27000				   -	       bpl	qs3
   1066  27000				   -	       lda	trackn_audc+1+4
   1067  27000				   -	       and	#$0f
   1068  27000				   -	       beq	qs3
   1069  27000				   -	       lda	trackn_audf+1+4
   1070  27000				   -	       clc
   1071  27000				   -	       adc	trackn_filter+1+4
   1072  27000				   -	       sta	trackn_audf+3+4
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1074  27000				   -	       lda	trackn_audc+3+4
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qs2a
   1077  27000				   -	       EIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+3+4
   1080  27000				   -qs2a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#2
   1083  27000				   -	       tax
   1084  27000				   -	       EIF
   1085  27000				   -qs3
   1086  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1087  27000				   -	       cpx	v_audctl2
   1088  27000				   -	       bne	qs5
   1089  27000				   -	       EIF
   1090  27000				   -	       EIF
   1091  27000				   -	       IF	FEAT_BASS16
   1092  27000				   -	       IF	FEAT_BASS16G1R
   1093  27000				   -	       lda	trackn_command+1+4
   1094  27000				   -	       and	#$0e
   1095  27000				   -	       cmp	#6
   1096  27000				   -	       bne	qs4
   1097  27000				   -	       lda	trackn_audc+1+4
   1098  27000				   -	       and	#$0f
   1099  27000				   -	       beq	qs4
   1100  27000				   -	       ldy	trackn_outnote+1+4
   1101  27000				   -	       lda	frqtabbasslo,y
   1102  27000				   -	       sta	trackn_audf+0+4
   1103  27000				   -	       lda	frqtabbasshi,y
   1104  27000				   -	       sta	trackn_audf+1+4
   1105  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1106  27000				   -	       lda	trackn_audc+0+4
   1107  27000				   -	       and	#$10
   1108  27000				   -	       bne	qs3a
   1109  27000				   -	       EIF
   1110  27000				   -	       lda	#0
   1111  27000				   -	       sta	trackn_audc+0+4
   1112  27000				   -qs3a
   1113  27000				   -	       txa
   1114  27000				   -	       ora	#$50
   1115  27000				   -	       tax
   1116  27000				   -	       EIF
   1117  27000				   -qs4
   1118  27000				   -	       IF	FEAT_BASS16G3R
   1119  27000				   -	       lda	trackn_command+3+4
   1120  27000				   -	       and	#$0e
   1121  27000				   -	       cmp	#6
   1122  27000				   -	       bne	qs5
   1123  27000				   -	       lda	trackn_audc+3+4
   1124  27000				   -	       and	#$0f
   1125  27000				   -	       beq	qs5
   1126  27000				   -	       ldy	trackn_outnote+3+4
   1127  27000				   -	       lda	frqtabbasslo,y
   1128  27000				   -	       sta	trackn_audf+2+4
   1129  27000				   -	       lda	frqtabbasshi,y
   1130  27000				   -	       sta	trackn_audf+3+4
   1131  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1132  27000				   -	       lda	trackn_audc+2+4
   1133  27000				   -	       and	#$10
   1134  27000				   -	       bne	qs4a
   1135  27000				   -	       EIF
   1136  27000				   -	       lda	#0
   1137  27000				   -	       sta	trackn_audc+2+4
   1138  27000				   -qs4a
   1139  27000				   -	       txa
   1140  27000				   -	       ora	#$28
   1141  27000				   -	       tax
   1142  27000				   -	       EIF
   1143  27000				   -	       EIF
   1144  27000				   -qs5
   1145  27000				   -	       stx	v_audctl2
   1146  27000				   -	       EIF
   1147  27000				   -rmt_p5
   1148  27000				   -	       lda	v_ainstrspeed
   1149  27000				   -	       rts
   1150  27000				   -SetPokey
   1151  27000				   -	       IF	STEREO8T
   1152  27000				   -	       ldy	v_audctl2
   1153  27000				   -	       lda	trackn_audf+0+4
   1154  27000				   -	       ldx	trackn_audf+0
   1155  27000				   -	       sta	POKEY_BASE_S+$00
   1156  27000				   -	       stx	POKEY_BASE+$00
   1157  27000				   -	       lda	trackn_audc+0+4
   1158  27000				   -	       ldx	trackn_audc+0
   1159  27000				   -	       sta	POKEY_BASE_S+$01
   1160  27000				   -	       stx	POKEY_BASE+$01
   1161  27000				   -	       lda	trackn_audf+1+4
   1162  27000				   -	       ldx	trackn_audf+1
   1163  27000				   -	       sta	POKEY_BASE_S+$02
   1164  27000				   -	       stx	POKEY_BASE+$02
   1165  27000				   -	       lda	trackn_audc+1+4
   1166  27000				   -	       ldx	trackn_audc+1
   1167  27000				   -	       sta	POKEY_BASE_S+$03
   1168  27000				   -	       stx	POKEY_BASE+$03
   1169  27000				   -	       lda	trackn_audf+2+4
   1170  27000				   -	       ldx	trackn_audf+2
   1171  27000				   -	       sta	POKEY_BASE_S+$04
   1172  27000				   -	       stx	POKEY_BASE+$04
   1173  27000				   -	       lda	trackn_audc+2+4
   1174  27000				   -	       ldx	trackn_audc+2
   1175  27000				   -	       sta	POKEY_BASE_S+$05
   1176  27000				   -	       stx	POKEY_BASE+$05
   1177  27000				   -	       lda	trackn_audf+3+4
   1178  27000				   -	       ldx	trackn_audf+3
   1179  27000				   -	       sta	POKEY_BASE_S+$06
   1180  27000				   -	       stx	POKEY_BASE+$06
   1181  27000				   -	       lda	trackn_audc+3+4
   1182  27000				   -	       ldx	trackn_audc+3
   1183  27000				   -	       sta	POKEY_BASE_S+$07
   1184  27000				   -	       stx	POKEY_BASE+$07
   1185  27000				   -	       lda	v_audctl
   1186  27000				   -	       sty	POKEY_BASE_S+$08
   1187  27000				   -	       sta	POKEY_BASE+$08
   1188  27000				   -	       ELSE
   1189  27000				   -
   1190  27000				   -	       ifconst	RMTVOLUME
   1191  27000				   -	       lda	rmtvolume
   1192  27000				   -	       sta	fourbitfadevalueint
   1193  27000				   -	       endif
   1194  27000				   -	       ldy	v_audctl
   1195  27000				   -	       ldx	trackn_audf+0
   1196  27000				   -	       lda	trackn_audc+0
   1197  27000				   -	       ifconst	RMTVOLUME
   1198  27000				   -	       jsr	fourbitfadeint
   1199  27000				   -	       endif
   1200  27000				   -	       stx	POKEY_BASE+$00+0
   1201  27000				   -	       stx	POKEY_BASE+$00+0
   1202  27000				   -	       sta	POKEY_BASE+$01+0
   1203  27000				   -	       sta	POKEY_BASE+$01+0
   1204  27000				   -
   1205  27000				   -	       ldx	trackn_audf+1
   1206  27000				   -	       lda	trackn_audc+1
   1207  27000				   -	       ifconst	RMTVOLUME
   1208  27000				   -	       jsr	fourbitfadeint
   1209  27000				   -	       endif
   1210  27000				   -	       stx	POKEY_BASE+$00+2
   1211  27000				   -	       stx	POKEY_BASE+$00+2
   1212  27000				   -	       sta	POKEY_BASE+$01+2
   1213  27000				   -	       sta	POKEY_BASE+$01+2
   1214  27000				   -
   1215  27000				   -	       ldx	trackn_audf+2
   1216  27000				   -	       lda	trackn_audc+2
   1217  27000				   -	       ifconst	RMTVOLUME
   1218  27000				   -	       jsr	fourbitfadeint
   1219  27000				   -	       endif
   1220  27000				   -	       stx	POKEY_BASE+$00+4
   1221  27000				   -	       stx	POKEY_BASE+$00+4
   1222  27000				   -	       sta	POKEY_BASE+$01+4
   1223  27000				   -	       sta	POKEY_BASE+$01+4
   1224  27000				   -
   1225  27000				   -	       ldx	trackn_audf+3
   1226  27000				   -	       lda	trackn_audc+3
   1227  27000				   -	       ifconst	RMTVOLUME
   1228  27000				   -	       jsr	fourbitfadeint
   1229  27000				   -	       endif
   1230  27000				   -	       stx	POKEY_BASE+$00+6
   1231  27000				   -	       stx	POKEY_BASE+$00+6
   1232  27000				   -	       sta	POKEY_BASE+$01+6
   1233  27000				   -	       sta	POKEY_BASE+$01+6
   1234  27000				   -
   1235  27000				   -	       sty	POKEY_BASE+$08
   1236  27000				   -	       sty	POKEY_BASE+$08
   1237  27000				   -
   1238  27000				   -	       EIF
   1239  27000				   -	       rts
   1240  27000				   -SetUpInstrumentY2
   1241  27000				   -	       lda	(p_instrstable),y
   1242  27000				   -	       sta	trackn_instrdb,x
   1243  27000				   -	       sta	_nt
   1244  27000				   -	       iny
   1245  27000				   -	       lda	(p_instrstable),y
   1246  27000				   -	       sta	trackn_instrhb,x
   1247  27000				   -	       sta	_nt+1
   1248  27000				   -	       ldy	#0
   1249  27000				   -	       lda	(_nt),y
   1250  27000				   -	       sta	trackn_tableend,x
   1251  27000				   -	       clc
   1252  27000				   -	       adc	#1
   1253  27000				   -	       sta	trackn_instridx,x
   1254  27000				   -	       iny
   1255  27000				   -	       lda	(_nt),y
   1256  27000				   -	       sta	trackn_tablelop,x
   1257  27000				   -	       iny
   1258  27000				   -	       lda	(_nt),y
   1259  27000				   -	       sta	trackn_instrlen,x
   1260  27000				   -	       iny
   1261  27000				   -	       lda	(_nt),y
   1262  27000				   -	       sta	trackn_instrlop,x
   1263  27000				   -	       iny
   1264  27000				   -	       lda	(_nt),y
   1265  27000				   -	       sta	trackn_tabletypespeed,x
   1266  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1267  27000				   -	       and	#$3f
   1268  27000				   -	       EIF
   1269  27000				   -	       sta	trackn_tablespeeda,x
   1270  27000				   -	       IF	FEAT_TABLEMODE
   1271  27000				   -	       lda	(_nt),y
   1272  27000				   -	       and	#$40
   1273  27000				   -	       sta	trackn_tablemode,x
   1274  27000				   -	       EIF
   1275  27000				   -	       iny
   1276  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1277  27000				   -	       lda	(_nt),y
   1278  27000				   -	       sta	trackn_audctl,x
   1279  27000				   -	       EIF
   1280  27000				   -	       iny
   1281  27000				   -	       lda	(_nt),y
   1282  27000				   -	       sta	trackn_volumeslidedepth,x
   1283  27000				   -	       iny
   1284  27000				   -	       lda	(_nt),y
   1285  27000				   -	       sta	trackn_volumemin,x
   1286  27000				   -	       iny
   1287  27000				   -	       lda	(_nt),y
   1288  27000				   -	       sta	trackn_effdelay,x
   1289  27000				   -	       iny
   1290  27000				   -	       lda	(_nt),y
   1291  27000				   -	       tay
   1292  27000				   -	       lda	vibtabbeg,y
   1293  27000				   -	       sta	trackn_effvibratoa,x
   1294  27000				   -	       sta	trackn_effvibratobeg,x
   1295  27000				   -	       lda	vibtabbeg+1,y
   1296  27000				   -	       sta	trackn_effvibratoend,x
   1297  27000				   -	       ldy	#10
   1298  27000				   -	       lda	(_nt),y
   1299  27000				   -	       sta	trackn_effshift,x
   1300  27000				   -	       lda	#128
   1301  27000				   -	       sta	trackn_volumeslidevalue,x
   1302  27000				   -	       lda	#0
   1303  27000				   -	       sta	trackn_instrreachend,x
   1304  27000				   -	       sta	trackn_shiftfrq,x
   1305  27000				   -	       lda	#INSTRPAR
   1306  27000				   -	       sta	trackn_tablea,x
   1307  27000				   -	       tay
   1308  27000				   -	       lda	(_nt),y
   1309  27000				   -	       sta	trackn_tablenote,x
   1310  27000				   -	       IF	FEAT_FILTER
   1311  27000				   -	       lda	#1
   1312  27000				   -	       sta	trackn_filter,x
   1313  27000				   -	       EIF
   1314  27000				   -	       rts
   1315  27000				   -InstrumentsEffects
   1316  27000				   -	       lda	trackn_effdelay,x
   1317  27000				   -	       beq	ei2
   1318  27000				   -	       tay
   1319  27000				   -	       dey
   1320  27000				   -	       bne	ei1
   1321  27000				   -	       lda	trackn_shiftfrq,x
   1322  27000				   -	       clc
   1323  27000				   -	       adc	trackn_effshift,x
   1324  27000				   -	       clc
   1325  27000				   -	       ldy	trackn_effvibratoa,x
   1326  27000				   -	       adc	vib0,y
   1327  27000				   -	       sta	trackn_shiftfrq,x
   1328  27000				   -	       iny
   1329  27000				   -	       tya
   1330  27000				   -	       cmp	trackn_effvibratoend,x
   1331  27000				   -	       bne	ei1a
   1332  27000				   -	       lda	trackn_effvibratobeg,x
   1333  27000				   -ei1a
   1334  27000				   -	       sta	trackn_effvibratoa,x
   1335  27000				   -	       jmp	ei2
   1336  27000				   -ei1
   1337  27000				   -	       tya
   1338  27000				   -	       sta	trackn_effdelay,x
   1339  27000				   -ei2
   1340  27000				   -	       lda	trackn_tableend,x
   1341  27000				   -	       cmp	#INSTRPAR
   1342  27000				   -	       beq	ei3
   1343  27000				   -	       lda	trackn_tablespeeda,x
   1344  27000				   -	       bpl	ei2f
   1345  27000				   -ei2c
   1346  27000				   -	       lda	trackn_tablea,x
   1347  27000				   -	       clc
   1348  27000				   -	       adc	#1
   1349  27000				   -	       cmp	trackn_tableend,x
   1350  27000				   -	       bcc	ei2a
   1351  27000				   -	       beq	ei2a
   1352  27000				   -	       lda	trackn_tablelop,x
   1353  27000				   -ei2a
   1354  27000				   -	       sta	trackn_tablea,x
   1355  27000				   -	       lda	trackn_instrdb,x
   1356  27000				   -	       sta	_nt
   1357  27000				   -	       lda	trackn_instrhb,x
   1358  27000				   -	       sta	_nt+1
   1359  27000				   -	       ldy	trackn_tablea,x
   1360  27000				   -	       lda	(_nt),y
   1361  27000				   -	       IF	FEAT_TABLEMODE
   1362  27000				   -	       ldy	trackn_tablemode,x
   1363  27000				   -	       beq	ei2e
   1364  27000				   -	       clc
   1365  27000				   -	       adc	trackn_tablenote,x
   1366  27000				   -ei2e
   1367  27000				   -	       EIF
   1368  27000				   -	       sta	trackn_tablenote,x
   1369  27000				   -	       lda	trackn_tabletypespeed,x
   1370  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1371  27000				   -	       and	#$3f
   1372  27000				   -	       EIF
   1373  27000				   -ei2f
   1374  27000				   -	       sec
   1375  27000				   -	       sbc	#1
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -ei3
   1378  27000				   -	       lda	trackn_instrreachend,x
   1379  27000				   -	       bpl	ei4
   1380  27000				   -	       lda	trackn_volume,x
   1381  27000				   -	       beq	ei4
   1382  27000				   -	       cmp	trackn_volumemin,x
   1383  27000				   -	       beq	ei4
   1384  27000				   -	       bcc	ei4
   1385  27000				   -	       tay
   1386  27000				   -	       lda	trackn_volumeslidevalue,x
   1387  27000				   -	       clc
   1388  27000				   -	       adc	trackn_volumeslidedepth,x
   1389  27000				   -	       sta	trackn_volumeslidevalue,x
   1390  27000				   -	       bcc	ei4
   1391  27000				   -	       tya
   1392  27000				   -	       sbc	#16
   1393  27000				   -	       sta	trackn_volume,x
   1394  27000				   -ei4
   1395  27000				   -	       jmp	returnfromInstrumentsEffects
   1396  27000				   -
   1397  27000				   -rmtmoduleend
   1398  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1399  27000				   -	       echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1400  27000				   -
   1401  27000					       endif		; RMT
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1742  27000					       endif
   1743  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1745  27000					       endif
   1746  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -checkpokeyplaying
     19  27000				   -	       ldx	#6
     20  27000				   -checkpokeyplayingloop
     21  27000				   -	       lda	pokey1pointlo,x
     22  27000				   -	       ora	pokey1pointhi,x
     23  27000				   -	       beq	pokeychannelinactive
     24  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     25  27000				   -pokeychannelinactive
     26  27000				   -	       dex
     27  27000				   -	       dex
     28  27000				   -	       bpl	checkpokeyplayingloop
     29  27000				   -	       rts
     30  27000				   -
     31  27000				   -playpokeysfxA
     32  27000				   -	       txa
     33  27000				   -	       tay
     34  27000				   -	       lda	pokey1tick,x
     35  27000				   -	       beq	playpokeysfxAcont
     36  27000				   -	       sec
     37  27000				   -	       sbc	#1
     38  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  27000				   -	       rts
     40  27000				   -
     41  27000				   -playpokeysfxAcont
     42  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  27000				   -	       sta	pokey1tick,x
     44  27000				   -
     45  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  27000				   -	       beq	playpokeysfxAcont2
     47  27000				   -	       sec
     48  27000				   -	       sbc	#1
     49  27000				   -	       sta	pokey1priority,x
     50  27000				   -playpokeysfxAcont2
     51  27000				   -
     52  27000				   -			; *** FREQUENCY
     53  27000				   -	       lda	(pokey1pointlo,x)
     54  27000				   -	       sta	inttemp1
     55  27000				   -	       clc
     56  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     57  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     58  27000				   -
     59  27000				   -			;advance the data pointer +1
     60  27000				   -	       inc	pokey1pointlo,x
     61  27000				   -	       bne	skippokeyhiinc1
     62  27000				   -	       inc	pokey1pointhi,x
     63  27000				   -skippokeyhiinc1
     64  27000				   -
     65  27000				   -			; *** WAVE
     66  27000				   -	       lda	(pokey1pointlo,x)
     67  27000				   -	       asl
     68  27000				   -	       asl
     69  27000				   -	       asl
     70  27000				   -	       asl		; x16
     71  27000				   -
     72  27000				   -			;advance the data pointer +1
     73  27000				   -	       inc	pokey1pointlo,x
     74  27000				   -	       bne	skippokeyhiinc2
     75  27000				   -	       inc	pokey1pointhi,x
     76  27000				   -skippokeyhiinc2
     77  27000				   -
     78  27000				   -	       ora	(pokey1pointlo,x)
     79  27000				   -	       iny
     80  27000				   -	       sta	(pokeybaselo),y
     81  27000				   -
     82  27000				   -	       ora	inttemp1	; check if F|C|V=0
     83  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  27000				   -
     85  27000				   -			; advance the pointer +1, on to the next sound chunk
     86  27000				   -	       inc	pokey1pointlo,x
     87  27000				   -	       bne	skippokeyhiinc3
     88  27000				   -	       inc	pokey1pointhi,x
     89  27000				   -skippokeyhiinc3
     90  27000				   -	       rts
     91  27000				   -
     92  27000				   -zeropokeypoint
     93  27000				   -	       sta	pokey1pointlo,x
     94  27000				   -	       sta	pokey1pointhi,x
     95  27000				   -	       sta	pokey1priority,x
     96  27000				   -	       rts
     97  27000				   -
     98  27000				   -schedulepokeysfx
     99  27000				   -	       ldx	#6
    100  27000				   -schedulepokeysfxloop
    101  27000				   -	       lda	pokey1pointlo,x
    102  27000				   -	       ora	pokey1pointhi,x
    103  27000				   -	       bne	schedulespokeysearch
    104  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  27000				   -schedulespokeysearch
    106  27000				   -	       dex
    107  27000				   -	       dex
    108  27000				   -	       bpl	schedulepokeysfxloop
    109  27000				   -
    110  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    111  27000				   -	       ldy	#1
    112  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  27000				   -	       bne	schedulepokeysfxcont1
    114  27000				   -	       rts		; ...and skip it if it's 0 priority
    115  27000				   -schedulepokeysfxcont1
    116  27000				   -
    117  27000				   -			; figure out which current sound has the lowest priority...
    118  27000				   -	       lda	#0
    119  27000				   -	       sta	temp8
    120  27000				   -	       lda	pokey1priority
    121  27000				   -	       sta	temp9
    122  27000				   -	       ldx	#6
    123  27000				   -findlowprioritypokeyloop
    124  27000				   -	       lda	pokey1priority,x
    125  27000				   -	       cmp	temp9
    126  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    127  27000				   -	       sta	temp9
    128  27000				   -	       stx	temp8
    129  27000				   -findlowprioritypokeyloopcontinue
    130  27000				   -	       dex
    131  27000				   -	       dex
    132  27000				   -	       bne	findlowprioritypokeyloop
    133  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    134  27000				   -
    135  27000				   -schedulepokeyX
    136  27000				   -			;called with X=2*pokey channel to play on...
    137  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    138  27000				   -	       lda	(sfxinstrumentlo),y
    139  27000				   -	       sta	pokey1priority,x
    140  27000				   -	       iny
    141  27000				   -	       lda	(sfxinstrumentlo),y
    142  27000				   -	       sta	pokey1frames,x
    143  27000				   -
    144  27000				   -	       lda	sfxinstrumentlo
    145  27000				   -	       clc
    146  27000				   -	       adc	#3
    147  27000				   -	       sta	pokey1pointlo,x
    148  27000				   -	       lda	sfxinstrumenthi
    149  27000				   -	       adc	#0
    150  27000				   -	       sta	pokey1pointhi,x
    151  27000				   -	       lda	sfxpitchoffset
    152  27000				   -	       sta	pokey1offset,x
    153  27000				   -	       lda	#0
    154  27000				   -	       sta	pokey1tick,x
    155  27000				   -	       rts
    156  27000				   -
    157  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  27000				   -			; and the standard $4000 location.
    159  27000				   -			; if pokey the pokey is present, this routine will reset it.
    160  27000				   -	       ifconst	pokeyaddress
    161  27000				   -detectpokeylocation
    162  27000				   -	       lda	#<pokeyaddress
    163  27000				   -	       sta	pokeybaselo
    164  27000				   -	       lda	#>pokeyaddress
    165  27000				   -	       sta	pokeybasehi
    166  27000				   -	       lda	#$ff
    167  27000				   -	       sta	pokeydetected
    168  27000				   -
    169  27000				   -	       if	pokeyaddress = $450
    170  27000				   -	       lda	XCTRL1s
    171  27000				   -	       ora	#%00010100
    172  27000				   -	       sta	XCTRL1s
    173  27000				   -	       sta	XCTRL1
    174  27000				   -	       endif
    175  27000				   -
    176  27000				   -
    177  27000				   -	       lda	#0
    178  27000				   -	       ldy	#15
    179  27000				   -clearpokeyloop
    180  27000				   -	       sta	(pokeybase),y
    181  27000				   -	       dey
    182  27000				   -	       bpl	clearpokeyloop
    183  27000				   -			; take pokey out of reset...
    184  27000				   -	       ldy	#PSKCTL
    185  27000				   -	       lda	#3
    186  27000				   -	       sta	(pokeybase),y
    187  27000				   -	       ldy	#PAUDCTL
    188  27000				   -	       lda	#0
    189  27000				   -	       sta	(pokeybase),y
    190  27000				   -	       rts
    191  27000				   -	       else		; !pokeyaddress
    192  27000				   -detectpokeylocation
    193  27000				   -			;XBoard/XM...
    194  27000				   -	       ldx	#2
    195  27000				   -detectpokeyloop
    196  27000				   -	       lda	XCTRL1s
    197  27000				   -	       ora	#%00010100
    198  27000				   -	       and	POKEYXMMASK,x
    199  27000				   -	       sta	XCTRL1s
    200  27000				   -	       sta	XCTRL1
    201  27000				   -
    202  27000				   -	       lda	POKEYCHECKLO,x
    203  27000				   -	       sta	pokeybaselo
    204  27000				   -	       lda	POKEYCHECKHI,x
    205  27000				   -	       sta	pokeybasehi
    206  27000				   -	       jsr	checkforpokey
    207  27000				   -	       lda	pokeydetected
    208  27000				   -	       beq	foundpokeychip
    209  27000				   -	       dex
    210  27000				   -	       bpl	detectpokeyloop
    211  27000				   -foundpokeychip
    212  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    213  27000				   -	       sta	pokeydetected
    214  27000				   -	       rts
    215  27000				   -
    216  27000				   -POKEYXMMASK
    217  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    218  27000				   -	       .byte	%11111111, %11101111, %11101111
    219  27000				   -
    220  27000				   -POKEYCHECKLO
    221  27000				   -	       .byte	<$0450, <$0450, <$4000
    222  27000				   -POKEYCHECKHI
    223  27000				   -	       .byte	>$0450, >$0450, >$4000
    224  27000				   -
    225  27000				   -checkforpokey
    226  27000				   -	       ldy	#$0f
    227  27000				   -	       lda	#$00
    228  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    229  27000				   -resetpokeyregistersloop
    230  27000				   -	       sta	(pokeybase),y
    231  27000				   -	       dey
    232  27000				   -	       bpl	resetpokeyregistersloop
    233  27000				   -
    234  27000				   -	       ldy	#PAUDCTL
    235  27000				   -	       sta	(pokeybase),y
    236  27000				   -	       ldy	#PSKCTL
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -
    239  27000				   -			; let the dust settle...
    240  27000				   -	       nop
    241  27000				   -	       nop
    242  27000				   -	       nop
    243  27000				   -
    244  27000				   -	       lda	#4
    245  27000				   -	       sta	temp9
    246  27000				   -pokeycheckloop1
    247  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    248  27000				   -	       ldy	#PRANDOM
    249  27000				   -	       lda	(pokeybase),y
    250  27000				   -	       cmp	#$ff
    251  27000				   -	       bne	nopokeydetected
    252  27000				   -	       dec	temp9
    253  27000				   -	       bne	pokeycheckloop1
    254  27000				   -
    255  27000				   -			; take pokey out of reset...
    256  27000				   -	       ldy	#PSKCTL
    257  27000				   -	       lda	#3
    258  27000				   -	       sta	(pokeybase),y
    259  27000				   -	       ldy	#PAUDCTL
    260  27000				   -	       lda	#0
    261  27000				   -	       sta	(pokeybase),y
    262  27000				   -
    263  27000				   -			; let the dust settle again...
    264  27000				   -	       nop
    265  27000				   -	       nop
    266  27000				   -	       nop
    267  27000				   -
    268  27000				   -	       lda	#4
    269  27000				   -	       sta	temp9
    270  27000				   -pokeycheckloop2
    271  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    272  27000				   -	       ldy	#PRANDOM
    273  27000				   -	       lda	(pokeybase),y
    274  27000				   -	       cmp	#$ff
    275  27000				   -	       beq	skippokeycheckreturn
    276  27000				   -	       rts
    277  27000				   -skippokeycheckreturn
    278  27000				   -	       dec	temp9
    279  27000				   -	       bne	pokeycheckloop2
    280  27000				   -nopokeydetected
    281  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    282  27000				   -	       rts
    283  27000				   -
    284  27000				   -	       endif		; !pokeyaddress
    285  27000				   -
    286  27000				   -pokeysoundmoduleend
    287  27000				   -
    288  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes)"
    289  27000				   -
    290  27000					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1748  27000					       endif
   1749  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       lda	songtempo
     15  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     16  27000				   -servicesongcontinue
     17  27000				   -	       lda	sfxschedulelock
     18  27000				   -	       sta	sfxschedulemissed
     19  27000				   -	       bne	servicesongover
     20  27000				   -	       lda	songtempo
     21  27000				   -	       clc
     22  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     23  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     24  27000				   -	       bcc	servicesongover
     25  27000				   -			; ** if we're here a new 16th note has passed
     26  27000				   -			; ** check if a new note is due on any of the 4 channels
     27  27000				   -servicesongredo
     28  27000				   -	       ldx	#3
     29  27000				   -checkchannelloop
     30  27000				   -	       dec	songchannel1busywait,x
     31  27000				   -	       bpl	carryoncheckingchannel
     32  27000				   -	       txa
     33  27000				   -	       pha		; save X for the loop
     34  27000				   -	       jsr	processsongdata
     35  27000				   -	       pla		; restore X for the loop
     36  27000				   -	       tax
     37  27000				   -carryoncheckingchannel
     38  27000				   -	       dex
     39  27000				   -	       bpl	checkchannelloop
     40  27000				   -	       lda	inactivechannelcount
     41  27000				   -	       cmp	#15
     42  27000				   -	       bne	skipstopsong
     43  27000				   -	       lda	songloops
     44  27000				   -	       bne	doasongloop
     45  27000				   -			;lda #0
     46  27000				   -	       sta	songtempo	; all channels are done. stop the song
     47  27000				   -	       rts
     48  27000				   -doasongloop
     49  27000				   -	       bmi	skipsongloopadjust
     50  27000				   -	       dec	songloops
     51  27000				   -skipsongloopadjust
     52  27000				   -	       jsr	setsongchannels
     53  27000				   -	       jmp	servicesongredo
     54  27000				   -skipstopsong
     55  27000				   -	       rts
     56  27000				   -
     57  27000				   -processsongdata
     58  27000				   -			; channel needs processing
     59  27000				   -			; X=channel #
     60  27000				   -
     61  27000				   -	       txa
     62  27000				   -	       clc
     63  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  27000				   -	       tay
     65  27000				   -
     66  27000				   -
     67  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     68  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     69  27000				   -	       lda	songchannel1layer1lo,y
     70  27000				   -	       sta	songdatalo
     71  27000				   -	       lda	songchannel1layer1hi,y
     72  27000				   -	       sta	songdatahi
     73  27000				   -	       ora	songdatalo
     74  27000				   -	       bne	channelhasdata
     75  27000				   -			;channel data is pointing at $0000
     76  27000				   -	       lda	#$7F
     77  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     78  27000				   -setchannelcountbits
     79  27000				   -	       lda	channel2bits,x
     80  27000				   -	       ora	inactivechannelcount
     81  27000				   -	       sta	inactivechannelcount
     82  27000				   -	       rts
     83  27000				   -channelhasdata
     84  27000				   -
     85  27000				   -	       sty	songstackindex
     86  27000				   -	       ldy	#0
     87  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  27000				   -	       cmp	#$ff
     89  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  27000				   -	       jmp	handlechannelEOD
     91  27000				   -
     92  27000				   -carryoncheckingdatatype
     93  27000				   -	       and	#$F0
     94  27000				   -	       cmp	#$C0
     95  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
     96  27000				   -	       cmp	#$F0
     97  27000				   -	       beq	handlemultibytecommand
     98  27000				   -	       cmp	#$D0
     99  27000				   -	       beq	handlesemiup
    100  27000				   -	       cmp	#$E0
    101  27000				   -	       beq	handlesemidown
    102  27000				   -handlenotedata
    103  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    104  27000				   -
    105  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    106  27000				   -
    107  27000				   -			; ** set the note length
    108  27000				   -	       lda	(songdatalo),y
    109  27000				   -	       and	#$0F
    110  27000				   -	       sta	songchannel1busywait,x
    111  27000				   -
    112  27000				   -			; ** load the instrument
    113  27000				   -	       lda	songchannel1instrumentlo,x
    114  27000				   -	       sta	sfxinstrumentlo
    115  27000				   -	       lda	songchannel1instrumenthi,x
    116  27000				   -	       sta	sfxinstrumenthi
    117  27000				   -
    118  27000				   -			; ** get the note, and transpose
    119  27000				   -	       lda	(songdatalo),y
    120  27000				   -	       lsr
    121  27000				   -	       lsr
    122  27000				   -	       lsr
    123  27000				   -	       lsr
    124  27000				   -	       clc
    125  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    126  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    127  27000				   -	       sta	sfxnoteindex
    128  27000				   -
    129  27000				   -	       lda	#0
    130  27000				   -	       sta	sfxpitchoffset
    131  27000				   -
    132  27000				   -	       jsr	schedulesfx
    133  27000				   -
    134  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  27000				   -
    136  27000				   -handlechannelrest
    137  27000				   -			; ** set the note length
    138  27000				   -	       lda	(songdatalo),y
    139  27000				   -	       and	#$0F
    140  27000				   -	       sta	songchannel1busywait,x
    141  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  27000				   -
    143  27000				   -handlesemiup
    144  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  27000				   -	       clc
    147  27000				   -handlesemidownentry
    148  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    149  27000				   -	       sta	songchannel1transpose,x
    150  27000				   -	       jsr	advancethesongpointer1byte
    151  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  27000				   -
    153  27000				   -handlesemidown
    154  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  27000				   -	       sec
    158  27000				   -	       jmp	handlesemidownentry
    159  27000				   -
    160  27000				   -handlemultibytecommand
    161  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  27000				   -	       cmp	#$08	; ** load new instrument?
    164  27000				   -	       bne	nothandleinstrumentchange
    165  27000				   -handleinstrumentchange
    166  27000				   -	       iny
    167  27000				   -	       lda	(songdatalo),y
    168  27000				   -	       sta	songchannel1instrumentlo,x
    169  27000				   -	       iny
    170  27000				   -	       lda	(songdatalo),y
    171  27000				   -	       sta	songchannel1instrumenthi,x
    172  27000				   -	       lda	#3
    173  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  27000				   -	       jmp	processsongdata
    175  27000				   -
    176  27000				   -nothandleinstrumentchange
    177  27000				   -	       cmp	#$09	; ** absolute tempo change?
    178  27000				   -	       bne	nothandletempochange
    179  27000				   -	       lda	#0
    180  27000				   -	       sta	songtempo
    181  27000				   -handlerelativetempochange
    182  27000				   -	       iny
    183  27000				   -	       lda	(songdatalo),y
    184  27000				   -	       clc
    185  27000				   -	       adc	songtempo
    186  27000				   -	       sta	songtempo
    187  27000				   -	       lda	#2
    188  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  27000				   -	       jmp	processsongdata
    190  27000				   -
    191  27000				   -nothandletempochange
    192  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    193  27000				   -	       beq	handlerelativetempochange
    194  27000				   -	       cmp	#$0B	; ** octave/semi change?
    195  27000				   -	       beq	handleoctavesemichange
    196  27000				   -handlepatterndata
    197  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    198  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    199  27000				   -
    200  27000				   -	       lda	#4
    201  27000				   -	       clc
    202  27000				   -	       adc	songchannel1stackdepth,x
    203  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  27000				   -
    205  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    206  27000				   -	       lda	songstackindex
    207  27000				   -	       adc	#4
    208  27000				   -	       tax
    209  27000				   -
    210  27000				   -	       lda	(songdatalo),y
    211  27000				   -	       and	#$7
    212  27000				   -	       sta	songchannel1layer1loops,x
    213  27000				   -	       iny
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       sta	songchannel1layer1lo,x
    216  27000				   -	       iny
    217  27000				   -	       lda	(songdatalo),y
    218  27000				   -	       sta	songchannel1layer1hi,x
    219  27000				   -
    220  27000				   -	       ldx	inttemp6	; restore x with the channel #
    221  27000				   -
    222  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  27000				   -	       lda	#3
    224  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  27000				   -
    226  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  27000				   -	       jmp	processsongdata
    228  27000				   -
    229  27000				   -handlechannelEOD
    230  27000				   -			; ** check if there are loops remaining on the pattern
    231  27000				   -	       stx	inttemp6
    232  27000				   -	       ldx	songstackindex
    233  27000				   -	       dec	songchannel1layer1loops,x
    234  27000				   -	       bmi	handlechannelEODnoloop
    235  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  27000				   -	       iny
    237  27000				   -	       lda	(songdatalo),y
    238  27000				   -	       sta	songchannel1layer1lo,x
    239  27000				   -	       iny
    240  27000				   -	       lda	(songdatalo),y
    241  27000				   -	       sta	songchannel1layer1hi,x
    242  27000				   -	       ldx	inttemp6
    243  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  27000				   -
    245  27000				   -handlechannelEODnoloop
    246  27000				   -			; this pattern/loop is done playing. "pop" the stack
    247  27000				   -	       ldx	inttemp6
    248  27000				   -	       lda	songchannel1stackdepth,x
    249  27000				   -	       beq	handlerootchannelEOD
    250  27000				   -	       sec
    251  27000				   -	       sbc	#4
    252  27000				   -	       sta	songchannel1stackdepth,x
    253  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  27000				   -
    255  27000				   -handlerootchannelEOD
    256  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  27000				   -	       lda	#0
    258  27000				   -	       sta	songchannel1layer1lo,x
    259  27000				   -	       sta	songchannel1layer1hi,x
    260  27000				   -	       sta	songchannel1busywait,x
    261  27000				   -	       jmp	setchannelcountbits
    262  27000				   -	       rts
    263  27000				   -
    264  27000				   -nothandlepatternchange
    265  27000				   -handleoctavesemichange
    266  27000				   -	       iny
    267  27000				   -	       lda	(songdatalo),y
    268  27000				   -	       sta	songchannel1transpose,x
    269  27000				   -	       lda	#2
    270  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  27000				   -	       jmp	processsongdata
    272  27000				   -
    273  27000				   -advancethesongpointer1byte
    274  27000				   -	       txa
    275  27000				   -	       ldx	songstackindex
    276  27000				   -	       inc	songchannel1layer1lo,x
    277  27000				   -	       bne	skiphiadvancethesongpointer1byte
    278  27000				   -	       inc	songchannel1layer1hi,x
    279  27000				   -skiphiadvancethesongpointer1byte
    280  27000				   -	       tax
    281  27000				   -	       rts
    282  27000				   -
    283  27000				   -advancethesongpointerNbytes
    284  27000				   -			; entered with A=# of byte to advance
    285  27000				   -	       stx	inttemp6
    286  27000				   -	       ldx	songstackindex
    287  27000				   -	       clc
    288  27000				   -	       adc	songchannel1layer1lo,x
    289  27000				   -	       sta	songchannel1layer1lo,x
    290  27000				   -	       lda	#0
    291  27000				   -	       adc	songchannel1layer1hi,x
    292  27000				   -	       sta	songchannel1layer1hi,x
    293  27000				   -	       ldx	inttemp6
    294  27000				   -	       rts
    295  27000				   -
    296  27000				   -clearsongmemory
    297  27000				   -	       lda	#0
    298  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  27000				   -clearsongmemoryloop1
    300  27000				   -	       sta	songchannel1layer1lo,x
    301  27000				   -	       dex
    302  27000				   -	       bpl	clearsongmemoryloop1
    303  27000				   -
    304  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  27000				   -clearsongmemoryloop2
    306  27000				   -	       sta	songchannel1layer1loops,x
    307  27000				   -	       dex
    308  27000				   -	       bpl	clearsongmemoryloop2
    309  27000				   -
    310  27000				   -	       lda	#$ff
    311  27000				   -	       ldx	#3
    312  27000				   -clearsongmemoryloop3
    313  27000				   -	       sta	songchannel1busywait,x
    314  27000				   -	       dex
    315  27000				   -	       bpl	clearsongmemoryloop3
    316  27000				   -	       rts
    317  27000				   -
    318  27000				   -setsongchannels
    319  27000				   -	       jsr	clearsongmemory
    320  27000				   -	       ldy	#7
    321  27000				   -	       ldx	#3
    322  27000				   -setsongchannelsloop
    323  27000				   -	       lda	(songpointerlo),y
    324  27000				   -	       sta	songchannel1layer1hi,x
    325  27000				   -	       dey
    326  27000				   -	       lda	(songpointerlo),y
    327  27000				   -	       sta	songchannel1layer1lo,x
    328  27000				   -	       dex
    329  27000				   -	       dey
    330  27000				   -	       bpl	setsongchannelsloop
    331  27000				   -	       rts
    332  27000				   -
    333  27000				   -channel2bits
    334  27000				   -	       .byte	1,2,4,8
    335  27000				   -
    336  27000				   -tiatrackeroctavenotes
    337  27000				   -	       ifconst	BUZZBASS
    338  27000				   -LOWC       =	15
    339  27000				   -	       else
    340  27000				   -LOWC       =	14
    341  27000				   -	       endif
    342  27000				   -			; ****** ELECTRONIC (0 to 11)
    343  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    344  27000				   -	       .byte	LOWC,18	; c#0
    345  27000				   -	       .byte	LOWC,17	; d0
    346  27000				   -	       .byte	LOWC,16	; d#0
    347  27000				   -	       .byte	LOWC,15	; e0
    348  27000				   -	       .byte	LOWC,14	; f0  (very off)
    349  27000				   -	       .byte	LOWC,14	; f#0
    350  27000				   -	       .byte	LOWC,13	; g0
    351  27000				   -	       .byte	LOWC,12	; g#0
    352  27000				   -	       .byte	LOWC,11	; a0
    353  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    354  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    355  27000				   -
    356  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  27000				   -	       .byte	6,30	; c1	 32.7Hz
    358  27000				   -	       .byte	6,28	; c#1
    359  27000				   -	       .byte	6,27	; d1
    360  27000				   -	       .byte	6,25	; d#1
    361  27000				   -	       .byte	6,24	; e1
    362  27000				   -	       .byte	6,22	; f1
    363  27000				   -	       .byte	6,21	; f#1
    364  27000				   -	       .byte	6,20	; g1
    365  27000				   -	       .byte	6,18	; g#1
    366  27000				   -	       .byte	6,17	; a1
    367  27000				   -	       .byte	6,16	; a#1
    368  27000				   -	       .byte	6,15	; b1	 63.4Hz
    369  27000				   -
    370  27000				   -			; ****** BUZZY (24 to 39)
    371  27000				   -	       .byte	1,31	; c2	 65.5
    372  27000				   -	       .byte	1,30	; c#2	 67.6
    373  27000				   -	       .byte	1,27	; d2	 72.3
    374  27000				   -	       .byte	1,26	; d#2	 77.6
    375  27000				   -	       .byte	1,24	; e2
    376  27000				   -	       .byte	1,23	; f2
    377  27000				   -	       .byte	1,22	; f#2
    378  27000				   -	       .byte	1,20	; g2
    379  27000				   -	       .byte	1,19	; g#2
    380  27000				   -	       .byte	1,18	; a2
    381  27000				   -	       .byte	1,17	; a#2
    382  27000				   -	       .byte	1,16	; b2
    383  27000				   -	       .byte	1,15	; c3	126.8Hz
    384  27000				   -	       .byte	1,14	; c#3
    385  27000				   -	       .byte	1,13	; d3	149.7Hz
    386  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    387  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    388  27000				   -	       .byte	12,31	; e3	163.8Hz
    389  27000				   -	       .byte	12,29	; f3
    390  27000				   -	       .byte	12,28	; f#3
    391  27000				   -	       .byte	12,26	; g3
    392  27000				   -	       .byte	12,24	; g#3
    393  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  27000				   -	       .byte	12,22	; a#3
    395  27000				   -	       .byte	12,20	; b3
    396  27000				   -	       .byte	12,19	; c4  (middle C)
    397  27000				   -	       .byte	12,18	; c#4
    398  27000				   -	       .byte	12,17	; d4
    399  27000				   -	       .byte	12,16	; d#4
    400  27000				   -	       .byte	12,15	; e4
    401  27000				   -	       .byte	12,14	; f4
    402  27000				   -	       .byte	12,13	; f#4
    403  27000				   -	       .byte	12,12	; g4  (very off)
    404  27000				   -	       .byte	12,12	; g#4
    405  27000				   -	       .byte	12,11	; a4
    406  27000				   -	       .byte	12,10	; a#4
    407  27000				   -	       .byte	4,31	; b4
    408  27000				   -	       .byte	4,29	; c5
    409  27000				   -	       .byte	4,28	; c#5
    410  27000				   -	       .byte	4,26	; d5
    411  27000				   -	       .byte	4,24	; d#5
    412  27000				   -	       .byte	4,23	; e5
    413  27000				   -	       .byte	4,22	; f5
    414  27000				   -	       .byte	4,20	; f#5
    415  27000				   -	       .byte	4,19	; g5
    416  27000				   -	       .byte	4,18	; g#5
    417  27000				   -	       .byte	4,17	; a5
    418  27000				   -	       .byte	4,16	; a#5
    419  27000				   -	       .byte	4,15	; b5
    420  27000				   -
    421  27000				   -			; ****** TUNED WIND (72 to 83)
    422  27000				   -	       .byte	8,30	; c
    423  27000				   -	       .byte	8,28	; c#
    424  27000				   -	       .byte	8,27	; d
    425  27000				   -	       .byte	8,25	; d#
    426  27000				   -	       .byte	8,24	; e
    427  27000				   -	       .byte	8,22	; f
    428  27000				   -	       .byte	8,21	; f#
    429  27000				   -	       .byte	8,20	; g
    430  27000				   -	       .byte	8,18	; g#
    431  27000				   -	       .byte	8,17	; a
    432  27000				   -	       .byte	8,16	; a#
    433  27000				   -	       .byte	8,15	; b
    434  27000				   -
    435  27000				   -	       include	"tiadrumkit.asm"
    436  27000				   -
    437  27000				   -trackerend
    438  27000				   -
    439  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  27000				   -
    441  27000					       endif		;MUSICTRACKER
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1751  27000					       endif
   1752  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -	       ifconst	BANKSETROM
      6  27000				   -	       ifconst	isBANKSETBANK
      7  27000				   -HSCHARSHERE =	1
      8  27000				   -	       endif
      9  27000				   -	       else		; !BANKSETROM so embed the character strings
     10  27000				   -HSCHARSHERE =	1
     11  27000				   -	       endif
     12  27000				   -
     13  27000				   -	       ifnconst	isBANKSETBANK
     14  27000				   -hiscorestart
     15  27000				   -
     16  27000				   -detectatarivoxeeprom
     17  27000				   -hiscoremodulestart
     18  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  27000				   -	       jsr	AVoxDetect
     20  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  27000				   -	       sta	avoxdetected
     22  27000				   -	       lda	#$0
     23  27000				   -	       sta	SWACNT
     24  27000				   -	       lda	avoxdetected
     25  27000				   -	       rts
     26  27000				   -
     27  27000				   -detecthsc
     28  27000				   -			; check for the HSC ROM signature...
     29  27000				   -	       lda	XCTRL1s
     30  27000				   -	       ora	#%00001100
     31  27000				   -	       sta	XCTRL1s
     32  27000				   -	       sta	XCTRL1
     33  27000				   -	       lda	$3900
     34  27000				   -	       eor	#$C6
     35  27000				   -	       bne	detecthscfail
     36  27000				   -	       lda	$3904
     37  27000				   -	       eor	#$FE
     38  27000				   -	       bne	detecthscfail
     39  27000				   -			; check if it's initialized...
     40  27000				   -	       ldy	#0
     41  27000				   -	       lda	#$ff
     42  27000				   -checkhscinit
     43  27000				   -	       and	$1000,y
     44  27000				   -	       dey
     45  27000				   -	       bpl	checkhscinit
     46  27000				   -	       cmp	#$ff
     47  27000				   -	       bne	hscisalreadyinit
     48  27000				   -			; if we're here, we need to do a minimal HSC init...
     49  27000				   -	       ldy	#$28
     50  27000				   -hscinitloop1
     51  27000				   -	       lda	hscheader,y
     52  27000				   -	       sta	$1000,y
     53  27000				   -	       dey
     54  27000				   -	       bpl	hscinitloop1
     55  27000				   -	       ldy	#$89
     56  27000				   -	       lda	#$7F
     57  27000				   -hscinitloop2
     58  27000				   -	       sta	$10B3,y
     59  27000				   -	       dey
     60  27000				   -	       cpy	#$ff
     61  27000				   -	       bne	hscinitloop2
     62  27000				   -hscisalreadyinit
     63  27000				   -	       lda	#$ff
     64  27000				   -	       rts
     65  27000				   -hscheader
     66  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     67  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     68  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     69  27000				   -detecthscfail
     70  27000				   -	       lda	XCTRL1s
     71  27000				   -	       and	#%11110111
     72  27000				   -	       sta	XCTRL1s
     73  27000				   -	       lda	#0
     74  27000				   -	       rts
     75  27000				   -	       endif		; isBANKSETBANK
     76  27000				   -
     77  27000				   -	       ifnconst	hiscorefont
     78  27000				   -	       echo	""
     79  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     80  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     81  27000				   -	       echo	" has been omitted from this build."
     82  27000				   -	       echo	""
     83  27000				   -	       else		; hiscorefont
     84  27000				   -	       ifnconst	isBANKSETBANK
     85  27000				   -hscdrawscreen
     86  27000				   -
     87  27000				   -			; we use 20 lines on a 24 line display
     88  27000				   -			; HSSCOREY to dynamically centers based on
     89  27000				   -			;HSSCOREY = 0
     90  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     91  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     92  27000				   -
     93  27000				   -	       ifconst	HSSCORESIZE
     94  27000				   -SCORESIZE  =	HSSCORESIZE
     95  27000				   -	       else
     96  27000				   -SCORESIZE  =	6
     97  27000				   -	       endif
     98  27000				   -
     99  27000				   -			;save shadow registers for later return...
    100  27000				   -	       lda	sCTRL
    101  27000				   -	       sta	ssCTRL
    102  27000				   -	       lda	sCHARBASE
    103  27000				   -	       sta	ssCHARBASE
    104  27000				   -	       lda	#$60
    105  27000				   -	       sta	charactermode
    106  27000				   -	       jsr	drawwait
    107  27000				   -	       jsr	blacken320colors
    108  27000				   -	       jsr	clearscreen
    109  27000				   -
    110  27000				   -			;set the character base to the HSC font
    111  27000				   -	       lda	#>hiscorefont
    112  27000				   -	       sta	CHARBASE
    113  27000				   -	       sta	sCHARBASE
    114  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    115  27000				   -	       sta	CTRL
    116  27000				   -	       sta	sCTRL
    117  27000				   -
    118  27000				   -	       lda	#60
    119  27000				   -	       sta	hsjoydebounce
    120  27000				   -
    121  27000				   -	       lda	#0
    122  27000				   -	       sta	hscursorx
    123  27000				   -	       sta	framecounter
    124  27000				   -	       ifnconst	HSCOLORCHASESTART
    125  27000				   -	       lda	#$8D	; default is blue. why not?
    126  27000				   -	       else
    127  27000				   -	       lda	#HSCOLORCHASESTART
    128  27000				   -	       endif
    129  27000				   -	       sta	hscolorchaseindex
    130  27000				   -
    131  27000				   -	       lda	#$0F
    132  27000				   -	       sta	P0C2	; base text is white
    133  27000				   -
    134  27000				   -	       jsr	hschasecolors
    135  27000				   -			; ** plot all of the initials
    136  27000				   -	       lda	#<HSRAMInitials
    137  27000				   -	       sta	temp1	; charmaplo
    138  27000				   -	       lda	#>HSRAMInitials
    139  27000				   -	       sta	temp2	; charmaphi
    140  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    141  27000				   -	       sta	temp3	; palette/width
    142  27000				   -	       lda	#104
    143  27000				   -	       sta	temp4	; X
    144  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    145  27000				   -	       sta	temp5	; Y
    146  27000				   -plothsinitialsloop
    147  27000				   -	       jsr	plotcharacters
    148  27000				   -	       clc
    149  27000				   -	       lda	temp3
    150  27000				   -	       adc	#32
    151  27000				   -	       sta	temp3
    152  27000				   -	       inc	temp5
    153  27000				   -	       if	WZONEHEIGHT = 8
    154  27000				   -	       inc	temp5
    155  27000				   -	       endif
    156  27000				   -	       clc
    157  27000				   -	       lda	#3
    158  27000				   -	       adc	temp1
    159  27000				   -	       sta	temp1
    160  27000				   -	       cmp	#(<(HSRAMInitials+15))
    161  27000				   -	       bcc	plothsinitialsloop
    162  27000				   -
    163  27000				   -	       ifconst	HSGAMENAMELEN
    164  27000				   -			;plot the game name...
    165  27000				   -	       lda	#<HSGAMENAMEtable
    166  27000				   -	       sta	temp1	; charmaplo
    167  27000				   -	       lda	#>HSGAMENAMEtable
    168  27000				   -	       sta	temp2	; charmaphi
    169  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    170  27000				   -	       sta	temp3	; palette/width
    171  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    172  27000				   -	       sta	temp4	; X
    173  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    174  27000				   -	       sta	temp5	; Y
    175  27000				   -	       jsr	plotcharacters
    176  27000				   -	       endif		; HSGAMENAMELEN
    177  27000				   -
    178  27000				   -			;plot "difficulty"...
    179  27000				   -	       ldy	gamedifficulty
    180  27000				   -	       ifnconst	HSNOLEVELNAMES
    181  27000				   -	       lda	highscoredifficultytextlo,y
    182  27000				   -	       sta	temp1
    183  27000				   -	       lda	highscoredifficultytexthi,y
    184  27000				   -	       sta	temp2
    185  27000				   -	       sec
    186  27000				   -	       lda	#32
    187  27000				   -	       sbc	highscoredifficultytextlen,y
    188  27000				   -	       sta	temp3	; palette/width
    189  27000				   -	       sec
    190  27000				   -	       lda	#40
    191  27000				   -	       sbc	highscoredifficultytextlen,y
    192  27000				   -	       asl
    193  27000				   -	       sta	temp4	; X
    194  27000				   -	       else
    195  27000				   -	       lda	#<HSHIGHSCOREStext
    196  27000				   -	       sta	temp1	; charmaplo
    197  27000				   -	       lda	#>HSHIGHSCOREStext
    198  27000				   -	       sta	temp2	; charmaphi
    199  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    200  27000				   -	       sta	temp3	; palette/width
    201  27000				   -	       lda	#(80-(11*2))
    202  27000				   -	       sta	temp4	; X
    203  27000				   -	       endif		; HSNOLEVELNAMES
    204  27000				   -
    205  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    206  27000				   -	       sta	temp5	; Y
    207  27000				   -	       jsr	plotcharacters
    208  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    209  27000				   -	       bne	carronwithscoreevaluation
    210  27000				   -	       jmp	donoscoreevaluation
    211  27000				   -carronwithscoreevaluation
    212  27000				   -	       dey
    213  27000				   -	       lda	highscorelabeltextlo,y
    214  27000				   -	       sta	temp1
    215  27000				   -	       lda	highscorelabeltexthi,y
    216  27000				   -	       sta	temp2
    217  27000				   -	       sec
    218  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    219  27000				   -	       sta	temp3	; palette/width
    220  27000				   -	       lda	highscorelabeladjust1,y
    221  27000				   -	       sta	temp4	; X
    222  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    223  27000				   -	       sta	temp5	; Y
    224  27000				   -	       jsr	plotcharacters
    225  27000				   -
    226  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    227  27000				   -	       dey
    228  27000				   -			;plot the current player score...
    229  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    230  27000				   -	       sta	temp3	; palette/width
    231  27000				   -	       lda	highscorelabeladjust2,y
    232  27000				   -	       sta	temp4	; X
    233  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    234  27000				   -	       sta	temp5	; Y
    235  27000				   -
    236  27000				   -	       lda	scorevarlo,y
    237  27000				   -	       sta	temp7	; score variable lo
    238  27000				   -	       lda	scorevarhi,y
    239  27000				   -	       sta	temp8	; score variable hi
    240  27000				   -
    241  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    242  27000				   -	       sta	temp9
    243  27000				   -
    244  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    245  27000				   -	       sta	temp1	; charmaplo
    246  27000				   -	       lda	#>(hiscorefont+33)
    247  27000				   -	       sta	temp2	; charmaphi
    248  27000				   -	       lda	#SCORESIZE
    249  27000				   -	       sta	temp6
    250  27000				   -	       ifnconst	DOUBLEWIDE
    251  27000				   -	       jsr	plotvalue
    252  27000				   -	       else
    253  27000				   -	       jsr	plotvaluedw
    254  27000				   -	       endif
    255  27000				   -
    256  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    257  27000				   -
    258  27000				   -	       ifconst	HSGAMERANKS
    259  27000				   -
    260  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    261  27000				   -comparescore2rankloop
    262  27000				   -	       inx
    263  27000				   -	       ldy	#0
    264  27000				   -	       lda	rankvalue_0,x
    265  27000				   -	       cmp	(temp7),y
    266  27000				   -	       bcc	score2rankloopdone
    267  27000				   -	       bne	comparescore2rankloop
    268  27000				   -	       iny
    269  27000				   -	       lda	rankvalue_1,x
    270  27000				   -	       cmp	(temp7),y
    271  27000				   -	       bcc	score2rankloopdone
    272  27000				   -	       bne	comparescore2rankloop
    273  27000				   -	       iny
    274  27000				   -	       lda	(temp7),y
    275  27000				   -	       cmp	rankvalue_2,x
    276  27000				   -	       bcs	score2rankloopdone
    277  27000				   -	       jmp	comparescore2rankloop
    278  27000				   -score2rankloopdone
    279  27000				   -	       stx	hsnewscorerank
    280  27000				   -
    281  27000				   -	       lda	ranklabello,x
    282  27000				   -	       sta	temp1
    283  27000				   -	       lda	ranklabelhi,x
    284  27000				   -	       sta	temp2
    285  27000				   -	       sec
    286  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    287  27000				   -	       sbc	ranklabellengths,x
    288  27000				   -	       sta	temp3	; palette/width
    289  27000				   -	       sec
    290  27000				   -	       lda	#(40+6)
    291  27000				   -	       sbc	ranklabellengths,x
    292  27000				   -	       asl
    293  27000				   -	       sta	temp4	; X
    294  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    295  27000				   -	       sta	temp5	; Y
    296  27000				   -	       jsr	plotcharacters
    297  27000				   -
    298  27000				   -	       ldx	hsnewscorerank
    299  27000				   -
    300  27000				   -	       lda	#<highscoreranklabel
    301  27000				   -	       sta	temp1
    302  27000				   -	       lda	#>highscoreranklabel
    303  27000				   -	       sta	temp2
    304  27000				   -
    305  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    306  27000				   -	       sta	temp3	; palette/width
    307  27000				   -	       lda	#(40-6)
    308  27000				   -	       sec
    309  27000				   -	       sbc	ranklabellengths,x
    310  27000				   -	       asl
    311  27000				   -	       sta	temp4	; X
    312  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    313  27000				   -	       sta	temp5	; Y
    314  27000				   -	       jsr	plotcharacters
    315  27000				   -	       endif		; HSGAMERANKS
    316  27000				   -
    317  27000				   -
    318  27000				   -			; ** which line did this player beat?
    319  27000				   -	       lda	#$ff
    320  27000				   -	       sta	hsnewscoreline
    321  27000				   -	       ldx	#$fd
    322  27000				   -comparescoreadd2x
    323  27000				   -	       inx
    324  27000				   -comparescoreadd1x
    325  27000				   -	       inx
    326  27000				   -comparescore2lineloop
    327  27000				   -	       inc	hsnewscoreline
    328  27000				   -	       inx		; initialrun, x=0
    329  27000				   -	       cpx	#15
    330  27000				   -	       beq	nohighscoreforyou
    331  27000				   -	       ldy	#0
    332  27000				   -	       lda	HSRAMScores,x
    333  27000				   -	       cmp	(temp7),y	; first score digit
    334  27000				   -	       bcc	score2lineloopdonedel1x
    335  27000				   -	       bne	comparescoreadd2x
    336  27000				   -	       iny
    337  27000				   -	       inx
    338  27000				   -	       lda	HSRAMScores,x
    339  27000				   -	       cmp	(temp7),y
    340  27000				   -	       bcc	score2lineloopdonedel2x
    341  27000				   -	       bne	comparescoreadd1x
    342  27000				   -	       iny
    343  27000				   -	       inx
    344  27000				   -	       lda	(temp7),y
    345  27000				   -	       cmp	HSRAMScores,x
    346  27000				   -	       bcs	score2lineloopdonedel3x
    347  27000				   -	       jmp	comparescore2lineloop
    348  27000				   -nohighscoreforyou
    349  27000				   -	       lda	#$ff
    350  27000				   -	       sta	hsnewscoreline
    351  27000				   -	       sta	countdownseconds
    352  27000				   -	       jmp	donoscoreevaluation
    353  27000				   -score2lineloopdonedel3x
    354  27000				   -	       dex
    355  27000				   -score2lineloopdonedel2x
    356  27000				   -	       dex
    357  27000				   -score2lineloopdonedel1x
    358  27000				   -	       dex
    359  27000				   -
    360  27000				   -			; 0 1 2
    361  27000				   -			; 3 4 5
    362  27000				   -			; 6 7 8
    363  27000				   -			; 9 0 1
    364  27000				   -			; 2 3 4
    365  27000				   -
    366  27000				   -	       stx	temp9
    367  27000				   -	       cpx	#11
    368  27000				   -	       beq	postsortscoresuploop
    369  27000				   -	       ldx	#11
    370  27000				   -sortscoresuploop
    371  27000				   -	       lda	HSRAMScores,x
    372  27000				   -	       sta	HSRAMScores+3,x
    373  27000				   -	       lda	HSRAMInitials,x
    374  27000				   -	       sta	HSRAMInitials+3,x
    375  27000				   -	       dex
    376  27000				   -	       cpx	temp9
    377  27000				   -	       bne	sortscoresuploop
    378  27000				   -postsortscoresuploop
    379  27000				   -
    380  27000				   -			;stick the score and cleared initials in the slot...
    381  27000				   -	       inx
    382  27000				   -	       ldy	#0
    383  27000				   -	       sty	hsinitialhold
    384  27000				   -	       lda	(temp7),y
    385  27000				   -	       sta	HSRAMScores,x
    386  27000				   -	       iny
    387  27000				   -	       lda	(temp7),y
    388  27000				   -	       sta	HSRAMScores+1,x
    389  27000				   -	       iny
    390  27000				   -	       lda	(temp7),y
    391  27000				   -	       sta	HSRAMScores+2,x
    392  27000				   -	       lda	#0
    393  27000				   -	       sta	HSRAMInitials,x
    394  27000				   -	       lda	#29
    395  27000				   -	       sta	HSRAMInitials+1,x
    396  27000				   -	       sta	HSRAMInitials+2,x
    397  27000				   -
    398  27000				   -	       stx	hsinitialpos
    399  27000				   -
    400  27000				   -	       ifconst	vox_highscore
    401  27000				   -	       lda	<#vox_highscore
    402  27000				   -	       sta	speech_addr
    403  27000				   -	       lda	>#vox_highscore
    404  27000				   -	       sta	speech_addr+1
    405  27000				   -	       endif		; vox_highscore
    406  27000				   -	       ifconst	sfx_highscore
    407  27000				   -	       lda	<#sfx_highscore
    408  27000				   -	       sta	temp1
    409  27000				   -	       lda	>#sfx_highscore
    410  27000				   -	       sta	temp2
    411  27000				   -	       lda	#0
    412  27000				   -	       sta	temp3
    413  27000				   -	       jsr	schedulesfx
    414  27000				   -	       endif		; sfx_highscore
    415  27000				   -	       ifconst	songdatastart_song_highscore
    416  27000				   -	       lda	#<songchanneltable_song_highscore
    417  27000				   -	       sta	songpointerlo
    418  27000				   -	       lda	#>songchanneltable_song_highscore
    419  27000				   -	       sta	songpointerhi
    420  27000				   -	       lda	#73
    421  27000				   -	       sta	songtempo
    422  27000				   -	       jsr	setsongchannels
    423  27000				   -	       endif		; songdatastart_song_highscore
    424  27000				   -
    425  27000				   -
    426  27000				   -donoscoreevaluation
    427  27000				   -
    428  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    429  27000				   -	       sta	temp3	; palette/width
    430  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    431  27000				   -	       sta	temp4	; X
    432  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    433  27000				   -	       sta	temp5	; Y
    434  27000				   -	       lda	#<HSRAMScores
    435  27000				   -	       sta	temp7	; score variable lo
    436  27000				   -	       lda	#>HSRAMScores
    437  27000				   -	       sta	temp8	; score variable hi
    438  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    439  27000				   -	       sta	temp9
    440  27000				   -plothsscoresloop
    441  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    442  27000				   -	       sta	temp1	; charmaplo
    443  27000				   -	       lda	#>(hiscorefont+33)
    444  27000				   -	       sta	temp2	; charmaphi
    445  27000				   -	       lda	#6
    446  27000				   -	       sta	temp6
    447  27000				   -	       ifnconst	DOUBLEWIDE
    448  27000				   -	       jsr	plotvalue
    449  27000				   -	       else
    450  27000				   -	       jsr	plotvaluedw
    451  27000				   -	       endif
    452  27000				   -	       clc
    453  27000				   -	       lda	temp3
    454  27000				   -	       adc	#32
    455  27000				   -	       sta	temp3
    456  27000				   -	       inc	temp5
    457  27000				   -	       if	WZONEHEIGHT = 8
    458  27000				   -	       inc	temp5
    459  27000				   -	       endif
    460  27000				   -	       clc
    461  27000				   -	       lda	#3
    462  27000				   -	       adc	temp7
    463  27000				   -	       sta	temp7
    464  27000				   -	       cmp	#(<(HSRAMScores+15))
    465  27000				   -	       bcc	plothsscoresloop
    466  27000				   -plothsindex
    467  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    468  27000				   -	       sta	temp3	; palette/width
    469  27000				   -	       lda	#44
    470  27000				   -	       sta	temp4	; X
    471  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    472  27000				   -	       sta	temp5	; Y
    473  27000				   -	       lda	#<hsgameslotnumbers
    474  27000				   -	       sta	temp7	; score variable lo
    475  27000				   -	       lda	#>hsgameslotnumbers
    476  27000				   -	       sta	temp8	; score variable hi
    477  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    478  27000				   -	       sta	temp9
    479  27000				   -plothsindexloop
    480  27000				   -	       lda	#<(hiscorefont+33)
    481  27000				   -	       sta	temp1	; charmaplo
    482  27000				   -	       lda	#>(hiscorefont+33)
    483  27000				   -	       sta	temp2	; charmaphi
    484  27000				   -	       lda	#1
    485  27000				   -	       sta	temp6	; number of characters
    486  27000				   -	       ifnconst	DOUBLEWIDE
    487  27000				   -	       jsr	plotvalue
    488  27000				   -	       else
    489  27000				   -	       jsr	plotvaluedw
    490  27000				   -	       endif
    491  27000				   -	       clc
    492  27000				   -	       lda	temp3
    493  27000				   -	       adc	#32
    494  27000				   -	       sta	temp3
    495  27000				   -	       inc	temp5
    496  27000				   -	       if	WZONEHEIGHT = 8
    497  27000				   -	       inc	temp5
    498  27000				   -	       endif
    499  27000				   -	       inc	temp7
    500  27000				   -	       lda	temp7
    501  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    502  27000				   -	       bcc	plothsindexloop
    503  27000				   -
    504  27000				   -	       jsr	savescreen
    505  27000				   -	       ifnconst	HSSECONDS
    506  27000				   -	       lda	#6
    507  27000				   -	       else
    508  27000				   -	       lda	#HSSECONDS
    509  27000				   -	       endif
    510  27000				   -
    511  27000				   -	       sta	countdownseconds
    512  27000				   -
    513  27000				   -keepdisplayinghs
    514  27000				   -	       jsr	restorescreen
    515  27000				   -
    516  27000				   -	       jsr	setuphsinpt1
    517  27000				   -
    518  27000				   -	       lda	hsnewscoreline
    519  27000				   -	       bpl	carryonkeepdisplayinghs
    520  27000				   -	       jmp	skipenterscorecontrol
    521  27000				   -carryonkeepdisplayinghs
    522  27000				   -
    523  27000				   -
    524  27000				   -	       ifnconst	HSSECONDS
    525  27000				   -	       lda	#6
    526  27000				   -	       else
    527  27000				   -	       lda	#HSSECONDS
    528  27000				   -	       endif
    529  27000				   -
    530  27000				   -	       sta	countdownseconds
    531  27000				   -
    532  27000				   -			;plot the "cursor" initial sprite...
    533  27000				   -	       lda	hsinitialhold
    534  27000				   -
    535  27000				   -	       sta	temp1
    536  27000				   -	       lda	#>(hiscorefont+32)
    537  27000				   -	       sta	temp2
    538  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    539  27000				   -	       sta	temp3	; palette/width
    540  27000				   -	       lda	hscursorx
    541  27000				   -	       asl
    542  27000				   -	       asl
    543  27000				   -	       clc
    544  27000				   -	       adc	#104
    545  27000				   -	       sta	temp4	; X
    546  27000				   -	       lda	hsnewscoreline
    547  27000				   -	       asl
    548  27000				   -	       asl
    549  27000				   -	       asl
    550  27000				   -	       asl
    551  27000				   -	       adc	#((3*16)+HSCURSORY)
    552  27000				   -	       sta	temp5	; Y
    553  27000				   -	       lda	#%01000000
    554  27000				   -	       sta	temp6
    555  27000				   -	       jsr	plotsprite
    556  27000				   -
    557  27000				   -	       ldx	hscursorx
    558  27000				   -	       ldy	hsdisplaymode
    559  27000				   -	       ifnconst	.HSup
    560  27000				   -	       lda	SWCHA
    561  27000				   -	       cpy	#3
    562  27000				   -	       bne	hsskipadjustjoystick1
    563  27000				   -	       asl
    564  27000				   -	       asl
    565  27000				   -	       asl
    566  27000				   -	       asl
    567  27000				   -hsskipadjustjoystick1
    568  27000				   -	       sta	hsswcha
    569  27000				   -	       else		; there are user-defined routines!
    570  27000				   -	       jsr	.HSdown
    571  27000				   -	       lda	hsreturn	; b0
    572  27000				   -	       asl
    573  27000				   -	       pha
    574  27000				   -	       jsr	.HSup
    575  27000				   -	       pla
    576  27000				   -	       ora	hsreturn
    577  27000				   -	       asl
    578  27000				   -	       asl
    579  27000				   -	       asl
    580  27000				   -	       asl
    581  27000				   -	       eor	#$FF
    582  27000				   -	       sta	hsswcha
    583  27000				   -	       endif
    584  27000				   -	       lda	SWCHB
    585  27000				   -	       and	#%00000010
    586  27000				   -	       bne	hsskipselectswitch
    587  27000				   -	       lda	#%00010000
    588  27000				   -	       sta	hsswcha
    589  27000				   -	       bne	hsdodebouncecheck
    590  27000				   -hsskipselectswitch
    591  27000				   -	       lda	hsswcha
    592  27000				   -	       and	#%00110000
    593  27000				   -	       cmp	#%00110000
    594  27000				   -	       beq	hsjoystickskipped
    595  27000				   -hsdodebouncecheck
    596  27000				   -	       lda	hsjoydebounce
    597  27000				   -	       beq	hsdontdebounce
    598  27000				   -	       jmp	hspostjoystick
    599  27000				   -hsdontdebounce
    600  27000				   -	       ldx	#1	; small tick sound
    601  27000				   -	       jsr	playhssfx
    602  27000				   -	       lda	hsswcha
    603  27000				   -	       and	#%00110000
    604  27000				   -	       ldx	hscursorx
    605  27000				   -	       cmp	#%00100000	; check down
    606  27000				   -	       bne	hsjoycheckup
    607  27000				   -	       ldy	hsinitialhold
    608  27000				   -	       cpx	#0
    609  27000				   -	       bne	skipavoid31_1
    610  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    611  27000				   -	       bne	skipavoid31_1
    612  27000				   -	       dey
    613  27000				   -skipavoid31_1
    614  27000				   -	       dey
    615  27000				   -	       jmp	hssetdebounce
    616  27000				   -hsjoycheckup
    617  27000				   -	       cmp	#%00010000	; check up
    618  27000				   -	       bne	hsjoystickskipped
    619  27000				   -	       ldy	hsinitialhold
    620  27000				   -	       cpx	#0
    621  27000				   -	       bne	skipavoid31_2
    622  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    623  27000				   -	       bne	skipavoid31_2
    624  27000				   -	       iny
    625  27000				   -skipavoid31_2
    626  27000				   -	       iny
    627  27000				   -hssetdebounce
    628  27000				   -	       tya
    629  27000				   -	       and	#31
    630  27000				   -	       sta	hsinitialhold
    631  27000				   -	       lda	#15
    632  27000				   -	       sta	hsjoydebounce
    633  27000				   -	       bne	hspostjoystick
    634  27000				   -hsjoystickskipped
    635  27000				   -			; check the fire button only when the stick isn't engaged
    636  27000				   -	       lda	hsinpt1
    637  27000				   -	       bpl	hsbuttonskipped
    638  27000				   -	       lda	hsjoydebounce
    639  27000				   -	       bne	hspostjoystick
    640  27000				   -hsfiredontdebounce
    641  27000				   -	       lda	hsinitialhold
    642  27000				   -	       cmp	#31
    643  27000				   -	       beq	hsmovecursorback
    644  27000				   -	       inc	hscursorx
    645  27000				   -	       inc	hsinitialpos
    646  27000				   -	       lda	hscursorx
    647  27000				   -	       cmp	#3
    648  27000				   -	       bne	skiphsentryisdone
    649  27000				   -	       lda	#0
    650  27000				   -	       sta	framecounter
    651  27000				   -	       lda	#$ff
    652  27000				   -	       sta	hsnewscoreline
    653  27000				   -	       dec	hsinitialpos
    654  27000				   -	       bne	skiphsentryisdone
    655  27000				   -hsmovecursorback
    656  27000				   -	       lda	hscursorx
    657  27000				   -	       beq	skiphsmovecursorback
    658  27000				   -	       lda	#29
    659  27000				   -	       ldx	hsinitialpos
    660  27000				   -	       sta	HSRAMInitials,x
    661  27000				   -	       dec	hsinitialpos
    662  27000				   -	       dec	hscursorx
    663  27000				   -	       dex
    664  27000				   -	       lda	HSRAMInitials,x
    665  27000				   -	       sta	hsinitialhold
    666  27000				   -skiphsmovecursorback
    667  27000				   -skiphsentryisdone
    668  27000				   -	       ldx	#0
    669  27000				   -	       jsr	playhssfx
    670  27000				   -	       lda	#20
    671  27000				   -	       sta	hsjoydebounce
    672  27000				   -	       bne	hspostjoystick
    673  27000				   -
    674  27000				   -hsbuttonskipped
    675  27000				   -	       lda	#0
    676  27000				   -	       sta	hsjoydebounce
    677  27000				   -hspostjoystick
    678  27000				   -
    679  27000				   -	       ldx	hsinitialpos
    680  27000				   -	       lda	hsinitialhold
    681  27000				   -	       sta	HSRAMInitials,x
    682  27000				   -
    683  27000				   -	       jmp	skiphschasecolors
    684  27000				   -
    685  27000				   -skipenterscorecontrol
    686  27000				   -	       jsr	hschasecolors
    687  27000				   -	       jsr	setuphsinpt1
    688  27000				   -	       lda	hsjoydebounce
    689  27000				   -	       bne	skiphschasecolors
    690  27000				   -	       lda	hsinpt1
    691  27000				   -	       bmi	returnfromhs
    692  27000				   -skiphschasecolors
    693  27000				   -
    694  27000				   -	       jsr	drawscreen
    695  27000				   -
    696  27000				   -	       lda	countdownseconds
    697  27000				   -	       beq	returnfromhs
    698  27000				   -	       jmp	keepdisplayinghs
    699  27000				   -returnfromhs
    700  27000				   -
    701  27000				   -	       ifconst	songdatastart_song_highscore
    702  27000				   -	       lda	hsdisplaymode
    703  27000				   -	       beq	skipclearHSCsong
    704  27000				   -	       lda	#0
    705  27000				   -	       sta	songtempo
    706  27000				   -skipclearHSCsong
    707  27000				   -	       endif
    708  27000				   -	       jsr	drawwait
    709  27000				   -	       jsr	clearscreen
    710  27000				   -	       lda	#0
    711  27000				   -	       ldy	#7
    712  27000				   -	       jsr	blacken320colors
    713  27000				   -	       lda	ssCTRL
    714  27000				   -	       sta	sCTRL
    715  27000				   -	       lda	ssCHARBASE
    716  27000				   -	       sta	sCHARBASE
    717  27000				   -	       rts
    718  27000				   -
    719  27000				   -setuphsinpt1
    720  27000				   -	       lda	#$ff
    721  27000				   -	       sta	hsinpt1
    722  27000				   -	       lda	hsjoydebounce
    723  27000				   -	       beq	skipdebounceadjust
    724  27000				   -	       dec	hsjoydebounce
    725  27000				   -	       bne	skipstorefirebuttonstatus
    726  27000				   -skipdebounceadjust
    727  27000				   -	       lda	SWCHB
    728  27000				   -	       and	#%00000001
    729  27000				   -	       bne	hscheckresetover
    730  27000				   -	       lda	#$ff
    731  27000				   -	       sta	hsinpt1
    732  27000				   -	       rts
    733  27000				   -hscheckresetover
    734  27000				   -	       ifnconst	.HSup
    735  27000				   -	       ldx	hsdisplaymode
    736  27000				   -	       cpx	#3
    737  27000				   -	       bne	hsskipadjustjoyfire1
    738  27000				   -	       lda	sINPT3
    739  27000				   -	       jmp	hsskipadjustjoyfire1done
    740  27000				   -hsskipadjustjoyfire1
    741  27000				   -	       lda	sINPT1
    742  27000				   -hsskipadjustjoyfire1done
    743  27000				   -	       sta	hsinpt1
    744  27000				   -	       else		; there are user-defined routines!
    745  27000				   -	       jsr	.HSselect
    746  27000				   -	       lda	hsreturn
    747  27000				   -	       ror		; carry
    748  27000				   -	       ror		; b7
    749  27000				   -	       sta	hsinpt1
    750  27000				   -	       endif	.HSup
    751  27000				   -skipstorefirebuttonstatus
    752  27000				   -	       rts
    753  27000				   -
    754  27000				   -blacken320colors
    755  27000				   -	       ldy	#7
    756  27000				   -blacken320colorsloop
    757  27000				   -	       sta	P0C2,y
    758  27000				   -	       dey
    759  27000				   -	       bpl	blacken320colorsloop
    760  27000				   -	       rts
    761  27000				   -
    762  27000				   -hschasecolors
    763  27000				   -	       lda	framecounter
    764  27000				   -	       and	#3
    765  27000				   -	       bne	hschasecolorsreturn
    766  27000				   -	       inc	hscolorchaseindex
    767  27000				   -	       lda	hscolorchaseindex
    768  27000				   -
    769  27000				   -	       sta	P5C2
    770  27000				   -	       sbc	#$02
    771  27000				   -	       sta	P4C2
    772  27000				   -	       sbc	#$02
    773  27000				   -	       sta	P3C2
    774  27000				   -	       sbc	#$02
    775  27000				   -	       sta	P2C2
    776  27000				   -	       sbc	#$02
    777  27000				   -	       sta	P1C2
    778  27000				   -hschasecolorsreturn
    779  27000				   -	       rts
    780  27000				   -
    781  27000				   -playhssfx
    782  27000				   -	       lda	hssfx_lo,x
    783  27000				   -	       sta	temp1
    784  27000				   -	       lda	hssfx_hi,x
    785  27000				   -	       sta	temp2
    786  27000				   -	       lda	#0
    787  27000				   -	       sta	temp3
    788  27000				   -	       jmp	schedulesfx
    789  27000				   -
    790  27000				   -hssfx_lo
    791  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    792  27000				   -hssfx_hi
    793  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    794  27000				   -
    795  27000				   -sfx_hsletterpositionchange
    796  27000				   -	       .byte	$10,$18,$00
    797  27000				   -	       .byte	$02,$06,$08
    798  27000				   -	       .byte	$02,$06,$04
    799  27000				   -	       .byte	$00,$00,$00
    800  27000				   -sfx_hslettertick
    801  27000				   -	       .byte	$10,$18,$00
    802  27000				   -	       .byte	$00,$00,$0a
    803  27000				   -	       .byte	$00,$00,$00
    804  27000				   -
    805  27000				   -highscorelabeladjust1
    806  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    807  27000				   -highscorelabeladjust2
    808  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    809  27000				   -
    810  27000				   -scorevarlo
    811  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    812  27000				   -scorevarhi
    813  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    814  27000				   -
    815  27000				   -	       endif		; !isBANKSETBANK
    816  27000				   -
    817  27000				   -	       ifnconst	HSNOLEVELNAMES
    818  27000				   -	       ifnconst	isBANKSETBANK
    819  27000				   -highscoredifficultytextlo
    820  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    821  27000				   -highscoredifficultytexthi
    822  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    823  27000				   -	       endif		; !isBANKSETBANK
    824  27000				   -
    825  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    826  27000				   -	       ifnconst	isBANKSETBANK
    827  27000				   -highscoredifficultytextlen
    828  27000				   -	       .byte	22, 30, 26, 24
    829  27000				   -	       endif		; !isBANKSETBANK
    830  27000				   -
    831  27000				   -	       ifconst	HSCHARSHERE
    832  27000				   -
    833  27000				   -easylevelname
    834  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    835  27000				   -mediumlevelname
    836  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    837  27000				   -hardlevelname
    838  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    839  27000				   -expertlevelname
    840  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    841  27000				   -	       endif		; HSCHARSHERE
    842  27000				   -	       else		; HSCUSTOMLEVELNAMES
    843  27000				   -	       include	"7800hsgamediffnames.asm"
    844  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    845  27000				   -	       else		; HSNOLEVELNAMES
    846  27000				   -	       ifconst	HSCHARSHERE
    847  27000				   -HSHIGHSCOREStext
    848  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  27000				   -	       endif		; HSCHARSHERE
    850  27000				   -	       endif		; HSNOLEVELNAMES
    851  27000				   -
    852  27000				   -	       ifnconst	isBANKSETBANK
    853  27000				   -highscorelabeltextlo
    854  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    855  27000				   -highscorelabeltexthi
    856  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    857  27000				   -	       endif		; !isBANKSETBANK
    858  27000				   -
    859  27000				   -	       ifconst	HSCHARSHERE
    860  27000				   -player0label
    861  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    862  27000				   -
    863  27000				   -player1label
    864  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    865  27000				   -
    866  27000				   -player2label
    867  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    868  27000				   -	       endif		; HSCHARSHERE
    869  27000				   -
    870  27000				   -
    871  27000				   -	       ifconst	HSGAMENAMELEN
    872  27000				   -	       ifconst	HSCHARSHERE
    873  27000				   -HSGAMENAMEtable
    874  27000				   -	       include	"7800hsgamename.asm"
    875  27000				   -	       endif		; HSCHARSHERE
    876  27000				   -	       endif		; HSGAMENAMELEN
    877  27000				   -	       ifconst	HSGAMERANKS
    878  27000				   -	       include	"7800hsgameranks.asm"
    879  27000				   -	       ifconst	HSCHARSHERE
    880  27000				   -highscoreranklabel
    881  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    882  27000				   -	       endif		; HSCHARSHERE
    883  27000				   -	       endif		; HSGAMERANKS
    884  27000				   -
    885  27000				   -			;ensure our table doesn't wrap a page...
    886  27000				   -	       if	((<*)>251)
    887  27000				   -	       align	256
    888  27000				   -	       endif
    889  27000				   -hsgameslotnumbers
    890  27000				   -	       .byte	33,34,35,36,37
    891  27000				   -	       endif		; hiscorefont
    892  27000				   -
    893  27000				   -
    894  27000				   -	       ifnconst	isBANKSETBANK
    895  27000				   -loaddifficultytable
    896  27000				   -	       lda	gamedifficulty
    897  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    898  27000				   -	       sta	gamedifficulty
    899  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    900  27000				   -	       bne	loaddifficultytablecontinue1
    901  27000				   -	       rts		; this high score difficulty table is already loaded
    902  27000				   -loaddifficultytablecontinue1
    903  27000				   -	       lda	gamedifficulty
    904  27000				   -	       sta	hsdifficulty
    905  27000				   -			;we need to check the device for the table
    906  27000				   -	       lda	hsdevice
    907  27000				   -	       bne	loaddifficultytablecontinue2
    908  27000				   -			; there's no save device. clear out this table.
    909  27000				   -	       jmp	cleardifficultytablemem
    910  27000				   -loaddifficultytablecontinue2
    911  27000				   -	       lda	hsdevice
    912  27000				   -	       and	#1
    913  27000				   -	       beq	memdeviceisntHSC
    914  27000				   -	       jmp	loaddifficultytableHSC
    915  27000				   -memdeviceisntHSC
    916  27000				   -	       jmp	loaddifficultytableAVOX
    917  27000				   -
    918  27000				   -savedifficultytable
    919  27000				   -			;*** we need to check which device we should use...
    920  27000				   -	       lda	hsdevice
    921  27000				   -	       bne	savedifficultytablerealdevice
    922  27000				   -	       rts		; its a ram device
    923  27000				   -savedifficultytablerealdevice
    924  27000				   -	       and	#1
    925  27000				   -	       beq	savememdeviceisntHSC
    926  27000				   -	       jmp	savedifficultytableHSC
    927  27000				   -savememdeviceisntHSC
    928  27000				   -	       jmp	savedifficultytableAVOX
    929  27000				   -
    930  27000				   -savedifficultytableAVOX
    931  27000				   -			; the load call already setup the memory structure and atarivox memory location
    932  27000				   -	       jsr	savealoadedHSCtablecontinue
    933  27000				   -savedifficultytableAVOXskipconvert
    934  27000				   -	       lda	#HSIDHI
    935  27000				   -	       sta	eeprombuffer
    936  27000				   -	       lda	#HSIDLO
    937  27000				   -	       sta	eeprombuffer+1
    938  27000				   -	       lda	hsdifficulty
    939  27000				   -	       sta	eeprombuffer+2
    940  27000				   -	       lda	#32
    941  27000				   -	       jsr	AVoxWriteBytes
    942  27000				   -	       rts
    943  27000				   -
    944  27000				   -savedifficultytableHSC
    945  27000				   -			;we always load a table before reaching here, so the
    946  27000				   -			;memory structures from the load should be intact...
    947  27000				   -	       ldy	hsgameslot
    948  27000				   -	       bpl	savealoadedHSCtable
    949  27000				   -	       rts
    950  27000				   -savealoadedHSCtable
    951  27000				   -	       lda	HSCGameDifficulty,y
    952  27000				   -	       cmp	#$7F
    953  27000				   -	       bne	savealoadedHSCtablecontinue
    954  27000				   -	       jsr	initializeHSCtableentry
    955  27000				   -savealoadedHSCtablecontinue
    956  27000				   -			;convert our RAM table to HSC format and write it out...
    957  27000				   -	       ldy	#0
    958  27000				   -	       ldx	#0
    959  27000				   -savedifficultytableScores
    960  27000				   -
    961  27000				   -	       lda	HSRAMInitials,x
    962  27000				   -	       sta	temp3
    963  27000				   -	       lda	HSRAMInitials+1,x
    964  27000				   -	       sta	temp4
    965  27000				   -	       lda	HSRAMInitials+2,x
    966  27000				   -	       sta	temp5
    967  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    968  27000				   -
    969  27000				   -	       lda	temp1
    970  27000				   -	       sta	(HSGameTableLo),y
    971  27000				   -	       iny
    972  27000				   -	       lda	temp2
    973  27000				   -	       sta	(HSGameTableLo),y
    974  27000				   -	       iny
    975  27000				   -
    976  27000				   -	       lda	HSRAMScores,x
    977  27000				   -	       sta	(HSGameTableLo),y
    978  27000				   -	       iny
    979  27000				   -	       lda	HSRAMScores+1,x
    980  27000				   -	       sta	(HSGameTableLo),y
    981  27000				   -	       iny
    982  27000				   -	       lda	HSRAMScores+2,x
    983  27000				   -	       sta	(HSGameTableLo),y
    984  27000				   -	       iny
    985  27000				   -	       inx
    986  27000				   -	       inx
    987  27000				   -	       inx		; +3
    988  27000				   -	       cpx	#15
    989  27000				   -	       bne	savedifficultytableScores
    990  27000				   -	       rts
    991  27000				   -
    992  27000				   -loaddifficultytableHSC
    993  27000				   -			; routine responsible for loading the difficulty table from HSC
    994  27000				   -	       jsr	findindexHSC
    995  27000				   -	       ldy	hsgameslot
    996  27000				   -	       lda	HSCGameDifficulty,y
    997  27000				   -	       cmp	#$7F
    998  27000				   -	       bne	loaddifficultytableHSCcontinue
    999  27000				   -			;there was an error. use a new RAM table instead...
   1000  27000				   -	       jsr	initializeHSCtableentry
   1001  27000				   -	       jmp	cleardifficultytablemem
   1002  27000				   -loaddifficultytableHSCcontinue
   1003  27000				   -			; parse the data into the HS memory...
   1004  27000				   -	       ldy	#0
   1005  27000				   -	       ldx	#0
   1006  27000				   -loaddifficultytableScores
   1007  27000				   -	       lda	(HSGameTableLo),y
   1008  27000				   -	       sta	temp1
   1009  27000				   -	       iny
   1010  27000				   -	       lda	(HSGameTableLo),y
   1011  27000				   -	       sta	temp2
   1012  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1013  27000				   -	       iny
   1014  27000				   -	       lda	(HSGameTableLo),y
   1015  27000				   -	       sta	HSRAMScores,x
   1016  27000				   -	       lda	temp3
   1017  27000				   -	       sta	HSRAMInitials,x
   1018  27000				   -	       inx
   1019  27000				   -	       iny
   1020  27000				   -	       lda	(HSGameTableLo),y
   1021  27000				   -	       sta	HSRAMScores,x
   1022  27000				   -	       lda	temp4
   1023  27000				   -	       sta	HSRAMInitials,x
   1024  27000				   -	       inx
   1025  27000				   -	       iny
   1026  27000				   -	       lda	(HSGameTableLo),y
   1027  27000				   -	       sta	HSRAMScores,x
   1028  27000				   -	       lda	temp5
   1029  27000				   -	       sta	HSRAMInitials,x
   1030  27000				   -	       inx
   1031  27000				   -	       iny
   1032  27000				   -	       cpx	#15
   1033  27000				   -	       bne	loaddifficultytableScores
   1034  27000				   -	       rts
   1035  27000				   -
   1036  27000				   -decodeHSCInitials
   1037  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1038  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1039  27000				   -	       lda	#0
   1040  27000				   -	       sta	temp4
   1041  27000				   -	       lda	temp1
   1042  27000				   -	       and	#%00011111
   1043  27000				   -	       sta	temp3
   1044  27000				   -
   1045  27000				   -	       lda	temp2
   1046  27000				   -	       and	#%00011111
   1047  27000				   -	       sta	temp5
   1048  27000				   -
   1049  27000				   -	       lda	temp1
   1050  27000				   -	       asl
   1051  27000				   -	       rol	temp4
   1052  27000				   -	       asl
   1053  27000				   -	       rol	temp4
   1054  27000				   -	       asl
   1055  27000				   -	       rol	temp4
   1056  27000				   -	       lda	temp2
   1057  27000				   -	       asl
   1058  27000				   -	       rol	temp4
   1059  27000				   -	       asl
   1060  27000				   -	       rol	temp4
   1061  27000				   -	       rts
   1062  27000				   -encodeHSCInitials
   1063  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1064  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1065  27000				   -			; start with packing temp1...
   1066  27000				   -	       lda	temp4
   1067  27000				   -	       and	#%00011100
   1068  27000				   -	       sta	temp1
   1069  27000				   -	       asl	temp1
   1070  27000				   -	       asl	temp1
   1071  27000				   -	       asl	temp1
   1072  27000				   -	       lda	temp3
   1073  27000				   -	       and	#%00011111
   1074  27000				   -	       ora	temp1
   1075  27000				   -	       sta	temp1
   1076  27000				   -			; ...temp1 is now packed, on to temp2...
   1077  27000				   -	       lda	temp5
   1078  27000				   -	       asl
   1079  27000				   -	       asl
   1080  27000				   -	       ror	temp4
   1081  27000				   -	       ror
   1082  27000				   -	       ror	temp4
   1083  27000				   -	       ror
   1084  27000				   -	       sta	temp2
   1085  27000				   -	       rts
   1086  27000				   -
   1087  27000				   -findindexHSCerror
   1088  27000				   -			;the HSC is stuffed. return the bad slot flag
   1089  27000				   -	       ldy	#$ff
   1090  27000				   -	       sty	hsgameslot
   1091  27000				   -	       rts
   1092  27000				   -
   1093  27000				   -findindexHSC
   1094  27000				   -HSCGameID1 =	$1029
   1095  27000				   -HSCGameID2 =	$106E
   1096  27000				   -HSCGameDifficulty =	$10B3
   1097  27000				   -HSCGameIndex =	$10F8
   1098  27000				   -			; routine responsible for finding the game index from HSC
   1099  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1100  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1101  27000				   -	       ldy	#69	; start +1 to account for the dey
   1102  27000				   -findindexHSCloop
   1103  27000				   -	       dey
   1104  27000				   -	       bmi	findindexHSCerror
   1105  27000				   -	       lda	HSCGameDifficulty,y
   1106  27000				   -	       cmp	#$7F
   1107  27000				   -	       beq	findourindexHSC
   1108  27000				   -	       cmp	gamedifficulty
   1109  27000				   -	       bne	findindexHSCloop
   1110  27000				   -	       lda	HSCGameID1,y
   1111  27000				   -	       cmp	#HSIDHI
   1112  27000				   -	       bne	findindexHSCloop
   1113  27000				   -	       lda	HSCGameID2,y
   1114  27000				   -	       cmp	#HSIDLO
   1115  27000				   -	       bne	findindexHSCloop
   1116  27000				   -findourindexHSC
   1117  27000				   -			; if we're here we found our index in the table
   1118  27000				   -			; or we found the first empty one
   1119  27000				   -	       sty	hsgameslot
   1120  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1121  27000				   -	       rts
   1122  27000				   -
   1123  27000				   -
   1124  27000				   -initializeHSCtableentry
   1125  27000				   -	       ldy	hsgameslot
   1126  27000				   -			; we need to make a new entry...
   1127  27000				   -	       lda	#HSIDHI
   1128  27000				   -	       sta	HSCGameID1,y
   1129  27000				   -	       lda	#HSIDLO
   1130  27000				   -	       sta	HSCGameID2,y
   1131  27000				   -	       lda	gamedifficulty
   1132  27000				   -	       sta	HSCGameDifficulty,y
   1133  27000				   -	       ldx	#0
   1134  27000				   -fixHSDGameDifficultylistLoop
   1135  27000				   -	       inx
   1136  27000				   -	       txa
   1137  27000				   -	       sta	HSCGameIndex,y
   1138  27000				   -	       iny
   1139  27000				   -	       cpy	#69
   1140  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1141  27000				   -	       rts
   1142  27000				   -
   1143  27000				   -setupHSCGamepointer
   1144  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1145  27000				   -	       lda	#$17
   1146  27000				   -	       sta	HSGameTableHi
   1147  27000				   -	       lda	#$FA
   1148  27000				   -	       sta	HSGameTableLo
   1149  27000				   -setupHSCGamepointerLoop
   1150  27000				   -	       lda	HSGameTableLo
   1151  27000				   -	       sec
   1152  27000				   -	       sbc	#25
   1153  27000				   -	       sta	HSGameTableLo
   1154  27000				   -	       lda	HSGameTableHi
   1155  27000				   -	       sbc	#0
   1156  27000				   -	       sta	HSGameTableHi
   1157  27000				   -	       iny
   1158  27000				   -	       cpy	#69
   1159  27000				   -	       bne	setupHSCGamepointerLoop
   1160  27000				   -	       rts
   1161  27000				   -
   1162  27000				   -loaddifficultytableAVOX
   1163  27000				   -			; routine responsible for loading the difficulty table from Avox
   1164  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1165  27000				   -	       lda	#>(eeprombuffer+3)
   1166  27000				   -	       sta	HSGameTableHi
   1167  27000				   -	       lda	#<(eeprombuffer+3)
   1168  27000				   -	       sta	HSGameTableLo
   1169  27000				   -
   1170  27000				   -			; the start location in EEPROM, subtract 32...
   1171  27000				   -	       lda	#$5F
   1172  27000				   -	       sta	HSVoxHi
   1173  27000				   -	       lda	#$E0
   1174  27000				   -	       sta	HSVoxLo
   1175  27000				   -	       lda	#0
   1176  27000				   -	       sta	temp1
   1177  27000				   -loaddifficultytableAVOXloop
   1178  27000				   -	       inc	temp1
   1179  27000				   -	       beq	loaddifficultytableAVOXfull
   1180  27000				   -	       clc
   1181  27000				   -	       lda	HSVoxLo
   1182  27000				   -	       adc	#32
   1183  27000				   -	       sta	HSVoxLo
   1184  27000				   -	       lda	HSVoxHi
   1185  27000				   -	       adc	#0
   1186  27000				   -	       sta	HSVoxHi
   1187  27000				   -	       lda	#3
   1188  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1189  27000				   -	       lda	eeprombuffer
   1190  27000				   -	       cmp	#$FF
   1191  27000				   -	       beq	loaddifficultytableAVOXempty
   1192  27000				   -	       cmp	#HSIDHI
   1193  27000				   -	       bne	loaddifficultytableAVOXloop
   1194  27000				   -	       lda	eeprombuffer+1
   1195  27000				   -	       cmp	#HSIDLO
   1196  27000				   -	       bne	loaddifficultytableAVOXloop
   1197  27000				   -	       lda	eeprombuffer+2
   1198  27000				   -	       cmp	gamedifficulty
   1199  27000				   -	       bne	loaddifficultytableAVOXloop
   1200  27000				   -loaddifficultytableAVOXdone
   1201  27000				   -	       lda	#32
   1202  27000				   -	       jsr	AVoxReadBytes
   1203  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1204  27000				   -	       rts
   1205  27000				   -loaddifficultytableAVOXfull
   1206  27000				   -	       lda	#0
   1207  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1208  27000				   -loaddifficultytableAVOXempty
   1209  27000				   -	       jmp	cleardifficultytablemem
   1210  27000				   -	       rts
   1211  27000				   -
   1212  27000				   -cleardifficultytablemem
   1213  27000				   -	       ldy	#29
   1214  27000				   -	       lda	#0
   1215  27000				   -cleardifficultytablememloop
   1216  27000				   -	       sta	HSRAMTable,y
   1217  27000				   -	       dey
   1218  27000				   -	       bpl	cleardifficultytablememloop
   1219  27000				   -	       rts
   1220  27000				   -hiscoremoduleend
   1221  27000				   -
   1222  27000				   -	       ifconst	DOUBLEWIDE
   1223  27000				   -plotvaluedw
   1224  27000				   -plotdigitcount =	temp6
   1225  27000				   -	       lda	#0
   1226  27000				   -	       tay
   1227  27000				   -	       ldx	valbufend
   1228  27000				   -
   1229  27000				   -	       lda	plotdigitcount
   1230  27000				   -	       and	#1
   1231  27000				   -	       beq	pvnibble2chardw
   1232  27000				   -	       lda	#0
   1233  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1234  27000				   -	       beq	pvnibble2char_skipnibbledw
   1235  27000				   -
   1236  27000				   -pvnibble2chardw
   1237  27000				   -			; high nibble...
   1238  27000				   -	       lda	(temp7),y
   1239  27000				   -	       and	#$f0
   1240  27000				   -	       lsr
   1241  27000				   -	       lsr
   1242  27000				   -	       lsr
   1243  27000				   -	       lsr
   1244  27000				   -
   1245  27000				   -	       clc
   1246  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1247  27000				   -	       sta	VALBUFFER,x
   1248  27000				   -	       inx
   1249  27000				   -	       dec	plotdigitcount
   1250  27000				   -pvnibble2char_skipnibbledw
   1251  27000				   -			; low nibble...
   1252  27000				   -	       lda	(temp7),y
   1253  27000				   -	       and	#$0f
   1254  27000				   -	       clc
   1255  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1256  27000				   -	       sta	VALBUFFER,x
   1257  27000				   -	       inx
   1258  27000				   -	       iny
   1259  27000				   -
   1260  27000				   -	       dec	plotdigitcount
   1261  27000				   -	       bne	pvnibble2chardw
   1262  27000				   -			;point to the start of our valuebuffer
   1263  27000				   -	       clc
   1264  27000				   -	       lda	#<VALBUFFER
   1265  27000				   -	       adc	valbufend
   1266  27000				   -	       sta	temp1
   1267  27000				   -	       lda	#>VALBUFFER
   1268  27000				   -	       adc	#0
   1269  27000				   -	       sta	temp2
   1270  27000				   -
   1271  27000				   -			;advance valbufend to the end of our value buffer
   1272  27000				   -	       stx	valbufend
   1273  27000				   -
   1274  27000				   -	       ifnconst	plotvalueonscreen
   1275  27000				   -	       jmp	plotcharacters
   1276  27000				   -	       else
   1277  27000				   -	       jmp	plotcharacterslive
   1278  27000				   -	       endif
   1279  27000				   -	       endif		; DOUBLEWIDE
   1280  27000				   -
   1281  27000				   -hiscoreend
   1282  27000				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1283  27000				   -	       endif		; !isBANKSETBANK
   1284  27000					       endif		; HSSUPPORT
   1285  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1754  27000					       endif
   1755  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes)"
     58  27000				   -
     59  27000					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\demo1\lesson3_3.78b.asm
   1757  27000					       endif
   1758  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1759  27000
   1760  27000							;standard routimes needed for pretty much all games
   1761  27000
   1762  27000							; some definitions used with "set debug color"
   1763  27000			00 91	    DEBUGCALC  =	$91
   1764  27000			00 41	    DEBUGWASTE =	$41
   1765  27000			00 c1	    DEBUGDRAW  =	$C1
   1766  27000
   1767  27000							;NMI and IRQ handlers
   1768  27000				    NMI
   1769  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   1770  27000			48		       pha		; save A
   1771  27001			d8		       cld
   1772  27002			a5 4d		       lda	visibleover
   1773  27004			49 ff		       eor	#255
   1774  27006			85 4d		       sta	visibleover
   1775  27008				   -	       ifconst	DEBUGINTERRUPT
   1776  27008				   -	       and	#$93
   1777  27008				   -	       sta	BACKGRND
   1778  27008					       endif
   1779  27008			8a		       txa		; save X
   1780  27009			48		       pha
   1781  2700a			98		       tya		; save Y
   1782  2700b			48		       pha
   1783  2700c			ce b2 01	       dec	interruptindex
   1784  2700f			d0 03		       bne	skipreallyoffvisible
   1785  27011			4c 73 f0	       jmp	reallyoffvisible
   1786  27014				    skipreallyoffvisible
   1787  27014			a5 4d		       lda	visibleover
   1788  27016			d0 03		       bne	carryontopscreenroutine
   1789  27018				   -	       ifconst	.bottomscreenroutine
   1790  27018				   -	       lda	interrupthold
   1791  27018				   -	       beq	skipbottomroutine
   1792  27018				   -	       jsr	.bottomscreenroutine
   1793  27018				   -skipbottomroutine
   1794  27018					       endif
   1795  27018			4c 81 f0	       jmp	NMIexit
   1796  2701b				    carryontopscreenroutine
   1797  2701b				   -	       ifconst	.topscreenroutine
   1798  2701b				   -	       lda	interrupthold
   1799  2701b				   -	       beq	skiptoproutine
   1800  2701b				   -	       jsr	.topscreenroutine
   1801  2701b				   -skiptoproutine
   1802  2701b					       endif
   1803  2701b					       ifnconst	CANARYOFF
   1804  2701b			ad c3 01	       lda	canary
   1805  2701e			f0 07		       beq	skipcanarytriggered
   1806  27020			a9 45		       lda	#$45
   1807  27022			85 20		       sta	BACKGRND
   1808  27024			4c 6b f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   1809  27027				    skipcanarytriggered
   1810  27027					       endif
   1811  27027
   1812  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   1813  2702a
   1814  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   1815  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   1816  2702a
   1817  2702a				   -	       ifconst	LONGCONTROLLERREAD
   1818  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   1819  2702a				   -	       ldy	port1control
   1820  2702a				   -	       lda	longreadtype,y
   1821  2702a				   -	       beq	LLRET1
   1822  2702a				   -	       tay
   1823  2702a				   -	       lda	longreadroutinehiP1,y
   1824  2702a				   -	       sta	inttemp4
   1825  2702a				   -	       lda	longreadroutineloP1,y
   1826  2702a				   -	       sta	inttemp3
   1827  2702a				   -	       jmp	(inttemp3)
   1828  2702a				   -LLRET1
   1829  2702a				   -	       ldy	port0control
   1830  2702a				   -	       lda	longreadtype,y
   1831  2702a				   -	       beq	LLRET0
   1832  2702a				   -	       tay
   1833  2702a				   -	       lda	longreadroutinehiP0,y
   1834  2702a				   -	       sta	inttemp4
   1835  2702a				   -	       lda	longreadroutineloP0,y
   1836  2702a				   -	       sta	inttemp3
   1837  2702a				   -	       jmp	(inttemp3)
   1838  2702a				   -LLRET0
   1839  2702a				   -
   1840  2702a				   -
   1841  2702a				   -	       ifconst	PADDLERANGE
   1842  2702a				   -TIMEVAL    =	PADDLERANGE
   1843  2702a				   -	       else
   1844  2702a				   -TIMEVAL    =	160
   1845  2702a				   -	       endif
   1846  2702a				   -TIMEOFFSET =	10
   1847  2702a				   -
   1848  2702a					       endif		; LONGCONTROLLERREAD
   1849  2702a
   1850  2702a
   1851  2702a			20 01 f2	       jsr	servicesfxchannels
   1852  2702d				   -	       ifconst	MUSICTRACKER
   1853  2702d				   -	       jsr	servicesong
   1854  2702d					       endif		; MUSICTRACKER
   1855  2702d				   -	       ifconst	RMT
   1856  2702d				   -	       lda	rasterpause
   1857  2702d				   -	       beq	skiprasterupdate
   1858  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   1859  2702d				   -skiprasterupdate
   1860  2702d				   -RMT_Iend
   1861  2702d					       endif
   1862  2702d
   1863  2702d			ee a4 01	       inc	framecounter
   1864  27030			ad a4 01	       lda	framecounter
   1865  27033			29 3f		       and	#63
   1866  27035			d0 08		       bne	skipcountdownseconds
   1867  27037			ad a5 01	       lda	countdownseconds
   1868  2703a			f0 03		       beq	skipcountdownseconds
   1869  2703c			ce a5 01	       dec	countdownseconds
   1870  2703f				    skipcountdownseconds
   1871  2703f
   1872  2703f			a2 01		       ldx	#1
   1873  27041				    buttonreadloop
   1874  27041			8a		       txa
   1875  27042			48		       pha
   1876  27043			bc b9 01	       ldy	port0control,x
   1877  27046			b9 de f1	       lda	buttonhandlerlo,y
   1878  27049			85 da		       sta	inttemp3
   1879  2704b			b9 d2 f1	       lda	buttonhandlerhi,y
   1880  2704e			85 db		       sta	inttemp4
   1881  27050			05 da		       ora	inttemp3
   1882  27052			f0 03		       beq	buttonreadloopreturn
   1883  27054			6c da 00	       jmp	(inttemp3)
   1884  27057				    buttonreadloopreturn
   1885  27057			68		       pla
   1886  27058			aa		       tax
   1887  27059			ca		       dex
   1888  2705a			10 e5		       bpl	buttonreadloop
   1889  2705c
   1890  2705c							;ifconst KEYPADSUPPORT
   1891  2705c							;  jsr keypadrowselect
   1892  2705c							;endif ; KEYPADSUPPORT
   1893  2705c
   1894  2705c
   1895  2705c					       ifconst	DOUBLEBUFFER
   1896  2705c			ad b4 01	       lda	doublebufferminimumframeindex
   1897  2705f			f0 03		       beq	skipdoublebufferminimumframeindexadjust
   1898  27061			ce b4 01	       dec	doublebufferminimumframeindex
   1899  27064				    skipdoublebufferminimumframeindexadjust
   1900  27064					       endif
   1901  27064
   1902  27064			4c 81 f0	       jmp	NMIexit
   1903  27067
   1904  27067				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   1905  27067					       ifnconst	BREAKPROTECTOFF
   1906  27067			a9 1a		       lda	#$1A
   1907  27069			85 20		       sta	BACKGRND
   1908  2706b				    skipbrkolorset
   1909  2706b				    skipbrkdetected
   1910  2706b			a9 60		       lda	#$60
   1911  2706d			8d 07 21	       sta	sCTRL
   1912  27070			85 3c		       sta	CTRL
   1913  27072					       ifnconst	hiscorefont
   1914  27072			02		       .byte.b	$02	; KIL/JAM
   1915  27073				   -	       else		; hiscorefont is present
   1916  27073				   -	       ifconst	CRASHDUMP
   1917  27073				   -	       bit	MSTAT
   1918  27073				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   1919  27073				   -
   1920  27073				   -	       ifconst	dumpbankswitch
   1921  27073				   -	       lda	dumpbankswitch
   1922  27073				   -	       pha
   1923  27073				   -	       endif
   1924  27073				   -
   1925  27073				   -			; bankswitch if needed, to get to the hiscore font
   1926  27073				   -	       ifconst	bankswitchmode
   1927  27073				   -	       ifconst	included.hiscore.asm.bank
   1928  27073				   -	       ifconst	MCPDEVCART
   1929  27073				   -	       lda	#($18 | included.hiscore.asm.bank)
   1930  27073				   -	       sta	$3000
   1931  27073				   -	       else
   1932  27073				   -	       lda	#(included.hiscore.asm.bank)
   1933  27073				   -	       sta	$8000
   1934  27073				   -	       endif
   1935  27073				   -	       endif		; included.hiscore.asm.bank
   1936  27073				   -	       endif		; bankswitchmode
   1937  27073				   -
   1938  27073				   -	       ifconst	DOUBLEBUFFER
   1939  27073				   -			;turn off double-buffering, if on...
   1940  27073				   -	       lda	#>DLLMEM
   1941  27073				   -	       sta	DPPH
   1942  27073				   -	       lda	#<DLLMEM
   1943  27073				   -	       sta	DPPL
   1944  27073				   -	       endif
   1945  27073				   -
   1946  27073				   -	       lda	#$00
   1947  27073				   -	       sta	P0C2
   1948  27073				   -
   1949  27073				   -			;update the second-from-top DL...
   1950  27073				   -	       ldy	#8
   1951  27073				   -NMIupdatetopDL
   1952  27073				   -	       lda	show2700,y
   1953  27073				   -	       sta	ZONE1ADDRESS,y
   1954  27073				   -	       dey
   1955  27073				   -	       bpl	NMIupdatetopDL
   1956  27073				   -
   1957  27073				   -			; the hiscore font is present, so we try to output the stack
   1958  27073				   -	       ldy	#0
   1959  27073				   -copystackloop
   1960  27073				   -	       pla
   1961  27073				   -	       pha
   1962  27073				   -	       lsr
   1963  27073				   -	       lsr
   1964  27073				   -	       lsr
   1965  27073				   -	       lsr
   1966  27073				   -	       tax
   1967  27073				   -	       lda	hiscorehexlut,x
   1968  27073				   -	       sta	$2700,y
   1969  27073				   -	       iny
   1970  27073				   -
   1971  27073				   -	       pla
   1972  27073				   -	       and	#$0F
   1973  27073				   -	       tax
   1974  27073				   -	       lda	hiscorehexlut,x
   1975  27073				   -	       sta	$2700,y
   1976  27073				   -	       iny
   1977  27073				   -
   1978  27073				   -	       lda	#27	; period
   1979  27073				   -	       sta	$2700,y
   1980  27073				   -	       iny
   1981  27073				   -
   1982  27073				   -	       cpy	#30
   1983  27073				   -	       bne	copystackloop
   1984  27073				   -
   1985  27073				   -	       lda	#>hiscorefont
   1986  27073				   -	       sta	CHARBASE
   1987  27073				   -	       sta	sCHARBASE
   1988  27073				   -	       lda	#%01000011	;Enable DMA, mode=320A
   1989  27073				   -	       sta	CTRL
   1990  27073				   -	       sta	sCTRL
   1991  27073				   -	       .byte	$02	; KIL/JAM
   1992  27073				   -hiscorehexlut
   1993  27073				   -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   1994  27073				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   1995  27073				   -show2700
   1996  27073				   -			;	 lo   mode	   hi	width=29  x   EODL
   1997  27073				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   1998  27073				   -	       else		; CRASHDUMP
   1999  27073				   -	       .byte	$02	; KIL/JAM
   2000  27073				   -	       endif		; crashdump
   2001  27073					       endif		; hiscorefont
   2002  27073				   -	       else
   2003  27073				   -	       RTI
   2004  27073					       endif
   2005  27073
   2006  27073				   -	       ifconst	LONGCONTROLLERREAD
   2007  27073				   -
   2008  27073				   -longreadtype
   2009  27073				   -	       .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   2010  27073				   -	       .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   2011  27073				   -	       .byte	3, 3, 0, 0	; STMOUSE  AMOUSE    ATARIVOX	SNES
   2012  27073				   -
   2013  27073				   -longreadroutineloP0
   2014  27073				   -	       .byte	<LLRET0	;  0 = no routine
   2015  27073				   -	       .byte	<paddleport0update	;  1 = paddle
   2016  27073				   -	       .byte	<trakball0update	;  2 = trakball
   2017  27073				   -	       .byte	<mouse0update	;  3 = mouse
   2018  27073				   -
   2019  27073				   -longreadroutinehiP0
   2020  27073				   -	       .byte	>LLRET0	;  0 = no routine
   2021  27073				   -	       .byte	>paddleport0update	;  1 = paddle
   2022  27073				   -	       .byte	>trakball0update	;  2 = trackball
   2023  27073				   -	       .byte	>mouse0update	;  3 = mouse
   2024  27073				   -
   2025  27073				   -longreadroutineloP1
   2026  27073				   -	       .byte	<LLRET1	;  0 = no routine
   2027  27073				   -	       .byte	<paddleport1update	;  1 = paddle
   2028  27073				   -	       .byte	<trakball1update	;  2 = trakball
   2029  27073				   -	       .byte	<mouse1update	;  3 = mouse
   2030  27073				   -
   2031  27073				   -longreadroutinehiP1
   2032  27073				   -	       .byte	>LLRET1	;  0 = no routine
   2033  27073				   -	       .byte	>paddleport1update	;  1 = paddle
   2034  27073				   -	       .byte	>trakball1update	;  2 = trackball
   2035  27073				   -	       .byte	>mouse1update	;  3 = mouse
   2036  27073				   -
   2037  27073				   -
   2038  27073				   -SETTIM64T
   2039  27073				   -	       bne	skipdefaulttime
   2040  27073				   -	       ifnconst	PADDLESMOOTHINGOFF
   2041  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   2042  27073				   -	       else
   2043  27073				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   2044  27073				   -	       endif
   2045  27073				   -skipdefaulttime
   2046  27073				   -	       tay
   2047  27073				   -	       dey
   2048  27073				   -.setTIM64Tloop
   2049  27073				   -	       sta	TIM64T
   2050  27073				   -	       cpy	INTIM
   2051  27073				   -	       bne	.setTIM64Tloop
   2052  27073				   -	       rts
   2053  27073					       endif		; LONGCONTROLLERREAD
   2054  27073
   2055  27073				    reallyoffvisible
   2056  27073			85 24		       sta	WSYNC
   2057  27075
   2058  27075			a9 00		       lda	#0
   2059  27077			85 4d		       sta	visibleover
   2060  27079				   -	       ifconst	DEBUGINTERRUPT
   2061  27079				   -	       sta	BACKGRND
   2062  27079					       endif
   2063  27079
   2064  27079			a9 03		       lda	#3
   2065  2707b			8d b2 01	       sta	interruptindex
   2066  2707e
   2067  2707e			20 73 f1	       jsr	uninterruptableroutines
   2068  27081
   2069  27081				   -	       ifconst	.userinterrupt
   2070  27081				   -	       lda	interrupthold
   2071  27081				   -	       beq	skipuserintroutine
   2072  27081				   -	       jsr	.userinterrupt
   2073  27081				   -skipuserintroutine
   2074  27081					       endif
   2075  27081
   2076  27081				   -	       ifconst	KEYPADSUPPORT
   2077  27081				   -	       jsr	keypadcolumnread
   2078  27081				   -	       jsr	keypadrowselect
   2079  27081					       endif
   2080  27081
   2081  27081				    NMIexit
   2082  27081			68		       pla
   2083  27082			a8		       tay
   2084  27083			68		       pla
   2085  27084			aa		       tax
   2086  27085			68		       pla
   2087  27086			40		       RTI
   2088  27087
   2089  27087				    clearscreen
   2090  27087			a2 0b		       ldx	#(WZONECOUNT-1)
   2091  27089			a9 00		       lda	#0
   2092  2708b				    clearscreenloop
   2093  2708b			95 65		       sta	dlend,x
   2094  2708d			ca		       dex
   2095  2708e			10 fb		       bpl	clearscreenloop
   2096  27090			a9 00		       lda	#0
   2097  27092			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   2098  27095			8d ae 01	       sta	valbufendsave
   2099  27098			60		       rts
   2100  27099
   2101  27099				    restorescreen
   2102  27099			a2 0b		       ldx	#(WZONECOUNT-1)
   2103  2709b			a9 00		       lda	#0
   2104  2709d				    restorescreenloop
   2105  2709d			b5 82		       lda	dlendsave,x
   2106  2709f			95 65		       sta	dlend,x
   2107  270a1			ca		       dex
   2108  270a2			10 f9		       bpl	restorescreenloop
   2109  270a4			ad ae 01	       lda	valbufendsave
   2110  270a7			8d ad 01	       sta	valbufend
   2111  270aa			60		       rts
   2112  270ab
   2113  270ab				    savescreen
   2114  270ab			a2 0b		       ldx	#(WZONECOUNT-1)
   2115  270ad				    savescreenloop
   2116  270ad			b5 65		       lda	dlend,x
   2117  270af			95 82		       sta	dlendsave,x
   2118  270b1			ca		       dex
   2119  270b2			10 f9		       bpl	savescreenloop
   2120  270b4			ad ad 01	       lda	valbufend
   2121  270b7			8d ae 01	       sta	valbufendsave
   2122  270ba					       ifconst	DOUBLEBUFFER
   2123  270ba			a5 d5		       lda	doublebufferstate
   2124  270bc			f0 04		       beq	savescreenrts
   2125  270be			a9 01		       lda	#1
   2126  270c0			85 d7		       sta	doublebufferbufferdirty
   2127  270c2				    savescreenrts
   2128  270c2					       endif		; DOUBLEBUFFER
   2129  270c2			60		       rts
   2130  270c3
   2131  270c3				    drawscreen
   2132  270c3
   2133  270c3				   -	       ifconst	interrupthold
   2134  270c3				   -	       lda	#$FF
   2135  270c3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   2136  270c3					       endif
   2137  270c3
   2138  270c3			a9 00		       lda	#0
   2139  270c5			85 42		       sta	temp1	; not B&W if we're here...
   2140  270c7
   2141  270c7				    drawscreenwait
   2142  270c7			a5 4d		       lda	visibleover
   2143  270c9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2144  270cb
   2145  270cb							;restore some registers in case the game changed them mid-screen...
   2146  270cb			ad 07 21	       lda	sCTRL
   2147  270ce			05 42		       ora	temp1
   2148  270d0			85 3c		       sta	CTRL
   2149  270d2			ad 0b 21	       lda	sCHARBASE
   2150  270d5			85 34		       sta	CHARBASE
   2151  270d7
   2152  270d7							;ensure all of the display list is terminated...
   2153  270d7			20 50 f1	       jsr	terminatedisplaylist
   2154  270da
   2155  270da					       ifnconst	pauseroutineoff
   2156  270da			20 e5 f0	       jsr	pauseroutine
   2157  270dd					       endif		; pauseroutineoff
   2158  270dd
   2159  270dd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2160  270dd							; delaying a full frame, but still allowing time for basic calculations.
   2161  270dd				    visiblescreenstartedwait
   2162  270dd			a5 4d		       lda	visibleover
   2163  270df			f0 fc		       beq	visiblescreenstartedwait
   2164  270e1				    visiblescreenstartedwaitdone
   2165  270e1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2166  270e4			60		       rts
   2167  270e5
   2168  270e5					       ifnconst	pauseroutineoff
   2169  270e5							; check to see if pause was pressed and released
   2170  270e5				    pauseroutine
   2171  270e5			ad b5 01	       lda	pausedisable
   2172  270e8			d0 55		       bne	leavepauseroutine
   2173  270ea			a9 08		       lda	#8
   2174  270ec			2c 82 02	       bit	SWCHB
   2175  270ef			f0 30		       beq	pausepressed
   2176  270f1
   2177  270f1					       ifnconst	SOFTPAUSEOFF
   2178  270f1					       ifnconst	SOFTRESETASPAUSEOFF
   2179  270f1					       ifnconst	MOUSESUPPORT
   2180  270f1					       ifnconst	TRAKBALLSUPPORT
   2181  270f1			ad b9 01	       lda	port0control
   2182  270f4			c9 0b		       cmp	#11
   2183  270f6			d0 07		       bne	skipsoftpause
   2184  270f8			ad 80 02	       lda	SWCHA	; then check the soft "RESET" joysick code...
   2185  270fb			29 70		       and	#%01110000	; _LDU
   2186  270fd			f0 22		       beq	pausepressed
   2187  270ff				    skipsoftpause
   2188  270ff					       endif
   2189  270ff					       endif
   2190  270ff					       endif
   2191  270ff					       endif
   2192  270ff				   -	       ifconst	SNES0PAUSE
   2193  270ff				   -	       lda	port0control
   2194  270ff				   -	       cmp	#11
   2195  270ff				   -	       bne	skipsnes0pause
   2196  270ff				   -	       lda	snesdetected0
   2197  270ff				   -	       beq	skipsnes0pause
   2198  270ff				   -	       lda	snes2atari0hi
   2199  270ff				   -	       and	#%00010000
   2200  270ff				   -	       beq	pausepressed
   2201  270ff				   -skipsnes0pause
   2202  270ff					       endif
   2203  270ff				   -	       ifconst	SNES1PAUSE
   2204  270ff				   -
   2205  270ff				   -	       lda	port1control
   2206  270ff				   -	       cmp	#11
   2207  270ff				   -	       bne	skipsnes1pause
   2208  270ff				   -	       lda	snesdetected1
   2209  270ff				   -	       beq	skipsnes1pause
   2210  270ff				   -	       lda	snes2atari1hi
   2211  270ff				   -	       and	#%00010000
   2212  270ff				   -	       beq	pausepressed
   2213  270ff				   -skipsnes1pause
   2214  270ff					       endif
   2215  270ff				   -	       ifconst	SNESNPAUSE
   2216  270ff				   -	       ldx	snesport
   2217  270ff				   -	       lda	port0control,x
   2218  270ff				   -	       cmp	#11
   2219  270ff				   -	       bne	skipsnesNpause
   2220  270ff				   -	       lda	snesdetected0,x
   2221  270ff				   -	       beq	skipsnesNpause
   2222  270ff				   -	       lda	snes2atari0hi,x
   2223  270ff				   -	       and	#%00010000
   2224  270ff				   -	       beq	pausepressed
   2225  270ff				   -skipsnesNpause
   2226  270ff					       endif
   2227  270ff
   2228  270ff							;pause isn't pressed
   2229  270ff			a9 00		       lda	#0
   2230  27101			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2231  27104
   2232  27104							;check if we're in an already paused state
   2233  27104			ad 00 21	       lda	pausestate
   2234  27107			f0 36		       beq	leavepauseroutine	; nope, leave
   2235  27109
   2236  27109			c9 01		       cmp	#1	; last frame was the start of pausing
   2237  2710b			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   2238  2710d
   2239  2710d			c9 02		       cmp	#2
   2240  2710f			f0 34		       beq	carryonpausing
   2241  27111
   2242  27111							;pausestate must be >2, which means we're ending an unpause 
   2243  27111			a9 00		       lda	#0
   2244  27113			8d ac 01	       sta	pausebuttonflag
   2245  27116			8d 00 21	       sta	pausestate
   2246  27119			ad 07 21	       lda	sCTRL
   2247  2711c			85 3c		       sta	CTRL
   2248  2711e			4c 3f f1	       jmp	leavepauseroutine
   2249  27121
   2250  27121				    pausepressed
   2251  27121							;pause is pressed
   2252  27121			ad ac 01	       lda	pausebuttonflag
   2253  27124			c9 ff		       cmp	#$ff
   2254  27126			f0 1d		       beq	carryonpausing
   2255  27128
   2256  27128							;its a new press, increment the state
   2257  27128			ee 00 21	       inc	pausestate
   2258  2712b
   2259  2712b							;silence volume at the start and end of pausing
   2260  2712b			a9 00		       lda	#0
   2261  2712d			85 19		       sta	AUDV0
   2262  2712f			85 1a		       sta	AUDV1
   2263  27131
   2264  27131				   -	       ifconst	pokeysupport
   2265  27131				   -	       ldy	#7
   2266  27131				   -pausesilencepokeyaudioloop
   2267  27131				   -	       sta	(pokeybase),y
   2268  27131				   -	       dey
   2269  27131				   -	       bpl	pausesilencepokeyaudioloop
   2270  27131					       endif		; pokeysupport
   2271  27131
   2272  27131			a9 ff		       lda	#$ff
   2273  27133			8d ac 01	       sta	pausebuttonflag
   2274  27136			d0 0d		       bne	carryonpausing
   2275  27138
   2276  27138				    enterpausestate2
   2277  27138			a9 02		       lda	#2
   2278  2713a			8d 00 21	       sta	pausestate
   2279  2713d			d0 06		       bne	carryonpausing
   2280  2713f				    leavepauseroutine
   2281  2713f			ad 07 21	       lda	sCTRL
   2282  27142			85 3c		       sta	CTRL
   2283  27144			60		       rts
   2284  27145				    carryonpausing
   2285  27145				   -	       ifconst	.pause
   2286  27145				   -	       jsr	.pause
   2287  27145					       endif		; .pause
   2288  27145			ad 07 21	       lda	sCTRL
   2289  27148			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2290  2714a			85 3c		       sta	CTRL
   2291  2714c			4c e5 f0	       jmp	pauseroutine
   2292  2714f					       endif		; pauseroutineoff
   2293  2714f
   2294  2714f
   2295  2714f					       ifconst	DOUBLEBUFFER
   2296  2714f				    skipterminatedisplaylistreturn
   2297  2714f			60		       rts
   2298  27150					       endif		; DOUBLEBUFFER
   2299  27150				    terminatedisplaylist
   2300  27150					       ifconst	DOUBLEBUFFER
   2301  27150			a5 d5		       lda	doublebufferstate
   2302  27152			d0 fb		       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2303  27154					       endif		; DOUBLEBUFFER
   2304  27154				    terminatedisplaybuffer
   2305  27154							;add DL end entry on each DL
   2306  27154			a2 0b		       ldx	#(WZONECOUNT-1)
   2307  27156				    dlendloop
   2308  27156			bd e2 f6	       lda	DLPOINTL,x
   2309  27159					       ifconst	DOUBLEBUFFER
   2310  27159			18		       clc
   2311  2715a			65 d6		       adc	doublebufferdloffset
   2312  2715c					       endif		; DOUBLEBUFFER
   2313  2715c			85 63		       sta	dlpnt
   2314  2715e			bd d6 f6	       lda	DLPOINTH,x
   2315  27161					       ifconst	DOUBLEBUFFER
   2316  27161			69 00		       adc	#0
   2317  27163					       endif		; DOUBLEBUFFER
   2318  27163			85 64		       sta	dlpnt+1
   2319  27165			b4 65		       ldy	dlend,x
   2320  27167			a9 00		       lda	#$00
   2321  27169				    dlendmoreloops
   2322  27169			c8		       iny
   2323  2716a			91 63		       sta	(dlpnt),y
   2324  2716c				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2325  2716c				   -	       cpy	#DLLASTOBJ+1
   2326  2716c				   -	       beq	dlendthiszonedone
   2327  2716c				   -	       iny
   2328  2716c				   -	       iny
   2329  2716c				   -	       iny
   2330  2716c				   -	       iny
   2331  2716c				   -	       iny
   2332  2716c				   -	       sta	(dlpnt),y
   2333  2716c				   -dlendthiszonedone
   2334  2716c					       endif	FRAMESKIPGLITCHFIXWEAK
   2335  2716c				   -	       ifconst	FRAMESKIPGLITCHFIX
   2336  2716c				   -	       iny
   2337  2716c				   -	       iny
   2338  2716c				   -	       iny
   2339  2716c				   -	       iny
   2340  2716c				   -	       cpy	#DLLASTOBJ-1
   2341  2716c				   -	       bcc	dlendmoreloops
   2342  2716c					       endif		; FRAMESKIPGLITCHFIX
   2343  2716c			ca		       dex
   2344  2716d			10 e7		       bpl	dlendloop
   2345  2716f
   2346  2716f					       ifnconst	pauseroutineoff
   2347  2716f			20 e5 f0	       jsr	pauseroutine
   2348  27172					       endif		; pauseroutineoff
   2349  27172			60		       rts
   2350  27173
   2351  27173				    uninterruptableroutines
   2352  27173							; this is for routines that must happen off the visible screen, each frame.
   2353  27173
   2354  27173				   -	       ifconst	AVOXVOICE
   2355  27173				   -	       jsr	serviceatarivoxqueue
   2356  27173					       endif
   2357  27173
   2358  27173			a9 00		       lda	#0
   2359  27175			8d b8 01	       sta	palfastframe
   2360  27178			ad 09 21	       lda	paldetected
   2361  2717b			f0 10		       beq	skippalframeadjusting
   2362  2717d							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   2363  2717d			ae b7 01	       ldx	palframes
   2364  27180			e8		       inx
   2365  27181			e0 05		       cpx	#5
   2366  27183			d0 05		       bne	palframeskipdone
   2367  27185			ee b8 01	       inc	palfastframe
   2368  27188			a2 00		       ldx	#0
   2369  2718a				    palframeskipdone
   2370  2718a			8e b7 01	       stx	palframes
   2371  2718d				    skippalframeadjusting
   2372  2718d
   2373  2718d				   -	       ifconst	MUSICTRACKER
   2374  2718d				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2375  2718d				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2376  2718d				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   2377  2718d				   -			; problem twice, and if we do, we just drop a musical note or two.
   2378  2718d				   -	       lda	sfxschedulemissed
   2379  2718d				   -	       beq	servicesongwasnotmissed
   2380  2718d				   -	       jsr	servicesong
   2381  2718d				   -servicesongwasnotmissed
   2382  2718d					       endif		; MUSICTRACKER
   2383  2718d
   2384  2718d				   -	       ifconst	RMT
   2385  2718d				   -	       lda	palfastframe
   2386  2718d				   -	       beq	skiprasterupdate2
   2387  2718d				   -	       lda	rasterpause
   2388  2718d				   -	       beq	skiprasterupdate2
   2389  2718d				   -	       jsr	RASTERMUSICTRACKER+3
   2390  2718d				   -skiprasterupdate2
   2391  2718d					       endif
   2392  2718d
   2393  2718d
   2394  2718d			60		       rts
   2395  2718e
   2396  2718e				    serviceatarivoxqueue
   2397  2718e				   -	       ifconst	AVOXVOICE
   2398  2718e				   -	       lda	voxlock
   2399  2718e				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2400  2718e				   -skipvoxqueuesizedec
   2401  2718e				   -	       jmp	processavoxvoice
   2402  2718e				   -skipvoxprocessing
   2403  2718e				   -	       rts
   2404  2718e				   -
   2405  2718e				   -processavoxvoice
   2406  2718e				   -	       ifconst	HSSUPPORT
   2407  2718e				   -			; ** we skip speech if hi-score is on and no vox was detected
   2408  2718e				   -			; ** this is to avoid later collision with snes pads.
   2409  2718e				   -	       lda	hsdevice
   2410  2718e				   -	       and	#2
   2411  2718e				   -	       beq	processavoxvoicereturn
   2412  2718e				   -	       endif		; HSSUPPORT
   2413  2718e				   -	       lda	avoxenable
   2414  2718e				   -	       bne	avoxfixport
   2415  2718e				   -	       SPKOUT	tempavox
   2416  2718e				   -	       rts
   2417  2718e				   -avoxfixport
   2418  2718e				   -	       lda	#0	; restore the port to all bits as inputs...
   2419  2718e				   -	       sta	CTLSWA
   2420  2718e				   -	       rts
   2421  2718e				   -silenceavoxvoice
   2422  2718e				   -	       SPEAK	avoxsilentdata
   2423  2718e				   -processavoxvoicereturn
   2424  2718e				   -	       rts
   2425  2718e				   -avoxsilentdata
   2426  2718e				   -	       .byte	31,255
   2427  2718e					       else
   2428  2718e			60		       rts
   2429  2718f					       endif		; AVOXVOICE
   2430  2718f
   2431  2718f				    joybuttonhandler
   2432  2718f			8a		       txa
   2433  27190			0a		       asl
   2434  27191			a8		       tay
   2435  27192			b9 08 00	       lda	INPT0,y
   2436  27195			4a		       lsr
   2437  27196			9d 02 21	       sta	sINPT1,x
   2438  27199			b9 09 00	       lda	INPT1,y
   2439  2719c			29 80		       and	#%10000000
   2440  2719e			1d 02 21	       ora	sINPT1,x
   2441  271a1			9d 02 21	       sta	sINPT1,x
   2442  271a4
   2443  271a4			b5 0c		       lda	INPT4,x
   2444  271a6			30 19		       bmi	.skip1bjoyfirecheck
   2445  271a8							;one button joystick is down
   2446  271a8			49 80		       eor	#%10000000
   2447  271aa			9d 02 21	       sta	sINPT1,x
   2448  271ad
   2449  271ad			ad b1 01	       lda	joybuttonmode
   2450  271b0			3d c4 f1	       and	twobuttonmask,x
   2451  271b3			f0 0c		       beq	.skip1bjoyfirecheck
   2452  271b5			ad b1 01	       lda	joybuttonmode
   2453  271b8			1d c4 f1	       ora	twobuttonmask,x
   2454  271bb			8d b1 01	       sta	joybuttonmode
   2455  271be			8d 82 02	       sta	SWCHB
   2456  271c1				    .skip1bjoyfirecheck
   2457  271c1			4c 57 f0	       jmp	buttonreadloopreturn
   2458  271c4
   2459  271c4				    twobuttonmask
   2460  271c4			04 10		       .byte.b	%00000100,%00010000
   2461  271c6
   2462  271c6				   -	       ifconst	SNES2ATARISUPPORT
   2463  271c6				   -
   2464  271c6				   -SNES_CLOCK_PORT_BIT
   2465  271c6				   -	       .byte	$10,$01
   2466  271c6				   -SNES_CTLSWA_MASK
   2467  271c6				   -	       .byte	$30,$03
   2468  271c6				   -SNES_CTLSWA_SIGNAL
   2469  271c6				   -	       .byte	$C0,$0C
   2470  271c6				   -SWCHA_DIRMASK
   2471  271c6				   -	       .byte	$F0,$0F
   2472  271c6				   -SWCHA_INVDIRMASK
   2473  271c6				   -	       .byte	$0F,$F0
   2474  271c6				   -
   2475  271c6				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
   2476  271c6				   -SNES_AUTODETECT
   2477  271c6				   -	       ifconst	HSSUPPORT
   2478  271c6				   -			; ** an atarivox might be plugged in, so we skip scanning the second
   2479  271c6				   -			; ** port for a snes if vox was detected...
   2480  271c6				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
   2481  271c6				   -	       lsr
   2482  271c6				   -	       and	#1
   2483  271c6				   -	       eor	#1
   2484  271c6				   -	       tax
   2485  271c6				   -	       else
   2486  271c6				   -	       ldx	#1
   2487  271c6				   -	       endif		; HSSUPPORT
   2488  271c6				   -
   2489  271c6				   -SNES_AUTODETECT_LOOP
   2490  271c6				   -	       lda	#1	; proline
   2491  271c6				   -	       sta	port0control,x
   2492  271c6				   -	       jsr	setportforinput
   2493  271c6				   -	       jsr	setonebuttonmode
   2494  271c6				   -	       jsr	SNES_READ
   2495  271c6				   -	       lda	snesdetected0,x
   2496  271c6				   -	       bne	SNES_AUTODETECT_FOUND
   2497  271c6				   -			; detection failed
   2498  271c6				   -	       jsr	setportforinput
   2499  271c6				   -	       jsr	settwobuttonmode
   2500  271c6				   -	       dex
   2501  271c6				   -	       bpl	SNES_AUTODETECT_LOOP
   2502  271c6				   -	       rts
   2503  271c6				   -SNES_AUTODETECT_FOUND
   2504  271c6				   -	       lda	#11	; formally set the snes controller
   2505  271c6				   -	       sta	port0control,x
   2506  271c6				   -	       stx	snesport
   2507  271c6				   -	       rts
   2508  271c6					       endif		; SNES2ATARISUPPORT
   2509  271c6
   2510  271c6				    snes2atarihandler
   2511  271c6				   -	       ifconst	SNES2ATARISUPPORT
   2512  271c6				   -SNES2ATARI
   2513  271c6				   -	       jsr	SNES_READ
   2514  271c6				   -	       jmp	buttonreadloopreturn
   2515  271c6				   -
   2516  271c6				   -SNES_READ
   2517  271c6				   -			; x=0 for left port, x=1 for right
   2518  271c6				   -
   2519  271c6				   -			; Start by checking if any port directions are pressed. 
   2520  271c6				   -			; Abort the autodetect for this port if so, as snes2atari doesn't ground any 
   2521  271c6				   -			; direction pins. if directions are pressed and the port is changed to output,
   2522  271c6				   -			; that means the output is direct-shorted, and nobody seems to know if riot's
   2523  271c6				   -			; output mode has current protection.
   2524  271c6				   -
   2525  271c6				   -	       lda	SWCHA
   2526  271c6				   -	       ora	SWCHA_INVDIRMASK,x
   2527  271c6				   -	       eor	SWCHA_DIRMASK,x
   2528  271c6				   -	       bne	SNES_READ_cont1
   2529  271c6				   -	       jmp	SNES_ABORT
   2530  271c6				   -SNES_READ_cont1
   2531  271c6				   -
   2532  271c6				   -	       lda	port0control,x
   2533  271c6				   -	       cmp	#11	; snes
   2534  271c6				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
   2535  271c6				   -	       lda	snesdetected0,x
   2536  271c6				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
   2537  271c6				   -snes2atari_signal_go
   2538  271c6				   -	       jsr	SNES2ATARI_SIGNAL
   2539  271c6				   -snes2atari_signal_skip
   2540  271c6				   -
   2541  271c6				   -			;lda SNES_CTLSWA_MASK,x
   2542  271c6				   -
   2543  271c6				   -	       lda	CTLSWA
   2544  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2545  271c6				   -	       ora	SNES_CTLSWA_MASK,x
   2546  271c6				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
   2547  271c6				   -
   2548  271c6				   -	       lda	SWCHA
   2549  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2550  271c6				   -	       ora	SNES_CTLSWA_MASK,x
   2551  271c6				   -
   2552  271c6				   -	       sta	SWCHA	; latch+clock high
   2553  271c6				   -	       nop
   2554  271c6				   -	       nop
   2555  271c6				   -	       nop
   2556  271c6				   -	       nop
   2557  271c6				   -	       nop
   2558  271c6				   -	       nop
   2559  271c6				   -	       nop
   2560  271c6				   -	       lda	SWCHA
   2561  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2562  271c6				   -	       sta	SWCHA	; latch and clock low
   2563  271c6				   -	       ldy	#16	; 16 bits 
   2564  271c6				   -SNES2ATARILOOP
   2565  271c6				   -	       rol	INPT4,x	; sample data into carry
   2566  271c6				   -	       lda	SWCHA
   2567  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2568  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2569  271c6				   -	       sta	SWCHA	; clock low
   2570  271c6				   -	       rol	snes2atari0lo,x
   2571  271c6				   -	       rol	snes2atari0hi,x
   2572  271c6				   -	       lda	SWCHA
   2573  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2574  271c6				   -	       sta	SWCHA	; latch and clock low
   2575  271c6				   -	       dey		; next bit
   2576  271c6				   -	       bne	SNES2ATARILOOP
   2577  271c6				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
   2578  271c6				   -	       rol		; 17th snes bit into A low bit
   2579  271c6				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
   2580  271c6				   -	       and	#1
   2581  271c6				   -	       sta	snesdetected0,x
   2582  271c6				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
   2583  271c6				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
   2584  271c6				   -	       lda	SWCHA
   2585  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2586  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2587  271c6				   -SNES_STOP_CLOCK
   2588  271c6				   -	       sta	SWCHA	; clock low
   2589  271c6				   -	       lda	CTLSWA
   2590  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2591  271c6				   -	       ora	SNES_CLOCK_PORT_BIT,x
   2592  271c6				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
   2593  271c6				   -	       rts
   2594  271c6				   -SNES_ABORT
   2595  271c6				   -	       sta	snesdetected0,x
   2596  271c6				   -	       rts
   2597  271c6				   -SNES2ATARI_SIGNAL
   2598  271c6				   -			; signal to SNES2ATARI++ that we want SNES mode...
   2599  271c6				   -	       lda	CTLSWA
   2600  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2601  271c6				   -	       ora	SNES_CTLSWA_SIGNAL,x
   2602  271c6				   -	       sta	CTLSWA
   2603  271c6				   -	       lda	CTLSWA
   2604  271c6				   -	       and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   2605  271c6				   -	       sta	SWCHA
   2606  271c6				   -	       ldy	#0
   2607  271c6				   -SNES_SIGNAL_LOOP
   2608  271c6				   -	       dey
   2609  271c6				   -	       bne	SNES_SIGNAL_LOOP
   2610  271c6				   -	       lda	SWCHA
   2611  271c6				   -	       ora	SWCHA_DIRMASK,x
   2612  271c6				   -	       sta	SWCHA
   2613  271c6				   -	       rts
   2614  271c6					       endif
   2615  271c6
   2616  271c6				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2617  271c6				   -	       ifconst	LIGHTGUNSUPPORT
   2618  271c6				   -	       cpx	#0
   2619  271c6				   -	       bne	secondportgunhandler
   2620  271c6				   -firstportgunhandler
   2621  271c6				   -	       lda	SWCHA
   2622  271c6				   -	       asl
   2623  271c6				   -	       asl
   2624  271c6				   -	       asl		; shift D4 to D7
   2625  271c6				   -	       and	#%10000000
   2626  271c6				   -	       eor	#%10000000
   2627  271c6				   -	       sta	sINPT1
   2628  271c6				   -	       jmp	buttonreadloopreturn
   2629  271c6				   -secondportgunhandler
   2630  271c6				   -	       lda	SWCHA
   2631  271c6				   -	       lsr		; shift D0 into carry
   2632  271c6				   -	       lsr		; shift carry into D7
   2633  271c6				   -	       and	#%10000000
   2634  271c6				   -	       eor	#%10000000
   2635  271c6				   -	       sta	sINPT3
   2636  271c6				   -	       jmp	buttonreadloopreturn
   2637  271c6					       endif		; LIGHTGUNSUPPORT
   2638  271c6
   2639  271c6				    controlsusing2buttoncode
   2640  271c6			00		       .byte.b	0	; 00=no controller plugged in
   2641  271c7			01		       .byte.b	1	; 01=proline joystick
   2642  271c8			00		       .byte.b	0	; 02=lightgun
   2643  271c9			00		       .byte.b	0	; 03=paddle
   2644  271ca			01		       .byte.b	1	; 04=trakball
   2645  271cb			01		       .byte.b	1	; 05=vcs joystick
   2646  271cc			01		       .byte.b	1	; 06=driving control
   2647  271cd			00		       .byte.b	0	; 07=keypad control
   2648  271ce			00		       .byte.b	0	; 08=st mouse/cx80
   2649  271cf			00		       .byte.b	0	; 09=amiga mouse
   2650  271d0			01		       .byte.b	1	; 10=atarivox
   2651  271d1			00		       .byte.b	0	; 11=snes2atari
   2652  271d2
   2653  271d2				    buttonhandlerhi
   2654  271d2			00		       .byte.b	0	; 00=no controller plugged in
   2655  271d3			f1		       .byte.b	>joybuttonhandler	; 01=proline joystick
   2656  271d4			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   2657  271d5			f6		       .byte.b	>paddlebuttonhandler	; 03=paddle
   2658  271d6			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   2659  271d7			f1		       .byte.b	>joybuttonhandler	; 05=vcs joystick
   2660  271d8			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   2661  271d9			00		       .byte.b	0	; 07=keypad
   2662  271da			f6		       .byte.b	>mousebuttonhandler	; 08=st mouse
   2663  271db			f6		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2664  271dc			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   2665  271dd			f1		       .byte.b	>snes2atarihandler	; 11=snes
   2666  271de				    buttonhandlerlo
   2667  271de			00		       .byte.b	0	; 00=no controller plugged in
   2668  271df			8f		       .byte.b	<joybuttonhandler	; 01=proline joystick
   2669  271e0			c6		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   2670  271e1			1a		       .byte.b	<paddlebuttonhandler	; 03=paddle
   2671  271e2			8f		       .byte.b	<joybuttonhandler	; 04=trakball
   2672  271e3			8f		       .byte.b	<joybuttonhandler	; 05=vcs joystick
   2673  271e4			8f		       .byte.b	<joybuttonhandler	; 06=driving control
   2674  271e5			00		       .byte.b	0	; 07=keypad
   2675  271e6			1a		       .byte.b	<mousebuttonhandler	; 08=st mouse
   2676  271e7			1a		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2677  271e8			8f		       .byte.b	<joybuttonhandler	; 10=atarivox
   2678  271e9			c6		       .byte.b	<snes2atarihandler	; 11=snes
   2679  271ea
   2680  271ea				    drawwait
   2681  271ea			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2682  271ec			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   2683  271ee			60		       rts
   2684  271ef
   2685  271ef				    drawoverwait
   2686  271ef			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   2687  271f1			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   2688  271f3			60		       rts
   2689  271f4
   2690  271f4
   2691  271f4				    mutetia
   2692  271f4			a9 00		       lda	#0
   2693  271f6			a2 03		       ldx	#3
   2694  271f8				    mutetialoop
   2695  271f8			95 4e		       sta	sfx1pointlo,x
   2696  271fa			95 17		       sta	AUDF0,x
   2697  271fc			ca		       dex
   2698  271fd			10 f9		       bpl	mutetialoop
   2699  271ff			60		       rts
   2700  27200
   2701  27200				    servicesfxchannelsdone
   2702  27200					       ifnconst	pokeysupport
   2703  27200			60		       rts
   2704  27201				   -	       else
   2705  27201				   -	       jmp	checkpokeyplaying
   2706  27201					       endif
   2707  27201				    servicesfxchannels
   2708  27201			a2 ff		       ldx	#255
   2709  27203				    servicesfxchannelsloop
   2710  27203			e8		       inx
   2711  27204					       ifnconst	TIASFXMONO
   2712  27204			e0 02		       cpx	#2
   2713  27206				   -	       else
   2714  27206				   -	       cpx	#1
   2715  27206					       endif
   2716  27206			f0 f8		       beq	servicesfxchannelsdone
   2717  27208
   2718  27208			a5 de		       lda	sfxschedulelock	; =1 if locked
   2719  2720a			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   2720  2720c
   2721  2720c			b5 4e		       lda	sfx1pointlo,x
   2722  2720e			85 dc		       sta	inttemp5
   2723  27210			15 50		       ora	sfx1pointhi,x
   2724  27212			f0 ef		       beq	servicesfxchannelsloop
   2725  27214			b5 50		       lda	sfx1pointhi,x
   2726  27216			85 dd		       sta	inttemp6
   2727  27218
   2728  27218			b5 58		       lda	sfx1tick,x
   2729  2721a			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   2730  2721c			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2731  2721e			4c 03 f2	       jmp	servicesfxchannelsloop
   2732  27221				    servicesfx_cont1
   2733  27221
   2734  27221			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   2735  27223			b1 dc		       lda	(inttemp5),y
   2736  27225			c9 10		       cmp	#$10
   2737  27227			d0 1b		       bne	servicesfx_cont1a
   2738  27229			a0 02		       ldy	#2
   2739  2722b			b1 dc		       lda	(inttemp5),y
   2740  2722d			95 56		       sta	sfx1frames,x	; change the frame countdown
   2741  2722f			a9 00		       lda	#0
   2742  27231			95 58		       sta	sfx1tick,x
   2743  27233							; advance the sound pointer by 3...
   2744  27233			b5 4e		       lda	sfx1pointlo,x
   2745  27235			18		       clc
   2746  27236			69 03		       adc	#3
   2747  27238			95 4e		       sta	sfx1pointlo,x
   2748  2723a			b5 50		       lda	sfx1pointhi,x
   2749  2723c			69 00		       adc	#0
   2750  2723e			95 50		       sta	sfx1pointhi,x
   2751  27240							; and then fetch another sample for this channel...
   2752  27240			ca		       dex
   2753  27241			4c 03 f2	       jmp	servicesfxchannelsloop
   2754  27244				    servicesfx_cont1a
   2755  27244
   2756  27244			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2757  27246			95 58		       sta	sfx1tick,x
   2758  27248
   2759  27248			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2760  2724a			f0 02		       beq	servicesfx_cont2
   2761  2724c			d6 52		       dec	sfx1priority,x
   2762  2724e				    servicesfx_cont2
   2763  2724e
   2764  2724e			a0 00		       ldy	#0	; play the sound
   2765  27250			b1 dc		       lda	(inttemp5),y
   2766  27252			85 d8		       sta	inttemp1
   2767  27254
   2768  27254				   -	       ifconst	MUSICTRACKER
   2769  27254				   -	       lda	sfx1notedata,x
   2770  27254				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   2771  27254				   -	       ldy	#0
   2772  27254				   -	       sty	inttemp2
   2773  27254				   -	       clc
   2774  27254				   -	       adc	(inttemp5),y
   2775  27254				   -	       asl		; x2
   2776  27254				   -	       tay
   2777  27254				   -	       lda	tiatrackeroctavenotes,y
   2778  27254				   -	       sta	AUDC0,x
   2779  27254				   -	       iny
   2780  27254				   -	       lda	tiatrackeroctavenotes,y
   2781  27254				   -	       sta	AUDF0,x
   2782  27254				   -	       ldy	#1
   2783  27254				   -	       jmp	sfxvolumeentrypt
   2784  27254				   -exitmusictracker
   2785  27254				   -	       lda	inttemp1
   2786  27254					       endif		; MUSICTRACKER
   2787  27254
   2788  27254			18		       clc
   2789  27255			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   2790  27257			95 17		       sta	AUDF0,x
   2791  27259			c8		       iny
   2792  2725a			b1 dc		       lda	(inttemp5),y
   2793  2725c			95 15		       sta	AUDC0,x
   2794  2725e			85 d9		       sta	inttemp2
   2795  27260			c8		       iny
   2796  27261				    sfxvolumeentrypt
   2797  27261				   -	       ifconst	TIAVOLUME
   2798  27261				   -	       lda	tiavolume
   2799  27261				   -	       asl
   2800  27261				   -	       asl
   2801  27261				   -	       asl
   2802  27261				   -	       asl
   2803  27261				   -	       sta	fourbitfadevalueint
   2804  27261					       endif		; TIAVOLUME
   2805  27261			b1 dc		       lda	(inttemp5),y
   2806  27263				   -	       ifconst	TIAVOLUME
   2807  27263				   -	       jsr	fourbitfadeint
   2808  27263					       endif		; TIAVOLUME
   2809  27263			95 19		       sta	AUDV0,x
   2810  27265			c9 10		       cmp	#$10
   2811  27267			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2812  27269
   2813  27269			05 d9		       ora	inttemp2
   2814  2726b			05 d8		       ora	inttemp1	; check if F|C|V=0
   2815  2726d			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   2816  2726f
   2817  2726f				    advancesfxpointer
   2818  2726f							; advance the pointer to the next sound chunk
   2819  2726f			c8		       iny
   2820  27270			84 da		       sty	inttemp3
   2821  27272			18		       clc
   2822  27273			b5 4e		       lda	sfx1pointlo,x
   2823  27275			65 da		       adc	inttemp3
   2824  27277			95 4e		       sta	sfx1pointlo,x
   2825  27279			b5 50		       lda	sfx1pointhi,x
   2826  2727b			69 00		       adc	#0
   2827  2727d			95 50		       sta	sfx1pointhi,x
   2828  2727f			4c 03 f2	       jmp	servicesfxchannelsloop
   2829  27282
   2830  27282				    sfxsoundloop
   2831  27282			48		       pha
   2832  27283			b5 52		       lda	sfx1priority,x
   2833  27285			d0 04		       bne	sfxsoundloop_carryon
   2834  27287			68		       pla		; fix the stack before we go
   2835  27288			4c 6f f2	       jmp	advancesfxpointer
   2836  2728b				    sfxsoundloop_carryon
   2837  2728b			68		       pla
   2838  2728c			29 f0		       and	#$F0
   2839  2728e			4a		       lsr
   2840  2728f			4a		       lsr
   2841  27290			4a		       lsr
   2842  27291			4a		       lsr
   2843  27292
   2844  27292				    zerosfx
   2845  27292			95 4e		       sta	sfx1pointlo,x
   2846  27294			95 50		       sta	sfx1pointhi,x
   2847  27296			95 52		       sta	sfx1priority,x
   2848  27298			4c 03 f2	       jmp	servicesfxchannelsloop
   2849  2729b
   2850  2729b
   2851  2729b				    schedulesfx
   2852  2729b							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2853  2729b			a0 00		       ldy	#0
   2854  2729d			b1 e0		       lda	(sfxinstrumentlo),y
   2855  2729f				   -	       ifconst	pokeysupport
   2856  2729f				   -	       cmp	#$20	; POKEY?
   2857  2729f				   -	       bne	scheduletiasfx
   2858  2729f				   -	       jmp	schedulepokeysfx
   2859  2729f					       endif
   2860  2729f				    scheduletiasfx
   2861  2729f							;cmp #$10 ; TIA?
   2862  2729f							;beq continuescheduletiasfx
   2863  2729f							; rts ; unhandled!!! 
   2864  2729f				    continuescheduletiasfx
   2865  2729f					       ifnconst	TIASFXMONO
   2866  2729f			a5 4e		       lda	sfx1pointlo
   2867  272a1			05 50		       ora	sfx1pointhi
   2868  272a3			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   2869  272a5			a5 4f		       lda	sfx2pointlo
   2870  272a7			05 51		       ora	sfx2pointhi
   2871  272a9			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   2872  272ab							; Both channels are scheduled. 
   2873  272ab			a0 01		       ldy	#1
   2874  272ad			b1 e0		       lda	(sfxinstrumentlo),y
   2875  272af			d0 01		       bne	interruptsfx
   2876  272b1			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2877  272b2				    interruptsfx
   2878  272b2							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2879  272b2			a5 52		       lda	sfx1priority
   2880  272b4			c5 53		       cmp	sfx2priority
   2881  272b6			b0 04		       bcs	schedulesfx2
   2882  272b8					       endif		; !TIASFXMONO
   2883  272b8
   2884  272b8				    schedulesfx1
   2885  272b8			a2 00		       ldx	#0	; channel 1
   2886  272ba					       ifnconst	TIASFXMONO
   2887  272ba			f0 02		       beq	skipschedulesfx2
   2888  272bc				    schedulesfx2
   2889  272bc			a2 01		       ldx	#1	; channel 2
   2890  272be				    skipschedulesfx2
   2891  272be					       endif		; !TIASFXMONO
   2892  272be
   2893  272be				   -	       ifconst	MUSICTRACKER
   2894  272be				   -	       lda	sfxnoteindex
   2895  272be				   -	       bpl	skipdrumkitoverride
   2896  272be				   -	       and	#$7F	; subtract 128
   2897  272be				   -	       sec
   2898  272be				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   2899  272be				   -	       asl
   2900  272be				   -	       tay
   2901  272be				   -	       lda	tiadrumkitdefinition,y
   2902  272be				   -	       sta	sfxinstrumentlo
   2903  272be				   -	       iny
   2904  272be				   -	       lda	tiadrumkitdefinition,y
   2905  272be				   -	       sta	sfxinstrumenthi
   2906  272be				   -	       lda	#0
   2907  272be				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2908  272be				   -skipdrumkitoverride
   2909  272be					       endif		; MUSICTRACKER
   2910  272be			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   2911  272c0			b1 e0		       lda	(sfxinstrumentlo),y
   2912  272c2			95 52		       sta	sfx1priority,x
   2913  272c4			c8		       iny
   2914  272c5			b1 e0		       lda	(sfxinstrumentlo),y
   2915  272c7			95 56		       sta	sfx1frames,x
   2916  272c9			a5 e0		       lda	sfxinstrumentlo
   2917  272cb			18		       clc
   2918  272cc			69 03		       adc	#3
   2919  272ce			95 4e		       sta	sfx1pointlo,x
   2920  272d0			a5 e1		       lda	sfxinstrumenthi
   2921  272d2			69 00		       adc	#0
   2922  272d4			95 50		       sta	sfx1pointhi,x
   2923  272d6			a5 e2		       lda	sfxpitchoffset
   2924  272d8			95 54		       sta	sfx1poffset,x
   2925  272da			a9 00		       lda	#0
   2926  272dc			95 58		       sta	sfx1tick,x
   2927  272de			a5 e3		       lda	sfxnoteindex
   2928  272e0			95 cd		       sta	sfx1notedata,x
   2929  272e2			60		       rts
   2930  272e3
   2931  272e3				    plotsprite
   2932  272e3					       ifnconst	NODRAWWAIT
   2933  272e3					       ifconst	DOUBLEBUFFER
   2934  272e3			a5 d5		       lda	doublebufferstate
   2935  272e5			d0 04		       bne	skipplotspritewait
   2936  272e7					       endif		; DOUBLEBUFFER
   2937  272e7				   -	       ifconst	DEBUGWAITCOLOR
   2938  272e7				   -	       lda	#$41
   2939  272e7				   -	       sta	BACKGRND
   2940  272e7					       endif
   2941  272e7				    plotspritewait
   2942  272e7			a5 4d		       lda	visibleover
   2943  272e9			d0 fc		       bne	plotspritewait
   2944  272eb				    skipplotspritewait
   2945  272eb				   -	       ifconst	DEBUGWAITCOLOR
   2946  272eb				   -	       lda	#$0
   2947  272eb				   -	       sta	BACKGRND
   2948  272eb					       endif
   2949  272eb					       endif
   2950  272eb
   2951  272eb							;arguments: 
   2952  272eb							; temp1=lo graphicdata 
   2953  272eb							; temp2=hi graphicdata 
   2954  272eb							; temp3=palette | width byte
   2955  272eb							; temp4=x
   2956  272eb							; temp5=y
   2957  272eb							; temp6=mode
   2958  272eb			a5 46		       lda	temp5	;Y position
   2959  272ed			4a		       lsr		; 2 - Divide by 8 or 16
   2960  272ee			4a		       lsr		; 2
   2961  272ef			4a		       lsr		; 2
   2962  272f0					       if	WZONEHEIGHT = 16
   2963  272f0			4a		       lsr		; 2
   2964  272f1					       endif
   2965  272f1
   2966  272f1			aa		       tax
   2967  272f2
   2968  272f2					       ifnconst	NOLIMITCHECKING
   2969  272f2
   2970  272f2							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   2971  272f2
   2972  272f2			c9 0c		       cmp	#WZONECOUNT
   2973  272f4
   2974  272f4			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   2975  272f6							; otherwise, check to see if the bottom half is in zone 0...
   2976  272f6
   2977  272f6					       if	WZONEHEIGHT = 16
   2978  272f6			c9 0f		       cmp	#15
   2979  272f8				   -	       else
   2980  272f8				   -	       cmp	#31
   2981  272f8					       endif
   2982  272f8
   2983  272f8			d0 05		       bne	exitplotsprite1
   2984  272fa			a2 00		       ldx	#0
   2985  272fc			4c 3a f3	       jmp	continueplotsprite2
   2986  272ff				    exitplotsprite1
   2987  272ff			60		       rts
   2988  27300
   2989  27300				    continueplotsprite1
   2990  27300					       endif
   2991  27300
   2992  27300			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2993  27303					       ifconst	DOUBLEBUFFER
   2994  27303			18		       clc
   2995  27304			65 d6		       adc	doublebufferdloffset
   2996  27306					       endif		; DOUBLEBUFFER
   2997  27306			85 63		       sta	dlpnt
   2998  27308			bd d6 f6	       lda	DLPOINTH,x
   2999  2730b					       ifconst	DOUBLEBUFFER
   3000  2730b			69 00		       adc	#0
   3001  2730d					       endif		; DOUBLEBUFFER
   3002  2730d			85 64		       sta	dlpnt+1
   3003  2730f
   3004  2730f							;Create DL entry for upper part of sprite
   3005  2730f
   3006  2730f			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3007  27311
   3008  27311				   -	       ifconst	CHECKOVERWRITE
   3009  27311				   -	       cpy	#DLLASTOBJ
   3010  27311				   -	       beq	checkcontinueplotsprite2
   3011  27311				   -continueplotsprite1a
   3012  27311					       endif
   3013  27311
   3014  27311			a5 42		       lda	temp1	; graphic data, lo byte
   3015  27313			91 63		       sta	(dlpnt),y	;Low byte of data address
   3016  27315
   3017  27315					       ifnconst	ATOMICSPRITEUPDATE
   3018  27315			c8		       iny
   3019  27316			a5 47		       lda	temp6
   3020  27318			91 63		       sta	(dlpnt),y
   3021  2731a				   -	       else
   3022  2731a				   -	       iny
   3023  2731a				   -	       sty	temp8
   3024  2731a					       endif
   3025  2731a
   3026  2731a			c8		       iny
   3027  2731b
   3028  2731b			a5 46		       lda	temp5	;Y position
   3029  2731d			29 0f		       and	#(WZONEHEIGHT - 1)
   3030  2731f			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   3031  27321			05 43		       ora	temp2	; graphic data, hi byte
   3032  27323			91 63		       sta	(dlpnt),y
   3033  27325
   3034  27325
   3035  27325			c8		       iny
   3036  27326			a5 44		       lda	temp3	;palette|width
   3037  27328			91 63		       sta	(dlpnt),y
   3038  2732a
   3039  2732a			c8		       iny
   3040  2732b			a5 45		       lda	temp4	;Horizontal position
   3041  2732d			91 63		       sta	(dlpnt),y
   3042  2732f
   3043  2732f			c8		       iny
   3044  27330			94 65		       sty	dlend,x
   3045  27332
   3046  27332				   -	       ifconst	ALWAYSTERMINATE
   3047  27332				   -	       iny
   3048  27332				   -	       lda	#0
   3049  27332				   -	       sta	(dlpnt),y
   3050  27332					       endif
   3051  27332
   3052  27332				   -	       ifconst	ATOMICSPRITEUPDATE
   3053  27332				   -	       ldy	temp8
   3054  27332				   -	       lda	temp6
   3055  27332				   -	       sta	(dlpnt),y
   3056  27332					       endif
   3057  27332
   3058  27332				    checkcontinueplotsprite2
   3059  27332
   3060  27332			90 38		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   3061  27334
   3062  27334							;Create DL entry for lower part of sprite
   3063  27334
   3064  27334			e8		       inx		;Next region
   3065  27335
   3066  27335					       ifnconst	NOLIMITCHECKING
   3067  27335			e0 0c		       cpx	#WZONECOUNT
   3068  27337
   3069  27337			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3070  27339			60		       rts
   3071  2733a				    continueplotsprite2
   3072  2733a					       endif
   3073  2733a
   3074  2733a			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to next DL
   3075  2733d					       ifconst	DOUBLEBUFFER
   3076  2733d			18		       clc
   3077  2733e			65 d6		       adc	doublebufferdloffset
   3078  27340					       endif		; DOUBLEBUFFER
   3079  27340			85 63		       sta	dlpnt
   3080  27342			bd d6 f6	       lda	DLPOINTH,x
   3081  27345					       ifconst	DOUBLEBUFFER
   3082  27345			69 00		       adc	#0
   3083  27347					       endif		; DOUBLEBUFFER
   3084  27347			85 64		       sta	dlpnt+1
   3085  27349			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3086  2734b
   3087  2734b				   -	       ifconst	CHECKOVERWRITE
   3088  2734b				   -	       cpy	#DLLASTOBJ
   3089  2734b				   -	       bne	continueplotsprite2a
   3090  2734b				   -	       rts
   3091  2734b				   -continueplotsprite2a
   3092  2734b					       endif
   3093  2734b
   3094  2734b			a5 42		       lda	temp1	; graphic data, lo byte
   3095  2734d			91 63		       sta	(dlpnt),y
   3096  2734f
   3097  2734f					       ifnconst	ATOMICSPRITEUPDATE
   3098  2734f			c8		       iny
   3099  27350			a5 47		       lda	temp6
   3100  27352			91 63		       sta	(dlpnt),y
   3101  27354				   -	       else
   3102  27354				   -	       iny
   3103  27354				   -	       sty	temp8
   3104  27354					       endif
   3105  27354
   3106  27354			c8		       iny
   3107  27355
   3108  27355			a5 46		       lda	temp5	;Y position
   3109  27357			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   3110  27359			05 43		       ora	temp2	; graphic data, hi byte
   3111  2735b			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   3112  2735d			91 63		       sta	(dlpnt),y
   3113  2735f
   3114  2735f			c8		       iny
   3115  27360
   3116  27360			a5 44		       lda	temp3	;palette|width
   3117  27362			91 63		       sta	(dlpnt),y
   3118  27364
   3119  27364			c8		       iny
   3120  27365
   3121  27365			a5 45		       lda	temp4	;Horizontal position
   3122  27367			91 63		       sta	(dlpnt),y
   3123  27369
   3124  27369			c8		       iny
   3125  2736a			94 65		       sty	dlend,x
   3126  2736c
   3127  2736c				   -	       ifconst	ALWAYSTERMINATE
   3128  2736c				   -	       iny
   3129  2736c				   -	       lda	#0
   3130  2736c				   -	       sta	(dlpnt),y
   3131  2736c					       endif
   3132  2736c
   3133  2736c				   -	       ifconst	ATOMICSPRITEUPDATE
   3134  2736c				   -	       ldy	temp8
   3135  2736c				   -	       lda	temp6
   3136  2736c				   -	       sta	(dlpnt),y
   3137  2736c					       endif
   3138  2736c
   3139  2736c				    doneSPDL
   3140  2736c			60		       rts
   3141  2736d
   3142  2736d
   3143  2736d				    lockzonex
   3144  2736d				   -	       ifconst	ZONELOCKS
   3145  2736d				   -	       ldy	dlend,x
   3146  2736d				   -	       cpy	#DLLASTOBJ
   3147  2736d				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3148  2736d				   -	       lda	DLPOINTL,x
   3149  2736d				   -	       ifconst	DOUBLEBUFFER
   3150  2736d				   -	       clc
   3151  2736d				   -	       adc	doublebufferdloffset
   3152  2736d				   -	       endif		; DOUBLEBUFFER
   3153  2736d				   -	       sta	dlpnt
   3154  2736d				   -	       lda	DLPOINTH,x
   3155  2736d				   -	       ifconst	DOUBLEBUFFER
   3156  2736d				   -	       adc	#0
   3157  2736d				   -	       endif		; DOUBLEBUFFER
   3158  2736d				   -	       sta	dlpnt+1
   3159  2736d				   -	       iny
   3160  2736d				   -	       lda	#0
   3161  2736d				   -	       sta	(dlpnt),y
   3162  2736d				   -	       dey
   3163  2736d				   -	       tya
   3164  2736d				   -	       ldy	#(DLLASTOBJ-1)
   3165  2736d				   -	       sta	(dlpnt),y
   3166  2736d				   -	       iny
   3167  2736d				   -	       sty	dlend,x
   3168  2736d				   -lockzonexreturn
   3169  2736d				   -	       rts
   3170  2736d					       endif		; ZONELOCKS
   3171  2736d				    unlockzonex
   3172  2736d				   -	       ifconst	ZONELOCKS
   3173  2736d				   -	       ldy	dlend,x
   3174  2736d				   -	       cpy	#DLLASTOBJ
   3175  2736d				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3176  2736d				   -	       lda	DLPOINTL,x
   3177  2736d				   -	       ifconst	DOUBLEBUFFER
   3178  2736d				   -	       clc
   3179  2736d				   -	       adc	doublebufferdloffset
   3180  2736d				   -	       endif		; DOUBLEBUFFER
   3181  2736d				   -	       sta	dlpnt
   3182  2736d				   -	       lda	DLPOINTH,x
   3183  2736d				   -	       ifconst	DOUBLEBUFFER
   3184  2736d				   -	       adc	#0
   3185  2736d				   -	       endif		; DOUBLEBUFFER
   3186  2736d				   -	       sta	dlpnt+1
   3187  2736d				   -	       dey
   3188  2736d				   -			;ldy #(DLLASTOBJ-1)
   3189  2736d				   -	       lda	(dlpnt),y
   3190  2736d				   -	       tay
   3191  2736d				   -	       sty	dlend,x
   3192  2736d				   -unlockzonexreturn
   3193  2736d					       endif		; ZONELOCKS
   3194  2736d			60		       rts
   3195  2736e
   3196  2736e				    plotcharloop
   3197  2736e							; ** read from a data indirectly pointed to from temp8,temp9
   3198  2736e							; ** format is: lo_data, hi_data, palette|width, x, y
   3199  2736e							; ** format ends with lo_data | hi_data = 0
   3200  2736e
   3201  2736e					       ifconst	DOUBLEBUFFER
   3202  2736e			a5 d5		       lda	doublebufferstate
   3203  27370			d0 04		       bne	skipplotcharloopwait
   3204  27372					       endif		; DOUBLEBUFFER
   3205  27372				   -	       ifconst	DEBUGWAITCOLOR
   3206  27372				   -	       lda	#$61
   3207  27372				   -	       sta	BACKGRND
   3208  27372					       endif
   3209  27372				    plotcharloopwait
   3210  27372			a5 4d		       lda	visibleover
   3211  27374			d0 fc		       bne	plotcharloopwait
   3212  27376				   -	       ifconst	DEBUGWAITCOLOR
   3213  27376				   -	       lda	#0
   3214  27376				   -	       sta	BACKGRND
   3215  27376					       endif
   3216  27376				    skipplotcharloopwait
   3217  27376				    plotcharlooploop
   3218  27376			a0 00		       ldy	#0
   3219  27378			b1 49		       lda	(temp8),y
   3220  2737a			85 42		       sta	temp1
   3221  2737c			c8		       iny
   3222  2737d			b1 49		       lda	(temp8),y
   3223  2737f			85 43		       sta	temp2
   3224  27381			05 42		       ora	temp1
   3225  27383			d0 01		       bne	plotcharloopcontinue
   3226  27385							;the pointer=0, so return
   3227  27385			60		       rts
   3228  27386				    plotcharloopcontinue
   3229  27386			c8		       iny
   3230  27387			b1 49		       lda	(temp8),y
   3231  27389			85 44		       sta	temp3
   3232  2738b			c8		       iny
   3233  2738c			b1 49		       lda	(temp8),y
   3234  2738e			85 45		       sta	temp4
   3235  27390			c8		       iny
   3236  27391			b1 49		       lda	(temp8),y
   3237  27393							;sta temp5 ; not needed with our late entry.
   3238  27393			20 b0 f3	       jsr	plotcharactersskipentry
   3239  27396			a5 49		       lda	temp8
   3240  27398			18		       clc
   3241  27399			69 05		       adc	#5
   3242  2739b			85 49		       sta	temp8
   3243  2739d			a5 4a		       lda	temp9
   3244  2739f			69 00		       adc	#0
   3245  273a1			85 4a		       sta	temp9
   3246  273a3			4c 76 f3	       jmp	plotcharlooploop
   3247  273a6
   3248  273a6				    plotcharacters
   3249  273a6					       ifconst	DOUBLEBUFFER
   3250  273a6			a5 d5		       lda	doublebufferstate
   3251  273a8			d0 04		       bne	skipplotcharacterswait
   3252  273aa					       endif		; DOUBLEBUFFER
   3253  273aa				   -	       ifconst	DEBUGWAITCOLOR
   3254  273aa				   -	       lda	#$41
   3255  273aa				   -	       sta	BACKGRND
   3256  273aa					       endif
   3257  273aa				    plotcharacterswait
   3258  273aa			a5 4d		       lda	visibleover
   3259  273ac			d0 fc		       bne	plotcharacterswait
   3260  273ae				   -	       ifconst	DEBUGWAITCOLOR
   3261  273ae				   -	       sta	BACKGRND
   3262  273ae					       endif
   3263  273ae				    skipplotcharacterswait
   3264  273ae							;arguments: 
   3265  273ae							; temp1=lo charactermap
   3266  273ae							; temp2=hi charactermap
   3267  273ae							; temp3=palette | width byte
   3268  273ae							; temp4=x
   3269  273ae							; temp5=y
   3270  273ae
   3271  273ae			a5 46		       lda	temp5	;Y position
   3272  273b0
   3273  273b0				    plotcharactersskipentry
   3274  273b0
   3275  273b0							;ifconst ZONEHEIGHT
   3276  273b0							; if ZONEHEIGHT = 16
   3277  273b0							; and #$0F
   3278  273b0							; endif
   3279  273b0							; if ZONEHEIGHT = 8
   3280  273b0							; and #$1F
   3281  273b0							; endif
   3282  273b0							;else
   3283  273b0							; and #$0F
   3284  273b0							;endif
   3285  273b0
   3286  273b0			aa		       tax
   3287  273b1			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3288  273b4					       ifconst	DOUBLEBUFFER
   3289  273b4			18		       clc
   3290  273b5			65 d6		       adc	doublebufferdloffset
   3291  273b7					       endif		; DOUBLEBUFFER
   3292  273b7			85 63		       sta	dlpnt
   3293  273b9			bd d6 f6	       lda	DLPOINTH,x
   3294  273bc					       ifconst	DOUBLEBUFFER
   3295  273bc			69 00		       adc	#0
   3296  273be					       endif		; DOUBLEBUFFER
   3297  273be			85 64		       sta	dlpnt+1
   3298  273c0
   3299  273c0							;Create DL entry for the characters
   3300  273c0
   3301  273c0			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3302  273c2
   3303  273c2				   -	       ifconst	CHECKOVERWRITE
   3304  273c2				   -	       cpy	#DLLASTOBJ
   3305  273c2				   -	       bne	continueplotcharacters
   3306  273c2				   -	       rts
   3307  273c2				   -continueplotcharacters
   3308  273c2					       endif
   3309  273c2
   3310  273c2			a5 42		       lda	temp1	; character map data, lo byte
   3311  273c4			91 63		       sta	(dlpnt),y	;(1) store low address
   3312  273c6
   3313  273c6			c8		       iny
   3314  273c7			ad 06 21	       lda	charactermode
   3315  273ca			91 63		       sta	(dlpnt),y	;(2) store mode
   3316  273cc
   3317  273cc			c8		       iny
   3318  273cd			a5 43		       lda	temp2	; character map, hi byte
   3319  273cf			91 63		       sta	(dlpnt),y	;(3) store high address
   3320  273d1
   3321  273d1			c8		       iny
   3322  273d2			a5 44		       lda	temp3	;palette|width
   3323  273d4			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3324  273d6
   3325  273d6			c8		       iny
   3326  273d7			a5 45		       lda	temp4	;Horizontal position
   3327  273d9			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3328  273db
   3329  273db			c8		       iny
   3330  273dc			94 65		       sty	dlend,x	; save display list end byte
   3331  273de			60		       rts
   3332  273df
   3333  273df
   3334  273df					       ifconst	plotvalueonscreen
   3335  273df				    plotcharacterslive
   3336  273df							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3337  273df
   3338  273df							;arguments: 
   3339  273df							; temp1=lo charactermap
   3340  273df							; temp2=hi charactermap
   3341  273df							; temp3=palette | width byte
   3342  273df							; temp4=x
   3343  273df							; temp5=y
   3344  273df
   3345  273df			a5 46		       lda	temp5	;Y position
   3346  273e1
   3347  273e1			aa		       tax
   3348  273e2			bd e2 f6	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3349  273e5					       ifconst	DOUBLEBUFFER
   3350  273e5			18		       clc
   3351  273e6			65 d6		       adc	doublebufferdloffset
   3352  273e8					       endif		; DOUBLEBUFFER
   3353  273e8			85 63		       sta	dlpnt
   3354  273ea			bd d6 f6	       lda	DLPOINTH,x
   3355  273ed					       ifconst	DOUBLEBUFFER
   3356  273ed			69 00		       adc	#0
   3357  273ef					       endif		; DOUBLEBUFFER
   3358  273ef			85 64		       sta	dlpnt+1
   3359  273f1
   3360  273f1							;Create DL entry for the characters
   3361  273f1
   3362  273f1			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3363  273f3
   3364  273f3				   -	       ifconst	CHECKOVERWRITE
   3365  273f3				   -	       cpy	#DLLASTOBJ
   3366  273f3				   -	       bne	continueplotcharacterslive
   3367  273f3				   -	       rts
   3368  273f3				   -continueplotcharacterslive
   3369  273f3					       endif
   3370  273f3
   3371  273f3			a5 42		       lda	temp1	; character map data, lo byte
   3372  273f5			91 63		       sta	(dlpnt),y	;(1) store low address
   3373  273f7
   3374  273f7			c8		       iny
   3375  273f8							; we don't add the second byte yet, since the charmap could briefly
   3376  273f8							; render without a proper character map address, width, or position.
   3377  273f8			ad 06 21	       lda	charactermode
   3378  273fb			91 63		       sta	(dlpnt),y	;(2) store mode
   3379  273fd
   3380  273fd			c8		       iny
   3381  273fe			a5 43		       lda	temp2	; character map, hi byte
   3382  27400			91 63		       sta	(dlpnt),y	;(3) store high address
   3383  27402
   3384  27402			c8		       iny
   3385  27403			a5 44		       lda	temp3	;palette|width
   3386  27405			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3387  27407
   3388  27407			c8		       iny
   3389  27408			a5 45		       lda	temp4	;Horizontal position
   3390  2740a			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3391  2740c
   3392  2740c			c8		       iny
   3393  2740d			94 65		       sty	dlend,x	; save display list end byte
   3394  2740f
   3395  2740f			60		       rts
   3396  27410					       endif		;plotcharacterslive
   3397  27410
   3398  27410				   -	       ifconst	USED_PLOTVALUE
   3399  27410				   -plotvalue
   3400  27410				   -			; calling 7800basic command:
   3401  27410				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3402  27410				   -			; ...displays the variable as BCD digits
   3403  27410				   -			;
   3404  27410				   -			; asm sub arguments: 
   3405  27410				   -			; temp1=lo charactermap
   3406  27410				   -			; temp2=hi charactermap
   3407  27410				   -			; temp3=palette | width byte
   3408  27410				   -			; temp4=x
   3409  27410				   -			; temp5=y
   3410  27410				   -			; temp6=number of digits
   3411  27410				   -			; temp7=lo variable
   3412  27410				   -			; temp8=hi variable
   3413  27410				   -			; temp9=character mode
   3414  27410				   -
   3415  27410				   -plotdigitcount =	temp6
   3416  27410				   -
   3417  27410				   -	       ifconst	ZONELOCKS
   3418  27410				   -	       ldx	temp5
   3419  27410				   -	       ldy	dlend,x
   3420  27410				   -	       cpy	#DLLASTOBJ
   3421  27410				   -	       bne	carryonplotvalue
   3422  27410				   -	       rts
   3423  27410				   -carryonplotvalue
   3424  27410				   -	       endif
   3425  27410				   -
   3426  27410				   -	       lda	#0
   3427  27410				   -	       tay
   3428  27410				   -	       ldx	valbufend
   3429  27410				   -
   3430  27410				   -	       lda	plotdigitcount
   3431  27410				   -	       and	#1
   3432  27410				   -	       beq	pvnibble2char
   3433  27410				   -	       lda	#0
   3434  27410				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   3435  27410				   -	       beq	pvnibble2char_skipnibble
   3436  27410				   -
   3437  27410				   -pvnibble2char
   3438  27410				   -			; high nibble...
   3439  27410				   -	       lda	(temp7),y
   3440  27410				   -	       and	#$f0
   3441  27410				   -	       lsr
   3442  27410				   -	       lsr
   3443  27410				   -	       lsr
   3444  27410				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3445  27410				   -	       lsr
   3446  27410				   -	       endif
   3447  27410				   -
   3448  27410				   -	       clc
   3449  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3450  27410				   -	       sta	VALBUFFER,x
   3451  27410				   -	       inx
   3452  27410				   -	       dec	plotdigitcount
   3453  27410				   -
   3454  27410				   -pvnibble2char_skipnibble
   3455  27410				   -			; low nibble...
   3456  27410				   -	       lda	(temp7),y
   3457  27410				   -	       and	#$0f
   3458  27410				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3459  27410				   -	       asl
   3460  27410				   -	       endif
   3461  27410				   -	       clc
   3462  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3463  27410				   -	       sta	VALBUFFER,x
   3464  27410				   -	       inx
   3465  27410				   -	       iny
   3466  27410				   -
   3467  27410				   -	       dec	plotdigitcount
   3468  27410				   -	       bne	pvnibble2char
   3469  27410				   -
   3470  27410				   -			;point to the start of our valuebuffer
   3471  27410				   -	       clc
   3472  27410				   -	       lda	#<VALBUFFER
   3473  27410				   -	       adc	valbufend
   3474  27410				   -	       sta	temp1
   3475  27410				   -	       lda	#>VALBUFFER
   3476  27410				   -	       adc	#0
   3477  27410				   -	       sta	temp2
   3478  27410				   -
   3479  27410				   -			;advance valbufend to the end of our value buffer
   3480  27410				   -	       stx	valbufend
   3481  27410				   -
   3482  27410				   -	       ifnconst	plotvalueonscreen
   3483  27410				   -	       jmp	plotcharacters
   3484  27410				   -	       else
   3485  27410				   -	       jmp	plotcharacterslive
   3486  27410				   -	       endif
   3487  27410				   -
   3488  27410					       endif		; USED_PLOTVALUE
   3489  27410
   3490  27410
   3491  27410				   -	       ifconst	USED_PLOTVALUEEXTRA
   3492  27410				   -plotdigitcount =	temp6
   3493  27410				   -plotvalueextra
   3494  27410				   -			; calling 7800basic command:
   3495  27410				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3496  27410				   -			; ...displays the variable as BCD digits
   3497  27410				   -			;
   3498  27410				   -			; asm sub arguments: 
   3499  27410				   -			; temp1=lo charactermap
   3500  27410				   -			; temp2=hi charactermap
   3501  27410				   -			; temp3=palette | width byte
   3502  27410				   -			; temp4=x
   3503  27410				   -			; temp5=y
   3504  27410				   -			; temp6=number of digits
   3505  27410				   -			; temp7=lo variable
   3506  27410				   -			; temp8=hi variable
   3507  27410				   -
   3508  27410				   -	       lda	#0
   3509  27410				   -	       tay
   3510  27410				   -	       ldx	valbufend
   3511  27410				   -	       ifnconst	plotvalueonscreen
   3512  27410				   -	       sta	VALBUFFER,x
   3513  27410				   -	       endif
   3514  27410				   -
   3515  27410				   -	       lda	plotdigitcount
   3516  27410				   -	       and	#1
   3517  27410				   -
   3518  27410				   -	       bne	pvnibble2char_skipnibbleextra
   3519  27410				   -
   3520  27410				   -pvnibble2charextra
   3521  27410				   -			; high nibble...
   3522  27410				   -	       lda	(temp7),y
   3523  27410				   -	       and	#$f0
   3524  27410				   -	       lsr
   3525  27410				   -	       lsr
   3526  27410				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3527  27410				   -	       lsr
   3528  27410				   -	       endif
   3529  27410				   -	       clc
   3530  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3531  27410				   -	       sta	VALBUFFER,x
   3532  27410				   -	       inx
   3533  27410				   -
   3534  27410				   -			; second half of the digit
   3535  27410				   -	       clc
   3536  27410				   -	       adc	#1
   3537  27410				   -	       sta	VALBUFFER,x
   3538  27410				   -	       inx
   3539  27410				   -
   3540  27410				   -pvnibble2char_skipnibbleextra
   3541  27410				   -			; low nibble...
   3542  27410				   -	       lda	(temp7),y
   3543  27410				   -	       and	#$0f
   3544  27410				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3545  27410				   -	       asl
   3546  27410				   -	       endif
   3547  27410				   -	       asl
   3548  27410				   -
   3549  27410				   -	       clc
   3550  27410				   -	       adc	temp1	; add the offset to character graphics to our value
   3551  27410				   -	       sta	VALBUFFER,x
   3552  27410				   -	       inx
   3553  27410				   -
   3554  27410				   -	       clc
   3555  27410				   -	       adc	#1
   3556  27410				   -	       sta	VALBUFFER,x
   3557  27410				   -	       inx
   3558  27410				   -	       iny
   3559  27410				   -
   3560  27410				   -	       dec	plotdigitcount
   3561  27410				   -	       bne	pvnibble2charextra
   3562  27410				   -
   3563  27410				   -			;point to the start of our valuebuffer
   3564  27410				   -	       clc
   3565  27410				   -	       lda	#<VALBUFFER
   3566  27410				   -	       adc	valbufend
   3567  27410				   -	       sta	temp1
   3568  27410				   -	       lda	#>VALBUFFER
   3569  27410				   -	       adc	#0
   3570  27410				   -	       sta	temp2
   3571  27410				   -
   3572  27410				   -			;advance valbufend to the end of our value buffer
   3573  27410				   -	       stx	valbufend
   3574  27410				   -
   3575  27410				   -	       ifnconst	plotvalueonscreen
   3576  27410				   -	       jmp	plotcharacters
   3577  27410				   -	       else
   3578  27410				   -	       jmp	plotcharacterslive
   3579  27410				   -	       endif
   3580  27410					       endif		; USED_PLOTVALUEEXTRA
   3581  27410
   3582  27410				    boxcollision
   3583  27410				   -	       ifconst	BOXCOLLISION
   3584  27410				   -			; the worst case cycle-time for the code below is 43 cycles.
   3585  27410				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3586  27410				   -
   3587  27410				   -			;__boxx1 = accumulator
   3588  27410				   -			;__boxy1 = y
   3589  27410				   -__boxw1    =	temp3
   3590  27410				   -__boxh1    =	temp4
   3591  27410				   -
   3592  27410				   -__boxx2    =	temp5
   3593  27410				   -__boxy2    =	temp6
   3594  27410				   -__boxw2    =	temp7
   3595  27410				   -__boxh2    =	temp8
   3596  27410				   -
   3597  27410				   -DoXCollisionCheck
   3598  27410				   -			;lda __boxx1 ; skipped. already in the accumulator
   3599  27410				   -	       cmp	__boxx2	;3
   3600  27410				   -	       bcs	X1isbiggerthanX2	;2/3
   3601  27410				   -X2isbiggerthanX1
   3602  27410				   -			; carry is clear
   3603  27410				   -	       adc	__boxw1	;3
   3604  27410				   -	       cmp	__boxx2	;3
   3605  27410				   -	       bcs	DoYCollisionCheck	;3/2
   3606  27410				   -	       rts		;6 - carry clear, no collision
   3607  27410				   -X1isbiggerthanX2
   3608  27410				   -	       clc		;2
   3609  27410				   -	       sbc	__boxw2	;3
   3610  27410				   -	       cmp	__boxx2	;3
   3611  27410				   -	       bcs	noboxcollision	;3/2
   3612  27410				   -DoYCollisionCheck
   3613  27410				   -	       tya		; 2 ; use to be "lda __boxy1"
   3614  27410				   -	       cmp	__boxy2	;3
   3615  27410				   -	       bcs	Y1isbiggerthanY2	;3/2
   3616  27410				   -Y2isbiggerthanY1
   3617  27410				   -			; carry is clear
   3618  27410				   -	       adc	__boxh1	;3
   3619  27410				   -	       cmp	__boxy2	;3
   3620  27410				   -	       rts		;6 
   3621  27410				   -Y1isbiggerthanY2
   3622  27410				   -	       clc		;2
   3623  27410				   -	       sbc	__boxh2	;3
   3624  27410				   -	       cmp	__boxy2	;3
   3625  27410				   -	       bcs	noboxcollision	;3/2
   3626  27410				   -yesboxcollision
   3627  27410				   -	       sec		;2
   3628  27410				   -	       rts		;6
   3629  27410				   -noboxcollision
   3630  27410				   -	       clc		;2
   3631  27410				   -	       rts		;6
   3632  27410					       endif		; BOXCOLLISION
   3633  27410
   3634  27410				    randomize
   3635  27410			a5 40		       lda	rand
   3636  27412			4a		       lsr
   3637  27413			26 41		       rol	rand16
   3638  27415			90 02		       bcc	noeor
   3639  27417			49 b4		       eor	#$B4
   3640  27419				    noeor
   3641  27419			85 40		       sta	rand
   3642  2741b			45 41		       eor	rand16
   3643  2741d			60		       rts
   3644  2741e
   3645  2741e							; *** bcd conversion routine courtesy Omegamatrix
   3646  2741e							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3647  2741e				    converttobcd
   3648  2741e							;value to convert is in the accumulator
   3649  2741e			85 42		       sta	temp1
   3650  27420			4a		       lsr
   3651  27421			65 42		       adc	temp1
   3652  27423			6a		       ror
   3653  27424			4a		       lsr
   3654  27425			4a		       lsr
   3655  27426			65 42		       adc	temp1
   3656  27428			6a		       ror
   3657  27429			65 42		       adc	temp1
   3658  2742b			6a		       ror
   3659  2742c			4a		       lsr
   3660  2742d			29 3c		       and	#$3C
   3661  2742f			85 43		       sta	temp2
   3662  27431			4a		       lsr
   3663  27432			65 43		       adc	temp2
   3664  27434			65 42		       adc	temp1
   3665  27436			60		       rts		; return the result in the accumulator
   3666  27437
   3667  27437							; Y and A contain multiplicands, result in A
   3668  27437				    mul8
   3669  27437			84 42		       sty	temp1
   3670  27439			85 43		       sta	temp2
   3671  2743b			a9 00		       lda	#0
   3672  2743d				    reptmul8
   3673  2743d			46 43		       lsr	temp2
   3674  2743f			90 03		       bcc	skipmul8
   3675  27441			18		       clc
   3676  27442			65 42		       adc	temp1
   3677  27444							;bcs donemul8 might save cycles?
   3678  27444				    skipmul8
   3679  27444							;beq donemul8 might save cycles?
   3680  27444			06 42		       asl	temp1
   3681  27446			d0 f5		       bne	reptmul8
   3682  27448				    donemul8
   3683  27448			60		       rts
   3684  27449
   3685  27449				    div8
   3686  27449							; A=numerator Y=denominator, result in A
   3687  27449			c0 02		       cpy	#2
   3688  2744b			90 0a		       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3689  2744d			84 42		       sty	temp1
   3690  2744f			a0 ff		       ldy	#$ff
   3691  27451				    div8loop
   3692  27451			e5 42		       sbc	temp1
   3693  27453			c8		       iny
   3694  27454			b0 fb		       bcs	div8loop
   3695  27456				    div8end
   3696  27456			98		       tya
   3697  27457							; result in A
   3698  27457			60		       rts
   3699  27458
   3700  27458							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3701  27458				    mul16
   3702  27458			84 42		       sty	temp1
   3703  2745a			85 43		       sta	temp2
   3704  2745c
   3705  2745c			a9 00		       lda	#0
   3706  2745e			a2 08		       ldx	#8
   3707  27460			46 42		       lsr	temp1
   3708  27462				    mul16_1
   3709  27462			90 03		       bcc	mul16_2
   3710  27464			18		       clc
   3711  27465			65 43		       adc	temp2
   3712  27467				    mul16_2
   3713  27467			6a		       ror
   3714  27468			66 42		       ror	temp1
   3715  2746a			ca		       dex
   3716  2746b			d0 f5		       bne	mul16_1
   3717  2746d			85 43		       sta	temp2
   3718  2746f			60		       rts
   3719  27470
   3720  27470							; div int/int
   3721  27470							; numerator in A, denom in temp1
   3722  27470							; returns with quotient in A, remainder in temp1
   3723  27470				    div16
   3724  27470			85 43		       sta	temp2
   3725  27472			84 42		       sty	temp1
   3726  27474			a9 00		       lda	#0
   3727  27476			a2 08		       ldx	#8
   3728  27478			06 43		       asl	temp2
   3729  2747a				    div16_1
   3730  2747a			2a		       rol
   3731  2747b			c5 42		       cmp	temp1
   3732  2747d			90 02		       bcc	div16_2
   3733  2747f			e5 42		       sbc	temp1
   3734  27481				    div16_2
   3735  27481			26 43		       rol	temp2
   3736  27483			ca		       dex
   3737  27484			d0 f4		       bne	div16_1
   3738  27486			85 42		       sta	temp1
   3739  27488			a5 43		       lda	temp2
   3740  2748a			60		       rts
   3741  2748b
   3742  2748b					       ifconst	bankswitchmode
   3743  2748b				    BS_jsr
   3744  2748b				   -	       ifconst	dumpbankswitch
   3745  2748b				   -	       sta	dumpbankswitch
   3746  2748b					       endif
   3747  2748b				   -	       ifconst	MCPDEVCART
   3748  2748b				   -	       ora	#$18
   3749  2748b				   -	       sta	$3000
   3750  2748b					       else
   3751  2748b			8d 00 80	       sta	$8000
   3752  2748e					       endif
   3753  2748e			68		       pla
   3754  2748f			aa		       tax
   3755  27490			68		       pla
   3756  27491			60		       rts
   3757  27492
   3758  27492				    BS_return
   3759  27492			68		       pla		; bankswitch bank
   3760  27493				   -	       ifconst	dumpbankswitch
   3761  27493				   -	       sta	dumpbankswitch
   3762  27493					       endif
   3763  27493				   -	       ifconst	BANKRAM
   3764  27493				   -	       sta	currentbank
   3765  27493				   -	       ora	currentrambank
   3766  27493					       endif
   3767  27493				   -	       ifconst	MCPDEVCART
   3768  27493				   -	       ora	#$18
   3769  27493				   -	       sta	$3000
   3770  27493					       else
   3771  27493			8d 00 80	       sta	$8000
   3772  27496					       endif
   3773  27496			68		       pla		; bankswitch $0 flag
   3774  27497			60		       rts
   3775  27498					       endif
   3776  27498
   3777  27498				    checkselectswitch
   3778  27498			ad 82 02	       lda	SWCHB	; first check the real select switch...
   3779  2749b			29 02		       and	#%00000010
   3780  2749d					       ifnconst	SOFTPAUSEOFF
   3781  2749d					       ifnconst	MOUSESUPPORT
   3782  2749d					       ifnconst	TRAKBALLSUPPORT
   3783  2749d			f0 0f		       beq	checkselectswitchreturn	; switch is pressed
   3784  2749f			ad b9 01	       lda	port0control
   3785  274a2			c9 0b		       cmp	#11
   3786  274a4			d0 03		       bne	checkselectsoftswitch
   3787  274a6			a9 ff		       lda	#$ff
   3788  274a8			60		       rts
   3789  274a9				    checkselectsoftswitch
   3790  274a9			ad 80 02	       lda	SWCHA	; then check the soft "select" joysick code...
   3791  274ac			29 b0		       and	#%10110000	; R_DU
   3792  274ae					       endif		; TRAKBALLSUPPORT
   3793  274ae					       endif		; MOUSESUPPORT
   3794  274ae					       endif		; SOFTPAUSEOFF
   3795  274ae				    checkselectswitchreturn
   3796  274ae			60		       rts
   3797  274af
   3798  274af				    checkresetswitch
   3799  274af			ad 82 02	       lda	SWCHB	; first check the real reset switch...
   3800  274b2			29 01		       and	#%00000001
   3801  274b4					       ifnconst	SOFTPAUSEOFF
   3802  274b4					       ifnconst	MOUSESUPPORT
   3803  274b4					       ifnconst	TRAKBALLSUPPORT
   3804  274b4			f0 0f		       beq	checkresetswitchreturn	; switch is pressed
   3805  274b6			ad b9 01	       lda	port0control
   3806  274b9			c9 0b		       cmp	#11
   3807  274bb			d0 03		       bne	checkresetsoftswitch
   3808  274bd			a9 ff		       lda	#$ff
   3809  274bf			60		       rts
   3810  274c0				    checkresetsoftswitch
   3811  274c0			ad 80 02	       lda	SWCHA	; then check the soft "reset" joysick code...
   3812  274c3			29 70		       and	#%01110000	; _LDU
   3813  274c5					       endif		; TRAKBALLSUPPORT
   3814  274c5					       endif		; MOUSESUPPORT
   3815  274c5					       endif		; SOFTPAUSEOFF
   3816  274c5				    checkresetswitchreturn
   3817  274c5			60		       rts
   3818  274c6
   3819  274c6				   -	       ifconst	FINESCROLLENABLED
   3820  274c6				   -finescrolldlls
   3821  274c6				   -	       ldx	temp1	; first DLL index x3
   3822  274c6				   -	       lda	DLLMEM,x
   3823  274c6				   -	       and	#%11110000
   3824  274c6				   -	       ora	finescrolly
   3825  274c6				   -	       sta	DLLMEM,x
   3826  274c6				   -
   3827  274c6				   -	       ldx	temp2	; last DLL index x3
   3828  274c6				   -	       lda	DLLMEM,x
   3829  274c6				   -	       and	#%11110000
   3830  274c6				   -	       ora	finescrolly
   3831  274c6				   -	       eor	#(WZONEHEIGHT-1)
   3832  274c6				   -	       sta	DLLMEM,x
   3833  274c6				   -	       rts
   3834  274c6					       endif		; FINESCROLLENABLED
   3835  274c6
   3836  274c6				   -	       ifconst	USED_ADJUSTVISIBLE
   3837  274c6				   -adjustvisible
   3838  274c6				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3839  274c6				   -	       jsr	waitforvblankstart	; ensure vblank just started
   3840  274c6				   -	       ldx	visibleDLLstart
   3841  274c6				   -findfirstinterrupt
   3842  274c6				   -	       lda	DLLMEM,x
   3843  274c6				   -	       bmi	foundfirstinterrupt
   3844  274c6				   -	       inx
   3845  274c6				   -	       inx
   3846  274c6				   -	       inx
   3847  274c6				   -	       bne	findfirstinterrupt
   3848  274c6				   -foundfirstinterrupt
   3849  274c6				   -	       and	#%01111111	; clear the interrupt bit
   3850  274c6				   -	       sta	DLLMEM,x
   3851  274c6				   -	       ifconst	DOUBLEBUFFER
   3852  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3853  274c6				   -	       endif		; DOUBLEBUFFER
   3854  274c6				   -	       ldx	overscanDLLstart
   3855  274c6				   -findlastinterrupt
   3856  274c6				   -	       lda	DLLMEM,x
   3857  274c6				   -	       bmi	foundlastinterrupt
   3858  274c6				   -	       dex
   3859  274c6				   -	       dex
   3860  274c6				   -	       dex
   3861  274c6				   -	       bne	findlastinterrupt
   3862  274c6				   -foundlastinterrupt
   3863  274c6				   -	       and	#%01111111	; clear the interrupt bit
   3864  274c6				   -	       sta	DLLMEM,x
   3865  274c6				   -	       ifconst	DOUBLEBUFFER
   3866  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3867  274c6				   -	       endif		; DOUBLEBUFFER
   3868  274c6				   -			;now we need to set the new interrupts
   3869  274c6				   -	       clc
   3870  274c6				   -	       lda	temp1
   3871  274c6				   -	       adc	visibleDLLstart
   3872  274c6				   -	       tax
   3873  274c6				   -	       lda	DLLMEM,x
   3874  274c6				   -	       ora	#%10000000
   3875  274c6				   -	       sta	DLLMEM,x
   3876  274c6				   -	       ifconst	DOUBLEBUFFER
   3877  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3878  274c6				   -	       endif		; DOUBLEBUFFER
   3879  274c6				   -	       clc
   3880  274c6				   -	       lda	temp2
   3881  274c6				   -	       adc	visibleDLLstart
   3882  274c6				   -	       tax
   3883  274c6				   -	       lda	DLLMEM,x
   3884  274c6				   -	       ora	#%10000000
   3885  274c6				   -	       sta	DLLMEM,x
   3886  274c6				   -	       ifconst	DOUBLEBUFFER
   3887  274c6				   -	       sta	DLLMEM+DBOFFSET,x
   3888  274c6				   -	       endif		; DOUBLEBUFFER
   3889  274c6				   -	       jsr	vblankresync
   3890  274c6				   -	       rts
   3891  274c6					       endif		; USED_ADJUSTVISIBLE
   3892  274c6
   3893  274c6				    vblankresync
   3894  274c6			20 87 f5	       jsr	waitforvblankstart	; ensure vblank just started
   3895  274c9			a9 00		       lda	#0
   3896  274cb			85 4d		       sta	visibleover
   3897  274cd			a9 03		       lda	#3
   3898  274cf			8d b2 01	       sta	interruptindex
   3899  274d2			60		       rts
   3900  274d3
   3901  274d3				    createallgamedlls
   3902  274d3			a2 00		       ldx	#0
   3903  274d5			a9 19		       lda	#NVLINES
   3904  274d7			ac 09 21	       ldy	paldetected
   3905  274da			f0 03		       beq	skipcreatePALpadding
   3906  274dc			18		       clc
   3907  274dd			69 15		       adc	#21
   3908  274df				    skipcreatePALpadding
   3909  274df			20 1d f5	       jsr	createnonvisibledlls
   3910  274e2			8e 3c 21	       stx	visibleDLLstart
   3911  274e5			20 57 f5	       jsr	createvisiblezones
   3912  274e8			8e 3d 21	       stx	overscanDLLstart
   3913  274eb				    createallgamedllscontinue
   3914  274eb			a9 50		       lda	#(NVLINES+55)	; extras for PAL
   3915  274ed			20 1d f5	       jsr	createnonvisibledlls
   3916  274f0
   3917  274f0			ae 3c 21	       ldx	visibleDLLstart
   3918  274f3			bd 00 18	       lda	DLLMEM,x
   3919  274f6			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   3920  274f8			9d 00 18	       sta	DLLMEM,x
   3921  274fb					       ifconst	DOUBLEBUFFER
   3922  274fb			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3923  274fe					       endif		; DOUBLEBUFFER
   3924  274fe
   3925  274fe			ae 3d 21	       ldx	overscanDLLstart
   3926  27501			bd 00 18	       lda	DLLMEM,x
   3927  27504			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   3928  27506			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3929  27508			9d 00 18	       sta	DLLMEM,x
   3930  2750b					       ifconst	DOUBLEBUFFER
   3931  2750b			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3932  2750e					       endif		; DOUBLEBUFFER
   3933  2750e
   3934  2750e			e8		       inx
   3935  2750f			e8		       inx
   3936  27510			e8		       inx
   3937  27511
   3938  27511			bd 00 18	       lda	DLLMEM,x
   3939  27514			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   3940  27516			9d 00 18	       sta	DLLMEM,x
   3941  27519					       ifconst	DOUBLEBUFFER
   3942  27519			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3943  2751c					       endif		; DOUBLEBUFFER
   3944  2751c
   3945  2751c			60		       rts
   3946  2751d
   3947  2751d				    createnonvisibledlls
   3948  2751d			85 42		       sta	temp1
   3949  2751f			4a		       lsr
   3950  27520			4a		       lsr
   3951  27521			4a		       lsr
   3952  27522			4a		       lsr		; /16
   3953  27523			f0 09		       beq	skipcreatenonvisibledlls1loop
   3954  27525			a8		       tay
   3955  27526				    createnonvisibledlls1loop
   3956  27526			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3957  27528			20 3d f5	       jsr	createblankdllentry
   3958  2752b			88		       dey
   3959  2752c			d0 f8		       bne	createnonvisibledlls1loop
   3960  2752e				    skipcreatenonvisibledlls1loop
   3961  2752e			a5 42		       lda	temp1
   3962  27530			29 0f		       and	#%00001111
   3963  27532			f0 08		       beq	createnonvisibledllsreturn
   3964  27534			38		       sec
   3965  27535			e9 01		       sbc	#1
   3966  27537			09 40		       ora	#%01000000
   3967  27539			20 3d f5	       jsr	createblankdllentry
   3968  2753c				    createnonvisibledllsreturn
   3969  2753c			60		       rts
   3970  2753d
   3971  2753d				    createblankdllentry
   3972  2753d			9d 00 18	       sta	DLLMEM,x
   3973  27540					       ifconst	DOUBLEBUFFER
   3974  27540			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3975  27543					       endif		; DOUBLEBUFFER
   3976  27543			e8		       inx
   3977  27544			a9 21		       lda	#$21	; blank
   3978  27546			9d 00 18	       sta	DLLMEM,x
   3979  27549					       ifconst	DOUBLEBUFFER
   3980  27549			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3981  2754c					       endif		; DOUBLEBUFFER
   3982  2754c			e8		       inx
   3983  2754d			a9 00		       lda	#$00
   3984  2754f			9d 00 18	       sta	DLLMEM,x
   3985  27552					       ifconst	DOUBLEBUFFER
   3986  27552			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3987  27555					       endif		; DOUBLEBUFFER
   3988  27555			e8		       inx
   3989  27556			60		       rts
   3990  27557
   3991  27557				    createvisiblezones
   3992  27557			a0 00		       ldy	#0
   3993  27559				    createvisiblezonesloop
   3994  27559			b9 ee f6	       lda.w	DLHEIGHT,y
   3995  2755c			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   3996  2755e			9d 00 18	       sta	DLLMEM,x
   3997  27561					       ifconst	DOUBLEBUFFER
   3998  27561			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   3999  27564					       endif		; DOUBLEBUFFER
   4000  27564			e8		       inx
   4001  27565			b9 d6 f6	       lda	DLPOINTH,y
   4002  27568				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   4003  27568				   -			; with bankset cart ram, we added $8000 to the DL address so plot functions would hit the write-address
   4004  27568				   -			; but now we need to subtract that $8000 location to give Maria the normal address
   4005  27568				   -	       sec
   4006  27568				   -	       sbc	#$80
   4007  27568					       endif		; BANKSET_DL_IN_CARTRAM
   4008  27568			9d 00 18	       sta	DLLMEM,x
   4009  2756b					       ifconst	DOUBLEBUFFER
   4010  2756b			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   4011  2756e					       endif		; DOUBLEBUFFER
   4012  2756e			e8		       inx
   4013  2756f			b9 e2 f6	       lda	DLPOINTL,y
   4014  27572			9d 00 18	       sta	DLLMEM,x
   4015  27575					       ifconst	DOUBLEBUFFER
   4016  27575			18		       clc
   4017  27576			69 ff		       adc	#DOUBLEBUFFEROFFSET
   4018  27578			9d 70 18	       sta	DLLMEM+DBOFFSET,x
   4019  2757b			90 03		       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   4020  2757d			fe 6f 18	       inc	DLLMEM+DBOFFSET-1,x
   4021  27580				    skiphidoublebufferadjust
   4022  27580					       endif		; DOUBLEBUFFER
   4023  27580			e8		       inx
   4024  27581			c8		       iny
   4025  27582			c0 0c		       cpy	#WZONECOUNT
   4026  27584			d0 d3		       bne	createvisiblezonesloop
   4027  27586			60		       rts
   4028  27587
   4029  27587				    waitforvblankstart
   4030  27587				    vblankendwait
   4031  27587			24 28		       BIT	MSTAT
   4032  27589			30 fc		       bmi	vblankendwait
   4033  2758b				    vblankstartwait
   4034  2758b			24 28		       BIT	MSTAT
   4035  2758d			10 fc		       bpl	vblankstartwait
   4036  2758f			60		       rts
   4037  27590
   4038  27590					       ifconst	DOUBLEBUFFER
   4039  27590				    flipdisplaybufferreturn
   4040  27590			60		       rts
   4041  27591				    flipdisplaybuffer
   4042  27591				   -	       ifconst	interrupthold
   4043  27591				   -	       lda	#$FF
   4044  27591				   -	       sta	interrupthold
   4045  27591					       endif
   4046  27591			a5 d5		       lda	doublebufferstate
   4047  27593			f0 fb		       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4048  27595
   4049  27595			20 54 f1	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4050  27598
   4051  27598			a5 d5		       lda	doublebufferstate
   4052  2759a			4a		       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4053  2759b			aa		       tax
   4054  2759c
   4055  2759c							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4056  2759c
   4057  2759c				    flipdisplaybufferwait1
   4058  2759c			a5 4d		       lda	visibleover
   4059  2759e			f0 fc		       beq	flipdisplaybufferwait1
   4060  275a0
   4061  275a0				    flipdisplaybufferwait
   4062  275a0			a5 4d		       lda	visibleover
   4063  275a2			d0 fc		       bne	flipdisplaybufferwait
   4064  275a4
   4065  275a4			ad b3 01	       lda	doublebufferminimumframetarget
   4066  275a7			f0 0b		       beq	skipminimumframecode
   4067  275a9			ad b4 01	       lda	doublebufferminimumframeindex
   4068  275ac			d0 ee		       bne	flipdisplaybufferwait1
   4069  275ae			ad b3 01	       lda	doublebufferminimumframetarget
   4070  275b1			8d b4 01	       sta	doublebufferminimumframeindex
   4071  275b4				    skipminimumframecode
   4072  275b4
   4073  275b4			bd 14 f6	       lda	DLLMEMLutHi,x
   4074  275b7			85 2c		       sta	DPPH
   4075  275b9			bd 12 f6	       lda	DLLMEMLutLo,x
   4076  275bc			85 30		       sta	DPPL
   4077  275be
   4078  275be			bd 16 f6	       lda	NewPageflipstate,x
   4079  275c1			85 d5		       sta	doublebufferstate
   4080  275c3			bd 18 f6	       lda	NewPageflipoffset,x
   4081  275c6			85 d6		       sta	doublebufferdloffset
   4082  275c8
   4083  275c8					       ifnconst	BANKSET_DL_IN_CARTRAM
   4084  275c8			a5 d7		       lda	doublebufferbufferdirty
   4085  275ca			f0 c4		       beq	flipdisplaybufferreturn
   4086  275cc
   4087  275cc							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4088  275cc							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4089  275cc							; from the displayed buffer to the working buffer...
   4090  275cc
   4091  275cc			a5 d6		       lda	doublebufferdloffset
   4092  275ce			49 ff		       eor	#DOUBLEBUFFEROFFSET
   4093  275d0			85 47		       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4094  275d2
   4095  275d2			a2 0b		       ldx	#(WZONECOUNT-1)
   4096  275d4				    copybufferzoneloop
   4097  275d4
   4098  275d4			bd e2 f6	       lda	DLPOINTL,x
   4099  275d7			18		       clc
   4100  275d8			65 d6		       adc	doublebufferdloffset
   4101  275da			85 42		       sta	temp1
   4102  275dc			bd d6 f6	       lda	DLPOINTH,x
   4103  275df			69 00		       adc	#0
   4104  275e1			85 43		       sta	temp2
   4105  275e3
   4106  275e3			bd e2 f6	       lda	DLPOINTL,x
   4107  275e6			18		       clc
   4108  275e7			65 47		       adc	temp6
   4109  275e9			85 44		       sta	temp3
   4110  275eb			bd d6 f6	       lda	DLPOINTH,x
   4111  275ee			69 00		       adc	#0
   4112  275f0			85 45		       sta	temp4
   4113  275f2
   4114  275f2			b5 82		       lda	dlendsave,x
   4115  275f4			a8		       tay
   4116  275f5				    copybuffercharsloop
   4117  275f5			b1 44		       lda	(temp3),y
   4118  275f7			91 42		       sta	(temp1),y
   4119  275f9			88		       dey
   4120  275fa			10 f9		       bpl	copybuffercharsloop
   4121  275fc			ca		       dex
   4122  275fd			10 d5		       bpl	copybufferzoneloop
   4123  275ff			a9 00		       lda	#0
   4124  27601			85 d7		       sta	doublebufferbufferdirty
   4125  27603					       endif		; ! BANKSET_DL_IN_CARTRAM
   4126  27603			60		       rts
   4127  27604
   4128  27604				    doublebufferoff
   4129  27604			a9 01		       lda	#1
   4130  27606			85 d5		       sta	doublebufferstate
   4131  27608			20 91 f5	       jsr	flipdisplaybuffer
   4132  2760b			a9 00		       lda	#0
   4133  2760d			85 d5		       sta	doublebufferstate
   4134  2760f			85 d6		       sta	doublebufferdloffset
   4135  27611			60		       rts
   4136  27612
   4137  27612				    DLLMEMLutLo
   4138  27612			00 70		       .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   4139  27614				    DLLMEMLutHi
   4140  27614			18 18		       .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   4141  27616				    NewPageflipstate
   4142  27616			03 01		       .byte.b	3,1
   4143  27618				    NewPageflipoffset
   4144  27618			ff 00		       .byte.b	DOUBLEBUFFEROFFSET,0
   4145  2761a
   4146  2761a					       endif		; DOUBLEBUFFER
   4147  2761a
   4148  2761a				   -	       ifconst	MOUSESUPPORT
   4149  2761a				   -
   4150  2761a				   -rotationalcompare
   4151  2761a				   -			; old =   00	  01	  10	 11
   4152  2761a				   -	       .byte	$00, $01, $ff, $00	; new=00
   4153  2761a				   -	       .byte	$ff, $00, $00, $01	; new=01
   4154  2761a				   -	       .byte	$01, $00, $00, $ff	; new=10
   4155  2761a				   -	       .byte	$00, $ff, $01, $00	; new=11
   4156  2761a				   -
   4157  2761a				   -			;  0000YyXx st mouse
   4158  2761a				   -
   4159  2761a				   -			;  0000xyXY amiga mouse
   4160  2761a				   -
   4161  2761a				   -	       ifconst	MOUSEXONLY
   4162  2761a				   -amigatoataribits		; swap bits 1 and 4...
   4163  2761a				   -	       .byte	%0000, %0000, %0010, %0010
   4164  2761a				   -	       .byte	%0000, %0000, %0010, %0010
   4165  2761a				   -	       .byte	%0001, %0001, %0011, %0011
   4166  2761a				   -	       .byte	%0001, %0001, %0011, %0011
   4167  2761a				   -
   4168  2761a				   -			; null change bits
   4169  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   4170  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   4171  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   4172  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   4173  2761a				   -
   4174  2761a				   -	       else		; !MOUSEXONLY
   4175  2761a				   -
   4176  2761a				   -amigatoataribits		; swap bits 1 and 4...
   4177  2761a				   -	       .byte	%0000, %1000, %0010, %1010
   4178  2761a				   -	       .byte	%0100, %1100, %0110, %1110
   4179  2761a				   -	       .byte	%0001, %1001, %0011, %1011
   4180  2761a				   -	       .byte	%0101, %1101, %0111, %1111
   4181  2761a				   -			; null change bits
   4182  2761a				   -	       .byte	%0000, %0001, %0010, %0011
   4183  2761a				   -	       .byte	%0100, %0101, %0110, %0111
   4184  2761a				   -	       .byte	%1000, %1001, %1010, %1011
   4185  2761a				   -	       .byte	%1100, %1101, %1110, %1111
   4186  2761a				   -	       endif		; !MOUSEXONLY
   4187  2761a				   -
   4188  2761a					       endif		; MOUSESUPPORT
   4189  2761a
   4190  2761a				    mouse0update
   4191  2761a				   -	       ifconst	MOUSE0SUPPORT
   4192  2761a				   -
   4193  2761a				   -mousetableselect =	inttemp2
   4194  2761a				   -mousexdelta =	inttemp3
   4195  2761a				   -mouseydelta =	inttemp4
   4196  2761a				   -lastSWCHA  =	inttemp6
   4197  2761a				   -
   4198  2761a				   -			;  0000YyXx st mouse
   4199  2761a				   -			;  0000xyXY amiga mouse
   4200  2761a				   -
   4201  2761a				   -	       lda	#$ff
   4202  2761a				   -	       sta	lastSWCHA
   4203  2761a				   -
   4204  2761a				   -	       ldy	port0control
   4205  2761a				   -
   4206  2761a				   -	       lda	#%00010000
   4207  2761a				   -	       cpy	#9	; AMIGA?
   4208  2761a				   -	       bne	skipamigabitsfix0
   4209  2761a				   -	       lda	#0
   4210  2761a				   -skipamigabitsfix0
   4211  2761a				   -	       sta	mousetableselect
   4212  2761a				   -	       ifconst	DRIVINGBOOST
   4213  2761a				   -	       cpy	#6	; DRIVING?
   4214  2761a				   -	       bne	skipdriving0setup
   4215  2761a				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   4216  2761a				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   4217  2761a				   -			; the actual position. This actual position is stored in mousey0 
   4218  2761a				   -			; after the driver has run.
   4219  2761a				   -	       ldx	mousex0
   4220  2761a				   -	       lda	mousey0
   4221  2761a				   -	       stx	mousey0
   4222  2761a				   -	       sta	mousex0
   4223  2761a				   -skipdriving0setup
   4224  2761a				   -	       endif		; DRIVINGBOOST
   4225  2761a				   -
   4226  2761a				   -	       lda	#0
   4227  2761a				   -	       sta	mousexdelta
   4228  2761a				   -	       sta	mouseydelta
   4229  2761a				   -
   4230  2761a				   -	       ifnconst	MOUSETIME
   4231  2761a				   -	       ifnconst	MOUSEXONLY
   4232  2761a				   -	       lda	#180	; minimum for x+y
   4233  2761a				   -	       else
   4234  2761a				   -	       lda	#100	; minimum for just x
   4235  2761a				   -	       endif
   4236  2761a				   -	       else
   4237  2761a				   -	       lda	#MOUSETIME
   4238  2761a				   -	       endif
   4239  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4240  2761a				   -
   4241  2761a				   -mouse0updateloop
   4242  2761a				   -	       lda	SWCHA
   4243  2761a				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4244  2761a				   -	       cmp	lastSWCHA
   4245  2761a				   -	       beq	mouse0loopcondition
   4246  2761a				   -	       sta	lastSWCHA
   4247  2761a				   -	       lsr
   4248  2761a				   -	       lsr
   4249  2761a				   -	       lsr
   4250  2761a				   -
   4251  2761a				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4252  2761a				   -
   4253  2761a				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4254  2761a				   -			;  0000YyXx st mouse
   4255  2761a				   -			;  0000xyXY amiga mouse
   4256  2761a				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4257  2761a				   -	       tay
   4258  2761a				   -	       lax	amigatoataribits,y
   4259  2761a				   -
   4260  2761a				   -	       ifnconst	MOUSEXONLY
   4261  2761a				   -			; first the Y...
   4262  2761a				   -	       and	#%00001100
   4263  2761a				   -	       ora	mousecodey0
   4264  2761a				   -	       tay
   4265  2761a				   -	       lda	rotationalcompare,y
   4266  2761a				   -	       clc
   4267  2761a				   -	       adc	mouseydelta
   4268  2761a				   -	       sta	mouseydelta
   4269  2761a				   -	       tya
   4270  2761a				   -	       lsr
   4271  2761a				   -	       lsr
   4272  2761a				   -	       sta	mousecodey0
   4273  2761a				   -	       txa
   4274  2761a				   -			; ...then the X...
   4275  2761a				   -	       and	#%00000011
   4276  2761a				   -	       tax
   4277  2761a				   -	       endif		; !MOUSEXONLY
   4278  2761a				   -
   4279  2761a				   -	       asl
   4280  2761a				   -	       asl
   4281  2761a				   -	       ora	mousecodex0
   4282  2761a				   -	       tay
   4283  2761a				   -	       lda	rotationalcompare,y
   4284  2761a				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4285  2761a				   -	       sta	mousexdelta
   4286  2761a				   -	       stx	mousecodex0
   4287  2761a				   -mouse0loopcondition
   4288  2761a				   -	       lda	TIMINT
   4289  2761a				   -	       bpl	mouse0updateloop
   4290  2761a				   -
   4291  2761a				   -			; *** adapt to selected device resolution. 
   4292  2761a				   -	       ldx	port0control
   4293  2761a				   -
   4294  2761a				   -	       ifconst	PRECISIONMOUSING
   4295  2761a				   -	       ldy	port0resolution
   4296  2761a				   -	       bne	mouse0halveddone
   4297  2761a				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4298  2761a				   -	       beq	mouse0halveddone
   4299  2761a				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4300  2761a				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4301  2761a				   -
   4302  2761a				   -	       lda	mousexdelta
   4303  2761a				   -	       cmp	#$80
   4304  2761a				   -	       ror		; do a signed divide by 2.
   4305  2761a				   -	       clc
   4306  2761a				   -	       adc	mousex0
   4307  2761a				   -	       sta	mousex0
   4308  2761a				   -	       ifnconst	MOUSEXONLY
   4309  2761a				   -	       lda	mouseydelta
   4310  2761a				   -	       clc
   4311  2761a				   -	       adc	mousey0
   4312  2761a				   -	       sta	mousey0
   4313  2761a				   -	       endif
   4314  2761a				   -			; at half resolution we just exit after updating x and y
   4315  2761a				   -	       jmp	LLRET0
   4316  2761a				   -mouse0halveddone
   4317  2761a				   -	       endif		; PRECISIONMOUSING
   4318  2761a				   -
   4319  2761a				   -	       ifnconst	MOUSEXONLY
   4320  2761a				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4321  2761a				   -	       ldy	port0resolution
   4322  2761a				   -	       dey
   4323  2761a				   -	       lda	#0
   4324  2761a				   -mousey0resolutionfix
   4325  2761a				   -	       clc
   4326  2761a				   -	       adc	mouseydelta
   4327  2761a				   -	       dey
   4328  2761a				   -	       bpl	mousey0resolutionfix
   4329  2761a				   -	       clc
   4330  2761a				   -	       adc	mousey0
   4331  2761a				   -	       sta	mousey0
   4332  2761a				   -	       endif		; MOUSEXONLY
   4333  2761a				   -
   4334  2761a				   -	       ldy	port0resolution
   4335  2761a				   -	       dey
   4336  2761a				   -	       lda	#0
   4337  2761a				   -mousex0resolutionfix
   4338  2761a				   -	       clc
   4339  2761a				   -	       adc	mousexdelta
   4340  2761a				   -	       dey
   4341  2761a				   -	       bpl	mousex0resolutionfix
   4342  2761a				   -	       ifnconst	DRIVINGBOOST
   4343  2761a				   -	       clc
   4344  2761a				   -	       adc	mousex0
   4345  2761a				   -	       sta	mousex0
   4346  2761a				   -	       else
   4347  2761a				   -	       cpx	#6
   4348  2761a				   -	       beq	carryonmouse0boost
   4349  2761a				   -	       clc
   4350  2761a				   -	       adc	mousex0
   4351  2761a				   -	       sta	mousex0
   4352  2761a				   -	       jmp	LLRET0
   4353  2761a				   -carryonmouse0boost
   4354  2761a				   -	       sta	mousexdelta
   4355  2761a				   -	       clc
   4356  2761a				   -	       adc	mousecodey0
   4357  2761a				   -	       sta	mousecodey0
   4358  2761a				   -	       clc
   4359  2761a				   -	       adc	mousex0
   4360  2761a				   -	       tay		; save the target X
   4361  2761a				   -	       adc	mousey0	; average in the smoothly-trailing X
   4362  2761a				   -	       ror
   4363  2761a				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   4364  2761a				   -	       sty	mousey0	; and mousey0 has the the target X
   4365  2761a				   -
   4366  2761a				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4367  2761a				   -			; A has mousex0, the smoothly trailing X
   4368  2761a				   -	       sbc	mousey0	; less the target X
   4369  2761a				   -	       bpl	skipabsolutedrive0
   4370  2761a				   -	       eor	#$ff
   4371  2761a				   -skipabsolutedrive0
   4372  2761a				   -	       cmp	#64	; just an unreasonably large change
   4373  2761a				   -	       bcc	skipdrivewrapfix0
   4374  2761a				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   4375  2761a				   -skipdrivewrapfix0
   4376  2761a				   -
   4377  2761a				   -			; get rid of the tweening if the distance travelled was very small
   4378  2761a				   -	       lda	mousexdelta
   4379  2761a				   -	       cmp	port0resolution
   4380  2761a				   -	       bcs	skipbetweenfix0
   4381  2761a				   -	       lda	mousex0
   4382  2761a				   -	       sta	mousey0
   4383  2761a				   -skipbetweenfix0
   4384  2761a				   -
   4385  2761a				   -drivingboostreductioncheck0
   4386  2761a				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4387  2761a				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4388  2761a				   -			; negated again because truncation during BCD math results in 
   4389  2761a				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4390  2761a				   -driving0fix
   4391  2761a				   -	       lax	mousecodey0
   4392  2761a				   -	       cmp	#$80
   4393  2761a				   -	       bcs	driving0skipnegate1
   4394  2761a				   -	       eor	#$FF
   4395  2761a				   -	       adc	#1
   4396  2761a				   -	       sta	mousecodey0
   4397  2761a				   -driving0skipnegate1
   4398  2761a				   -	       cmp	#$80
   4399  2761a				   -	       ror
   4400  2761a				   -	       cmp	#$80
   4401  2761a				   -	       ror
   4402  2761a				   -	       cmp	#$80
   4403  2761a				   -	       ror
   4404  2761a				   -	       sta	inttemp1
   4405  2761a				   -	       lda	mousecodey0
   4406  2761a				   -	       sec
   4407  2761a				   -	       sbc	inttemp1
   4408  2761a				   -	       cpx	#$80
   4409  2761a				   -	       bcs	driving0skipnegate2
   4410  2761a				   -	       eor	#$FF
   4411  2761a				   -	       adc	#1
   4412  2761a				   -driving0skipnegate2
   4413  2761a				   -	       sta	mousecodey0
   4414  2761a				   -drivingboostdone0
   4415  2761a				   -	       endif		; DRIVINGBOOST
   4416  2761a				   -
   4417  2761a				   -	       jmp	LLRET0
   4418  2761a				   -
   4419  2761a					       endif		; MOUSE0SUPPORT
   4420  2761a
   4421  2761a				    mouse1update
   4422  2761a				   -	       ifconst	MOUSE1SUPPORT
   4423  2761a				   -
   4424  2761a				   -mousetableselect =	inttemp2
   4425  2761a				   -mousexdelta =	inttemp3
   4426  2761a				   -mouseydelta =	inttemp4
   4427  2761a				   -lastSWCHA  =	inttemp6
   4428  2761a				   -
   4429  2761a				   -			;  0000YyXx st mouse
   4430  2761a				   -			;  0000xyXY amiga mouse
   4431  2761a				   -
   4432  2761a				   -	       lda	#$ff
   4433  2761a				   -	       sta	lastSWCHA
   4434  2761a				   -
   4435  2761a				   -	       ldy	port1control
   4436  2761a				   -
   4437  2761a				   -	       lda	#%00010000
   4438  2761a				   -	       cpy	#9	; AMIGA?
   4439  2761a				   -	       bne	skipamigabitsfix1
   4440  2761a				   -	       lda	#0
   4441  2761a				   -skipamigabitsfix1
   4442  2761a				   -	       sta	mousetableselect
   4443  2761a				   -	       ifconst	DRIVINGBOOST
   4444  2761a				   -	       cpy	#6	; DRIVING?
   4445  2761a				   -	       bne	skipdriving1setup
   4446  2761a				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   4447  2761a				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   4448  2761a				   -			; the actual position. This actual position is stored in mousey1 
   4449  2761a				   -			; after the driver has run.
   4450  2761a				   -	       ldx	mousex1
   4451  2761a				   -	       lda	mousey1
   4452  2761a				   -	       stx	mousey1
   4453  2761a				   -	       sta	mousex1
   4454  2761a				   -skipdriving1setup
   4455  2761a				   -	       endif		; DRIVINGBOOST
   4456  2761a				   -
   4457  2761a				   -	       lda	#0
   4458  2761a				   -	       sta	mousexdelta
   4459  2761a				   -	       sta	mouseydelta
   4460  2761a				   -
   4461  2761a				   -	       ifnconst	MOUSETIME
   4462  2761a				   -	       ifnconst	MOUSEXONLY
   4463  2761a				   -	       lda	#180	; minimum for x+y
   4464  2761a				   -	       else
   4465  2761a				   -	       lda	#100	; minimum for just x
   4466  2761a				   -	       endif
   4467  2761a				   -	       else
   4468  2761a				   -	       lda	#MOUSETIME
   4469  2761a				   -	       endif
   4470  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4471  2761a				   -
   4472  2761a				   -mouse1updateloop
   4473  2761a				   -	       lda	SWCHA
   4474  2761a				   -	       and	#%00001111
   4475  2761a				   -	       cmp	lastSWCHA
   4476  2761a				   -	       beq	mouse1loopcondition
   4477  2761a				   -	       sta	lastSWCHA
   4478  2761a				   -
   4479  2761a				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4480  2761a				   -
   4481  2761a				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4482  2761a				   -			;  0000YyXx st mouse
   4483  2761a				   -			;  0000xyXY amiga mouse
   4484  2761a				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4485  2761a				   -	       tay
   4486  2761a				   -	       lax	amigatoataribits,y
   4487  2761a				   -
   4488  2761a				   -	       ifnconst	MOUSEXONLY
   4489  2761a				   -			; first the Y...
   4490  2761a				   -	       and	#%00001100
   4491  2761a				   -	       ora	mousecodey1
   4492  2761a				   -	       tay
   4493  2761a				   -	       lda	rotationalcompare,y
   4494  2761a				   -	       clc
   4495  2761a				   -	       adc	mouseydelta
   4496  2761a				   -	       sta	mouseydelta
   4497  2761a				   -	       tya
   4498  2761a				   -	       lsr
   4499  2761a				   -	       lsr
   4500  2761a				   -	       sta	mousecodey1
   4501  2761a				   -	       txa
   4502  2761a				   -			; ...then the X...
   4503  2761a				   -	       and	#%00000011
   4504  2761a				   -	       tax
   4505  2761a				   -	       endif		; !MOUSEXONLY
   4506  2761a				   -
   4507  2761a				   -	       asl
   4508  2761a				   -	       asl
   4509  2761a				   -	       ora	mousecodex1
   4510  2761a				   -	       tay
   4511  2761a				   -	       lda	rotationalcompare,y
   4512  2761a				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4513  2761a				   -	       sta	mousexdelta
   4514  2761a				   -	       stx	mousecodex1
   4515  2761a				   -mouse1loopcondition
   4516  2761a				   -	       lda	TIMINT
   4517  2761a				   -	       bpl	mouse1updateloop
   4518  2761a				   -
   4519  2761a				   -			; *** adapt to selected device resolution. 
   4520  2761a				   -	       ldx	port1control
   4521  2761a				   -
   4522  2761a				   -	       ifconst	PRECISIONMOUSING
   4523  2761a				   -	       ldy	port1resolution
   4524  2761a				   -	       bne	mouse1halveddone
   4525  2761a				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4526  2761a				   -	       beq	mouse1halveddone
   4527  2761a				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4528  2761a				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4529  2761a				   -
   4530  2761a				   -	       lda	mousexdelta
   4531  2761a				   -	       cmp	#$80
   4532  2761a				   -	       ror		; do a signed divide by 2.
   4533  2761a				   -	       clc
   4534  2761a				   -	       adc	mousex1
   4535  2761a				   -	       sta	mousex1
   4536  2761a				   -	       ifnconst	MOUSEXONLY
   4537  2761a				   -	       lda	mouseydelta
   4538  2761a				   -	       clc
   4539  2761a				   -	       adc	mousey1
   4540  2761a				   -	       sta	mousey1
   4541  2761a				   -	       endif
   4542  2761a				   -			; at half resolution we just exit after updating x and y
   4543  2761a				   -	       jmp	LLRET1
   4544  2761a				   -mouse1halveddone
   4545  2761a				   -	       endif		; PRECISIONMOUSING
   4546  2761a				   -
   4547  2761a				   -	       ifnconst	MOUSEXONLY
   4548  2761a				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4549  2761a				   -	       ldy	port1resolution
   4550  2761a				   -	       dey
   4551  2761a				   -	       lda	#0
   4552  2761a				   -mousey1resolutionfix
   4553  2761a				   -	       clc
   4554  2761a				   -	       adc	mouseydelta
   4555  2761a				   -	       dey
   4556  2761a				   -	       bpl	mousey1resolutionfix
   4557  2761a				   -	       clc
   4558  2761a				   -	       adc	mousey1
   4559  2761a				   -	       sta	mousey1
   4560  2761a				   -	       endif		; MOUSEXONLY
   4561  2761a				   -
   4562  2761a				   -	       ldy	port1resolution
   4563  2761a				   -	       dey
   4564  2761a				   -	       lda	#0
   4565  2761a				   -mousex1resolutionfix
   4566  2761a				   -	       clc
   4567  2761a				   -	       adc	mousexdelta
   4568  2761a				   -	       dey
   4569  2761a				   -	       bpl	mousex1resolutionfix
   4570  2761a				   -	       ifnconst	DRIVINGBOOST
   4571  2761a				   -	       clc
   4572  2761a				   -	       adc	mousex1
   4573  2761a				   -	       sta	mousex1
   4574  2761a				   -	       else
   4575  2761a				   -	       cpx	#6
   4576  2761a				   -	       beq	carryonmouse1boost
   4577  2761a				   -	       clc
   4578  2761a				   -	       adc	mousex1
   4579  2761a				   -	       sta	mousex1
   4580  2761a				   -	       jmp	LLRET1
   4581  2761a				   -carryonmouse1boost
   4582  2761a				   -	       sta	mousexdelta
   4583  2761a				   -	       clc
   4584  2761a				   -	       adc	mousecodey1
   4585  2761a				   -	       sta	mousecodey1
   4586  2761a				   -	       clc
   4587  2761a				   -	       adc	mousex1
   4588  2761a				   -	       tay		; save the target X
   4589  2761a				   -	       adc	mousey1	; average in the smoothly-trailing X
   4590  2761a				   -	       ror
   4591  2761a				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   4592  2761a				   -	       sty	mousey1	; and mousey0 has the the target X
   4593  2761a				   -
   4594  2761a				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4595  2761a				   -			; A has mousex1, the smoothly trailing X
   4596  2761a				   -	       sbc	mousey1	; less the target X
   4597  2761a				   -	       bpl	skipabsolutedrive1
   4598  2761a				   -	       eor	#$ff
   4599  2761a				   -skipabsolutedrive1
   4600  2761a				   -	       cmp	#64	; just an unreasonably large change
   4601  2761a				   -	       bcc	skipdrivewrapfix1
   4602  2761a				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   4603  2761a				   -skipdrivewrapfix1
   4604  2761a				   -
   4605  2761a				   -			; get rid of the tweening if the distance travelled was very small
   4606  2761a				   -	       lda	mousexdelta
   4607  2761a				   -	       cmp	port1resolution
   4608  2761a				   -	       bcs	skipbetweenfix1
   4609  2761a				   -	       lda	mousex1
   4610  2761a				   -	       sta	mousey1
   4611  2761a				   -skipbetweenfix1
   4612  2761a				   -
   4613  2761a				   -drivingboostreductioncheck1
   4614  2761a				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4615  2761a				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4616  2761a				   -			; negated again because truncation during BCD math results in 
   4617  2761a				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4618  2761a				   -driving1fix
   4619  2761a				   -	       lax	mousecodey1
   4620  2761a				   -	       cmp	#$80
   4621  2761a				   -	       bcs	driving0skipnegate1
   4622  2761a				   -	       eor	#$FF
   4623  2761a				   -	       adc	#1
   4624  2761a				   -	       sta	mousecodey1
   4625  2761a				   -driving0skipnegate1
   4626  2761a				   -	       cmp	#$80
   4627  2761a				   -	       ror
   4628  2761a				   -	       cmp	#$80
   4629  2761a				   -	       ror
   4630  2761a				   -	       cmp	#$80
   4631  2761a				   -	       ror
   4632  2761a				   -	       sta	inttemp1
   4633  2761a				   -	       lda	mousecodey1
   4634  2761a				   -	       sec
   4635  2761a				   -	       sbc	inttemp1
   4636  2761a				   -	       cpx	#$80
   4637  2761a				   -	       bcs	driving1skipnegate2
   4638  2761a				   -	       eor	#$FF
   4639  2761a				   -	       adc	#1
   4640  2761a				   -driving1skipnegate2
   4641  2761a				   -	       sta	mousecodey1
   4642  2761a				   -drivingboostdone1
   4643  2761a				   -	       endif		; DRIVINGBOOST
   4644  2761a				   -
   4645  2761a				   -	       jmp	LLRET1
   4646  2761a				   -
   4647  2761a					       endif		; MOUSE1SUPPORT
   4648  2761a
   4649  2761a
   4650  2761a				    trakball0update
   4651  2761a				   -	       ifconst	TRAKBALL0SUPPORT
   4652  2761a				   -	       ifnconst	TRAKTIME
   4653  2761a				   -	       ifnconst	TRAKXONLY
   4654  2761a				   -	       lda	#180	; minimum for x+y
   4655  2761a				   -	       else		;  !TRAKXONLY
   4656  2761a				   -	       lda	#100	; minimum for just x
   4657  2761a				   -	       endif		; !TRAKXONLY
   4658  2761a				   -	       else		; !TRAKTIME
   4659  2761a				   -	       lda	#TRAKTIME
   4660  2761a				   -	       endif		; !TRAKTIME
   4661  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4662  2761a				   -	       ldx	#0
   4663  2761a				   -	       ifnconst	TRAKXONLY
   4664  2761a				   -	       ldy	#0
   4665  2761a				   -	       endif		;  TRAKXONLY
   4666  2761a				   -trakball0updateloop
   4667  2761a				   -	       lda	SWCHA
   4668  2761a				   -	       and	#%00110000
   4669  2761a				   -	       cmp	trakballcodex0
   4670  2761a				   -	       sta	trakballcodex0
   4671  2761a				   -	       beq	trakball0movementXdone
   4672  2761a				   -	       and	#%00010000
   4673  2761a				   -	       beq	trakball0negativeX
   4674  2761a				   -trakball0positiveX
   4675  2761a				   -			;(2 from beq)
   4676  2761a				   -	       inx		; 2
   4677  2761a				   -	       jmp	trakball0movementXdone	; 3
   4678  2761a				   -trakball0negativeX
   4679  2761a				   -			;(3 from beq)
   4680  2761a				   -	       dex		; 2
   4681  2761a				   -	       nop		; 2
   4682  2761a				   -trakball0movementXdone
   4683  2761a				   -
   4684  2761a				   -	       ifnconst	TRAKXONLY
   4685  2761a				   -	       lda	SWCHA
   4686  2761a				   -	       and	#%11000000
   4687  2761a				   -	       cmp	trakballcodey0
   4688  2761a				   -	       sta	trakballcodey0
   4689  2761a				   -	       beq	trakball0movementYdone
   4690  2761a				   -	       and	#%01000000
   4691  2761a				   -	       beq	trakball0negativeY
   4692  2761a				   -trakball0positiveY
   4693  2761a				   -			;(2 from beq)
   4694  2761a				   -	       iny		; 2
   4695  2761a				   -	       jmp	trakball0movementYdone	; 3
   4696  2761a				   -trakball0negativeY
   4697  2761a				   -			;(3 from beq)
   4698  2761a				   -	       dey		; 2
   4699  2761a				   -	       nop		; 2
   4700  2761a				   -trakball0movementYdone
   4701  2761a				   -	       endif		; !TRAKXONLY
   4702  2761a				   -
   4703  2761a				   -	       lda	TIMINT
   4704  2761a				   -	       bpl	trakball0updateloop
   4705  2761a				   -	       lda	#0
   4706  2761a				   -	       cpx	#0
   4707  2761a				   -	       beq	trakball0skipXadjust
   4708  2761a				   -	       clc
   4709  2761a				   -trakball0Xloop
   4710  2761a				   -	       adc	port0resolution
   4711  2761a				   -	       dex
   4712  2761a				   -	       bne	trakball0Xloop
   4713  2761a				   -	       clc
   4714  2761a				   -	       adc	trakballx0
   4715  2761a				   -	       sta	trakballx0
   4716  2761a				   -trakball0skipXadjust
   4717  2761a				   -	       ifnconst	TRAKXONLY
   4718  2761a				   -	       lda	#0
   4719  2761a				   -	       cpy	#0
   4720  2761a				   -	       beq	trakball0skipYadjust
   4721  2761a				   -	       clc
   4722  2761a				   -trakball0yloop
   4723  2761a				   -	       adc	port0resolution
   4724  2761a				   -	       dey
   4725  2761a				   -	       bne	trakball0yloop
   4726  2761a				   -	       clc
   4727  2761a				   -	       adc	trakbally0
   4728  2761a				   -	       sta	trakbally0
   4729  2761a				   -trakball0skipYadjust
   4730  2761a				   -	       endif		; !TRAKXONLY
   4731  2761a				   -
   4732  2761a				   -	       jmp	LLRET0
   4733  2761a					       endif
   4734  2761a
   4735  2761a
   4736  2761a
   4737  2761a				    trakball1update
   4738  2761a				   -	       ifconst	TRAKBALL1SUPPORT
   4739  2761a				   -	       ifnconst	TRAKTIME
   4740  2761a				   -	       ifnconst	TRAKXONLY
   4741  2761a				   -	       lda	#180	; minimum for x+y
   4742  2761a				   -	       else		;  !TRAKXONLY
   4743  2761a				   -	       lda	#100	; minimum for just x
   4744  2761a				   -	       endif		; !TRAKXONLY
   4745  2761a				   -	       else		; !TRAKTIME
   4746  2761a				   -	       lda	#TRAKTIME
   4747  2761a				   -	       endif		; !TRAKTIME
   4748  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4749  2761a				   -	       ldx	#0
   4750  2761a				   -	       ifnconst	TRAKXONLY
   4751  2761a				   -	       ldy	#0
   4752  2761a				   -	       endif		;  TRAKXONLY
   4753  2761a				   -trakball1updateloop
   4754  2761a				   -	       lda	SWCHA
   4755  2761a				   -	       and	#%00000011
   4756  2761a				   -	       cmp	trakballcodex1
   4757  2761a				   -	       sta	trakballcodex1
   4758  2761a				   -	       beq	trakball1movementXdone
   4759  2761a				   -	       and	#%00000001
   4760  2761a				   -	       beq	trakball1negativeX
   4761  2761a				   -trakball1positiveX
   4762  2761a				   -			;(2 from beq)
   4763  2761a				   -	       inx		; 2
   4764  2761a				   -	       jmp	trakball1movementXdone	; 3
   4765  2761a				   -trakball1negativeX
   4766  2761a				   -			;(3 from beq)
   4767  2761a				   -	       dex		; 2
   4768  2761a				   -	       nop		; 2
   4769  2761a				   -trakball1movementXdone
   4770  2761a				   -
   4771  2761a				   -	       ifnconst	TRAKXONLY
   4772  2761a				   -	       lda	SWCHA
   4773  2761a				   -	       and	#%00001100
   4774  2761a				   -	       cmp	trakballcodey1
   4775  2761a				   -	       sta	trakballcodey1
   4776  2761a				   -	       beq	trakball1movementYdone
   4777  2761a				   -	       and	#%00000100
   4778  2761a				   -	       beq	trakball1negativeY
   4779  2761a				   -trakball1positiveY
   4780  2761a				   -			;(2 from beq)
   4781  2761a				   -	       iny		; 2
   4782  2761a				   -	       jmp	trakball1movementYdone	; 3
   4783  2761a				   -trakball1negativeY
   4784  2761a				   -			;(3 from beq)
   4785  2761a				   -	       dey		; 2
   4786  2761a				   -	       nop		; 2
   4787  2761a				   -trakball1movementYdone
   4788  2761a				   -	       endif		; !TRAKXONLY
   4789  2761a				   -
   4790  2761a				   -	       lda	TIMINT
   4791  2761a				   -	       bpl	trakball1updateloop
   4792  2761a				   -	       lda	#0
   4793  2761a				   -	       cpx	#0
   4794  2761a				   -	       beq	trakball1skipXadjust
   4795  2761a				   -	       clc
   4796  2761a				   -trakball1Xloop
   4797  2761a				   -	       adc	port1resolution
   4798  2761a				   -	       dex
   4799  2761a				   -	       bne	trakball1Xloop
   4800  2761a				   -	       clc
   4801  2761a				   -	       adc	trakballx1
   4802  2761a				   -	       sta	trakballx1
   4803  2761a				   -trakball1skipXadjust
   4804  2761a				   -	       ifnconst	TRAKXONLY
   4805  2761a				   -	       lda	#0
   4806  2761a				   -	       cpy	#0
   4807  2761a				   -	       beq	trakball1skipYadjust
   4808  2761a				   -	       clc
   4809  2761a				   -trakball1yloop
   4810  2761a				   -	       adc	port1resolution
   4811  2761a				   -	       dey
   4812  2761a				   -	       bne	trakball1yloop
   4813  2761a				   -	       clc
   4814  2761a				   -	       adc	trakbally1
   4815  2761a				   -	       sta	trakbally1
   4816  2761a				   -trakball1skipYadjust
   4817  2761a				   -	       endif		; !TRAKXONLY
   4818  2761a				   -
   4819  2761a				   -	       jmp	LLRET1
   4820  2761a					       endif
   4821  2761a
   4822  2761a
   4823  2761a				    paddleport0update
   4824  2761a				   -	       ifconst	PADDLE0SUPPORT
   4825  2761a				   -	       lda	#6
   4826  2761a				   -	       sta	VBLANK	; start charging the paddle caps
   4827  2761a				   -	       lda	#0	; use PADDLE timing
   4828  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4829  2761a				   -
   4830  2761a				   -paddleport0updateloop
   4831  2761a				   -	       lda	INPT0
   4832  2761a				   -	       bmi	skippaddle0setposition
   4833  2761a				   -	       sty	paddleposition0
   4834  2761a				   -skippaddle0setposition
   4835  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4836  2761a				   -	       lda	INPT1
   4837  2761a				   -	       bmi	skippaddle1setposition
   4838  2761a				   -	       sty	paddleposition1
   4839  2761a				   -skippaddle1setposition
   4840  2761a				   -	       endif
   4841  2761a				   -	       ldy	INTIM
   4842  2761a				   -	       cpy	#TIMEOFFSET
   4843  2761a				   -	       bcs	paddleport0updateloop
   4844  2761a				   -
   4845  2761a				   -	       lda	#%10000110
   4846  2761a				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4847  2761a				   -	       sec
   4848  2761a				   -	       lda	paddleposition0
   4849  2761a				   -	       sbc	#TIMEOFFSET
   4850  2761a				   -	       ifconst	PADDLESCALEX2
   4851  2761a				   -	       asl
   4852  2761a				   -	       endif
   4853  2761a				   -
   4854  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4855  2761a				   -	       clc
   4856  2761a				   -	       adc	paddleprevious0
   4857  2761a				   -	       ror
   4858  2761a				   -	       sta	paddleprevious0
   4859  2761a				   -	       endif
   4860  2761a				   -
   4861  2761a				   -	       sta	paddleposition0
   4862  2761a				   -
   4863  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4864  2761a				   -	       sec
   4865  2761a				   -	       lda	paddleposition1
   4866  2761a				   -	       sbc	#TIMEOFFSET
   4867  2761a				   -	       ifconst	PADDLESCALEX2
   4868  2761a				   -	       asl
   4869  2761a				   -	       endif
   4870  2761a				   -
   4871  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4872  2761a				   -	       clc
   4873  2761a				   -	       adc	paddleprevious1
   4874  2761a				   -	       ror
   4875  2761a				   -	       sta	paddleprevious1
   4876  2761a				   -	       endif
   4877  2761a				   -	       sta	paddleposition1
   4878  2761a				   -	       endif		; TWOPADDLESUPPORT
   4879  2761a				   -
   4880  2761a				   -	       jmp	LLRET0
   4881  2761a					       endif
   4882  2761a
   4883  2761a				    paddleport1update
   4884  2761a				   -	       ifconst	PADDLE1SUPPORT
   4885  2761a				   -	       lda	#6
   4886  2761a				   -	       sta	VBLANK	; start charging the paddle caps
   4887  2761a				   -
   4888  2761a				   -	       lda	#0	; use PADDLE timing
   4889  2761a				   -	       jsr	SETTIM64T	; INTIM is in Y
   4890  2761a				   -
   4891  2761a				   -paddleport1updateloop
   4892  2761a				   -	       lda	INPT2
   4893  2761a				   -	       bmi	skippaddle2setposition
   4894  2761a				   -	       sty	paddleposition2
   4895  2761a				   -skippaddle2setposition
   4896  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4897  2761a				   -	       lda	INPT3
   4898  2761a				   -	       bmi	skippaddle3setposition
   4899  2761a				   -	       sty	paddleposition3
   4900  2761a				   -skippaddle3setposition
   4901  2761a				   -	       endif
   4902  2761a				   -	       ldy	INTIM
   4903  2761a				   -	       cpy	#TIMEOFFSET
   4904  2761a				   -	       bcs	paddleport1updateloop
   4905  2761a				   -
   4906  2761a				   -	       lda	#%10000110
   4907  2761a				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4908  2761a				   -	       sec
   4909  2761a				   -	       lda	paddleposition2
   4910  2761a				   -	       sbc	#TIMEOFFSET
   4911  2761a				   -	       ifconst	PADDLESCALEX2
   4912  2761a				   -	       asl
   4913  2761a				   -	       endif
   4914  2761a				   -
   4915  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4916  2761a				   -	       clc
   4917  2761a				   -	       adc	paddleprevious2
   4918  2761a				   -	       ror
   4919  2761a				   -	       sta	paddleprevious2
   4920  2761a				   -	       endif
   4921  2761a				   -
   4922  2761a				   -	       sta	paddleposition2
   4923  2761a				   -
   4924  2761a				   -	       ifconst	TWOPADDLESUPPORT
   4925  2761a				   -	       sec
   4926  2761a				   -	       lda	paddleposition3
   4927  2761a				   -	       sbc	#TIMEOFFSET
   4928  2761a				   -	       ifconst	PADDLESCALEX2
   4929  2761a				   -	       asl
   4930  2761a				   -	       endif
   4931  2761a				   -
   4932  2761a				   -	       ifnconst	PADDLESMOOTHINGOFF
   4933  2761a				   -	       clc
   4934  2761a				   -	       adc	paddleprevious3
   4935  2761a				   -	       ror
   4936  2761a				   -	       sta	paddleprevious3
   4937  2761a				   -	       endif
   4938  2761a				   -	       sta	paddleposition3
   4939  2761a				   -	       endif		; TWOPADDLESUPPORT
   4940  2761a				   -
   4941  2761a				   -	       jmp	LLRET1
   4942  2761a					       endif
   4943  2761a
   4944  2761a
   4945  2761a				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   4946  2761a				   -	       ifconst	PADDLESUPPORT
   4947  2761a				   -			; x=0|1 for port, rather than paddle #. 
   4948  2761a				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   4949  2761a				   -			; game wants to support 2 paddles, up to the game to instead test the 
   4950  2761a				   -			; joystick right+left directions instead.
   4951  2761a				   -	       lda	SWCHA	; top of nibble is first paddle button
   4952  2761a				   -	       cpx	#0	; port 0?
   4953  2761a				   -	       beq	skippaddleport2shift
   4954  2761a				   -	       asl		; shift second port to upper nibble
   4955  2761a				   -	       asl
   4956  2761a				   -	       asl
   4957  2761a				   -	       asl
   4958  2761a				   -skippaddleport2shift
   4959  2761a				   -	       and	#%10000000
   4960  2761a				   -	       eor	#%10000000	; invert
   4961  2761a				   -	       sta	sINPT1,x
   4962  2761a				   -	       jmp	buttonreadloopreturn
   4963  2761a					       endif		; PADDLESUPPORT
   4964  2761a
   4965  2761a				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   4966  2761a				   -	       ifconst	MOUSESUPPORT
   4967  2761a				   -			; stick the mouse buttons in the correct shadow register...
   4968  2761a				   -	       txa
   4969  2761a				   -	       asl
   4970  2761a				   -	       tay		; y=x*2
   4971  2761a				   -	       lda	INPT4,x
   4972  2761a				   -	       eor	#%10000000
   4973  2761a				   -	       lsr
   4974  2761a				   -	       sta	sINPT1,x
   4975  2761a				   -
   4976  2761a				   -	       lda	INPT1,y
   4977  2761a				   -	       and	#%10000000
   4978  2761a				   -	       eor	#%10000000
   4979  2761a				   -	       ora	sINPT1,x
   4980  2761a				   -	       sta	sINPT1,x
   4981  2761a				   -	       jmp	buttonreadloopreturn
   4982  2761a					       endif		; MOUSESUPPORT
   4983  2761a
   4984  2761a				   -	       ifconst	KEYPADSUPPORT
   4985  2761a				   -			; ** select keypad rows 0 to 3 over 4 frames...
   4986  2761a				   -keypadrowselect
   4987  2761a				   -	       inc	keypadcounter
   4988  2761a				   -	       ldy	#0
   4989  2761a				   -	       lda	port0control
   4990  2761a				   -	       cmp	#7
   4991  2761a				   -	       bne	skipport0val
   4992  2761a				   -	       iny		; y=y+1
   4993  2761a				   -skipport0val
   4994  2761a				   -	       lda	port1control
   4995  2761a				   -	       cmp	#7
   4996  2761a				   -	       bne	skipport1val
   4997  2761a				   -	       iny
   4998  2761a				   -	       iny		; y=y+2
   4999  2761a				   -skipport1val
   5000  2761a				   -	       cpy	#0
   5001  2761a				   -	       beq	exitkeypadrowselect
   5002  2761a				   -	       lda	keyrowdirectionmask,y
   5003  2761a				   -	       sta	CTLSWA
   5004  2761a				   -	       tya
   5005  2761a				   -	       asl
   5006  2761a				   -	       asl
   5007  2761a				   -	       sta	inttemp1
   5008  2761a				   -	       lda	keypadcounter
   5009  2761a				   -	       and	#3
   5010  2761a				   -	       ora	inttemp1
   5011  2761a				   -	       tax
   5012  2761a				   -	       lda	keyrowselectvalue,x
   5013  2761a				   -	       sta	SWCHA
   5014  2761a				   -exitkeypadrowselect
   5015  2761a				   -	       rts
   5016  2761a				   -
   5017  2761a				   -keyrowdirectionmask
   5018  2761a				   -	       .byte	#%00000000	; 0 : port0=input  port1=input
   5019  2761a				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   5020  2761a				   -	       .byte	#%00001111	; 2 : port0=input  port1=output
   5021  2761a				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   5022  2761a				   -
   5023  2761a				   -keyrowselectvalue
   5024  2761a				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   5025  2761a				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   5026  2761a				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   5027  2761a				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   5028  2761a					       endif		;  KEYPADSUPPORT
   5029  2761a
   5030  2761a				   -	       ifconst	KEYPADSUPPORT
   5031  2761a				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   5032  2761a				   -keypadcolumnread
   5033  2761a				   -	       lda	port0control
   5034  2761a				   -	       cmp	#7
   5035  2761a				   -	       bne	skipkeypadcolumnread0
   5036  2761a				   -	       lda	keypadcounter
   5037  2761a				   -	       and	#3
   5038  2761a				   -	       asl		; x2 because keypad variables are interleaved
   5039  2761a				   -	       tax
   5040  2761a				   -	       lda	#0
   5041  2761a				   -	       sta	keypadmatrix0a,x
   5042  2761a				   -	       lda	INPT0
   5043  2761a				   -	       cmp	#$80
   5044  2761a				   -	       rol	keypadmatrix0a,x
   5045  2761a				   -	       lda	INPT1
   5046  2761a				   -	       cmp	#$80
   5047  2761a				   -	       rol	keypadmatrix0a,x
   5048  2761a				   -	       lda	INPT4
   5049  2761a				   -	       cmp	#$80
   5050  2761a				   -	       rol	keypadmatrix0a,x
   5051  2761a				   -	       lda	keypadmatrix0a,x
   5052  2761a				   -	       eor	#%00000111
   5053  2761a				   -	       sta	keypadmatrix0a,x
   5054  2761a				   -skipkeypadcolumnread0
   5055  2761a				   -
   5056  2761a				   -	       lda	port1control
   5057  2761a				   -	       cmp	#7
   5058  2761a				   -	       bne	skipkeypadcolumnread1
   5059  2761a				   -	       lda	keypadcounter
   5060  2761a				   -	       and	#3
   5061  2761a				   -	       asl		; x2 because keypad variables are interleaved
   5062  2761a				   -	       tax
   5063  2761a				   -	       lda	#0
   5064  2761a				   -	       sta	keypadmatrix1a,x
   5065  2761a				   -	       rol	keypadmatrix1a,x
   5066  2761a				   -	       lda	INPT2
   5067  2761a				   -	       cmp	#$80
   5068  2761a				   -	       rol	keypadmatrix1a,x
   5069  2761a				   -	       lda	INPT3
   5070  2761a				   -	       cmp	#$80
   5071  2761a				   -	       rol	keypadmatrix1a,x
   5072  2761a				   -	       lda	INPT5
   5073  2761a				   -	       cmp	#$80
   5074  2761a				   -	       rol	keypadmatrix1a,x
   5075  2761a				   -	       lda	keypadmatrix1a,x
   5076  2761a				   -	       eor	#%00000111
   5077  2761a				   -	       sta	keypadmatrix1a,x
   5078  2761a				   -skipkeypadcolumnread1
   5079  2761a				   -	       rts
   5080  2761a					       endif		; KEYPADSUPPORT
   5081  2761a
   5082  2761a				    setportforinput
   5083  2761a			a5 e4		       lda	CTLSWAs
   5084  2761c			3d 25 f6	       and	allpinsinputlut,x
   5085  2761f			85 e4		       sta	CTLSWAs
   5086  27621			8d 81 02	       sta	CTLSWA
   5087  27624			60		       rts
   5088  27625
   5089  27625				    allpinsinputlut
   5090  27625			0f f0		       .byte.b	$0F, $F0
   5091  27627
   5092  27627				    setonebuttonmode
   5093  27627			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5094  27629			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5095  2762b			a9 14		       lda	#$14
   5096  2762d			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   5097  27630			a5 e5		       lda	CTLSWBs
   5098  27632			1d 3b f6	       ora	thisjoy2buttonbit,x
   5099  27635			85 e5		       sta	CTLSWBs
   5100  27637			8d 82 02	       sta	SWCHB	; turn off the 2-button disable bits
   5101  2763a			60		       rts
   5102  2763b
   5103  2763b				    thisjoy2buttonbit
   5104  2763b			04 10		       .byte.b	$04, $10
   5105  2763d
   5106  2763d				    settwobuttonmode
   5107  2763d			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5108  2763f			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5109  27641			a9 14		       lda	#$14
   5110  27643			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   5111  27646			a5 e5		       lda	CTLSWBs
   5112  27648			3d 51 f6	       and	thisjoy2buttonmask,x
   5113  2764b			85 e5		       sta	CTLSWBs
   5114  2764d			8d 82 02	       sta	SWCHB
   5115  27650			60		       rts
   5116  27651
   5117  27651				    thisjoy2buttonmask
   5118  27651			fb ef		       .byte.b	$fb, $ef
   5119  27653
   5120  27653							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5121  27653
   5122  27653				    START
   5123  27653				    start
   5124  27653
   5125  27653							;******** more or less the Atari recommended startup procedure
   5126  27653
   5127  27653			78		       sei
   5128  27654			d8		       cld
   5129  27655
   5130  27655					       ifnconst	NOTIALOCK
   5131  27655			a9 07		       lda	#$07
   5132  27657				   -	       else
   5133  27657				   -	       lda	#$06
   5134  27657					       endif
   5135  27657			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   5136  27659			a9 7f		       lda	#$7F
   5137  2765b			85 3c		       sta	CTRL	;disable DMA
   5138  2765d			a9 00		       lda	#$00
   5139  2765f			85 38		       sta	OFFSET
   5140  27661					       ifnconst	NOTIALOCK
   5141  27661			85 01		       sta	INPTCTRL
   5142  27663			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   5143  27665					       endif
   5144  27665			a2 ff		       ldx	#$FF
   5145  27667			9a		       txs
   5146  27668
   5147  27668							;************** Clear Memory
   5148  27668
   5149  27668							; ** Clear 1800-27FF, pg0+pg1 memory.
   5150  27668				    ClearMemPages
   5151  27668			a9 00		       lda	#0
   5152  2766a			a8		       tay		; y=0
   5153  2766b			85 80		       sta	$80
   5154  2766d			a2 18		       ldx	#$18
   5155  2766f				    ClearMemPagesLoop
   5156  2766f			86 81		       stx	$81	; needed for when we step on ZP memory
   5157  27671			91 80		       sta	($80),y	;Store data
   5158  27673			c8		       iny		;Next byte
   5159  27674			d0 f9		       bne	ClearMemPagesLoop
   5160  27676			e8		       inx
   5161  27677			e0 28		       cpx	#$28
   5162  27679			d0 f4		       bne	ClearMemPagesLoop
   5163  2767b			85 81		       sta	$81
   5164  2767d
   5165  2767d							;seed random number with hopefully-random timer value
   5166  2767d			a9 01		       lda	#1
   5167  2767f			0d 84 02	       ora	INTIM
   5168  27682			85 40		       sta	rand
   5169  27684
   5170  27684							; detect the console type...
   5171  27684				    pndetectvblankstart
   5172  27684			a5 28		       lda	MSTAT
   5173  27686			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5174  27688				    pndetectvblankover
   5175  27688			a5 28		       lda	MSTAT
   5176  2768a			30 fc		       bmi	pndetectvblankover	;  then wait for it to be over
   5177  2768c			a0 00		       ldy	#$00
   5178  2768e			a2 00		       ldx	#$00
   5179  27690				    pndetectvblankhappening
   5180  27690			a5 28		       lda	MSTAT
   5181  27692			30 07		       bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   5182  27694			85 24		       sta	WSYNC
   5183  27696			85 24		       sta	WSYNC
   5184  27698			e8		       inx
   5185  27699			d0 f5		       bne	pndetectvblankhappening
   5186  2769b				    pndetectinvblank
   5187  2769b			e0 7d		       cpx	#125
   5188  2769d			90 02		       bcc	pndetecispal
   5189  2769f			a0 01		       ldy	#$01
   5190  276a1				    pndetecispal
   5191  276a1			8c 09 21	       sty	paldetected
   5192  276a4
   5193  276a4			20 d3 f4	       jsr	createallgamedlls
   5194  276a7
   5195  276a7			a9 18		       lda	#>DLLMEM
   5196  276a9			85 2c		       sta	DPPH
   5197  276ab			a9 00		       lda	#<DLLMEM
   5198  276ad			85 30		       sta	DPPL
   5199  276af
   5200  276af				   -	       ifconst	pokeysupport
   5201  276af				   -			; pokey support is compiled in, so try to detect it...
   5202  276af				   -	       jsr	detectpokeylocation
   5203  276af					       endif
   5204  276af
   5205  276af			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   5206  276b1			8d b9 01	       sta	port0control
   5207  276b4			8d ba 01	       sta	port1control
   5208  276b7
   5209  276b7							;Setup port A to read mode
   5210  276b7							;lda #$00
   5211  276b7							;sta SWCHA
   5212  276b7							;sta CTLSWA
   5213  276b7
   5214  276b7				   -	       ifconst	HSSUPPORT
   5215  276b7				   -	       ifconst	bankswitchmode
   5216  276b7				   -	       ifconst	included.hiscore.asm.bank
   5217  276b7				   -	       ifconst	MCPDEVCART
   5218  276b7				   -	       lda	#($18 | included.hiscore.asm.bank)
   5219  276b7				   -	       ifconst	dumpbankswitch
   5220  276b7				   -	       sta	dumpbankswitch
   5221  276b7				   -	       endif
   5222  276b7				   -	       sta	$3000
   5223  276b7				   -	       else
   5224  276b7				   -	       lda	#(included.hiscore.asm.bank)
   5225  276b7				   -	       ifconst	dumpbankswitch
   5226  276b7				   -	       sta	dumpbankswitch
   5227  276b7				   -	       endif
   5228  276b7				   -	       sta	$8000
   5229  276b7				   -	       endif
   5230  276b7				   -	       endif		; included.hiscore.asm.bank
   5231  276b7				   -	       endif		; bankswitchmode
   5232  276b7				   -			; try to detect HSC
   5233  276b7				   -	       jsr	detecthsc
   5234  276b7				   -	       and	#1
   5235  276b7				   -	       sta	hsdevice
   5236  276b7				   -skipHSCdetect
   5237  276b7				   -			; try to detect AtariVox eeprom
   5238  276b7				   -	       jsr	detectatarivoxeeprom
   5239  276b7				   -	       and	#2
   5240  276b7				   -	       ora	hsdevice
   5241  276b7				   -	       cmp	#3
   5242  276b7				   -	       bne	storeAinhsdevice
   5243  276b7				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5244  276b7				   -			; Later we should check each device's priority byte if set, instead, 
   5245  276b7				   -	       lda	#2
   5246  276b7				   -storeAinhsdevice
   5247  276b7				   -	       sta	hsdevice
   5248  276b7				   -	       lda	#$ff
   5249  276b7				   -	       sta	hsdifficulty
   5250  276b7				   -	       sta	hsgameslot
   5251  276b7				   -	       sta	hsnewscoreline
   5252  276b7					       endif		; HSSUPPORT
   5253  276b7
   5254  276b7				   -	       ifconst	AVOXVOICE
   5255  276b7				   -	       jsr	silenceavoxvoice
   5256  276b7					       endif
   5257  276b7
   5258  276b7				   -	       ifconst	RMT
   5259  276b7				   -	       ifconst	RMTVOLUME
   5260  276b7				   -	       lda	#$F0	; default to full RMT volume
   5261  276b7				   -	       sta	rmtvolume
   5262  276b7				   -	       ifconst	TIAVOLUME
   5263  276b7				   -	       sta	tiavolume
   5264  276b7				   -	       endif		; TIAVOLUME
   5265  276b7				   -	       endif		; RMTVOLUME
   5266  276b7					       else		; !RMT
   5267  276b7				   -	       ifconst	TIAVOLUME
   5268  276b7				   -	       lda	#$F0	; default to full TIA volume
   5269  276b7				   -	       sta	tiavolume
   5270  276b7					       endif		; TIAVOLUME
   5271  276b7					       endif		; RMT
   5272  276b7
   5273  276b7					       ifconst	bankswitchmode
   5274  276b7							; we need to switch to the first bank as a default. this needs to
   5275  276b7							; happen before DMA, in case there's a topscreenroutine in bank 0
   5276  276b7				   -	       ifconst	MCPDEVCART
   5277  276b7				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5278  276b7				   -	       ifconst	dumpbankswitch
   5279  276b7				   -	       sta	dumpbankswitch
   5280  276b7				   -	       endif
   5281  276b7				   -	       sta	$3000
   5282  276b7					       else
   5283  276b7			a9 00		       lda	#0
   5284  276b9				   -	       ifconst	dumpbankswitch
   5285  276b9				   -	       sta	dumpbankswitch
   5286  276b9					       endif
   5287  276b9			8d 00 80	       sta	$8000
   5288  276bc					       endif
   5289  276bc					       endif
   5290  276bc
   5291  276bc							; CTRL 76543210
   5292  276bc							; 7 colorburst kill
   5293  276bc							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5294  276bc							; 4 character width 1=2 byte chars, 0=1 byte chars
   5295  276bc							; 3 border control 0=background color border, 1=black border
   5296  276bc							; 2 kangaroo mode 0=transparency, 1=kangaroo
   5297  276bc							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5298  276bc
   5299  276bc				   -	       ifconst	DOUBLEWIDE
   5300  276bc				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5301  276bc					       else
   5302  276bc			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5303  276be					       endif
   5304  276be
   5305  276be			20 87 f5	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   5306  276c1
   5307  276c1			85 3c		       sta	CTRL
   5308  276c3			8d 07 21	       sta	sCTRL
   5309  276c6
   5310  276c6			20 c6 f4	       jsr	vblankresync
   5311  276c9
   5312  276c9			a2 01		       ldx	#1
   5313  276cb			20 3d f6	       jsr	settwobuttonmode
   5314  276ce			a2 00		       ldx	#0
   5315  276d0			20 3d f6	       jsr	settwobuttonmode
   5316  276d3
   5317  276d3					       ifnconst	.altgamestart
   5318  276d3			4c 00 80	       jmp	game
   5319  276d6				   -	       else
   5320  276d6				   -	       jmp	.altgamestart
   5321  276d6					       endif
   5322  276d6
   5323  276d6							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5324  276d6
   5325  276d6							;************** Setup DLL entries
   5326  276d6
   5327  276d6							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5328  276d6					       ifnconst	SCREENHEIGHT
   5329  276d6			00 c0	    WSCREENHEIGHT =	192
   5330  276d6				   -	       else
   5331  276d6				   -WSCREENHEIGHT =	SCREENHEIGHT
   5332  276d6					       endif
   5333  276d6
   5334  276d6				   -	       ifnconst	ZONEHEIGHT
   5335  276d6				   -WZONEHEIGHT =	16
   5336  276d6					       else
   5337  276d6			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   5338  276d6					       endif
   5339  276d6
   5340  276d6					       ifnconst	ZONECOUNT
   5341  276d6			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5342  276d6				   -	       else
   5343  276d6				   -WZONECOUNT =	ZONECOUNT
   5344  276d6					       endif
   5345  276d6
   5346  276d6							; top of the frame, non-visible lines. this is based on NTSC,
   5347  276d6							; but we add in extra NV lines at the end of the display to ensure
   5348  276d6							; our PAL friends can play the game without it crashing.
   5349  276d6			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   5350  276d6
   5351  276d6				   -	       ifnconst	DLMEMSTART
   5352  276d6				   -	       ifnconst	DOUBLEBUFFER
   5353  276d6				   -WDLMEMSTART =	$1880
   5354  276d6				   -	       else
   5355  276d6				   -WDLMEMSTART =	$18E0
   5356  276d6				   -	       endif		; DOUBLEBUFFER
   5357  276d6					       else
   5358  276d6			40 00	    WDLMEMSTART =	DLMEMSTART
   5359  276d6					       endif
   5360  276d6
   5361  276d6				   -	       ifnconst	DLMEMEND
   5362  276d6				   -	       ifconst	EXTRADLMEMORY
   5363  276d6				   -WDLMEMEND  =	$23FF
   5364  276d6				   -	       else
   5365  276d6				   -WDLMEMEND  =	$1FFF
   5366  276d6				   -	       endif
   5367  276d6					       else
   5368  276d6			7f ff	    WDLMEMEND  =	DLMEMEND
   5369  276d6					       endif
   5370  276d6
   5371  276d6
   5372  276d6			40 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   5373  276d6
   5374  276d6				   -	       ifnconst	DOUBLEBUFFER
   5375  276d6				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5376  276d6					       else
   5377  276d6			02 a8	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5378  276d6					       endif
   5379  276d6
   5380  276d6			02 aa	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5381  276d6					       if	TDOUBLEBUFFEROFFSET > 255
   5382  276d6			00 ff	    DOUBLEBUFFEROFFSET =	255
   5383  276d6				   -	       else
   5384  276d6				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5385  276d6					       endif
   5386  276d6
   5387  276d6				   -	       ifconst	EXTRADLMEMORY
   5388  276d6				   -SECONDDLHALFSTART SET	$2300
   5389  276d6					       endif
   5390  276d6
   5391  276d6				    DLPOINTH
   5392  276d6				    DLINDEX    SET	0
   5393  276d6					       REPEAT	WZONECOUNT
   5394  276d6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276d6				   -	       ifconst	EXTRADLMEMORY
   5396  276d6				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276d6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276d6				   -	       else
   5399  276d6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276d6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276d6				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276d6				   -	       endif
   5403  276d6				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276d6					       endif		; EXTRADLMEMORY
   5405  276d6							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276d6			40		       .byte.b	>TMPMEMADDRESS
   5407  276d6				    DLINDEX    SET	DLINDEX + 1
   5393  276d6					       REPEND
   5394  276d6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276d7				   -	       ifconst	EXTRADLMEMORY
   5396  276d7				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276d7				   -	       else
   5399  276d7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276d7				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276d7				   -	       endif
   5403  276d7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276d7					       endif		; EXTRADLMEMORY
   5405  276d7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276d7			45		       .byte.b	>TMPMEMADDRESS
   5407  276d7				    DLINDEX    SET	DLINDEX + 1
   5393  276d7					       REPEND
   5394  276d7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276d8				   -	       ifconst	EXTRADLMEMORY
   5396  276d8				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276d8				   -	       else
   5399  276d8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276d8				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276d8				   -	       endif
   5403  276d8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276d8					       endif		; EXTRADLMEMORY
   5405  276d8							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276d8			4a		       .byte.b	>TMPMEMADDRESS
   5407  276d8				    DLINDEX    SET	DLINDEX + 1
   5393  276d8					       REPEND
   5394  276d8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276d9				   -	       ifconst	EXTRADLMEMORY
   5396  276d9				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276d9				   -	       else
   5399  276d9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276d9				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276d9				   -	       endif
   5403  276d9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276d9					       endif		; EXTRADLMEMORY
   5405  276d9							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276d9			50		       .byte.b	>TMPMEMADDRESS
   5407  276d9				    DLINDEX    SET	DLINDEX + 1
   5393  276d9					       REPEND
   5394  276d9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276da				   -	       ifconst	EXTRADLMEMORY
   5396  276da				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276da				   -	       else
   5399  276da				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276da				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276da				   -	       endif
   5403  276da				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276da					       endif		; EXTRADLMEMORY
   5405  276da							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276da			55		       .byte.b	>TMPMEMADDRESS
   5407  276da				    DLINDEX    SET	DLINDEX + 1
   5393  276da					       REPEND
   5394  276da				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276db				   -	       ifconst	EXTRADLMEMORY
   5396  276db				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276db				   -	       else
   5399  276db				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276db				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276db				   -	       endif
   5403  276db				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276db					       endif		; EXTRADLMEMORY
   5405  276db							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276db			5a		       .byte.b	>TMPMEMADDRESS
   5407  276db				    DLINDEX    SET	DLINDEX + 1
   5393  276db					       REPEND
   5394  276db				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276dc				   -	       ifconst	EXTRADLMEMORY
   5396  276dc				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276dc				   -	       else
   5399  276dc				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276dc				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276dc				   -	       endif
   5403  276dc				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276dc					       endif		; EXTRADLMEMORY
   5405  276dc							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276dc			60		       .byte.b	>TMPMEMADDRESS
   5407  276dc				    DLINDEX    SET	DLINDEX + 1
   5393  276dc					       REPEND
   5394  276dc				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276dd				   -	       ifconst	EXTRADLMEMORY
   5396  276dd				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276dd				   -	       else
   5399  276dd				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276dd				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276dd				   -	       endif
   5403  276dd				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276dd					       endif		; EXTRADLMEMORY
   5405  276dd							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276dd			65		       .byte.b	>TMPMEMADDRESS
   5407  276dd				    DLINDEX    SET	DLINDEX + 1
   5393  276dd					       REPEND
   5394  276dd				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276de				   -	       ifconst	EXTRADLMEMORY
   5396  276de				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276de				   -	       else
   5399  276de				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276de				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276de				   -	       endif
   5403  276de				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276de					       endif		; EXTRADLMEMORY
   5405  276de							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276de			6a		       .byte.b	>TMPMEMADDRESS
   5407  276de				    DLINDEX    SET	DLINDEX + 1
   5393  276de					       REPEND
   5394  276de				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276df				   -	       ifconst	EXTRADLMEMORY
   5396  276df				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276df				   -	       else
   5399  276df				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276df				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276df				   -	       endif
   5403  276df				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276df					       endif		; EXTRADLMEMORY
   5405  276df							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276df			70		       .byte.b	>TMPMEMADDRESS
   5407  276df				    DLINDEX    SET	DLINDEX + 1
   5393  276df					       REPEND
   5394  276df				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276e0				   -	       ifconst	EXTRADLMEMORY
   5396  276e0				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276e0				   -	       else
   5399  276e0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276e0				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276e0				   -	       endif
   5403  276e0				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276e0					       endif		; EXTRADLMEMORY
   5405  276e0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276e0			75		       .byte.b	>TMPMEMADDRESS
   5407  276e0				    DLINDEX    SET	DLINDEX + 1
   5393  276e0					       REPEND
   5394  276e0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5395  276e1				   -	       ifconst	EXTRADLMEMORY
   5396  276e1				   -	       if	TMPMEMADDRESS > $1FFF
   5397  276e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5398  276e1				   -	       else
   5399  276e1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5400  276e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  276e1				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5402  276e1				   -	       endif
   5403  276e1				   -	       endif		; TMPMEMADDRESS > $1FFF
   5404  276e1					       endif		; EXTRADLMEMORY
   5405  276e1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5406  276e1			7a		       .byte.b	>TMPMEMADDRESS
   5407  276e1				    DLINDEX    SET	DLINDEX + 1
   5408  276e2					       REPEND
   5409  276e2
   5410  276e2				   -	       ifconst	EXTRADLMEMORY
   5411  276e2				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5412  276e2					       endif
   5413  276e2
   5414  276e2
   5415  276e2				    DLPOINTL
   5416  276e2				    DLINDEX    SET	0
   5417  276e2					       REPEAT	WZONECOUNT
   5418  276e2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e2				   -	       ifconst	EXTRADLMEMORY
   5420  276e2				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e2				   -	       else
   5423  276e2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e2				   -	       endif
   5426  276e2				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e2					       endif		; EXTRADLMEMORY
   5428  276e2			00		       .byte.b	<TMPMEMADDRESS
   5429  276e2				    DLINDEX    SET	DLINDEX + 1
   5417  276e2					       REPEND
   5418  276e2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e3				   -	       ifconst	EXTRADLMEMORY
   5420  276e3				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e3				   -	       else
   5423  276e3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e3				   -	       endif
   5426  276e3				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e3					       endif		; EXTRADLMEMORY
   5428  276e3			55		       .byte.b	<TMPMEMADDRESS
   5429  276e3				    DLINDEX    SET	DLINDEX + 1
   5417  276e3					       REPEND
   5418  276e3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e4				   -	       ifconst	EXTRADLMEMORY
   5420  276e4				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e4				   -	       else
   5423  276e4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e4				   -	       endif
   5426  276e4				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e4					       endif		; EXTRADLMEMORY
   5428  276e4			aa		       .byte.b	<TMPMEMADDRESS
   5429  276e4				    DLINDEX    SET	DLINDEX + 1
   5417  276e4					       REPEND
   5418  276e4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e5				   -	       ifconst	EXTRADLMEMORY
   5420  276e5				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e5				   -	       else
   5423  276e5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e5				   -	       endif
   5426  276e5				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e5					       endif		; EXTRADLMEMORY
   5428  276e5			00		       .byte.b	<TMPMEMADDRESS
   5429  276e5				    DLINDEX    SET	DLINDEX + 1
   5417  276e5					       REPEND
   5418  276e5				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e6				   -	       ifconst	EXTRADLMEMORY
   5420  276e6				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e6				   -	       else
   5423  276e6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e6				   -	       endif
   5426  276e6				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e6					       endif		; EXTRADLMEMORY
   5428  276e6			55		       .byte.b	<TMPMEMADDRESS
   5429  276e6				    DLINDEX    SET	DLINDEX + 1
   5417  276e6					       REPEND
   5418  276e6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e7				   -	       ifconst	EXTRADLMEMORY
   5420  276e7				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e7				   -	       else
   5423  276e7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e7				   -	       endif
   5426  276e7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e7					       endif		; EXTRADLMEMORY
   5428  276e7			aa		       .byte.b	<TMPMEMADDRESS
   5429  276e7				    DLINDEX    SET	DLINDEX + 1
   5417  276e7					       REPEND
   5418  276e7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e8				   -	       ifconst	EXTRADLMEMORY
   5420  276e8				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e8				   -	       else
   5423  276e8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e8				   -	       endif
   5426  276e8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e8					       endif		; EXTRADLMEMORY
   5428  276e8			00		       .byte.b	<TMPMEMADDRESS
   5429  276e8				    DLINDEX    SET	DLINDEX + 1
   5417  276e8					       REPEND
   5418  276e8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276e9				   -	       ifconst	EXTRADLMEMORY
   5420  276e9				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276e9				   -	       else
   5423  276e9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276e9				   -	       endif
   5426  276e9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276e9					       endif		; EXTRADLMEMORY
   5428  276e9			55		       .byte.b	<TMPMEMADDRESS
   5429  276e9				    DLINDEX    SET	DLINDEX + 1
   5417  276e9					       REPEND
   5418  276e9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276ea				   -	       ifconst	EXTRADLMEMORY
   5420  276ea				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276ea				   -	       else
   5423  276ea				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276ea				   -	       endif
   5426  276ea				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276ea					       endif		; EXTRADLMEMORY
   5428  276ea			aa		       .byte.b	<TMPMEMADDRESS
   5429  276ea				    DLINDEX    SET	DLINDEX + 1
   5417  276ea					       REPEND
   5418  276ea				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276eb				   -	       ifconst	EXTRADLMEMORY
   5420  276eb				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276eb				   -	       else
   5423  276eb				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276eb				   -	       endif
   5426  276eb				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276eb					       endif		; EXTRADLMEMORY
   5428  276eb			00		       .byte.b	<TMPMEMADDRESS
   5429  276eb				    DLINDEX    SET	DLINDEX + 1
   5417  276eb					       REPEND
   5418  276eb				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276ec				   -	       ifconst	EXTRADLMEMORY
   5420  276ec				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276ec				   -	       else
   5423  276ec				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276ec				   -	       endif
   5426  276ec				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276ec					       endif		; EXTRADLMEMORY
   5428  276ec			55		       .byte.b	<TMPMEMADDRESS
   5429  276ec				    DLINDEX    SET	DLINDEX + 1
   5417  276ec					       REPEND
   5418  276ec				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5419  276ed				   -	       ifconst	EXTRADLMEMORY
   5420  276ed				   -	       if	TMPMEMADDRESS > $1FFF
   5421  276ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5422  276ed				   -	       else
   5423  276ed				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5424  276ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  276ed				   -	       endif
   5426  276ed				   -	       endif		; TMPMEMADDRESS > $1FFF
   5427  276ed					       endif		; EXTRADLMEMORY
   5428  276ed			aa		       .byte.b	<TMPMEMADDRESS
   5429  276ed				    DLINDEX    SET	DLINDEX + 1
   5430  276ee					       REPEND
   5431  276ee
   5432  276ee
   5433  276ee				    DLINDEX    SET	0
   5434  276ee					       REPEAT	WZONECOUNT
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5434  276ee					       REPEND
   5435  276ee				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5436  276ee				   -	       ifconst	EXTRADLMEMORY
   5437  276ee				   -	       if	TMPMEMADDRESS > $1FFF
   5438  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5439  276ee				   -	       else
   5440  276ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5441  276ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  276ee				   -	       endif
   5443  276ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5444  276ee					       endif		; EXTRADLMEMORY
   5445  276ee
   5446  276ee			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   5447  276ee
   5448  276ee				    DLINDEX    SET	DLINDEX + 1
   5449  276ee					       REPEND
   5450  276ee
   5451  276ee
     $4000 to $7fff used as zone memory, allowing 136 display objects per zone.
   5452  276ee					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5453  276ee
   5454  276ee				    DLHEIGHT
   5455  276ee					       REPEAT	WZONECOUNT
   5456  276ee			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276ee					       REPEND
   5456  276ef			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276ef					       REPEND
   5456  276f0			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f0					       REPEND
   5456  276f1			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f1					       REPEND
   5456  276f2			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f2					       REPEND
   5456  276f3			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f3					       REPEND
   5456  276f4			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f4					       REPEND
   5456  276f5			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f5					       REPEND
   5456  276f6			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f6					       REPEND
   5456  276f7			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f7					       REPEND
   5456  276f8			0f		       .byte.b	(WZONEHEIGHT-1)
   5455  276f8					       REPEND
   5456  276f9			0f		       .byte.b	(WZONEHEIGHT-1)
   5457  276fa					       REPEND
   5458  276fa
   5459  276fa							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5460  276fa
   5461  276fa							; a simple guard, than ensures the 7800basic code hasn't
   5462  276fa							; spilled into the encryption area...
     2180 bytes left in the 7800basic reserved area.
   5463  276fa					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5464  276fa				   -	       if	(*>$FF7D)
   5465  276fa				   -	       ERR		; abort the assembly
   5466  276fa					       endif
   5467  276fa							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5468  276fa
   5469  276fa				   -	       ifconst	DEV
   5470  276fa				   -	       ifnconst	ZONEHEIGHT
   5471  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5472  276fa				   -	       else
   5473  276fa				   -	       if	ZONEHEIGHT = 8
   5474  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5475  276fa				   -	       else
   5476  276fa				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5477  276fa				   -	       endif
   5478  276fa				   -	       endif
   5479  276fa					       endif
   5480  276fa
   5481  276fa				   -	       if	START_OF_ROM = .
   5482  276fa				   -	       .byte	0
   5483  276fa					       endif
   5484  276fa				    START_OF_ROM SET	0
   5485  276fa
   5486  276fa							; FF7E/FF7F contains the 7800basic crc checksum word
   5487  276fa
   5488  276fa							; FF80 - FFF7 contains the 7800 encryption key 
   5489  276fa
   5490  276fa				   -	       ifnconst	bankswitchmode
   5491  276fa				   -	       ORG	$FFF8
   5492  276fa					       else
   5493  276fa					       ifconst	ROM128K
   5494  27ff8					       ORG	$27FF8
   5495  27ff8					       RORG	$FFF8
   5496  27ff8					       endif
   5497  27ff8				   -	       ifconst	ROM144K
   5498  27ff8				   -	       ORG	$27FF8
   5499  27ff8				   -	       RORG	$FFF8
   5500  27ff8					       endif
   5501  27ff8				   -	       ifconst	ROM256K
   5502  27ff8				   -	       ORG	$47FF8
   5503  27ff8				   -	       RORG	$FFF8
   5504  27ff8					       endif
   5505  27ff8				   -	       ifconst	ROM272K
   5506  27ff8				   -	       ORG	$47FF8
   5507  27ff8				   -	       RORG	$FFF8
   5508  27ff8					       endif
   5509  27ff8				   -	       ifconst	ROM512K
   5510  27ff8				   -	       ORG	$87FF8
   5511  27ff8				   -	       RORG	$FFF8
   5512  27ff8					       endif
   5513  27ff8				   -	       ifconst	ROM528K
   5514  27ff8				   -	       ORG	$87FF8
   5515  27ff8				   -	       RORG	$FFF8
   5516  27ff8					       endif
   5517  27ff8					       endif
   5518  27ff8
   5519  27ff8
   5520  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   5521  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5522  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5523  27ffa
   5524  27ffa							;Vectors
   5525  27ffa			00 f0		       .word.w	NMI
   5526  27ffc			53 f6		       .word.w	START
   5527  27ffe			67 f0		       .word.w	IRQ
   5528  28000
