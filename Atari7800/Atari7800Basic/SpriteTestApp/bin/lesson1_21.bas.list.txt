------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm LEVEL 1 PASS 3
      1  10000 ????						; MACRO.H
      2  10000 ????
      3  10000 ????						; Based on the 2600 macro.h file.
      4  10000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  10000 ????						; has been adapted to give accurate results on the 7800.
      6  10000 ????
      7  10000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  10000 ????
      9  10000 ????						; Available macros...
     10  10000 ????						;   SLEEP n		 - sleep for n cycles
     11  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  10000 ????
     13  10000 ????						;-------------------------------------------------------------------------------
     14  10000 ????						; SLEEP duration
     15  10000 ????						; Original author: Thomas Jentzsch
     16  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  10000 ????						; useful for code where precise timing is required.
     18  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  10000 ????
     22  10000 ????				       MAC	sleep
     23  10000 ????			    .CYCLES    SET	{1}
     24  10000 ????
     25  10000 ????				       IF	.CYCLES < 2
     26  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  10000 ????				       ERR
     28  10000 ????				       ENDIF
     29  10000 ????
     30  10000 ????				       IF	.CYCLES & 1
     31  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  10000 ????				       nop	$80
     33  10000 ????				       ELSE
     34  10000 ????				       bit	$80
     35  10000 ????				       ENDIF
     36  10000 ????			    .CYCLES    SET	.CYCLES - 3
     37  10000 ????				       ENDIF
     38  10000 ????
     39  10000 ????				       REPEAT	.CYCLES / 2
     40  10000 ????				       nop
     41  10000 ????				       REPEND
     42  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  10000 ????
     44  10000 ????						;-------------------------------------------------------
     45  10000 ????						; SET_POINTER
     46  10000 ????						; Original author: Manuel Rotschkar
     47  10000 ????						;
     48  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     49  10000 ????						;
     50  10000 ????						; Usage: SET_POINTER pointer, address
     51  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     52  10000 ????						;
     53  10000 ????						; Note: Alters the accumulator, NZ flags
     54  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
     55  10000 ????						; IN 2: absolute address
     56  10000 ????
     57  10000 ????				       MAC	set_pointer
     58  10000 ????			    .POINTER   SET	{1}
     59  10000 ????			    .ADDRESS   SET	{2}
     60  10000 ????
     61  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
     62  10000 ????				       STA	.POINTER	; Store in pointer
     63  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
     64  10000 ????				       STA	.POINTER+1	; Store in pointer+1
     65  10000 ????
     66  10000 ????				       ENDM
     67  10000 ????
     68  10000 ????						; EOF
     69  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
     70  10000 ????
     71  10000 ????						; 7800MACRO.H
     72  10000 ????
     73  10000 ????						;-------------------------------------------------------
     74  10000 ????						; BOXCOLLISIONCHECK
     75  10000 ????						; author: Mike Saarna
     76  10000 ????						;
     77  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
     78  10000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
     79  10000 ????						; 
     80  10000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
     81  10000 ????						;
     82  10000 ????
     83  10000 ????				       MAC	boxcollisioncheck
     84  10000 ????			    .boxx1     SET	{1}
     85  10000 ????			    .boxy1     SET	{2}
     86  10000 ????			    .boxw1     SET	{3}
     87  10000 ????			    .boxh1     SET	{4}
     88  10000 ????			    .boxx2     SET	{5}
     89  10000 ????			    .boxy2     SET	{6}
     90  10000 ????			    .boxw2     SET	{7}
     91  10000 ????			    .boxh2     SET	{8}
     92  10000 ????
     93  10000 ????			    .DoXCollisionCheck
     94  10000 ????				       lda	.boxx1	;3
     95  10000 ????				       cmp	.boxx2	;2
     96  10000 ????				       bcs	.X1isbiggerthanX2	;2/3
     97  10000 ????			    .X2isbiggerthanX1
     98  10000 ????				       adc	#.boxw1	;2
     99  10000 ????				       cmp	.boxx2	;3
    100  10000 ????				       bcs	.DoYCollisionCheck	;3/2
    101  10000 ????				       bcc	.noboxcollision	;3
    102  10000 ????			    .X1isbiggerthanX2
    103  10000 ????				       clc		;2
    104  10000 ????				       sbc	#.boxw2	;2
    105  10000 ????				       cmp	.boxx2	;3
    106  10000 ????				       bcs	.noboxcollision	;3/2
    107  10000 ????			    .DoYCollisionCheck
    108  10000 ????				       lda	.boxy1	;3
    109  10000 ????				       cmp	.boxy2	;3
    110  10000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    111  10000 ????			    .Y2isbiggerthanY1
    112  10000 ????				       adc	#.boxh1	;2
    113  10000 ????				       cmp	.boxy2	;3
    114  10000 ????				       jmp	.checkdone	;6 
    115  10000 ????			    .Y1isbiggerthanY2
    116  10000 ????				       clc		;2
    117  10000 ????				       sbc	#.boxh2	;2
    118  10000 ????				       cmp	.boxy2	;3
    119  10000 ????				       bcs	.noboxcollision	;3/2
    120  10000 ????			    .boxcollision
    121  10000 ????				       sec		;2
    122  10000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    123  10000 ????			    .noboxcollision
    124  10000 ????				       clc		;2
    125  10000 ????			    .checkdone
    126  10000 ????
    127  10000 ????				       ENDM
    128  10000 ????
    129  10000 ????				       MAC	median3
    130  10000 ????
    131  10000 ????						; A median filter (for smoothing paddle jitter)
    132  10000 ????						;   this macro takes the current paddle value, compares it to historic
    133  10000 ????						;   values, and replaces the current paddle value with the median.
    134  10000 ????						; 
    135  10000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    136  10000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    137  10000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    138  10000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    139  10000 ????						;	  the previous values, and update with the median value.
    140  10000 ????						;
    141  10000 ????						; returns: CURRENT (modified to contain median value)
    142  10000 ????						;
    143  10000 ????						; author: Mike Saarna (aka RevEng)
    144  10000 ????
    145  10000 ????			    .MedianBytes SET	{1}
    146  10000 ????			    .NewValue  SET	{2}
    147  10000 ????
    148  10000 ????				       lda	#0
    149  10000 ????				       ldy	.NewValue
    150  10000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    151  10000 ????
    152  10000 ????						; build an index from relative size comparisons between our 3 values.
    153  10000 ????				       cpy	.MedianBytes
    154  10000 ????				       rol
    155  10000 ????				       cpy	.MedianBytes+1
    156  10000 ????				       rol
    157  10000 ????				       ldy	.MedianBytes
    158  10000 ????				       cpy	.MedianBytes+1
    159  10000 ????				       rol
    160  10000 ????				       tay
    161  10000 ????
    162  10000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    163  10000 ????				       lda	.MedianBytes,x
    164  10000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    165  10000 ????
    166  10000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    167  10000 ????						; newest byte (.MedianBytes+2) empty for next time.
    168  10000 ????				       lda	.MedianBytes+1
    169  10000 ????				       sta	.MedianBytes
    170  10000 ????				       lda	.MedianBytes+2
    171  10000 ????				       sta	.MedianBytes+1
    172  10000 ????				       ifnconst	MedianOrderLUT
    173  10000 ????				       jmp	MedianOrderLUTend
    174  10000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    175  10000 ????				       .byte	0	; 0  B2 < B0 < B1
    176  10000 ????				       .byte	1	; 1  B2 < B1 < B0
    177  10000 ????				       .byte	2	; 2   impossible 
    178  10000 ????				       .byte	2	; 3  B1 < B2 < B0
    179  10000 ????				       .byte	2	; 4  B0 < B2 < B1
    180  10000 ????				       .byte	2	; 5   impossible 
    181  10000 ????				       .byte	1	; 6  B0 < B1 < B2
    182  10000 ????				       .byte	0	; 7  B1 < B0 < B2
    183  10000 ????			    MedianOrderLUTend
    184  10000 ????				       endif
    185  10000 ????				       ENDM
    186  10000 ????
    187  10000 ????						; EOF
    188  10000 ????						;
    189  10000 ????						; speakjet.inc
    190  10000 ????						;
    191  10000 ????						;
    192  10000 ????						; AtariVox Speech Synth Driver
    193  10000 ????						;
    194  10000 ????						; By Alex Herbert, 2004
    195  10000 ????						;
    196  10000 ????
    197  10000 ????
    198  10000 ????
    199  10000 ????
    200  10000 ????						; Constants
    201  10000 ????
    202  10000 ????
    203  10000 ????		00 01	    SERIAL_OUTMASK equ	$01
    204  10000 ????		00 02	    SERIAL_RDYMASK equ	$02
    205  10000 ????
    206  10000 ????
    207  10000 ????
    208  10000 ????						; Macros
    209  10000 ????
    210  10000 ????				       mac	spkout
    211  10000 ????
    212  10000 ????						; check buffer-full status
    213  10000 ????				       lda	SWCHA
    214  10000 ????				       and	#SERIAL_RDYMASK
    215  10000 ????				       beq	.speech_done
    216  10000 ????
    217  10000 ????						; get next speech byte
    218  10000 ????				       ldy	#$00
    219  10000 ????				       lda	(speech_addr),y
    220  10000 ????
    221  10000 ????						; invert data and check for end of string
    222  10000 ????				       eor	#$ff
    223  10000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    224  10000 ????				       beq	.speech_done
    225  10000 ????				       sta	{1}
    226  10000 ????
    227  10000 ????						; increment speech pointer
    228  10000 ????				       inc	speech_addr
    229  10000 ????				       bne	.incaddr_skip
    230  10000 ????				       inc	speech_addr+1
    231  10000 ????			    .incaddr_skip
    232  10000 ????
    233  10000 ????						; output byte as serial data
    234  10000 ????
    235  10000 ????				       sec		; start bit
    236  10000 ????			    .byteout_loop
    237  10000 ????						; put carry flag into bit 0 of SWACNT, perserving other bits
    238  10000 ????				       lda	SWACNT	; 4
    239  10000 ????				       and	#$fe	; 2 6
    240  10000 ????				       adc	#$00	; 2 8
    241  10000 ????				       sta	SWACNT	; 4 12
    242  10000 ????
    243  10000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    244  10000 ????				       cpy	#$09	; 2 14
    245  10000 ????				       beq	.speech_done	; 2 16
    246  10000 ????				       iny		; 2 18
    247  10000 ????
    248  10000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    249  10000 ????						; to match the original baud rate...
    250  10000 ????						;ldx	  #$07 ; 2600
    251  10000 ????				       ldx	#$0D
    252  10000 ????
    253  10000 ????			    .delay_loop
    254  10000 ????				       dex		; 
    255  10000 ????				       bne	.delay_loop	; 36 54
    256  10000 ????
    257  10000 ????						; shift next data bit into carry
    258  10000 ????				       lsr	{1}	; 5 59
    259  10000 ????
    260  10000 ????						; and loop (branch always taken)
    261  10000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    262  10000 ????
    263  10000 ????			    .speech_done
    264  10000 ????
    265  10000 ????				       endm
    266  10000 ????
    267  10000 ????
    268  10000 ????				       mac	speak
    269  10000 ????
    270  10000 ????				       lda	#<{1}
    271  10000 ????				       sta	speech_addr
    272  10000 ????				       lda	#>{1}
    273  10000 ????				       sta	speech_addr+1
    274  10000 ????
    275  10000 ????				       endm
    276  10000 ????
    277  10000 ????
    278  10000 ????
    279  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    280  10000 ????
    281  10000 ????				       processor	6502
    282  10000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; 7800.h
      4  10000 ????						; Version 1.0, 2019/12/13
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at https://github.com/dasm-assembler/dasm
     10  10000 ????
     11  10000 ????
     12  10000 ????						; ******************** 7800 Hardware Adresses ***************************
     13  10000 ????						;
     14  10000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  10000 ????						;
     16  10000 ????						;	  00 -   1F	TIA REGISTERS
     17  10000 ????						;	  20 -   3F	MARIA REGISTERS
     18  10000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  10000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  10000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  10000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  10000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  10000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  10000 ????						;	 240 -  27F	???
     25  10000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  10000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  10000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  10000 ????						;	 340 -  3FF	???
     29  10000 ????						;	 400 -  47F	unused address space
     30  10000 ????						;	 480 -  4FF	RIOT RAM
     31  10000 ????						;	 500 -  57F	unused address space
     32  10000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  10000 ????						;	 600 - 17FF	unused address space
     34  10000 ????						;	1800 - 203F	RAM
     35  10000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  10000 ????						;	2100 - 213F	RAM
     37  10000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  10000 ????						;	2200 - 27FF	RAM
     39  10000 ????						;	2800 - 2FFF	mirror of 1800-27ff
     40  10000 ????						;	3000 - 3FFF	unused address space
     41  10000 ????						;	4000 - FF7F	potential cartridge address space
     42  10000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  10000 ????						;	FFFA - FFFF	6502 VECTORS
     44  10000 ????
     45  10000 ????
     46  10000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  10000 ????
     48  10000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  10000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  10000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     51  10000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     52  10000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     53  10000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     54  10000 ????
     55  10000 ????						; ** some common alternate names for INPT0/1/2/3
     56  10000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     57  10000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     58  10000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     59  10000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     60  10000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     61  10000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     62  10000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     63  10000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     64  10000 ????
     65  10000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     66  10000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     67  10000 ????
     68  10000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     69  10000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     70  10000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     71  10000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     72  10000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     73  10000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     74  10000 ????
     75  10000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     76  10000 ????
     77  10000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     78  10000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     79  10000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     80  10000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     81  10000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     82  10000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     83  10000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     84  10000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     85  10000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     86  10000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     87  10000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     88  10000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     89  10000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     90  10000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     91  10000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     92  10000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     93  10000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     94  10000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     95  10000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     96  10000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     97  10000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
     98  10000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
     99  10000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    100  10000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    101  10000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    102  10000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    103  10000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    104  10000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    105  10000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    106  10000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    107  10000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    108  10000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    109  10000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    110  10000 ????
    111  10000 ????
    112  10000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    113  10000 ????
    114  10000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    115  10000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    116  10000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    117  10000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    118  10000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    119  10000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    120  10000 ????
    121  10000 ????		02 84	    INTIM      =	$284	;Iterval Timer Read			       read-only
    122  10000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    123  10000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    124  10000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    125  10000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    126  10000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    127  10000 ????
    128  10000 ????						;XM
    129  10000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    130  10000 ????		04 70	    XCTRL1     =	$470
    131  10000 ????		04 78	    XCTRL2     =	$478
    132  10000 ????		04 7c	    XCTRL3     =	$47c
    133  10000 ????		04 71	    XCTRL4     =	$471
    134  10000 ????		04 72	    XCTRL5     =	$472
    135  10000 ????
    136  10000 ????						; Pokey register relative locations, since its base may be different
    137  10000 ????						; depending on the hardware.
    138  10000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    139  10000 ????		00 01	    PAUDC0     =	$1
    140  10000 ????		00 02	    PAUDF1     =	$2
    141  10000 ????		00 03	    PAUDC1     =	$3
    142  10000 ????		00 04	    PAUDF2     =	$4
    143  10000 ????		00 05	    PAUDC2     =	$5
    144  10000 ????		00 06	    PAUDF3     =	$6
    145  10000 ????		00 07	    PAUDC3     =	$7
    146  10000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    147  10000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    148  10000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    blank_mode =	$00
      7  10000 ????		00 1c	    blank_width_twoscompliment =	$1c
      8  10000 ????		00 04	    blank_width =	$04
      9  10000 ????		00 00	    p1_mode    =	$00
     10  10000 ????		00 1e	    p1_width_twoscompliment =	$1e
     11  10000 ????		00 02	    p1_width   =	$02
     12  10000 ????		00 00	    ex7_mode   =	$00
     13  10000 ????		00 1c	    ex7_width_twoscompliment =	$1c
     14  10000 ????		00 04	    ex7_width  =	$04
     15  10000 ????		00 00	    ex6_mode   =	$00
     16  10000 ????		00 1c	    ex6_width_twoscompliment =	$1c
     17  10000 ????		00 04	    ex6_width  =	$04
     18  10000 ????		00 00	    ex5_mode   =	$00
     19  10000 ????		00 1c	    ex5_width_twoscompliment =	$1c
     20  10000 ????		00 04	    ex5_width  =	$04
     21  10000 ????		00 00	    ex4_mode   =	$00
     22  10000 ????		00 1c	    ex4_width_twoscompliment =	$1c
     23  10000 ????		00 04	    ex4_width  =	$04
     24  10000 ????		00 00	    ex3_mode   =	$00
     25  10000 ????		00 1c	    ex3_width_twoscompliment =	$1c
     26  10000 ????		00 04	    ex3_width  =	$04
     27  10000 ????		00 00	    ex2_mode   =	$00
     28  10000 ????		00 1c	    ex2_width_twoscompliment =	$1c
     29  10000 ????		00 04	    ex2_width  =	$04
     30  10000 ????		00 00	    ex1_mode   =	$00
     31  10000 ????		00 1c	    ex1_width_twoscompliment =	$1c
     32  10000 ????		00 04	    ex1_width  =	$04
     33  10000 ????		00 00	    zonebg80x16_16_mode =	$00
     34  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
     35  10000 ????		00 14	    zonebg80x16_16_width =	$14
     36  10000 ????		00 00	    g16x16_4color8_mode =	$00
     37  10000 ????		00 1c	    g16x16_4color8_width_twoscompliment =	$1c
     38  10000 ????		00 04	    g16x16_4color8_width =	$04
     39  10000 ????		00 00	    g16x16_4color7_mode =	$00
     40  10000 ????		00 1c	    g16x16_4color7_width_twoscompliment =	$1c
     41  10000 ????		00 04	    g16x16_4color7_width =	$04
     42  10000 ????		00 00	    g16x16_4color6_mode =	$00
     43  10000 ????		00 1c	    g16x16_4color6_width_twoscompliment =	$1c
     44  10000 ????		00 04	    g16x16_4color6_width =	$04
     45  10000 ????		00 00	    g16x16_4color5_mode =	$00
     46  10000 ????		00 1c	    g16x16_4color5_width_twoscompliment =	$1c
     47  10000 ????		00 04	    g16x16_4color5_width =	$04
     48  10000 ????		00 00	    g16x16_4color4_mode =	$00
     49  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     50  10000 ????		00 04	    g16x16_4color4_width =	$04
     51  10000 ????		00 00	    g16x16_4color3_mode =	$00
     52  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     53  10000 ????		00 04	    g16x16_4color3_width =	$04
     54  10000 ????		00 00	    g16x16_4color2_mode =	$00
     55  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     56  10000 ????		00 04	    g16x16_4color2_width =	$04
     57  10000 ????		00 00	    g16x16_4color_mode =	$00
     58  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     59  10000 ????		00 04	    g16x16_4color_width =	$04
     60  10000 ????		00 01	    DOUBLEBUFFER =	1
     61  10000 ????		01 45	    wrap       =	var5
     62  10000 ????
     63  10000 ????		01 44	    ex	       =	var4
     64  10000 ????
     65  10000 ????		01 43	    an	       =	var3
     66  10000 ????
     67  10000 ????		01 42	    db	       =	var2
     68  10000 ????
     69  10000 ????		01 41	    bg	       =	var1
     70  10000 ????
     71  10000 ????		00 0f	    font_color1 =	$0f
     72  10000 ????		00 00	    font_color0 =	$00
     73  10000 ????		00 00	    blank_color1 =	0
     74  10000 ????		00 00	    blank_color0 =	$00
     75  10000 ????		00 35	    p1_color3  =	$35
     76  10000 ????		00 07	    p1_color2  =	$07
     77  10000 ????		00 0c	    p1_color1  =	$0c
     78  10000 ????		00 00	    p1_color0  =	$00
     79  10000 ????		00 07	    ex7_color1 =	$07
     80  10000 ????		00 00	    ex7_color0 =	$00
     81  10000 ????		00 00	    ex6_color3 =	0
     82  10000 ????		00 35	    ex6_color2 =	$35
     83  10000 ????		00 07	    ex6_color1 =	$07
     84  10000 ????		00 00	    ex6_color0 =	$00
     85  10000 ????		00 35	    ex5_color3 =	$35
     86  10000 ????		00 0c	    ex5_color2 =	$0c
     87  10000 ????		00 07	    ex5_color1 =	$07
     88  10000 ????		00 00	    ex5_color0 =	$00
     89  10000 ????		00 35	    ex4_color3 =	$35
     90  10000 ????		00 0c	    ex4_color2 =	$0c
     91  10000 ????		00 07	    ex4_color1 =	$07
     92  10000 ????		00 00	    ex4_color0 =	$00
     93  10000 ????		00 35	    ex3_color3 =	$35
     94  10000 ????		00 0c	    ex3_color2 =	$0c
     95  10000 ????		00 07	    ex3_color1 =	$07
     96  10000 ????		00 00	    ex3_color0 =	$00
     97  10000 ????		00 35	    ex2_color3 =	$35
     98  10000 ????		00 0c	    ex2_color2 =	$0c
     99  10000 ????		00 07	    ex2_color1 =	$07
    100  10000 ????		00 00	    ex2_color0 =	$00
    101  10000 ????		00 35	    ex1_color3 =	$35
    102  10000 ????		00 0c	    ex1_color2 =	$0c
    103  10000 ????		00 07	    ex1_color1 =	$07
    104  10000 ????		00 00	    ex1_color0 =	$00
    105  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
    106  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
    107  10000 ????		00 91	    g16x16_4color8_color3 =	$91
    108  10000 ????		00 a8	    g16x16_4color8_color2 =	$a8
    109  10000 ????		00 91	    g16x16_4color8_color1 =	$91
    110  10000 ????		00 00	    g16x16_4color8_color0 =	$00
    111  10000 ????		00 a8	    g16x16_4color7_color3 =	$a8
    112  10000 ????		00 91	    g16x16_4color7_color2 =	$91
    113  10000 ????		00 91	    g16x16_4color7_color1 =	$91
    114  10000 ????		00 00	    g16x16_4color7_color0 =	$00
    115  10000 ????		00 91	    g16x16_4color6_color3 =	$91
    116  10000 ????		00 a8	    g16x16_4color6_color2 =	$a8
    117  10000 ????		00 91	    g16x16_4color6_color1 =	$91
    118  10000 ????		00 00	    g16x16_4color6_color0 =	$00
    119  10000 ????		00 91	    g16x16_4color5_color3 =	$91
    120  10000 ????		00 a8	    g16x16_4color5_color2 =	$a8
    121  10000 ????		00 91	    g16x16_4color5_color1 =	$91
    122  10000 ????		00 00	    g16x16_4color5_color0 =	$00
    123  10000 ????		00 91	    g16x16_4color4_color3 =	$91
    124  10000 ????		00 a8	    g16x16_4color4_color2 =	$a8
    125  10000 ????		00 91	    g16x16_4color4_color1 =	$91
    126  10000 ????		00 00	    g16x16_4color4_color0 =	$00
    127  10000 ????		00 91	    g16x16_4color3_color3 =	$91
    128  10000 ????		00 a8	    g16x16_4color3_color2 =	$a8
    129  10000 ????		00 91	    g16x16_4color3_color1 =	$91
    130  10000 ????		00 00	    g16x16_4color3_color0 =	$00
    131  10000 ????		00 91	    g16x16_4color2_color3 =	$91
    132  10000 ????		00 a8	    g16x16_4color2_color2 =	$a8
    133  10000 ????		00 91	    g16x16_4color2_color1 =	$91
    134  10000 ????		00 00	    g16x16_4color2_color0 =	$00
    135  10000 ????		00 91	    g16x16_4color_color3 =	$91
    136  10000 ????		00 a8	    g16x16_4color_color2 =	$a8
    137  10000 ????		00 91	    g16x16_4color_color1 =	$91
    138  10000 ????		00 00	    g16x16_4color_color0 =	$00
    139  10000 ????		00 01	    ROM48K     =	1
    140  10000 ????		00 01	    plotvalueonscreen =	1
    141  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  10000 ????
      7  10000 ????						;************ 7800 overall RAM map **************
      8  10000 ????
      9  10000 ????						;	   40-FF	 zero page RAM
     10  10000 ????						;	  140-1FF	 RAM (stack)
     11  10000 ????						;	 1800-203F	 RAM
     12  10000 ????						;	 2100-213F	 RAM
     13  10000 ????						;	 2200-27FF	 RAM
     14  10000 ????
     15  10000 ????						;************ 7800basic RAM usage map **************
     16  10000 ????
     17  10000 ????						;	   40-FF	 numerous defines, listed below
     18  10000 ????						;	  140-1FF	 RAM (stack)
     19  10000 ????
     20  10000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  10000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  10000 ????
     23  10000 ????						;	 2000-203F	 Reserved
     24  10000 ????						;	 2100-213F	 Reserved
     25  10000 ????						;	 2200-27FF	 Free
     26  10000 ????
     27  10000 ????		1f e0	    eeprombuffer =	$1FE0
     28  10000 ????		18 00	    DLLMEM     =	$1800
     29  10000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  10000 ????
     31  10000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  10000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  10000 ????				       else
     34  10000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  10000 ????				       endif
     36  10000 ????
     37  10000 ????
     38  10000 ????		21 00	    pausestate =	$2100
     39  10000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  10000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  10000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  10000 ????		21 04	    currentbank =	$2104
     43  10000 ????
     44  10000 ????		21 05	    currentrambank =	$2105
     45  10000 ????		21 06	    charactermode =	$2106
     46  10000 ????		21 07	    sCTRL      =	$2107
     47  10000 ????		21 08	    pokeydetected =	$2108
     48  10000 ????		21 09	    paldetected =	$2109
     49  10000 ????		21 0a	    avoxdetected =	$210A
     50  10000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  10000 ????
     52  10000 ????		21 0c	    hsdevice   =	$210C
     53  10000 ????		21 0d	    hsdifficulty =	$210D
     54  10000 ????		21 0e	    hserror    =	$210E
     55  10000 ????		21 0f	    hsgameslot =	$210F
     56  10000 ????		21 10	    hsnewscoreline =	$2110
     57  10000 ????		21 11	    hsnewscorerank =	$2111
     58  10000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  10000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  10000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  10000 ????
     62  10000 ????		21 31	    ssCTRL     =	$2131
     63  10000 ????		21 32	    ssCHARBASE =	$2132
     64  10000 ????		21 33	    hsdisplaymode =	$2133
     65  10000 ????		21 34	    gamedifficulty =	$2134
     66  10000 ????		21 35	    hsinitialpos =	$2135
     67  10000 ????		21 36	    hsinitialhold =	$2136
     68  10000 ????		21 37	    hscursorx  =	$2137
     69  10000 ????		21 38	    hsjoydebounce =	$2138
     70  10000 ????		21 39	    hsswcha    =	$2139
     71  10000 ????		21 3a	    hsinpt1    =	$213A
     72  10000 ????		21 3b	    hscolorchaseindex =	$213B
     73  10000 ????		21 3c	    visibleDLLstart =	$213C
     74  10000 ????		21 3d	    overscanDLLstart =	$213D
     75  10000 ????		21 3e	    frameslost =	$213E
     76  10000 ????
     77  10000 ????
     78  10000 ????		00 40	    rand       =	$40
     79  10000 ????		00 41	    rand16     =	$41
     80  10000 ????		00 42	    temp1      =	$42
     81  10000 ????		00 43	    temp2      =	$43
     82  10000 ????		00 44	    temp3      =	$44
     83  10000 ????		00 45	    temp4      =	$45
     84  10000 ????		00 46	    temp5      =	$46
     85  10000 ????		00 47	    temp6      =	$47
     86  10000 ????		00 48	    temp7      =	$48
     87  10000 ????		00 49	    temp8      =	$49
     88  10000 ????		00 4a	    temp9      =	$4a
     89  10000 ????
     90  10000 ????		00 4b	    pokeybase  =	$4b
     91  10000 ????		00 4b	    pokeybaselo =	$4b
     92  10000 ????		00 4c	    pokeybasehi =	$4c
     93  10000 ????
     94  10000 ????		00 4d	    visibleover =	$4d
     95  10000 ????
     96  10000 ????		00 4e	    sfx1pointlo =	$4e
     97  10000 ????		00 4f	    sfx2pointlo =	$4f
     98  10000 ????		00 50	    sfx1pointhi =	$50
     99  10000 ????		00 51	    sfx2pointhi =	$51
    100  10000 ????
    101  10000 ????		00 52	    sfx1priority =	$52
    102  10000 ????		00 53	    sfx2priority =	$53
    103  10000 ????		00 54	    sfx1poffset =	$54
    104  10000 ????		00 55	    sfx2poffset =	$55
    105  10000 ????
    106  10000 ????		00 56	    sfx1frames =	$56
    107  10000 ????		00 57	    sfx2frames =	$57
    108  10000 ????		00 58	    sfx1tick   =	$58
    109  10000 ????		00 59	    sfx2tick   =	$59
    110  10000 ????
    111  10000 ????		00 5a	    tempmath   =	$5a
    112  10000 ????
    113  10000 ????		00 5b	    pokey1pointlo =	$5b
    114  10000 ????		00 5c	    pokey1pointhi =	$5c
    115  10000 ????		00 5d	    pokey2pointlo =	$5d
    116  10000 ????		00 5e	    pokey2pointhi =	$5e
    117  10000 ????		00 5f	    pokey3pointlo =	$5f
    118  10000 ????		00 60	    pokey3pointhi =	$60
    119  10000 ????		00 61	    pokey4pointlo =	$61
    120  10000 ????		00 62	    pokey4pointhi =	$62
    121  10000 ????
    122  10000 ????		00 63	    dlpnt      =	$63	; to $64
    123  10000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    124  10000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    125  10000 ????
    126  10000 ????		00 9f	    speech_addr =	$9f
    127  10000 ????		00 a0	    speech_addr_hi =	$a0
    128  10000 ????
    129  10000 ????		00 a1	    HSGameTableLo =	$a1
    130  10000 ????		00 a2	    HSGameTableHi =	$a2
    131  10000 ????		00 a3	    HSVoxHi    =	$a3
    132  10000 ????		00 a4	    HSVoxLo    =	$a4
    133  10000 ????
    134  10000 ????						;channel pointers
    135  10000 ????
    136  10000 ????		00 a5	    songchannel1layer1lo =	$a5
    137  10000 ????		00 a6	    songchannel2layer1lo =	$a6
    138  10000 ????		00 a7	    songchannel3layer1lo =	$a7
    139  10000 ????		00 a8	    songchannel4layer1lo =	$a8
    140  10000 ????
    141  10000 ????		00 a9	    songchannel1layer2lo =	$a9
    142  10000 ????		00 aa	    songchannel2layer2lo =	$aA
    143  10000 ????		00 ab	    songchannel3layer2lo =	$aB
    144  10000 ????		00 ac	    songchannel4layer2lo =	$aC
    145  10000 ????
    146  10000 ????		00 ad	    songchannel1layer3lo =	$aD
    147  10000 ????		00 ae	    songchannel2layer3lo =	$aE
    148  10000 ????		00 af	    songchannel3layer3lo =	$aF
    149  10000 ????		00 b0	    songchannel4layer3lo =	$b0
    150  10000 ????
    151  10000 ????		00 b1	    songchannel1layer1hi =	$b1
    152  10000 ????		00 b2	    songchannel2layer1hi =	$b2
    153  10000 ????		00 b3	    songchannel3layer1hi =	$b3
    154  10000 ????		00 b4	    songchannel4layer1hi =	$b4
    155  10000 ????
    156  10000 ????		00 b5	    songchannel1layer2hi =	$b5
    157  10000 ????		00 b6	    songchannel2layer2hi =	$b6
    158  10000 ????		00 b7	    songchannel3layer2hi =	$b7
    159  10000 ????		00 b8	    songchannel4layer2hi =	$b8
    160  10000 ????
    161  10000 ????		00 b9	    songchannel1layer3hi =	$b9
    162  10000 ????		00 ba	    songchannel2layer3hi =	$bA
    163  10000 ????		00 bb	    songchannel3layer3hi =	$bB
    164  10000 ????		00 bc	    songchannel4layer3hi =	$bC
    165  10000 ????
    166  10000 ????		00 bd	    songdatalo =	$bd
    167  10000 ????		00 be	    songdatahi =	$be
    168  10000 ????
    169  10000 ????		00 bf	    inactivechannelcount =	$bf
    170  10000 ????
    171  10000 ????
    172  10000 ????		00 c0	    songchannel1transpose =	$c0
    173  10000 ????		00 c1	    songchannel2transpose =	$c1
    174  10000 ????		00 c2	    songchannel3transpose =	$c2
    175  10000 ????		00 c3	    songchannel4transpose =	$c3
    176  10000 ????
    177  10000 ????		00 c4	    songstackindex =	$c4
    178  10000 ????
    179  10000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  10000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  10000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  10000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  10000 ????
    184  10000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  10000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  10000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  10000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  10000 ????
    189  10000 ????		00 cd	    sfx1notedata =	$cd
    190  10000 ????		00 ce	    sfx2notedata =	$ce
    191  10000 ????
    192  10000 ????		00 cf	    songloops  =	$cf
    193  10000 ????
    194  10000 ????		00 d0	    songpointerlo =	$D0
    195  10000 ????		00 d1	    songpointerhi =	$D1
    196  10000 ????
    197  10000 ????		00 d2	    voxlock    =	$D2
    198  10000 ????		00 d3	    voxqueuesize =	$D3
    199  10000 ????
    200  10000 ????		00 d4	    vblankroutines =	$D4
    201  10000 ????
    202  10000 ????		00 d5	    doublebufferstate =	$D5
    203  10000 ????		00 d6	    doublebufferdloffset =	$D6
    204  10000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  10000 ????
    206  10000 ????		00 d8	    inttemp1   =	$D8
    207  10000 ????		00 d9	    inttemp2   =	$D9
    208  10000 ????		00 da	    inttemp3   =	$DA
    209  10000 ????		00 db	    inttemp4   =	$DB
    210  10000 ????		00 dc	    inttemp5   =	$DC
    211  10000 ????		00 dd	    inttemp6   =	$DD
    212  10000 ????
    213  10000 ????		00 de	    sfxschedulelock =	$DE
    214  10000 ????		00 df	    sfxschedulemissed =	$DF
    215  10000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  10000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  10000 ????		00 e2	    sfxpitchoffset =	$E2
    218  10000 ????		00 e3	    sfxnoteindex =	$E3
    219  10000 ????
    220  10000 ????		00 e4	    CTLSWAs    =	$E4
    221  10000 ????		00 e5	    CTLSWBs    =	$E5
    222  10000 ????
    223  10000 ????		00 e6	    A	       =	$e6
    224  10000 ????		00 e6	    a	       =	$e6
    225  10000 ????		00 e7	    B	       =	$e7
    226  10000 ????		00 e7	    b	       =	$e7
    227  10000 ????		00 e8	    C	       =	$e8
    228  10000 ????		00 e8	    c	       =	$e8
    229  10000 ????		00 e9	    D	       =	$e9
    230  10000 ????		00 e9	    d	       =	$e9
    231  10000 ????		00 ea	    E	       =	$ea
    232  10000 ????		00 ea	    e	       =	$ea
    233  10000 ????		00 eb	    F	       =	$eb
    234  10000 ????		00 eb	    f	       =	$eb
    235  10000 ????		00 ec	    G	       =	$ec
    236  10000 ????		00 ec	    g	       =	$ec
    237  10000 ????		00 ed	    H	       =	$ed
    238  10000 ????		00 ed	    h	       =	$ed
    239  10000 ????		00 ee	    I	       =	$ee
    240  10000 ????		00 ee	    i	       =	$ee
    241  10000 ????		00 ef	    J	       =	$ef
    242  10000 ????		00 ef	    j	       =	$ef
    243  10000 ????		00 f0	    K	       =	$f0
    244  10000 ????		00 f0	    k	       =	$f0
    245  10000 ????		00 f1	    L	       =	$f1
    246  10000 ????		00 f1	    l	       =	$f1
    247  10000 ????		00 f2	    M	       =	$f2
    248  10000 ????		00 f2	    m	       =	$f2
    249  10000 ????		00 f3	    N	       =	$f3
    250  10000 ????		00 f3	    n	       =	$f3
    251  10000 ????		00 f4	    O	       =	$f4
    252  10000 ????		00 f4	    o	       =	$f4
    253  10000 ????		00 f5	    P	       =	$f5
    254  10000 ????		00 f5	    p	       =	$f5
    255  10000 ????		00 f6	    Q	       =	$f6
    256  10000 ????		00 f6	    q	       =	$f6
    257  10000 ????		00 f7	    R	       =	$f7
    258  10000 ????		00 f7	    r	       =	$f7
    259  10000 ????		00 f8	    S	       =	$f8
    260  10000 ????		00 f8	    s	       =	$f8
    261  10000 ????		00 f9	    T	       =	$f9
    262  10000 ????		00 f9	    t	       =	$f9
    263  10000 ????		00 fa	    U	       =	$fa
    264  10000 ????		00 fa	    u	       =	$fa
    265  10000 ????		00 fb	    V	       =	$fb
    266  10000 ????		00 fb	    v	       =	$fb
    267  10000 ????		00 fc	    W	       =	$fc
    268  10000 ????		00 fc	    w	       =	$fc
    269  10000 ????		00 fd	    X	       =	$fd
    270  10000 ????		00 fd	    x	       =	$fd
    271  10000 ????		00 fe	    Y	       =	$fe
    272  10000 ????		00 fe	    y	       =	$fe
    273  10000 ????		00 ff	    Z	       =	$ff
    274  10000 ????		00 ff	    z	       =	$ff
    275  10000 ????
    276  10000 ????						; var0-var99 variables use the top of the stack
    277  10000 ????		01 40	    var0       =	$140
    278  10000 ????		01 41	    var1       =	$141
    279  10000 ????		01 42	    var2       =	$142
    280  10000 ????		01 43	    var3       =	$143
    281  10000 ????		01 44	    var4       =	$144
    282  10000 ????		01 45	    var5       =	$145
    283  10000 ????		01 46	    var6       =	$146
    284  10000 ????		01 47	    var7       =	$147
    285  10000 ????		01 48	    var8       =	$148
    286  10000 ????		01 49	    var9       =	$149
    287  10000 ????		01 4a	    var10      =	$14a
    288  10000 ????		01 4b	    var11      =	$14b
    289  10000 ????		01 4c	    var12      =	$14c
    290  10000 ????		01 4d	    var13      =	$14d
    291  10000 ????		01 4e	    var14      =	$14e
    292  10000 ????		01 4f	    var15      =	$14f
    293  10000 ????		01 50	    var16      =	$150
    294  10000 ????		01 51	    var17      =	$151
    295  10000 ????		01 52	    var18      =	$152
    296  10000 ????		01 53	    var19      =	$153
    297  10000 ????		01 54	    var20      =	$154
    298  10000 ????		01 55	    var21      =	$155
    299  10000 ????		01 56	    var22      =	$156
    300  10000 ????		01 57	    var23      =	$157
    301  10000 ????		01 58	    var24      =	$158
    302  10000 ????		01 59	    var25      =	$159
    303  10000 ????		01 5a	    var26      =	$15a
    304  10000 ????		01 5b	    var27      =	$15b
    305  10000 ????		01 5c	    var28      =	$15c
    306  10000 ????		01 5d	    var29      =	$15d
    307  10000 ????		01 5e	    var30      =	$15e
    308  10000 ????		01 5f	    var31      =	$15f
    309  10000 ????		01 60	    var32      =	$160
    310  10000 ????		01 61	    var33      =	$161
    311  10000 ????		01 62	    var34      =	$162
    312  10000 ????		01 63	    var35      =	$163
    313  10000 ????		01 64	    var36      =	$164
    314  10000 ????		01 65	    var37      =	$165
    315  10000 ????		01 66	    var38      =	$166
    316  10000 ????		01 67	    var39      =	$167
    317  10000 ????		01 68	    var40      =	$168
    318  10000 ????		01 69	    var41      =	$169
    319  10000 ????		01 6a	    var42      =	$16a
    320  10000 ????		01 6b	    var43      =	$16b
    321  10000 ????		01 6c	    var44      =	$16c
    322  10000 ????		01 6d	    var45      =	$16d
    323  10000 ????		01 6e	    var46      =	$16e
    324  10000 ????		01 6f	    var47      =	$16f
    325  10000 ????		01 70	    var48      =	$170
    326  10000 ????		01 71	    var49      =	$171
    327  10000 ????		01 72	    var50      =	$172
    328  10000 ????		01 73	    var51      =	$173
    329  10000 ????		01 74	    var52      =	$174
    330  10000 ????		01 75	    var53      =	$175
    331  10000 ????		01 76	    var54      =	$176
    332  10000 ????		01 77	    var55      =	$177
    333  10000 ????		01 78	    var56      =	$178
    334  10000 ????		01 79	    var57      =	$179
    335  10000 ????		01 7a	    var58      =	$17a
    336  10000 ????		01 7b	    var59      =	$17b
    337  10000 ????		01 7c	    var60      =	$17c
    338  10000 ????		01 7d	    var61      =	$17d
    339  10000 ????		01 7e	    var62      =	$17e
    340  10000 ????		01 7f	    var63      =	$17f
    341  10000 ????		01 80	    var64      =	$180
    342  10000 ????		01 81	    var65      =	$181
    343  10000 ????		01 82	    var66      =	$182
    344  10000 ????		01 83	    var67      =	$183
    345  10000 ????		01 84	    var68      =	$184
    346  10000 ????		01 85	    var69      =	$185
    347  10000 ????		01 86	    var70      =	$186
    348  10000 ????		01 87	    var71      =	$187
    349  10000 ????		01 88	    var72      =	$188
    350  10000 ????		01 89	    var73      =	$189
    351  10000 ????		01 8a	    var74      =	$18a
    352  10000 ????		01 8b	    var75      =	$18b
    353  10000 ????		01 8c	    var76      =	$18c
    354  10000 ????		01 8d	    var77      =	$18d
    355  10000 ????		01 8e	    var78      =	$18e
    356  10000 ????		01 8f	    var79      =	$18f
    357  10000 ????		01 90	    var80      =	$190
    358  10000 ????		01 91	    var81      =	$191
    359  10000 ????		01 92	    var82      =	$192
    360  10000 ????		01 93	    var83      =	$193
    361  10000 ????		01 94	    var84      =	$194
    362  10000 ????		01 95	    var85      =	$195
    363  10000 ????		01 96	    var86      =	$196
    364  10000 ????		01 97	    var87      =	$197
    365  10000 ????		01 98	    var88      =	$198
    366  10000 ????		01 99	    var89      =	$199
    367  10000 ????		01 9a	    var90      =	$19a
    368  10000 ????		01 9b	    var91      =	$19b
    369  10000 ????		01 9c	    var92      =	$19c
    370  10000 ????		01 9d	    var93      =	$19d
    371  10000 ????		01 9e	    var94      =	$19e
    372  10000 ????		01 9f	    var95      =	$19f
    373  10000 ????		01 a0	    var96      =	$1a0
    374  10000 ????		01 a1	    var97      =	$1a1
    375  10000 ????		01 a2	    var98      =	$1a2
    376  10000 ????		01 a3	    var99      =	$1a3
    377  10000 ????
    378  10000 ????		01 a4	    framecounter =	$1A4
    379  10000 ????		01 a5	    countdownseconds =	$1A5
    380  10000 ????		01 a6	    score0     =	$1A6	; $1A7 $1A8
    381  10000 ????		01 a9	    score1     =	$1A9	; $1AA $1AB
    382  10000 ????		01 ac	    pausebuttonflag =	$1AC
    383  10000 ????		01 ad	    valbufend  =	$1AD
    384  10000 ????		01 ae	    valbufendsave =	$1AE
    385  10000 ????		01 af	    finescrollx =	$1AF
    386  10000 ????		01 b0	    finescrolly =	$1B0
    387  10000 ????		01 b1	    joybuttonmode =	$1B1	; used to track any joysticks that were changed to one-button mode
    388  10000 ????		01 b2	    interruptindex =	$1B2
    389  10000 ????		01 b3	    tempavox   =	$1B3
    390  10000 ????		01 b4	    doublebufferminimumframetarget =	$1B4
    391  10000 ????		01 b5	    doublebufferminimumframeindex =	$1B5
    392  10000 ????		01 b6	    pausedisable =	$1B6
    393  10000 ????		01 b7	    XCTRL1s    =	$1B7
    394  10000 ????		01 b8	    spritecount =	$1B8
    395  10000 ????		01 b9	    avoxenable =	$1B9
    396  10000 ????
    397  10000 ????		01 ba	    pokey1frames =	$1BA
    398  10000 ????		01 bb	    pokey1tick =	$1BB
    399  10000 ????		01 bc	    pokey2frames =	$1BC
    400  10000 ????		01 bd	    pokey2tick =	$1BD
    401  10000 ????		01 be	    pokey3frames =	$1BE
    402  10000 ????		01 bf	    pokey3tick =	$1BF
    403  10000 ????		01 c0	    pokey4frames =	$1C0
    404  10000 ????		01 c1	    pokey4tick =	$1C1
    405  10000 ????		01 c2	    pokey1priority =	$1C2
    406  10000 ????		01 c3	    pokey1offset =	$1C3
    407  10000 ????		01 c4	    pokey2priority =	$1C4
    408  10000 ????		01 c5	    pokey2offset =	$1C5
    409  10000 ????		01 c6	    pokey3priority =	$1C6
    410  10000 ????		01 c7	    pokey3offset =	$1C7
    411  10000 ????		01 c8	    pokey4priority =	$1C8
    412  10000 ????		01 c9	    pokey4offset =	$1C9
    413  10000 ????
    414  10000 ????		01 ca	    songtempo  =	$1CA
    415  10000 ????		01 cb	    songtick   =	$1CB
    416  10000 ????
    417  10000 ????		01 cc	    songchannel1layer1loops =	$1CC
    418  10000 ????		01 cd	    songchannel2layer1loops =	$1CD
    419  10000 ????		01 ce	    songchannel3layer1loops =	$1CE
    420  10000 ????		01 cf	    songchannel4layer1loops =	$1CF
    421  10000 ????
    422  10000 ????		01 d0	    songchannel1layer2loops =	$1D0
    423  10000 ????		01 d1	    songchannel2layer2loops =	$1D1
    424  10000 ????		01 d2	    songchannel3layer2loops =	$1D2
    425  10000 ????		01 d3	    songchannel4layer2loops =	$1D3
    426  10000 ????
    427  10000 ????		01 d4	    songchannel1layer3loops =	$1D4
    428  10000 ????		01 d5	    songchannel2layer3loops =	$1D5
    429  10000 ????		01 d6	    songchannel3layer3loops =	$1D6
    430  10000 ????		01 d7	    songchannel4layer3loops =	$1D7
    431  10000 ????
    432  10000 ????		01 d8	    songchannel1busywait =	$1D8
    433  10000 ????		01 d9	    songchannel2busywait =	$1D9
    434  10000 ????		01 da	    songchannel3busywait =	$1DA
    435  10000 ????		01 db	    songchannel4busywait =	$1DB
    436  10000 ????
    437  10000 ????		01 dc	    songchannel1stackdepth =	$1DC
    438  10000 ????		01 dd	    songchannel2stackdepth =	$1DD
    439  10000 ????		01 de	    songchannel3stackdepth =	$1DE
    440  10000 ????		01 df	    songchannel4stackdepth =	$1DF
    441  10000 ????
    442  10000 ????		01 e0	    palframes  =	$1E0
    443  10000 ????		01 e1	    palfastframe =	$1E1
    444  10000 ????
    445  10000 ????		01 e2	    port0control =	$1E2
    446  10000 ????		01 e3	    port1control =	$1E3
    447  10000 ????
    448  10000 ????						; port#control values...
    449  10000 ????						;	1 = proline
    450  10000 ????						;	2 = lightgun
    451  10000 ????						;	3 = paddle
    452  10000 ????						;	4 = trakball
    453  10000 ????						;	5 = vcs joystick
    454  10000 ????						;	6 = driving
    455  10000 ????						;	7 = keypad
    456  10000 ????						;	8 = st mouse/cx80
    457  10000 ????						;	9 = amiga mouse
    458  10000 ????						;     10 = atarivox
    459  10000 ????
    460  10000 ????						; controller 0 data...
    461  10000 ????		01 e4	    paddleposition0 =	$1E4
    462  10000 ????		01 e4	    keypadmatrix0a =	$1E4
    463  10000 ????		01 e4	    drivingposition0 =	$1E4
    464  10000 ????		01 e4	    trakballx0 =	$1E4
    465  10000 ????		01 e4	    mousex0    =	$1E4
    466  10000 ????		01 e4	    lighttgunx0 =	$1E4
    467  10000 ????
    468  10000 ????						; controller 1 data...
    469  10000 ????		01 e5	    paddleposition2 =	$1E5
    470  10000 ????		01 e5	    keypadmatrix1a =	$1E5
    471  10000 ????		01 e5	    drivingposition1 =	$1E5
    472  10000 ????		01 e5	    trakballx1 =	$1E5
    473  10000 ????		01 e5	    mousex1    =	$1E5
    474  10000 ????		01 e5	    lightgunx1 =	$1E5
    475  10000 ????
    476  10000 ????						; controller 0 altdata...
    477  10000 ????		01 e6	    paddleposition1 =	$1E6
    478  10000 ????		01 e6	    keypadmatrix0b =	$1E6
    479  10000 ????		01 e6	    trakbally0 =	$1E6
    480  10000 ????		01 e6	    mousey0    =	$1E6
    481  10000 ????		01 e6	    lightguny0 =	$1E6
    482  10000 ????
    483  10000 ????						; controller 1 altdata...
    484  10000 ????		01 e7	    paddleposition3 =	$1E7
    485  10000 ????		01 e7	    keypadmatrix1b =	$1E7
    486  10000 ????		01 e7	    trakbally1 =	$1E7
    487  10000 ????		01 e7	    mousey1    =	$1E7
    488  10000 ????		01 e7	    lightguny1 =	$1E7
    489  10000 ????
    490  10000 ????						; controller state save. for trakball state+dir codes, rotary position codes
    491  10000 ????		01 e8	    controller0statesave =	$1E8
    492  10000 ????		01 e8	    mousecodex0 =	$1E8
    493  10000 ????		01 e8	    trakballcodex0 =	$1E8
    494  10000 ????		01 e8	    keypadmatrix0c =	$1E8
    495  10000 ????
    496  10000 ????		01 e9	    controller1statesave =	$1E9
    497  10000 ????		01 e9	    mousecodex1 =	$1E9
    498  10000 ????		01 e9	    trakballcodex1 =	$1E9
    499  10000 ????		01 e9	    keypadmatrix1c =	$1E9
    500  10000 ????
    501  10000 ????		01 ea	    keypadmatrix0d =	$1EA
    502  10000 ????		01 ea	    mousecodey0 =	$1EA
    503  10000 ????		01 ea	    trakballcodey0 =	$1EA
    504  10000 ????
    505  10000 ????		01 eb	    keypadmatrix1d =	$1EB
    506  10000 ????		01 eb	    mousecodey1 =	$1EB
    507  10000 ????		01 eb	    trakballcodey1 =	$1EB
    508  10000 ????
    509  10000 ????		01 ec	    genesisdetected0 =	$1EC
    510  10000 ????		01 ed	    genesisdetected1 =	$1ED
    511  10000 ????
    512  10000 ????						; $1EE - $1FF reserved for stack
    513  10000 ????
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    blank_mode =	$00
      7  10000 ????		00 1c	    blank_width_twoscompliment =	$1c
      8  10000 ????		00 04	    blank_width =	$04
      9  10000 ????		00 00	    p1_mode    =	$00
     10  10000 ????		00 1e	    p1_width_twoscompliment =	$1e
     11  10000 ????		00 02	    p1_width   =	$02
     12  10000 ????		00 00	    ex7_mode   =	$00
     13  10000 ????		00 1c	    ex7_width_twoscompliment =	$1c
     14  10000 ????		00 04	    ex7_width  =	$04
     15  10000 ????		00 00	    ex6_mode   =	$00
     16  10000 ????		00 1c	    ex6_width_twoscompliment =	$1c
     17  10000 ????		00 04	    ex6_width  =	$04
     18  10000 ????		00 00	    ex5_mode   =	$00
     19  10000 ????		00 1c	    ex5_width_twoscompliment =	$1c
     20  10000 ????		00 04	    ex5_width  =	$04
     21  10000 ????		00 00	    ex4_mode   =	$00
     22  10000 ????		00 1c	    ex4_width_twoscompliment =	$1c
     23  10000 ????		00 04	    ex4_width  =	$04
     24  10000 ????		00 00	    ex3_mode   =	$00
     25  10000 ????		00 1c	    ex3_width_twoscompliment =	$1c
     26  10000 ????		00 04	    ex3_width  =	$04
     27  10000 ????		00 00	    ex2_mode   =	$00
     28  10000 ????		00 1c	    ex2_width_twoscompliment =	$1c
     29  10000 ????		00 04	    ex2_width  =	$04
     30  10000 ????		00 00	    ex1_mode   =	$00
     31  10000 ????		00 1c	    ex1_width_twoscompliment =	$1c
     32  10000 ????		00 04	    ex1_width  =	$04
     33  10000 ????		00 00	    zonebg80x16_16_mode =	$00
     34  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
     35  10000 ????		00 14	    zonebg80x16_16_width =	$14
     36  10000 ????		00 00	    g16x16_4color8_mode =	$00
     37  10000 ????		00 1c	    g16x16_4color8_width_twoscompliment =	$1c
     38  10000 ????		00 04	    g16x16_4color8_width =	$04
     39  10000 ????		00 00	    g16x16_4color7_mode =	$00
     40  10000 ????		00 1c	    g16x16_4color7_width_twoscompliment =	$1c
     41  10000 ????		00 04	    g16x16_4color7_width =	$04
     42  10000 ????		00 00	    g16x16_4color6_mode =	$00
     43  10000 ????		00 1c	    g16x16_4color6_width_twoscompliment =	$1c
     44  10000 ????		00 04	    g16x16_4color6_width =	$04
     45  10000 ????		00 00	    g16x16_4color5_mode =	$00
     46  10000 ????		00 1c	    g16x16_4color5_width_twoscompliment =	$1c
     47  10000 ????		00 04	    g16x16_4color5_width =	$04
     48  10000 ????		00 00	    g16x16_4color4_mode =	$00
     49  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     50  10000 ????		00 04	    g16x16_4color4_width =	$04
     51  10000 ????		00 00	    g16x16_4color3_mode =	$00
     52  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     53  10000 ????		00 04	    g16x16_4color3_width =	$04
     54  10000 ????		00 00	    g16x16_4color2_mode =	$00
     55  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     56  10000 ????		00 04	    g16x16_4color2_width =	$04
     57  10000 ????		00 00	    g16x16_4color_mode =	$00
     58  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     59  10000 ????		00 04	    g16x16_4color_width =	$04
     60  10000 ????		00 01	    DOUBLEBUFFER =	1
     61  10000 ????		01 45	    wrap       =	var5
     62  10000 ????
     63  10000 ????		01 44	    ex	       =	var4
     64  10000 ????
     65  10000 ????		01 43	    an	       =	var3
     66  10000 ????
     67  10000 ????		01 42	    db	       =	var2
     68  10000 ????
     69  10000 ????		01 41	    bg	       =	var1
     70  10000 ????
     71  10000 ????		00 0f	    font_color1 =	$0f
     72  10000 ????		00 00	    font_color0 =	$00
     73  10000 ????		00 00	    blank_color1 =	0
     74  10000 ????		00 00	    blank_color0 =	$00
     75  10000 ????		00 35	    p1_color3  =	$35
     76  10000 ????		00 07	    p1_color2  =	$07
     77  10000 ????		00 0c	    p1_color1  =	$0c
     78  10000 ????		00 00	    p1_color0  =	$00
     79  10000 ????		00 07	    ex7_color1 =	$07
     80  10000 ????		00 00	    ex7_color0 =	$00
     81  10000 ????		00 00	    ex6_color3 =	0
     82  10000 ????		00 35	    ex6_color2 =	$35
     83  10000 ????		00 07	    ex6_color1 =	$07
     84  10000 ????		00 00	    ex6_color0 =	$00
     85  10000 ????		00 35	    ex5_color3 =	$35
     86  10000 ????		00 0c	    ex5_color2 =	$0c
     87  10000 ????		00 07	    ex5_color1 =	$07
     88  10000 ????		00 00	    ex5_color0 =	$00
     89  10000 ????		00 35	    ex4_color3 =	$35
     90  10000 ????		00 0c	    ex4_color2 =	$0c
     91  10000 ????		00 07	    ex4_color1 =	$07
     92  10000 ????		00 00	    ex4_color0 =	$00
     93  10000 ????		00 35	    ex3_color3 =	$35
     94  10000 ????		00 0c	    ex3_color2 =	$0c
     95  10000 ????		00 07	    ex3_color1 =	$07
     96  10000 ????		00 00	    ex3_color0 =	$00
     97  10000 ????		00 35	    ex2_color3 =	$35
     98  10000 ????		00 0c	    ex2_color2 =	$0c
     99  10000 ????		00 07	    ex2_color1 =	$07
    100  10000 ????		00 00	    ex2_color0 =	$00
    101  10000 ????		00 35	    ex1_color3 =	$35
    102  10000 ????		00 0c	    ex1_color2 =	$0c
    103  10000 ????		00 07	    ex1_color1 =	$07
    104  10000 ????		00 00	    ex1_color0 =	$00
    105  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
    106  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
    107  10000 ????		00 91	    g16x16_4color8_color3 =	$91
    108  10000 ????		00 a8	    g16x16_4color8_color2 =	$a8
    109  10000 ????		00 91	    g16x16_4color8_color1 =	$91
    110  10000 ????		00 00	    g16x16_4color8_color0 =	$00
    111  10000 ????		00 a8	    g16x16_4color7_color3 =	$a8
    112  10000 ????		00 91	    g16x16_4color7_color2 =	$91
    113  10000 ????		00 91	    g16x16_4color7_color1 =	$91
    114  10000 ????		00 00	    g16x16_4color7_color0 =	$00
    115  10000 ????		00 91	    g16x16_4color6_color3 =	$91
    116  10000 ????		00 a8	    g16x16_4color6_color2 =	$a8
    117  10000 ????		00 91	    g16x16_4color6_color1 =	$91
    118  10000 ????		00 00	    g16x16_4color6_color0 =	$00
    119  10000 ????		00 91	    g16x16_4color5_color3 =	$91
    120  10000 ????		00 a8	    g16x16_4color5_color2 =	$a8
    121  10000 ????		00 91	    g16x16_4color5_color1 =	$91
    122  10000 ????		00 00	    g16x16_4color5_color0 =	$00
    123  10000 ????		00 91	    g16x16_4color4_color3 =	$91
    124  10000 ????		00 a8	    g16x16_4color4_color2 =	$a8
    125  10000 ????		00 91	    g16x16_4color4_color1 =	$91
    126  10000 ????		00 00	    g16x16_4color4_color0 =	$00
    127  10000 ????		00 91	    g16x16_4color3_color3 =	$91
    128  10000 ????		00 a8	    g16x16_4color3_color2 =	$a8
    129  10000 ????		00 91	    g16x16_4color3_color1 =	$91
    130  10000 ????		00 00	    g16x16_4color3_color0 =	$00
    131  10000 ????		00 91	    g16x16_4color2_color3 =	$91
    132  10000 ????		00 a8	    g16x16_4color2_color2 =	$a8
    133  10000 ????		00 91	    g16x16_4color2_color1 =	$91
    134  10000 ????		00 00	    g16x16_4color2_color0 =	$00
    135  10000 ????		00 91	    g16x16_4color_color3 =	$91
    136  10000 ????		00 a8	    g16x16_4color_color2 =	$a8
    137  10000 ????		00 91	    g16x16_4color_color1 =	$91
    138  10000 ????		00 00	    g16x16_4color_color0 =	$00
    139  10000 ????		00 01	    ROM48K     =	1
    140  10000 ????		00 01	    plotvalueonscreen =	1
    141  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
    285  10000 ????
    286  10000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    287  10000 ????						; For more BEAD executable info, check out the spec...
    288  10000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    289  10000 ????
    290  10000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    291  10000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    292  10000 ????
    293  10000 ????		00 40	    BDHSC      =	%01000000
    294  10000 ????		00 20	    BDYM       =	%00100000
    295  10000 ????		00 10	    BDPOKEY    =	%00010000
    296  10000 ????		00 08	    BDROF      =	%00001000
    297  10000 ????		00 00	    BD16K      =	%00000000
    298  10000 ????		00 01	    BD32K      =	%00000001
    299  10000 ????		00 02	    BD48K      =	%00000010
    300  10000 ????		00 05	    BD1800     =	%00000101
    301  10000 ????		00 06	    BD4000     =	%00000110
    302  10000 ????
    303  10000 ????			   -	       ifconst	ROM16K
    304  10000 ????			   -BEADHEADER =	1
    305  10000 ????				       endif
    306  10000 ????			   -	       ifconst	ROM32K
    307  10000 ????			   -BEADHEADER =	1
    308  10000 ????				       endif
    309  10000 ????				       ifconst	ROM48K
    310  10000 ????		00 01	    BEADHEADER =	1
    311  10000 ????				       endif
    312  10000 ????
    313  10000 ????				       ifconst	BEADHEADER
    314  10000 ????			    BEADHARDWARE SET	0
    315  10000 ????			   -	       ifconst	ROM16K
    316  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    317  10000 ????				       endif
    318  10000 ????			   -	       ifconst	ROM32K
    319  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    320  10000 ????				       endif
    321  10000 ????				       ifconst	ROM48K
    322  10000 ????			    BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    323  10000 ????				       endif
    324  10000 ????			   -	       ifconst	pokeysupport
    325  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    326  10000 ????				       endif
    327  10000 ????			   -	       ifconst	HSSUPPORT
    328  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    329  10000 ????				       endif
    330  10000 ????				       endif
    331  10000 ????
    332  10000 ????						;start address of cart...
    333  10000 ????				       ifconst	ROM48K
    334  4000					      ORG	$4000,0
    335  4000					      ifconst	BEADHEADER
    336  4000		       be ad 02 	      .byte.b	$BE,$AD,BEADHARDWARE
    337  4003					      ifconst	GAMEDESCRIPTIONSET
    338  4003		       18		      CLC
    339  4004		       90 0a		      BCC	_SKIPDESCRIPTION
    340  4006		       54 65 73 74*	      .byte.b	GAMEDESCRIPTION,0
    341  4010				   _SKIPDESCRIPTION
    342  4010					      endif
    343  4010		       6c fc ff 	      jmp	($FFFC)
    344  4013					      endif
    345  4013				  -	      else
    346  4013				  -	      ifconst	bankswitchmode
    347  4013				  -	      ifconst	ROMAT4K
    348  4013				  -	      ORG	$4000,0
    349  4013				  -	      RORG	$4000
    350  4013				  -	      else
    351  4013				  -	      ORG	$8000,0
    352  4013				  -	      RORG	$8000
    353  4013				  -	      endif
    354  4013				  -	      else		; not bankswitchmode
    355  4013				  -	      ifconst	ROM16K
    356  4013				  -	      ORG	$C000,0
    357  4013				  -	      ifconst	BEADHEADER
    358  4013				  -	      .byte	$BE,$AD,BEADHARDWARE
    359  4013				  -	      ifconst	GAMEDESCRIPTION
    360  4013				  -	      CLC
    361  4013				  -	      BCC	_SKIPDESCRIPTION
    362  4013				  -	      .byte	GAMEDESCRIPTION,0
    363  4013				  -_SKIPDESCRIPTION
    364  4013				  -	      endif
    365  4013				  -	      jmp	($FFFC)
    366  4013				  -	      endif
    367  4013				  -	      else
    368  4013				  -	      ifconst	ROM8K
    369  4013				  -	      ORG	$E000,0
    370  4013				  -	      else
    371  4013				  -	      ORG	$8000,0
    372  4013				  -	      ifconst	BEADHEADER
    373  4013				  -	      .byte	$BE,$AD,BEADHARDWARE
    374  4013				  -	      ifconst	GAMEDESCRIPTION
    375  4013				  -	      CLC
    376  4013				  -	      BCC	_SKIPDESCRIPTION
    377  4013				  -	      .byte	GAMEDESCRIPTION,0
    378  4013				  -_SKIPDESCRIPTION
    379  4013				  -	      endif
    380  4013				  -	      jmp	($FFFC)
    381  4013				  -	      endif
    382  4013				  -	      endif
    383  4013				  -	      endif
    384  4013				  -	      endif
    385  4013					      endif
    386  4013
    387  4013				   game
    388  4013				   .L00 		;;  set zoneheight 16
    389  4013
    390  4013				   .L01 		;;  displaymode 160A
    391  4013
    392  4013		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    393  4015		       85 3c		      sta	CTRL
    394  4017
    395  4017		       8d 07 21 	      sta	sCTRL
    396  401a
    397  401a				   .L02 		;;  set plotvalueonscreen on
    398  401a
    399  401a				   .L03 		;;  set romsize 48k
    400  401a
    401  401a				   .
    402  401a							;; 
    403  401a
    404  401a				   .L04 		;;  incgraphic g16x16_4color.png 160A
    405  401a
    406  401a				   .L05 		;;  incgraphic g16x16_4color2.png 160A
    407  401a
    408  401a				   .L06 		;;  incgraphic g16x16_4color3.png 160A
    409  401a
    410  401a				   .L07 		;;  incgraphic g16x16_4color4.png 160A 
    411  401a
    412  401a				   .L08 		;;  incgraphic g16x16_4color5.png 160A
    413  401a
    414  401a				   .L09 		;;  incgraphic g16x16_4color6.png 160A
    415  401a
    416  401a				   .L010		;;  incgraphic g16x16_4color7.png 160A
    417  401a
    418  401a				   .L011		;;  incgraphic g16x16_4color8.png 160A 
    419  401a
    420  401a				   .L012		;;  incgraphic zonebg80x16_16.png 160A 0 2 3 1
    421  401a
    422  401a				   .L013		;;  incgraphic ex1.png 160A
    423  401a
    424  401a				   .L014		;;  incgraphic ex2.png 160A
    425  401a
    426  401a				   .L015		;;  incgraphic ex3.png 160A
    427  401a
    428  401a				   .L016		;;  incgraphic ex4.png 160A
    429  401a
    430  401a				   .L017		;;  incgraphic ex5.png 160A
    431  401a
    432  401a				   .L018		;;  incgraphic ex6.png 160A
    433  401a
    434  401a				   .L019		;;  incgraphic ex7.png 160A
    435  401a
    436  401a				   .L020		;;  incgraphic p1.png 160A
    437  401a
    438  401a				   .L021		;;  incgraphic blank.png 160A
    439  401a
    440  401a				   .L022		;;  incgraphic font.png 160A 
    441  401a
    442  401a				   .
    443  401a							;; 
    444  401a
    445  401a				   .L023		;;  rem font
    446  401a
    447  401a				   .L024		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    448  401a
    449  401a				   .L025		;;  characterset font
    450  401a
    451  401a		       a9 e0		      lda	#>font
    452  401c		       85 34		      sta	CHARBASE
    453  401e		       8d 0b 21 	      sta	sCHARBASE
    454  4021
    455  4021		       a9 60		      lda	#(font_mode | %01100000)
    456  4023		       8d 06 21 	      sta	charactermode
    457  4026
    458  4026				   .
    459  4026							;; 
    460  4026
    461  4026				   .L026		;;  rem blue
    462  4026
    463  4026				   .L027		;;  P0C1 = $90
    464  4026
    465  4026		       a9 90		      LDA	#$90
    466  4028		       85 21		      STA	P0C1
    467  402a				   .L028		;;  P0C2 = $70
    468  402a
    469  402a		       a9 70		      LDA	#$70
    470  402c		       85 22		      STA	P0C2
    471  402e				   .L029		;;  P0C3 = $98
    472  402e
    473  402e		       a9 98		      LDA	#$98
    474  4030		       85 23		      STA	P0C3
    475  4032				   .L030		;;  rem red
    476  4032
    477  4032				   .L031		;;  P1C1 = $20
    478  4032
    479  4032		       a9 20		      LDA	#$20
    480  4034		       85 25		      STA	P1C1
    481  4036				   .L032		;;  P1C2 = $32
    482  4036
    483  4036		       a9 32		      LDA	#$32
    484  4038		       85 26		      STA	P1C2
    485  403a				   .L033		;;  P1C3 = $36
    486  403a
    487  403a		       a9 36		      LDA	#$36
    488  403c		       85 27		      STA	P1C3
    489  403e				   .L034		;;  rem green
    490  403e
    491  403e				   .L035		;;  P2C1 = $C1
    492  403e
    493  403e		       a9 c1		      LDA	#$C1
    494  4040		       85 29		      STA	P2C1
    495  4042				   .L036		;;  P2C2 = $C6
    496  4042
    497  4042		       a9 c6		      LDA	#$C6
    498  4044		       85 2a		      STA	P2C2
    499  4046				   .L037		;;  P2C3 = $CB
    500  4046
    501  4046		       a9 cb		      LDA	#$CB
    502  4048		       85 2b		      STA	P2C3
    503  404a				   .L038		;;  rem purple
    504  404a
    505  404a				   .L039		;;  P3C1 = $50
    506  404a
    507  404a		       a9 50		      LDA	#$50
    508  404c		       85 2d		      STA	P3C1
    509  404e				   .L040		;;  P3C2 = $53
    510  404e
    511  404e		       a9 53		      LDA	#$53
    512  4050		       85 2e		      STA	P3C2
    513  4052				   .L041		;;  P3C3 = $58
    514  4052
    515  4052		       a9 58		      LDA	#$58
    516  4054		       85 2f		      STA	P3C3
    517  4056				   .L042		;;  rem orange
    518  4056
    519  4056				   .L043		;;  P4C1 = $35
    520  4056
    521  4056		       a9 35		      LDA	#$35
    522  4058		       85 31		      STA	P4C1
    523  405a				   .L044		;;  P4C2 = $38
    524  405a
    525  405a		       a9 38		      LDA	#$38
    526  405c		       85 32		      STA	P4C2
    527  405e				   .L045		;;  P4C3 = $3C
    528  405e
    529  405e		       a9 3c		      LDA	#$3C
    530  4060		       85 33		      STA	P4C3
    531  4062				   .L046		;;  rem yellow
    532  4062
    533  4062				   .L047		;;  P5C1 = $15
    534  4062
    535  4062		       a9 15		      LDA	#$15
    536  4064		       85 35		      STA	P5C1
    537  4066				   .L048		;;  P5C2 = $1A
    538  4066
    539  4066		       a9 1a		      LDA	#$1A
    540  4068		       85 36		      STA	P5C2
    541  406a				   .L049		;;  P5C3 = $1E
    542  406a
    543  406a		       a9 1e		      LDA	#$1E
    544  406c		       85 37		      STA	P5C3
    545  406e				   .L050		;;  rem teal
    546  406e
    547  406e				   .L051		;;  P6C1 = $A1
    548  406e
    549  406e		       a9 a1		      LDA	#$A1
    550  4070		       85 39		      STA	P6C1
    551  4072				   .L052		;;  P6C2 = $A6
    552  4072
    553  4072		       a9 a6		      LDA	#$A6
    554  4074		       85 3a		      STA	P6C2
    555  4076				   .L053		;;  P6C3 = $Ac
    556  4076
    557  4076		       a9 ac		      LDA	#$Ac
    558  4078		       85 3b		      STA	P6C3
    559  407a				   .L054		;;  rem white
    560  407a
    561  407a				   .L055		;;  P7C1 = $0F
    562  407a
    563  407a		       a9 0f		      LDA	#$0F
    564  407c		       85 3d		      STA	P7C1
    565  407e				   .L056		;;  P7C2 = $05
    566  407e
    567  407e		       a9 05		      LDA	#$05
    568  4080		       85 3e		      STA	P7C2
    569  4082				   .L057		;;  P7C3 = $09
    570  4082
    571  4082		       a9 09		      LDA	#$09
    572  4084		       85 3f		      STA	P7C3
    573  4086				   .
    574  4086							;; 
    575  4086
    576  4086				   .L058		;;  dim bg  =	var1
    577  4086
    578  4086				   .L059		;;  dim db  =	var2
    579  4086
    580  4086				   .L060		;;  dim an  =	var3
    581  4086
    582  4086				   .L061		;;  dim ex  =	var4
    583  4086
    584  4086				   .L062		;;  dim wrap  =  var5
    585  4086
    586  4086				   .
    587  4086							;; 
    588  4086
    589  4086				   .L063		;;  bg  =  0
    590  4086
    591  4086		       a9 00		      LDA	#0
    592  4088		       8d 41 01 	      STA	bg
    593  408b				   .L064		;;  db  =  0
    594  408b
    595  408b		       a9 00		      LDA	#0
    596  408d		       8d 42 01 	      STA	db
    597  4090				   .L065		;;  an  =  0
    598  4090
    599  4090		       a9 00		      LDA	#0
    600  4092		       8d 43 01 	      STA	an
    601  4095				   .L066		;;  ex  =  0
    602  4095
    603  4095		       a9 00		      LDA	#0
    604  4097		       8d 44 01 	      STA	ex
    605  409a				   .L067		;;  wrap  =  0
    606  409a
    607  409a		       a9 00		      LDA	#0
    608  409c		       8d 45 01 	      STA	wrap
    609  409f				   .
    610  409f							;; 
    611  409f
    612  409f				   .L068		;;  w	=  0
    613  409f
    614  409f		       a9 00		      LDA	#0
    615  40a1		       85 fc		      STA	w
    616  40a3				   .L069		;;  z	=  0
    617  40a3
    618  40a3		       a9 00		      LDA	#0
    619  40a5		       85 ff		      STA	z
    620  40a7				   .
    621  40a7							;; 
    622  40a7
    623  40a7				   ._title
    624  40a7							;; _title
    625  40a7
    626  40a7				   .L070		;;  clearscreen
    627  40a7
    628  40a7		       20 77 f0 	      jsr	clearscreen
    629  40aa				   .L071		;;  plotchars 'demo^1' 7 67 3 1
    630  40aa
    631  40aa		       4c b3 40 	      JMP	skipalphadata0
    632  40ad				   alphadata0
    633  40ad		       63		      .byte.b	(<font + $0d)
    634  40ae		       64		      .byte.b	(<font + $0e)
    635  40af		       6c		      .byte.b	(<font + $16)
    636  40b0		       6e		      .byte.b	(<font + $18)
    637  40b1		       8a		      .byte.b	(<font + $34)
    638  40b2		       57		      .byte.b	(<font + $01)
    639  40b3				   skipalphadata0
    640  40b3		       a9 ad		      lda	#<alphadata0
    641  40b5		       85 42		      sta	temp1
    642  40b7
    643  40b7		       a9 40		      lda	#>alphadata0
    644  40b9		       85 43		      sta	temp2
    645  40bb
    646  40bb		       a9 1a		      lda	#26	; width in two's complement
    647  40bd		       09 e0		      ora	#224	; palette left shifted 5 bits
    648  40bf		       85 44		      sta	temp3
    649  40c1		       a9 43		      lda	#67
    650  40c3		       85 45		      sta	temp4
    651  40c5
    652  40c5		       a9 03		      lda	#3
    653  40c7		       85 46		      sta	temp5
    654  40c9
    655  40c9		       20 67 f3 	      jsr	plotcharacters
    656  40cc				   .L072		;;  plotchars 'atari^7800^basic^exploration' 1 23 5 1
    657  40cc
    658  40cc		       4c eb 40 	      JMP	skipalphadata1
    659  40cf				   alphadata1
    660  40cf		       60		      .byte.b	(<font + $0a)
    661  40d0		       73		      .byte.b	(<font + $1d)
    662  40d1		       60		      .byte.b	(<font + $0a)
    663  40d2		       71		      .byte.b	(<font + $1b)
    664  40d3		       68		      .byte.b	(<font + $12)
    665  40d4		       8a		      .byte.b	(<font + $34)
    666  40d5		       5d		      .byte.b	(<font + $07)
    667  40d6		       5e		      .byte.b	(<font + $08)
    668  40d7		       56		      .byte.b	(<font + $00)
    669  40d8		       56		      .byte.b	(<font + $00)
    670  40d9		       8a		      .byte.b	(<font + $34)
    671  40da		       61		      .byte.b	(<font + $0b)
    672  40db		       60		      .byte.b	(<font + $0a)
    673  40dc		       72		      .byte.b	(<font + $1c)
    674  40dd		       68		      .byte.b	(<font + $12)
    675  40de		       62		      .byte.b	(<font + $0c)
    676  40df		       8a		      .byte.b	(<font + $34)
    677  40e0		       64		      .byte.b	(<font + $0e)
    678  40e1		       77		      .byte.b	(<font + $21)
    679  40e2		       6f		      .byte.b	(<font + $19)
    680  40e3		       6b		      .byte.b	(<font + $15)
    681  40e4		       6e		      .byte.b	(<font + $18)
    682  40e5		       71		      .byte.b	(<font + $1b)
    683  40e6		       60		      .byte.b	(<font + $0a)
    684  40e7		       73		      .byte.b	(<font + $1d)
    685  40e8		       68		      .byte.b	(<font + $12)
    686  40e9		       6e		      .byte.b	(<font + $18)
    687  40ea		       6d		      .byte.b	(<font + $17)
    688  40eb				   skipalphadata1
    689  40eb		       a9 cf		      lda	#<alphadata1
    690  40ed		       85 42		      sta	temp1
    691  40ef
    692  40ef		       a9 40		      lda	#>alphadata1
    693  40f1		       85 43		      sta	temp2
    694  40f3
    695  40f3		       a9 04		      lda	#4	; width in two's complement
    696  40f5		       09 20		      ora	#32	; palette left shifted 5 bits
    697  40f7		       85 44		      sta	temp3
    698  40f9		       a9 17		      lda	#23
    699  40fb		       85 45		      sta	temp4
    700  40fd
    701  40fd		       a9 05		      lda	#5
    702  40ff		       85 46		      sta	temp5
    703  4101
    704  4101		       20 67 f3 	      jsr	plotcharacters
    705  4104				   .L073		;;  plotchars '160a^zoneheight^16' 7 47 7 1
    706  4104
    707  4104		       4c 19 41 	      JMP	skipalphadata2
    708  4107				   alphadata2
    709  4107		       57		      .byte.b	(<font + $01)
    710  4108		       5c		      .byte.b	(<font + $06)
    711  4109		       56		      .byte.b	(<font + $00)
    712  410a		       60		      .byte.b	(<font + $0a)
    713  410b		       8a		      .byte.b	(<font + $34)
    714  410c		       79		      .byte.b	(<font + $23)
    715  410d		       6e		      .byte.b	(<font + $18)
    716  410e		       6d		      .byte.b	(<font + $17)
    717  410f		       64		      .byte.b	(<font + $0e)
    718  4110		       67		      .byte.b	(<font + $11)
    719  4111		       64		      .byte.b	(<font + $0e)
    720  4112		       68		      .byte.b	(<font + $12)
    721  4113		       66		      .byte.b	(<font + $10)
    722  4114		       67		      .byte.b	(<font + $11)
    723  4115		       73		      .byte.b	(<font + $1d)
    724  4116		       8a		      .byte.b	(<font + $34)
    725  4117		       57		      .byte.b	(<font + $01)
    726  4118		       5c		      .byte.b	(<font + $06)
    727  4119				   skipalphadata2
    728  4119		       a9 07		      lda	#<alphadata2
    729  411b		       85 42		      sta	temp1
    730  411d
    731  411d		       a9 41		      lda	#>alphadata2
    732  411f		       85 43		      sta	temp2
    733  4121
    734  4121		       a9 0e		      lda	#14	; width in two's complement
    735  4123		       09 e0		      ora	#224	; palette left shifted 5 bits
    736  4125		       85 44		      sta	temp3
    737  4127		       a9 2f		      lda	#47
    738  4129		       85 45		      sta	temp4
    739  412b
    740  412b		       a9 07		      lda	#7
    741  412d		       85 46		      sta	temp5
    742  412f
    743  412f		       20 67 f3 	      jsr	plotcharacters
    744  4132				   .L074		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen2_init
    745  4132
    746  4132		       a9 08		      LDA	#8
    747  4134		       c5 fc		      CMP	w
    748  4136		       b0 0c		      BCS	.skipL074
    749  4138				   .condpart0
    750  4138		       2c 02 21 	      bit	sINPT1
    751  413b		       10 07		      BPL	.skip0then
    752  413d				   .condpart1
    753  413d		       a9 00		      LDA	#0
    754  413f		       85 fc		      STA	w
    755  4141		       4c 51 41 	      jmp	._screen2_init
    756  4144
    757  4144				   .skip0then
    758  4144				   .skipL074
    759  4144				   .L075		;;  w	=  w  +  1
    760  4144
    761  4144		       a5 fc		      LDA	w
    762  4146		       18		      CLC
    763  4147		       69 01		      ADC	#1
    764  4149		       85 fc		      STA	w
    765  414b				   .L076		;;  drawscreen
    766  414b
    767  414b		       20 b3 f0 	      jsr	drawscreen
    768  414e				   .L077		;;  goto _title
    769  414e
    770  414e		       4c a7 40 	      jmp	._title
    771  4151
    772  4151				   .
    773  4151							;; 
    774  4151
    775  4151				   .L078		;;  rem background with no animation or doublebuffering
    776  4151
    777  4151				   ._screen2_init
    778  4151							;; _screen2_init
    779  4151
    780  4151				   .L079		;;  bg  =  1
    781  4151
    782  4151		       a9 01		      LDA	#1
    783  4153		       8d 41 01 	      STA	bg
    784  4156				   .L080		;;  db  =  0
    785  4156
    786  4156		       a9 00		      LDA	#0
    787  4158		       8d 42 01 	      STA	db
    788  415b				   .L081		;;  an  =  0
    789  415b
    790  415b		       a9 00		      LDA	#0
    791  415d		       8d 43 01 	      STA	an
    792  4160				   .L082		;;  w	=  0
    793  4160
    794  4160		       a9 00		      LDA	#0
    795  4162		       85 fc		      STA	w
    796  4164				   .L083		;;  gosub _screen_setup
    797  4164
    798  4164		       20 c9 42 	      jsr	._screen_setup
    799  4167
    800  4167				   ._screen2_loop
    801  4167							;; _screen2_loop
    802  4167
    803  4167				   .L084		;;  gosub _screen
    804  4167
    805  4167		       20 fb 42 	      jsr	._screen
    806  416a
    807  416a				   .L085		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen3_init
    808  416a
    809  416a		       a9 08		      LDA	#8
    810  416c		       c5 fc		      CMP	w
    811  416e		       b0 0c		      BCS	.skipL085
    812  4170				   .condpart2
    813  4170		       2c 02 21 	      bit	sINPT1
    814  4173		       10 07		      BPL	.skip2then
    815  4175				   .condpart3
    816  4175		       a9 00		      LDA	#0
    817  4177		       85 fc		      STA	w
    818  4179		       4c 86 41 	      jmp	._screen3_init
    819  417c
    820  417c				   .skip2then
    821  417c				   .skipL085
    822  417c				   .L086		;;  w	=  w  +  1
    823  417c
    824  417c		       a5 fc		      LDA	w
    825  417e		       18		      CLC
    826  417f		       69 01		      ADC	#1
    827  4181		       85 fc		      STA	w
    828  4183				   .L087		;;  goto _screen2_loop
    829  4183
    830  4183		       4c 67 41 	      jmp	._screen2_loop
    831  4186
    832  4186				   .
    833  4186							;; 
    834  4186
    835  4186				   .L088		;;  rem no background with no animation or doublebuffering
    836  4186
    837  4186				   ._screen3_init
    838  4186							;; _screen3_init
    839  4186
    840  4186				   .L089		;;  bg  =  0
    841  4186
    842  4186		       a9 00		      LDA	#0
    843  4188		       8d 41 01 	      STA	bg
    844  418b				   .L090		;;  db  =  0
    845  418b
    846  418b		       a9 00		      LDA	#0
    847  418d		       8d 42 01 	      STA	db
    848  4190				   .L091		;;  an  =  0
    849  4190
    850  4190		       a9 00		      LDA	#0
    851  4192		       8d 43 01 	      STA	an
    852  4195				   .L092		;;  w	=  0
    853  4195
    854  4195		       a9 00		      LDA	#0
    855  4197		       85 fc		      STA	w
    856  4199				   .L093		;;  gosub _screen_setup
    857  4199
    858  4199		       20 c9 42 	      jsr	._screen_setup
    859  419c
    860  419c				   ._screen3_loop
    861  419c							;; _screen3_loop
    862  419c
    863  419c				   .L094		;;  gosub _screen
    864  419c
    865  419c		       20 fb 42 	      jsr	._screen
    866  419f
    867  419f				   .L095		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen4_init
    868  419f
    869  419f		       a9 08		      LDA	#8
    870  41a1		       c5 fc		      CMP	w
    871  41a3		       b0 0c		      BCS	.skipL095
    872  41a5				   .condpart4
    873  41a5		       2c 02 21 	      bit	sINPT1
    874  41a8		       10 07		      BPL	.skip4then
    875  41aa				   .condpart5
    876  41aa		       a9 00		      LDA	#0
    877  41ac		       85 fc		      STA	w
    878  41ae		       4c bb 41 	      jmp	._screen4_init
    879  41b1
    880  41b1				   .skip4then
    881  41b1				   .skipL095
    882  41b1				   .L096		;;  w	=  w  +  1
    883  41b1
    884  41b1		       a5 fc		      LDA	w
    885  41b3		       18		      CLC
    886  41b4		       69 01		      ADC	#1
    887  41b6		       85 fc		      STA	w
    888  41b8				   .L097		;;  goto _screen3_loop
    889  41b8
    890  41b8		       4c 9c 41 	      jmp	._screen3_loop
    891  41bb
    892  41bb				   .
    893  41bb							;; 
    894  41bb
    895  41bb				   .L098		;;  rem no background with  animation and no doublebuffering
    896  41bb
    897  41bb				   ._screen4_init
    898  41bb							;; _screen4_init
    899  41bb
    900  41bb				   .L099		;;  bg  =  0
    901  41bb
    902  41bb		       a9 00		      LDA	#0
    903  41bd		       8d 41 01 	      STA	bg
    904  41c0				   .L0100		;;  db  =  0
    905  41c0
    906  41c0		       a9 00		      LDA	#0
    907  41c2		       8d 42 01 	      STA	db
    908  41c5				   .L0101		;;  an  =  1
    909  41c5
    910  41c5		       a9 01		      LDA	#1
    911  41c7		       8d 43 01 	      STA	an
    912  41ca				   .L0102		;;  w	=  0
    913  41ca
    914  41ca		       a9 00		      LDA	#0
    915  41cc		       85 fc		      STA	w
    916  41ce				   .L0103		;;  gosub _screen_setup
    917  41ce
    918  41ce		       20 c9 42 	      jsr	._screen_setup
    919  41d1
    920  41d1				   ._screen4_loop
    921  41d1							;; _screen4_loop
    922  41d1
    923  41d1				   .L0104		;;  gosub _screen
    924  41d1
    925  41d1		       20 fb 42 	      jsr	._screen
    926  41d4
    927  41d4				   .L0105		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen5_init
    928  41d4
    929  41d4		       a9 08		      LDA	#8
    930  41d6		       c5 fc		      CMP	w
    931  41d8		       b0 0c		      BCS	.skipL0105
    932  41da				   .condpart6
    933  41da		       2c 02 21 	      bit	sINPT1
    934  41dd		       10 07		      BPL	.skip6then
    935  41df				   .condpart7
    936  41df		       a9 00		      LDA	#0
    937  41e1		       85 fc		      STA	w
    938  41e3		       4c f0 41 	      jmp	._screen5_init
    939  41e6
    940  41e6				   .skip6then
    941  41e6				   .skipL0105
    942  41e6				   .L0106		;;  w	=  w  +  1
    943  41e6
    944  41e6		       a5 fc		      LDA	w
    945  41e8		       18		      CLC
    946  41e9		       69 01		      ADC	#1
    947  41eb		       85 fc		      STA	w
    948  41ed				   .L0107		;;  goto _screen4_loop
    949  41ed
    950  41ed		       4c d1 41 	      jmp	._screen4_loop
    951  41f0
    952  41f0				   .
    953  41f0							;; 
    954  41f0
    955  41f0				   .L0108		;;  rem with background with animation and no doublebuffering
    956  41f0
    957  41f0				   ._screen5_init
    958  41f0							;; _screen5_init
    959  41f0
    960  41f0				   .L0109		;;  bg  =  1
    961  41f0
    962  41f0		       a9 01		      LDA	#1
    963  41f2		       8d 41 01 	      STA	bg
    964  41f5				   .L0110		;;  db  =  0
    965  41f5
    966  41f5		       a9 00		      LDA	#0
    967  41f7		       8d 42 01 	      STA	db
    968  41fa				   .L0111		;;  an  =  1
    969  41fa
    970  41fa		       a9 01		      LDA	#1
    971  41fc		       8d 43 01 	      STA	an
    972  41ff				   .L0112		;;  w	=  0
    973  41ff
    974  41ff		       a9 00		      LDA	#0
    975  4201		       85 fc		      STA	w
    976  4203				   .L0113		;;  gosub _screen_setup
    977  4203
    978  4203		       20 c9 42 	      jsr	._screen_setup
    979  4206
    980  4206				   ._screen5_loop
    981  4206							;; _screen5_loop
    982  4206
    983  4206				   .L0114		;;  gosub _screen
    984  4206
    985  4206		       20 fb 42 	      jsr	._screen
    986  4209
    987  4209				   .L0115		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen6_init
    988  4209
    989  4209		       a9 08		      LDA	#8
    990  420b		       c5 fc		      CMP	w
    991  420d		       b0 0c		      BCS	.skipL0115
    992  420f				   .condpart8
    993  420f		       2c 02 21 	      bit	sINPT1
    994  4212		       10 07		      BPL	.skip8then
    995  4214				   .condpart9
    996  4214		       a9 00		      LDA	#0
    997  4216		       85 fc		      STA	w
    998  4218		       4c 25 42 	      jmp	._screen6_init
    999  421b
   1000  421b				   .skip8then
   1001  421b				   .skipL0115
   1002  421b				   .L0116		;;  w	=  w  +  1
   1003  421b
   1004  421b		       a5 fc		      LDA	w
   1005  421d		       18		      CLC
   1006  421e		       69 01		      ADC	#1
   1007  4220		       85 fc		      STA	w
   1008  4222				   .L0117		;;  goto _screen5_loop
   1009  4222
   1010  4222		       4c 06 42 	      jmp	._screen5_loop
   1011  4225
   1012  4225				   .
   1013  4225							;; 
   1014  4225
   1015  4225				   .L0118		;;  rem with no background with animation and with doublebuffering
   1016  4225
   1017  4225				   ._screen6_init
   1018  4225							;; _screen6_init
   1019  4225
   1020  4225				   .L0119		;;  bg  =  0
   1021  4225
   1022  4225		       a9 00		      LDA	#0
   1023  4227		       8d 41 01 	      STA	bg
   1024  422a				   .L0120		;;  db  =  1
   1025  422a
   1026  422a		       a9 01		      LDA	#1
   1027  422c		       8d 42 01 	      STA	db
   1028  422f				   .L0121		;;  an  =  1
   1029  422f
   1030  422f		       a9 01		      LDA	#1
   1031  4231		       8d 43 01 	      STA	an
   1032  4234				   .L0122		;;  w	=  0
   1033  4234
   1034  4234		       a9 00		      LDA	#0
   1035  4236		       85 fc		      STA	w
   1036  4238				   .L0123		;;  gosub _screen_setup
   1037  4238
   1038  4238		       20 c9 42 	      jsr	._screen_setup
   1039  423b
   1040  423b				   ._screen6_loop
   1041  423b							;; _screen6_loop
   1042  423b
   1043  423b				   .L0124		;;  gosub _screen
   1044  423b
   1045  423b		       20 fb 42 	      jsr	._screen
   1046  423e
   1047  423e				   .L0125		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen7_init
   1048  423e
   1049  423e		       a9 08		      LDA	#8
   1050  4240		       c5 fc		      CMP	w
   1051  4242		       b0 0c		      BCS	.skipL0125
   1052  4244				   .condpart10
   1053  4244		       2c 02 21 	      bit	sINPT1
   1054  4247		       10 07		      BPL	.skip10then
   1055  4249				   .condpart11
   1056  4249		       a9 00		      LDA	#0
   1057  424b		       85 fc		      STA	w
   1058  424d		       4c 5a 42 	      jmp	._screen7_init
   1059  4250
   1060  4250				   .skip10then
   1061  4250				   .skipL0125
   1062  4250				   .L0126		;;  w	=  w  +  1
   1063  4250
   1064  4250		       a5 fc		      LDA	w
   1065  4252		       18		      CLC
   1066  4253		       69 01		      ADC	#1
   1067  4255		       85 fc		      STA	w
   1068  4257				   .L0127		;;  goto _screen6_loop
   1069  4257
   1070  4257		       4c 3b 42 	      jmp	._screen6_loop
   1071  425a
   1072  425a				   .
   1073  425a							;; 
   1074  425a
   1075  425a				   .L0128		;;  rem with background with animation and with doublebuffering
   1076  425a
   1077  425a				   ._screen7_init
   1078  425a							;; _screen7_init
   1079  425a
   1080  425a				   .L0129		;;  bg  =  1
   1081  425a
   1082  425a		       a9 01		      LDA	#1
   1083  425c		       8d 41 01 	      STA	bg
   1084  425f				   .L0130		;;  db  =  1
   1085  425f
   1086  425f		       a9 01		      LDA	#1
   1087  4261		       8d 42 01 	      STA	db
   1088  4264				   .L0131		;;  an  =  1
   1089  4264
   1090  4264		       a9 01		      LDA	#1
   1091  4266		       8d 43 01 	      STA	an
   1092  4269				   .L0132		;;  w	=  0
   1093  4269
   1094  4269		       a9 00		      LDA	#0
   1095  426b		       85 fc		      STA	w
   1096  426d				   .L0133		;;  gosub _screen_setup
   1097  426d
   1098  426d		       20 c9 42 	      jsr	._screen_setup
   1099  4270
   1100  4270				   ._screen7_loop
   1101  4270							;; _screen7_loop
   1102  4270
   1103  4270				   .L0134		;;  gosub _screen
   1104  4270
   1105  4270		       20 fb 42 	      jsr	._screen
   1106  4273
   1107  4273				   .L0135		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen8_init
   1108  4273
   1109  4273		       a9 08		      LDA	#8
   1110  4275		       c5 fc		      CMP	w
   1111  4277		       b0 0c		      BCS	.skipL0135
   1112  4279				   .condpart12
   1113  4279		       2c 02 21 	      bit	sINPT1
   1114  427c		       10 07		      BPL	.skip12then
   1115  427e				   .condpart13
   1116  427e		       a9 00		      LDA	#0
   1117  4280		       85 fc		      STA	w
   1118  4282		       4c 8f 42 	      jmp	._screen8_init
   1119  4285
   1120  4285				   .skip12then
   1121  4285				   .skipL0135
   1122  4285				   .L0136		;;  w	=  w  +  1
   1123  4285
   1124  4285		       a5 fc		      LDA	w
   1125  4287		       18		      CLC
   1126  4288		       69 01		      ADC	#1
   1127  428a		       85 fc		      STA	w
   1128  428c				   .L0137		;;  goto _screen7_loop
   1129  428c
   1130  428c		       4c 70 42 	      jmp	._screen7_loop
   1131  428f
   1132  428f				   .
   1133  428f							;; 
   1134  428f
   1135  428f				   ._screen8_init
   1136  428f							;; _screen8_init
   1137  428f
   1138  428f				   .L0138		;;  bg  =  1
   1139  428f
   1140  428f		       a9 01		      LDA	#1
   1141  4291		       8d 41 01 	      STA	bg
   1142  4294				   .L0139		;;  db  =  1
   1143  4294
   1144  4294		       a9 01		      LDA	#1
   1145  4296		       8d 42 01 	      STA	db
   1146  4299				   .L0140		;;  an  =  1
   1147  4299
   1148  4299		       a9 01		      LDA	#1
   1149  429b		       8d 43 01 	      STA	an
   1150  429e				   .L0141		;;  ex  =  1
   1151  429e
   1152  429e		       a9 01		      LDA	#1
   1153  42a0		       8d 44 01 	      STA	ex
   1154  42a3				   .L0142		;;  w	=  0
   1155  42a3
   1156  42a3		       a9 00		      LDA	#0
   1157  42a5		       85 fc		      STA	w
   1158  42a7				   .L0143		;;  gosub _screen_setup
   1159  42a7
   1160  42a7		       20 c9 42 	      jsr	._screen_setup
   1161  42aa
   1162  42aa				   ._screen8_loop
   1163  42aa							;; _screen8_loop
   1164  42aa
   1165  42aa				   .L0144		;;  gosub _screen
   1166  42aa
   1167  42aa		       20 fb 42 	      jsr	._screen
   1168  42ad
   1169  42ad				   .L0145		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen2_init
   1170  42ad
   1171  42ad		       a9 08		      LDA	#8
   1172  42af		       c5 fc		      CMP	w
   1173  42b1		       b0 0c		      BCS	.skipL0145
   1174  42b3				   .condpart14
   1175  42b3		       2c 02 21 	      bit	sINPT1
   1176  42b6		       10 07		      BPL	.skip14then
   1177  42b8				   .condpart15
   1178  42b8		       a9 00		      LDA	#0
   1179  42ba		       85 fc		      STA	w
   1180  42bc		       4c 51 41 	      jmp	._screen2_init
   1181  42bf
   1182  42bf				   .skip14then
   1183  42bf				   .skipL0145
   1184  42bf				   .L0146		;;  w	=  w  +  1
   1185  42bf
   1186  42bf		       a5 fc		      LDA	w
   1187  42c1		       18		      CLC
   1188  42c2		       69 01		      ADC	#1
   1189  42c4		       85 fc		      STA	w
   1190  42c6				   .L0147		;;  goto _screen8_loop
   1191  42c6
   1192  42c6		       4c aa 42 	      jmp	._screen8_loop
   1193  42c9
   1194  42c9				   .
   1195  42c9							;; 
   1196  42c9
   1197  42c9				   .L0148		;;  rem set-up screen vars
   1198  42c9
   1199  42c9				   ._screen_setup
   1200  42c9							;; _screen_setup
   1201  42c9
   1202  42c9				   .L0149		;;  clearscreen
   1203  42c9
   1204  42c9		       20 77 f0 	      jsr	clearscreen
   1205  42cc				   .L0150		;;  if db then doublebuffer on
   1206  42cc
   1207  42cc		       ad 42 01 	      LDA	db
   1208  42cf		       f0 04		      BEQ	.skipL0150
   1209  42d1				   .condpart16
   1210  42d1		       a9 01		      lda	#1
   1211  42d3		       85 d5		      sta	doublebufferstate
   1212  42d5				   .skipL0150
   1213  42d5				   .L0151		;;  if !db then doublebuffer off
   1214  42d5
   1215  42d5		       ad 42 01 	      LDA	db
   1216  42d8		       d0 03		      BNE	.skipL0151
   1217  42da				   .condpart17
   1218  42da		       20 13 f6 	      jsr	doublebufferoff
   1219  42dd				   .skipL0151
   1220  42dd				   .L0152		;;  if bg then gosub drawZoneBG
   1221  42dd
   1222  42dd		       ad 41 01 	      LDA	bg
   1223  42e0		       f0 03		      BEQ	.skipL0152
   1224  42e2				   .condpart18
   1225  42e2		       20 ec 45 	      jsr	.drawZoneBG
   1226  42e5
   1227  42e5				   .skipL0152
   1228  42e5				   .L0153		;;  m	=  0
   1229  42e5
   1230  42e5		       a9 00		      LDA	#0
   1231  42e7		       85 f2		      STA	m
   1232  42e9				   .L0154		;;  n	=  0
   1233  42e9
   1234  42e9		       a9 00		      LDA	#0
   1235  42eb		       85 f3		      STA	n
   1236  42ed				   .L0155		;;  c	=  0
   1237  42ed
   1238  42ed		       a9 00		      LDA	#0
   1239  42ef		       85 e8		      STA	c
   1240  42f1				   .L0156		;;  f	=  0
   1241  42f1
   1242  42f1		       a9 00		      LDA	#0
   1243  42f3		       85 eb		      STA	f
   1244  42f5				   .L0157		;;  wrap  =  0
   1245  42f5
   1246  42f5		       a9 00		      LDA	#0
   1247  42f7		       8d 45 01 	      STA	wrap
   1248  42fa				   .L0158		;;  return
   1249  42fa
   1250  42fa		       60		      RTS
   1251  42fb				   .
   1252  42fb							;; 
   1253  42fb
   1254  42fb				   .L0159		;;  rem draw screen
   1255  42fb
   1256  42fb				   ._screen
   1257  42fb							;; _screen
   1258  42fb
   1259  42fb				   .L0160		;;  if bg then restorescreen
   1260  42fb
   1261  42fb		       ad 41 01 	      LDA	bg
   1262  42fe		       f0 03		      BEQ	.skipL0160
   1263  4300				   .condpart19
   1264  4300		       20 89 f0 	      jsr	restorescreen
   1265  4303				   .skipL0160
   1266  4303				   .L0161		;;  if !bg then clearscreen
   1267  4303
   1268  4303		       ad 41 01 	      LDA	bg
   1269  4306		       d0 03		      BNE	.skipL0161
   1270  4308				   .condpart20
   1271  4308		       20 77 f0 	      jsr	clearscreen
   1272  430b				   .skipL0161
   1273  430b				   .L0162		;;  y	=  0
   1274  430b
   1275  430b		       a9 00		      LDA	#0
   1276  430d		       85 fe		      STA	y
   1277  430f				   .L0163		;;  x	=  0
   1278  430f
   1279  430f		       a9 00		      LDA	#0
   1280  4311		       85 fd		      STA	x
   1281  4313				   .L0164		;;  c	=  0
   1282  4313
   1283  4313		       a9 00		      LDA	#0
   1284  4315		       85 e8		      STA	c
   1285  4317				   .L0165		;;  for i  =  0 to n
   1286  4317
   1287  4317		       a9 00		      LDA	#0
   1288  4319		       85 ee		      STA	i
   1289  431b				   .L0165fori
   1290  431b				   .L0166		;;  for j  =  0 to m
   1291  431b
   1292  431b		       a9 00		      LDA	#0
   1293  431d		       85 ef		      STA	j
   1294  431f				   .L0166forj
   1295  431f				   .L0167		;;  if ex  =  1  &&  wrap  =  0 then plotsprite ex1 c x y f
   1296  431f
   1297  431f		       ad 44 01 	      LDA	ex
   1298  4322		       c9 01		      CMP	#1
   1299  4324		       d0 33		      BNE	.skipL0167
   1300  4326				   .condpart21
   1301  4326		       ad 45 01 	      LDA	wrap
   1302  4329		       c9 00		      CMP	#0
   1303  432b		       d0 2c		      BNE	.skip21then
   1304  432d				   .condpart22
   1305  432d		       a9 34		      lda	#<ex1
   1306  432f		       a0 04		      ldy	#ex1_width
   1307  4331		       18		      clc
   1308  4332		       f0 05		      beq	plotspritewidthskip3
   1309  4334				   plotspritewidthloop3
   1310  4334		       65 eb		      adc	f
   1311  4336		       88		      dey
   1312  4337		       d0 fb		      bne	plotspritewidthloop3
   1313  4339				   plotspritewidthskip3
   1314  4339		       85 42		      sta	temp1
   1315  433b
   1316  433b		       a9 e0		      lda	#>ex1
   1317  433d		       85 43		      sta	temp2
   1318  433f
   1319  433f		       a5 e8		      lda	c
   1320  4341		       0a		      asl
   1321  4342		       0a		      asl
   1322  4343		       0a		      asl
   1323  4344		       0a		      asl
   1324  4345		       0a		      asl
   1325  4346		       09 1c		      ora	#ex1_width_twoscompliment
   1326  4348		       85 44		      sta	temp3
   1327  434a
   1328  434a		       a5 fd		      lda	x
   1329  434c		       85 45		      sta	temp4
   1330  434e
   1331  434e		       a5 fe		      lda	y
   1332  4350		       85 46		      sta	temp5
   1333  4352
   1334  4352		       a9 40		      lda	#(ex1_mode|%01000000)
   1335  4354		       85 47		      sta	temp6
   1336  4356
   1337  4356		       20 9d f2 	      jsr	plotsprite
   1338  4359				   .skip21then
   1339  4359				   .skipL0167
   1340  4359				   .L0168		;;  if ex  =  0  &&  wrap  =  0 then plotsprite g16x16_4color c x y f
   1341  4359
   1342  4359		       ad 44 01 	      LDA	ex
   1343  435c		       c9 00		      CMP	#0
   1344  435e		       d0 33		      BNE	.skipL0168
   1345  4360				   .condpart23
   1346  4360		       ad 45 01 	      LDA	wrap
   1347  4363		       c9 00		      CMP	#0
   1348  4365		       d0 2c		      BNE	.skip23then
   1349  4367				   .condpart24
   1350  4367		       a9 00		      lda	#<g16x16_4color
   1351  4369		       a0 04		      ldy	#g16x16_4color_width
   1352  436b		       18		      clc
   1353  436c		       f0 05		      beq	plotspritewidthskip4
   1354  436e				   plotspritewidthloop4
   1355  436e		       65 eb		      adc	f
   1356  4370		       88		      dey
   1357  4371		       d0 fb		      bne	plotspritewidthloop4
   1358  4373				   plotspritewidthskip4
   1359  4373		       85 42		      sta	temp1
   1360  4375
   1361  4375		       a9 e0		      lda	#>g16x16_4color
   1362  4377		       85 43		      sta	temp2
   1363  4379
   1364  4379		       a5 e8		      lda	c
   1365  437b		       0a		      asl
   1366  437c		       0a		      asl
   1367  437d		       0a		      asl
   1368  437e		       0a		      asl
   1369  437f		       0a		      asl
   1370  4380		       09 1c		      ora	#g16x16_4color_width_twoscompliment
   1371  4382		       85 44		      sta	temp3
   1372  4384
   1373  4384		       a5 fd		      lda	x
   1374  4386		       85 45		      sta	temp4
   1375  4388
   1376  4388		       a5 fe		      lda	y
   1377  438a		       85 46		      sta	temp5
   1378  438c
   1379  438c		       a9 40		      lda	#(g16x16_4color_mode|%01000000)
   1380  438e		       85 47		      sta	temp6
   1381  4390
   1382  4390		       20 9d f2 	      jsr	plotsprite
   1383  4393				   .skip23then
   1384  4393				   .skipL0168
   1385  4393				   .L0169		;;  if wrap  =  1 then plotsprite p1 7 x y 0
   1386  4393
   1387  4393		       ad 45 01 	      LDA	wrap
   1388  4396		       c9 01		      CMP	#1
   1389  4398		       d0 1b		      BNE	.skipL0169
   1390  439a				   .condpart25
   1391  439a		       a9 50		      lda	#<p1
   1392  439c		       85 42		      sta	temp1
   1393  439e
   1394  439e		       a9 e0		      lda	#>p1
   1395  43a0		       85 43		      sta	temp2
   1396  43a2
   1397  43a2		       a9 fe		      lda	#(224|p1_width_twoscompliment)
   1398  43a4		       85 44		      sta	temp3
   1399  43a6
   1400  43a6		       a5 fd		      lda	x
   1401  43a8		       85 45		      sta	temp4
   1402  43aa
   1403  43aa		       a5 fe		      lda	y
   1404  43ac		       85 46		      sta	temp5
   1405  43ae
   1406  43ae		       a9 40		      lda	#(p1_mode|%01000000)
   1407  43b0		       85 47		      sta	temp6
   1408  43b2
   1409  43b2		       20 9d f2 	      jsr	plotsprite
   1410  43b5				   .skipL0169
   1411  43b5				   .L0170		;;  x	=  x  +  16
   1412  43b5
   1413  43b5		       a5 fd		      LDA	x
   1414  43b7		       18		      CLC
   1415  43b8		       69 10		      ADC	#16
   1416  43ba		       85 fd		      STA	x
   1417  43bc				   .L0171		;;  if x  >  144 then x  =  0	:  wrap  =  1
   1418  43bc
   1419  43bc		       a9 90		      LDA	#144
   1420  43be		       c5 fd		      CMP	x
   1421  43c0		       b0 09		      BCS	.skipL0171
   1422  43c2				   .condpart26
   1423  43c2		       a9 00		      LDA	#0
   1424  43c4		       85 fd		      STA	x
   1425  43c6		       a9 01		      LDA	#1
   1426  43c8		       8d 45 01 	      STA	wrap
   1427  43cb				   .skipL0171
   1428  43cb				   .L0172		;;  next
   1429  43cb
   1430  43cb		       a5 ef		      LDA	j
   1431  43cd		       c5 f2		      CMP	m
   1432  43cf		       e6 ef		      INC	j
   1433  43d1				  -	      if	((* - .L0166forj) < 127) && ((* - .L0166forj) > -128)
   1434  43d1				  -	      bcc	.L0166forj
   1435  43d1					      else
   1436  43d1		       b0 03		      bcs	.0skipL0166forj
   1437  43d3		       4c 1f 43 	      jmp	.L0166forj
   1438  43d6				   .0skipL0166forj
   1439  43d6					      endif
   1440  43d6				   .L0173		;;  wrap  =  0
   1441  43d6
   1442  43d6		       a9 00		      LDA	#0
   1443  43d8		       8d 45 01 	      STA	wrap
   1444  43db				   .L0174		;;  x	=  0
   1445  43db
   1446  43db		       a9 00		      LDA	#0
   1447  43dd		       85 fd		      STA	x
   1448  43df				   .L0175		;;  y	=  y  +  16
   1449  43df
   1450  43df		       a5 fe		      LDA	y
   1451  43e1		       18		      CLC
   1452  43e2		       69 10		      ADC	#16
   1453  43e4		       85 fe		      STA	y
   1454  43e6				   .L0176		;;  c	=  c  +  1
   1455  43e6
   1456  43e6		       a5 e8		      LDA	c
   1457  43e8		       18		      CLC
   1458  43e9		       69 01		      ADC	#1
   1459  43eb		       85 e8		      STA	c
   1460  43ed				   .L0177		;;  if c  >  6 then c	=  0
   1461  43ed
   1462  43ed		       a9 06		      LDA	#6
   1463  43ef		       c5 e8		      CMP	c
   1464  43f1		       b0 04		      BCS	.skipL0177
   1465  43f3				   .condpart27
   1466  43f3		       a9 00		      LDA	#0
   1467  43f5		       85 e8		      STA	c
   1468  43f7				   .skipL0177
   1469  43f7				   .L0178		;;  next
   1470  43f7
   1471  43f7		       a5 ee		      LDA	i
   1472  43f9		       c5 f3		      CMP	n
   1473  43fb		       e6 ee		      INC	i
   1474  43fd				  -	      if	((* - .L0165fori) < 127) && ((* - .L0165fori) > -128)
   1475  43fd				  -	      bcc	.L0165fori
   1476  43fd					      else
   1477  43fd		       b0 03		      bcs	.1skipL0165fori
   1478  43ff		       4c 1b 43 	      jmp	.L0165fori
   1479  4402				   .1skipL0165fori
   1480  4402					      endif
   1481  4402				   .L0179		;;  if w  >  8  &&  joy0right then w  = 0  :  m  =  m	+  1
   1482  4402
   1483  4402		       a9 08		      LDA	#8
   1484  4404		       c5 fc		      CMP	w
   1485  4406		       b0 10		      BCS	.skipL0179
   1486  4408				   .condpart28
   1487  4408		       2c 80 02 	      bit	SWCHA
   1488  440b		       30 0b		      BMI	.skip28then
   1489  440d				   .condpart29
   1490  440d		       a9 00		      LDA	#0
   1491  440f		       85 fc		      STA	w
   1492  4411		       a5 f2		      LDA	m
   1493  4413		       18		      CLC
   1494  4414		       69 01		      ADC	#1
   1495  4416		       85 f2		      STA	m
   1496  4418				   .skip28then
   1497  4418				   .skipL0179
   1498  4418				   .L0180		;;  if w  >  8  &&  joy0down then w  =  0  :  n  =  n	+  1
   1499  4418
   1500  4418		       a9 08		      LDA	#8
   1501  441a		       c5 fc		      CMP	w
   1502  441c		       b0 12		      BCS	.skipL0180
   1503  441e				   .condpart30
   1504  441e		       a9 20		      lda	#$20
   1505  4420		       2c 80 02 	      bit	SWCHA
   1506  4423		       d0 0b		      BNE	.skip30then
   1507  4425				   .condpart31
   1508  4425		       a9 00		      LDA	#0
   1509  4427		       85 fc		      STA	w
   1510  4429		       a5 f3		      LDA	n
   1511  442b		       18		      CLC
   1512  442c		       69 01		      ADC	#1
   1513  442e		       85 f3		      STA	n
   1514  4430				   .skip30then
   1515  4430				   .skipL0180
   1516  4430				   .L0181		;;  if w  >  8  &&  joy0left then w  = 0  :  m  =  m  -  1
   1517  4430
   1518  4430		       a9 08		      LDA	#8
   1519  4432		       c5 fc		      CMP	w
   1520  4434		       b0 10		      BCS	.skipL0181
   1521  4436				   .condpart32
   1522  4436		       2c 80 02 	      bit	SWCHA
   1523  4439		       70 0b		      BVS	.skip32then
   1524  443b				   .condpart33
   1525  443b		       a9 00		      LDA	#0
   1526  443d		       85 fc		      STA	w
   1527  443f		       a5 f2		      LDA	m
   1528  4441		       38		      SEC
   1529  4442		       e9 01		      SBC	#1
   1530  4444		       85 f2		      STA	m
   1531  4446				   .skip32then
   1532  4446				   .skipL0181
   1533  4446				   .L0182		;;  if w  >  8  &&  joy0up then w  =  0  :  n	=  n  -  1
   1534  4446
   1535  4446		       a9 08		      LDA	#8
   1536  4448		       c5 fc		      CMP	w
   1537  444a		       b0 12		      BCS	.skipL0182
   1538  444c				   .condpart34
   1539  444c		       a9 10		      lda	#$10
   1540  444e		       2c 80 02 	      bit	SWCHA
   1541  4451		       d0 0b		      BNE	.skip34then
   1542  4453				   .condpart35
   1543  4453		       a9 00		      LDA	#0
   1544  4455		       85 fc		      STA	w
   1545  4457		       a5 f3		      LDA	n
   1546  4459		       38		      SEC
   1547  445a		       e9 01		      SBC	#1
   1548  445c		       85 f3		      STA	n
   1549  445e				   .skip34then
   1550  445e				   .skipL0182
   1551  445e				   .L0183		;;  if n  >  24 then n  =  0
   1552  445e
   1553  445e		       a9 18		      LDA	#24
   1554  4460		       c5 f3		      CMP	n
   1555  4462		       b0 04		      BCS	.skipL0183
   1556  4464				   .condpart36
   1557  4464		       a9 00		      LDA	#0
   1558  4466		       85 f3		      STA	n
   1559  4468				   .skipL0183
   1560  4468				   .L0184		;;  if m  >  40 then m  =  0
   1561  4468
   1562  4468		       a9 28		      LDA	#40
   1563  446a		       c5 f2		      CMP	m
   1564  446c		       b0 04		      BCS	.skipL0184
   1565  446e				   .condpart37
   1566  446e		       a9 00		      LDA	#0
   1567  4470		       85 f2		      STA	m
   1568  4472				   .skipL0184
   1569  4472				   .L0185		;;  if an  =  1 then f  =  f  +  1
   1570  4472
   1571  4472		       ad 43 01 	      LDA	an
   1572  4475		       c9 01		      CMP	#1
   1573  4477		       d0 07		      BNE	.skipL0185
   1574  4479				   .condpart38
   1575  4479		       a5 eb		      LDA	f
   1576  447b		       18		      CLC
   1577  447c		       69 01		      ADC	#1
   1578  447e		       85 eb		      STA	f
   1579  4480				   .skipL0185
   1580  4480				   .L0186		;;  if an  =  1  &&  f  >  7 then f  =  0
   1581  4480
   1582  4480		       ad 43 01 	      LDA	an
   1583  4483		       c9 01		      CMP	#1
   1584  4485		       d0 0a		      BNE	.skipL0186
   1585  4487				   .condpart39
   1586  4487		       a9 07		      LDA	#7
   1587  4489		       c5 eb		      CMP	f
   1588  448b		       b0 04		      BCS	.skip39then
   1589  448d				   .condpart40
   1590  448d		       a9 00		      LDA	#0
   1591  448f		       85 eb		      STA	f
   1592  4491				   .skip39then
   1593  4491				   .skipL0186
   1594  4491				   .
   1595  4491							;; 
   1596  4491
   1597  4491				   .L0187		;;  rem plotchars 'joystick to draw fire to next' 7 10 23 1
   1598  4491
   1599  4491				   .L0188		;;  r	=  n  +  1
   1600  4491
   1601  4491		       a5 f3		      LDA	n
   1602  4493		       18		      CLC
   1603  4494		       69 01		      ADC	#1
   1604  4496		       85 f7		      STA	r
   1605  4498				   .L0189		;;  s	=  m  +  1
   1606  4498
   1607  4498		       a5 f2		      LDA	m
   1608  449a		       18		      CLC
   1609  449b		       69 01		      ADC	#1
   1610  449d		       85 f8		      STA	s
   1611  449f				   .
   1612  449f							;; 
   1613  449f
   1614  449f				   .L0190		;;  plotvalue font 4 s 2 8 11
   1615  449f
   1616  449f		       a9 56		      lda	#<font
   1617  44a1		       85 42		      sta	temp1
   1618  44a3
   1619  44a3		       a9 e0		      lda	#>font
   1620  44a5		       85 43		      sta	temp2
   1621  44a7
   1622  44a7		       ad 06 21 	      lda	charactermode
   1623  44aa		       85 4a		      sta	temp9
   1624  44ac		       a9 60		      lda	#(font_mode | %01100000)
   1625  44ae		       8d 06 21 	      sta	charactermode
   1626  44b1		       a9 1e		      lda	#30	; width in two's complement
   1627  44b3		       09 80		      ora	#128	; palette left shifted 5 bits
   1628  44b5		       85 44		      sta	temp3
   1629  44b7		       a9 08		      lda	#8
   1630  44b9		       85 45		      sta	temp4
   1631  44bb
   1632  44bb		       a9 0b		      lda	#11
   1633  44bd		       85 46		      sta	temp5
   1634  44bf
   1635  44bf		       a9 02		      lda	#2
   1636  44c1		       85 47		      sta	temp6
   1637  44c3
   1638  44c3		       a9 f8		      lda	#<s
   1639  44c5		       85 48		      sta	temp7
   1640  44c7
   1641  44c7		       a9 00		      lda	#>s
   1642  44c9		       85 49		      sta	temp8
   1643  44cb
   1644  44cb		       20 d1 f3 	      jsr	plotvalue
   1645  44cb		       00 01	   USED_PLOTVALUE =	1
   1646  44ce		       a5 4a		      lda	temp9
   1647  44d0		       8d 06 21 	      sta	charactermode
   1648  44d3				   .L0191		;;  plotvalue font 4 r 2 24 11
   1649  44d3
   1650  44d3		       a9 56		      lda	#<font
   1651  44d5		       85 42		      sta	temp1
   1652  44d7
   1653  44d7		       a9 e0		      lda	#>font
   1654  44d9		       85 43		      sta	temp2
   1655  44db
   1656  44db		       ad 06 21 	      lda	charactermode
   1657  44de		       85 4a		      sta	temp9
   1658  44e0		       a9 60		      lda	#(font_mode | %01100000)
   1659  44e2		       8d 06 21 	      sta	charactermode
   1660  44e5		       a9 1e		      lda	#30	; width in two's complement
   1661  44e7		       09 80		      ora	#128	; palette left shifted 5 bits
   1662  44e9		       85 44		      sta	temp3
   1663  44eb		       a9 18		      lda	#24
   1664  44ed		       85 45		      sta	temp4
   1665  44ef
   1666  44ef		       a9 0b		      lda	#11
   1667  44f1		       85 46		      sta	temp5
   1668  44f3
   1669  44f3		       a9 02		      lda	#2
   1670  44f5		       85 47		      sta	temp6
   1671  44f7
   1672  44f7		       a9 f7		      lda	#<r
   1673  44f9		       85 48		      sta	temp7
   1674  44fb
   1675  44fb		       a9 00		      lda	#>r
   1676  44fd		       85 49		      sta	temp8
   1677  44ff
   1678  44ff		       20 d1 f3 	      jsr	plotvalue
   1679  44ff		       00 01	   USED_PLOTVALUE =	1
   1680  4502		       a5 4a		      lda	temp9
   1681  4504		       8d 06 21 	      sta	charactermode
   1682  4507				   .L0192		;;  plotvalue font 4 z 2 40 11
   1683  4507
   1684  4507		       a9 56		      lda	#<font
   1685  4509		       85 42		      sta	temp1
   1686  450b
   1687  450b		       a9 e0		      lda	#>font
   1688  450d		       85 43		      sta	temp2
   1689  450f
   1690  450f		       ad 06 21 	      lda	charactermode
   1691  4512		       85 4a		      sta	temp9
   1692  4514		       a9 60		      lda	#(font_mode | %01100000)
   1693  4516		       8d 06 21 	      sta	charactermode
   1694  4519		       a9 1e		      lda	#30	; width in two's complement
   1695  451b		       09 80		      ora	#128	; palette left shifted 5 bits
   1696  451d		       85 44		      sta	temp3
   1697  451f		       a9 28		      lda	#40
   1698  4521		       85 45		      sta	temp4
   1699  4523
   1700  4523		       a9 0b		      lda	#11
   1701  4525		       85 46		      sta	temp5
   1702  4527
   1703  4527		       a9 02		      lda	#2
   1704  4529		       85 47		      sta	temp6
   1705  452b
   1706  452b		       a9 ff		      lda	#<z
   1707  452d		       85 48		      sta	temp7
   1708  452f
   1709  452f		       a9 00		      lda	#>z
   1710  4531		       85 49		      sta	temp8
   1711  4533
   1712  4533		       20 d1 f3 	      jsr	plotvalue
   1713  4533		       00 01	   USED_PLOTVALUE =	1
   1714  4536		       a5 4a		      lda	temp9
   1715  4538		       8d 06 21 	      sta	charactermode
   1716  453b				   .L0193		;;  plotvalue font 4 bg 2 56 11
   1717  453b
   1718  453b		       a9 56		      lda	#<font
   1719  453d		       85 42		      sta	temp1
   1720  453f
   1721  453f		       a9 e0		      lda	#>font
   1722  4541		       85 43		      sta	temp2
   1723  4543
   1724  4543		       ad 06 21 	      lda	charactermode
   1725  4546		       85 4a		      sta	temp9
   1726  4548		       a9 60		      lda	#(font_mode | %01100000)
   1727  454a		       8d 06 21 	      sta	charactermode
   1728  454d		       a9 1e		      lda	#30	; width in two's complement
   1729  454f		       09 80		      ora	#128	; palette left shifted 5 bits
   1730  4551		       85 44		      sta	temp3
   1731  4553		       a9 38		      lda	#56
   1732  4555		       85 45		      sta	temp4
   1733  4557
   1734  4557		       a9 0b		      lda	#11
   1735  4559		       85 46		      sta	temp5
   1736  455b
   1737  455b		       a9 02		      lda	#2
   1738  455d		       85 47		      sta	temp6
   1739  455f
   1740  455f		       a9 41		      lda	#<bg
   1741  4561		       85 48		      sta	temp7
   1742  4563
   1743  4563		       a9 01		      lda	#>bg
   1744  4565		       85 49		      sta	temp8
   1745  4567
   1746  4567		       20 d1 f3 	      jsr	plotvalue
   1747  4567		       00 01	   USED_PLOTVALUE =	1
   1748  456a		       a5 4a		      lda	temp9
   1749  456c		       8d 06 21 	      sta	charactermode
   1750  456f				   .L0194		;;  plotvalue font 4 an 2 72 11
   1751  456f
   1752  456f		       a9 56		      lda	#<font
   1753  4571		       85 42		      sta	temp1
   1754  4573
   1755  4573		       a9 e0		      lda	#>font
   1756  4575		       85 43		      sta	temp2
   1757  4577
   1758  4577		       ad 06 21 	      lda	charactermode
   1759  457a		       85 4a		      sta	temp9
   1760  457c		       a9 60		      lda	#(font_mode | %01100000)
   1761  457e		       8d 06 21 	      sta	charactermode
   1762  4581		       a9 1e		      lda	#30	; width in two's complement
   1763  4583		       09 80		      ora	#128	; palette left shifted 5 bits
   1764  4585		       85 44		      sta	temp3
   1765  4587		       a9 48		      lda	#72
   1766  4589		       85 45		      sta	temp4
   1767  458b
   1768  458b		       a9 0b		      lda	#11
   1769  458d		       85 46		      sta	temp5
   1770  458f
   1771  458f		       a9 02		      lda	#2
   1772  4591		       85 47		      sta	temp6
   1773  4593
   1774  4593		       a9 43		      lda	#<an
   1775  4595		       85 48		      sta	temp7
   1776  4597
   1777  4597		       a9 01		      lda	#>an
   1778  4599		       85 49		      sta	temp8
   1779  459b
   1780  459b		       20 d1 f3 	      jsr	plotvalue
   1781  459b		       00 01	   USED_PLOTVALUE =	1
   1782  459e		       a5 4a		      lda	temp9
   1783  45a0		       8d 06 21 	      sta	charactermode
   1784  45a3				   .L0195		;;  plotvalue font 4 db 2 88 11
   1785  45a3
   1786  45a3		       a9 56		      lda	#<font
   1787  45a5		       85 42		      sta	temp1
   1788  45a7
   1789  45a7		       a9 e0		      lda	#>font
   1790  45a9		       85 43		      sta	temp2
   1791  45ab
   1792  45ab		       ad 06 21 	      lda	charactermode
   1793  45ae		       85 4a		      sta	temp9
   1794  45b0		       a9 60		      lda	#(font_mode | %01100000)
   1795  45b2		       8d 06 21 	      sta	charactermode
   1796  45b5		       a9 1e		      lda	#30	; width in two's complement
   1797  45b7		       09 80		      ora	#128	; palette left shifted 5 bits
   1798  45b9		       85 44		      sta	temp3
   1799  45bb		       a9 58		      lda	#88
   1800  45bd		       85 45		      sta	temp4
   1801  45bf
   1802  45bf		       a9 0b		      lda	#11
   1803  45c1		       85 46		      sta	temp5
   1804  45c3
   1805  45c3		       a9 02		      lda	#2
   1806  45c5		       85 47		      sta	temp6
   1807  45c7
   1808  45c7		       a9 42		      lda	#<db
   1809  45c9		       85 48		      sta	temp7
   1810  45cb
   1811  45cb		       a9 01		      lda	#>db
   1812  45cd		       85 49		      sta	temp8
   1813  45cf
   1814  45cf		       20 d1 f3 	      jsr	plotvalue
   1815  45cf		       00 01	   USED_PLOTVALUE =	1
   1816  45d2		       a5 4a		      lda	temp9
   1817  45d4		       8d 06 21 	      sta	charactermode
   1818  45d7				   .
   1819  45d7							;; 
   1820  45d7
   1821  45d7				   .L0196		;;  if db then doublebuffer flip
   1822  45d7
   1823  45d7		       ad 42 01 	      LDA	db
   1824  45da		       f0 03		      BEQ	.skipL0196
   1825  45dc				   .condpart41
   1826  45dc		       20 a0 f5 	      jsr	flipdisplaybuffer
   1827  45df				   .skipL0196
   1828  45df				   .L0197		;;  if !db then drawscreen
   1829  45df
   1830  45df		       ad 42 01 	      LDA	db
   1831  45e2		       d0 03		      BNE	.skipL0197
   1832  45e4				   .condpart42
   1833  45e4		       20 b3 f0 	      jsr	drawscreen
   1834  45e7				   .skipL0197
   1835  45e7				   .L0198		;;  z	=  0
   1836  45e7
   1837  45e7		       a9 00		      LDA	#0
   1838  45e9		       85 ff		      STA	z
   1839  45eb				   .L0199		;;  return
   1840  45eb
   1841  45eb		       60		      RTS
   1842  45ec				   .
   1843  45ec							;; 
   1844  45ec
   1845  45ec				   .L0200		;;  rem draw sprites with arrow no bg
   1846  45ec
   1847  45ec				   .
   1848  45ec							;; 
   1849  45ec
   1850  45ec				   .
   1851  45ec							;; 
   1852  45ec
   1853  45ec				   .
   1854  45ec							;; 
   1855  45ec
   1856  45ec				   .
   1857  45ec							;; 
   1858  45ec
   1859  45ec				   .
   1860  45ec							;; 
   1861  45ec
   1862  45ec				   .
   1863  45ec							;; 
   1864  45ec
   1865  45ec				   .
   1866  45ec							;; 
   1867  45ec
   1868  45ec				   .
   1869  45ec							;; 
   1870  45ec
   1871  45ec				   .
   1872  45ec							;; 
   1873  45ec
   1874  45ec				   .
   1875  45ec							;; 
   1876  45ec
   1877  45ec				   .
   1878  45ec							;; 
   1879  45ec
   1880  45ec				   .
   1881  45ec							;; 
   1882  45ec
   1883  45ec				   .
   1884  45ec							;; 
   1885  45ec
   1886  45ec				   .
   1887  45ec							;; 
   1888  45ec
   1889  45ec				   .
   1890  45ec							;; 
   1891  45ec
   1892  45ec				   .
   1893  45ec							;; 
   1894  45ec
   1895  45ec				   .
   1896  45ec							;; 
   1897  45ec
   1898  45ec				   .
   1899  45ec							;; 
   1900  45ec
   1901  45ec				   .
   1902  45ec							;; 
   1903  45ec
   1904  45ec				   .
   1905  45ec							;; 
   1906  45ec
   1907  45ec				   .
   1908  45ec							;; 
   1909  45ec
   1910  45ec				   .
   1911  45ec							;; 
   1912  45ec
   1913  45ec				   .
   1914  45ec							;; 
   1915  45ec
   1916  45ec				   .
   1917  45ec							;; 
   1918  45ec
   1919  45ec				   .
   1920  45ec							;; 
   1921  45ec
   1922  45ec				   .
   1923  45ec							;; 
   1924  45ec
   1925  45ec				   .
   1926  45ec							;; 
   1927  45ec
   1928  45ec				   .
   1929  45ec							;; 
   1930  45ec
   1931  45ec				   .
   1932  45ec							;; 
   1933  45ec
   1934  45ec				   .
   1935  45ec							;; 
   1936  45ec
   1937  45ec				   .
   1938  45ec							;; 
   1939  45ec
   1940  45ec				   .
   1941  45ec							;; 
   1942  45ec
   1943  45ec				   .
   1944  45ec							;; 
   1945  45ec
   1946  45ec				   .
   1947  45ec							;; 
   1948  45ec
   1949  45ec				   .
   1950  45ec							;; 
   1951  45ec
   1952  45ec				   .
   1953  45ec							;; 
   1954  45ec
   1955  45ec				   .
   1956  45ec							;; 
   1957  45ec
   1958  45ec				   .
   1959  45ec							;; 
   1960  45ec
   1961  45ec				   .
   1962  45ec							;; 
   1963  45ec
   1964  45ec				   .
   1965  45ec							;; 
   1966  45ec
   1967  45ec				   .
   1968  45ec							;; 
   1969  45ec
   1970  45ec				   .
   1971  45ec							;; 
   1972  45ec
   1973  45ec				   .
   1974  45ec							;; 
   1975  45ec
   1976  45ec				   .
   1977  45ec							;; 
   1978  45ec
   1979  45ec				   .
   1980  45ec							;; 
   1981  45ec
   1982  45ec				   .
   1983  45ec							;; 
   1984  45ec
   1985  45ec				   .
   1986  45ec							;; 
   1987  45ec
   1988  45ec				   .
   1989  45ec							;; 
   1990  45ec
   1991  45ec				   .
   1992  45ec							;; 
   1993  45ec
   1994  45ec				   .
   1995  45ec							;; 
   1996  45ec
   1997  45ec				   .
   1998  45ec							;; 
   1999  45ec
   2000  45ec				   .
   2001  45ec							;; 
   2002  45ec
   2003  45ec				   .
   2004  45ec							;; 
   2005  45ec
   2006  45ec				   .
   2007  45ec							;; 
   2008  45ec
   2009  45ec				   .
   2010  45ec							;; 
   2011  45ec
   2012  45ec				   .
   2013  45ec							;; 
   2014  45ec
   2015  45ec				   .
   2016  45ec							;; 
   2017  45ec
   2018  45ec				   .
   2019  45ec							;; 
   2020  45ec
   2021  45ec				   .
   2022  45ec							;; 
   2023  45ec
   2024  45ec				   .
   2025  45ec							;; 
   2026  45ec
   2027  45ec				   .
   2028  45ec							;; 
   2029  45ec
   2030  45ec				   .
   2031  45ec							;; 
   2032  45ec
   2033  45ec				   .
   2034  45ec							;; 
   2035  45ec
   2036  45ec				   .
   2037  45ec							;; 
   2038  45ec
   2039  45ec				   .
   2040  45ec							;; 
   2041  45ec
   2042  45ec				   .
   2043  45ec							;; 
   2044  45ec
   2045  45ec				   .
   2046  45ec							;; 
   2047  45ec
   2048  45ec				   .
   2049  45ec							;; 
   2050  45ec
   2051  45ec				   .
   2052  45ec							;; 
   2053  45ec
   2054  45ec				   .
   2055  45ec							;; 
   2056  45ec
   2057  45ec				   .
   2058  45ec							;; 
   2059  45ec
   2060  45ec				   .
   2061  45ec							;; 
   2062  45ec
   2063  45ec				   .
   2064  45ec							;; 
   2065  45ec
   2066  45ec				   .
   2067  45ec							;; 
   2068  45ec
   2069  45ec				   .
   2070  45ec							;; 
   2071  45ec
   2072  45ec				   .
   2073  45ec							;; 
   2074  45ec
   2075  45ec				   .
   2076  45ec							;; 
   2077  45ec
   2078  45ec				   .drawZoneBG
   2079  45ec							;; drawZoneBG
   2080  45ec
   2081  45ec				   .L0201		;;  x	=  0
   2082  45ec
   2083  45ec		       a9 00		      LDA	#0
   2084  45ee		       85 fd		      STA	x
   2085  45f0				   .L0202		;;  y	=  0
   2086  45f0
   2087  45f0		       a9 00		      LDA	#0
   2088  45f2		       85 fe		      STA	y
   2089  45f4				   .L0203		;;  for j  =  0 to 10
   2090  45f4
   2091  45f4		       a9 00		      LDA	#0
   2092  45f6		       85 ef		      STA	j
   2093  45f8				   .L0203forj
   2094  45f8				   .L0204		;;  for i  =  0 to 1
   2095  45f8
   2096  45f8		       a9 00		      LDA	#0
   2097  45fa		       85 ee		      STA	i
   2098  45fc				   .L0204fori
   2099  45fc				   .L0205		;;  plotsprite zonebg80x16_16 7 x y 0
   2100  45fc
   2101  45fc		       a9 20		      lda	#<zonebg80x16_16
   2102  45fe		       85 42		      sta	temp1
   2103  4600
   2104  4600		       a9 e0		      lda	#>zonebg80x16_16
   2105  4602		       85 43		      sta	temp2
   2106  4604
   2107  4604		       a9 ec		      lda	#(224|zonebg80x16_16_width_twoscompliment)
   2108  4606		       85 44		      sta	temp3
   2109  4608
   2110  4608		       a5 fd		      lda	x
   2111  460a		       85 45		      sta	temp4
   2112  460c
   2113  460c		       a5 fe		      lda	y
   2114  460e		       85 46		      sta	temp5
   2115  4610
   2116  4610		       a9 40		      lda	#(zonebg80x16_16_mode|%01000000)
   2117  4612		       85 47		      sta	temp6
   2118  4614
   2119  4614		       20 9d f2 	      jsr	plotsprite
   2120  4617				   .L0206		;;  x	=  x  +  80
   2121  4617
   2122  4617		       a5 fd		      LDA	x
   2123  4619		       18		      CLC
   2124  461a		       69 50		      ADC	#80
   2125  461c		       85 fd		      STA	x
   2126  461e				   .L0207		;;  next
   2127  461e
   2128  461e		       a5 ee		      LDA	i
   2129  4620		       c9 01		      CMP	#1
   2130  4622		       e6 ee		      INC	i
   2131  4624					      if	((* - .L0204fori) < 127) && ((* - .L0204fori) > -128)
   2132  4624		       90 d6		      bcc	.L0204fori
   2133  4626				  -	      else
   2134  4626				  -	      bcs	.2skipL0204fori
   2135  4626				  -	      jmp	.L0204fori
   2136  4626				  -.2skipL0204fori
   2137  4626					      endif
   2138  4626				   .L0208		;;  x	=  0
   2139  4626
   2140  4626		       a9 00		      LDA	#0
   2141  4628		       85 fd		      STA	x
   2142  462a				   .L0209		;;  y	=  y  +  16
   2143  462a
   2144  462a		       a5 fe		      LDA	y
   2145  462c		       18		      CLC
   2146  462d		       69 10		      ADC	#16
   2147  462f		       85 fe		      STA	y
   2148  4631				   .L0210		;;  next
   2149  4631
   2150  4631		       a5 ef		      LDA	j
   2151  4633		       c9 0a		      CMP	#10
   2152  4635		       e6 ef		      INC	j
   2153  4637					      if	((* - .L0203forj) < 127) && ((* - .L0203forj) > -128)
   2154  4637		       90 bf		      bcc	.L0203forj
   2155  4639				  -	      else
   2156  4639				  -	      bcs	.3skipL0203forj
   2157  4639				  -	      jmp	.L0203forj
   2158  4639				  -.3skipL0203forj
   2159  4639					      endif
   2160  4639				   .L0211		;;  savescreen
   2161  4639
   2162  4639		       20 9b f0 	      jsr	savescreen
   2163  463c				   .L0212		;;  return
   2164  463c
   2165  463c		       60		      RTS
   2166  463d				   .
   2167  463d							;; 
   2168  463d
   2169  463d				   .topscreenroutine
   2170  463d							;; topscreenroutine
   2171  463d
   2172  463d				   .L0213		;;  z	=  z  +  1
   2173  463d
   2174  463d		       a5 ff		      LDA	z
   2175  463f		       18		      CLC
   2176  4640		       69 01		      ADC	#1
   2177  4642		       85 ff		      STA	z
   2178  4644				   .L0214		;;  return
   2179  4644		       60		      RTS
   2180  4644				   DMAHOLEEND0 SET	.
   2181  4645				   gameend
   2182  4645				   DMAHOLEEND0 SET	.
   39355 bytes of ROM space left in the main area.
   2183  4645					      echo	" ",[($E000 - gameend)]d , "bytes of ROM space left in the main area."
   2184  4645
   2185  e000					      ORG	$E000,0	; *************
   2186  e000
   2187  e000				   g16x16_4color
   2188  e000		       aa aa aa aa	      HEX	aaaaaaaa
   2189  e004				   g16x16_4color2
   2190  e004		       aa aa aa aa	      HEX	aaaaaaaa
   2191  e008				   g16x16_4color3
   2192  e008		       ff ff ff ff	      HEX	ffffffff
   2193  e00c				   g16x16_4color4
   2194  e00c		       ff ff ff ff	      HEX	ffffffff
   2195  e010				   g16x16_4color5
   2196  e010		       55 55 55 55	      HEX	55555555
   2197  e014				   g16x16_4color6
   2198  e014		       55 55 55 55	      HEX	55555555
   2199  e018				   g16x16_4color7
   2200  e018		       55 55 55 55	      HEX	55555555
   2201  e01c				   g16x16_4color8
   2202  e01c		       00 00 00 00	      HEX	00000000
   2203  e020				   zonebg80x16_16
   2204  e020		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2205  e034				   ex1
   2206  e034		       00 00 00 00	      HEX	00000000
   2207  e038				   ex2
   2208  e038		       00 00 00 00	      HEX	00000000
   2209  e03c				   ex3
   2210  e03c		       00 00 00 00	      HEX	00000000
   2211  e040				   ex4
   2212  e040		       00 41 50 00	      HEX	00415000
   2213  e044				   ex5
   2214  e044		       31 41 51 00	      HEX	31415100
   2215  e048				   ex6
   2216  e048		       00 15 15 00	      HEX	00151500
   2217  e04c				   ex7
   2218  e04c		       01 50 55 40	      HEX	01505540
   2219  e050				   p1
   2220  e050		       00 00		      HEX	0000
   2221  e052				   blank
   2222  e052		       00 00 00 00	      HEX	00000000
   2223  e056				   font
   2224  e056		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2225  e076		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2226  e08b
   2227  e100					      ORG	$E100,0	; *************
   2228  e100
   2229  e100							;g16x16_4color
   2230  e100		       aa aa aa aa	      HEX	aaaaaaaa
   2231  e104							;g16x16_4color2
   2232  e104		       ff ff ff ff	      HEX	ffffffff
   2233  e108							;g16x16_4color3
   2234  e108		       ff ff ff ff	      HEX	ffffffff
   2235  e10c							;g16x16_4color4
   2236  e10c		       55 55 55 55	      HEX	55555555
   2237  e110							;g16x16_4color5
   2238  e110		       55 55 55 55	      HEX	55555555
   2239  e114							;g16x16_4color6
   2240  e114		       00 00 00 00	      HEX	00000000
   2241  e118							;g16x16_4color7
   2242  e118		       55 55 55 55	      HEX	55555555
   2243  e11c							;g16x16_4color8
   2244  e11c		       aa aa aa aa	      HEX	aaaaaaaa
   2245  e120							;zonebg80x16_16
   2246  e120		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2247  e134							;ex1
   2248  e134		       00 00 00 00	      HEX	00000000
   2249  e138							;ex2
   2250  e138		       00 03 00 30	      HEX	00030030
   2251  e13c							;ex3
   2252  e13c		       30 15 40 0c	      HEX	3015400c
   2253  e140							;ex4
   2254  e140		       00 51 25 90	      HEX	00512590
   2255  e144							;ex5
   2256  e144		       01 55 35 53	      HEX	01553553
   2257  e148							;ex6
   2258  e148		       05 65 56 40	      HEX	05655640
   2259  e14c							;ex7
   2260  e14c		       04 00 00 00	      HEX	04000000
   2261  e150							;p1
   2262  e150		       00 00		      HEX	0000
   2263  e152							;blank
   2264  e152		       00 00 00 00	      HEX	00000000
   2265  e156							;font
   2266  e156		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2267  e176		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2268  e18b
   2269  e200					      ORG	$E200,0	; *************
   2270  e200
   2271  e200							;g16x16_4color
   2272  e200		       ff ff ff ff	      HEX	ffffffff
   2273  e204							;g16x16_4color2
   2274  e204		       ff ff ff ff	      HEX	ffffffff
   2275  e208							;g16x16_4color3
   2276  e208		       55 55 55 55	      HEX	55555555
   2277  e20c							;g16x16_4color4
   2278  e20c		       55 55 55 55	      HEX	55555555
   2279  e210							;g16x16_4color5
   2280  e210		       00 00 00 00	      HEX	00000000
   2281  e214							;g16x16_4color6
   2282  e214		       00 00 00 00	      HEX	00000000
   2283  e218							;g16x16_4color7
   2284  e218		       ff ff ff ff	      HEX	ffffffff
   2285  e21c							;g16x16_4color8
   2286  e21c		       aa aa aa aa	      HEX	aaaaaaaa
   2287  e220							;zonebg80x16_16
   2288  e220		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2289  e234							;ex1
   2290  e234		       00 30 00 00	      HEX	00300000
   2291  e238							;ex2
   2292  e238		       0c 14 14 00	      HEX	0c141400
   2293  e23c							;ex3
   2294  e23c		       00 2b 91 00	      HEX	002b9100
   2295  e240							;ex4
   2296  e240		       05 aa 3a 60	      HEX	05aa3a60
   2297  e244							;ex5
   2298  e244		       15 9a a9 10	      HEX	159aa910
   2299  e248							;ex6
   2300  e248		       11 40 14 54	      HEX	11401454
   2301  e24c							;ex7
   2302  e24c		       10 00 00 04	      HEX	10000004
   2303  e250							;p1
   2304  e250		       00 00		      HEX	0000
   2305  e252							;blank
   2306  e252		       00 00 00 00	      HEX	00000000
   2307  e256							;font
   2308  e256		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2309  e276		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2310  e28b
   2311  e300					      ORG	$E300,0	; *************
   2312  e300
   2313  e300							;g16x16_4color
   2314  e300		       ff ff ff ff	      HEX	ffffffff
   2315  e304							;g16x16_4color2
   2316  e304		       55 55 55 55	      HEX	55555555
   2317  e308							;g16x16_4color3
   2318  e308		       55 55 55 55	      HEX	55555555
   2319  e30c							;g16x16_4color4
   2320  e30c		       00 00 00 00	      HEX	00000000
   2321  e310							;g16x16_4color5
   2322  e310		       00 00 00 00	      HEX	00000000
   2323  e314							;g16x16_4color6
   2324  e314		       aa aa aa aa	      HEX	aaaaaaaa
   2325  e318							;g16x16_4color7
   2326  e318		       ff ff ff ff	      HEX	ffffffff
   2327  e31c							;g16x16_4color8
   2328  e31c		       ff ff ff ff	      HEX	ffffffff
   2329  e320							;zonebg80x16_16
   2330  e320		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2331  e334							;ex1
   2332  e334		       00 01 43 00	      HEX	00014300
   2333  e338							;ex2
   2334  e338		       00 29 69 00	      HEX	00296900
   2335  e33c							;ex3
   2336  e33c		       01 85 a2 40	      HEX	0185a240
   2337  e340							;ex4
   2338  e340		       19 12 a4 94	      HEX	1912a494
   2339  e344							;ex5
   2340  e344		       52 79 1a d4	      HEX	52791ad4
   2341  e348							;ex6
   2342  e348		       15 00 00 10	      HEX	15000010
   2343  e34c							;ex7
   2344  e34c		       00 00 00 01	      HEX	00000001
   2345  e350							;p1
   2346  e350		       00 00		      HEX	0000
   2347  e352							;blank
   2348  e352		       00 00 00 00	      HEX	00000000
   2349  e356							;font
   2350  e356		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2351  e376		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2352  e38b
   2353  e400					      ORG	$E400,0	; *************
   2354  e400
   2355  e400							;g16x16_4color
   2356  e400		       55 55 55 55	      HEX	55555555
   2357  e404							;g16x16_4color2
   2358  e404		       55 55 55 55	      HEX	55555555
   2359  e408							;g16x16_4color3
   2360  e408		       00 00 00 00	      HEX	00000000
   2361  e40c							;g16x16_4color4
   2362  e40c		       00 00 00 00	      HEX	00000000
   2363  e410							;g16x16_4color5
   2364  e410		       aa aa aa aa	      HEX	aaaaaaaa
   2365  e414							;g16x16_4color6
   2366  e414		       aa aa aa aa	      HEX	aaaaaaaa
   2367  e418							;g16x16_4color7
   2368  e418		       aa aa aa aa	      HEX	aaaaaaaa
   2369  e41c							;g16x16_4color8
   2370  e41c		       ff ff ff ff	      HEX	ffffffff
   2371  e420							;zonebg80x16_16
   2372  e420		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2373  e434							;ex1
   2374  e434		       00 01 80 00	      HEX	00018000
   2375  e438							;ex2
   2376  e438		       01 95 8a 03	      HEX	01958a03
   2377  e43c							;ex3
   2378  e43c		       04 6a 98 90	      HEX	046a9890
   2379  e440							;ex4
   2380  e440		       62 eb 4a 89	      HEX	62eb4a89
   2381  e444							;ex5
   2382  e444		       5a 94 04 a5	      HEX	5a9404a5
   2383  e448							;ex6
   2384  e448		       54 00 00 16	      HEX	54000016
   2385  e44c							;ex7
   2386  e44c		       40 00 00 01	      HEX	40000001
   2387  e450							;p1
   2388  e450		       00 00		      HEX	0000
   2389  e452							;blank
   2390  e452		       00 00 00 00	      HEX	00000000
   2391  e456							;font
   2392  e456		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2393  e476		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2394  e48b
   2395  e500					      ORG	$E500,0	; *************
   2396  e500
   2397  e500							;g16x16_4color
   2398  e500		       55 55 55 55	      HEX	55555555
   2399  e504							;g16x16_4color2
   2400  e504		       00 00 00 00	      HEX	00000000
   2401  e508							;g16x16_4color3
   2402  e508		       00 00 00 00	      HEX	00000000
   2403  e50c							;g16x16_4color4
   2404  e50c		       aa aa aa aa	      HEX	aaaaaaaa
   2405  e510							;g16x16_4color5
   2406  e510		       aa aa aa aa	      HEX	aaaaaaaa
   2407  e514							;g16x16_4color6
   2408  e514		       ff ff ff ff	      HEX	ffffffff
   2409  e518							;g16x16_4color7
   2410  e518		       aa aa aa aa	      HEX	aaaaaaaa
   2411  e51c							;g16x16_4color8
   2412  e51c		       55 55 55 55	      HEX	55555555
   2413  e520							;zonebg80x16_16
   2414  e520		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2415  e534							;ex1
   2416  e534		       00 da 24 00	      HEX	00da2400
   2417  e538							;ex2
   2418  e538		       06 46 6e 40	      HEX	06466e40
   2419  e53c							;ex3
   2420  e53c		       1a 88 69 e4	      HEX	1a8869e4
   2421  e540							;ex4
   2422  e540		       52 44 1a 6c	      HEX	52441a6c
   2423  e544							;ex5
   2424  e544		       ca 00 00 49	      HEX	ca000049
   2425  e548							;ex6
   2426  e548		       60 00 00 05	      HEX	60000005
   2427  e54c							;ex7
   2428  e54c		       40 00 00 01	      HEX	40000001
   2429  e550							;p1
   2430  e550		       00 00		      HEX	0000
   2431  e552							;blank
   2432  e552		       00 00 00 00	      HEX	00000000
   2433  e556							;font
   2434  e556		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2435  e576		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2436  e58b
   2437  e600					      ORG	$E600,0	; *************
   2438  e600
   2439  e600							;g16x16_4color
   2440  e600		       00 00 00 00	      HEX	00000000
   2441  e604							;g16x16_4color2
   2442  e604		       00 00 00 00	      HEX	00000000
   2443  e608							;g16x16_4color3
   2444  e608		       aa aa aa aa	      HEX	aaaaaaaa
   2445  e60c							;g16x16_4color4
   2446  e60c		       aa aa aa aa	      HEX	aaaaaaaa
   2447  e610							;g16x16_4color5
   2448  e610		       ff ff ff ff	      HEX	ffffffff
   2449  e614							;g16x16_4color6
   2450  e614		       ff ff ff ff	      HEX	ffffffff
   2451  e618							;g16x16_4color7
   2452  e618		       55 55 55 55	      HEX	55555555
   2453  e61c							;g16x16_4color8
   2454  e61c		       55 55 55 55	      HEX	55555555
   2455  e620							;zonebg80x16_16
   2456  e620		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2457  e634							;ex1
   2458  e634		       00 05 b9 00	      HEX	0005b900
   2459  e638							;ex2
   2460  e638		       c5 ae a1 90	      HEX	c5aea190
   2461  e63c							;ex3
   2462  e63c		       07 67 18 90	      HEX	07671890
   2463  e640							;ex4
   2464  e640		       6a 90 07 64	      HEX	6a900764
   2465  e644							;ex5
   2466  e644		       58 40 00 69	      HEX	58400069
   2467  e648							;ex6
   2468  e648		       50 00 00 04	      HEX	50000004
   2469  e64c							;ex7
   2470  e64c		       40 00 00 00	      HEX	40000000
   2471  e650							;p1
   2472  e650		       00 00		      HEX	0000
   2473  e652							;blank
   2474  e652		       00 00 00 00	      HEX	00000000
   2475  e656							;font
   2476  e656		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2477  e676		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2478  e68b
   2479  e700					      ORG	$E700,0	; *************
   2480  e700
   2481  e700							;g16x16_4color
   2482  e700		       00 00 00 00	      HEX	00000000
   2483  e704							;g16x16_4color2
   2484  e704		       aa aa aa aa	      HEX	aaaaaaaa
   2485  e708							;g16x16_4color3
   2486  e708		       aa aa aa aa	      HEX	aaaaaaaa
   2487  e70c							;g16x16_4color4
   2488  e70c		       ff ff ff ff	      HEX	ffffffff
   2489  e710							;g16x16_4color5
   2490  e710		       ff ff ff ff	      HEX	ffffffff
   2491  e714							;g16x16_4color6
   2492  e714		       55 55 55 55	      HEX	55555555
   2493  e718							;g16x16_4color7
   2494  e718		       55 55 55 55	      HEX	55555555
   2495  e71c							;g16x16_4color8
   2496  e71c		       00 00 00 00	      HEX	00000000
   2497  e720							;zonebg80x16_16
   2498  e720		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2499  e734							;ex1
   2500  e734		       00 63 44 00	      HEX	00634400
   2501  e738							;ex2
   2502  e738		       06 28 91 40	      HEX	06289140
   2503  e73c							;ex3
   2504  e73c		       18 a0 ca 10	      HEX	18a0ca10
   2505  e740							;ex4
   2506  e740		       1d 80 02 05	      HEX	1d800205
   2507  e744							;ex5
   2508  e744		       12 00 00 63	      HEX	12000063
   2509  e748							;ex6
   2510  e748		       14 00 00 01	      HEX	14000001
   2511  e74c							;ex7
   2512  e74c		       00 00 00 01	      HEX	00000001
   2513  e750							;p1
   2514  e750		       00 00		      HEX	0000
   2515  e752							;blank
   2516  e752		       00 00 00 00	      HEX	00000000
   2517  e756							;font
   2518  e756		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2519  e776		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2520  e78b
   2521  e800					      ORG	$E800,0	; *************
   2522  e800
   2523  e800							;g16x16_4color
   2524  e800		       aa aa aa aa	      HEX	aaaaaaaa
   2525  e804							;g16x16_4color2
   2526  e804		       aa aa aa aa	      HEX	aaaaaaaa
   2527  e808							;g16x16_4color3
   2528  e808		       ff ff ff ff	      HEX	ffffffff
   2529  e80c							;g16x16_4color4
   2530  e80c		       ff ff ff ff	      HEX	ffffffff
   2531  e810							;g16x16_4color5
   2532  e810		       55 55 55 55	      HEX	55555555
   2533  e814							;g16x16_4color6
   2534  e814		       55 55 55 55	      HEX	55555555
   2535  e818							;g16x16_4color7
   2536  e818		       00 00 00 00	      HEX	00000000
   2537  e81c							;g16x16_4color8
   2538  e81c		       00 00 00 00	      HEX	00000000
   2539  e820							;zonebg80x16_16
   2540  e820		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2541  e834							;ex1
   2542  e834		       00 66 b9 00	      HEX	0066b900
   2543  e838							;ex2
   2544  e838		       01 6a f9 80	      HEX	016af980
   2545  e83c							;ex3
   2546  e83c		       c5 ac 16 c4	      HEX	c5ac16c4
   2547  e840							;ex4
   2548  e840		       16 90 04 64	      HEX	16900464
   2549  e844							;ex5
   2550  e844		       5e 00 00 34	      HEX	5e000034
   2551  e848							;ex6
   2552  e848		       14 00 00 01	      HEX	14000001
   2553  e84c							;ex7
   2554  e84c		       40 00 00 00	      HEX	40000000
   2555  e850							;p1
   2556  e850		       56 00		      HEX	5600
   2557  e852							;blank
   2558  e852		       00 00 00 00	      HEX	00000000
   2559  e856							;font
   2560  e856		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2561  e876		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   2562  e88b
   2563  e900					      ORG	$E900,0	; *************
   2564  e900
   2565  e900							;g16x16_4color
   2566  e900		       aa aa aa aa	      HEX	aaaaaaaa
   2567  e904							;g16x16_4color2
   2568  e904		       ff ff ff ff	      HEX	ffffffff
   2569  e908							;g16x16_4color3
   2570  e908		       ff ff ff ff	      HEX	ffffffff
   2571  e90c							;g16x16_4color4
   2572  e90c		       55 55 55 55	      HEX	55555555
   2573  e910							;g16x16_4color5
   2574  e910		       55 55 55 55	      HEX	55555555
   2575  e914							;g16x16_4color6
   2576  e914		       00 00 00 00	      HEX	00000000
   2577  e918							;g16x16_4color7
   2578  e918		       00 00 00 00	      HEX	00000000
   2579  e91c							;g16x16_4color8
   2580  e91c		       aa aa aa aa	      HEX	aaaaaaaa
   2581  e920							;zonebg80x16_16
   2582  e920		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2583  e934							;ex1
   2584  e934		       03 19 24 00	      HEX	03192400
   2585  e938							;ex2
   2586  e938		       06 7b 69 10	      HEX	067b6910
   2587  e93c							;ex3
   2588  e93c		       04 99 6a 64	      HEX	04996a64
   2589  e940							;ex4
   2590  e940		       62 74 06 64	      HEX	62740664
   2591  e944							;ex5
   2592  e944		       19 40 00 65	      HEX	19400065
   2593  e948							;ex6
   2594  e948		       50 00 00 01	      HEX	50000001
   2595  e94c							;ex7
   2596  e94c		       40 00 00 01	      HEX	40000001
   2597  e950							;p1
   2598  e950		       14 00		      HEX	1400
   2599  e952							;blank
   2600  e952		       00 00 00 00	      HEX	00000000
   2601  e956							;font
   2602  e956		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   2603  e976		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   2604  e98b
   2605  ea00					      ORG	$EA00,0	; *************
   2606  ea00
   2607  ea00							;g16x16_4color
   2608  ea00		       ff ff ff ff	      HEX	ffffffff
   2609  ea04							;g16x16_4color2
   2610  ea04		       ff ff ff ff	      HEX	ffffffff
   2611  ea08							;g16x16_4color3
   2612  ea08		       55 55 55 55	      HEX	55555555
   2613  ea0c							;g16x16_4color4
   2614  ea0c		       55 55 55 55	      HEX	55555555
   2615  ea10							;g16x16_4color5
   2616  ea10		       00 00 00 00	      HEX	00000000
   2617  ea14							;g16x16_4color6
   2618  ea14		       00 00 00 00	      HEX	00000000
   2619  ea18							;g16x16_4color7
   2620  ea18		       ff ff ff ff	      HEX	ffffffff
   2621  ea1c							;g16x16_4color8
   2622  ea1c		       aa aa aa aa	      HEX	aaaaaaaa
   2623  ea20							;zonebg80x16_16
   2624  ea20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2625  ea34							;ex1
   2626  ea34		       00 05 90 c0	      HEX	000590c0
   2627  ea38							;ex2
   2628  ea38		       05 96 2e 90	      HEX	05962e90
   2629  ea3c							;ex3
   2630  ea3c		       1b 8a 98 50	      HEX	1b8a9850
   2631  ea40							;ex4
   2632  ea40		       66 69 1e a5	      HEX	66691ea5
   2633  ea44							;ex5
   2634  ea44		       5a 50 00 61	      HEX	5a500061
   2635  ea48							;ex6
   2636  ea48		       54 00 00 05	      HEX	54000005
   2637  ea4c							;ex7
   2638  ea4c		       00 00 00 01	      HEX	00000001
   2639  ea50							;p1
   2640  ea50		       15 80		      HEX	1580
   2641  ea52							;blank
   2642  ea52		       00 00 00 00	      HEX	00000000
   2643  ea56							;font
   2644  ea56		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   2645  ea76		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   2646  ea8b
   2647  eb00					      ORG	$EB00,0	; *************
   2648  eb00
   2649  eb00							;g16x16_4color
   2650  eb00		       ff ff ff ff	      HEX	ffffffff
   2651  eb04							;g16x16_4color2
   2652  eb04		       55 55 55 55	      HEX	55555555
   2653  eb08							;g16x16_4color3
   2654  eb08		       55 55 55 55	      HEX	55555555
   2655  eb0c							;g16x16_4color4
   2656  eb0c		       00 00 00 00	      HEX	00000000
   2657  eb10							;g16x16_4color5
   2658  eb10		       00 00 00 00	      HEX	00000000
   2659  eb14							;g16x16_4color6
   2660  eb14		       aa aa aa aa	      HEX	aaaaaaaa
   2661  eb18							;g16x16_4color7
   2662  eb18		       ff ff ff ff	      HEX	ffffffff
   2663  eb1c							;g16x16_4color8
   2664  eb1c		       ff ff ff ff	      HEX	ffffffff
   2665  eb20							;zonebg80x16_16
   2666  eb20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2667  eb34							;ex1
   2668  eb34		       00 30 40 00	      HEX	00304000
   2669  eb38							;ex2
   2670  eb38		       30 69 9a 40	      HEX	30699a40
   2671  eb3c							;ex3
   2672  eb3c		       05 a5 6d 83	      HEX	05a56d83
   2673  eb40							;ex4
   2674  eb40		       26 9a 68 d8	      HEX	269a68d8
   2675  eb44							;ex5
   2676  eb44		       18 d4 04 69	      HEX	18d40469
   2677  eb48							;ex6
   2678  eb48		       14 00 00 01	      HEX	14000001
   2679  eb4c							;ex7
   2680  eb4c		       40 00 00 01	      HEX	40000001
   2681  eb50							;p1
   2682  eb50		       0d 56		      HEX	0d56
   2683  eb52							;blank
   2684  eb52		       00 00 00 00	      HEX	00000000
   2685  eb56							;font
   2686  eb56		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   2687  eb76		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   2688  eb8b
   2689  ec00					      ORG	$EC00,0	; *************
   2690  ec00
   2691  ec00							;g16x16_4color
   2692  ec00		       55 55 55 55	      HEX	55555555
   2693  ec04							;g16x16_4color2
   2694  ec04		       55 55 55 55	      HEX	55555555
   2695  ec08							;g16x16_4color3
   2696  ec08		       00 00 00 00	      HEX	00000000
   2697  ec0c							;g16x16_4color4
   2698  ec0c		       00 00 00 00	      HEX	00000000
   2699  ec10							;g16x16_4color5
   2700  ec10		       aa aa aa aa	      HEX	aaaaaaaa
   2701  ec14							;g16x16_4color6
   2702  ec14		       aa aa aa aa	      HEX	aaaaaaaa
   2703  ec18							;g16x16_4color7
   2704  ec18		       aa aa aa aa	      HEX	aaaaaaaa
   2705  ec1c							;g16x16_4color8
   2706  ec1c		       ff ff ff ff	      HEX	ffffffff
   2707  ec20							;zonebg80x16_16
   2708  ec20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2709  ec34							;ex1
   2710  ec34		       00 00 00 00	      HEX	00000000
   2711  ec38							;ex2
   2712  ec38		       00 64 a8 00	      HEX	0064a800
   2713  ec3c							;ex3
   2714  ec3c		       00 6e a2 40	      HEX	006ea240
   2715  ec40							;ex4
   2716  ec40		       1b 26 a6 a4	      HEX	1b26a6a4
   2717  ec44							;ex5
   2718  ec44		       12 a5 5a a4	      HEX	12a55aa4
   2719  ec48							;ex6
   2720  ec48		       11 00 00 14	      HEX	11000014
   2721  ec4c							;ex7
   2722  ec4c		       10 00 00 00	      HEX	10000000
   2723  ec50							;p1
   2724  ec50		       0d 56		      HEX	0d56
   2725  ec52							;blank
   2726  ec52		       00 00 00 00	      HEX	00000000
   2727  ec56							;font
   2728  ec56		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   2729  ec76		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   2730  ec8b
   2731  ed00					      ORG	$ED00,0	; *************
   2732  ed00
   2733  ed00							;g16x16_4color
   2734  ed00		       55 55 55 55	      HEX	55555555
   2735  ed04							;g16x16_4color2
   2736  ed04		       00 00 00 00	      HEX	00000000
   2737  ed08							;g16x16_4color3
   2738  ed08		       00 00 00 00	      HEX	00000000
   2739  ed0c							;g16x16_4color4
   2740  ed0c		       aa aa aa aa	      HEX	aaaaaaaa
   2741  ed10							;g16x16_4color5
   2742  ed10		       aa aa aa aa	      HEX	aaaaaaaa
   2743  ed14							;g16x16_4color6
   2744  ed14		       ff ff ff ff	      HEX	ffffffff
   2745  ed18							;g16x16_4color7
   2746  ed18		       aa aa aa aa	      HEX	aaaaaaaa
   2747  ed1c							;g16x16_4color8
   2748  ed1c		       55 55 55 55	      HEX	55555555
   2749  ed20							;zonebg80x16_16
   2750  ed20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2751  ed34							;ex1
   2752  ed34		       00 00 00 00	      HEX	00000000
   2753  ed38							;ex2
   2754  ed38		       00 14 14 0c	      HEX	0014140c
   2755  ed3c							;ex3
   2756  ed3c		       00 65 95 03	      HEX	00659503
   2757  ed40							;ex4
   2758  ed40		       16 68 4a 60	      HEX	16684a60
   2759  ed44							;ex5
   2760  ed44		       15 82 a3 54	      HEX	1582a354
   2761  ed48							;ex6
   2762  ed48		       25 51 05 24	      HEX	25510524
   2763  ed4c							;ex7
   2764  ed4c		       00 00 00 04	      HEX	00000004
   2765  ed50							;p1
   2766  ed50		       15 80		      HEX	1580
   2767  ed52							;blank
   2768  ed52		       00 00 00 00	      HEX	00000000
   2769  ed56							;font
   2770  ed56		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   2771  ed76		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   2772  ed8b
   2773  ee00					      ORG	$EE00,0	; *************
   2774  ee00
   2775  ee00							;g16x16_4color
   2776  ee00		       00 00 00 00	      HEX	00000000
   2777  ee04							;g16x16_4color2
   2778  ee04		       00 00 00 00	      HEX	00000000
   2779  ee08							;g16x16_4color3
   2780  ee08		       aa aa aa aa	      HEX	aaaaaaaa
   2781  ee0c							;g16x16_4color4
   2782  ee0c		       aa aa aa aa	      HEX	aaaaaaaa
   2783  ee10							;g16x16_4color5
   2784  ee10		       ff ff ff ff	      HEX	ffffffff
   2785  ee14							;g16x16_4color6
   2786  ee14		       ff ff ff ff	      HEX	ffffffff
   2787  ee18							;g16x16_4color7
   2788  ee18		       55 55 55 55	      HEX	55555555
   2789  ee1c							;g16x16_4color8
   2790  ee1c		       55 55 55 55	      HEX	55555555
   2791  ee20							;zonebg80x16_16
   2792  ee20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2793  ee34							;ex1
   2794  ee34		       00 00 00 00	      HEX	00000000
   2795  ee38							;ex2
   2796  ee38		       00 c0 00 00	      HEX	00c00000
   2797  ee3c							;ex3
   2798  ee3c		       c0 10 50 00	      HEX	c0105000
   2799  ee40							;ex4
   2800  ee40		       06 a5 79 40	      HEX	06a57940
   2801  ee44							;ex5
   2802  ee44		       31 55 45 13	      HEX	31554513
   2803  ee48							;ex6
   2804  ee48		       01 15 45 50	      HEX	01154550
   2805  ee4c							;ex7
   2806  ee4c		       05 00 00 10	      HEX	05000010
   2807  ee50							;p1
   2808  ee50		       14 00		      HEX	1400
   2809  ee52							;blank
   2810  ee52		       00 00 00 00	      HEX	00000000
   2811  ee56							;font
   2812  ee56		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   2813  ee76		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   2814  ee8b
   2815  ef00					      ORG	$EF00,0	; *************
   2816  ef00
   2817  ef00							;g16x16_4color
   2818  ef00		       00 00 00 00	      HEX	00000000
   2819  ef04							;g16x16_4color2
   2820  ef04		       aa aa aa aa	      HEX	aaaaaaaa
   2821  ef08							;g16x16_4color3
   2822  ef08		       aa aa aa aa	      HEX	aaaaaaaa
   2823  ef0c							;g16x16_4color4
   2824  ef0c		       ff ff ff ff	      HEX	ffffffff
   2825  ef10							;g16x16_4color5
   2826  ef10		       ff ff ff ff	      HEX	ffffffff
   2827  ef14							;g16x16_4color6
   2828  ef14		       55 55 55 55	      HEX	55555555
   2829  ef18							;g16x16_4color7
   2830  ef18		       55 55 55 55	      HEX	55555555
   2831  ef1c							;g16x16_4color8
   2832  ef1c		       00 00 00 00	      HEX	00000000
   2833  ef20							;zonebg80x16_16
   2834  ef20		       aa aa aa aa*	      HEX	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   2835  ef34							;ex1
   2836  ef34		       00 00 00 00	      HEX	00000000
   2837  ef38							;ex2
   2838  ef38		       00 00 c0 00	      HEX	0000c000
   2839  ef3c							;ex3
   2840  ef3c		       00 00 00 c0	      HEX	000000c0
   2841  ef40							;ex4
   2842  ef40		       00 50 54 00	      HEX	00505400
   2843  ef44							;ex5
   2844  ef44		       01 15 07 40	      HEX	01150740
   2845  ef48							;ex6
   2846  ef48		       00 50 64 40	      HEX	00506440
   2847  ef4c							;ex7
   2848  ef4c		       01 45 45 40	      HEX	01454540
   2849  ef50							;p1
   2850  ef50		       56 00		      HEX	5600
   2851  ef52							;blank
   2852  ef52		       00 00 00 00	      HEX	00000000
   2853  ef56							;font
   2854  ef56		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   2855  ef76		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   2856  ef8b
   2857  ef8b
   2858  ef8b							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2859  ef8b
   2860  ef8b					      ifnconst	bankswitchmode
   2861  ef8b					      if	( * < $f000 )
   2862  f000					      ORG	$F000
   2863  f000					      endif
   2864  f000				  -	      else
   2865  f000				  -	      ifconst	ROM128K
   2866  f000				  -	      if	( * < $f000 )
   2867  f000				  -	      ORG	$27000
   2868  f000				  -	      RORG	$F000
   2869  f000				  -	      endif
   2870  f000				  -	      endif
   2871  f000				  -	      ifconst	ROM144K
   2872  f000				  -	      if	( * < $f000 )
   2873  f000				  -	      ORG	$27000
   2874  f000				  -	      RORG	$F000
   2875  f000				  -	      endif
   2876  f000				  -	      endif
   2877  f000				  -	      ifconst	ROM256K
   2878  f000				  -	      if	( * < $f000 )
   2879  f000				  -	      ORG	$47000
   2880  f000				  -	      RORG	$F000
   2881  f000				  -	      endif
   2882  f000				  -	      endif
   2883  f000				  -	      ifconst	ROM272K
   2884  f000				  -	      if	( * < $f000 )
   2885  f000				  -	      ORG	$47000
   2886  f000				  -	      RORG	$F000
   2887  f000				  -	      endif
   2888  f000				  -	      endif
   2889  f000				  -	      ifconst	ROM512K
   2890  f000				  -	      if	( * < $f000 )
   2891  f000				  -	      ORG	$87000
   2892  f000				  -	      RORG	$F000
   2893  f000				  -	      endif
   2894  f000				  -	      endif
   2895  f000				  -	      ifconst	ROM528K
   2896  f000				  -	      if	( * < $f000 )
   2897  f000				  -	      ORG	$87000
   2898  f000				  -	      RORG	$F000
   2899  f000				  -	      endif
   2900  f000				  -	      endif
   2901  f000					      endif
   2902  f000
   2903  f000							; all of these "modules" have conditional clauses in them, so even though
   2904  f000							; they're always included here, they don't take up rom unless the user
   2905  f000							; explicitly enables support for the feature.
   2906  f000
   2907  f000					      ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  f000					      include	7800vox.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000							; AtariVox 7800basic wrapper
      4  f000
      5  f000							; to be called with
      6  f000							; A=# of bytes
      7  f000							;
      8  f000
      9  f000				  -	      ifconst	HSSUPPORT
     10  f000				  -
     11  f000				  -AVoxReadBytes
     12  f000				  -	      sta	temp8
     13  f000				  -	      jsr	i2c_startwrite
     14  f000				  -	      bcs	eeprom_error
     15  f000				  -
     16  f000				  -	      lda	HSVoxHi
     17  f000				  -	      jsr	i2c_txbyte
     18  f000				  -	      lda	HSVoxLo
     19  f000				  -	      jsr	i2c_txbyte
     20  f000				  -	      jsr	i2c_stopwrite
     21  f000				  -
     22  f000				  -	      jsr	i2c_startread
     23  f000				  -
     24  f000				  -	      ldx	#0
     25  f000				  -AVoxReadBytesLoop
     26  f000				  -	      jsr	i2c_rxbyte
     27  f000				  -	      sta	eeprombuffer,x
     28  f000				  -	      inx
     29  f000				  -	      cpx	temp8
     30  f000				  -	      bne	AVoxReadBytesLoop
     31  f000				  -	      jsr	i2c_stopread
     32  f000				  -	      lda	#0
     33  f000				  -	      rts
     34  f000				  -
     35  f000				  -			; to be called with
     36  f000				  -			; A=# of bytes
     37  f000				  -			;
     38  f000				  -
     39  f000				  -AVoxWriteBytes
     40  f000				  -	      sta	temp8
     41  f000				  -	      jsr	i2c_startwrite
     42  f000				  -	      bcs	eeprom_error
     43  f000				  -
     44  f000				  -	      lda	HSVoxHi
     45  f000				  -	      jsr	i2c_txbyte
     46  f000				  -	      lda	HSVoxLo
     47  f000				  -	      jsr	i2c_txbyte
     48  f000				  -
     49  f000				  -	      ldx	#$00
     50  f000				  -AVoxWriteBytesLoop
     51  f000				  -	      lda	eeprombuffer,x
     52  f000				  -	      jsr	i2c_txbyte
     53  f000				  -	      inx
     54  f000				  -	      cpx	temp8
     55  f000				  -	      bne	AVoxWriteBytesLoop
     56  f000				  -	      jsr	i2c_stopwrite
     57  f000				  -
     58  f000				  -	      lda	#0
     59  f000				  -	      rts
     60  f000				  -
     61  f000				  -eeprom_error
     62  f000				  -	      lda	#$ff
     63  f000				  -	      rts
     64  f000				  -
     65  f000				  -AVoxDetect
     66  f000				  -
     67  f000				  -	      jsr	i2c_startwrite
     68  f000				  -	      bcs	eeprom_error
     69  f000				  -	      lda	#$30
     70  f000				  -	      jsr	i2c_txbyte
     71  f000				  -	      lda	#$00
     72  f000				  -	      jsr	i2c_txbyte
     73  f000				  -	      jsr	i2c_stopwrite
     74  f000				  -	      rts
     75  f000				  -
     76  f000				  -	      include	"i2c7800.inc"
     77  f000				  -	      I2C_SUBS	temp9
     78  f000				  -
     79  f000					      endif
     80  f000
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
   2909  f000					      endif
   2910  f000					      ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  f000					      include	pokeysound.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	pokeysupport
      5  f000				  -
      6  f000				  -pokeysoundmodulestart
      7  f000				  -
      8  f000				  -mutepokey
      9  f000				  -	      lda	#0
     10  f000				  -	      ldy	#7
     11  f000				  -mutepokeyloop
     12  f000				  -	      sta	pokey1pointlo,y
     13  f000				  -	      sta	(pokeybaselo),y
     14  f000				  -	      dey
     15  f000				  -	      bpl	mutepokeyloop
     16  f000				  -	      rts
     17  f000				  -
     18  f000				  -checkpokeyplaying
     19  f000				  -	      ldx	#6
     20  f000				  -checkpokeyplayingloop
     21  f000				  -	      lda	pokey1pointlo,x
     22  f000				  -	      ora	pokey1pointhi,x
     23  f000				  -	      beq	pokeychannelinactive
     24  f000				  -	      jsr	playpokeysfxA	; x=channel*2
     25  f000				  -pokeychannelinactive
     26  f000				  -	      dex
     27  f000				  -	      dex
     28  f000				  -	      bpl	checkpokeyplayingloop
     29  f000				  -	      rts
     30  f000				  -
     31  f000				  -playpokeysfxA
     32  f000				  -	      txa
     33  f000				  -	      tay
     34  f000				  -	      lda	pokey1tick,x
     35  f000				  -	      beq	playpokeysfxAcont
     36  f000				  -	      sec
     37  f000				  -	      sbc	#1
     38  f000				  -	      sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  f000				  -	      rts
     40  f000				  -
     41  f000				  -playpokeysfxAcont
     42  f000				  -	      lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  f000				  -	      sta	pokey1tick,x
     44  f000				  -
     45  f000				  -	      lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  f000				  -	      beq	playpokeysfxAcont2
     47  f000				  -	      sec
     48  f000				  -	      sbc	#1
     49  f000				  -	      sta	pokey1priority,x
     50  f000				  -playpokeysfxAcont2
     51  f000				  -
     52  f000				  -			; *** FREQUENCY
     53  f000				  -	      lda	(pokey1pointlo,x)
     54  f000				  -	      sta	temp1
     55  f000				  -	      clc
     56  f000				  -	      adc	pokey1offset,x	; take into account any pitch modification
     57  f000				  -	      sta	(pokeybaselo),y	; PAUDF0,0
     58  f000				  -
     59  f000				  -			;advance the data pointer +1
     60  f000				  -	      inc	pokey1pointlo,x
     61  f000				  -	      bne	skippokeyhiinc1
     62  f000				  -	      inc	pokey1pointhi,x
     63  f000				  -skippokeyhiinc1
     64  f000				  -
     65  f000				  -			; *** WAVE
     66  f000				  -	      lda	(pokey1pointlo,x)
     67  f000				  -	      asl
     68  f000				  -	      asl
     69  f000				  -	      asl
     70  f000				  -	      asl		; x16
     71  f000				  -
     72  f000				  -			;advance the data pointer +1
     73  f000				  -	      inc	pokey1pointlo,x
     74  f000				  -	      bne	skippokeyhiinc2
     75  f000				  -	      inc	pokey1pointhi,x
     76  f000				  -skippokeyhiinc2
     77  f000				  -
     78  f000				  -	      ora	(pokey1pointlo,x)
     79  f000				  -	      iny
     80  f000				  -	      sta	(pokeybaselo),y
     81  f000				  -
     82  f000				  -	      ora	temp1	; check if F|C|V=0
     83  f000				  -	      beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  f000				  -
     85  f000				  -			; advance the pointer +1, on to the next sound chunk
     86  f000				  -	      inc	pokey1pointlo,x
     87  f000				  -	      bne	skippokeyhiinc3
     88  f000				  -	      inc	pokey1pointhi,x
     89  f000				  -skippokeyhiinc3
     90  f000				  -	      rts
     91  f000				  -
     92  f000				  -zeropokeypoint
     93  f000				  -	      sta	pokey1pointlo,x
     94  f000				  -	      sta	pokey1pointhi,x
     95  f000				  -	      sta	pokey1priority,x
     96  f000				  -	      rts
     97  f000				  -
     98  f000				  -schedulepokeysfx
     99  f000				  -	      ldx	#6
    100  f000				  -schedulepokeysfxloop
    101  f000				  -	      lda	pokey1pointlo,x
    102  f000				  -	      ora	pokey1pointhi,x
    103  f000				  -	      bne	schedulespokeysearch
    104  f000				  -	      jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  f000				  -schedulespokeysearch
    106  f000				  -	      dex
    107  f000				  -	      dex
    108  f000				  -	      bpl	schedulepokeysfxloop
    109  f000				  -
    110  f000				  -			; if we're here, all 4 channels are presently playing a sound...
    111  f000				  -	      ldy	#1
    112  f000				  -	      lda	(temp1),y	; peek at the priority of this sfx...
    113  f000				  -	      bne	schedulepokeysfxcont1
    114  f000				  -	      rts		; ...and skip it if it's 0 priority
    115  f000				  -schedulepokeysfxcont1
    116  f000				  -
    117  f000				  -			; figure out which current sound has the lowest priority...
    118  f000				  -	      lda	#0
    119  f000				  -	      sta	temp8
    120  f000				  -	      lda	pokey1priority
    121  f000				  -	      sta	temp9
    122  f000				  -	      ldx	#6
    123  f000				  -findlowprioritypokeyloop
    124  f000				  -	      lda	pokey1priority,x
    125  f000				  -	      cmp	temp9
    126  f000				  -	      bcs	findlowprioritypokeyloopcontinue
    127  f000				  -	      sta	temp9
    128  f000				  -	      stx	temp8
    129  f000				  -findlowprioritypokeyloopcontinue
    130  f000				  -	      dex
    131  f000				  -	      dex
    132  f000				  -	      bne	findlowprioritypokeyloop
    133  f000				  -	      ldx	temp8	; the low priority channel we'll interrupt
    134  f000				  -
    135  f000				  -schedulepokeyX
    136  f000				  -			;called with X=2*pokey channel to play on...
    137  f000				  -	      ldy	#1	; get priority and sound-resolution (in frames)
    138  f000				  -	      lda	(temp1),y
    139  f000				  -	      sta	pokey1priority,x
    140  f000				  -	      iny
    141  f000				  -	      lda	(temp1),y
    142  f000				  -	      sta	pokey1frames,x
    143  f000				  -
    144  f000				  -	      lda	temp1
    145  f000				  -	      clc
    146  f000				  -	      adc	#3
    147  f000				  -	      sta	pokey1pointlo,x
    148  f000				  -	      lda	temp2
    149  f000				  -	      adc	#0
    150  f000				  -	      sta	pokey1pointhi,x
    151  f000				  -	      lda	temp3
    152  f000				  -	      sta	pokey1offset,x
    153  f000				  -	      lda	#0
    154  f000				  -	      sta	pokey1tick,x
    155  f000				  -	      rts
    156  f000				  -
    157  f000				  -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  f000				  -			; and the standard $4000 location.
    159  f000				  -			; if pokey the pokey is present, this routine will reset it.
    160  f000				  -
    161  f000				  -detectpokeylocation
    162  f000				  -			;XBoard/XM...
    163  f000				  -	      ldx	#2
    164  f000				  -detectpokeyloop
    165  f000				  -	      lda	XCTRL1s
    166  f000				  -	      ora	#%00010100
    167  f000				  -	      and	POKEYXMMASK,x
    168  f000				  -	      sta	XCTRL1s
    169  f000				  -	      sta	XCTRL1
    170  f000				  -
    171  f000				  -	      lda	POKEYCHECKLO,x
    172  f000				  -	      sta	pokeybaselo
    173  f000				  -	      lda	POKEYCHECKHI,x
    174  f000				  -	      sta	pokeybasehi
    175  f000				  -	      jsr	checkforpokey
    176  f000				  -	      lda	pokeydetected
    177  f000				  -	      beq	foundpokeychip
    178  f000				  -	      dex
    179  f000				  -	      bpl	detectpokeyloop
    180  f000				  -foundpokeychip
    181  f000				  -	      eor	#$ff	; invert state for 7800basic if...then test
    182  f000				  -	      sta	pokeydetected
    183  f000				  -	      rts
    184  f000				  -
    185  f000				  -POKEYXMMASK
    186  f000				  -			;     XM POKEY on    XM POKEY off   XM POKEY off
    187  f000				  -	      .byte	%11111111, %11101111, %11101111
    188  f000				  -
    189  f000				  -POKEYCHECKLO
    190  f000				  -	      .byte	<$0450, <$0450, <$4000
    191  f000				  -POKEYCHECKHI
    192  f000				  -	      .byte	>$0450, >$0450, >$4000
    193  f000				  -
    194  f000				  -checkforpokey
    195  f000				  -	      ldy	#$0f
    196  f000				  -	      lda	#$00
    197  f000				  -	      sta	pokeydetected	; start off by assuming pokey will be detected
    198  f000				  -resetpokeyregistersloop
    199  f000				  -	      sta	(pokeybase),y
    200  f000				  -	      dey
    201  f000				  -	      bpl	resetpokeyregistersloop
    202  f000				  -
    203  f000				  -	      ldy	#PAUDCTL
    204  f000				  -	      sta	(pokeybase),y
    205  f000				  -	      ldy	#PSKCTL
    206  f000				  -	      sta	(pokeybase),y
    207  f000				  -
    208  f000				  -			; let the dust settle...
    209  f000				  -	      nop
    210  f000				  -	      nop
    211  f000				  -	      nop
    212  f000				  -
    213  f000				  -	      lda	#4
    214  f000				  -	      sta	temp9
    215  f000				  -pokeycheckloop1
    216  f000				  -			; we're in reset, so the RANDOM register should read $ff...
    217  f000				  -	      ldy	#PRANDOM
    218  f000				  -	      lda	(pokeybase),y
    219  f000				  -	      cmp	#$ff
    220  f000				  -	      bne	nopokeydetected
    221  f000				  -	      dec	temp9
    222  f000				  -	      bne	pokeycheckloop1
    223  f000				  -
    224  f000				  -			; take pokey out of reset...
    225  f000				  -	      ldy	#PSKCTL
    226  f000				  -	      lda	#3
    227  f000				  -	      sta	(pokeybase),y
    228  f000				  -	      ldy	#PAUDCTL
    229  f000				  -	      lda	#0
    230  f000				  -	      sta	(pokeybase),y
    231  f000				  -
    232  f000				  -			; let the dust settle again...
    233  f000				  -	      nop
    234  f000				  -	      nop
    235  f000				  -	      nop
    236  f000				  -
    237  f000				  -	      lda	#4
    238  f000				  -	      sta	temp9
    239  f000				  -pokeycheckloop2
    240  f000				  -			; we're out of reset, so RANDOM should read non-$ff...
    241  f000				  -	      ldy	#PRANDOM
    242  f000				  -	      lda	(pokeybase),y
    243  f000				  -	      cmp	#$ff
    244  f000				  -	      beq	skippokeycheckreturn
    245  f000				  -	      rts
    246  f000				  -skippokeycheckreturn
    247  f000				  -	      dec	temp9
    248  f000				  -	      bne	pokeycheckloop2
    249  f000				  -nopokeydetected
    250  f000				  -	      dec	pokeydetected	; pokeydetected=#$ff
    251  f000				  -	      rts
    252  f000				  -
    253  f000				  -pokeysoundmoduleend
    254  f000				  -
    255  f000				  -	      echo	"  pokeysound assembly: ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes"
    256  f000				  -
    257  f000					      endif
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
   2912  f000					      endif
   2913  f000					      ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  f000					      include	tracker.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	MUSICTRACKER
      5  f000				  -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      6  f000				  -			; ** the player operates on a 16th note grid.
      7  f000				  -
      8  f000				  -servicesongover
      9  f000				  -	      rts
     10  f000				  -servicesong
     11  f000				  -	      lda	songtempo
     12  f000				  -	      beq	servicesongover	; ** if song is off/paused then return
     13  f000				  -servicesongcontinue
     14  f000				  -	      lda	sfxschedulelock
     15  f000				  -	      sta	sfxschedulemissed
     16  f000				  -	      bne	servicesongover
     17  f000				  -	      lda	songtempo
     18  f000				  -	      clc
     19  f000				  -	      adc	songtick	; add songtempo to songtick until it rolls over
     20  f000				  -	      sta	songtick	; this is how we break away from 50/60Hz timing.
     21  f000				  -	      bcc	servicesongover
     22  f000				  -			; ** if we're here a new 16th note has passed
     23  f000				  -			; ** check if a new note is due on any of the 4 channels
     24  f000				  -servicesongredo
     25  f000				  -	      ldx	#3
     26  f000				  -checkchannelloop
     27  f000				  -	      dec	songchannel1busywait,x
     28  f000				  -	      bpl	carryoncheckingchannel
     29  f000				  -	      txa
     30  f000				  -	      pha		; save X for the loop
     31  f000				  -	      jsr	processsongdata
     32  f000				  -	      pla		; restore X for the loop
     33  f000				  -	      tax
     34  f000				  -carryoncheckingchannel
     35  f000				  -	      dex
     36  f000				  -	      bpl	checkchannelloop
     37  f000				  -	      lda	inactivechannelcount
     38  f000				  -	      cmp	#15
     39  f000				  -	      bne	skipstopsong
     40  f000				  -	      lda	songloops
     41  f000				  -	      bne	doasongloop
     42  f000				  -			;lda #0
     43  f000				  -	      sta	songtempo	; all channels are done. stop the song
     44  f000				  -	      rts
     45  f000				  -doasongloop
     46  f000				  -	      bmi	skipsongloopadjust
     47  f000				  -	      dec	songloops
     48  f000				  -skipsongloopadjust
     49  f000				  -	      jsr	setsongchannels
     50  f000				  -	      jmp	servicesongredo
     51  f000				  -skipstopsong
     52  f000				  -	      rts
     53  f000				  -
     54  f000				  -processsongdata
     55  f000				  -			; channel needs processing
     56  f000				  -			; X=channel #
     57  f000				  -
     58  f000				  -	      txa
     59  f000				  -	      clc
     60  f000				  -	      adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     61  f000				  -	      tay
     62  f000				  -
     63  f000				  -
     64  f000				  -			; ** indirect x is cumbersome with mult-byte commands.
     65  f000				  -			; ** setup a pointer to the song data for indirect y addressing.
     66  f000				  -	      lda	songchannel1layer1lo,y
     67  f000				  -	      sta	songdatalo
     68  f000				  -	      lda	songchannel1layer1hi,y
     69  f000				  -	      sta	songdatahi
     70  f000				  -	      ora	songdatalo
     71  f000				  -	      bne	channelhasdata
     72  f000				  -			;channel data is pointing at $0000
     73  f000				  -	      lda	#$7F
     74  f000				  -	      sta	songchannel1busywait,x	; skip a bunch of notes
     75  f000				  -setchannelcountbits
     76  f000				  -	      lda	channel2bits,x
     77  f000				  -	      ora	inactivechannelcount
     78  f000				  -	      sta	inactivechannelcount
     79  f000				  -	      rts
     80  f000				  -channelhasdata
     81  f000				  -
     82  f000				  -	      sty	songstackindex
     83  f000				  -	      ldy	#0
     84  f000				  -	      lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     85  f000				  -	      cmp	#$ff
     86  f000				  -	      bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     87  f000				  -	      jmp	handlechannelEOD
     88  f000				  -
     89  f000				  -carryoncheckingdatatype
     90  f000				  -	      and	#$F0
     91  f000				  -	      cmp	#$C0
     92  f000				  -	      beq	handlechannelrest	; 0000XXXX=rest
     93  f000				  -	      cmp	#$F0
     94  f000				  -	      beq	handlemultibytecommand
     95  f000				  -	      cmp	#$D0
     96  f000				  -	      beq	handlesemiup
     97  f000				  -	      cmp	#$E0
     98  f000				  -	      beq	handlesemidown
     99  f000				  -handlenotedata
    100  f000				  -			; ** TODO: note playing is a terrible choice for fall-through
    101  f000				  -
    102  f000				  -			; ** its simple note data, prepare arguments for schedulesfx
    103  f000				  -
    104  f000				  -			; ** set the note length
    105  f000				  -	      lda	(songdatalo),y
    106  f000				  -	      and	#$0F
    107  f000				  -	      sta	songchannel1busywait,x
    108  f000				  -
    109  f000				  -			; ** load the instrument
    110  f000				  -	      lda	songchannel1instrumentlo,x
    111  f000				  -	      sta	sfxinstrumentlo
    112  f000				  -	      lda	songchannel1instrumenthi,x
    113  f000				  -	      sta	sfxinstrumenthi
    114  f000				  -
    115  f000				  -			; ** get the note, and transpose
    116  f000				  -	      lda	(songdatalo),y
    117  f000				  -	      lsr
    118  f000				  -	      lsr
    119  f000				  -	      lsr
    120  f000				  -	      lsr
    121  f000				  -	      clc
    122  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    123  f000				  -			; ** its up the respective SFX scheduler to handle and save the note data
    124  f000				  -	      sta	sfxnoteindex
    125  f000				  -
    126  f000				  -	      lda	#0
    127  f000				  -	      sta	sfxpitchoffset
    128  f000				  -
    129  f000				  -	      jsr	schedulesfx
    130  f000				  -
    131  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    132  f000				  -
    133  f000				  -handlechannelrest
    134  f000				  -			; ** set the note length
    135  f000				  -	      lda	(songdatalo),y
    136  f000				  -	      and	#$0F
    137  f000				  -	      sta	songchannel1busywait,x
    138  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  f000				  -
    140  f000				  -handlesemiup
    141  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    142  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    143  f000				  -	      clc
    144  f000				  -handlesemidownentry
    145  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    146  f000				  -	      sta	songchannel1transpose,x
    147  f000				  -	      jsr	advancethesongpointer1byte
    148  f000				  -	      jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    149  f000				  -
    150  f000				  -handlesemidown
    151  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    152  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    153  f000				  -	      eor	#$ff	; ** its easier if we negate it, and then add it instead.
    154  f000				  -	      sec
    155  f000				  -	      jmp	handlesemidownentry
    156  f000				  -
    157  f000				  -handlemultibytecommand
    158  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  f000				  -	      cmp	#$08	; ** load new instrument?
    161  f000				  -	      bne	nothandleinstrumentchange
    162  f000				  -handleinstrumentchange
    163  f000				  -	      iny
    164  f000				  -	      lda	(songdatalo),y
    165  f000				  -	      sta	songchannel1instrumentlo,x
    166  f000				  -	      iny
    167  f000				  -	      lda	(songdatalo),y
    168  f000				  -	      sta	songchannel1instrumenthi,x
    169  f000				  -	      lda	#3
    170  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    171  f000				  -	      jmp	processsongdata
    172  f000				  -
    173  f000				  -nothandleinstrumentchange
    174  f000				  -	      cmp	#$09	; ** absolute tempo change?
    175  f000				  -	      bne	nothandletempochange
    176  f000				  -	      lda	#0
    177  f000				  -	      sta	songtempo
    178  f000				  -handlerelativetempochange
    179  f000				  -	      iny
    180  f000				  -	      lda	(songdatalo),y
    181  f000				  -	      clc
    182  f000				  -	      adc	songtempo
    183  f000				  -	      sta	songtempo
    184  f000				  -	      lda	#2
    185  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    186  f000				  -	      jmp	processsongdata
    187  f000				  -
    188  f000				  -nothandletempochange
    189  f000				  -	      cmp	#$0A	; ** relative tempo change?:
    190  f000				  -	      beq	handlerelativetempochange
    191  f000				  -	      cmp	#$0B	; ** octave/semi change?
    192  f000				  -	      beq	handleoctavesemichange
    193  f000				  -handlepatterndata
    194  f000				  -			; ** if we're here its a pattern/loop "subroutine"
    195  f000				  -			; ** move the channel's "stack" pointer and populate the new stack level
    196  f000				  -
    197  f000				  -	      lda	#4
    198  f000				  -	      clc
    199  f000				  -	      adc	songchannel1stackdepth,x
    200  f000				  -	      sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    201  f000				  -
    202  f000				  -	      stx	inttemp6	; about to invalidate x. save it.
    203  f000				  -	      lda	songstackindex
    204  f000				  -	      adc	#4
    205  f000				  -	      tax
    206  f000				  -
    207  f000				  -	      lda	(songdatalo),y
    208  f000				  -	      and	#$7
    209  f000				  -	      sta	songchannel1layer1loops,x
    210  f000				  -	      iny
    211  f000				  -	      lda	(songdatalo),y
    212  f000				  -	      sta	songchannel1layer1lo,x
    213  f000				  -	      iny
    214  f000				  -	      lda	(songdatalo),y
    215  f000				  -	      sta	songchannel1layer1hi,x
    216  f000				  -
    217  f000				  -	      ldx	inttemp6	; restore x with the channel #
    218  f000				  -
    219  f000				  -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    220  f000				  -	      lda	#3
    221  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    222  f000				  -
    223  f000				  -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    224  f000				  -	      jmp	processsongdata
    225  f000				  -
    226  f000				  -handlechannelEOD
    227  f000				  -			; ** check if there are loops remaining on the pattern
    228  f000				  -	      stx	inttemp6
    229  f000				  -	      ldx	songstackindex
    230  f000				  -	      dec	songchannel1layer1loops,x
    231  f000				  -	      bmi	handlechannelEODnoloop
    232  f000				  -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    233  f000				  -	      iny
    234  f000				  -	      lda	(songdatalo),y
    235  f000				  -	      sta	songchannel1layer1lo,x
    236  f000				  -	      iny
    237  f000				  -	      lda	(songdatalo),y
    238  f000				  -	      sta	songchannel1layer1hi,x
    239  f000				  -	      ldx	inttemp6
    240  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    241  f000				  -
    242  f000				  -handlechannelEODnoloop
    243  f000				  -			; this pattern/loop is done playing. "pop" the stack
    244  f000				  -	      ldx	inttemp6
    245  f000				  -	      lda	songchannel1stackdepth,x
    246  f000				  -	      beq	handlerootchannelEOD
    247  f000				  -	      sec
    248  f000				  -	      sbc	#4
    249  f000				  -	      sta	songchannel1stackdepth,x
    250  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    251  f000				  -
    252  f000				  -handlerootchannelEOD
    253  f000				  -			; this channel is done. point it to $ff data so we no longer process this channel.
    254  f000				  -	      lda	#0
    255  f000				  -	      sta	songchannel1layer1lo,x
    256  f000				  -	      sta	songchannel1layer1hi,x
    257  f000				  -	      sta	songchannel1busywait,x
    258  f000				  -	      jmp	setchannelcountbits
    259  f000				  -	      rts
    260  f000				  -
    261  f000				  -nothandlepatternchange
    262  f000				  -handleoctavesemichange
    263  f000				  -	      iny
    264  f000				  -	      lda	(songdatalo),y
    265  f000				  -	      sta	songchannel1transpose,x
    266  f000				  -	      lda	#2
    267  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    268  f000				  -	      jmp	processsongdata
    269  f000				  -
    270  f000				  -advancethesongpointer1byte
    271  f000				  -	      txa
    272  f000				  -	      ldx	songstackindex
    273  f000				  -	      inc	songchannel1layer1lo,x
    274  f000				  -	      bne	skiphiadvancethesongpointer1byte
    275  f000				  -	      inc	songchannel1layer1hi,x
    276  f000				  -skiphiadvancethesongpointer1byte
    277  f000				  -	      tax
    278  f000				  -	      rts
    279  f000				  -
    280  f000				  -advancethesongpointerNbytes
    281  f000				  -			; entered with A=# of byte to advance
    282  f000				  -	      stx	inttemp6
    283  f000				  -	      ldx	songstackindex
    284  f000				  -	      clc
    285  f000				  -	      adc	songchannel1layer1lo,x
    286  f000				  -	      sta	songchannel1layer1lo,x
    287  f000				  -	      lda	#0
    288  f000				  -	      adc	songchannel1layer1hi,x
    289  f000				  -	      sta	songchannel1layer1hi,x
    290  f000				  -	      ldx	inttemp6
    291  f000				  -	      rts
    292  f000				  -
    293  f000				  -clearsongmemory
    294  f000				  -	      lda	#0
    295  f000				  -	      ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    296  f000				  -clearsongmemoryloop1
    297  f000				  -	      sta	songchannel1layer1lo,x
    298  f000				  -	      dex
    299  f000				  -	      bpl	clearsongmemoryloop1
    300  f000				  -
    301  f000				  -	      ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    302  f000				  -clearsongmemoryloop2
    303  f000				  -	      sta	songchannel1layer1loops,x
    304  f000				  -	      dex
    305  f000				  -	      bpl	clearsongmemoryloop2
    306  f000				  -
    307  f000				  -	      lda	#$ff
    308  f000				  -	      ldx	#3
    309  f000				  -clearsongmemoryloop3
    310  f000				  -	      sta	songchannel1busywait,x
    311  f000				  -	      dex
    312  f000				  -	      bpl	clearsongmemoryloop3
    313  f000				  -	      rts
    314  f000				  -
    315  f000				  -setsongchannels
    316  f000				  -	      jsr	clearsongmemory
    317  f000				  -	      ldy	#7
    318  f000				  -	      ldx	#3
    319  f000				  -setsongchannelsloop
    320  f000				  -	      lda	(songpointerlo),y
    321  f000				  -	      sta	songchannel1layer1hi,x
    322  f000				  -	      dey
    323  f000				  -	      lda	(songpointerlo),y
    324  f000				  -	      sta	songchannel1layer1lo,x
    325  f000				  -	      dex
    326  f000				  -	      dey
    327  f000				  -	      bpl	setsongchannelsloop
    328  f000				  -	      rts
    329  f000				  -
    330  f000				  -channel2bits
    331  f000				  -	      .byte	1,2,4,8
    332  f000				  -
    333  f000				  -tiatrackeroctavenotes
    334  f000				  -	      ifconst	BUZZBASS
    335  f000				  -LOWC       =	15
    336  f000				  -	      else
    337  f000				  -LOWC       =	14
    338  f000				  -	      endif
    339  f000				  -			; ****** ELECTRONIC (0 to 11)
    340  f000				  -	      .byte	LOWC,20	; c0	 16.1Hz
    341  f000				  -	      .byte	LOWC,18	; c#0
    342  f000				  -	      .byte	LOWC,17	; d0
    343  f000				  -	      .byte	LOWC,16	; d#0
    344  f000				  -	      .byte	LOWC,15	; e0
    345  f000				  -	      .byte	LOWC,14	; f0  (very off)
    346  f000				  -	      .byte	LOWC,14	; f#0
    347  f000				  -	      .byte	LOWC,13	; g0
    348  f000				  -	      .byte	LOWC,12	; g#0
    349  f000				  -	      .byte	LOWC,11	; a0
    350  f000				  -	      .byte	LOWC,11	; a#0 (very off)
    351  f000				  -	      .byte	LOWC,10	; b0	 30.7Hz
    352  f000				  -
    353  f000				  -			; ****** SLIGHTLY BUZZY (12 to 23)
    354  f000				  -	      .byte	6,30	; c1	 32.7Hz
    355  f000				  -	      .byte	6,28	; c#1
    356  f000				  -	      .byte	6,27	; d1
    357  f000				  -	      .byte	6,25	; d#1
    358  f000				  -	      .byte	6,24	; e1
    359  f000				  -	      .byte	6,22	; f1
    360  f000				  -	      .byte	6,21	; f#1
    361  f000				  -	      .byte	6,20	; g1
    362  f000				  -	      .byte	6,18	; g#1
    363  f000				  -	      .byte	6,17	; a1
    364  f000				  -	      .byte	6,16	; a#1
    365  f000				  -	      .byte	6,15	; b1	 63.4Hz
    366  f000				  -
    367  f000				  -			; ****** BUZZY (24 to 39)
    368  f000				  -	      .byte	1,31	; c2	 65.5
    369  f000				  -	      .byte	1,30	; c#2	 67.6
    370  f000				  -	      .byte	1,27	; d2	 72.3
    371  f000				  -	      .byte	1,26	; d#2	 77.6
    372  f000				  -	      .byte	1,24	; e2
    373  f000				  -	      .byte	1,23	; f2
    374  f000				  -	      .byte	1,22	; f#2
    375  f000				  -	      .byte	1,20	; g2
    376  f000				  -	      .byte	1,19	; g#2
    377  f000				  -	      .byte	1,18	; a2
    378  f000				  -	      .byte	1,17	; a#2
    379  f000				  -	      .byte	1,16	; b2
    380  f000				  -	      .byte	1,15	; c3	126.8Hz
    381  f000				  -	      .byte	1,14	; c#3
    382  f000				  -	      .byte	1,13	; d3	149.7Hz
    383  f000				  -	      .byte	1,12	; d#3	161.2Hz (very off)
    384  f000				  -			; ****** PURE (40 to 71) - best key is A3 Major
    385  f000				  -	      .byte	12,31	; e3	163.8Hz
    386  f000				  -	      .byte	12,29	; f3
    387  f000				  -	      .byte	12,28	; f#3
    388  f000				  -	      .byte	12,26	; g3
    389  f000				  -	      .byte	12,24	; g#3
    390  f000				  -	      .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    391  f000				  -	      .byte	12,22	; a#3
    392  f000				  -	      .byte	12,20	; b3
    393  f000				  -	      .byte	12,19	; c4  (middle C)
    394  f000				  -	      .byte	12,18	; c#4
    395  f000				  -	      .byte	12,17	; d4
    396  f000				  -	      .byte	12,16	; d#4
    397  f000				  -	      .byte	12,15	; e4
    398  f000				  -	      .byte	12,14	; f4
    399  f000				  -	      .byte	12,13	; f#4
    400  f000				  -	      .byte	12,12	; g4  (very off)
    401  f000				  -	      .byte	12,12	; g#4
    402  f000				  -	      .byte	12,11	; a4
    403  f000				  -	      .byte	12,10	; a#4
    404  f000				  -	      .byte	4,31	; b4
    405  f000				  -	      .byte	4,29	; c5
    406  f000				  -	      .byte	4,28	; c#5
    407  f000				  -	      .byte	4,26	; d5
    408  f000				  -	      .byte	4,24	; d#5
    409  f000				  -	      .byte	4,23	; e5
    410  f000				  -	      .byte	4,22	; f5
    411  f000				  -	      .byte	4,20	; f#5
    412  f000				  -	      .byte	4,19	; g5
    413  f000				  -	      .byte	4,18	; g#5
    414  f000				  -	      .byte	4,17	; a5
    415  f000				  -	      .byte	4,16	; a#5
    416  f000				  -	      .byte	4,15	; b5
    417  f000				  -
    418  f000				  -			; ****** TUNED WIND (72 to 83)
    419  f000				  -	      .byte	8,30	; c
    420  f000				  -	      .byte	8,28	; c#
    421  f000				  -	      .byte	8,27	; d
    422  f000				  -	      .byte	8,25	; d#
    423  f000				  -	      .byte	8,24	; e
    424  f000				  -	      .byte	8,22	; f
    425  f000				  -	      .byte	8,21	; f#
    426  f000				  -	      .byte	8,20	; g
    427  f000				  -	      .byte	8,18	; g#
    428  f000				  -	      .byte	8,17	; a
    429  f000				  -	      .byte	8,16	; a#
    430  f000				  -	      .byte	8,15	; b
    431  f000				  -
    432  f000				  -	      include	"tiadrumkit.asm"
    433  f000				  -
    434  f000					      endif		;MUSICTRACKER
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
   2915  f000					      endif
   2916  f000					      ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  f000					      include	hiscore.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	HSSUPPORT
      4  f000				  -detectatarivoxeeprom
      5  f000				  -hiscoremodulestart
      6  f000				  -			; do a test to see if atarivox eeprom can be accessed, and save results
      7  f000				  -	      jsr	AVoxDetect
      8  f000				  -	      eor	#$ff	; invert for easy 7800basic if...then logic
      9  f000				  -	      sta	avoxdetected
     10  f000				  -	      lda	#$0
     11  f000				  -	      sta	SWACNT
     12  f000				  -	      lda	avoxdetected
     13  f000				  -	      rts
     14  f000				  -
     15  f000				  -detecthsc
     16  f000				  -			; check for the HSC ROM signature...
     17  f000				  -	      lda	XCTRL1s
     18  f000				  -	      ora	#%00001100
     19  f000				  -	      sta	XCTRL1s
     20  f000				  -	      sta	XCTRL1
     21  f000				  -	      lda	$3900
     22  f000				  -	      cmp	#$C6
     23  f000				  -	      bne	detecthscfail
     24  f000				  -	      lda	$3904
     25  f000				  -	      cmp	#$FE
     26  f000				  -	      bne	detecthscfail
     27  f000				  -			; check if it's initialized...
     28  f000				  -	      ldy	#0
     29  f000				  -	      lda	#$ff
     30  f000				  -checkhscinit
     31  f000				  -	      and	$1000,y
     32  f000				  -	      dey
     33  f000				  -	      bpl	checkhscinit
     34  f000				  -	      cmp	#$ff
     35  f000				  -	      bne	hscisalreadyinit
     36  f000				  -			; if we're here, we need to do a minimal HSC init...
     37  f000				  -	      ldy	#$28
     38  f000				  -hscinitloop1
     39  f000				  -	      lda	hscheader,y
     40  f000				  -	      sta	$1000,y
     41  f000				  -	      dey
     42  f000				  -	      bpl	hscinitloop1
     43  f000				  -	      ldy	#$89
     44  f000				  -	      lda	#$7F
     45  f000				  -hscinitloop2
     46  f000				  -	      sta	$10B3,y
     47  f000				  -	      dey
     48  f000				  -	      cpy	#$ff
     49  f000				  -	      bne	hscinitloop2
     50  f000				  -hscisalreadyinit
     51  f000				  -	      lda	#$ff
     52  f000				  -	      rts
     53  f000				  -hscheader
     54  f000				  -	      .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     55  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     56  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     57  f000				  -detecthscfail
     58  f000				  -	      lda	XCTRL1s
     59  f000				  -	      and	#%11110111
     60  f000				  -	      sta	XCTRL1s
     61  f000				  -	      lda	#0
     62  f000				  -	      rts
     63  f000					      endif		; HSSUPPORT
     64  f000
     65  f000				  -	      ifconst	HSSUPPORT
     66  f000				  -	      ifnconst	hiscorefont
     67  f000				  -	      echo	""
     68  f000				  -	      echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     69  f000				  -	      echo	" NOT imported with incgraphic. The high score display code"
     70  f000				  -	      echo	" has been omitted from this build."
     71  f000				  -	      echo	""
     72  f000				  -	      else
     73  f000				  -hscdrawscreen
     74  f000				  -
     75  f000				  -			; we use 20 lines on a 24 line display
     76  f000				  -			; HSSCOREY to dynamically centers based on
     77  f000				  -			;HSSCOREY = 0
     78  f000				  -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     79  f000				  -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     80  f000				  -
     81  f000				  -	      ifconst	HSSCORESIZE
     82  f000				  -SCORESIZE  =	HSSCORESIZE
     83  f000				  -	      else
     84  f000				  -SCORESIZE  =	6
     85  f000				  -	      endif
     86  f000				  -
     87  f000				  -			;save shadow registers for later return...
     88  f000				  -	      lda	sCTRL
     89  f000				  -	      sta	ssCTRL
     90  f000				  -	      lda	sCHARBASE
     91  f000				  -	      sta	ssCHARBASE
     92  f000				  -	      lda	#$60
     93  f000				  -	      sta	charactermode
     94  f000				  -	      jsr	drawwait
     95  f000				  -	      jsr	blacken320colors
     96  f000				  -	      jsr	clearscreen
     97  f000				  -
     98  f000				  -			;set the character base to the HSC font
     99  f000				  -	      lda	#>hiscorefont
    100  f000				  -	      sta	CHARBASE
    101  f000				  -	      sta	sCHARBASE
    102  f000				  -	      lda	#%01000011	;Enable DMA, mode=320A
    103  f000				  -	      sta	CTRL
    104  f000				  -	      sta	sCTRL
    105  f000				  -
    106  f000				  -	      lda	#60
    107  f000				  -	      sta	hsjoydebounce
    108  f000				  -
    109  f000				  -	      lda	#0
    110  f000				  -	      sta	hscursorx
    111  f000				  -	      sta	framecounter
    112  f000				  -	      ifnconst	HSCOLORCHASESTART
    113  f000				  -	      lda	#$8D	; default is blue. why not?
    114  f000				  -	      else
    115  f000				  -	      lda	#HSCOLORCHASESTART
    116  f000				  -	      endif
    117  f000				  -	      sta	hscolorchaseindex
    118  f000				  -
    119  f000				  -	      lda	#$0F
    120  f000				  -	      sta	P0C2	; base text is white
    121  f000				  -
    122  f000				  -	      jsr	hschasecolors
    123  f000				  -			; ** plot all of the initials
    124  f000				  -	      lda	#<HSRAMInitials
    125  f000				  -	      sta	temp1	; charmaplo
    126  f000				  -	      lda	#>HSRAMInitials
    127  f000				  -	      sta	temp2	; charmaphi
    128  f000				  -	      lda	#32+29	; palette=0-29 | 32-(width=3)
    129  f000				  -	      sta	temp3	; palette/width
    130  f000				  -	      lda	#104
    131  f000				  -	      sta	temp4	; X
    132  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    133  f000				  -	      sta	temp5	; Y
    134  f000				  -plothsinitialsloop
    135  f000				  -	      jsr	plotcharacters
    136  f000				  -	      clc
    137  f000				  -	      lda	temp3
    138  f000				  -	      adc	#32
    139  f000				  -	      sta	temp3
    140  f000				  -	      inc	temp5
    141  f000				  -	      if	WZONEHEIGHT = 8
    142  f000				  -	      inc	temp5
    143  f000				  -	      endif
    144  f000				  -	      clc
    145  f000				  -	      lda	#3
    146  f000				  -	      adc	temp1
    147  f000				  -	      sta	temp1
    148  f000				  -	      cmp	#(<(HSRAMInitials+15))
    149  f000				  -	      bcc	plothsinitialsloop
    150  f000				  -
    151  f000				  -	      ifconst	HSGAMENAMELEN
    152  f000				  -			;plot the game name...
    153  f000				  -	      lda	#<HSGAMENAMEtable
    154  f000				  -	      sta	temp1	; charmaplo
    155  f000				  -	      lda	#>HSGAMENAMEtable
    156  f000				  -	      sta	temp2	; charmaphi
    157  f000				  -	      lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    158  f000				  -	      sta	temp3	; palette/width
    159  f000				  -	      lda	#(80-(HSGAMENAMELEN*2))
    160  f000				  -	      sta	temp4	; X
    161  f000				  -	      lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    162  f000				  -	      sta	temp5	; Y
    163  f000				  -	      jsr	plotcharacters
    164  f000				  -	      endif		; HSGAMENAMELEN
    165  f000				  -
    166  f000				  -			;plot "difficulty"...
    167  f000				  -	      ldy	gamedifficulty
    168  f000				  -	      ifnconst	HSNOLEVELNAMES
    169  f000				  -	      lda	highscoredifficultytextlo,y
    170  f000				  -	      sta	temp1
    171  f000				  -	      lda	highscoredifficultytexthi,y
    172  f000				  -	      sta	temp2
    173  f000				  -	      sec
    174  f000				  -	      lda	#32
    175  f000				  -	      sbc	highscoredifficultytextlen,y
    176  f000				  -	      sta	temp3	; palette/width
    177  f000				  -	      sec
    178  f000				  -	      lda	#40
    179  f000				  -	      sbc	highscoredifficultytextlen,y
    180  f000				  -	      asl
    181  f000				  -	      sta	temp4	; X
    182  f000				  -	      else
    183  f000				  -	      lda	#<HSHIGHSCOREStext
    184  f000				  -	      sta	temp1	; charmaplo
    185  f000				  -	      lda	#>HSHIGHSCOREStext
    186  f000				  -	      sta	temp2	; charmaphi
    187  f000				  -	      lda	#(32-11)	; palette=0*29 | 32-(width=3)
    188  f000				  -	      sta	temp3	; palette/width
    189  f000				  -	      lda	#(80-(11*2))
    190  f000				  -	      sta	temp4	; X
    191  f000				  -	      endif		; HSNOLEVELNAMES
    192  f000				  -
    193  f000				  -	      lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    194  f000				  -	      sta	temp5	; Y
    195  f000				  -	      jsr	plotcharacters
    196  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    197  f000				  -	      bne	carronwithscoreevaluation
    198  f000				  -	      jmp	donoscoreevaluation
    199  f000				  -carronwithscoreevaluation
    200  f000				  -	      dey
    201  f000				  -	      lda	highscorelabeltextlo,y
    202  f000				  -	      sta	temp1
    203  f000				  -	      lda	highscorelabeltexthi,y
    204  f000				  -	      sta	temp2
    205  f000				  -	      sec
    206  f000				  -	      lda	#(32-15)	; palette=0*29 | 32-(width=3)
    207  f000				  -	      sta	temp3	; palette/width
    208  f000				  -	      lda	highscorelabeladjust1,y
    209  f000				  -	      sta	temp4	; X
    210  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    211  f000				  -	      sta	temp5	; Y
    212  f000				  -	      jsr	plotcharacters
    213  f000				  -
    214  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    215  f000				  -	      dey
    216  f000				  -			;plot the current player score...
    217  f000				  -	      lda	#(32-SCORESIZE)	; palette=0*32
    218  f000				  -	      sta	temp3	; palette/width
    219  f000				  -	      lda	highscorelabeladjust2,y
    220  f000				  -	      sta	temp4	; X
    221  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    222  f000				  -	      sta	temp5	; Y
    223  f000				  -
    224  f000				  -	      lda	scorevarlo,y
    225  f000				  -	      sta	temp7	; score variable lo
    226  f000				  -	      lda	scorevarhi,y
    227  f000				  -	      sta	temp8	; score variable hi
    228  f000				  -
    229  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    230  f000				  -	      sta	temp9
    231  f000				  -
    232  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    233  f000				  -	      sta	temp1	; charmaplo
    234  f000				  -	      lda	#>(hiscorefont+33)
    235  f000				  -	      sta	temp2	; charmaphi
    236  f000				  -	      lda	#SCORESIZE
    237  f000				  -	      sta	temp6
    238  f000				  -	      ifnconst	DOUBLEWIDE
    239  f000				  -	      jsr	plotvalue
    240  f000				  -	      else
    241  f000				  -	      jsr	plotvaluedw
    242  f000				  -	      endif
    243  f000				  -
    244  f000				  -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    245  f000				  -
    246  f000				  -	      ifconst	HSGAMERANKS
    247  f000				  -
    248  f000				  -	      ldx	#$ff	; start at 0 after the inx...
    249  f000				  -comparescore2rankloop
    250  f000				  -	      inx
    251  f000				  -	      ldy	#0
    252  f000				  -	      lda	rankvalue_0,x
    253  f000				  -	      cmp	(temp7),y
    254  f000				  -	      bcc	score2rankloopdone
    255  f000				  -	      bne	comparescore2rankloop
    256  f000				  -	      iny
    257  f000				  -	      lda	rankvalue_1,x
    258  f000				  -	      cmp	(temp7),y
    259  f000				  -	      bcc	score2rankloopdone
    260  f000				  -	      bne	comparescore2rankloop
    261  f000				  -	      iny
    262  f000				  -	      lda	(temp7),y
    263  f000				  -	      cmp	rankvalue_2,x
    264  f000				  -	      bcs	score2rankloopdone
    265  f000				  -	      jmp	comparescore2rankloop
    266  f000				  -score2rankloopdone
    267  f000				  -	      stx	hsnewscorerank
    268  f000				  -
    269  f000				  -	      lda	ranklabello,x
    270  f000				  -	      sta	temp1
    271  f000				  -	      lda	ranklabelhi,x
    272  f000				  -	      sta	temp2
    273  f000				  -	      sec
    274  f000				  -	      lda	#32	; palette=0*29 | 32-(width=3)
    275  f000				  -	      sbc	ranklabellengths,x
    276  f000				  -	      sta	temp3	; palette/width
    277  f000				  -	      sec
    278  f000				  -	      lda	#(40+6)
    279  f000				  -	      sbc	ranklabellengths,x
    280  f000				  -	      asl
    281  f000				  -	      sta	temp4	; X
    282  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    283  f000				  -	      sta	temp5	; Y
    284  f000				  -	      jsr	plotcharacters
    285  f000				  -
    286  f000				  -	      ldx	hsnewscorerank
    287  f000				  -
    288  f000				  -	      lda	#<highscoreranklabel
    289  f000				  -	      sta	temp1
    290  f000				  -	      lda	#>highscoreranklabel
    291  f000				  -	      sta	temp2
    292  f000				  -
    293  f000				  -	      lda	#(32-5)	; palette=0*29 | 32-(width=3)
    294  f000				  -	      sta	temp3	; palette/width
    295  f000				  -	      lda	#(40-6)
    296  f000				  -	      sec
    297  f000				  -	      sbc	ranklabellengths,x
    298  f000				  -	      asl
    299  f000				  -	      sta	temp4	; X
    300  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    301  f000				  -	      sta	temp5	; Y
    302  f000				  -	      jsr	plotcharacters
    303  f000				  -	      endif
    304  f000				  -
    305  f000				  -
    306  f000				  -			; ** which line did this player beat?
    307  f000				  -	      lda	#$ff
    308  f000				  -	      sta	hsnewscoreline
    309  f000				  -	      ldx	#$fd
    310  f000				  -comparescoreadd2x
    311  f000				  -	      inx
    312  f000				  -comparescoreadd1x
    313  f000				  -	      inx
    314  f000				  -comparescore2lineloop
    315  f000				  -	      inc	hsnewscoreline
    316  f000				  -	      inx		; initialrun, x=0
    317  f000				  -	      cpx	#15
    318  f000				  -	      beq	nohighscoreforyou
    319  f000				  -	      ldy	#0
    320  f000				  -	      lda	HSRAMScores,x
    321  f000				  -	      cmp	(temp7),y	; first score digit
    322  f000				  -	      bcc	score2lineloopdonedel1x
    323  f000				  -	      bne	comparescoreadd2x
    324  f000				  -	      iny
    325  f000				  -	      inx
    326  f000				  -	      lda	HSRAMScores,x
    327  f000				  -	      cmp	(temp7),y
    328  f000				  -	      bcc	score2lineloopdonedel2x
    329  f000				  -	      bne	comparescoreadd1x
    330  f000				  -	      iny
    331  f000				  -	      inx
    332  f000				  -	      lda	(temp7),y
    333  f000				  -	      cmp	HSRAMScores,x
    334  f000				  -	      bcs	score2lineloopdonedel3x
    335  f000				  -	      jmp	comparescore2lineloop
    336  f000				  -nohighscoreforyou
    337  f000				  -	      lda	#$ff
    338  f000				  -	      sta	hsnewscoreline
    339  f000				  -	      sta	countdownseconds
    340  f000				  -	      jmp	donoscoreevaluation
    341  f000				  -score2lineloopdonedel3x
    342  f000				  -	      dex
    343  f000				  -score2lineloopdonedel2x
    344  f000				  -	      dex
    345  f000				  -score2lineloopdonedel1x
    346  f000				  -	      dex
    347  f000				  -
    348  f000				  -			; 0 1 2
    349  f000				  -			; 3 4 5
    350  f000				  -			; 6 7 8
    351  f000				  -			; 9 0 1
    352  f000				  -			; 2 3 4
    353  f000				  -
    354  f000				  -	      stx	temp9
    355  f000				  -	      cpx	#11
    356  f000				  -	      beq	postsortscoresuploop
    357  f000				  -	      ldx	#11
    358  f000				  -sortscoresuploop
    359  f000				  -	      lda	HSRAMScores,x
    360  f000				  -	      sta	HSRAMScores+3,x
    361  f000				  -	      lda	HSRAMInitials,x
    362  f000				  -	      sta	HSRAMInitials+3,x
    363  f000				  -	      dex
    364  f000				  -	      cpx	temp9
    365  f000				  -	      bne	sortscoresuploop
    366  f000				  -postsortscoresuploop
    367  f000				  -
    368  f000				  -			;stick the score and cleared initials in the slot...
    369  f000				  -	      inx
    370  f000				  -	      ldy	#0
    371  f000				  -	      sty	hsinitialhold
    372  f000				  -	      lda	(temp7),y
    373  f000				  -	      sta	HSRAMScores,x
    374  f000				  -	      iny
    375  f000				  -	      lda	(temp7),y
    376  f000				  -	      sta	HSRAMScores+1,x
    377  f000				  -	      iny
    378  f000				  -	      lda	(temp7),y
    379  f000				  -	      sta	HSRAMScores+2,x
    380  f000				  -	      lda	#0
    381  f000				  -	      sta	HSRAMInitials,x
    382  f000				  -	      lda	#29
    383  f000				  -	      sta	HSRAMInitials+1,x
    384  f000				  -	      sta	HSRAMInitials+2,x
    385  f000				  -
    386  f000				  -	      stx	hsinitialpos
    387  f000				  -
    388  f000				  -	      ifconst	vox_highscore
    389  f000				  -	      lda	<#vox_highscore
    390  f000				  -	      sta	speech_addr
    391  f000				  -	      lda	>#vox_highscore
    392  f000				  -	      sta	speech_addr+1
    393  f000				  -	      endif
    394  f000				  -	      ifconst	sfx_highscore
    395  f000				  -	      lda	<#sfx_highscore
    396  f000				  -	      sta	temp1
    397  f000				  -	      lda	>#sfx_highscore
    398  f000				  -	      sta	temp2
    399  f000				  -	      lda	#0
    400  f000				  -	      sta	temp3
    401  f000				  -	      jsr	schedulesfx
    402  f000				  -	      endif
    403  f000				  -	      ifconst	songdatastart_song_highscore
    404  f000				  -	      lda	#<songchanneltable_song_highscore
    405  f000				  -	      sta	songpointerlo
    406  f000				  -	      lda	#>songchanneltable_song_highscore
    407  f000				  -	      sta	songpointerhi
    408  f000				  -	      lda	#73
    409  f000				  -	      sta	songtempo
    410  f000				  -	      jsr	setsongchannels
    411  f000				  -	      endif
    412  f000				  -
    413  f000				  -
    414  f000				  -donoscoreevaluation
    415  f000				  -
    416  f000				  -	      lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    417  f000				  -	      sta	temp3	; palette/width
    418  f000				  -	      lda	#(72+(4*(6-SCORESIZE)))
    419  f000				  -	      sta	temp4	; X
    420  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    421  f000				  -	      sta	temp5	; Y
    422  f000				  -	      lda	#<HSRAMScores
    423  f000				  -	      sta	temp7	; score variable lo
    424  f000				  -	      lda	#>HSRAMScores
    425  f000				  -	      sta	temp8	; score variable hi
    426  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    427  f000				  -	      sta	temp9
    428  f000				  -plothsscoresloop
    429  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    430  f000				  -	      sta	temp1	; charmaplo
    431  f000				  -	      lda	#>(hiscorefont+33)
    432  f000				  -	      sta	temp2	; charmaphi
    433  f000				  -	      lda	#6
    434  f000				  -	      sta	temp6
    435  f000				  -	      ifnconst	DOUBLEWIDE
    436  f000				  -	      jsr	plotvalue
    437  f000				  -	      else
    438  f000				  -	      jsr	plotvaluedw
    439  f000				  -	      endif
    440  f000				  -	      clc
    441  f000				  -	      lda	temp3
    442  f000				  -	      adc	#32
    443  f000				  -	      sta	temp3
    444  f000				  -	      inc	temp5
    445  f000				  -	      if	WZONEHEIGHT = 8
    446  f000				  -	      inc	temp5
    447  f000				  -	      endif
    448  f000				  -	      clc
    449  f000				  -	      lda	#3
    450  f000				  -	      adc	temp7
    451  f000				  -	      sta	temp7
    452  f000				  -	      cmp	#(<(HSRAMScores+15))
    453  f000				  -	      bcc	plothsscoresloop
    454  f000				  -plothsindex
    455  f000				  -	      lda	#32+31	; palette=0*32 | 32-(width=1)
    456  f000				  -	      sta	temp3	; palette/width
    457  f000				  -	      lda	#44
    458  f000				  -	      sta	temp4	; X
    459  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    460  f000				  -	      sta	temp5	; Y
    461  f000				  -	      lda	#<hsgameslotnumbers
    462  f000				  -	      sta	temp7	; score variable lo
    463  f000				  -	      lda	#>hsgameslotnumbers
    464  f000				  -	      sta	temp8	; score variable hi
    465  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    466  f000				  -	      sta	temp9
    467  f000				  -plothsindexloop
    468  f000				  -	      lda	#<(hiscorefont+33)
    469  f000				  -	      sta	temp1	; charmaplo
    470  f000				  -	      lda	#>(hiscorefont+33)
    471  f000				  -	      sta	temp2	; charmaphi
    472  f000				  -	      lda	#1
    473  f000				  -	      sta	temp6	; number of characters
    474  f000				  -	      ifnconst	DOUBLEWIDE
    475  f000				  -	      jsr	plotvalue
    476  f000				  -	      else
    477  f000				  -	      jsr	plotvaluedw
    478  f000				  -	      endif
    479  f000				  -	      clc
    480  f000				  -	      lda	temp3
    481  f000				  -	      adc	#32
    482  f000				  -	      sta	temp3
    483  f000				  -	      inc	temp5
    484  f000				  -	      if	WZONEHEIGHT = 8
    485  f000				  -	      inc	temp5
    486  f000				  -	      endif
    487  f000				  -	      inc	temp7
    488  f000				  -	      lda	temp7
    489  f000				  -	      cmp	#(<(hsgameslotnumbers+5))
    490  f000				  -	      bcc	plothsindexloop
    491  f000				  -
    492  f000				  -	      jsr	savescreen
    493  f000				  -	      ifnconst	HSSECONDS
    494  f000				  -	      lda	#6
    495  f000				  -	      else
    496  f000				  -	      lda	#HSSECONDS
    497  f000				  -	      endif
    498  f000				  -
    499  f000				  -	      sta	countdownseconds
    500  f000				  -
    501  f000				  -keepdisplayinghs
    502  f000				  -	      jsr	restorescreen
    503  f000				  -
    504  f000				  -	      jsr	setuphsinpt1
    505  f000				  -
    506  f000				  -	      lda	hsnewscoreline
    507  f000				  -	      bpl	carryonkeepdisplayinghs
    508  f000				  -	      jmp	skipenterscorecontrol
    509  f000				  -carryonkeepdisplayinghs
    510  f000				  -
    511  f000				  -
    512  f000				  -	      ifnconst	HSSECONDS
    513  f000				  -	      lda	#6
    514  f000				  -	      else
    515  f000				  -	      lda	#HSSECONDS
    516  f000				  -	      endif
    517  f000				  -
    518  f000				  -	      sta	countdownseconds
    519  f000				  -
    520  f000				  -			;plot the "cursor" initial sprite...
    521  f000				  -	      lda	hsinitialhold
    522  f000				  -
    523  f000				  -	      sta	temp1
    524  f000				  -	      lda	#>(hiscorefont+32)
    525  f000				  -	      sta	temp2
    526  f000				  -	      lda	#31	; palette=0*32 | 32-(width=1)
    527  f000				  -	      sta	temp3	; palette/width
    528  f000				  -	      lda	hscursorx
    529  f000				  -	      asl
    530  f000				  -	      asl
    531  f000				  -	      clc
    532  f000				  -	      adc	#104
    533  f000				  -	      sta	temp4	; X
    534  f000				  -	      lda	hsnewscoreline
    535  f000				  -	      asl
    536  f000				  -	      asl
    537  f000				  -	      asl
    538  f000				  -	      asl
    539  f000				  -	      adc	#((3*16)+HSCURSORY)
    540  f000				  -	      sta	temp5	; Y
    541  f000				  -	      lda	#%01000000
    542  f000				  -	      sta	temp6
    543  f000				  -	      jsr	plotsprite
    544  f000				  -
    545  f000				  -	      ldx	hscursorx
    546  f000				  -	      ldy	hsdisplaymode
    547  f000				  -	      lda	SWCHA
    548  f000				  -	      cpy	#3
    549  f000				  -	      bne	hsskipadjustjoystick1
    550  f000				  -	      asl
    551  f000				  -	      asl
    552  f000				  -	      asl
    553  f000				  -	      asl
    554  f000				  -hsskipadjustjoystick1
    555  f000				  -	      sta	hsswcha
    556  f000				  -	      and	#%00110000
    557  f000				  -	      cmp	#%00110000
    558  f000				  -	      beq	hsjoystickskipped
    559  f000				  -	      lda	hsjoydebounce
    560  f000				  -	      beq	hsdontdebounce
    561  f000				  -	      jmp	hspostjoystick
    562  f000				  -hsdontdebounce
    563  f000				  -	      ldx	#1	; small tick sound
    564  f000				  -	      jsr	playhssfx
    565  f000				  -	      lda	hsswcha
    566  f000				  -	      and	#%00110000
    567  f000				  -	      ldx	hscursorx
    568  f000				  -	      cmp	#%00100000	; check down
    569  f000				  -	      bne	hsjoycheckup
    570  f000				  -	      ldy	hsinitialhold
    571  f000				  -	      cpx	#0
    572  f000				  -	      bne	skipavoid31_1
    573  f000				  -	      cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    574  f000				  -	      bne	skipavoid31_1
    575  f000				  -	      dey
    576  f000				  -skipavoid31_1
    577  f000				  -	      dey
    578  f000				  -	      jmp	hssetdebounce
    579  f000				  -hsjoycheckup
    580  f000				  -	      cmp	#%00010000	; check up
    581  f000				  -	      bne	hsjoystickskipped
    582  f000				  -	      ldy	hsinitialhold
    583  f000				  -	      cpx	#0
    584  f000				  -	      bne	skipavoid31_2
    585  f000				  -	      cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    586  f000				  -	      bne	skipavoid31_2
    587  f000				  -	      iny
    588  f000				  -skipavoid31_2
    589  f000				  -	      iny
    590  f000				  -hssetdebounce
    591  f000				  -	      tya
    592  f000				  -	      and	#31
    593  f000				  -	      sta	hsinitialhold
    594  f000				  -	      lda	#15
    595  f000				  -	      sta	hsjoydebounce
    596  f000				  -	      bne	hspostjoystick
    597  f000				  -hsjoystickskipped
    598  f000				  -			; check the fire button only when the stick isn't engaged
    599  f000				  -	      lda	hsinpt1
    600  f000				  -	      bpl	hsbuttonskipped
    601  f000				  -	      lda	hsjoydebounce
    602  f000				  -	      beq	hsfiredontdebounce
    603  f000				  -	      bne	hspostjoystick
    604  f000				  -hsfiredontdebounce
    605  f000				  -	      lda	hsinitialhold
    606  f000				  -	      cmp	#31
    607  f000				  -	      beq	hsmovecursorback
    608  f000				  -	      inc	hscursorx
    609  f000				  -	      inc	hsinitialpos
    610  f000				  -	      lda	hscursorx
    611  f000				  -	      cmp	#3
    612  f000				  -	      bne	skiphsentryisdone
    613  f000				  -	      lda	#0
    614  f000				  -	      sta	framecounter
    615  f000				  -	      lda	#$ff
    616  f000				  -	      sta	hsnewscoreline
    617  f000				  -	      dec	hsinitialpos
    618  f000				  -	      bne	skiphsentryisdone
    619  f000				  -hsmovecursorback
    620  f000				  -	      lda	hscursorx
    621  f000				  -	      beq	skiphsmovecursorback
    622  f000				  -	      lda	#29
    623  f000				  -	      ldx	hsinitialpos
    624  f000				  -	      sta	HSRAMInitials,x
    625  f000				  -	      dec	hsinitialpos
    626  f000				  -	      dec	hscursorx
    627  f000				  -	      dex
    628  f000				  -	      lda	HSRAMInitials,x
    629  f000				  -	      sta	hsinitialhold
    630  f000				  -skiphsmovecursorback
    631  f000				  -skiphsentryisdone
    632  f000				  -	      ldx	#0
    633  f000				  -	      jsr	playhssfx
    634  f000				  -	      lda	#20
    635  f000				  -	      sta	hsjoydebounce
    636  f000				  -	      bne	hspostjoystick
    637  f000				  -
    638  f000				  -hsbuttonskipped
    639  f000				  -	      lda	#0
    640  f000				  -	      sta	hsjoydebounce
    641  f000				  -hspostjoystick
    642  f000				  -
    643  f000				  -	      ldx	hsinitialpos
    644  f000				  -	      lda	hsinitialhold
    645  f000				  -	      sta	HSRAMInitials,x
    646  f000				  -
    647  f000				  -	      jmp	skiphschasecolors
    648  f000				  -
    649  f000				  -skipenterscorecontrol
    650  f000				  -	      jsr	hschasecolors
    651  f000				  -	      jsr	setuphsinpt1
    652  f000				  -	      lda	hsjoydebounce
    653  f000				  -	      bne	skiphschasecolors
    654  f000				  -	      lda	hsinpt1
    655  f000				  -	      bmi	returnfromhs
    656  f000				  -skiphschasecolors
    657  f000				  -
    658  f000				  -	      jsr	drawscreen
    659  f000				  -
    660  f000				  -	      lda	countdownseconds
    661  f000				  -	      beq	returnfromhs
    662  f000				  -	      jmp	keepdisplayinghs
    663  f000				  -returnfromhs
    664  f000				  -
    665  f000				  -	      ifconst	songdatastart_song_highscore
    666  f000				  -	      lda	hsdisplaymode
    667  f000				  -	      beq	skipclearHSCsong
    668  f000				  -	      lda	#0
    669  f000				  -	      sta	songtempo
    670  f000				  -skipclearHSCsong
    671  f000				  -	      endif
    672  f000				  -	      jsr	drawwait
    673  f000				  -	      jsr	clearscreen
    674  f000				  -	      lda	#0
    675  f000				  -	      ldy	#7
    676  f000				  -	      jsr	blacken320colors
    677  f000				  -	      lda	ssCTRL
    678  f000				  -	      sta	sCTRL
    679  f000				  -	      lda	ssCHARBASE
    680  f000				  -	      sta	sCHARBASE
    681  f000				  -	      rts
    682  f000				  -
    683  f000				  -setuphsinpt1
    684  f000				  -	      lda	#$ff
    685  f000				  -	      sta	hsinpt1
    686  f000				  -	      lda	hsjoydebounce
    687  f000				  -	      beq	skipdebounceadjust
    688  f000				  -	      dec	hsjoydebounce
    689  f000				  -	      bne	skipstorefirebuttonstatus
    690  f000				  -skipdebounceadjust
    691  f000				  -	      ldx	hsdisplaymode
    692  f000				  -	      cpx	#3
    693  f000				  -	      bne	hsskipadjustjoyfire1
    694  f000				  -	      lda	sINPT3
    695  f000				  -	      jmp	hsskipadjustjoyfire1done
    696  f000				  -hsskipadjustjoyfire1
    697  f000				  -	      lda	sINPT1
    698  f000				  -hsskipadjustjoyfire1done
    699  f000				  -	      sta	hsinpt1
    700  f000				  -skipstorefirebuttonstatus
    701  f000				  -	      rts
    702  f000				  -
    703  f000				  -blacken320colors
    704  f000				  -	      ldy	#7
    705  f000				  -blacken320colorsloop
    706  f000				  -	      sta	P0C2,y
    707  f000				  -	      dey
    708  f000				  -	      bpl	blacken320colorsloop
    709  f000				  -	      rts
    710  f000				  -
    711  f000				  -hschasecolors
    712  f000				  -	      lda	framecounter
    713  f000				  -	      and	#3
    714  f000				  -	      bne	hschasecolorsreturn
    715  f000				  -	      inc	hscolorchaseindex
    716  f000				  -	      lda	hscolorchaseindex
    717  f000				  -
    718  f000				  -	      sta	P5C2
    719  f000				  -	      sbc	#$02
    720  f000				  -	      sta	P4C2
    721  f000				  -	      sbc	#$02
    722  f000				  -	      sta	P3C2
    723  f000				  -	      sbc	#$02
    724  f000				  -	      sta	P2C2
    725  f000				  -	      sbc	#$02
    726  f000				  -	      sta	P1C2
    727  f000				  -hschasecolorsreturn
    728  f000				  -	      rts
    729  f000				  -
    730  f000				  -playhssfx
    731  f000				  -	      lda	hssfx_lo,x
    732  f000				  -	      sta	temp1
    733  f000				  -	      lda	hssfx_hi,x
    734  f000				  -	      sta	temp2
    735  f000				  -	      lda	#0
    736  f000				  -	      sta	temp3
    737  f000				  -	      jmp	schedulesfx
    738  f000				  -
    739  f000				  -hssfx_lo
    740  f000				  -	      .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    741  f000				  -hssfx_hi
    742  f000				  -	      .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    743  f000				  -
    744  f000				  -sfx_hsletterpositionchange
    745  f000				  -	      .byte	$10,$18,$00
    746  f000				  -	      .byte	$02,$06,$08
    747  f000				  -	      .byte	$02,$06,$04
    748  f000				  -	      .byte	$00,$00,$00
    749  f000				  -sfx_hslettertick
    750  f000				  -	      .byte	$10,$18,$00
    751  f000				  -	      .byte	$00,$00,$0a
    752  f000				  -	      .byte	$00,$00,$00
    753  f000				  -
    754  f000				  -highscorelabeladjust1
    755  f000				  -	      .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    756  f000				  -highscorelabeladjust2
    757  f000				  -	      .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    758  f000				  -
    759  f000				  -scorevarlo
    760  f000				  -	      .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    761  f000				  -scorevarhi
    762  f000				  -	      .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    763  f000				  -
    764  f000				  -	      ifnconst	HSNOLEVELNAMES
    765  f000				  -highscoredifficultytextlo
    766  f000				  -	      .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    767  f000				  -highscoredifficultytexthi
    768  f000				  -	      .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    769  f000				  -	      ifnconst	HSCUSTOMLEVELNAMES
    770  f000				  -highscoredifficultytextlen
    771  f000				  -	      .byte	22, 30, 26, 24
    772  f000				  -
    773  f000				  -easylevelname
    774  f000				  -	      .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    775  f000				  -mediumlevelname
    776  f000				  -	      .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    777  f000				  -hardlevelname
    778  f000				  -	      .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    779  f000				  -expertlevelname
    780  f000				  -	      .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    781  f000				  -	      else
    782  f000				  -	      include	"7800hsgamediffnames.asm"
    783  f000				  -	      endif		; HSCUSTOMLEVELNAMES
    784  f000				  -	      else
    785  f000				  -HSHIGHSCOREStext
    786  f000				  -	      .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    787  f000				  -	      endif		; HSNOLEVELNAMES
    788  f000				  -
    789  f000				  -highscorelabeltextlo
    790  f000				  -	      .byte	<player0label, <player1label, <player2label
    791  f000				  -highscorelabeltexthi
    792  f000				  -	      .byte	>player0label, >player1label, >player2label
    793  f000				  -
    794  f000				  -player0label
    795  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    796  f000				  -
    797  f000				  -player1label
    798  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    799  f000				  -
    800  f000				  -player2label
    801  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    802  f000				  -
    803  f000				  -
    804  f000				  -	      ifconst	HSGAMENAMELEN
    805  f000				  -HSGAMENAMEtable
    806  f000				  -	      include	"7800hsgamename.asm"
    807  f000				  -	      endif
    808  f000				  -	      ifconst	HSGAMERANKS
    809  f000				  -	      include	"7800hsgameranks.asm"
    810  f000				  -highscoreranklabel
    811  f000				  -	      .byte	$11,$00,$0d,$0a,$1a
    812  f000				  -	      endif
    813  f000				  -
    814  f000				  -			;ensure our table doesn't wrap a page...
    815  f000				  -	      if	((<*)>251)
    816  f000				  -	      align	256
    817  f000				  -	      endif
    818  f000				  -hsgameslotnumbers
    819  f000				  -	      .byte	33,34,35,36,37
    820  f000				  -	      endif
    821  f000				  -
    822  f000				  -loaddifficultytable
    823  f000				  -	      lda	gamedifficulty
    824  f000				  -	      and	#$03	; ensure the user hasn't selected an invalid difficulty
    825  f000				  -	      sta	gamedifficulty
    826  f000				  -	      cmp	hsdifficulty	; check game difficulty is the same as RAM table
    827  f000				  -	      bne	loaddifficultytablecontinue1
    828  f000				  -	      rts		; this high score difficulty table is already loaded
    829  f000				  -loaddifficultytablecontinue1
    830  f000				  -	      lda	gamedifficulty
    831  f000				  -	      sta	hsdifficulty
    832  f000				  -			;we need to check the device for the table
    833  f000				  -	      lda	hsdevice
    834  f000				  -	      bne	loaddifficultytablecontinue2
    835  f000				  -			; there's no save device. clear out this table.
    836  f000				  -	      jmp	cleardifficultytablemem
    837  f000				  -loaddifficultytablecontinue2
    838  f000				  -	      lda	hsdevice
    839  f000				  -	      and	#1
    840  f000				  -	      beq	memdeviceisntHSC
    841  f000				  -	      jmp	loaddifficultytableHSC
    842  f000				  -memdeviceisntHSC
    843  f000				  -	      jmp	loaddifficultytableAVOX
    844  f000				  -
    845  f000				  -savedifficultytable
    846  f000				  -			;*** we need to check wich device we should use...
    847  f000				  -	      lda	hsdevice
    848  f000				  -	      bne	savedifficultytablerealdevice
    849  f000				  -	      rts		; its a ram device
    850  f000				  -savedifficultytablerealdevice
    851  f000				  -	      and	#1
    852  f000				  -	      beq	savememdeviceisntHSC
    853  f000				  -	      jmp	savedifficultytableHSC
    854  f000				  -savememdeviceisntHSC
    855  f000				  -	      jmp	savedifficultytableAVOX
    856  f000				  -
    857  f000				  -savedifficultytableAVOX
    858  f000				  -			; the load call already setup the memory structure and atarivox memory location
    859  f000				  -	      jsr	savealoadedHSCtablecontinue
    860  f000				  -savedifficultytableAVOXskipconvert
    861  f000				  -	      lda	#HSIDHI
    862  f000				  -	      sta	eeprombuffer
    863  f000				  -	      lda	#HSIDLO
    864  f000				  -	      sta	eeprombuffer+1
    865  f000				  -	      lda	hsdifficulty
    866  f000				  -	      sta	eeprombuffer+2
    867  f000				  -	      lda	#32
    868  f000				  -	      jsr	AVoxWriteBytes
    869  f000				  -	      rts
    870  f000				  -
    871  f000				  -savedifficultytableHSC
    872  f000				  -			;we always load a table before reaching here, so the
    873  f000				  -			;memory structures from the load should be intact...
    874  f000				  -	      ldy	hsgameslot
    875  f000				  -	      bpl	savealoadedHSCtable
    876  f000				  -	      rts
    877  f000				  -savealoadedHSCtable
    878  f000				  -	      lda	HSCGameDifficulty,y
    879  f000				  -	      cmp	#$7F
    880  f000				  -	      bne	savealoadedHSCtablecontinue
    881  f000				  -	      jsr	initializeHSCtableentry
    882  f000				  -savealoadedHSCtablecontinue
    883  f000				  -			;convert our RAM table to HSC format and write it out...
    884  f000				  -	      ldy	#0
    885  f000				  -	      ldx	#0
    886  f000				  -savedifficultytableScores
    887  f000				  -
    888  f000				  -	      lda	HSRAMInitials,x
    889  f000				  -	      sta	temp3
    890  f000				  -	      lda	HSRAMInitials+1,x
    891  f000				  -	      sta	temp4
    892  f000				  -	      lda	HSRAMInitials+2,x
    893  f000				  -	      sta	temp5
    894  f000				  -	      jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    895  f000				  -
    896  f000				  -	      lda	temp1
    897  f000				  -	      sta	(HSGameTableLo),y
    898  f000				  -	      iny
    899  f000				  -	      lda	temp2
    900  f000				  -	      sta	(HSGameTableLo),y
    901  f000				  -	      iny
    902  f000				  -
    903  f000				  -	      lda	HSRAMScores,x
    904  f000				  -	      sta	(HSGameTableLo),y
    905  f000				  -	      iny
    906  f000				  -	      lda	HSRAMScores+1,x
    907  f000				  -	      sta	(HSGameTableLo),y
    908  f000				  -	      iny
    909  f000				  -	      lda	HSRAMScores+2,x
    910  f000				  -	      sta	(HSGameTableLo),y
    911  f000				  -	      iny
    912  f000				  -	      inx
    913  f000				  -	      inx
    914  f000				  -	      inx		; +3
    915  f000				  -	      cpx	#15
    916  f000				  -	      bne	savedifficultytableScores
    917  f000				  -	      rts
    918  f000				  -
    919  f000				  -loaddifficultytableHSC
    920  f000				  -			; routine responsible for loading the difficulty table from HSC
    921  f000				  -	      jsr	findindexHSC
    922  f000				  -	      ldy	hsgameslot
    923  f000				  -	      lda	HSCGameDifficulty,y
    924  f000				  -	      cmp	#$7F
    925  f000				  -	      bne	loaddifficultytableHSCcontinue
    926  f000				  -			;there was an error. use a new RAM table instead...
    927  f000				  -	      jmp	cleardifficultytablemem
    928  f000				  -loaddifficultytableHSCcontinue
    929  f000				  -			; parse the data into the HS memory...
    930  f000				  -	      ldy	#0
    931  f000				  -	      ldx	#0
    932  f000				  -loaddifficultytableScores
    933  f000				  -	      lda	(HSGameTableLo),y
    934  f000				  -	      sta	temp1
    935  f000				  -	      iny
    936  f000				  -	      lda	(HSGameTableLo),y
    937  f000				  -	      sta	temp2
    938  f000				  -	      jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    939  f000				  -	      iny
    940  f000				  -	      lda	(HSGameTableLo),y
    941  f000				  -	      sta	HSRAMScores,x
    942  f000				  -	      lda	temp3
    943  f000				  -	      sta	HSRAMInitials,x
    944  f000				  -	      inx
    945  f000				  -	      iny
    946  f000				  -	      lda	(HSGameTableLo),y
    947  f000				  -	      sta	HSRAMScores,x
    948  f000				  -	      lda	temp4
    949  f000				  -	      sta	HSRAMInitials,x
    950  f000				  -	      inx
    951  f000				  -	      iny
    952  f000				  -	      lda	(HSGameTableLo),y
    953  f000				  -	      sta	HSRAMScores,x
    954  f000				  -	      lda	temp5
    955  f000				  -	      sta	HSRAMInitials,x
    956  f000				  -	      inx
    957  f000				  -	      iny
    958  f000				  -	      cpx	#15
    959  f000				  -	      bne	loaddifficultytableScores
    960  f000				  -	      rts
    961  f000				  -
    962  f000				  -decodeHSCInitials
    963  f000				  -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    964  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
    965  f000				  -	      lda	#0
    966  f000				  -	      sta	temp4
    967  f000				  -	      lda	temp1
    968  f000				  -	      and	#%00011111
    969  f000				  -	      sta	temp3
    970  f000				  -
    971  f000				  -	      lda	temp2
    972  f000				  -	      and	#%00011111
    973  f000				  -	      sta	temp5
    974  f000				  -
    975  f000				  -	      lda	temp1
    976  f000				  -	      asl
    977  f000				  -	      rol	temp4
    978  f000				  -	      asl
    979  f000				  -	      rol	temp4
    980  f000				  -	      asl
    981  f000				  -	      rol	temp4
    982  f000				  -	      lda	temp2
    983  f000				  -	      asl
    984  f000				  -	      rol	temp4
    985  f000				  -	      asl
    986  f000				  -	      rol	temp4
    987  f000				  -	      rts
    988  f000				  -encodeHSCInitials
    989  f000				  -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    990  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
    991  f000				  -			; start with packing temp1...
    992  f000				  -	      lda	temp4
    993  f000				  -	      and	#%00011100
    994  f000				  -	      sta	temp1
    995  f000				  -	      asl	temp1
    996  f000				  -	      asl	temp1
    997  f000				  -	      asl	temp1
    998  f000				  -	      lda	temp3
    999  f000				  -	      and	#%00011111
   1000  f000				  -	      ora	temp1
   1001  f000				  -	      sta	temp1
   1002  f000				  -			; ...temp1 is now packed, on to temp2...
   1003  f000				  -	      lda	temp5
   1004  f000				  -	      asl
   1005  f000				  -	      asl
   1006  f000				  -	      ror	temp4
   1007  f000				  -	      ror
   1008  f000				  -	      ror	temp4
   1009  f000				  -	      ror
   1010  f000				  -	      sta	temp2
   1011  f000				  -	      rts
   1012  f000				  -
   1013  f000				  -findindexHSCerror
   1014  f000				  -			;the HSC is stuffed. return the bad slot flag
   1015  f000				  -	      ldy	#$ff
   1016  f000				  -	      sty	hsgameslot
   1017  f000				  -	      rts
   1018  f000				  -
   1019  f000				  -findindexHSC
   1020  f000				  -HSCGameID1 =	$1029
   1021  f000				  -HSCGameID2 =	$106E
   1022  f000				  -HSCGameDifficulty =	$10B3
   1023  f000				  -HSCGameIndex =	$10F8
   1024  f000				  -			; routine responsible for finding the game index from HSC
   1025  f000				  -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1026  f000				  -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1027  f000				  -	      ldy	#69	; start +1 to account for the dey
   1028  f000				  -findindexHSCloop
   1029  f000				  -	      dey
   1030  f000				  -	      bmi	findindexHSCerror
   1031  f000				  -	      lda	HSCGameDifficulty,y
   1032  f000				  -	      cmp	#$7F
   1033  f000				  -	      beq	findourindexHSC
   1034  f000				  -	      cmp	gamedifficulty
   1035  f000				  -	      bne	findindexHSCloop
   1036  f000				  -	      lda	HSCGameID1,y
   1037  f000				  -	      cmp	#HSIDHI
   1038  f000				  -	      bne	findindexHSCloop
   1039  f000				  -	      lda	HSCGameID2,y
   1040  f000				  -	      cmp	#HSIDLO
   1041  f000				  -	      bne	findindexHSCloop
   1042  f000				  -findourindexHSC
   1043  f000				  -			; if we're here we found our index in the table
   1044  f000				  -			; or we found the first empty one
   1045  f000				  -	      sty	hsgameslot
   1046  f000				  -	      jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1047  f000				  -	      rts
   1048  f000				  -
   1049  f000				  -
   1050  f000				  -initializeHSCtableentry
   1051  f000				  -	      ldy	hsgameslot
   1052  f000				  -			; we need to make a new entry...
   1053  f000				  -	      lda	#HSIDHI
   1054  f000				  -	      sta	HSCGameID1,y
   1055  f000				  -	      lda	#HSIDLO
   1056  f000				  -	      sta	HSCGameID2,y
   1057  f000				  -	      lda	gamedifficulty
   1058  f000				  -	      sta	HSCGameDifficulty,y
   1059  f000				  -	      ldx	#0
   1060  f000				  -fixHSDGameDifficultylistLoop
   1061  f000				  -	      inx
   1062  f000				  -	      txa
   1063  f000				  -	      sta	HSCGameIndex,y
   1064  f000				  -	      iny
   1065  f000				  -	      cpy	#69
   1066  f000				  -	      bne	fixHSDGameDifficultylistLoop
   1067  f000				  -	      rts
   1068  f000				  -
   1069  f000				  -setupHSCGamepointer
   1070  f000				  -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1071  f000				  -	      lda	#$17
   1072  f000				  -	      sta	HSGameTableHi
   1073  f000				  -	      lda	#$FA
   1074  f000				  -	      sta	HSGameTableLo
   1075  f000				  -setupHSCGamepointerLoop
   1076  f000				  -	      lda	HSGameTableLo
   1077  f000				  -	      sec
   1078  f000				  -	      sbc	#25
   1079  f000				  -	      sta	HSGameTableLo
   1080  f000				  -	      lda	HSGameTableHi
   1081  f000				  -	      sbc	#0
   1082  f000				  -	      sta	HSGameTableHi
   1083  f000				  -	      iny
   1084  f000				  -	      cpy	#69
   1085  f000				  -	      bne	setupHSCGamepointerLoop
   1086  f000				  -	      rts
   1087  f000				  -
   1088  f000				  -loaddifficultytableAVOX
   1089  f000				  -			; routine responsible for loading the difficulty table from Avox
   1090  f000				  -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1091  f000				  -	      lda	#>(eeprombuffer+3)
   1092  f000				  -	      sta	HSGameTableHi
   1093  f000				  -	      lda	#<(eeprombuffer+3)
   1094  f000				  -	      sta	HSGameTableLo
   1095  f000				  -
   1096  f000				  -			; the start location in EEPROM, subtract 32...
   1097  f000				  -	      lda	#$5F
   1098  f000				  -	      sta	HSVoxHi
   1099  f000				  -	      lda	#$E0
   1100  f000				  -	      sta	HSVoxLo
   1101  f000				  -	      lda	#0
   1102  f000				  -	      sta	temp1
   1103  f000				  -loaddifficultytableAVOXloop
   1104  f000				  -	      inc	temp1
   1105  f000				  -	      beq	loaddifficultytableAVOXfull
   1106  f000				  -	      clc
   1107  f000				  -	      lda	HSVoxLo
   1108  f000				  -	      adc	#32
   1109  f000				  -	      sta	HSVoxLo
   1110  f000				  -	      lda	HSVoxHi
   1111  f000				  -	      adc	#0
   1112  f000				  -	      sta	HSVoxHi
   1113  f000				  -	      lda	#3
   1114  f000				  -	      jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1115  f000				  -	      lda	eeprombuffer
   1116  f000				  -	      cmp	#$FF
   1117  f000				  -	      beq	loaddifficultytableAVOXempty
   1118  f000				  -	      cmp	#HSIDHI
   1119  f000				  -	      bne	loaddifficultytableAVOXloop
   1120  f000				  -	      lda	eeprombuffer+1
   1121  f000				  -	      cmp	#HSIDLO
   1122  f000				  -	      bne	loaddifficultytableAVOXloop
   1123  f000				  -	      lda	eeprombuffer+2
   1124  f000				  -	      cmp	gamedifficulty
   1125  f000				  -	      bne	loaddifficultytableAVOXloop
   1126  f000				  -loaddifficultytableAVOXdone
   1127  f000				  -	      lda	#32
   1128  f000				  -	      jsr	AVoxReadBytes
   1129  f000				  -	      jsr	loaddifficultytableHSCcontinue
   1130  f000				  -	      rts
   1131  f000				  -loaddifficultytableAVOXfull
   1132  f000				  -	      lda	#0
   1133  f000				  -	      sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1134  f000				  -loaddifficultytableAVOXempty
   1135  f000				  -	      jmp	cleardifficultytablemem
   1136  f000				  -	      rts
   1137  f000				  -
   1138  f000				  -cleardifficultytablemem
   1139  f000				  -	      ldy	#29
   1140  f000				  -	      lda	#0
   1141  f000				  -cleardifficultytablememloop
   1142  f000				  -	      sta	HSRAMTable,y
   1143  f000				  -	      dey
   1144  f000				  -	      bpl	cleardifficultytablememloop
   1145  f000				  -	      rts
   1146  f000				  -hiscoremoduleend
   1147  f000				  -
   1148  f000				  -	      echo	"  hiscore assembly: ",[(hiscoremoduleend-hiscoremodulestart)]d," bytes"
   1149  f000				  -
   1150  f000				  -	      ifconst	DOUBLEWIDE
   1151  f000				  -plotvaluedw
   1152  f000				  -plotdigitcount =	temp6
   1153  f000				  -	      lda	#0
   1154  f000				  -	      tay
   1155  f000				  -	      ldx	valbufend
   1156  f000				  -
   1157  f000				  -	      lda	plotdigitcount
   1158  f000				  -	      and	#1
   1159  f000				  -	      beq	pvnibble2chardw
   1160  f000				  -	      lda	#0
   1161  f000				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   1162  f000				  -	      beq	pvnibble2char_skipnibbledw
   1163  f000				  -
   1164  f000				  -pvnibble2chardw
   1165  f000				  -			; high nibble...
   1166  f000				  -	      lda	(temp7),y
   1167  f000				  -	      and	#$f0
   1168  f000				  -	      lsr
   1169  f000				  -	      lsr
   1170  f000				  -	      lsr
   1171  f000				  -	      lsr
   1172  f000				  -
   1173  f000				  -	      clc
   1174  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1175  f000				  -	      sta	VALBUFFER,x
   1176  f000				  -	      inx
   1177  f000				  -	      dec	plotdigitcount
   1178  f000				  -pvnibble2char_skipnibbledw
   1179  f000				  -			; low nibble...
   1180  f000				  -	      lda	(temp7),y
   1181  f000				  -	      and	#$0f
   1182  f000				  -	      clc
   1183  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1184  f000				  -	      sta	VALBUFFER,x
   1185  f000				  -	      inx
   1186  f000				  -	      iny
   1187  f000				  -
   1188  f000				  -	      dec	plotdigitcount
   1189  f000				  -	      bne	pvnibble2chardw
   1190  f000				  -			;point to the start of our valuebuffer
   1191  f000				  -	      clc
   1192  f000				  -	      lda	#<VALBUFFER
   1193  f000				  -	      adc	valbufend
   1194  f000				  -	      sta	temp1
   1195  f000				  -	      lda	#>VALBUFFER
   1196  f000				  -	      adc	#0
   1197  f000				  -	      sta	temp2
   1198  f000				  -
   1199  f000				  -			;advance valbufend to the end of our value buffer
   1200  f000				  -	      stx	valbufend
   1201  f000				  -
   1202  f000				  -	      ifnconst	plotvalueonscreen
   1203  f000				  -	      jmp	plotcharacters
   1204  f000				  -	      else
   1205  f000				  -	      jmp	plotcharacterslive
   1206  f000				  -	      endif
   1207  f000				  -	      endif		; DOUBLEWIDE
   1208  f000				  -
   1209  f000					      endif		; HSSUPPORT
   1210  f000
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_21.bas.asm
   2918  f000					      endif
   2919  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2920  f000
   2921  f000							;standard routimes needed for pretty much all games
   2922  f000
   2923  f000							; some definitions used with "set debug color"
   2924  f000		       00 91	   DEBUGCALC  =	$91
   2925  f000		       00 41	   DEBUGWASTE =	$41
   2926  f000		       00 c1	   DEBUGDRAW  =	$C1
   2927  f000
   2928  f000							;NMI and IRQ handlers
   2929  f000				   NMI
   2930  f000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   2931  f000		       48		      pha		; save A
   2932  f001		       a5 4d		      lda	visibleover
   2933  f003		       49 ff		      eor	#255
   2934  f005		       85 4d		      sta	visibleover
   2935  f007				  -	      ifconst	DEBUGINTERRUPT
   2936  f007				  -	      and	#$93
   2937  f007				  -	      sta	BACKGRND
   2938  f007					      endif
   2939  f007		       ce b2 01 	      dec	interruptindex
   2940  f00a		       d0 03		      bne	skipreallyoffvisible
   2941  f00c		       4c 5e f0 	      jmp	reallyoffvisible
   2942  f00f				   skipreallyoffvisible
   2943  f00f		       a5 4d		      lda	visibleover
   2944  f011		       f0 49		      beq	skiptopscreenroutine
   2945  f013		       8a		      txa		; save X+Y
   2946  f014		       48		      pha
   2947  f015		       98		      tya
   2948  f016		       48		      pha
   2949  f017		       d8		      cld
   2950  f018					      ifconst	.topscreenroutine
   2951  f018		       20 3d 46 	      jsr	.topscreenroutine
   2952  f01b					      endif
   2953  f01b		       ee 3e 21 	      inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   2954  f01e
   2955  f01e							; ** Other important routines that need to regularly run, and can run onscreen.
   2956  f01e							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   2957  f01e
   2958  f01e				   longcontrollerreads		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   2959  f01e				  -	      ifconst	LONGCONTROLLERREAD
   2960  f01e				  -	      lda	#$38
   2961  f01e				  -	      ifconst	LONGDEBUG
   2962  f01e				  -	      sta	BACKGRND
   2963  f01e				  -	      endif
   2964  f01e				  -	      sta	inttemp6
   2965  f01e				  -
   2966  f01e				  -longreadlineloop
   2967  f01e				  -	      ldx	#1
   2968  f01e				  -longreadloop
   2969  f01e				  -	      ldy	port0control,x
   2970  f01e				  -	      lda	longreadroutinelo,y
   2971  f01e				  -	      sta	inttemp3
   2972  f01e				  -	      lda	longreadroutinehi,y
   2973  f01e				  -	      sta	inttemp4
   2974  f01e				  -	      ora	inttemp3
   2975  f01e				  -	      beq	longreadloopreturn
   2976  f01e				  -	      jmp	(inttemp3)
   2977  f01e				  -longreadloopreturn
   2978  f01e				  -	      dex
   2979  f01e				  -	      bpl	longreadloop
   2980  f01e				  -	      dec	inttemp6
   2981  f01e				  -	      sta	WSYNC
   2982  f01e				  -	      bne	longreadlineloop
   2983  f01e				  -
   2984  f01e				  -	      ifconst	LONGDEBUG
   2985  f01e				  -	      lda	#$00
   2986  f01e				  -	      sta	BACKGRND
   2987  f01e				  -	      endif
   2988  f01e					      endif		; LONGCONTROLLERREAD
   2989  f01e
   2990  f01e		       20 e2 f1 	      jsr	servicesfxchannels
   2991  f021				  -	      ifconst	MUSICTRACKER
   2992  f021				  -	      jsr	servicesong
   2993  f021					      endif		; MUSICTRACKER
   2994  f021
   2995  f021		       ee a4 01 	      inc	framecounter
   2996  f024		       ad a4 01 	      lda	framecounter
   2997  f027		       29 3f		      and	#63
   2998  f029		       d0 08		      bne	skipcountdownseconds
   2999  f02b		       ad a5 01 	      lda	countdownseconds
   3000  f02e		       f0 03		      beq	skipcountdownseconds
   3001  f030		       ce a5 01 	      dec	countdownseconds
   3002  f033				   skipcountdownseconds
   3003  f033
   3004  f033		       a2 01		      ldx	#1
   3005  f035				   buttonreadloop
   3006  f035		       8a		      txa
   3007  f036		       48		      pha
   3008  f037		       bc e2 01 	      ldy	port0control,x
   3009  f03a		       b9 c5 f1 	      lda	buttonhandlerlo,y
   3010  f03d		       85 da		      sta	inttemp3
   3011  f03f		       b9 ba f1 	      lda	buttonhandlerhi,y
   3012  f042		       85 db		      sta	inttemp4
   3013  f044		       05 da		      ora	inttemp3
   3014  f046		       f0 03		      beq	buttonreadloopreturn
   3015  f048		       6c da 00 	      jmp	(inttemp3)
   3016  f04b				   buttonreadloopreturn
   3017  f04b		       68		      pla
   3018  f04c		       aa		      tax
   3019  f04d		       ca		      dex
   3020  f04e		       10 e5		      bpl	buttonreadloop
   3021  f050
   3022  f050				  -	      ifconst	DRIVINGSUPPORT
   3023  f050				  -	      jsr	drivingupdate
   3024  f050					      endif		; DRIVINGSUPPORT
   3025  f050				  -	      ifconst	KEYPADSUPPORT
   3026  f050				  -	      jsr	keypadrowselect
   3027  f050					      endif		; KEYPADSUPPORT
   3028  f050
   3029  f050
   3030  f050		       ad b5 01 	      lda	doublebufferminimumframeindex
   3031  f053		       f0 03		      beq	skipdoublebufferminimumframeindexadjust
   3032  f055		       ce b5 01 	      dec	doublebufferminimumframeindex
   3033  f058				   skipdoublebufferminimumframeindexadjust
   3034  f058
   3035  f058		       68		      pla
   3036  f059		       a8		      tay
   3037  f05a		       68		      pla
   3038  f05b		       aa		      tax
   3039  f05c				   skiptopscreenroutine
   3040  f05c		       68		      pla
   3041  f05d				   IRQ
   3042  f05d		       40		      RTI
   3043  f05e
   3044  f05e				  -	      ifconst	LONGCONTROLLERREAD
   3045  f05e				  -longreadroutinelo
   3046  f05e				  -			;	  NONE		PROLINE        LIGHTGUN      PADDLE
   3047  f05e				  -	      .byte	0, 0, 0, 0
   3048  f05e				  -			;	  TRKBALL	VCS STICK      DRIVING	     KEYPAD
   3049  f05e				  -	      .byte	0, 0, 0, 0
   3050  f05e				  -			;	  STMOUSE	AMOUSE	       ATARIVOX
   3051  f05e				  -	      .byte	<mouseupdate, <mouseupdate, 0
   3052  f05e				  -
   3053  f05e				  -longreadroutinehi
   3054  f05e				  -			;	  NONE		PROLINE        LIGHTGUN      PADDLE
   3055  f05e				  -	      .byte	0, 0, 0, 0
   3056  f05e				  -			;	  TRKBALL	VCS STICK      DRIVING	     KEYPAD
   3057  f05e				  -	      .byte	0, 0, 0, 0
   3058  f05e				  -			;	  STMOUSE	AMOUSE	       ATARIVOX
   3059  f05e				  -	      .byte	>mouseupdate, >mouseupdate, 0
   3060  f05e				  -nullroutine
   3061  f05e				  -	      rts
   3062  f05e					      endif		; LONGCONTROLLERREAD
   3063  f05e
   3064  f05e				   reallyoffvisible
   3065  f05e		       85 24		      sta	WSYNC
   3066  f060
   3067  f060		       a9 00		      lda	#0
   3068  f062		       85 4d		      sta	visibleover
   3069  f064				  -	      ifconst	DEBUGINTERRUPT
   3070  f064				  -	      sta	BACKGRND
   3071  f064					      endif
   3072  f064
   3073  f064		       a9 03		      lda	#3
   3074  f066		       8d b2 01 	      sta	interruptindex
   3075  f069
   3076  f069		       8a		      txa
   3077  f06a		       48		      pha
   3078  f06b		       98		      tya
   3079  f06c		       48		      pha
   3080  f06d		       d8		      cld
   3081  f06e
   3082  f06e		       20 5c f1 	      jsr	uninterruptableroutines
   3083  f071
   3084  f071				  -	      ifconst	.userinterrupt
   3085  f071				  -	      jsr	.userinterrupt
   3086  f071					      endif
   3087  f071
   3088  f071				  -	      ifconst	KEYPADSUPPORT
   3089  f071				  -	      jsr	keypadcolumnread
   3090  f071					      endif
   3091  f071
   3092  f071		       68		      pla
   3093  f072		       a8		      tay
   3094  f073		       68		      pla
   3095  f074		       aa		      tax
   3096  f075		       68		      pla
   3097  f076		       40		      RTI
   3098  f077
   3099  f077				   clearscreen
   3100  f077		       a2 0b		      ldx	#(WZONECOUNT-1)
   3101  f079		       a9 00		      lda	#0
   3102  f07b				   clearscreenloop
   3103  f07b		       95 65		      sta	dlend,x
   3104  f07d		       ca		      dex
   3105  f07e		       10 fb		      bpl	clearscreenloop
   3106  f080		       a9 00		      lda	#0
   3107  f082		       8d ad 01 	      sta	valbufend	; clear the bcd value buffer
   3108  f085		       8d ae 01 	      sta	valbufendsave
   3109  f088		       60		      rts
   3110  f089
   3111  f089				   restorescreen
   3112  f089		       a2 0b		      ldx	#(WZONECOUNT-1)
   3113  f08b		       a9 00		      lda	#0
   3114  f08d				   restorescreenloop
   3115  f08d		       b5 82		      lda	dlendsave,x
   3116  f08f		       95 65		      sta	dlend,x
   3117  f091		       ca		      dex
   3118  f092		       10 f9		      bpl	restorescreenloop
   3119  f094		       ad ae 01 	      lda	valbufendsave
   3120  f097		       8d ad 01 	      sta	valbufend
   3121  f09a		       60		      rts
   3122  f09b
   3123  f09b				   savescreen
   3124  f09b		       a2 0b		      ldx	#(WZONECOUNT-1)
   3125  f09d				   savescreenloop
   3126  f09d		       b5 65		      lda	dlend,x
   3127  f09f		       95 82		      sta	dlendsave,x
   3128  f0a1		       ca		      dex
   3129  f0a2		       10 f9		      bpl	savescreenloop
   3130  f0a4		       ad ad 01 	      lda	valbufend
   3131  f0a7		       8d ae 01 	      sta	valbufendsave
   3132  f0aa					      ifconst	DOUBLEBUFFER
   3133  f0aa		       a5 d5		      lda	doublebufferstate
   3134  f0ac		       f0 04		      beq	savescreenrts
   3135  f0ae		       a9 01		      lda	#1
   3136  f0b0		       85 d7		      sta	doublebufferbufferdirty
   3137  f0b2				   savescreenrts
   3138  f0b2					      endif		; DOUBLEBUFFER
   3139  f0b2		       60		      rts
   3140  f0b3
   3141  f0b3				   drawscreen
   3142  f0b3
   3143  f0b3		       a9 00		      lda	#0
   3144  f0b5		       85 42		      sta	temp1	; not B&W if we're here...
   3145  f0b7
   3146  f0b7				   drawscreenwait
   3147  f0b7		       a5 4d		      lda	visibleover
   3148  f0b9		       d0 fc		      bne	drawscreenwait	; make sure the visible screen isn't being drawn
   3149  f0bb
   3150  f0bb							;restore some registers in case the game changed them mid-screen...
   3151  f0bb		       ad 07 21 	      lda	sCTRL
   3152  f0be		       05 42		      ora	temp1
   3153  f0c0		       85 3c		      sta	CTRL
   3154  f0c2		       ad 0b 21 	      lda	sCHARBASE
   3155  f0c5		       85 34		      sta	CHARBASE
   3156  f0c7
   3157  f0c7							;ensure all of the display list is terminated...
   3158  f0c7		       20 39 f1 	      jsr	terminatedisplaylist
   3159  f0ca
   3160  f0ca					      ifnconst	pauseroutineoff
   3161  f0ca		       20 d5 f0 	      jsr	pauseroutine
   3162  f0cd					      endif		; pauseroutineoff
   3163  f0cd
   3164  f0cd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   3165  f0cd							; delaying a full frame, but still allowing time for basic calculations.
   3166  f0cd				   visiblescreenstartedwait
   3167  f0cd		       a5 4d		      lda	visibleover
   3168  f0cf		       f0 fc		      beq	visiblescreenstartedwait
   3169  f0d1				   visiblescreenstartedwaitdone
   3170  f0d1		       ce 3e 21 	      dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   3171  f0d4		       60		      rts
   3172  f0d5
   3173  f0d5					      ifnconst	pauseroutineoff
   3174  f0d5							; check to see if pause was pressed and released
   3175  f0d5				   pauseroutine
   3176  f0d5		       ad b6 01 	      lda	pausedisable
   3177  f0d8		       d0 4e		      bne	leavepauseroutine
   3178  f0da		       a9 08		      lda	#8
   3179  f0dc		       2c 82 02 	      bit	SWCHB
   3180  f0df		       f0 29		      beq	pausepressed
   3181  f0e1
   3182  f0e1					      ifnconst	SOFTRESETASPAUSEOFF
   3183  f0e1					      ifnconst	MOUSESUPPORT
   3184  f0e1		       ad 80 02 	      lda	SWCHA	; then check the soft "RESET" joysick code...
   3185  f0e4		       29 70		      and	#%01110000	; _LDU
   3186  f0e6		       f0 22		      beq	pausepressed
   3187  f0e8					      endif
   3188  f0e8					      endif
   3189  f0e8
   3190  f0e8							;pause isn't pressed
   3191  f0e8		       a9 00		      lda	#0
   3192  f0ea		       8d ac 01 	      sta	pausebuttonflag	; clear pause hold state in case its set
   3193  f0ed
   3194  f0ed							;check if we're in an already paused state
   3195  f0ed		       ad 00 21 	      lda	pausestate
   3196  f0f0		       f0 36		      beq	leavepauseroutine	; nope, leave
   3197  f0f2
   3198  f0f2		       c9 01		      cmp	#1	; last frame was the start of pausing
   3199  f0f4		       f0 2b		      beq	enterpausestate2	; move from state 1 to 2
   3200  f0f6
   3201  f0f6		       c9 02		      cmp	#2
   3202  f0f8		       f0 34		      beq	carryonpausing
   3203  f0fa
   3204  f0fa							;pausestate must be >2, which means we're ending an unpause 
   3205  f0fa		       a9 00		      lda	#0
   3206  f0fc		       8d ac 01 	      sta	pausebuttonflag
   3207  f0ff		       8d 00 21 	      sta	pausestate
   3208  f102		       ad 07 21 	      lda	sCTRL
   3209  f105		       85 3c		      sta	CTRL
   3210  f107		       4c 28 f1 	      jmp	leavepauseroutine
   3211  f10a
   3212  f10a				   pausepressed
   3213  f10a							;pause is pressed
   3214  f10a		       ad ac 01 	      lda	pausebuttonflag
   3215  f10d		       c9 ff		      cmp	#$ff
   3216  f10f		       f0 1d		      beq	carryonpausing
   3217  f111
   3218  f111							;its a new press, increment the state
   3219  f111		       ee 00 21 	      inc	pausestate
   3220  f114
   3221  f114							;silence volume at the start and end of pausing
   3222  f114		       a9 00		      lda	#0
   3223  f116		       85 19		      sta	AUDV0
   3224  f118		       85 1a		      sta	AUDV1
   3225  f11a
   3226  f11a				  -	      ifconst	pokeysupport
   3227  f11a				  -	      ldy	#7
   3228  f11a				  -pausesilencepokeyaudioloop
   3229  f11a				  -	      sta	(pokeybase),y
   3230  f11a				  -	      dey
   3231  f11a				  -	      bpl	pausesilencepokeyaudioloop
   3232  f11a					      endif		; pokeysupport
   3233  f11a
   3234  f11a		       a9 ff		      lda	#$ff
   3235  f11c		       8d ac 01 	      sta	pausebuttonflag
   3236  f11f		       d0 0d		      bne	carryonpausing
   3237  f121
   3238  f121				   enterpausestate2
   3239  f121		       a9 02		      lda	#2
   3240  f123		       8d 00 21 	      sta	pausestate
   3241  f126		       d0 06		      bne	carryonpausing
   3242  f128				   leavepauseroutine
   3243  f128		       ad 07 21 	      lda	sCTRL
   3244  f12b		       85 3c		      sta	CTRL
   3245  f12d		       60		      rts
   3246  f12e				   carryonpausing
   3247  f12e				  -	      ifconst	.pause
   3248  f12e				  -	      jsr	.pause
   3249  f12e					      endif		; .pause
   3250  f12e		       ad 07 21 	      lda	sCTRL
   3251  f131		       09 80		      ora	#%10000000	; turn off colorburst during pause...
   3252  f133		       85 3c		      sta	CTRL
   3253  f135		       4c d5 f0 	      jmp	pauseroutine
   3254  f138					      endif		; pauseroutineoff
   3255  f138
   3256  f138
   3257  f138					      ifconst	DOUBLEBUFFER
   3258  f138				   skipterminatedisplaylistreturn
   3259  f138		       60		      rts
   3260  f139					      endif		; DOUBLEBUFFER
   3261  f139				   terminatedisplaylist
   3262  f139					      ifconst	DOUBLEBUFFER
   3263  f139		       a5 d5		      lda	doublebufferstate
   3264  f13b		       d0 fb		      bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   3265  f13d					      endif		; DOUBLEBUFFER
   3266  f13d				   terminatedisplaybuffer
   3267  f13d							;add DL end entry on each DL
   3268  f13d		       a2 0b		      ldx	#(WZONECOUNT-1)
   3269  f13f				   dlendloop
   3270  f13f		       bd 24 f7 	      lda	DLPOINTL,x
   3271  f142					      ifconst	DOUBLEBUFFER
   3272  f142		       18		      clc
   3273  f143		       65 d6		      adc	doublebufferdloffset
   3274  f145					      endif		; DOUBLEBUFFER
   3275  f145		       85 63		      sta	dlpnt
   3276  f147		       bd 18 f7 	      lda	DLPOINTH,x
   3277  f14a					      ifconst	DOUBLEBUFFER
   3278  f14a		       69 00		      adc	#0
   3279  f14c					      endif		; DOUBLEBUFFER
   3280  f14c		       85 64		      sta	dlpnt+1
   3281  f14e		       b4 65		      ldy	dlend,x
   3282  f150		       a9 00		      lda	#$00
   3283  f152				   dlendmoreloops
   3284  f152		       c8		      iny
   3285  f153		       91 63		      sta	(dlpnt),y
   3286  f155				  -	      ifconst	FRAMESKIPGLITCHFIXWEAK
   3287  f155				  -	      cpy	#DLLASTOBJ+1
   3288  f155				  -	      beq	dlendthiszonedone
   3289  f155				  -	      iny
   3290  f155				  -	      iny
   3291  f155				  -	      iny
   3292  f155				  -	      iny
   3293  f155				  -	      iny
   3294  f155				  -	      sta	(dlpnt),y
   3295  f155				  -dlendthiszonedone
   3296  f155					      endif	FRAMESKIPGLITCHFIXWEAK
   3297  f155				  -	      ifconst	FRAMESKIPGLITCHFIX
   3298  f155				  -	      iny
   3299  f155				  -	      iny
   3300  f155				  -	      iny
   3301  f155				  -	      iny
   3302  f155				  -	      cpy	#DLLASTOBJ-1
   3303  f155				  -	      bcc	dlendmoreloops
   3304  f155					      endif		; FRAMESKIPGLITCHFIX
   3305  f155		       ca		      dex
   3306  f156		       10 e7		      bpl	dlendloop
   3307  f158
   3308  f158					      ifnconst	pauseroutineoff
   3309  f158		       20 d5 f0 	      jsr	pauseroutine
   3310  f15b					      endif		; pauseroutineoff
   3311  f15b		       60		      rts
   3312  f15c
   3313  f15c				   uninterruptableroutines
   3314  f15c							; this is for routines that must happen off the visible screen, each frame.
   3315  f15c
   3316  f15c				  -	      ifconst	AVOXVOICE
   3317  f15c				  -	      jsr	serviceatarivoxqueue
   3318  f15c					      endif
   3319  f15c
   3320  f15c		       a9 00		      lda	#0
   3321  f15e		       8d e1 01 	      sta	palfastframe
   3322  f161		       ad 09 21 	      lda	paldetected
   3323  f164		       f0 10		      beq	skippalframeadjusting
   3324  f166							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   3325  f166		       ae e0 01 	      ldx	palframes
   3326  f169		       e8		      inx
   3327  f16a		       e0 05		      cpx	#5
   3328  f16c		       d0 05		      bne	palframeskipdone
   3329  f16e		       ee e1 01 	      inc	palfastframe
   3330  f171		       a2 00		      ldx	#0
   3331  f173				   palframeskipdone
   3332  f173		       8e e0 01 	      stx	palframes
   3333  f176				   skippalframeadjusting
   3334  f176
   3335  f176				  -	      ifconst	MUSICTRACKER
   3336  f176				  -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   3337  f176				  -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   3338  f176				  -			; If that happens, we try again here. Chances are very small we'll run into the same
   3339  f176				  -			; problem twice, and if we do, we just drop a musical note or two.
   3340  f176				  -	      lda	sfxschedulemissed
   3341  f176				  -	      beq	servicesongwasnotmissed
   3342  f176				  -	      jsr	servicesong
   3343  f176				  -servicesongwasnotmissed
   3344  f176					      endif		; MUSICTRACKER
   3345  f176
   3346  f176		       60		      rts
   3347  f177
   3348  f177				   serviceatarivoxqueue
   3349  f177				  -	      ifconst	AVOXVOICE
   3350  f177				  -	      lda	voxlock
   3351  f177				  -	      bne	skipvoxprocessing	; the vox is in the middle of speech address update
   3352  f177				  -skipvoxqueuesizedec
   3353  f177				  -	      jmp	processavoxvoice
   3354  f177				  -skipvoxprocessing
   3355  f177				  -	      rts
   3356  f177				  -
   3357  f177				  -processavoxvoice
   3358  f177				  -	      lda	avoxenable
   3359  f177				  -	      bne	avoxfixport
   3360  f177				  -	      SPKOUT	tempavox
   3361  f177				  -	      rts
   3362  f177				  -avoxfixport
   3363  f177				  -	      lda	#0	; restore the port to all bits as inputs...
   3364  f177				  -	      sta	CTLSWA
   3365  f177				  -	      rts
   3366  f177				  -silenceavoxvoice
   3367  f177				  -	      SPEAK	avoxsilentdata
   3368  f177				  -	      rts
   3369  f177				  -avoxsilentdata
   3370  f177				  -	      .byte	31,255
   3371  f177					      else
   3372  f177		       60		      rts
   3373  f178					      endif		; AVOXVOICE
   3374  f178
   3375  f178				   joybuttonhandler
   3376  f178		       8a		      txa
   3377  f179		       0a		      asl
   3378  f17a		       a8		      tay
   3379  f17b		       b9 08 00 	      lda	INPT0,y
   3380  f17e		       4a		      lsr
   3381  f17f		       9d 02 21 	      sta	sINPT1,x
   3382  f182		       b9 09 00 	      lda	INPT1,y
   3383  f185		       29 80		      and	#%10000000
   3384  f187		       1d 02 21 	      ora	sINPT1,x
   3385  f18a							;eor genesisdetected0,x ; invert INPT1 if genesis is detected
   3386  f18a		       9d 02 21 	      sta	sINPT1,x
   3387  f18d
   3388  f18d		       b5 0c		      lda	INPT4,x
   3389  f18f		       30 19		      bmi	.skip1bjoyfirecheck
   3390  f191							;one button joystick is down
   3391  f191		       49 80		      eor	#%10000000
   3392  f193		       9d 02 21 	      sta	sINPT1,x
   3393  f196
   3394  f196		       ad b1 01 	      lda	joybuttonmode
   3395  f199		       3d ad f1 	      and	twobuttonmask,x
   3396  f19c		       f0 0c		      beq	.skip1bjoyfirecheck
   3397  f19e		       ad b1 01 	      lda	joybuttonmode
   3398  f1a1		       1d ad f1 	      ora	twobuttonmask,x
   3399  f1a4		       8d b1 01 	      sta	joybuttonmode
   3400  f1a7		       8d 82 02 	      sta	SWCHB
   3401  f1aa				   .skip1bjoyfirecheck
   3402  f1aa		       4c 4b f0 	      jmp	buttonreadloopreturn
   3403  f1ad
   3404  f1ad				   twobuttonmask
   3405  f1ad		       04 10		      .byte.b	%00000100,%00010000
   3406  f1af
   3407  f1af				   gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   3408  f1af				  -	      ifconst	LIGHTGUNSUPPORT
   3409  f1af				  -	      cpx	#0
   3410  f1af				  -	      bne	secondportgunhandler
   3411  f1af				  -firstportgunhandler
   3412  f1af				  -	      lda	SWCHA
   3413  f1af				  -	      asl
   3414  f1af				  -	      asl
   3415  f1af				  -	      asl		; shift D4 to D7
   3416  f1af				  -	      and	#%10000000
   3417  f1af				  -	      eor	#%10000000
   3418  f1af				  -	      sta	sINPT1
   3419  f1af				  -	      jmp	buttonreadloopreturn
   3420  f1af				  -secondportgunhandler
   3421  f1af				  -	      lda	SWCHA
   3422  f1af				  -	      lsr		; shift D0 into carry
   3423  f1af				  -	      lsr		; shift carry into D7
   3424  f1af				  -	      and	#%10000000
   3425  f1af				  -	      eor	#%10000000
   3426  f1af				  -	      sta	sINPT3
   3427  f1af				  -	      jmp	buttonreadloopreturn
   3428  f1af					      endif		; LIGHTGUNSUPPORT
   3429  f1af
   3430  f1af				   controlsusing2buttoncode
   3431  f1af		       00		      .byte.b	0	; 00=no controller plugged in
   3432  f1b0		       01		      .byte.b	1	; 01=proline joystick
   3433  f1b1		       00		      .byte.b	0	; 02=lightgun
   3434  f1b2		       00		      .byte.b	0	; 03=paddle
   3435  f1b3		       01		      .byte.b	1	; 04=trakball
   3436  f1b4		       01		      .byte.b	1	; 05=vcs joystick
   3437  f1b5		       01		      .byte.b	1	; 06=driving control
   3438  f1b6		       00		      .byte.b	0	; 07=keypad control
   3439  f1b7		       00		      .byte.b	0	; 08=st mouse/cx80
   3440  f1b8		       00		      .byte.b	0	; 09=amiga mouse
   3441  f1b9		       01		      .byte.b	1	; 10=atarivox
   3442  f1ba
   3443  f1ba				   buttonhandlerhi
   3444  f1ba		       00		      .byte.b	0	; 00=no controller plugged in
   3445  f1bb		       f1		      .byte.b	>joybuttonhandler	; 01=proline joystick
   3446  f1bc		       f1		      .byte.b	>gunbuttonhandler	; 02=lightgun
   3447  f1bd		       00		      .byte.b	0	; 03=paddle [not implemented yet]
   3448  f1be		       f1		      .byte.b	>joybuttonhandler	; 04=trakball
   3449  f1bf		       f1		      .byte.b	>joybuttonhandler	; 05=vcs joystick
   3450  f1c0		       f1		      .byte.b	>joybuttonhandler	; 06=driving control
   3451  f1c1		       00		      .byte.b	0	; 07=keypad
   3452  f1c2		       f6		      .byte.b	>mousebuttonhandler	; 08=st mouse
   3453  f1c3		       f6		      .byte.b	>mousebuttonhandler	; 09=amiga mouse
   3454  f1c4		       f1		      .byte.b	>joybuttonhandler	; 10=atarivox
   3455  f1c5				   buttonhandlerlo
   3456  f1c5		       00		      .byte.b	0	; 00=no controller plugged in
   3457  f1c6		       78		      .byte.b	<joybuttonhandler	; 01=proline joystick
   3458  f1c7		       af		      .byte.b	<gunbuttonhandler	; 02=lightgun 
   3459  f1c8		       00		      .byte.b	0	; 03=paddle [not implemented yet]
   3460  f1c9		       78		      .byte.b	<joybuttonhandler	; 04=trakball
   3461  f1ca		       78		      .byte.b	<joybuttonhandler	; 05=vcs joystick
   3462  f1cb		       78		      .byte.b	<joybuttonhandler	; 06=driving control
   3463  f1cc		       00		      .byte.b	0	; 07=keypad
   3464  f1cd		       29		      .byte.b	<mousebuttonhandler	; 08=st mouse
   3465  f1ce		       29		      .byte.b	<mousebuttonhandler	; 09=amiga mouse
   3466  f1cf		       78		      .byte.b	<joybuttonhandler	; 10=atarivox
   3467  f1d0
   3468  f1d0				   drawwait
   3469  f1d0		       a5 4d		      lda	visibleover
   3470  f1d2		       d0 fc		      bne	drawwait	; make sure the visible screen isn't being drawn
   3471  f1d4		       60		      rts
   3472  f1d5
   3473  f1d5				   mutetia
   3474  f1d5		       a9 00		      lda	#0
   3475  f1d7		       a2 03		      ldx	#3
   3476  f1d9				   mutetialoop
   3477  f1d9		       95 4e		      sta	sfx1pointlo,x
   3478  f1db		       95 17		      sta	AUDF0,x
   3479  f1dd		       ca		      dex
   3480  f1de		       10 f9		      bpl	mutetialoop
   3481  f1e0		       60		      rts
   3482  f1e1
   3483  f1e1				   servicesfxchannelsdone
   3484  f1e1					      ifnconst	pokeysupport
   3485  f1e1		       60		      rts
   3486  f1e2				  -	      else
   3487  f1e2				  -	      jmp	checkpokeyplaying
   3488  f1e2					      endif
   3489  f1e2				   servicesfxchannels
   3490  f1e2		       a2 ff		      ldx	#255
   3491  f1e4				   servicesfxchannelsloop
   3492  f1e4		       e8		      inx
   3493  f1e5					      ifnconst	TIASFXMONO
   3494  f1e5		       e0 02		      cpx	#2
   3495  f1e7				  -	      else
   3496  f1e7				  -	      cpx	#1
   3497  f1e7					      endif
   3498  f1e7		       f0 f8		      beq	servicesfxchannelsdone
   3499  f1e9
   3500  f1e9		       b5 4e		      lda	sfx1pointlo,x
   3501  f1eb		       85 dc		      sta	inttemp5
   3502  f1ed		       15 50		      ora	sfx1pointhi,x
   3503  f1ef		       f0 f3		      beq	servicesfxchannelsloop
   3504  f1f1		       b5 50		      lda	sfx1pointhi,x
   3505  f1f3		       85 dd		      sta	inttemp6
   3506  f1f5
   3507  f1f5		       b5 58		      lda	sfx1tick,x
   3508  f1f7		       f0 05		      beq	servicesfx_cont1	; this chunk is over, load the next!
   3509  f1f9		       d6 58		      dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   3510  f1fb		       4c e4 f1 	      jmp	servicesfxchannelsloop
   3511  f1fe				   servicesfx_cont1
   3512  f1fe
   3513  f1fe		       b5 56		      lda	sfx1frames,x	; set the frame countdown for this sound chunk
   3514  f200		       95 58		      sta	sfx1tick,x
   3515  f202
   3516  f202		       b5 52		      lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   3517  f204		       f0 02		      beq	servicesfx_cont2
   3518  f206		       d6 52		      dec	sfx1priority,x
   3519  f208				   servicesfx_cont2
   3520  f208
   3521  f208		       a0 00		      ldy	#0	; play the sound
   3522  f20a		       b1 dc		      lda	(inttemp5),y
   3523  f20c		       85 d8		      sta	inttemp1
   3524  f20e
   3525  f20e				  -	      ifconst	MUSICTRACKER
   3526  f20e				  -	      lda	sfx1notedata,x
   3527  f20e				  -	      beq	exitmusictracker	; exit if this isn't a pitched instrument
   3528  f20e				  -	      ldy	#0
   3529  f20e				  -	      sty	inttemp2
   3530  f20e				  -	      clc
   3531  f20e				  -	      adc	(inttemp5),y
   3532  f20e				  -	      asl		; x2
   3533  f20e				  -	      tay
   3534  f20e				  -	      lda	tiatrackeroctavenotes,y
   3535  f20e				  -	      sta	AUDC0,x
   3536  f20e				  -	      iny
   3537  f20e				  -	      lda	tiatrackeroctavenotes,y
   3538  f20e				  -	      sta	AUDF0,x
   3539  f20e				  -	      ldy	#1
   3540  f20e				  -	      jmp	sfxvolumeentrypt
   3541  f20e				  -exitmusictracker
   3542  f20e				  -	      lda	inttemp1
   3543  f20e					      endif		; MUSICTRACKER
   3544  f20e
   3545  f20e		       18		      clc
   3546  f20f		       75 54		      adc	sfx1poffset,x	; take into account any pitch modification
   3547  f211		       95 17		      sta	AUDF0,x
   3548  f213		       c8		      iny
   3549  f214		       b1 dc		      lda	(inttemp5),y
   3550  f216		       95 15		      sta	AUDC0,x
   3551  f218		       85 d9		      sta	inttemp2
   3552  f21a		       c8		      iny
   3553  f21b				   sfxvolumeentrypt
   3554  f21b		       b1 dc		      lda	(inttemp5),y
   3555  f21d		       95 19		      sta	AUDV0,x
   3556  f21f		       c9 10		      cmp	#$10
   3557  f221		       b0 19		      bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   3558  f223
   3559  f223		       05 d9		      ora	inttemp2
   3560  f225		       05 d8		      ora	inttemp1	; check if F|C|V=0
   3561  f227		       f0 23		      beq	zerosfx	; if so, we're at the end of the sound.
   3562  f229
   3563  f229				   advancesfxpointer
   3564  f229							; advance the pointer to the next sound chunk
   3565  f229		       c8		      iny
   3566  f22a		       84 da		      sty	inttemp3
   3567  f22c		       18		      clc
   3568  f22d		       b5 4e		      lda	sfx1pointlo,x
   3569  f22f		       65 da		      adc	inttemp3
   3570  f231		       95 4e		      sta	sfx1pointlo,x
   3571  f233		       b5 50		      lda	sfx1pointhi,x
   3572  f235		       69 00		      adc	#0
   3573  f237		       95 50		      sta	sfx1pointhi,x
   3574  f239		       4c e4 f1 	      jmp	servicesfxchannelsloop
   3575  f23c
   3576  f23c				   sfxsoundloop
   3577  f23c		       48		      pha
   3578  f23d		       b5 52		      lda	sfx1priority,x
   3579  f23f		       d0 04		      bne	sfxsoundloop_carryon
   3580  f241		       68		      pla		; fix the stack before we go
   3581  f242		       4c 29 f2 	      jmp	advancesfxpointer
   3582  f245				   sfxsoundloop_carryon
   3583  f245		       68		      pla
   3584  f246		       29 f0		      and	#$F0
   3585  f248		       4a		      lsr
   3586  f249		       4a		      lsr
   3587  f24a		       4a		      lsr
   3588  f24b		       4a		      lsr
   3589  f24c
   3590  f24c				   zerosfx
   3591  f24c		       95 4e		      sta	sfx1pointlo,x
   3592  f24e		       95 50		      sta	sfx1pointhi,x
   3593  f250		       95 52		      sta	sfx1priority,x
   3594  f252		       4c e4 f1 	      jmp	servicesfxchannelsloop
   3595  f255
   3596  f255
   3597  f255				   schedulesfx
   3598  f255							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   3599  f255		       a0 00		      ldy	#0
   3600  f257		       b1 e0		      lda	(sfxinstrumentlo),y
   3601  f259				  -	      ifconst	pokeysupport
   3602  f259				  -	      cmp	#$20	; POKEY?
   3603  f259				  -	      bne	scheduletiasfx
   3604  f259				  -	      jmp	schedulepokeysfx
   3605  f259					      endif
   3606  f259				   scheduletiasfx
   3607  f259							;cmp #$10 ; TIA?
   3608  f259							;beq continuescheduletiasfx
   3609  f259							; rts ; unhandled!!! 
   3610  f259				   continuescheduletiasfx
   3611  f259					      ifnconst	TIASFXMONO
   3612  f259		       a5 4e		      lda	sfx1pointlo
   3613  f25b		       05 50		      ora	sfx1pointhi
   3614  f25d		       f0 13		      beq	schedulesfx1	;if channel 1 is idle, use it
   3615  f25f		       a5 4f		      lda	sfx2pointlo
   3616  f261		       05 51		      ora	sfx2pointhi
   3617  f263		       f0 11		      beq	schedulesfx2	;if channel 2 is idle, use it
   3618  f265							; Both channels are scheduled. 
   3619  f265		       a0 01		      ldy	#1
   3620  f267		       b1 e0		      lda	(sfxinstrumentlo),y
   3621  f269		       d0 01		      bne	interruptsfx
   3622  f26b		       60		      rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   3623  f26c				   interruptsfx
   3624  f26c							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   3625  f26c		       a5 52		      lda	sfx1priority
   3626  f26e		       c5 53		      cmp	sfx2priority
   3627  f270		       b0 04		      bcs	schedulesfx2
   3628  f272					      endif		; !TIASFXMONO
   3629  f272
   3630  f272				   schedulesfx1
   3631  f272		       a2 00		      ldx	#0	; channel 1
   3632  f274					      ifnconst	TIASFXMONO
   3633  f274		       f0 02		      beq	skipschedulesfx2
   3634  f276				   schedulesfx2
   3635  f276		       a2 01		      ldx	#1	; channel 2
   3636  f278				   skipschedulesfx2
   3637  f278					      endif		; !TIASFXMONO
   3638  f278
   3639  f278				  -	      ifconst	MUSICTRACKER
   3640  f278				  -	      lda	sfxnoteindex
   3641  f278				  -	      bpl	skipdrumkitoverride
   3642  f278				  -	      and	#$7F	; subtract 128
   3643  f278				  -	      sec
   3644  f278				  -	      sbc	#4	; drums start at 132, i.e. octave 10
   3645  f278				  -	      asl
   3646  f278				  -	      tay
   3647  f278				  -	      lda	tiadrumkitdefinition,y
   3648  f278				  -	      sta	sfxinstrumentlo
   3649  f278				  -	      iny
   3650  f278				  -	      lda	tiadrumkitdefinition,y
   3651  f278				  -	      sta	sfxinstrumenthi
   3652  f278				  -	      lda	#0
   3653  f278				  -	      sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   3654  f278				  -skipdrumkitoverride
   3655  f278					      endif		; MUSICTRACKER
   3656  f278		       a0 01		      ldy	#1	; get priority and sound-resolution (in frames)
   3657  f27a		       b1 e0		      lda	(sfxinstrumentlo),y
   3658  f27c		       95 52		      sta	sfx1priority,x
   3659  f27e		       c8		      iny
   3660  f27f		       b1 e0		      lda	(sfxinstrumentlo),y
   3661  f281		       95 56		      sta	sfx1frames,x
   3662  f283		       a5 e0		      lda	sfxinstrumentlo
   3663  f285		       18		      clc
   3664  f286		       69 03		      adc	#3
   3665  f288		       95 4e		      sta	sfx1pointlo,x
   3666  f28a		       a5 e1		      lda	sfxinstrumenthi
   3667  f28c		       69 00		      adc	#0
   3668  f28e		       95 50		      sta	sfx1pointhi,x
   3669  f290		       a5 e2		      lda	sfxpitchoffset
   3670  f292		       95 54		      sta	sfx1poffset,x
   3671  f294		       a9 00		      lda	#0
   3672  f296		       95 58		      sta	sfx1tick,x
   3673  f298		       a5 e3		      lda	sfxnoteindex
   3674  f29a		       95 cd		      sta	sfx1notedata,x
   3675  f29c		       60		      rts
   3676  f29d
   3677  f29d				   plotsprite
   3678  f29d					      ifconst	DOUBLEBUFFER
   3679  f29d		       a5 d5		      lda	doublebufferstate
   3680  f29f		       d0 04		      bne	skipplotspritewait
   3681  f2a1					      endif		; DOUBLEBUFFER
   3682  f2a1				   plotspritewait
   3683  f2a1		       a5 4d		      lda	visibleover
   3684  f2a3		       d0 fc		      bne	plotspritewait
   3685  f2a5				   skipplotspritewait
   3686  f2a5
   3687  f2a5							;arguments: 
   3688  f2a5							; temp1=lo graphicdata 
   3689  f2a5							; temp2=hi graphicdata 
   3690  f2a5							; temp3=palette | width byte
   3691  f2a5							; temp4=x
   3692  f2a5							; temp5=y
   3693  f2a5							; temp6=mode
   3694  f2a5		       a5 46		      lda	temp5	;Y position
   3695  f2a7		       4a		      lsr		; 2 - Divide by 8 or 16
   3696  f2a8		       4a		      lsr		; 2
   3697  f2a9		       4a		      lsr		; 2
   3698  f2aa					      if	WZONEHEIGHT = 16
   3699  f2aa		       4a		      lsr		; 2
   3700  f2ab					      endif
   3701  f2ab
   3702  f2ab		       aa		      tax
   3703  f2ac
   3704  f2ac							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   3705  f2ac
   3706  f2ac		       c9 0c		      cmp	#WZONECOUNT
   3707  f2ae
   3708  f2ae		       90 0a		      bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   3709  f2b0							; otherwise, check to see if the bottom half is in zone 0...
   3710  f2b0
   3711  f2b0					      if	WZONEHEIGHT = 16
   3712  f2b0		       c9 0f		      cmp	#15
   3713  f2b2				  -	      else
   3714  f2b2				  -	      cmp	#31
   3715  f2b2					      endif
   3716  f2b2
   3717  f2b2		       d0 05		      bne	exitplotsprite1
   3718  f2b4		       a2 00		      ldx	#0
   3719  f2b6		       4c f6 f2 	      jmp	continueplotsprite2
   3720  f2b9				   exitplotsprite1
   3721  f2b9		       60		      rts
   3722  f2ba
   3723  f2ba				   continueplotsprite1
   3724  f2ba
   3725  f2ba		       bd 24 f7 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3726  f2bd					      ifconst	DOUBLEBUFFER
   3727  f2bd		       18		      clc
   3728  f2be		       65 d6		      adc	doublebufferdloffset
   3729  f2c0					      endif		; DOUBLEBUFFER
   3730  f2c0		       85 63		      sta	dlpnt
   3731  f2c2		       bd 18 f7 	      lda	DLPOINTH,x
   3732  f2c5					      ifconst	DOUBLEBUFFER
   3733  f2c5		       69 00		      adc	#0
   3734  f2c7					      endif		; DOUBLEBUFFER
   3735  f2c7		       85 64		      sta	dlpnt+1
   3736  f2c9
   3737  f2c9							;Create DL entry for upper part of sprite
   3738  f2c9
   3739  f2c9		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3740  f2cb
   3741  f2cb				  -	      ifconst	CHECKOVERWRITE
   3742  f2cb				  -	      cpy	#DLLASTOBJ
   3743  f2cb				  -	      beq	checkcontinueplotsprite2
   3744  f2cb				  -continueplotsprite1a
   3745  f2cb					      endif
   3746  f2cb
   3747  f2cb		       a5 42		      lda	temp1	; graphic data, lo byte
   3748  f2cd		       91 63		      sta	(dlpnt),y	;Low byte of data address
   3749  f2cf
   3750  f2cf					      ifnconst	ATOMICSPRITEUPDATE
   3751  f2cf		       c8		      iny
   3752  f2d0		       a5 47		      lda	temp6
   3753  f2d2		       91 63		      sta	(dlpnt),y
   3754  f2d4				  -	      else
   3755  f2d4				  -	      iny
   3756  f2d4				  -	      sty	temp8
   3757  f2d4				  -			;lda #0
   3758  f2d4				  -			;sta (dlpnt),y
   3759  f2d4					      endif
   3760  f2d4
   3761  f2d4		       c8		      iny
   3762  f2d5		       a5 46		      lda	temp5	;Y position
   3763  f2d7
   3764  f2d7					      if	WZONEHEIGHT = 16
   3765  f2d7		       29 0f		      and	#$0F
   3766  f2d9				  -	      else		; WZONEHEIGHT = 8
   3767  f2d9				  -	      and	#$7
   3768  f2d9					      endif
   3769  f2d9
   3770  f2d9		       05 43		      ora	temp2	; graphic data, hi byte
   3771  f2db		       91 63		      sta	(dlpnt),y
   3772  f2dd
   3773  f2dd		       c8		      iny
   3774  f2de		       a5 44		      lda	temp3	;palette|width
   3775  f2e0		       91 63		      sta	(dlpnt),y
   3776  f2e2
   3777  f2e2		       c8		      iny
   3778  f2e3		       a5 45		      lda	temp4	;Horizontal position
   3779  f2e5		       91 63		      sta	(dlpnt),y
   3780  f2e7
   3781  f2e7		       c8		      iny
   3782  f2e8		       94 65		      sty	dlend,x
   3783  f2ea
   3784  f2ea				  -	      ifconst	ATOMICSPRITEUPDATE
   3785  f2ea				  -	      ldy	temp8
   3786  f2ea				  -	      lda	temp6
   3787  f2ea				  -	      sta	(dlpnt),y
   3788  f2ea					      endif
   3789  f2ea				   checkcontinueplotsprite2
   3790  f2ea
   3791  f2ea		       a5 46		      lda	temp5
   3792  f2ec		       29 0f		      and	#(WZONEHEIGHT-1)
   3793  f2ee
   3794  f2ee		       f0 3d		      beq	doneSPDL	;branch if it is
   3795  f2f0
   3796  f2f0							;Create DL entry for lower part of sprite
   3797  f2f0
   3798  f2f0		       e8		      inx		;Next region
   3799  f2f1
   3800  f2f1		       e0 0c		      cpx	#WZONECOUNT
   3801  f2f3
   3802  f2f3		       90 01		      bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3803  f2f5		       60		      rts
   3804  f2f6				   continueplotsprite2
   3805  f2f6
   3806  f2f6		       bd 24 f7 	      lda	DLPOINTL,x	;Get pointer to next DL
   3807  f2f9					      ifconst	DOUBLEBUFFER
   3808  f2f9		       18		      clc
   3809  f2fa		       65 d6		      adc	doublebufferdloffset
   3810  f2fc					      endif		; DOUBLEBUFFER
   3811  f2fc		       85 63		      sta	dlpnt
   3812  f2fe		       bd 18 f7 	      lda	DLPOINTH,x
   3813  f301					      ifconst	DOUBLEBUFFER
   3814  f301		       69 00		      adc	#0
   3815  f303					      endif		; DOUBLEBUFFER
   3816  f303		       85 64		      sta	dlpnt+1
   3817  f305		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3818  f307
   3819  f307				  -	      ifconst	CHECKOVERWRITE
   3820  f307				  -	      cpy	#DLLASTOBJ
   3821  f307				  -	      bne	continueplotsprite2a
   3822  f307				  -	      rts
   3823  f307				  -continueplotsprite2a
   3824  f307					      endif
   3825  f307
   3826  f307		       a5 42		      lda	temp1	; graphic data, lo byte
   3827  f309		       91 63		      sta	(dlpnt),y
   3828  f30b
   3829  f30b					      ifnconst	ATOMICSPRITEUPDATE
   3830  f30b		       c8		      iny
   3831  f30c		       a5 47		      lda	temp6
   3832  f30e		       91 63		      sta	(dlpnt),y
   3833  f310				  -	      else
   3834  f310				  -	      iny
   3835  f310				  -	      sty	temp8
   3836  f310				  -			;lda #0
   3837  f310				  -			;sta (dlpnt),y
   3838  f310					      endif
   3839  f310
   3840  f310		       c8		      iny
   3841  f311		       a5 46		      lda	temp5	;Y position
   3842  f313
   3843  f313					      if	WZONEHEIGHT = 16
   3844  f313		       29 0f		      and	#$0F
   3845  f315		       49 0f		      eor	#$0F
   3846  f317					      endif
   3847  f317				  -	      if	WZONEHEIGHT = 8
   3848  f317				  -	      and	#$07
   3849  f317				  -	      eor	#$07
   3850  f317					      endif
   3851  f317
   3852  f317		       85 4a		      sta	temp9
   3853  f319		       a5 43		      lda	temp2	; graphic data, hi byte
   3854  f31b		       18		      clc
   3855  f31c		       e5 4a		      sbc	temp9
   3856  f31e		       91 63		      sta	(dlpnt),y
   3857  f320
   3858  f320		       c8		      iny
   3859  f321		       a5 44		      lda	temp3	;palette|width
   3860  f323		       91 63		      sta	(dlpnt),y
   3861  f325
   3862  f325		       c8		      iny
   3863  f326		       a5 45		      lda	temp4	;Horizontal position
   3864  f328		       91 63		      sta	(dlpnt),y
   3865  f32a
   3866  f32a		       c8		      iny
   3867  f32b		       94 65		      sty	dlend,x
   3868  f32d
   3869  f32d				  -	      ifconst	ATOMICSPRITEUPDATE
   3870  f32d				  -	      ldy	temp8
   3871  f32d				  -	      lda	temp6
   3872  f32d				  -	      sta	(dlpnt),y
   3873  f32d					      endif
   3874  f32d
   3875  f32d				   doneSPDL
   3876  f32d		       60		      rts
   3877  f32e
   3878  f32e				   lockzonex
   3879  f32e				  -	      ifconst	ZONELOCKS
   3880  f32e				  -	      ldy	dlend,x
   3881  f32e				  -	      cpy	#DLLASTOBJ
   3882  f32e				  -	      beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3883  f32e				  -	      lda	DLPOINTL,x
   3884  f32e				  -	      ifconst	DOUBLEBUFFER
   3885  f32e				  -	      clc
   3886  f32e				  -	      adc	doublebufferdloffset
   3887  f32e				  -	      endif		; DOUBLEBUFFER
   3888  f32e				  -	      sta	dlpnt
   3889  f32e				  -	      lda	DLPOINTH,x
   3890  f32e				  -	      ifconst	DOUBLEBUFFER
   3891  f32e				  -	      adc	#0
   3892  f32e				  -	      endif		; DOUBLEBUFFER
   3893  f32e				  -	      sta	dlpnt+1
   3894  f32e				  -	      iny
   3895  f32e				  -	      lda	#0
   3896  f32e				  -	      sta	(dlpnt),y
   3897  f32e				  -	      dey
   3898  f32e				  -	      tya
   3899  f32e				  -	      ldy	#(DLLASTOBJ-1)
   3900  f32e				  -	      sta	(dlpnt),y
   3901  f32e				  -	      iny
   3902  f32e				  -	      sty	dlend,x
   3903  f32e				  -lockzonexreturn
   3904  f32e				  -	      rts
   3905  f32e					      endif		; ZONELOCKS
   3906  f32e				   unlockzonex
   3907  f32e				  -	      ifconst	ZONELOCKS
   3908  f32e				  -	      ldy	dlend,x
   3909  f32e				  -	      cpy	#DLLASTOBJ
   3910  f32e				  -	      bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3911  f32e				  -	      lda	DLPOINTL,x
   3912  f32e				  -	      ifconst	DOUBLEBUFFER
   3913  f32e				  -	      clc
   3914  f32e				  -	      adc	doublebufferdloffset
   3915  f32e				  -	      endif		; DOUBLEBUFFER
   3916  f32e				  -	      sta	dlpnt
   3917  f32e				  -	      lda	DLPOINTH,x
   3918  f32e				  -	      ifconst	DOUBLEBUFFER
   3919  f32e				  -	      adc	#0
   3920  f32e				  -	      endif		; DOUBLEBUFFER
   3921  f32e				  -	      sta	dlpnt+1
   3922  f32e				  -	      dey
   3923  f32e				  -			;ldy #(DLLASTOBJ-1)
   3924  f32e				  -	      lda	(dlpnt),y
   3925  f32e				  -	      tay
   3926  f32e				  -	      sty	dlend,x
   3927  f32e				  -unlockzonexreturn
   3928  f32e					      endif		; ZONELOCKS
   3929  f32e		       60		      rts
   3930  f32f
   3931  f32f				   plotcharloop
   3932  f32f							; ** read from a data indirectly pointed to from temp8,temp9
   3933  f32f							; ** format is: lo_data, hi_data, palette|width, x, y
   3934  f32f							; ** format ends with lo_data | hi_data = 0
   3935  f32f
   3936  f32f					      ifconst	DOUBLEBUFFER
   3937  f32f		       a5 d5		      lda	doublebufferstate
   3938  f331		       d0 04		      bne	skipplotcharloopwait
   3939  f333					      endif		; DOUBLEBUFFER
   3940  f333				   plotcharloopwait
   3941  f333		       a5 4d		      lda	visibleover
   3942  f335		       d0 fc		      bne	plotcharloopwait
   3943  f337				   skipplotcharloopwait
   3944  f337				   plotcharlooploop
   3945  f337		       a0 00		      ldy	#0
   3946  f339		       b1 49		      lda	(temp8),y
   3947  f33b		       85 42		      sta	temp1
   3948  f33d		       c8		      iny
   3949  f33e		       b1 49		      lda	(temp8),y
   3950  f340		       85 43		      sta	temp2
   3951  f342		       05 42		      ora	temp1
   3952  f344		       d0 01		      bne	plotcharloopcontinue
   3953  f346							;the pointer=0, so return
   3954  f346		       60		      rts
   3955  f347				   plotcharloopcontinue
   3956  f347		       c8		      iny
   3957  f348		       b1 49		      lda	(temp8),y
   3958  f34a		       85 44		      sta	temp3
   3959  f34c		       c8		      iny
   3960  f34d		       b1 49		      lda	(temp8),y
   3961  f34f		       85 45		      sta	temp4
   3962  f351		       c8		      iny
   3963  f352		       b1 49		      lda	(temp8),y
   3964  f354							;sta temp5 ; not needed with our late entry.
   3965  f354		       20 71 f3 	      jsr	plotcharactersskipentry
   3966  f357		       a5 49		      lda	temp8
   3967  f359		       18		      clc
   3968  f35a		       69 05		      adc	#5
   3969  f35c		       85 49		      sta	temp8
   3970  f35e		       a5 4a		      lda	temp9
   3971  f360		       69 00		      adc	#0
   3972  f362		       85 4a		      sta	temp9
   3973  f364		       4c 37 f3 	      jmp	plotcharlooploop
   3974  f367
   3975  f367				   plotcharacters
   3976  f367					      ifconst	DOUBLEBUFFER
   3977  f367		       a5 d5		      lda	doublebufferstate
   3978  f369		       d0 04		      bne	skipplotcharacterswait
   3979  f36b					      endif		; DOUBLEBUFFER
   3980  f36b				   plotcharacterswait
   3981  f36b		       a5 4d		      lda	visibleover
   3982  f36d		       d0 fc		      bne	plotcharacterswait
   3983  f36f				   skipplotcharacterswait
   3984  f36f							;arguments: 
   3985  f36f							; temp1=lo charactermap
   3986  f36f							; temp2=hi charactermap
   3987  f36f							; temp3=palette | width byte
   3988  f36f							; temp4=x
   3989  f36f							; temp5=y
   3990  f36f
   3991  f36f		       a5 46		      lda	temp5	;Y position
   3992  f371
   3993  f371				   plotcharactersskipentry
   3994  f371
   3995  f371							;ifconst ZONEHEIGHT
   3996  f371							; if ZONEHEIGHT = 16
   3997  f371							; and #$0F
   3998  f371							; endif
   3999  f371							; if ZONEHEIGHT = 8
   4000  f371							; and #$1F
   4001  f371							; endif
   4002  f371							;else
   4003  f371							; and #$0F
   4004  f371							;endif
   4005  f371
   4006  f371		       aa		      tax
   4007  f372		       bd 24 f7 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4008  f375					      ifconst	DOUBLEBUFFER
   4009  f375		       18		      clc
   4010  f376		       65 d6		      adc	doublebufferdloffset
   4011  f378					      endif		; DOUBLEBUFFER
   4012  f378		       85 63		      sta	dlpnt
   4013  f37a		       bd 18 f7 	      lda	DLPOINTH,x
   4014  f37d					      ifconst	DOUBLEBUFFER
   4015  f37d		       69 00		      adc	#0
   4016  f37f					      endif		; DOUBLEBUFFER
   4017  f37f		       85 64		      sta	dlpnt+1
   4018  f381
   4019  f381							;Create DL entry for the characters
   4020  f381
   4021  f381		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4022  f383
   4023  f383				  -	      ifconst	CHECKOVERWRITE
   4024  f383				  -	      cpy	#DLLASTOBJ
   4025  f383				  -	      bne	continueplotcharacters
   4026  f383				  -	      rts
   4027  f383				  -continueplotcharacters
   4028  f383					      endif
   4029  f383
   4030  f383		       a5 42		      lda	temp1	; character map data, lo byte
   4031  f385		       91 63		      sta	(dlpnt),y	;(1) store low address
   4032  f387
   4033  f387		       c8		      iny
   4034  f388		       ad 06 21 	      lda	charactermode
   4035  f38b		       91 63		      sta	(dlpnt),y	;(2) store mode
   4036  f38d
   4037  f38d		       c8		      iny
   4038  f38e		       a5 43		      lda	temp2	; character map, hi byte
   4039  f390		       91 63		      sta	(dlpnt),y	;(3) store high address
   4040  f392
   4041  f392		       c8		      iny
   4042  f393		       a5 44		      lda	temp3	;palette|width
   4043  f395		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   4044  f397
   4045  f397		       c8		      iny
   4046  f398		       a5 45		      lda	temp4	;Horizontal position
   4047  f39a		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   4048  f39c
   4049  f39c		       c8		      iny
   4050  f39d		       94 65		      sty	dlend,x	; save display list end byte
   4051  f39f		       60		      rts
   4052  f3a0
   4053  f3a0
   4054  f3a0					      ifconst	plotvalueonscreen
   4055  f3a0				   plotcharacterslive
   4056  f3a0							; a version of plotcharacters that draws live and minimally disrupts the screen...
   4057  f3a0
   4058  f3a0							;arguments: 
   4059  f3a0							; temp1=lo charactermap
   4060  f3a0							; temp2=hi charactermap
   4061  f3a0							; temp3=palette | width byte
   4062  f3a0							; temp4=x
   4063  f3a0							; temp5=y
   4064  f3a0
   4065  f3a0		       a5 46		      lda	temp5	;Y position
   4066  f3a2
   4067  f3a2		       aa		      tax
   4068  f3a3		       bd 24 f7 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4069  f3a6					      ifconst	DOUBLEBUFFER
   4070  f3a6		       18		      clc
   4071  f3a7		       65 d6		      adc	doublebufferdloffset
   4072  f3a9					      endif		; DOUBLEBUFFER
   4073  f3a9		       85 63		      sta	dlpnt
   4074  f3ab		       bd 18 f7 	      lda	DLPOINTH,x
   4075  f3ae					      ifconst	DOUBLEBUFFER
   4076  f3ae		       69 00		      adc	#0
   4077  f3b0					      endif		; DOUBLEBUFFER
   4078  f3b0		       85 64		      sta	dlpnt+1
   4079  f3b2
   4080  f3b2							;Create DL entry for the characters
   4081  f3b2
   4082  f3b2		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4083  f3b4
   4084  f3b4				  -	      ifconst	CHECKOVERWRITE
   4085  f3b4				  -	      cpy	#DLLASTOBJ
   4086  f3b4				  -	      bne	continueplotcharacterslive
   4087  f3b4				  -	      rts
   4088  f3b4				  -continueplotcharacterslive
   4089  f3b4					      endif
   4090  f3b4
   4091  f3b4		       a5 42		      lda	temp1	; character map data, lo byte
   4092  f3b6		       91 63		      sta	(dlpnt),y	;(1) store low address
   4093  f3b8
   4094  f3b8		       c8		      iny
   4095  f3b9							; we don't add the second byte yet, since the charmap could briefly
   4096  f3b9							; render without a proper character map address, width, or position.
   4097  f3b9		       ad 06 21 	      lda	charactermode
   4098  f3bc		       91 63		      sta	(dlpnt),y	;(2) store mode
   4099  f3be
   4100  f3be		       c8		      iny
   4101  f3bf		       a5 43		      lda	temp2	; character map, hi byte
   4102  f3c1		       91 63		      sta	(dlpnt),y	;(3) store high address
   4103  f3c3
   4104  f3c3		       c8		      iny
   4105  f3c4		       a5 44		      lda	temp3	;palette|width
   4106  f3c6		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   4107  f3c8
   4108  f3c8		       c8		      iny
   4109  f3c9		       a5 45		      lda	temp4	;Horizontal position
   4110  f3cb		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   4111  f3cd
   4112  f3cd		       c8		      iny
   4113  f3ce		       94 65		      sty	dlend,x	; save display list end byte
   4114  f3d0
   4115  f3d0		       60		      rts
   4116  f3d1					      endif		;plotcharacterslive
   4117  f3d1
   4118  f3d1					      ifconst	USED_PLOTVALUE
   4119  f3d1				   plotvalue
   4120  f3d1							; calling 7800basic command:
   4121  f3d1							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4122  f3d1							; ...displays the variable as BCD digits
   4123  f3d1							;
   4124  f3d1							; asm sub arguments: 
   4125  f3d1							; temp1=lo charactermap
   4126  f3d1							; temp2=hi charactermap
   4127  f3d1							; temp3=palette | width byte
   4128  f3d1							; temp4=x
   4129  f3d1							; temp5=y
   4130  f3d1							; temp6=number of digits
   4131  f3d1							; temp7=lo variable
   4132  f3d1							; temp8=hi variable
   4133  f3d1							; temp9=character mode
   4134  f3d1
   4135  f3d1		       00 47	   plotdigitcount =	temp6
   4136  f3d1
   4137  f3d1				  -	      ifconst	ZONELOCKS
   4138  f3d1				  -	      ldx	temp5
   4139  f3d1				  -	      ldy	dlend,x
   4140  f3d1				  -	      cpy	#DLLASTOBJ
   4141  f3d1				  -	      bne	carryonplotvalue
   4142  f3d1				  -	      rts
   4143  f3d1				  -carryonplotvalue
   4144  f3d1					      endif
   4145  f3d1
   4146  f3d1		       a9 00		      lda	#0
   4147  f3d3		       a8		      tay
   4148  f3d4		       ae ad 01 	      ldx	valbufend
   4149  f3d7
   4150  f3d7		       a5 47		      lda	plotdigitcount
   4151  f3d9		       29 01		      and	#1
   4152  f3db		       f0 07		      beq	pvnibble2char
   4153  f3dd		       a9 00		      lda	#0
   4154  f3df		       9d 00 20 	      sta	VALBUFFER,x	; just in case we skip this digit
   4155  f3e2		       f0 11		      beq	pvnibble2char_skipnibble
   4156  f3e4
   4157  f3e4				   pvnibble2char
   4158  f3e4							; high nibble...
   4159  f3e4		       b1 48		      lda	(temp7),y
   4160  f3e6		       29 f0		      and	#$f0
   4161  f3e8		       4a		      lsr
   4162  f3e9		       4a		      lsr
   4163  f3ea		       4a		      lsr
   4164  f3eb					      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4165  f3eb		       4a		      lsr
   4166  f3ec					      endif
   4167  f3ec
   4168  f3ec		       18		      clc
   4169  f3ed		       65 42		      adc	temp1	; add the offset to character graphics to our value
   4170  f3ef		       9d 00 20 	      sta	VALBUFFER,x
   4171  f3f2		       e8		      inx
   4172  f3f3		       c6 47		      dec	plotdigitcount
   4173  f3f5
   4174  f3f5				   pvnibble2char_skipnibble
   4175  f3f5							; low nibble...
   4176  f3f5		       b1 48		      lda	(temp7),y
   4177  f3f7		       29 0f		      and	#$0f
   4178  f3f9				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4179  f3f9				  -	      asl
   4180  f3f9					      endif
   4181  f3f9		       18		      clc
   4182  f3fa		       65 42		      adc	temp1	; add the offset to character graphics to our value
   4183  f3fc		       9d 00 20 	      sta	VALBUFFER,x
   4184  f3ff		       e8		      inx
   4185  f400		       c8		      iny
   4186  f401
   4187  f401		       c6 47		      dec	plotdigitcount
   4188  f403		       d0 df		      bne	pvnibble2char
   4189  f405
   4190  f405							;point to the start of our valuebuffer
   4191  f405		       18		      clc
   4192  f406		       a9 00		      lda	#<VALBUFFER
   4193  f408		       6d ad 01 	      adc	valbufend
   4194  f40b		       85 42		      sta	temp1
   4195  f40d		       a9 20		      lda	#>VALBUFFER
   4196  f40f		       69 00		      adc	#0
   4197  f411		       85 43		      sta	temp2
   4198  f413
   4199  f413							;advance valbufend to the end of our value buffer
   4200  f413		       8e ad 01 	      stx	valbufend
   4201  f416
   4202  f416				  -	      ifnconst	plotvalueonscreen
   4203  f416				  -	      jmp	plotcharacters
   4204  f416					      else
   4205  f416		       4c a0 f3 	      jmp	plotcharacterslive
   4206  f419					      endif
   4207  f419
   4208  f419					      endif		; USED_PLOTVALUE
   4209  f419
   4210  f419
   4211  f419				  -	      ifconst	USED_PLOTVALUEEXTRA
   4212  f419				  -plotdigitcount =	temp6
   4213  f419				  -plotvalueextra
   4214  f419				  -			; calling 7800basic command:
   4215  f419				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4216  f419				  -			; ...displays the variable as BCD digits
   4217  f419				  -			;
   4218  f419				  -			; asm sub arguments: 
   4219  f419				  -			; temp1=lo charactermap
   4220  f419				  -			; temp2=hi charactermap
   4221  f419				  -			; temp3=palette | width byte
   4222  f419				  -			; temp4=x
   4223  f419				  -			; temp5=y
   4224  f419				  -			; temp6=number of digits
   4225  f419				  -			; temp7=lo variable
   4226  f419				  -			; temp8=hi variable
   4227  f419				  -
   4228  f419				  -	      lda	#0
   4229  f419				  -	      tay
   4230  f419				  -	      ldx	valbufend
   4231  f419				  -	      ifnconst	plotvalueonscreen
   4232  f419				  -	      sta	VALBUFFER,x
   4233  f419				  -	      endif
   4234  f419				  -
   4235  f419				  -	      lda	plotdigitcount
   4236  f419				  -	      and	#1
   4237  f419				  -
   4238  f419				  -	      bne	pvnibble2char_skipnibbleextra
   4239  f419				  -
   4240  f419				  -pvnibble2charextra
   4241  f419				  -			; high nibble...
   4242  f419				  -	      lda	(temp7),y
   4243  f419				  -	      and	#$f0
   4244  f419				  -	      lsr
   4245  f419				  -	      lsr
   4246  f419				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4247  f419				  -	      lsr
   4248  f419				  -	      endif
   4249  f419				  -	      clc
   4250  f419				  -	      adc	temp1	; add the offset to character graphics to our value
   4251  f419				  -	      sta	VALBUFFER,x
   4252  f419				  -	      inx
   4253  f419				  -
   4254  f419				  -			; second half of the digit
   4255  f419				  -	      clc
   4256  f419				  -	      adc	#1
   4257  f419				  -	      sta	VALBUFFER,x
   4258  f419				  -	      inx
   4259  f419				  -
   4260  f419				  -pvnibble2char_skipnibbleextra
   4261  f419				  -			; low nibble...
   4262  f419				  -	      lda	(temp7),y
   4263  f419				  -	      and	#$0f
   4264  f419				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4265  f419				  -	      asl
   4266  f419				  -	      endif
   4267  f419				  -	      asl
   4268  f419				  -
   4269  f419				  -	      clc
   4270  f419				  -	      adc	temp1	; add the offset to character graphics to our value
   4271  f419				  -	      sta	VALBUFFER,x
   4272  f419				  -	      inx
   4273  f419				  -
   4274  f419				  -	      clc
   4275  f419				  -	      adc	#1
   4276  f419				  -	      sta	VALBUFFER,x
   4277  f419				  -	      inx
   4278  f419				  -	      iny
   4279  f419				  -
   4280  f419				  -	      dec	plotdigitcount
   4281  f419				  -	      bne	pvnibble2charextra
   4282  f419				  -
   4283  f419				  -			;point to the start of our valuebuffer
   4284  f419				  -	      clc
   4285  f419				  -	      lda	#<VALBUFFER
   4286  f419				  -	      adc	valbufend
   4287  f419				  -	      sta	temp1
   4288  f419				  -	      lda	#>VALBUFFER
   4289  f419				  -	      adc	#0
   4290  f419				  -	      sta	temp2
   4291  f419				  -
   4292  f419				  -			;advance valbufend to the end of our value buffer
   4293  f419				  -	      stx	valbufend
   4294  f419				  -
   4295  f419				  -	      ifnconst	plotvalueonscreen
   4296  f419				  -	      jmp	plotcharacters
   4297  f419				  -	      else
   4298  f419				  -	      jmp	plotcharacterslive
   4299  f419				  -	      endif
   4300  f419					      endif		; USED_PLOTVALUEEXTRA
   4301  f419
   4302  f419				   boxcollision
   4303  f419							; the worst case cycle-time for the code below is 43 cycles.
   4304  f419							; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   4305  f419
   4306  f419							;__boxx1 = accumulator
   4307  f419							;__boxy1 = y
   4308  f419		       00 44	   __boxw1    =	temp3
   4309  f419		       00 45	   __boxh1    =	temp4
   4310  f419
   4311  f419		       00 46	   __boxx2    =	temp5
   4312  f419		       00 47	   __boxy2    =	temp6
   4313  f419		       00 48	   __boxw2    =	temp7
   4314  f419		       00 49	   __boxh2    =	temp8
   4315  f419
   4316  f419				   DoXCollisionCheck
   4317  f419							;lda __boxx1 ; skipped. already in the accumulator
   4318  f419		       c5 46		      cmp	__boxx2	;3
   4319  f41b		       b0 07		      bcs	X1isbiggerthanX2	;2/3
   4320  f41d				   X2isbiggerthanX1
   4321  f41d							; carry is clear
   4322  f41d		       65 44		      adc	__boxw1	;3
   4323  f41f		       c5 46		      cmp	__boxx2	;3
   4324  f421		       b0 08		      bcs	DoYCollisionCheck	;3/2
   4325  f423		       60		      rts		;6 - carry clear, no collision
   4326  f424				   X1isbiggerthanX2
   4327  f424		       18		      clc		;2
   4328  f425		       e5 48		      sbc	__boxw2	;3
   4329  f427		       c5 46		      cmp	__boxx2	;3
   4330  f429		       b0 13		      bcs	noboxcollision	;3/2
   4331  f42b				   DoYCollisionCheck
   4332  f42b		       98		      tya		; 2 ; use to be "lda __boxy1"
   4333  f42c		       c5 47		      cmp	__boxy2	;3
   4334  f42e		       b0 05		      bcs	Y1isbiggerthanY2	;3/2
   4335  f430				   Y2isbiggerthanY1
   4336  f430							; carry is clear
   4337  f430		       65 45		      adc	__boxh1	;3
   4338  f432		       c5 47		      cmp	__boxy2	;3
   4339  f434		       60		      rts		;6 
   4340  f435				   Y1isbiggerthanY2
   4341  f435		       18		      clc		;2
   4342  f436		       e5 49		      sbc	__boxh2	;3
   4343  f438		       c5 47		      cmp	__boxy2	;3
   4344  f43a		       b0 02		      bcs	noboxcollision	;3/2
   4345  f43c				   yesboxcollision
   4346  f43c		       38		      sec		;2
   4347  f43d		       60		      rts		;6
   4348  f43e				   noboxcollision
   4349  f43e		       18		      clc		;2
   4350  f43f		       60		      rts		;6
   4351  f440
   4352  f440				   randomize
   4353  f440		       a5 40		      lda	rand
   4354  f442		       4a		      lsr
   4355  f443		       26 41		      rol	rand16
   4356  f445		       90 02		      bcc	noeor
   4357  f447		       49 b4		      eor	#$B4
   4358  f449				   noeor
   4359  f449		       85 40		      sta	rand
   4360  f44b		       45 41		      eor	rand16
   4361  f44d		       60		      rts
   4362  f44e
   4363  f44e							; bcd conversion routine courtesy Omegamatrix
   4364  f44e							; http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   4365  f44e				   converttobcd
   4366  f44e							;value to convert is in the accumulator
   4367  f44e		       85 42		      sta	temp1
   4368  f450		       4a		      lsr
   4369  f451		       65 42		      adc	temp1
   4370  f453		       6a		      ror
   4371  f454		       4a		      lsr
   4372  f455		       4a		      lsr
   4373  f456		       65 42		      adc	temp1
   4374  f458		       6a		      ror
   4375  f459		       65 42		      adc	temp1
   4376  f45b		       6a		      ror
   4377  f45c		       4a		      lsr
   4378  f45d		       29 3c		      and	#$3C
   4379  f45f		       85 43		      sta	temp2
   4380  f461		       4a		      lsr
   4381  f462		       65 43		      adc	temp2
   4382  f464		       65 42		      adc	temp1
   4383  f466		       60		      rts		; return the result in the accumulator
   4384  f467
   4385  f467							; Y and A contain multiplicands, result in A
   4386  f467				   mul8
   4387  f467		       84 42		      sty	temp1
   4388  f469		       85 43		      sta	temp2
   4389  f46b		       a9 00		      lda	#0
   4390  f46d				   reptmul8
   4391  f46d		       46 43		      lsr	temp2
   4392  f46f		       90 03		      bcc	skipmul8
   4393  f471		       18		      clc
   4394  f472		       65 42		      adc	temp1
   4395  f474							;bcs donemul8 might save cycles?
   4396  f474				   skipmul8
   4397  f474							;beq donemul8 might save cycles?
   4398  f474		       06 42		      asl	temp1
   4399  f476		       d0 f5		      bne	reptmul8
   4400  f478				   donemul8
   4401  f478		       60		      rts
   4402  f479
   4403  f479				   div8
   4404  f479							; A=numerator Y=denominator, result in A
   4405  f479		       c0 02		      cpy	#2
   4406  f47b		       90 0a		      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   4407  f47d		       84 42		      sty	temp1
   4408  f47f		       a0 ff		      ldy	#$ff
   4409  f481				   div8loop
   4410  f481		       e5 42		      sbc	temp1
   4411  f483		       c8		      iny
   4412  f484		       b0 fb		      bcs	div8loop
   4413  f486				   div8end
   4414  f486		       98		      tya
   4415  f487							; result in A
   4416  f487		       60		      rts
   4417  f488
   4418  f488							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   4419  f488				   mul16
   4420  f488		       84 42		      sty	temp1
   4421  f48a		       85 43		      sta	temp2
   4422  f48c
   4423  f48c		       a9 00		      lda	#0
   4424  f48e		       a2 08		      ldx	#8
   4425  f490		       46 42		      lsr	temp1
   4426  f492				   mul16_1
   4427  f492		       90 03		      bcc	mul16_2
   4428  f494		       18		      clc
   4429  f495		       65 43		      adc	temp2
   4430  f497				   mul16_2
   4431  f497		       6a		      ror
   4432  f498		       66 42		      ror	temp1
   4433  f49a		       ca		      dex
   4434  f49b		       d0 f5		      bne	mul16_1
   4435  f49d		       85 43		      sta	temp2
   4436  f49f		       60		      rts
   4437  f4a0
   4438  f4a0							; div int/int
   4439  f4a0							; numerator in A, denom in temp1
   4440  f4a0							; returns with quotient in A, remainder in temp1
   4441  f4a0				   div16
   4442  f4a0		       85 43		      sta	temp2
   4443  f4a2		       84 42		      sty	temp1
   4444  f4a4		       a9 00		      lda	#0
   4445  f4a6		       a2 08		      ldx	#8
   4446  f4a8		       06 43		      asl	temp2
   4447  f4aa				   div16_1
   4448  f4aa		       2a		      rol
   4449  f4ab		       c5 42		      cmp	temp1
   4450  f4ad		       90 02		      bcc	div16_2
   4451  f4af		       e5 42		      sbc	temp1
   4452  f4b1				   div16_2
   4453  f4b1		       26 43		      rol	temp2
   4454  f4b3		       ca		      dex
   4455  f4b4		       d0 f4		      bne	div16_1
   4456  f4b6		       85 42		      sta	temp1
   4457  f4b8		       a5 43		      lda	temp2
   4458  f4ba		       60		      rts
   4459  f4bb
   4460  f4bb				  -	      ifconst	bankswitchmode
   4461  f4bb				  -BS_jsr
   4462  f4bb				  -	      ifconst	MCPDEVCART
   4463  f4bb				  -	      ora	#$18
   4464  f4bb				  -	      sta	$3000
   4465  f4bb				  -	      else
   4466  f4bb				  -	      sta	$8000
   4467  f4bb				  -	      endif
   4468  f4bb				  -	      pla
   4469  f4bb				  -	      tax
   4470  f4bb				  -	      pla
   4471  f4bb				  -	      rts
   4472  f4bb				  -
   4473  f4bb				  -BS_return
   4474  f4bb				  -	      pla		; bankswitch bank
   4475  f4bb				  -	      ifconst	BANKRAM
   4476  f4bb				  -	      sta	currentbank
   4477  f4bb				  -	      ora	currentrambank
   4478  f4bb				  -	      endif
   4479  f4bb				  -	      ifconst	MCPDEVCART
   4480  f4bb				  -	      ora	#$18
   4481  f4bb				  -	      sta	$3000
   4482  f4bb				  -	      else
   4483  f4bb				  -	      sta	$8000
   4484  f4bb				  -	      endif
   4485  f4bb				  -	      pla		; bankswitch $0 flag
   4486  f4bb				  -	      rts
   4487  f4bb					      endif
   4488  f4bb
   4489  f4bb				   checkselectswitch
   4490  f4bb		       ad 82 02 	      lda	SWCHB	; first check the real select switch...
   4491  f4be		       29 02		      and	#%00000010
   4492  f4c0					      ifnconst	MOUSESUPPORT
   4493  f4c0		       f0 05		      beq	checkselectswitchreturn	; switch is pressed
   4494  f4c2		       ad 80 02 	      lda	SWCHA	; then check the soft "select" joysick code...
   4495  f4c5		       29 b0		      and	#%10110000	; R_DU
   4496  f4c7					      endif		; MOUSESUPPORT
   4497  f4c7				   checkselectswitchreturn
   4498  f4c7		       60		      rts
   4499  f4c8
   4500  f4c8				   checkresetswitch
   4501  f4c8		       ad 82 02 	      lda	SWCHB	; first check the real reset switch...
   4502  f4cb		       29 01		      and	#%00000001
   4503  f4cd					      ifnconst	MOUSESUPPORT
   4504  f4cd		       f0 05		      beq	checkresetswitchreturn	; switch is pressed
   4505  f4cf		       ad 80 02 	      lda	SWCHA	; then check the soft "reset" joysick code...
   4506  f4d2		       29 70		      and	#%01110000	; _LDU
   4507  f4d4					      endif		; MOUSESUPPORT
   4508  f4d4				   checkresetswitchreturn
   4509  f4d4		       60		      rts
   4510  f4d5
   4511  f4d5				  -	      ifconst	FINESCROLLENABLED
   4512  f4d5				  -finescrolldlls
   4513  f4d5				  -	      ldx	temp1	; first DLL index x3
   4514  f4d5				  -	      lda	DLLMEM,x
   4515  f4d5				  -	      and	#%11110000
   4516  f4d5				  -	      ora	finescrolly
   4517  f4d5				  -	      sta	DLLMEM,x
   4518  f4d5				  -
   4519  f4d5				  -	      ldx	temp2	; last DLL index x3
   4520  f4d5				  -	      lda	DLLMEM,x
   4521  f4d5				  -	      and	#%11110000
   4522  f4d5				  -	      ora	finescrolly
   4523  f4d5				  -	      eor	#(WZONEHEIGHT-1)
   4524  f4d5				  -	      sta	DLLMEM,x
   4525  f4d5				  -	      rts
   4526  f4d5					      endif		; FINESCROLLENABLED
   4527  f4d5
   4528  f4d5				  -	      ifconst	USED_ADJUSTVISIBLE
   4529  f4d5				  -adjustvisible
   4530  f4d5				  -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   4531  f4d5				  -	      jsr	waitforvblankstart	; ensure vblank just started
   4532  f4d5				  -	      ldx	visibleDLLstart
   4533  f4d5				  -findfirstinterrupt
   4534  f4d5				  -	      lda	DLLMEM,x
   4535  f4d5				  -	      bmi	foundfirstinterrupt
   4536  f4d5				  -	      inx
   4537  f4d5				  -	      inx
   4538  f4d5				  -	      inx
   4539  f4d5				  -	      bne	findfirstinterrupt
   4540  f4d5				  -foundfirstinterrupt
   4541  f4d5				  -	      and	#%01111111	; clear the interrupt bit
   4542  f4d5				  -	      sta	DLLMEM,x
   4543  f4d5				  -	      ifconst	DOUBLEBUFFER
   4544  f4d5				  -	      sta	DLLMEM+DBOFFSET,x
   4545  f4d5				  -	      endif		; DOUBLEBUFFER
   4546  f4d5				  -	      ldx	overscanDLLstart
   4547  f4d5				  -findlastinterrupt
   4548  f4d5				  -	      lda	DLLMEM,x
   4549  f4d5				  -	      bmi	foundlastinterrupt
   4550  f4d5				  -	      dex
   4551  f4d5				  -	      dex
   4552  f4d5				  -	      dex
   4553  f4d5				  -	      bne	findlastinterrupt
   4554  f4d5				  -foundlastinterrupt
   4555  f4d5				  -	      and	#%01111111	; clear the interrupt bit
   4556  f4d5				  -	      sta	DLLMEM,x
   4557  f4d5				  -	      ifconst	DOUBLEBUFFER
   4558  f4d5				  -	      sta	DLLMEM+DBOFFSET,x
   4559  f4d5				  -	      endif		; DOUBLEBUFFER
   4560  f4d5				  -			;now we need to set the new interrupts
   4561  f4d5				  -	      clc
   4562  f4d5				  -	      lda	temp1
   4563  f4d5				  -	      adc	visibleDLLstart
   4564  f4d5				  -	      tax
   4565  f4d5				  -	      lda	DLLMEM,x
   4566  f4d5				  -	      ora	#%10000000
   4567  f4d5				  -	      sta	DLLMEM,x
   4568  f4d5				  -	      ifconst	DOUBLEBUFFER
   4569  f4d5				  -	      sta	DLLMEM+DBOFFSET,x
   4570  f4d5				  -	      endif		; DOUBLEBUFFER
   4571  f4d5				  -	      clc
   4572  f4d5				  -	      lda	temp2
   4573  f4d5				  -	      adc	visibleDLLstart
   4574  f4d5				  -	      tax
   4575  f4d5				  -	      lda	DLLMEM,x
   4576  f4d5				  -	      ora	#%10000000
   4577  f4d5				  -	      sta	DLLMEM,x
   4578  f4d5				  -	      ifconst	DOUBLEBUFFER
   4579  f4d5				  -	      sta	DLLMEM+DBOFFSET,x
   4580  f4d5				  -	      endif		; DOUBLEBUFFER
   4581  f4d5				  -	      jsr	vblankresync
   4582  f4d5				  -	      rts
   4583  f4d5					      endif		; USED_ADJUSTVISIBLE
   4584  f4d5
   4585  f4d5				   vblankresync
   4586  f4d5		       20 96 f5 	      jsr	waitforvblankstart	; ensure vblank just started
   4587  f4d8		       a9 00		      lda	#0
   4588  f4da		       85 4d		      sta	visibleover
   4589  f4dc		       a9 03		      lda	#3
   4590  f4de		       8d b2 01 	      sta	interruptindex
   4591  f4e1		       60		      rts
   4592  f4e2
   4593  f4e2				   createallgamedlls
   4594  f4e2		       a2 00		      ldx	#0
   4595  f4e4		       a9 19		      lda	#NVLINES
   4596  f4e6		       ac 09 21 	      ldy	paldetected
   4597  f4e9		       f0 03		      beq	skipcreatePALpadding
   4598  f4eb		       18		      clc
   4599  f4ec		       69 15		      adc	#21
   4600  f4ee				   skipcreatePALpadding
   4601  f4ee		       20 2c f5 	      jsr	createnonvisibledlls
   4602  f4f1		       8e 3c 21 	      stx	visibleDLLstart
   4603  f4f4		       20 66 f5 	      jsr	createvisiblezones
   4604  f4f7		       8e 3d 21 	      stx	overscanDLLstart
   4605  f4fa				   createallgamedllscontinue
   4606  f4fa		       a9 50		      lda	#(NVLINES+55)	; extras for PAL
   4607  f4fc		       20 2c f5 	      jsr	createnonvisibledlls
   4608  f4ff
   4609  f4ff		       ae 3c 21 	      ldx	visibleDLLstart
   4610  f502		       bd 00 18 	      lda	DLLMEM,x
   4611  f505		       09 80		      ora	#%10000000	; NMI 1 - start of visible screen
   4612  f507		       9d 00 18 	      sta	DLLMEM,x
   4613  f50a					      ifconst	DOUBLEBUFFER
   4614  f50a		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4615  f50d					      endif		; DOUBLEBUFFER
   4616  f50d
   4617  f50d		       ae 3d 21 	      ldx	overscanDLLstart
   4618  f510		       bd 00 18 	      lda	DLLMEM,x
   4619  f513		       09 83		      ora	#%10000011	; NMI 2 - end of visible screen
   4620  f515		       29 f3		      and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   4621  f517		       9d 00 18 	      sta	DLLMEM,x
   4622  f51a					      ifconst	DOUBLEBUFFER
   4623  f51a		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4624  f51d					      endif		; DOUBLEBUFFER
   4625  f51d
   4626  f51d		       e8		      inx
   4627  f51e		       e8		      inx
   4628  f51f		       e8		      inx
   4629  f520
   4630  f520		       bd 00 18 	      lda	DLLMEM,x
   4631  f523		       09 80		      ora	#%10000000	; NMI 3 - deeper overscan
   4632  f525		       9d 00 18 	      sta	DLLMEM,x
   4633  f528					      ifconst	DOUBLEBUFFER
   4634  f528		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4635  f52b					      endif		; DOUBLEBUFFER
   4636  f52b
   4637  f52b		       60		      rts
   4638  f52c
   4639  f52c				   createnonvisibledlls
   4640  f52c		       85 42		      sta	temp1
   4641  f52e		       4a		      lsr
   4642  f52f		       4a		      lsr
   4643  f530		       4a		      lsr
   4644  f531		       4a		      lsr		; /16
   4645  f532		       f0 09		      beq	skipcreatenonvisibledlls1loop
   4646  f534		       a8		      tay
   4647  f535				   createnonvisibledlls1loop
   4648  f535		       a9 4f		      lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   4649  f537		       20 4c f5 	      jsr	createblankdllentry
   4650  f53a		       88		      dey
   4651  f53b		       d0 f8		      bne	createnonvisibledlls1loop
   4652  f53d				   skipcreatenonvisibledlls1loop
   4653  f53d		       a5 42		      lda	temp1
   4654  f53f		       29 0f		      and	#%00001111
   4655  f541		       f0 08		      beq	createnonvisibledllsreturn
   4656  f543		       38		      sec
   4657  f544		       e9 01		      sbc	#1
   4658  f546		       09 40		      ora	#%01000000
   4659  f548		       20 4c f5 	      jsr	createblankdllentry
   4660  f54b				   createnonvisibledllsreturn
   4661  f54b		       60		      rts
   4662  f54c
   4663  f54c				   createblankdllentry
   4664  f54c		       9d 00 18 	      sta	DLLMEM,x
   4665  f54f					      ifconst	DOUBLEBUFFER
   4666  f54f		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4667  f552					      endif		; DOUBLEBUFFER
   4668  f552		       e8		      inx
   4669  f553		       a9 21		      lda	#$21	; blank
   4670  f555		       9d 00 18 	      sta	DLLMEM,x
   4671  f558					      ifconst	DOUBLEBUFFER
   4672  f558		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4673  f55b					      endif		; DOUBLEBUFFER
   4674  f55b		       e8		      inx
   4675  f55c		       a9 00		      lda	#$00
   4676  f55e		       9d 00 18 	      sta	DLLMEM,x
   4677  f561					      ifconst	DOUBLEBUFFER
   4678  f561		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4679  f564					      endif		; DOUBLEBUFFER
   4680  f564		       e8		      inx
   4681  f565		       60		      rts
   4682  f566
   4683  f566				   createvisiblezones
   4684  f566		       a0 00		      ldy	#0
   4685  f568				   createvisiblezonesloop
   4686  f568		       b9 30 f7 	      lda.w	DLHEIGHT,y
   4687  f56b		       09 40		      ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   4688  f56d		       9d 00 18 	      sta	DLLMEM,x
   4689  f570					      ifconst	DOUBLEBUFFER
   4690  f570		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4691  f573					      endif		; DOUBLEBUFFER
   4692  f573		       e8		      inx
   4693  f574		       b9 18 f7 	      lda	DLPOINTH,y
   4694  f577		       9d 00 18 	      sta	DLLMEM,x
   4695  f57a					      ifconst	DOUBLEBUFFER
   4696  f57a		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4697  f57d					      endif		; DOUBLEBUFFER
   4698  f57d		       e8		      inx
   4699  f57e		       b9 24 f7 	      lda	DLPOINTL,y
   4700  f581		       9d 00 18 	      sta	DLLMEM,x
   4701  f584					      ifconst	DOUBLEBUFFER
   4702  f584		       18		      clc
   4703  f585		       69 48		      adc	#DOUBLEBUFFEROFFSET
   4704  f587		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   4705  f58a		       90 03		      bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   4706  f58c		       fe 6f 18 	      inc	DLLMEM+DBOFFSET-1,x
   4707  f58f				   skiphidoublebufferadjust
   4708  f58f					      endif		; DOUBLEBUFFER
   4709  f58f		       e8		      inx
   4710  f590		       c8		      iny
   4711  f591		       c0 0c		      cpy	#WZONECOUNT
   4712  f593		       d0 d3		      bne	createvisiblezonesloop
   4713  f595		       60		      rts
   4714  f596
   4715  f596				   waitforvblankstart
   4716  f596				   visibleoverwait
   4717  f596		       24 28		      BIT	MSTAT
   4718  f598		       10 fc		      bpl	visibleoverwait
   4719  f59a				   vblankstartwait
   4720  f59a		       24 28		      BIT	MSTAT
   4721  f59c		       30 fc		      bmi	vblankstartwait
   4722  f59e		       60		      rts
   4723  f59f
   4724  f59f					      ifconst	DOUBLEBUFFER
   4725  f59f				   flipdisplaybufferreturn
   4726  f59f		       60		      rts
   4727  f5a0				   flipdisplaybuffer
   4728  f5a0		       a5 d5		      lda	doublebufferstate
   4729  f5a2		       f0 fb		      beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4730  f5a4
   4731  f5a4		       20 3d f1 	      jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4732  f5a7
   4733  f5a7		       a5 d5		      lda	doublebufferstate
   4734  f5a9		       4a		      lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4735  f5aa		       aa		      tax
   4736  f5ab
   4737  f5ab							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4738  f5ab
   4739  f5ab				   flipdisplaybufferwait1
   4740  f5ab		       a5 4d		      lda	visibleover
   4741  f5ad		       f0 fc		      beq	flipdisplaybufferwait1
   4742  f5af
   4743  f5af				   flipdisplaybufferwait
   4744  f5af		       a5 4d		      lda	visibleover
   4745  f5b1		       d0 fc		      bne	flipdisplaybufferwait
   4746  f5b3
   4747  f5b3		       ad b4 01 	      lda	doublebufferminimumframetarget
   4748  f5b6		       f0 0b		      beq	skipminimumframecode
   4749  f5b8		       ad b5 01 	      lda	doublebufferminimumframeindex
   4750  f5bb		       d0 ee		      bne	flipdisplaybufferwait1
   4751  f5bd		       ad b4 01 	      lda	doublebufferminimumframetarget
   4752  f5c0		       8d b5 01 	      sta	doublebufferminimumframeindex
   4753  f5c3				   skipminimumframecode
   4754  f5c3
   4755  f5c3		       bd 23 f6 	      lda	DLLMEMLutHi,x
   4756  f5c6		       85 2c		      sta	DPPH
   4757  f5c8		       bd 21 f6 	      lda	DLLMEMLutLo,x
   4758  f5cb		       85 30		      sta	DPPL
   4759  f5cd
   4760  f5cd		       bd 25 f6 	      lda	NewPageflipstate,x
   4761  f5d0		       85 d5		      sta	doublebufferstate
   4762  f5d2		       bd 27 f6 	      lda	NewPageflipoffset,x
   4763  f5d5		       85 d6		      sta	doublebufferdloffset
   4764  f5d7
   4765  f5d7		       a5 d7		      lda	doublebufferbufferdirty
   4766  f5d9		       f0 c4		      beq	flipdisplaybufferreturn
   4767  f5db
   4768  f5db							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4769  f5db							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4770  f5db							; from the displayed buffer to the working buffer...
   4771  f5db
   4772  f5db		       a5 d6		      lda	doublebufferdloffset
   4773  f5dd		       49 48		      eor	#DOUBLEBUFFEROFFSET
   4774  f5df		       85 47		      sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4775  f5e1
   4776  f5e1		       a2 0b		      ldx	#(WZONECOUNT-1)
   4777  f5e3				   copybufferzoneloop
   4778  f5e3
   4779  f5e3		       bd 24 f7 	      lda	DLPOINTL,x
   4780  f5e6		       18		      clc
   4781  f5e7		       65 d6		      adc	doublebufferdloffset
   4782  f5e9		       85 42		      sta	temp1
   4783  f5eb		       bd 18 f7 	      lda	DLPOINTH,x
   4784  f5ee		       69 00		      adc	#0
   4785  f5f0		       85 43		      sta	temp2
   4786  f5f2
   4787  f5f2		       bd 24 f7 	      lda	DLPOINTL,x
   4788  f5f5		       18		      clc
   4789  f5f6		       65 47		      adc	temp6
   4790  f5f8		       85 44		      sta	temp3
   4791  f5fa		       bd 18 f7 	      lda	DLPOINTH,x
   4792  f5fd		       69 00		      adc	#0
   4793  f5ff		       85 45		      sta	temp4
   4794  f601
   4795  f601		       b5 82		      lda	dlendsave,x
   4796  f603		       a8		      tay
   4797  f604				   copybuffercharsloop
   4798  f604		       b1 44		      lda	(temp3),y
   4799  f606		       91 42		      sta	(temp1),y
   4800  f608		       88		      dey
   4801  f609		       10 f9		      bpl	copybuffercharsloop
   4802  f60b		       ca		      dex
   4803  f60c		       10 d5		      bpl	copybufferzoneloop
   4804  f60e		       a9 00		      lda	#0
   4805  f610		       85 d7		      sta	doublebufferbufferdirty
   4806  f612		       60		      rts
   4807  f613
   4808  f613				   doublebufferoff
   4809  f613		       a9 01		      lda	#1
   4810  f615		       85 d5		      sta	doublebufferstate
   4811  f617		       20 a0 f5 	      jsr	flipdisplaybuffer
   4812  f61a		       a9 00		      lda	#0
   4813  f61c		       85 d5		      sta	doublebufferstate
   4814  f61e		       85 d6		      sta	doublebufferdloffset
   4815  f620		       60		      rts
   4816  f621
   4817  f621				   DLLMEMLutLo
   4818  f621		       00 70		      .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   4819  f623				   DLLMEMLutHi
   4820  f623		       18 18		      .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   4821  f625				   NewPageflipstate
   4822  f625		       03 01		      .byte.b	3,1
   4823  f627				   NewPageflipoffset
   4824  f627		       48 00		      .byte.b	DOUBLEBUFFEROFFSET,0
   4825  f629
   4826  f629					      endif		; DOUBLEBUFFER
   4827  f629
   4828  f629				  -	      ifconst	MOUSESUPPORT
   4829  f629				  -	      ifnconst	DRIVINGSUPPORT
   4830  f629				  -rotationalcompare
   4831  f629				  -			; new=00, old=xx
   4832  f629				  -	      .byte	$00, $01, $ff, $00
   4833  f629				  -			; new=01, old=xx
   4834  f629				  -	      .byte	$ff, $00, $00, $01
   4835  f629				  -			; new=10, old=xx
   4836  f629				  -	      .byte	$01, $00, $00, $ff
   4837  f629				  -			; new=11, old=xx
   4838  f629				  -	      .byte	$00, $ff, $01, $00
   4839  f629				  -	      endif
   4840  f629				  -
   4841  f629				  -			;  0000YyXx st mouse
   4842  f629				  -			;  0000xyXY amiga mouse
   4843  f629				  -amigatoataribits		; swap bits 1 and 4...
   4844  f629				  -	      .byte	%00000000, %00001000, %00000010, %00001010
   4845  f629				  -	      .byte	%00000100, %00001100, %00000110, %00001110
   4846  f629				  -	      .byte	%00000001, %00001001, %00000011, %00001011
   4847  f629				  -	      .byte	%00000101, %00001101, %00000111, %00001111
   4848  f629				  -
   4849  f629				  -mouseupdate
   4850  f629				  -			;LONGDEBUG = 1
   4851  f629				  -	      lda	SWCHA
   4852  f629				  -	      and	#$0f
   4853  f629				  -	      sta	inttemp2
   4854  f629				  -	      lda	SWCHA
   4855  f629				  -	      lsr
   4856  f629				  -	      lsr
   4857  f629				  -	      lsr
   4858  f629				  -	      lsr
   4859  f629				  -	      sta	inttemp1
   4860  f629				  -
   4861  f629				  -	      lda	port0control,x
   4862  f629				  -	      cmp	#8	; st mouse
   4863  f629				  -	      beq	domousecontrol
   4864  f629				  -	      cmp	#9	; amiga mouse
   4865  f629				  -	      bne	skipmousecontrol
   4866  f629				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   4867  f629				  -			;  0000YyXx st mouse
   4868  f629				  -			;  0000xyXY amiga mouse
   4869  f629				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   4870  f629				  -	      lda	inttemp1,x
   4871  f629				  -	      tay
   4872  f629				  -	      lda	amigatoataribits,y
   4873  f629				  -	      sta	inttemp1,x
   4874  f629				  -domousecontrol
   4875  f629				  -			;port X has a mouse enabled
   4876  f629				  -	      lda	inttemp1,x
   4877  f629				  -	      and	#%00000011
   4878  f629				  -	      asl
   4879  f629				  -	      asl
   4880  f629				  -	      ora	mousecodex0,x
   4881  f629				  -	      and	#%00001111
   4882  f629				  -	      tay
   4883  f629				  -	      lda	rotationalcompare,y
   4884  f629				  -	      clc
   4885  f629				  -	      adc	mousex0,x
   4886  f629				  -	      sta	mousex0,x
   4887  f629				  -	      tya
   4888  f629				  -	      lsr
   4889  f629				  -	      lsr
   4890  f629				  -	      sta	mousecodex0,x
   4891  f629				  -
   4892  f629				  -	      lda	inttemp1,x
   4893  f629				  -	      and	#%00001100
   4894  f629				  -	      ora	mousecodey0,x
   4895  f629				  -	      and	#%00001111
   4896  f629				  -	      tay
   4897  f629				  -	      lda	rotationalcompare,y
   4898  f629				  -	      asl		; *2 for y axis, since it has ~double the resolution of x
   4899  f629				  -	      clc
   4900  f629				  -	      adc	mousey0,x
   4901  f629				  -	      sta	mousey0,x
   4902  f629				  -	      tya
   4903  f629				  -	      lsr
   4904  f629				  -	      lsr
   4905  f629				  -	      sta	mousecodey0,x
   4906  f629				  -skipmousecontrol
   4907  f629				  -	      jmp	longreadloopreturn
   4908  f629					      endif		; MOUSESUPPORT
   4909  f629
   4910  f629				   mousebuttonhandler		; outside of conditional, so button handler entry in LUT is valid
   4911  f629				  -	      ifconst	MOUSESUPPORT
   4912  f629				  -			; stick the mouse buttons in the correct shadow register...
   4913  f629				  -	      txa
   4914  f629				  -	      asl
   4915  f629				  -	      tay		; y=x*2
   4916  f629				  -	      lda	INPT1,y
   4917  f629				  -	      eor	#%10000000
   4918  f629				  -	      lsr
   4919  f629				  -	      sta	sINPT1,x
   4920  f629				  -
   4921  f629				  -	      lda	INPT4,x
   4922  f629				  -	      and	#%10000000
   4923  f629				  -	      eor	#%10000000
   4924  f629				  -	      ora	sINPT1,x
   4925  f629				  -	      sta	sINPT1,x
   4926  f629				  -	      jmp	buttonreadloopreturn
   4927  f629					      endif		; MOUSESUPPORT
   4928  f629
   4929  f629				  -	      ifconst	DRIVINGSUPPORT
   4930  f629				  -rotationalcompare
   4931  f629				  -			; new=00, old=xx
   4932  f629				  -	      .byte	$00, $01, $ff, $00
   4933  f629				  -			; new=01, old=xx
   4934  f629				  -	      .byte	$ff, $00, $00, $01
   4935  f629				  -			; new=10, old=xx
   4936  f629				  -	      .byte	$01, $00, $00, $ff
   4937  f629				  -			; new=11, old=xx
   4938  f629				  -	      .byte	$00, $ff, $01, $00
   4939  f629				  -drivingupdate
   4940  f629				  -	      ldx	#1
   4941  f629				  -	      lda	port1control
   4942  f629				  -	      cmp	#6	; check if port1=driving
   4943  f629				  -	      bne	skipfirstdrivingcontrol
   4944  f629				  -	      lda	SWCHA
   4945  f629				  -	      and	#%00000011
   4946  f629				  -	      asl
   4947  f629				  -	      asl
   4948  f629				  -drivingupdateloop
   4949  f629				  -	      ora	controller0statesave,x
   4950  f629				  -	      tay
   4951  f629				  -	      lda	rotationalcompare,y
   4952  f629				  -	      clc
   4953  f629				  -	      adc	drivingposition0,x
   4954  f629				  -	      sta	drivingposition0,x
   4955  f629				  -	      tya
   4956  f629				  -	      lsr
   4957  f629				  -	      lsr
   4958  f629				  -	      sta	controller0statesave,x
   4959  f629				  -skipfirstdrivingcontrol
   4960  f629				  -	      lda	port0control
   4961  f629				  -	      cmp	#6	; check if port0=driving
   4962  f629				  -	      bne	drivingcontrolsloopdone
   4963  f629				  -	      lda	SWCHA
   4964  f629				  -	      and	#%00110000
   4965  f629				  -	      lsr
   4966  f629				  -	      lsr
   4967  f629				  -	      dex
   4968  f629				  -	      bpl	drivingupdateloop
   4969  f629				  -drivingcontrolsloopdone
   4970  f629				  -	      rts
   4971  f629					      endif		; DRIVINGSUPPORT
   4972  f629
   4973  f629				  -	      ifconst	KEYPADSUPPORT
   4974  f629				  -			; ** select keypad rows 0 to 3 over 4 frames...
   4975  f629				  -keypadrowselect
   4976  f629				  -	      ldy	#0
   4977  f629				  -	      lda	port0control
   4978  f629				  -	      cmp	#7
   4979  f629				  -	      bne	skipport0val
   4980  f629				  -	      iny		; y=y+1
   4981  f629				  -skipport0val
   4982  f629				  -	      lda	port1control
   4983  f629				  -	      cmp	#7
   4984  f629				  -	      bne	skipport1val
   4985  f629				  -	      iny
   4986  f629				  -	      iny		; y=y+2
   4987  f629				  -skipport1val
   4988  f629				  -	      lda	keyrowdirectionmask,y
   4989  f629				  -	      sta	CTLSWA
   4990  f629				  -	      tya
   4991  f629				  -	      asl
   4992  f629				  -	      asl
   4993  f629				  -	      sta	inttemp1
   4994  f629				  -	      lda	framecounter
   4995  f629				  -	      and	#3
   4996  f629				  -	      ora	inttemp1
   4997  f629				  -	      tax
   4998  f629				  -	      lda	keyrowselectvalue,x
   4999  f629				  -	      sta	SWCHA
   5000  f629				  -	      rts
   5001  f629				  -
   5002  f629				  -keyrowdirectionmask
   5003  f629				  -	      .byte	#%00000000	; 0 : port0=input  port1=input
   5004  f629				  -	      .byte	#%11110000	; 1 : port0=output port1=input
   5005  f629				  -	      .byte	#%00001111	; 2 : port0=input  port1=output
   5006  f629				  -	      .byte	#%11111111	; 3 : port0=output port1=output
   5007  f629				  -
   5008  f629				  -keyrowselectvalue
   5009  f629				  -	      .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   5010  f629				  -	      .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   5011  f629				  -	      .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   5012  f629				  -	      .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   5013  f629					      endif		;  KEYPADSUPPORT
   5014  f629
   5015  f629				  -	      ifconst	KEYPADSUPPORT
   5016  f629				  -keypadcolumnread
   5017  f629				  -	      lda	framecounter
   5018  f629				  -	      and	#3
   5019  f629				  -	      asl		; x2 because keypad variables are interleaved
   5020  f629				  -	      tax
   5021  f629				  -
   5022  f629				  -	      lda	#0
   5023  f629				  -	      sta	keypadmatrix0a,x
   5024  f629				  -	      sta	keypadmatrix1a,x
   5025  f629				  -
   5026  f629				  -	      lda	INPT0
   5027  f629				  -	      cmp	#$80
   5028  f629				  -	      rol	keypadmatrix0a,x
   5029  f629				  -	      lda	INPT1
   5030  f629				  -	      cmp	#$80
   5031  f629				  -	      rol	keypadmatrix0a,x
   5032  f629				  -	      lda	INPT4
   5033  f629				  -	      cmp	#$80
   5034  f629				  -	      rol	keypadmatrix0a,x
   5035  f629				  -	      lda	keypadmatrix0a,x
   5036  f629				  -	      eor	#%00000111
   5037  f629				  -	      sta	keypadmatrix0a,x
   5038  f629				  -
   5039  f629				  -	      rol	keypadmatrix1a,x
   5040  f629				  -	      lda	INPT2
   5041  f629				  -	      cmp	#$80
   5042  f629				  -	      rol	keypadmatrix1a,x
   5043  f629				  -	      lda	INPT3
   5044  f629				  -	      cmp	#$80
   5045  f629				  -	      rol	keypadmatrix1a,x
   5046  f629				  -	      lda	INPT5
   5047  f629				  -	      cmp	#$80
   5048  f629				  -	      rol	keypadmatrix1a,x
   5049  f629				  -	      lda	keypadmatrix1a,x
   5050  f629				  -	      eor	#%00000111
   5051  f629				  -	      sta	keypadmatrix1a,x
   5052  f629				  -
   5053  f629				  -	      rts
   5054  f629					      endif		; KEYPADSUPPORT
   5055  f629
   5056  f629				   setportforinput
   5057  f629		       a5 e4		      lda	CTLSWAs
   5058  f62b		       3d 34 f6 	      and	allpinsinputlut,x
   5059  f62e		       85 e4		      sta	CTLSWAs
   5060  f630		       8d 81 02 	      sta	CTLSWA
   5061  f633		       60		      rts
   5062  f634
   5063  f634				   allpinsinputlut
   5064  f634		       0f f0		      .byte.b	$0F, $F0
   5065  f636
   5066  f636				   setonebuttonmode
   5067  f636		       a9 14		      lda	#$14
   5068  f638		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   5069  f63b		       a5 e5		      lda	CTLSWBs
   5070  f63d		       1d 46 f6 	      ora	thisjoy2buttonbit,x
   5071  f640		       85 e5		      sta	CTLSWBs
   5072  f642		       8d 82 02 	      sta	SWCHB	; turn off the 2-button disable bits
   5073  f645		       60		      rts
   5074  f646
   5075  f646				   thisjoy2buttonbit
   5076  f646		       04 10		      .byte.b	$04, $10
   5077  f648
   5078  f648				   settwobuttonmode
   5079  f648		       a9 14		      lda	#$14
   5080  f64a		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   5081  f64d		       a5 e5		      lda	CTLSWBs
   5082  f64f		       3d 58 f6 	      and	thisjoy2buttonmask,x
   5083  f652		       85 e5		      sta	CTLSWBs
   5084  f654		       8d 82 02 	      sta	SWCHB
   5085  f657		       60		      rts
   5086  f658
   5087  f658				   thisjoy2buttonmask
   5088  f658		       fb ef		      .byte.b	$fb, $ef
   5089  f65a
   5090  f65a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5091  f65a
   5092  f65a				   START
   5093  f65a				   start
   5094  f65a
   5095  f65a							;******** more or less the Atari recommended startup procedure
   5096  f65a
   5097  f65a		       78		      sei
   5098  f65b		       d8		      cld
   5099  f65c
   5100  f65c					      ifnconst	NOTIALOCK
   5101  f65c		       a9 07		      lda	#$07
   5102  f65e				  -	      else
   5103  f65e				  -	      lda	#$06
   5104  f65e					      endif
   5105  f65e		       85 01		      sta	INPTCTRL	;lock 7800 into 7800 mode
   5106  f660		       a9 7f		      lda	#$7F
   5107  f662		       85 3c		      sta	CTRL	;disable DMA
   5108  f664		       a9 00		      lda	#$00
   5109  f666		       85 38		      sta	OFFSET
   5110  f668					      ifnconst	NOTIALOCK
   5111  f668		       85 01		      sta	INPTCTRL
   5112  f66a					      endif
   5113  f66a		       a2 ff		      ldx	#$FF
   5114  f66c		       9a		      txs
   5115  f66d
   5116  f66d							;************** Clear Memory
   5117  f66d
   5118  f66d		       a2 40		      ldx	#$40
   5119  f66f		       a9 00		      lda	#$00
   5120  f671				   crloop1
   5121  f671		       95 00		      sta	$00,x	;Clear zero page
   5122  f673		       9d 00 01 	      sta	$100,x	;Clear page 1
   5123  f676		       e8		      inx
   5124  f677		       d0 f8		      bne	crloop1
   5125  f679
   5126  f679
   5127  f679		       a0 00		      ldy	#$00	;Clear Ram
   5128  f67b		       a9 18		      lda	#$18	;Start at $1800
   5129  f67d		       85 81		      sta	$81
   5130  f67f		       a9 00		      lda	#$00
   5131  f681		       85 80		      sta	$80
   5132  f683				   crloop3
   5133  f683		       a9 00		      lda	#$00
   5134  f685		       91 80		      sta	($80),y	;Store data
   5135  f687		       c8		      iny		;Next byte
   5136  f688		       d0 f9		      bne	crloop3	;Branch if not done page
   5137  f68a		       e6 81		      inc	$81	;Next page
   5138  f68c		       a5 81		      lda	$81
   5139  f68e		       c9 20		      cmp	#$20	;End at $1FFF
   5140  f690		       d0 f1		      bne	crloop3	;Branch if not
   5141  f692
   5142  f692		       a0 00		      ldy	#$00	;Clear Ram
   5143  f694		       a9 22		      lda	#$22	;Start at $2200
   5144  f696		       85 81		      sta	$81
   5145  f698		       a9 00		      lda	#$00
   5146  f69a		       85 80		      sta	$80
   5147  f69c				   crloop4
   5148  f69c		       a9 00		      lda	#$00
   5149  f69e		       91 80		      sta	($80),y	;Store data
   5150  f6a0		       c8		      iny		;Next byte
   5151  f6a1		       d0 f9		      bne	crloop4	;Branch if not done page
   5152  f6a3		       e6 81		      inc	$81	;Next page
   5153  f6a5		       a5 81		      lda	$81
   5154  f6a7		       c9 27		      cmp	#$27	;End at $27FF
   5155  f6a9		       d0 f1		      bne	crloop4	;Branch if not
   5156  f6ab
   5157  f6ab		       a2 00		      ldx	#$00
   5158  f6ad		       a9 00		      lda	#$00
   5159  f6af				   crloop5		;Clear 2100-213F, 2000-203F
   5160  f6af		       9d 00 20 	      sta	$2000,x
   5161  f6b2		       9d 00 21 	      sta	$2100,x
   5162  f6b5		       e8		      inx
   5163  f6b6		       e0 40		      cpx	#$40
   5164  f6b8		       d0 f5		      bne	crloop5
   5165  f6ba
   5166  f6ba		       85 80		      sta	$80
   5167  f6bc		       85 81		      sta	$81
   5168  f6be		       85 82		      sta	$82
   5169  f6c0		       85 83		      sta	$83
   5170  f6c2
   5171  f6c2							;seed random number with hopefully-random timer value
   5172  f6c2		       a9 01		      lda	#1
   5173  f6c4		       0d 84 02 	      ora	INTIM
   5174  f6c7		       85 40		      sta	rand
   5175  f6c9
   5176  f6c9							; detect the console type...
   5177  f6c9				   pndetectvblankstart
   5178  f6c9		       a5 28		      lda	MSTAT
   5179  f6cb		       10 fc		      bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5180  f6cd				   pndetectvblankover
   5181  f6cd		       a5 28		      lda	MSTAT
   5182  f6cf		       30 fc		      bmi	pndetectvblankover	;  then wait for it to be over
   5183  f6d1		       a0 00		      ldy	#$00
   5184  f6d3		       a2 00		      ldx	#$00
   5185  f6d5				   pndetectvblankhappening
   5186  f6d5		       a5 28		      lda	MSTAT
   5187  f6d7		       30 07		      bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   5188  f6d9		       85 24		      sta	WSYNC
   5189  f6db		       85 24		      sta	WSYNC
   5190  f6dd		       e8		      inx
   5191  f6de		       d0 f5		      bne	pndetectvblankhappening
   5192  f6e0				   pndetectinvblank
   5193  f6e0		       e0 7d		      cpx	#125
   5194  f6e2		       90 02		      bcc	pndetecispal
   5195  f6e4		       a0 01		      ldy	#$01
   5196  f6e6				   pndetecispal
   5197  f6e6		       8c 09 21 	      sty	paldetected
   5198  f6e9
   5199  f6e9		       20 e2 f4 	      jsr	createallgamedlls
   5200  f6ec
   5201  f6ec		       a9 18		      lda	#>DLLMEM
   5202  f6ee		       85 2c		      sta	DPPH
   5203  f6f0		       a9 00		      lda	#<DLLMEM
   5204  f6f2		       85 30		      sta	DPPL
   5205  f6f4
   5206  f6f4							; CTRL 76543210
   5207  f6f4							; 7 colorburst kill
   5208  f6f4							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5209  f6f4							; 4 character width 1=2 byte chars, 0=1 byte chars
   5210  f6f4							; 3 border control 0=background color border, 1=black border
   5211  f6f4							; 2 kangaroo mode 0=transparancy, 1=kangaroo
   5212  f6f4							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5213  f6f4
   5214  f6f4				  -	      ifconst	DOUBLEWIDE
   5215  f6f4				  -	      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5216  f6f4					      else
   5217  f6f4		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5218  f6f6					      endif
   5219  f6f6		       85 3c		      sta	CTRL
   5220  f6f8		       8d 07 21 	      sta	sCTRL
   5221  f6fb
   5222  f6fb		       20 d5 f4 	      jsr	vblankresync
   5223  f6fe
   5224  f6fe		       a9 04		      lda	#%00000100	; leave cartridge plugged in for any testing
   5225  f700		       8d b7 01 	      sta	XCTRL1s
   5226  f703
   5227  f703				  -	      ifconst	pokeysupport
   5228  f703				  -			; pokey support is compiled in, so try to detect it...
   5229  f703				  -	      jsr	detectpokeylocation
   5230  f703					      endif
   5231  f703
   5232  f703		       a9 01		      lda	#1	; default for port 0 and 1 is a regular joystick
   5233  f705		       8d e2 01 	      sta	port0control
   5234  f708		       8d e3 01 	      sta	port1control
   5235  f70b
   5236  f70b							;Setup port A to read mode
   5237  f70b							;lda #$00
   5238  f70b							;sta SWCHA
   5239  f70b							;sta CTLSWA
   5240  f70b
   5241  f70b				  -	      ifconst	HSSUPPORT
   5242  f70b				  -			; try to detect HSC
   5243  f70b				  -	      jsr	detecthsc
   5244  f70b				  -	      and	#1
   5245  f70b				  -	      sta	hsdevice
   5246  f70b				  -skipHSCdetect
   5247  f70b				  -			; try to detect AtariVox eeprom
   5248  f70b				  -	      jsr	detectatarivoxeeprom
   5249  f70b				  -	      and	#2
   5250  f70b				  -	      ora	hsdevice
   5251  f70b				  -	      cmp	#3
   5252  f70b				  -	      bne	storeAinhsdevice
   5253  f70b				  -			; For now, we tie break by giving HSC priority over AtariVox.
   5254  f70b				  -			; Later we should check each device's priority byte if set, instead, 
   5255  f70b				  -	      lda	#2
   5256  f70b				  -storeAinhsdevice
   5257  f70b				  -	      sta	hsdevice
   5258  f70b				  -	      lda	#$ff
   5259  f70b				  -	      sta	hsdifficulty
   5260  f70b				  -	      sta	hsgameslot
   5261  f70b				  -	      sta	hsnewscoreline
   5262  f70b					      endif
   5263  f70b
   5264  f70b				  -	      ifconst	AVOXVOICE
   5265  f70b				  -	      jsr	silenceavoxvoice
   5266  f70b					      endif
   5267  f70b
   5268  f70b				  -	      ifconst	SGRAM
   5269  f70b				  -			; check if we actually have SGRAM. If not, probe XM for it...
   5270  f70b				  -	      ldy	#$EA
   5271  f70b				  -	      sty	$4000
   5272  f70b				  -	      ldy	$4000
   5273  f70b				  -	      cpy	#$EA
   5274  f70b				  -	      beq	skipSGRAMcheck
   5275  f70b				  -	      lda	XCTRL1s
   5276  f70b				  -	      ora	#%01100100
   5277  f70b				  -	      sta	XCTRL1
   5278  f70b				  -	      sty	$4000
   5279  f70b				  -	      ldy	$4000
   5280  f70b				  -	      cpy	#$EA
   5281  f70b				  -	      bne	skipSGRAMcheck
   5282  f70b				  -			;if we're here, XM memory satisfied our RAM requirement
   5283  f70b				  -	      sta	XCTRL1s	; save it
   5284  f70b				  -	      lda	#$10
   5285  f70b				  -	      sta	XCTRL2
   5286  f70b				  -	      sta	XCTRL3
   5287  f70b				  -skipSGRAMcheck
   5288  f70b					      endif
   5289  f70b
   5290  f70b				  -	      ifconst	TURNEDOFF
   5291  f70b				  -	      ldx	#1
   5292  f70b				  -	      ldy	#3
   5293  f70b				  -joystickdetectloop
   5294  f70b				  -	      jsr	setonebuttonmode
   5295  f70b				  -			; ensure we're in one-button mode and check for a genesis controller
   5296  f70b				  -	      lda	INPT0,y
   5297  f70b				  -	      and	#$80
   5298  f70b				  -	      sta	genesisdetected0,x
   5299  f70b				  -	      bne	skipsetgenesistwobutton
   5300  f70b				  -skipsetgenesis
   5301  f70b				  -	      jsr	settwobuttonmode
   5302  f70b				  -skipsetgenesistwobutton
   5303  f70b				  -	      dey
   5304  f70b				  -	      dey
   5305  f70b				  -	      dex
   5306  f70b				  -	      bpl	joystickdetectloop
   5307  f70b					      endif
   5308  f70b
   5309  f70b		       a2 01		      ldx	#1
   5310  f70d		       20 48 f6 	      jsr	settwobuttonmode
   5311  f710		       a2 00		      ldx	#0
   5312  f712		       20 48 f6 	      jsr	settwobuttonmode
   5313  f715
   5314  f715				  -	      ifconst	bankswitchmode
   5315  f715				  -			; we need to switch to the first bank before we jump there!
   5316  f715				  -	      ifconst	MCPDEVCART
   5317  f715				  -	      lda	#$18	; xxx11nnn - switch to bank 0
   5318  f715				  -	      sta	$3000
   5319  f715				  -	      else
   5320  f715				  -	      lda	#0
   5321  f715				  -	      sta	$8000
   5322  f715				  -	      endif
   5323  f715					      endif
   5324  f715
   5325  f715		       4c 13 40 	      jmp	game
   5326  f718
   5327  f718
   5328  f718							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5329  f718
   5330  f718							;************** Setup DLL entries
   5331  f718
   5332  f718							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5333  f718					      ifnconst	SCREENHEIGHT
   5334  f718		       00 c0	   WSCREENHEIGHT =	192
   5335  f718				  -	      else
   5336  f718				  -WSCREENHEIGHT =	SCREENHEIGHT
   5337  f718					      endif
   5338  f718
   5339  f718				  -	      ifnconst	ZONEHEIGHT
   5340  f718				  -WZONEHEIGHT =	16
   5341  f718					      else
   5342  f718		       00 10	   WZONEHEIGHT =	ZONEHEIGHT
   5343  f718					      endif
   5344  f718
   5345  f718					      ifnconst	ZONECOUNT
   5346  f718		       00 0c	   WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5347  f718				  -	      else
   5348  f718				  -WZONECOUNT =	ZONECOUNT
   5349  f718					      endif
   5350  f718
   5351  f718							; top of the frame, non-visible lines. this is based on NTSC,
   5352  f718							; but we add in extra NV lines at the end of the display to ensure
   5353  f718							; our PAL friends can play the game without it crashing.
   5354  f718		       00 19	   NVLINES    =	((243-WSCREENHEIGHT)/2)
   5355  f718
   5356  f718					      ifnconst	DLMEMSTART
   5357  f718				  -	      ifnconst	DOUBLEBUFFER
   5358  f718				  -WDLMEMSTART =	$1880
   5359  f718					      else
   5360  f718		       18 e0	   WDLMEMSTART =	$18E0
   5361  f718					      endif		; DOUBLEBUFFER
   5362  f718				  -	      else
   5363  f718				  -WDLMEMSTART =	DLMEMSTART
   5364  f718					      endif
   5365  f718
   5366  f718					      ifnconst	DLMEMEND
   5367  f718				  -	      ifconst	EXTRADLMEMORY
   5368  f718				  -WDLMEMEND  =	$23FF
   5369  f718					      else
   5370  f718		       1f ff	   WDLMEMEND  =	$1FFF
   5371  f718					      endif
   5372  f718				  -	      else
   5373  f718				  -WDLMEMEND  =	DLMEMEND
   5374  f718					      endif
   5375  f718
   5376  f718
   5377  f718		       07 20	   WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   5378  f718
   5379  f718				  -	      ifnconst	DOUBLEBUFFER
   5380  f718				  -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5381  f718					      else
   5382  f718		       00 46	   DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5383  f718					      endif
   5384  f718
   5385  f718		       00 48	   TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5386  f718				  -	      if	TDOUBLEBUFFEROFFSET > 255
   5387  f718				  -DOUBLEBUFFEROFFSET =	255
   5388  f718					      else
   5389  f718		       00 48	   DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5390  f718					      endif
   5391  f718
   5392  f718				  -	      ifconst	EXTRADLMEMORY
   5393  f718				  -SECONDDLHALFSTART SET	$2300
   5394  f718					      endif
   5395  f718
   5396  f718				   DLPOINTH
   5397  f718				   DLINDEX    SET	0
   5398  f718					      REPEAT	WZONECOUNT
   5399  f718				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f718				  -	      ifconst	EXTRADLMEMORY
   5401  f718				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f718				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f718				  -	      else
   5404  f718				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f718				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f718				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f718				  -	      endif
   5408  f718				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f718					      endif		; EXTRADLMEMORY
   5410  f718							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f718		       18		      .byte.b	>TMPMEMADDRESS
   5412  f718				   DLINDEX    SET	DLINDEX + 1
   5398  f718					      REPEND
   5399  f718				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f719				  -	      ifconst	EXTRADLMEMORY
   5401  f719				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f719				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f719				  -	      else
   5404  f719				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f719				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f719				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f719				  -	      endif
   5408  f719				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f719					      endif		; EXTRADLMEMORY
   5410  f719							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f719		       19		      .byte.b	>TMPMEMADDRESS
   5412  f719				   DLINDEX    SET	DLINDEX + 1
   5398  f719					      REPEND
   5399  f719				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71a				  -	      ifconst	EXTRADLMEMORY
   5401  f71a				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71a				  -	      else
   5404  f71a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71a				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71a				  -	      endif
   5408  f71a				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71a					      endif		; EXTRADLMEMORY
   5410  f71a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71a		       1a		      .byte.b	>TMPMEMADDRESS
   5412  f71a				   DLINDEX    SET	DLINDEX + 1
   5398  f71a					      REPEND
   5399  f71a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71b				  -	      ifconst	EXTRADLMEMORY
   5401  f71b				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71b				  -	      else
   5404  f71b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71b				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71b				  -	      endif
   5408  f71b				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71b					      endif		; EXTRADLMEMORY
   5410  f71b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71b		       1a		      .byte.b	>TMPMEMADDRESS
   5412  f71b				   DLINDEX    SET	DLINDEX + 1
   5398  f71b					      REPEND
   5399  f71b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71c				  -	      ifconst	EXTRADLMEMORY
   5401  f71c				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71c				  -	      else
   5404  f71c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71c				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71c				  -	      endif
   5408  f71c				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71c					      endif		; EXTRADLMEMORY
   5410  f71c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71c		       1b		      .byte.b	>TMPMEMADDRESS
   5412  f71c				   DLINDEX    SET	DLINDEX + 1
   5398  f71c					      REPEND
   5399  f71c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71d				  -	      ifconst	EXTRADLMEMORY
   5401  f71d				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71d				  -	      else
   5404  f71d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71d				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71d				  -	      endif
   5408  f71d				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71d					      endif		; EXTRADLMEMORY
   5410  f71d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71d		       1b		      .byte.b	>TMPMEMADDRESS
   5412  f71d				   DLINDEX    SET	DLINDEX + 1
   5398  f71d					      REPEND
   5399  f71d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71e				  -	      ifconst	EXTRADLMEMORY
   5401  f71e				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71e				  -	      else
   5404  f71e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71e				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71e				  -	      endif
   5408  f71e				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71e					      endif		; EXTRADLMEMORY
   5410  f71e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71e		       1c		      .byte.b	>TMPMEMADDRESS
   5412  f71e				   DLINDEX    SET	DLINDEX + 1
   5398  f71e					      REPEND
   5399  f71e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f71f				  -	      ifconst	EXTRADLMEMORY
   5401  f71f				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f71f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f71f				  -	      else
   5404  f71f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f71f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f71f				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f71f				  -	      endif
   5408  f71f				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f71f					      endif		; EXTRADLMEMORY
   5410  f71f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f71f		       1d		      .byte.b	>TMPMEMADDRESS
   5412  f71f				   DLINDEX    SET	DLINDEX + 1
   5398  f71f					      REPEND
   5399  f71f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f720				  -	      ifconst	EXTRADLMEMORY
   5401  f720				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f720				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f720				  -	      else
   5404  f720				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f720				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f720				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f720				  -	      endif
   5408  f720				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f720					      endif		; EXTRADLMEMORY
   5410  f720							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f720		       1d		      .byte.b	>TMPMEMADDRESS
   5412  f720				   DLINDEX    SET	DLINDEX + 1
   5398  f720					      REPEND
   5399  f720				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f721				  -	      ifconst	EXTRADLMEMORY
   5401  f721				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f721				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f721				  -	      else
   5404  f721				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f721				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f721				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f721				  -	      endif
   5408  f721				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f721					      endif		; EXTRADLMEMORY
   5410  f721							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f721		       1e		      .byte.b	>TMPMEMADDRESS
   5412  f721				   DLINDEX    SET	DLINDEX + 1
   5398  f721					      REPEND
   5399  f721				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f722				  -	      ifconst	EXTRADLMEMORY
   5401  f722				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f722				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f722				  -	      else
   5404  f722				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f722				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f722				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f722				  -	      endif
   5408  f722				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f722					      endif		; EXTRADLMEMORY
   5410  f722							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f722		       1e		      .byte.b	>TMPMEMADDRESS
   5412  f722				   DLINDEX    SET	DLINDEX + 1
   5398  f722					      REPEND
   5399  f722				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5400  f723				  -	      ifconst	EXTRADLMEMORY
   5401  f723				  -	      if	TMPMEMADDRESS > $1FFF
   5402  f723				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5403  f723				  -	      else
   5404  f723				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5405  f723				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5406  f723				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5407  f723				  -	      endif
   5408  f723				  -	      endif		; TMPMEMADDRESS > $1FFF
   5409  f723					      endif		; EXTRADLMEMORY
   5410  f723							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5411  f723		       1f		      .byte.b	>TMPMEMADDRESS
   5412  f723				   DLINDEX    SET	DLINDEX + 1
   5413  f724					      REPEND
   5414  f724
   5415  f724				  -	      ifconst	EXTRADLMEMORY
   5416  f724				  -	      echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5417  f724					      endif
   5418  f724
   5419  f724
   5420  f724				   DLPOINTL
   5421  f724				   DLINDEX    SET	0
   5422  f724					      REPEAT	WZONECOUNT
   5423  f724				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f724				  -	      ifconst	EXTRADLMEMORY
   5425  f724				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f724				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f724				  -	      else
   5428  f724				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f724				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f724				  -	      endif
   5431  f724				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f724					      endif		; EXTRADLMEMORY
   5433  f724		       e0		      .byte.b	<TMPMEMADDRESS
   5434  f724				   DLINDEX    SET	DLINDEX + 1
   5422  f724					      REPEND
   5423  f724				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f725				  -	      ifconst	EXTRADLMEMORY
   5425  f725				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f725				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f725				  -	      else
   5428  f725				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f725				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f725				  -	      endif
   5431  f725				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f725					      endif		; EXTRADLMEMORY
   5433  f725		       78		      .byte.b	<TMPMEMADDRESS
   5434  f725				   DLINDEX    SET	DLINDEX + 1
   5422  f725					      REPEND
   5423  f725				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f726				  -	      ifconst	EXTRADLMEMORY
   5425  f726				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f726				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f726				  -	      else
   5428  f726				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f726				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f726				  -	      endif
   5431  f726				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f726					      endif		; EXTRADLMEMORY
   5433  f726		       10		      .byte.b	<TMPMEMADDRESS
   5434  f726				   DLINDEX    SET	DLINDEX + 1
   5422  f726					      REPEND
   5423  f726				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f727				  -	      ifconst	EXTRADLMEMORY
   5425  f727				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f727				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f727				  -	      else
   5428  f727				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f727				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f727				  -	      endif
   5431  f727				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f727					      endif		; EXTRADLMEMORY
   5433  f727		       a8		      .byte.b	<TMPMEMADDRESS
   5434  f727				   DLINDEX    SET	DLINDEX + 1
   5422  f727					      REPEND
   5423  f727				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f728				  -	      ifconst	EXTRADLMEMORY
   5425  f728				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f728				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f728				  -	      else
   5428  f728				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f728				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f728				  -	      endif
   5431  f728				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f728					      endif		; EXTRADLMEMORY
   5433  f728		       40		      .byte.b	<TMPMEMADDRESS
   5434  f728				   DLINDEX    SET	DLINDEX + 1
   5422  f728					      REPEND
   5423  f728				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f729				  -	      ifconst	EXTRADLMEMORY
   5425  f729				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f729				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f729				  -	      else
   5428  f729				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f729				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f729				  -	      endif
   5431  f729				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f729					      endif		; EXTRADLMEMORY
   5433  f729		       d8		      .byte.b	<TMPMEMADDRESS
   5434  f729				   DLINDEX    SET	DLINDEX + 1
   5422  f729					      REPEND
   5423  f729				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72a				  -	      ifconst	EXTRADLMEMORY
   5425  f72a				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72a				  -	      else
   5428  f72a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72a				  -	      endif
   5431  f72a				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72a					      endif		; EXTRADLMEMORY
   5433  f72a		       70		      .byte.b	<TMPMEMADDRESS
   5434  f72a				   DLINDEX    SET	DLINDEX + 1
   5422  f72a					      REPEND
   5423  f72a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72b				  -	      ifconst	EXTRADLMEMORY
   5425  f72b				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72b				  -	      else
   5428  f72b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72b				  -	      endif
   5431  f72b				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72b					      endif		; EXTRADLMEMORY
   5433  f72b		       08		      .byte.b	<TMPMEMADDRESS
   5434  f72b				   DLINDEX    SET	DLINDEX + 1
   5422  f72b					      REPEND
   5423  f72b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72c				  -	      ifconst	EXTRADLMEMORY
   5425  f72c				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72c				  -	      else
   5428  f72c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72c				  -	      endif
   5431  f72c				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72c					      endif		; EXTRADLMEMORY
   5433  f72c		       a0		      .byte.b	<TMPMEMADDRESS
   5434  f72c				   DLINDEX    SET	DLINDEX + 1
   5422  f72c					      REPEND
   5423  f72c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72d				  -	      ifconst	EXTRADLMEMORY
   5425  f72d				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72d				  -	      else
   5428  f72d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72d				  -	      endif
   5431  f72d				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72d					      endif		; EXTRADLMEMORY
   5433  f72d		       38		      .byte.b	<TMPMEMADDRESS
   5434  f72d				   DLINDEX    SET	DLINDEX + 1
   5422  f72d					      REPEND
   5423  f72d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72e				  -	      ifconst	EXTRADLMEMORY
   5425  f72e				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72e				  -	      else
   5428  f72e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72e				  -	      endif
   5431  f72e				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72e					      endif		; EXTRADLMEMORY
   5433  f72e		       d0		      .byte.b	<TMPMEMADDRESS
   5434  f72e				   DLINDEX    SET	DLINDEX + 1
   5422  f72e					      REPEND
   5423  f72e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5424  f72f				  -	      ifconst	EXTRADLMEMORY
   5425  f72f				  -	      if	TMPMEMADDRESS > $1FFF
   5426  f72f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5427  f72f				  -	      else
   5428  f72f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5429  f72f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5430  f72f				  -	      endif
   5431  f72f				  -	      endif		; TMPMEMADDRESS > $1FFF
   5432  f72f					      endif		; EXTRADLMEMORY
   5433  f72f		       68		      .byte.b	<TMPMEMADDRESS
   5434  f72f				   DLINDEX    SET	DLINDEX + 1
   5435  f730					      REPEND
   5436  f730
   5437  f730
   5438  f730				   DLINDEX    SET	0
   5439  f730					      REPEAT	WZONECOUNT
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730					      if	DLINDEX = 0
   5451  f730		       18 e0	   ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730					      if	DLINDEX = 1
   5454  f730		       19 78	   ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730					      if	DLINDEX = 2
   5457  f730		       1a 10	   ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730					      if	DLINDEX = 3
   5460  f730		       1a a8	   ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730					      if	DLINDEX = 4
   5463  f730		       1b 40	   ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730					      if	DLINDEX = 5
   5466  f730		       1b d8	   ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730					      if	DLINDEX = 6
   5469  f730		       1c 70	   ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730					      if	DLINDEX = 7
   5472  f730		       1d 08	   ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730					      if	DLINDEX = 8
   5475  f730		       1d a0	   ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730					      if	DLINDEX = 9
   5478  f730		       1e 38	   ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730					      if	DLINDEX = 10
   5481  f730		       1e d0	   ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730				  -	      if	DLINDEX = 11
   5484  f730				  -ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5439  f730					      REPEND
   5440  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5441  f730				  -	      ifconst	EXTRADLMEMORY
   5442  f730				  -	      if	TMPMEMADDRESS > $1FFF
   5443  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5444  f730				  -	      else
   5445  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5446  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5447  f730				  -	      endif
   5448  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   5449  f730					      endif		; EXTRADLMEMORY
   5450  f730				  -	      if	DLINDEX = 0
   5451  f730				  -ZONE0ADDRESS =	TMPMEMADDRESS
   5452  f730					      endif
   5453  f730				  -	      if	DLINDEX = 1
   5454  f730				  -ZONE1ADDRESS =	TMPMEMADDRESS
   5455  f730					      endif
   5456  f730				  -	      if	DLINDEX = 2
   5457  f730				  -ZONE2ADDRESS =	TMPMEMADDRESS
   5458  f730					      endif
   5459  f730				  -	      if	DLINDEX = 3
   5460  f730				  -ZONE3ADDRESS =	TMPMEMADDRESS
   5461  f730					      endif
   5462  f730				  -	      if	DLINDEX = 4
   5463  f730				  -ZONE4ADDRESS =	TMPMEMADDRESS
   5464  f730					      endif
   5465  f730				  -	      if	DLINDEX = 5
   5466  f730				  -ZONE5ADDRESS =	TMPMEMADDRESS
   5467  f730					      endif
   5468  f730				  -	      if	DLINDEX = 6
   5469  f730				  -ZONE6ADDRESS =	TMPMEMADDRESS
   5470  f730					      endif
   5471  f730				  -	      if	DLINDEX = 7
   5472  f730				  -ZONE7ADDRESS =	TMPMEMADDRESS
   5473  f730					      endif
   5474  f730				  -	      if	DLINDEX = 8
   5475  f730				  -ZONE8ADDRESS =	TMPMEMADDRESS
   5476  f730					      endif
   5477  f730				  -	      if	DLINDEX = 9
   5478  f730				  -ZONE9ADDRESS =	TMPMEMADDRESS
   5479  f730					      endif
   5480  f730				  -	      if	DLINDEX = 10
   5481  f730				  -ZONE10ADDRESS =	TMPMEMADDRESS
   5482  f730					      endif
   5483  f730					      if	DLINDEX = 11
   5484  f730		       1f 68	   ZONE11ADDRESS =	TMPMEMADDRESS
   5485  f730					      endif
   5486  f730				  -	      if	DLINDEX = 12
   5487  f730				  -ZONE12ADDRESS =	TMPMEMADDRESS
   5488  f730					      endif
   5489  f730				  -	      if	DLINDEX = 13
   5490  f730				  -ZONE13ADDRESS =	TMPMEMADDRESS
   5491  f730					      endif
   5492  f730				  -	      if	DLINDEX = 14
   5493  f730				  -ZONE14ADDRESS =	TMPMEMADDRESS
   5494  f730					      endif
   5495  f730				  -	      if	DLINDEX = 15
   5496  f730				  -ZONE15ADDRESS =	TMPMEMADDRESS
   5497  f730					      endif
   5498  f730				  -	      if	DLINDEX = 16
   5499  f730				  -ZONE16ADDRESS =	TMPMEMADDRESS
   5500  f730					      endif
   5501  f730				  -	      if	DLINDEX = 17
   5502  f730				  -ZONE17ADDRESS =	TMPMEMADDRESS
   5503  f730					      endif
   5504  f730				  -	      if	DLINDEX = 18
   5505  f730				  -ZONE18ADDRESS =	TMPMEMADDRESS
   5506  f730					      endif
   5507  f730				  -	      if	DLINDEX = 19
   5508  f730				  -ZONE19ADDRESS =	TMPMEMADDRESS
   5509  f730					      endif
   5510  f730				  -	      if	DLINDEX = 20
   5511  f730				  -ZONE20ADDRESS =	TMPMEMADDRESS
   5512  f730					      endif
   5513  f730				  -	      if	DLINDEX = 21
   5514  f730				  -ZONE21ADDRESS =	TMPMEMADDRESS
   5515  f730					      endif
   5516  f730				  -	      if	DLINDEX = 22
   5517  f730				  -ZONE22ADDRESS =	TMPMEMADDRESS
   5518  f730					      endif
   5519  f730				  -	      if	DLINDEX = 23
   5520  f730				  -ZONE23ADDRESS =	TMPMEMADDRESS
   5521  f730					      endif
   5522  f730				  -	      if	DLINDEX = 24
   5523  f730				  -ZONE24ADDRESS =	TMPMEMADDRESS
   5524  f730					      endif
   5525  f730				  -	      if	DLINDEX = 25
   5526  f730				  -ZONE25ADDRESS =	TMPMEMADDRESS
   5527  f730					      endif
   5528  f730				  -	      if	DLINDEX = 26
   5529  f730				  -ZONE26ADDRESS =	TMPMEMADDRESS
   5530  f730					      endif
   5531  f730				  -	      if	DLINDEX = 27
   5532  f730				  -ZONE27ADDRESS =	TMPMEMADDRESS
   5533  f730					      endif
   5534  f730				   DLINDEX    SET	DLINDEX + 1
   5535  f730					      REPEND
   5536  f730
   5537  f730
     $18e0 to $1fff used as zone memory, allowing 14 display objects per zone.
   5538  f730					      echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5539  f730
   5540  f730				   DLHEIGHT
   5541  f730					      REPEAT	WZONECOUNT
   5542  f730		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f730					      REPEND
   5542  f731		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f731					      REPEND
   5542  f732		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f732					      REPEND
   5542  f733		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f733					      REPEND
   5542  f734		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f734					      REPEND
   5542  f735		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f735					      REPEND
   5542  f736		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f736					      REPEND
   5542  f737		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f737					      REPEND
   5542  f738		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f738					      REPEND
   5542  f739		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f739					      REPEND
   5542  f73a		       0f		      .byte.b	(WZONEHEIGHT-1)
   5541  f73a					      REPEND
   5542  f73b		       0f		      .byte.b	(WZONEHEIGHT-1)
   5543  f73c					      REPEND
   5544  f73c
   5545  f73c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5546  f73c
   5547  f73c							; a simple guard, than ensures the 7800basic code hasn't
   5548  f73c							; spilled into the encryption area...
     2114 bytes left in the 7800basic reserved area.
   5549  f73c					      echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5550  f73c				  -	      if	(*>$FF7D)
   5551  f73c				  -	      ERR		; abort the assembly
   5552  f73c					      endif
   5553  f73c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5554  f73c
   5555  f73c				  -	      ifconst	DEV
   5556  f73c				  -	      ifnconst	ZONEHEIGHT
   5557  f73c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5558  f73c				  -	      else
   5559  f73c				  -	      if	ZONEHEIGHT = 8
   5560  f73c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5561  f73c				  -	      else
   5562  f73c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5563  f73c				  -	      endif
   5564  f73c				  -	      endif
   5565  f73c					      endif
   5566  f73c
   5567  f73c							; FF7E/FF7F contains the 7800basic crc checksum word
   5568  f73c
   5569  f73c							; FF80 - FFF7 contains the 7800 encryption key 
   5570  f73c
   5571  f73c					      ifnconst	bankswitchmode
   5572  fff8					      ORG	$FFF8
   5573  fff8				  -	      else
   5574  fff8				  -	      ifconst	ROM128K
   5575  fff8				  -	      ORG	$27FF8
   5576  fff8				  -	      RORG	$FFF8
   5577  fff8				  -	      endif
   5578  fff8				  -	      ifconst	ROM144K
   5579  fff8				  -	      ORG	$27FF8
   5580  fff8				  -	      RORG	$FFF8
   5581  fff8				  -	      endif
   5582  fff8				  -	      ifconst	ROM256K
   5583  fff8				  -	      ORG	$47FF8
   5584  fff8				  -	      RORG	$FFF8
   5585  fff8				  -	      endif
   5586  fff8				  -	      ifconst	ROM272K
   5587  fff8				  -	      ORG	$47FF8
   5588  fff8				  -	      RORG	$FFF8
   5589  fff8				  -	      endif
   5590  fff8				  -	      ifconst	ROM512K
   5591  fff8				  -	      ORG	$87FF8
   5592  fff8				  -	      RORG	$FFF8
   5593  fff8				  -	      endif
   5594  fff8				  -	      ifconst	ROM528K
   5595  fff8				  -	      ORG	$87FF8
   5596  fff8				  -	      RORG	$FFF8
   5597  fff8				  -	      endif
   5598  fff8					      endif
   5599  fff8
   5600  fff8
   5601  fff8		       ff		      .byte.b	$FF	; region verification. $FF=all regions
   5602  fff9		       f7		      .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5603  fffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5604  fffa
   5605  fffa							;Vectors
   5606  fffa		       00 f0		      .word.w	NMI
   5607  fffc		       5a f6		      .word.w	START
   5608  fffe		       5d f0		      .word.w	IRQ
   5609  10000
