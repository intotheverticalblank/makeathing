------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm LEVEL 1 PASS 3
      1  10000 ????						; MACRO.H
      2  10000 ????
      3  10000 ????						; Based on the 2600 macro.h file.
      4  10000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  10000 ????						; has been adapted to give accurate results on the 7800.
      6  10000 ????
      7  10000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  10000 ????
      9  10000 ????						; Available macros...
     10  10000 ????						;   SLEEP n		 - sleep for n cycles
     11  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  10000 ????
     13  10000 ????						;-------------------------------------------------------------------------------
     14  10000 ????						; SLEEP duration
     15  10000 ????						; Original author: Thomas Jentzsch
     16  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  10000 ????						; useful for code where precise timing is required.
     18  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  10000 ????
     22  10000 ????				       MAC	sleep
     23  10000 ????			    .CYCLES    SET	{1}
     24  10000 ????
     25  10000 ????				       IF	.CYCLES < 2
     26  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  10000 ????				       ERR
     28  10000 ????				       ENDIF
     29  10000 ????
     30  10000 ????				       IF	.CYCLES & 1
     31  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  10000 ????				       nop	$80
     33  10000 ????				       ELSE
     34  10000 ????				       bit	$80
     35  10000 ????				       ENDIF
     36  10000 ????			    .CYCLES    SET	.CYCLES - 3
     37  10000 ????				       ENDIF
     38  10000 ????
     39  10000 ????				       REPEAT	.CYCLES / 2
     40  10000 ????				       nop
     41  10000 ????				       REPEND
     42  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  10000 ????
     44  10000 ????
     45  10000 ????						;-------------------------------------------------------------------------------
     46  10000 ????						; FRACSLEEP duration
     47  10000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  10000 ????						; 7800 based 0.5 cycle sleep.
     49  10000 ????
     50  10000 ????				       MAC	fracsleep
     51  10000 ????			    .CYCLES    SET	{1}
     52  10000 ????
     53  10000 ????				       IF	.CYCLES < 4
     54  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  10000 ????				       ERR
     56  10000 ????				       ENDIF
     57  10000 ????				       IF	.CYCLES = 5
     58  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  10000 ????				       ERR
     60  10000 ????				       ENDIF
     61  10000 ????
     62  10000 ????				       IF	.CYCLES & 1
     63  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  10000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  10000 ????				       ELSE
     66  10000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  10000 ????				       ENDIF
     68  10000 ????			    .CYCLES    SET	.CYCLES - 7
     69  10000 ????				       ENDIF
     70  10000 ????
     71  10000 ????				       IF	.CYCLES & 2
     72  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  10000 ????				       nop	$80
     74  10000 ????				       ELSE
     75  10000 ????				       bit	$80
     76  10000 ????				       ENDIF
     77  10000 ????			    .CYCLES    SET	.CYCLES - 6
     78  10000 ????				       ENDIF
     79  10000 ????
     80  10000 ????				       REPEAT	.CYCLES / 4
     81  10000 ????				       nop
     82  10000 ????				       REPEND
     83  10000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  10000 ????
     85  10000 ????
     86  10000 ????						;-------------------------------------------------------
     87  10000 ????						; SET_POINTER
     88  10000 ????						; Original author: Manuel Rotschkar
     89  10000 ????						;
     90  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  10000 ????						;
     92  10000 ????						; Usage: SET_POINTER pointer, address
     93  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  10000 ????						;
     95  10000 ????						; Note: Alters the accumulator, NZ flags
     96  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  10000 ????						; IN 2: absolute address
     98  10000 ????
     99  10000 ????				       MAC	set_pointer
    100  10000 ????			    .POINTER   SET	{1}
    101  10000 ????			    .ADDRESS   SET	{2}
    102  10000 ????
    103  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  10000 ????				       STA	.POINTER	; Store in pointer
    105  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  10000 ????
    108  10000 ????				       ENDM
    109  10000 ????
    110  10000 ????						; EOF
    111  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  10000 ????
    113  10000 ????						; 7800MACRO.H
    114  10000 ????
    115  10000 ????						;-------------------------------------------------------
    116  10000 ????						; BOXCOLLISIONCHECK
    117  10000 ????						; author: Mike Saarna
    118  10000 ????						;
    119  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  10000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  10000 ????						; 
    122  10000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  10000 ????						;
    124  10000 ????
    125  10000 ????				       MAC	boxcollisioncheck
    126  10000 ????			    .boxx1     SET	{1}
    127  10000 ????			    .boxy1     SET	{2}
    128  10000 ????			    .boxw1     SET	{3}
    129  10000 ????			    .boxh1     SET	{4}
    130  10000 ????			    .boxx2     SET	{5}
    131  10000 ????			    .boxy2     SET	{6}
    132  10000 ????			    .boxw2     SET	{7}
    133  10000 ????			    .boxh2     SET	{8}
    134  10000 ????
    135  10000 ????			    .DoXCollisionCheck
    136  10000 ????				       lda	.boxx1	;3
    137  10000 ????				       cmp	.boxx2	;2
    138  10000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  10000 ????			    .X2isbiggerthanX1
    140  10000 ????				       adc	#.boxw1	;2
    141  10000 ????				       cmp	.boxx2	;3
    142  10000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  10000 ????				       bcc	.noboxcollision	;3
    144  10000 ????			    .X1isbiggerthanX2
    145  10000 ????				       clc		;2
    146  10000 ????				       sbc	#.boxw2	;2
    147  10000 ????				       cmp	.boxx2	;3
    148  10000 ????				       bcs	.noboxcollision	;3/2
    149  10000 ????			    .DoYCollisionCheck
    150  10000 ????				       lda	.boxy1	;3
    151  10000 ????				       cmp	.boxy2	;3
    152  10000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  10000 ????			    .Y2isbiggerthanY1
    154  10000 ????				       adc	#.boxh1	;2
    155  10000 ????				       cmp	.boxy2	;3
    156  10000 ????				       jmp	.checkdone	;6 
    157  10000 ????			    .Y1isbiggerthanY2
    158  10000 ????				       clc		;2
    159  10000 ????				       sbc	#.boxh2	;2
    160  10000 ????				       cmp	.boxy2	;3
    161  10000 ????				       bcs	.noboxcollision	;3/2
    162  10000 ????			    .boxcollision
    163  10000 ????				       sec		;2
    164  10000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  10000 ????			    .noboxcollision
    166  10000 ????				       clc		;2
    167  10000 ????			    .checkdone
    168  10000 ????
    169  10000 ????				       ENDM
    170  10000 ????
    171  10000 ????						; QBOXCOLLISIONCHECK
    172  10000 ????						; author: unknown
    173  10000 ????						;
    174  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  10000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  10000 ????						; 
    177  10000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  10000 ????						;
    179  10000 ????				       MAC	qboxcollisioncheck
    180  10000 ????			    .boxx1     SET	{1}
    181  10000 ????			    .boxy1     SET	{2}
    182  10000 ????			    .boxw1     SET	{3}
    183  10000 ????			    .boxh1     SET	{4}
    184  10000 ????			    .boxx2     SET	{5}
    185  10000 ????			    .boxy2     SET	{6}
    186  10000 ????			    .boxw2     SET	{7}
    187  10000 ????			    .boxh2     SET	{8}
    188  10000 ????
    189  10000 ????				       lda	.boxx2
    190  10000 ????				       clc
    191  10000 ????				       adc	#.boxw2
    192  10000 ????				       sbc	.boxx1
    193  10000 ????				       cmp	#.boxw1+.boxw2-1
    194  10000 ????				       bcs	.qboxcollisiondone
    195  10000 ????						;if we're here, carry is clear
    196  10000 ????				       lda	.boxy2
    197  10000 ????				       adc	#.boxh2
    198  10000 ????				       sbc	.boxy1
    199  10000 ????				       cmp	#.boxh1+.boxh2-1
    200  10000 ????			    .qboxcollisiondone
    201  10000 ????				       rol		; temp for testing - invert carry...
    202  10000 ????				       eor	#1
    203  10000 ????				       ror
    204  10000 ????				       ENDM
    205  10000 ????
    206  10000 ????
    207  10000 ????				       MAC	median3
    208  10000 ????
    209  10000 ????						; A median filter (for smoothing paddle jitter)
    210  10000 ????						;   this macro takes the current paddle value, compares it to historic
    211  10000 ????						;   values, and replaces the current paddle value with the median.
    212  10000 ????						; 
    213  10000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  10000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  10000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  10000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  10000 ????						;	  the previous values, and update with the median value.
    218  10000 ????						;
    219  10000 ????						; returns: CURRENT (modified to contain median value)
    220  10000 ????						;
    221  10000 ????						; author: Mike Saarna (aka RevEng)
    222  10000 ????
    223  10000 ????			    .MedianBytes SET	{1}
    224  10000 ????			    .NewValue  SET	{2}
    225  10000 ????
    226  10000 ????				       lda	#0
    227  10000 ????				       ldy	.NewValue
    228  10000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  10000 ????
    230  10000 ????						; build an index from relative size comparisons between our 3 values.
    231  10000 ????				       cpy	.MedianBytes
    232  10000 ????				       rol
    233  10000 ????				       cpy	.MedianBytes+1
    234  10000 ????				       rol
    235  10000 ????				       ldy	.MedianBytes
    236  10000 ????				       cpy	.MedianBytes+1
    237  10000 ????				       rol
    238  10000 ????				       tay
    239  10000 ????
    240  10000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  10000 ????				       lda	.MedianBytes,x
    242  10000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  10000 ????
    244  10000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  10000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  10000 ????				       lda	.MedianBytes+1
    247  10000 ????				       sta	.MedianBytes
    248  10000 ????				       lda	.MedianBytes+2
    249  10000 ????				       sta	.MedianBytes+1
    250  10000 ????				       ifnconst	MedianOrderLUT
    251  10000 ????				       jmp	MedianOrderLUTend
    252  10000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  10000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  10000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  10000 ????				       .byte	2	; 2   impossible 
    256  10000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  10000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  10000 ????				       .byte	2	; 5   impossible 
    259  10000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  10000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  10000 ????			    MedianOrderLUTend
    262  10000 ????				       endif
    263  10000 ????				       ENDM
    264  10000 ????
    265  10000 ????				       MAC	plotsprite
    266  10000 ????
    267  10000 ????						; A macro version of the plotsprite command. 
    268  10000 ????						; This trades off rom space for speed.
    269  10000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  10000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  10000 ????
    272  10000 ????			    .GFXLabel  SET	{1}
    273  10000 ????			    .Palette   SET	{2}	; constant
    274  10000 ????			    .SpriteX   SET	{3}	; variable
    275  10000 ????			    .SpriteY   SET	{4}	; variable
    276  10000 ????			    .ByteOffset SET	{5}	; variable 
    277  10000 ????
    278  10000 ????				       lda	.SpriteY
    279  10000 ????				       lsr
    280  10000 ????				       lsr
    281  10000 ????				       asr	#%11111110	; ensure carry is clear
    282  10000 ????				       if	WZONEHEIGHT = 16
    283  10000 ????				       asr	#%11111110	; ensure carry is clear
    284  10000 ????				       endif
    285  10000 ????
    286  10000 ????				       tax
    287  10000 ????
    288  10000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    289  10000 ????				       sta	dlpnt
    290  10000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    291  10000 ????				       sta	dlpnt+1
    292  10000 ????
    293  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    294  10000 ????
    295  10000 ????				       lda	.ByteOffset
    296  10000 ????				       if	{1}_width = 2
    297  10000 ????				       asl
    298  10000 ????				       endif
    299  10000 ????				       if	{1}_width = 3
    300  10000 ????				       asl
    301  10000 ????				       adc	.ByteOffset
    302  10000 ????				       endif
    303  10000 ????				       if	{1}_width = 4
    304  10000 ????				       asl
    305  10000 ????				       asl
    306  10000 ????				       endif
    307  10000 ????				       if	{1}_width = 5
    308  10000 ????				       asl
    309  10000 ????				       asl
    310  10000 ????				       adc	.ByteOffset
    311  10000 ????				       endif
    312  10000 ????				       if	{1}_width = 6
    313  10000 ????				       asl
    314  10000 ????				       adc	.ByteOffset
    315  10000 ????				       asl
    316  10000 ????				       endif
    317  10000 ????				       if	{1}_width = 7
    318  10000 ????				       asl
    319  10000 ????				       adc	.ByteOffset
    320  10000 ????				       asl
    321  10000 ????				       adc	.ByteOffset
    322  10000 ????				       endif
    323  10000 ????				       if	{1}_width = 8
    324  10000 ????				       asl
    325  10000 ????				       asl
    326  10000 ????				       asl
    327  10000 ????				       endif
    328  10000 ????				       if	{1}_width = 9
    329  10000 ????				       asl
    330  10000 ????				       asl
    331  10000 ????				       asl
    332  10000 ????				       adc	.ByteOffset
    333  10000 ????				       endif
    334  10000 ????				       if	{1}_width = 10
    335  10000 ????				       asl
    336  10000 ????				       asl
    337  10000 ????				       adc	.ByteOffset
    338  10000 ????				       asl
    339  10000 ????				       endif
    340  10000 ????				       if	{1}_width = 11
    341  10000 ????				       asl
    342  10000 ????				       asl
    343  10000 ????				       adc	.ByteOffset
    344  10000 ????				       asl
    345  10000 ????				       adc	.ByteOffset
    346  10000 ????				       endif
    347  10000 ????				       if	{1}_width = 12
    348  10000 ????				       asl
    349  10000 ????				       adc	.ByteOffset
    350  10000 ????				       asl
    351  10000 ????				       asl
    352  10000 ????				       endif
    353  10000 ????				       if	{1}_width = 13
    354  10000 ????				       asl
    355  10000 ????				       adc	.ByteOffset
    356  10000 ????				       asl
    357  10000 ????				       asl
    358  10000 ????				       adc	.ByteOffset
    359  10000 ????				       endif
    360  10000 ????				       if	{1}_width = 14
    361  10000 ????				       asl
    362  10000 ????				       adc	.ByteOffset
    363  10000 ????				       asl
    364  10000 ????				       adc	.ByteOffset
    365  10000 ????				       asl
    366  10000 ????				       endif
    367  10000 ????
    368  10000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    369  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    370  10000 ????
    371  10000 ????				       iny
    372  10000 ????
    373  10000 ????				       lda	#({1}_mode | %01000000)
    374  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    375  10000 ????
    376  10000 ????				       iny
    377  10000 ????
    378  10000 ????				       lda	.SpriteY
    379  10000 ????				       and	#(WZONEHEIGHT - 1)
    380  10000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    381  10000 ????				       ora	#>.GFXLabel
    382  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    383  10000 ????
    384  10000 ????				       iny
    385  10000 ????
    386  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    387  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    388  10000 ????
    389  10000 ????				       iny
    390  10000 ????
    391  10000 ????				       lda	.SpriteX
    392  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    393  10000 ????
    394  10000 ????				       iny
    395  10000 ????				       sty	dlend,x
    396  10000 ????
    397  10000 ????				       ifconst	ALWAYSTERMINATE
    398  10000 ????				       iny
    399  10000 ????				       lda	#0
    400  10000 ????				       sta	(dlpnt),y
    401  10000 ????				       endif
    402  10000 ????
    403  10000 ????				       bcc	.PLOTSPRITEend
    404  10000 ????
    405  10000 ????				       inx		; next zone
    406  10000 ????
    407  10000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    408  10000 ????				       sta	dlpnt
    409  10000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    410  10000 ????				       sta	dlpnt+1
    411  10000 ????
    412  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    413  10000 ????
    414  10000 ????				       lda	.ByteOffset
    415  10000 ????				       if	{1}_width = 1
    416  10000 ????				       clc
    417  10000 ????				       endif
    418  10000 ????				       if	{1}_width = 2
    419  10000 ????				       asl		; carry clear
    420  10000 ????				       endif
    421  10000 ????				       if	{1}_width = 3
    422  10000 ????				       asl		; carry clear
    423  10000 ????				       adc	.ByteOffset
    424  10000 ????				       endif
    425  10000 ????				       if	{1}_width = 4
    426  10000 ????				       asl		; carry clear
    427  10000 ????				       asl
    428  10000 ????				       endif
    429  10000 ????				       if	{1}_width = 5
    430  10000 ????				       asl		; carry clear
    431  10000 ????				       asl
    432  10000 ????				       adc	.ByteOffset
    433  10000 ????				       endif
    434  10000 ????				       if	{1}_width = 6
    435  10000 ????				       asl		; carry clear
    436  10000 ????				       adc	.ByteOffset
    437  10000 ????				       asl
    438  10000 ????				       endif
    439  10000 ????				       if	{1}_width = 7
    440  10000 ????				       asl		; carry clear
    441  10000 ????				       adc	.ByteOffset
    442  10000 ????				       asl
    443  10000 ????				       endif
    444  10000 ????				       if	{1}_width = 8
    445  10000 ????				       asl		; carry clear
    446  10000 ????				       asl
    447  10000 ????				       asl
    448  10000 ????				       endif
    449  10000 ????				       if	{1}_width = 9
    450  10000 ????				       asl		; carry clear
    451  10000 ????				       asl
    452  10000 ????				       asl
    453  10000 ????				       adc	.ByteOffset
    454  10000 ????				       endif
    455  10000 ????				       if	{1}_width = 10
    456  10000 ????				       asl		; carry clear
    457  10000 ????				       asl
    458  10000 ????				       adc	.ByteOffset
    459  10000 ????				       asl
    460  10000 ????				       endif
    461  10000 ????				       if	{1}_width = 11
    462  10000 ????				       asl		; carry clear
    463  10000 ????				       asl
    464  10000 ????				       adc	.ByteOffset
    465  10000 ????				       asl
    466  10000 ????				       adc	.ByteOffset
    467  10000 ????				       endif
    468  10000 ????				       if	{1}_width = 12
    469  10000 ????				       asl		; carry clear
    470  10000 ????				       adc	.ByteOffset
    471  10000 ????				       asl
    472  10000 ????				       asl
    473  10000 ????				       endif
    474  10000 ????				       if	{1}_width = 13
    475  10000 ????				       asl		; carry clear
    476  10000 ????				       adc	.ByteOffset
    477  10000 ????				       asl
    478  10000 ????				       asl
    479  10000 ????				       adc	.ByteOffset
    480  10000 ????				       endif
    481  10000 ????				       if	{1}_width = 14
    482  10000 ????				       asl		; carry clear
    483  10000 ????				       adc	.ByteOffset
    484  10000 ????				       asl
    485  10000 ????				       adc	.ByteOffset
    486  10000 ????				       asl
    487  10000 ????				       endif
    488  10000 ????
    489  10000 ????				       adc	#<.GFXLabel
    490  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    491  10000 ????
    492  10000 ????				       iny
    493  10000 ????
    494  10000 ????				       lda	#({1}_mode | %01000000)
    495  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    496  10000 ????
    497  10000 ????				       iny
    498  10000 ????
    499  10000 ????				       lda	.SpriteY
    500  10000 ????				       and	#(WZONEHEIGHT - 1)
    501  10000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    502  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    503  10000 ????
    504  10000 ????				       iny
    505  10000 ????
    506  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    507  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    508  10000 ????
    509  10000 ????				       iny
    510  10000 ????
    511  10000 ????				       lda	.SpriteX
    512  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    513  10000 ????
    514  10000 ????				       iny
    515  10000 ????				       sty	dlend,x
    516  10000 ????
    517  10000 ????				       ifconst	ALWAYSTERMINATE
    518  10000 ????				       iny
    519  10000 ????				       lda	#0
    520  10000 ????				       sta	(dlpnt),y
    521  10000 ????				       endif
    522  10000 ????
    523  10000 ????			    .PLOTSPRITEend
    524  10000 ????				       ENDM
    525  10000 ????
    526  10000 ????				       MAC	sizeof
    527  10000 ????
    528  10000 ????						; echo's the size difference between the current address and the
    529  10000 ????						; a label that was passed as an argument. This is a quick way to
    530  10000 ????						; determine the size of a structure.
    531  10000 ????
    532  10000 ????			    .NAME      SETSTR	{1}
    533  10000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    534  10000 ????				       ENDM
    535  10000 ????
    536  10000 ????						;
    537  10000 ????						; speakjet.inc
    538  10000 ????						;
    539  10000 ????						;
    540  10000 ????						; AtariVox Speech Synth Driver
    541  10000 ????						;
    542  10000 ????						; By Alex Herbert, 2004
    543  10000 ????						;
    544  10000 ????
    545  10000 ????
    546  10000 ????
    547  10000 ????
    548  10000 ????						; Constants
    549  10000 ????
    550  10000 ????
    551  10000 ????		00 01	    SERIAL_OUTMASK equ	$01
    552  10000 ????		00 02	    SERIAL_RDYMASK equ	$02
    553  10000 ????
    554  10000 ????
    555  10000 ????
    556  10000 ????						; Macros
    557  10000 ????
    558  10000 ????				       mac	spkout
    559  10000 ????
    560  10000 ????						; check buffer-full status
    561  10000 ????				       lda	SWCHA
    562  10000 ????				       and	#SERIAL_RDYMASK
    563  10000 ????				       beq	.speech_done
    564  10000 ????
    565  10000 ????						; get next speech byte
    566  10000 ????				       ldy	#$00
    567  10000 ????				       lda	(speech_addr),y
    568  10000 ????
    569  10000 ????						; invert data and check for end of string
    570  10000 ????				       eor	#$ff
    571  10000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    572  10000 ????				       beq	.speech_done
    573  10000 ????				       sta	{1}
    574  10000 ????
    575  10000 ????						; increment speech pointer
    576  10000 ????				       inc	speech_addr
    577  10000 ????				       bne	.incaddr_skip
    578  10000 ????				       inc	speech_addr+1
    579  10000 ????			    .incaddr_skip
    580  10000 ????
    581  10000 ????						; output byte as serial data
    582  10000 ????
    583  10000 ????				       sec		; start bit
    584  10000 ????			    .byteout_loop
    585  10000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
    586  10000 ????				       lda	SWACNT	; 4
    587  10000 ????				       and	#$fe	; 2 6
    588  10000 ????				       adc	#$00	; 2 8
    589  10000 ????				       sta	SWACNT	; 4 12
    590  10000 ????
    591  10000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    592  10000 ????				       cpy	#$09	; 2 14
    593  10000 ????				       beq	.speech_done	; 2 16
    594  10000 ????				       iny		; 2 18
    595  10000 ????
    596  10000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    597  10000 ????						; to match the original baud rate...
    598  10000 ????						;ldx	  #$07 ; 2600
    599  10000 ????				       ldx	#$0D
    600  10000 ????
    601  10000 ????			    .delay_loop
    602  10000 ????				       dex		; 
    603  10000 ????				       bne	.delay_loop	; 36 54
    604  10000 ????
    605  10000 ????						; shift next data bit into carry
    606  10000 ????				       lsr	{1}	; 5 59
    607  10000 ????
    608  10000 ????						; and loop (branch always taken)
    609  10000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    610  10000 ????
    611  10000 ????			    .speech_done
    612  10000 ????
    613  10000 ????				       endm
    614  10000 ????
    615  10000 ????
    616  10000 ????				       mac	speak
    617  10000 ????
    618  10000 ????				       lda	#<{1}
    619  10000 ????				       sta	speech_addr
    620  10000 ????				       lda	#>{1}
    621  10000 ????				       sta	speech_addr+1
    622  10000 ????
    623  10000 ????				       endm
    624  10000 ????
    625  10000 ????
    626  10000 ????
    627  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    628  10000 ????
    629  10000 ????				       processor	6502
    630  10000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; 7800.h
      4  10000 ????						; Version 1.0, 2019/12/13
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at https://github.com/dasm-assembler/dasm
     10  10000 ????
     11  10000 ????
     12  10000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  10000 ????						;
     14  10000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  10000 ????						;
     16  10000 ????						;	  00 -   1F	TIA REGISTERS
     17  10000 ????						;	  20 -   3F	MARIA REGISTERS
     18  10000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  10000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  10000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  10000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  10000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  10000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  10000 ????						;	 240 -  27F	???
     25  10000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  10000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  10000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  10000 ????						;	 340 -  3FF	???
     29  10000 ????						;	 400 -  47F	unused address space
     30  10000 ????						;	 480 -  4FF	RIOT RAM
     31  10000 ????						;	 500 -  57F	unused address space
     32  10000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  10000 ????						;	 600 - 17FF	unused address space
     34  10000 ????						;	1800 - 203F	RAM
     35  10000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  10000 ????						;	2100 - 213F	RAM
     37  10000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  10000 ????						;	2200 - 27FF	RAM
     39  10000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  10000 ????						;	3000 - 3FFF	unused address space
     41  10000 ????						;	4000 - FF7F	potential cartridge address space
     42  10000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  10000 ????						;	FFFA - FFFF	6502 VECTORS
     44  10000 ????
     45  10000 ????
     46  10000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  10000 ????
     48  10000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  10000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  10000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  10000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  10000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  10000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  10000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  10000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  10000 ????
     57  10000 ????						; ** some common alternate names for INPT0/1/2/3
     58  10000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  10000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  10000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  10000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  10000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  10000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  10000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  10000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  10000 ????
     67  10000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  10000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  10000 ????
     70  10000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  10000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  10000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  10000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  10000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  10000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  10000 ????
     77  10000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  10000 ????
     79  10000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  10000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  10000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  10000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  10000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  10000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  10000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  10000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  10000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  10000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  10000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  10000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  10000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  10000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  10000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  10000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  10000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  10000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  10000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  10000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  10000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  10000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  10000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  10000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  10000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  10000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  10000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  10000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  10000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  10000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  10000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  10000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  10000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  10000 ????
    113  10000 ????
    114  10000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  10000 ????
    116  10000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  10000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  10000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  10000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  10000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  10000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  10000 ????
    123  10000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  10000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  10000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  10000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  10000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  10000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  10000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  10000 ????
    131  10000 ????						;XM
    132  10000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  10000 ????		04 70	    XCTRL1     =	$470
    134  10000 ????		04 78	    XCTRL2     =	$478
    135  10000 ????		04 7c	    XCTRL3     =	$47c
    136  10000 ????		04 71	    XCTRL4     =	$471
    137  10000 ????		04 72	    XCTRL5     =	$472
    138  10000 ????
    139  10000 ????						; Pokey register relative locations, since its base may be different
    140  10000 ????						; depending on the hardware.
    141  10000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  10000 ????		00 01	    PAUDC0     =	$1
    143  10000 ????		00 02	    PAUDF1     =	$2
    144  10000 ????		00 03	    PAUDC1     =	$3
    145  10000 ????		00 04	    PAUDF2     =	$4
    146  10000 ????		00 05	    PAUDC2     =	$5
    147  10000 ????		00 06	    PAUDF3     =	$6
    148  10000 ????		00 07	    PAUDC3     =	$7
    149  10000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  10000 ????		00 09	    PSTIMER    =	$9
    151  10000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  10000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    blank_mode =	$00
      7  10000 ????		00 1c	    blank_width_twoscompliment =	$1c
      8  10000 ????		00 04	    blank_width =	$04
      9  10000 ????		00 00	    p1_mode    =	$00
     10  10000 ????		00 1e	    p1_width_twoscompliment =	$1e
     11  10000 ????		00 02	    p1_width   =	$02
     12  10000 ????		00 00	    ex7_mode   =	$00
     13  10000 ????		00 1c	    ex7_width_twoscompliment =	$1c
     14  10000 ????		00 04	    ex7_width  =	$04
     15  10000 ????		00 00	    ex6_mode   =	$00
     16  10000 ????		00 1c	    ex6_width_twoscompliment =	$1c
     17  10000 ????		00 04	    ex6_width  =	$04
     18  10000 ????		00 00	    ex5_mode   =	$00
     19  10000 ????		00 1c	    ex5_width_twoscompliment =	$1c
     20  10000 ????		00 04	    ex5_width  =	$04
     21  10000 ????		00 00	    ex4_mode   =	$00
     22  10000 ????		00 1c	    ex4_width_twoscompliment =	$1c
     23  10000 ????		00 04	    ex4_width  =	$04
     24  10000 ????		00 00	    ex3_mode   =	$00
     25  10000 ????		00 1c	    ex3_width_twoscompliment =	$1c
     26  10000 ????		00 04	    ex3_width  =	$04
     27  10000 ????		00 00	    ex2_mode   =	$00
     28  10000 ????		00 1c	    ex2_width_twoscompliment =	$1c
     29  10000 ????		00 04	    ex2_width  =	$04
     30  10000 ????		00 00	    ex1_mode   =	$00
     31  10000 ????		00 1c	    ex1_width_twoscompliment =	$1c
     32  10000 ????		00 04	    ex1_width  =	$04
     33  10000 ????		00 00	    zonebg80x16_16_mode =	$00
     34  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
     35  10000 ????		00 14	    zonebg80x16_16_width =	$14
     36  10000 ????		00 00	    g16x16_4color8_mode =	$00
     37  10000 ????		00 1c	    g16x16_4color8_width_twoscompliment =	$1c
     38  10000 ????		00 04	    g16x16_4color8_width =	$04
     39  10000 ????		00 00	    g16x16_4color7_mode =	$00
     40  10000 ????		00 1c	    g16x16_4color7_width_twoscompliment =	$1c
     41  10000 ????		00 04	    g16x16_4color7_width =	$04
     42  10000 ????		00 00	    g16x16_4color6_mode =	$00
     43  10000 ????		00 1c	    g16x16_4color6_width_twoscompliment =	$1c
     44  10000 ????		00 04	    g16x16_4color6_width =	$04
     45  10000 ????		00 00	    g16x16_4color5_mode =	$00
     46  10000 ????		00 1c	    g16x16_4color5_width_twoscompliment =	$1c
     47  10000 ????		00 04	    g16x16_4color5_width =	$04
     48  10000 ????		00 00	    g16x16_4color4_mode =	$00
     49  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     50  10000 ????		00 04	    g16x16_4color4_width =	$04
     51  10000 ????		00 00	    g16x16_4color3_mode =	$00
     52  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     53  10000 ????		00 04	    g16x16_4color3_width =	$04
     54  10000 ????		00 00	    g16x16_4color2_mode =	$00
     55  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     56  10000 ????		00 04	    g16x16_4color2_width =	$04
     57  10000 ????		00 00	    g16x16_4color_mode =	$00
     58  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     59  10000 ????		00 04	    g16x16_4color_width =	$04
     60  10000 ????		00 01	    DOUBLEBUFFER =	1
     61  10000 ????		01 45	    wrap       =	var5
     62  10000 ????
     63  10000 ????		01 44	    ex	       =	var4
     64  10000 ????
     65  10000 ????		01 43	    an	       =	var3
     66  10000 ????
     67  10000 ????		01 42	    db	       =	var2
     68  10000 ????
     69  10000 ????		01 41	    bg	       =	var1
     70  10000 ????
     71  10000 ????		00 0f	    font_color1 =	$0f
     72  10000 ????		00 00	    font_color0 =	$00
     73  10000 ????		00 00	    blank_color1 =	0
     74  10000 ????		00 00	    blank_color0 =	$00
     75  10000 ????		00 35	    p1_color3  =	$35
     76  10000 ????		00 07	    p1_color2  =	$07
     77  10000 ????		00 0c	    p1_color1  =	$0c
     78  10000 ????		00 00	    p1_color0  =	$00
     79  10000 ????		00 07	    ex7_color1 =	$07
     80  10000 ????		00 00	    ex7_color0 =	$00
     81  10000 ????		00 00	    ex6_color3 =	0
     82  10000 ????		00 35	    ex6_color2 =	$35
     83  10000 ????		00 07	    ex6_color1 =	$07
     84  10000 ????		00 00	    ex6_color0 =	$00
     85  10000 ????		00 35	    ex5_color3 =	$35
     86  10000 ????		00 0c	    ex5_color2 =	$0c
     87  10000 ????		00 07	    ex5_color1 =	$07
     88  10000 ????		00 00	    ex5_color0 =	$00
     89  10000 ????		00 35	    ex4_color3 =	$35
     90  10000 ????		00 0c	    ex4_color2 =	$0c
     91  10000 ????		00 07	    ex4_color1 =	$07
     92  10000 ????		00 00	    ex4_color0 =	$00
     93  10000 ????		00 35	    ex3_color3 =	$35
     94  10000 ????		00 0c	    ex3_color2 =	$0c
     95  10000 ????		00 07	    ex3_color1 =	$07
     96  10000 ????		00 00	    ex3_color0 =	$00
     97  10000 ????		00 35	    ex2_color3 =	$35
     98  10000 ????		00 0c	    ex2_color2 =	$0c
     99  10000 ????		00 07	    ex2_color1 =	$07
    100  10000 ????		00 00	    ex2_color0 =	$00
    101  10000 ????		00 35	    ex1_color3 =	$35
    102  10000 ????		00 0c	    ex1_color2 =	$0c
    103  10000 ????		00 07	    ex1_color1 =	$07
    104  10000 ????		00 00	    ex1_color0 =	$00
    105  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
    106  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
    107  10000 ????		00 91	    g16x16_4color8_color3 =	$91
    108  10000 ????		00 a8	    g16x16_4color8_color2 =	$a8
    109  10000 ????		00 91	    g16x16_4color8_color1 =	$91
    110  10000 ????		00 00	    g16x16_4color8_color0 =	$00
    111  10000 ????		00 a8	    g16x16_4color7_color3 =	$a8
    112  10000 ????		00 91	    g16x16_4color7_color2 =	$91
    113  10000 ????		00 91	    g16x16_4color7_color1 =	$91
    114  10000 ????		00 00	    g16x16_4color7_color0 =	$00
    115  10000 ????		00 91	    g16x16_4color6_color3 =	$91
    116  10000 ????		00 a8	    g16x16_4color6_color2 =	$a8
    117  10000 ????		00 91	    g16x16_4color6_color1 =	$91
    118  10000 ????		00 00	    g16x16_4color6_color0 =	$00
    119  10000 ????		00 91	    g16x16_4color5_color3 =	$91
    120  10000 ????		00 a8	    g16x16_4color5_color2 =	$a8
    121  10000 ????		00 91	    g16x16_4color5_color1 =	$91
    122  10000 ????		00 00	    g16x16_4color5_color0 =	$00
    123  10000 ????		00 91	    g16x16_4color4_color3 =	$91
    124  10000 ????		00 a8	    g16x16_4color4_color2 =	$a8
    125  10000 ????		00 91	    g16x16_4color4_color1 =	$91
    126  10000 ????		00 00	    g16x16_4color4_color0 =	$00
    127  10000 ????		00 91	    g16x16_4color3_color3 =	$91
    128  10000 ????		00 a8	    g16x16_4color3_color2 =	$a8
    129  10000 ????		00 91	    g16x16_4color3_color1 =	$91
    130  10000 ????		00 00	    g16x16_4color3_color0 =	$00
    131  10000 ????		00 91	    g16x16_4color2_color3 =	$91
    132  10000 ????		00 a8	    g16x16_4color2_color2 =	$a8
    133  10000 ????		00 91	    g16x16_4color2_color1 =	$91
    134  10000 ????		00 00	    g16x16_4color2_color0 =	$00
    135  10000 ????		00 91	    g16x16_4color_color3 =	$91
    136  10000 ????		00 a8	    g16x16_4color_color2 =	$a8
    137  10000 ????		00 91	    g16x16_4color_color1 =	$91
    138  10000 ????		00 00	    g16x16_4color_color0 =	$00
    139  10000 ????		00 01	    ROM48K     =	1
    140  10000 ????		00 01	    plotvalueonscreen =	1
    141  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  10000 ????
      7  10000 ????						;************ 7800 overall RAM map **************
      8  10000 ????
      9  10000 ????						;	   40-FF	 zero page RAM
     10  10000 ????						;	  140-1FF	 RAM (stack)
     11  10000 ????						;	 1800-203F	 RAM
     12  10000 ????						;	 2100-213F	 RAM
     13  10000 ????						;	 2200-27FF	 RAM
     14  10000 ????
     15  10000 ????						;************ 7800basic RAM usage map **************
     16  10000 ????
     17  10000 ????						;	   40-FF	 numerous defines, listed below
     18  10000 ????						;	  140-1FF	 RAM (stack)
     19  10000 ????
     20  10000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  10000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  10000 ????
     23  10000 ????						;	 2000-203F	 Reserved
     24  10000 ????						;	 2100-213F	 Reserved
     25  10000 ????						;	 2200-27FF	 Free
     26  10000 ????
     27  10000 ????		1f e0	    eeprombuffer =	$1FE0
     28  10000 ????		18 00	    DLLMEM     =	$1800
     29  10000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  10000 ????
     31  10000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  10000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  10000 ????				       else
     34  10000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  10000 ????				       endif
     36  10000 ????
     37  10000 ????
     38  10000 ????		21 00	    pausestate =	$2100
     39  10000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  10000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  10000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  10000 ????		21 04	    currentbank =	$2104
     43  10000 ????
     44  10000 ????		21 05	    currentrambank =	$2105
     45  10000 ????		21 06	    charactermode =	$2106
     46  10000 ????		21 07	    sCTRL      =	$2107
     47  10000 ????		21 08	    pokeydetected =	$2108
     48  10000 ????		21 09	    paldetected =	$2109
     49  10000 ????		21 0a	    avoxdetected =	$210A
     50  10000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  10000 ????
     52  10000 ????		21 0c	    hsdevice   =	$210C
     53  10000 ????		21 0d	    hsdifficulty =	$210D
     54  10000 ????		21 0e	    hserror    =	$210E
     55  10000 ????		21 0f	    hsgameslot =	$210F
     56  10000 ????		21 10	    hsnewscoreline =	$2110
     57  10000 ????		21 11	    hsnewscorerank =	$2111
     58  10000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  10000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  10000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  10000 ????
     62  10000 ????		21 31	    ssCTRL     =	$2131
     63  10000 ????		21 32	    ssCHARBASE =	$2132
     64  10000 ????		21 33	    hsdisplaymode =	$2133
     65  10000 ????		21 34	    gamedifficulty =	$2134
     66  10000 ????		21 35	    hsinitialpos =	$2135
     67  10000 ????		21 36	    hsinitialhold =	$2136
     68  10000 ????		21 37	    hscursorx  =	$2137
     69  10000 ????		21 38	    hsjoydebounce =	$2138
     70  10000 ????		21 39	    hsswcha    =	$2139
     71  10000 ????		21 3a	    hsinpt1    =	$213A
     72  10000 ????		21 3b	    hscolorchaseindex =	$213B
     73  10000 ????		21 3c	    visibleDLLstart =	$213C
     74  10000 ????		21 3d	    overscanDLLstart =	$213D
     75  10000 ????		21 3e	    frameslost =	$213E
     76  10000 ????		21 3f	    hsreturn   =	$213F
     77  10000 ????
     78  10000 ????
     79  10000 ????		00 40	    rand       =	$40
     80  10000 ????		00 41	    rand16     =	$41
     81  10000 ????		00 42	    temp1      =	$42
     82  10000 ????		00 43	    temp2      =	$43
     83  10000 ????		00 44	    temp3      =	$44
     84  10000 ????		00 45	    temp4      =	$45
     85  10000 ????		00 46	    temp5      =	$46
     86  10000 ????		00 47	    temp6      =	$47
     87  10000 ????		00 48	    temp7      =	$48
     88  10000 ????		00 49	    temp8      =	$49
     89  10000 ????		00 4a	    temp9      =	$4a
     90  10000 ????
     91  10000 ????		00 4b	    pokeybase  =	$4b
     92  10000 ????		00 4b	    pokeybaselo =	$4b
     93  10000 ????		00 4c	    pokeybasehi =	$4c
     94  10000 ????
     95  10000 ????		00 4d	    visibleover =	$4d
     96  10000 ????
     97  10000 ????		00 4e	    sfx1pointlo =	$4e
     98  10000 ????		00 4f	    sfx2pointlo =	$4f
     99  10000 ????		00 50	    sfx1pointhi =	$50
    100  10000 ????		00 51	    sfx2pointhi =	$51
    101  10000 ????
    102  10000 ????		00 52	    sfx1priority =	$52
    103  10000 ????		00 53	    sfx2priority =	$53
    104  10000 ????		00 54	    sfx1poffset =	$54
    105  10000 ????		00 55	    sfx2poffset =	$55
    106  10000 ????
    107  10000 ????		00 56	    sfx1frames =	$56
    108  10000 ????		00 57	    sfx2frames =	$57
    109  10000 ????		00 58	    sfx1tick   =	$58
    110  10000 ????		00 59	    sfx2tick   =	$59
    111  10000 ????
    112  10000 ????		00 5a	    tempmath   =	$5a
    113  10000 ????
    114  10000 ????		00 5b	    pokey1pointlo =	$5b
    115  10000 ????		00 5c	    pokey1pointhi =	$5c
    116  10000 ????		00 5d	    pokey2pointlo =	$5d
    117  10000 ????		00 5e	    pokey2pointhi =	$5e
    118  10000 ????		00 5f	    pokey3pointlo =	$5f
    119  10000 ????		00 60	    pokey3pointhi =	$60
    120  10000 ????		00 61	    pokey4pointlo =	$61
    121  10000 ????		00 62	    pokey4pointhi =	$62
    122  10000 ????
    123  10000 ????		00 63	    dlpnt      =	$63	; to $64
    124  10000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    125  10000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    126  10000 ????
    127  10000 ????		00 9f	    speech_addr =	$9f
    128  10000 ????		00 a0	    speech_addr_hi =	$a0
    129  10000 ????
    130  10000 ????		00 a1	    HSGameTableLo =	$a1
    131  10000 ????		00 a2	    HSGameTableHi =	$a2
    132  10000 ????		00 a3	    HSVoxHi    =	$a3
    133  10000 ????		00 a4	    HSVoxLo    =	$a4
    134  10000 ????
    135  10000 ????						;channel pointers
    136  10000 ????
    137  10000 ????		00 a5	    songchannel1layer1lo =	$a5
    138  10000 ????		00 a6	    songchannel2layer1lo =	$a6
    139  10000 ????		00 a7	    songchannel3layer1lo =	$a7
    140  10000 ????		00 a8	    songchannel4layer1lo =	$a8
    141  10000 ????
    142  10000 ????		00 a9	    songchannel1layer2lo =	$a9
    143  10000 ????		00 aa	    songchannel2layer2lo =	$aA
    144  10000 ????		00 ab	    songchannel3layer2lo =	$aB
    145  10000 ????		00 ac	    songchannel4layer2lo =	$aC
    146  10000 ????
    147  10000 ????		00 ad	    songchannel1layer3lo =	$aD
    148  10000 ????		00 ae	    songchannel2layer3lo =	$aE
    149  10000 ????		00 af	    songchannel3layer3lo =	$aF
    150  10000 ????		00 b0	    songchannel4layer3lo =	$b0
    151  10000 ????
    152  10000 ????		00 b1	    songchannel1layer1hi =	$b1
    153  10000 ????		00 b2	    songchannel2layer1hi =	$b2
    154  10000 ????		00 b3	    songchannel3layer1hi =	$b3
    155  10000 ????		00 b4	    songchannel4layer1hi =	$b4
    156  10000 ????
    157  10000 ????		00 b5	    songchannel1layer2hi =	$b5
    158  10000 ????		00 b6	    songchannel2layer2hi =	$b6
    159  10000 ????		00 b7	    songchannel3layer2hi =	$b7
    160  10000 ????		00 b8	    songchannel4layer2hi =	$b8
    161  10000 ????
    162  10000 ????		00 b9	    songchannel1layer3hi =	$b9
    163  10000 ????		00 ba	    songchannel2layer3hi =	$bA
    164  10000 ????		00 bb	    songchannel3layer3hi =	$bB
    165  10000 ????		00 bc	    songchannel4layer3hi =	$bC
    166  10000 ????
    167  10000 ????		00 bd	    songdatalo =	$bd
    168  10000 ????		00 be	    songdatahi =	$be
    169  10000 ????
    170  10000 ????		00 bf	    inactivechannelcount =	$bf
    171  10000 ????
    172  10000 ????		00 c0	    songchannel1transpose =	$c0
    173  10000 ????		00 c1	    songchannel2transpose =	$c1
    174  10000 ????		00 c2	    songchannel3transpose =	$c2
    175  10000 ????		00 c3	    songchannel4transpose =	$c3
    176  10000 ????
    177  10000 ????		00 c4	    songstackindex =	$c4
    178  10000 ????
    179  10000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  10000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  10000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  10000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  10000 ????
    184  10000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  10000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  10000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  10000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  10000 ????
    189  10000 ????		00 cd	    sfx1notedata =	$cd
    190  10000 ????		00 ce	    sfx2notedata =	$ce
    191  10000 ????
    192  10000 ????		00 cf	    songloops  =	$cf
    193  10000 ????
    194  10000 ????		00 d0	    songpointerlo =	$D0
    195  10000 ????		00 d1	    songpointerhi =	$D1
    196  10000 ????
    197  10000 ????		00 d2	    voxlock    =	$D2
    198  10000 ????		00 d3	    voxqueuesize =	$D3
    199  10000 ????
    200  10000 ????		00 d4	    vblankroutines =	$D4
    201  10000 ????
    202  10000 ????		00 d5	    doublebufferstate =	$D5
    203  10000 ????		00 d6	    doublebufferdloffset =	$D6
    204  10000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  10000 ????
    206  10000 ????		00 d8	    inttemp1   =	$D8
    207  10000 ????		00 d9	    inttemp2   =	$D9
    208  10000 ????		00 da	    inttemp3   =	$DA
    209  10000 ????		00 db	    inttemp4   =	$DB
    210  10000 ????		00 dc	    inttemp5   =	$DC
    211  10000 ????		00 dd	    inttemp6   =	$DD
    212  10000 ????
    213  10000 ????		00 de	    sfxschedulelock =	$DE
    214  10000 ????		00 df	    sfxschedulemissed =	$DF
    215  10000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  10000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  10000 ????		00 e2	    sfxpitchoffset =	$E2
    218  10000 ????		00 e3	    sfxnoteindex =	$E3
    219  10000 ????
    220  10000 ????		00 e4	    CTLSWAs    =	$E4
    221  10000 ????		00 e5	    CTLSWBs    =	$E5
    222  10000 ????
    223  10000 ????		00 e6	    A	       =	$e6
    224  10000 ????		00 e6	    a	       =	$e6
    225  10000 ????		00 e7	    B	       =	$e7
    226  10000 ????		00 e7	    b	       =	$e7
    227  10000 ????		00 e8	    C	       =	$e8
    228  10000 ????		00 e8	    c	       =	$e8
    229  10000 ????		00 e9	    D	       =	$e9
    230  10000 ????		00 e9	    d	       =	$e9
    231  10000 ????		00 ea	    E	       =	$ea
    232  10000 ????		00 ea	    e	       =	$ea
    233  10000 ????		00 eb	    F	       =	$eb
    234  10000 ????		00 eb	    f	       =	$eb
    235  10000 ????		00 ec	    G	       =	$ec
    236  10000 ????		00 ec	    g	       =	$ec
    237  10000 ????		00 ed	    H	       =	$ed
    238  10000 ????		00 ed	    h	       =	$ed
    239  10000 ????		00 ee	    I	       =	$ee
    240  10000 ????		00 ee	    i	       =	$ee
    241  10000 ????		00 ef	    J	       =	$ef
    242  10000 ????		00 ef	    j	       =	$ef
    243  10000 ????		00 f0	    K	       =	$f0
    244  10000 ????		00 f0	    k	       =	$f0
    245  10000 ????		00 f1	    L	       =	$f1
    246  10000 ????		00 f1	    l	       =	$f1
    247  10000 ????		00 f2	    M	       =	$f2
    248  10000 ????		00 f2	    m	       =	$f2
    249  10000 ????		00 f3	    N	       =	$f3
    250  10000 ????		00 f3	    n	       =	$f3
    251  10000 ????		00 f4	    O	       =	$f4
    252  10000 ????		00 f4	    o	       =	$f4
    253  10000 ????		00 f5	    P	       =	$f5
    254  10000 ????		00 f5	    p	       =	$f5
    255  10000 ????		00 f6	    Q	       =	$f6
    256  10000 ????		00 f6	    q	       =	$f6
    257  10000 ????		00 f7	    R	       =	$f7
    258  10000 ????		00 f7	    r	       =	$f7
    259  10000 ????		00 f8	    S	       =	$f8
    260  10000 ????		00 f8	    s	       =	$f8
    261  10000 ????		00 f9	    T	       =	$f9
    262  10000 ????		00 f9	    t	       =	$f9
    263  10000 ????		00 fa	    U	       =	$fa
    264  10000 ????		00 fa	    u	       =	$fa
    265  10000 ????		00 fb	    V	       =	$fb
    266  10000 ????		00 fb	    v	       =	$fb
    267  10000 ????		00 fc	    W	       =	$fc
    268  10000 ????		00 fc	    w	       =	$fc
    269  10000 ????		00 fd	    X	       =	$fd
    270  10000 ????		00 fd	    x	       =	$fd
    271  10000 ????		00 fe	    Y	       =	$fe
    272  10000 ????		00 fe	    y	       =	$fe
    273  10000 ????		00 ff	    Z	       =	$ff
    274  10000 ????		00 ff	    z	       =	$ff
    275  10000 ????
    276  10000 ????						; var0-var99 variables use the top of the stack
    277  10000 ????		01 40	    var0       =	$140
    278  10000 ????		01 41	    var1       =	$141
    279  10000 ????		01 42	    var2       =	$142
    280  10000 ????		01 43	    var3       =	$143
    281  10000 ????		01 44	    var4       =	$144
    282  10000 ????		01 45	    var5       =	$145
    283  10000 ????		01 46	    var6       =	$146
    284  10000 ????		01 47	    var7       =	$147
    285  10000 ????		01 48	    var8       =	$148
    286  10000 ????		01 49	    var9       =	$149
    287  10000 ????		01 4a	    var10      =	$14a
    288  10000 ????		01 4b	    var11      =	$14b
    289  10000 ????		01 4c	    var12      =	$14c
    290  10000 ????		01 4d	    var13      =	$14d
    291  10000 ????		01 4e	    var14      =	$14e
    292  10000 ????		01 4f	    var15      =	$14f
    293  10000 ????		01 50	    var16      =	$150
    294  10000 ????		01 51	    var17      =	$151
    295  10000 ????		01 52	    var18      =	$152
    296  10000 ????		01 53	    var19      =	$153
    297  10000 ????		01 54	    var20      =	$154
    298  10000 ????		01 55	    var21      =	$155
    299  10000 ????		01 56	    var22      =	$156
    300  10000 ????		01 57	    var23      =	$157
    301  10000 ????		01 58	    var24      =	$158
    302  10000 ????		01 59	    var25      =	$159
    303  10000 ????		01 5a	    var26      =	$15a
    304  10000 ????		01 5b	    var27      =	$15b
    305  10000 ????		01 5c	    var28      =	$15c
    306  10000 ????		01 5d	    var29      =	$15d
    307  10000 ????		01 5e	    var30      =	$15e
    308  10000 ????		01 5f	    var31      =	$15f
    309  10000 ????		01 60	    var32      =	$160
    310  10000 ????		01 61	    var33      =	$161
    311  10000 ????		01 62	    var34      =	$162
    312  10000 ????		01 63	    var35      =	$163
    313  10000 ????		01 64	    var36      =	$164
    314  10000 ????		01 65	    var37      =	$165
    315  10000 ????		01 66	    var38      =	$166
    316  10000 ????		01 67	    var39      =	$167
    317  10000 ????		01 68	    var40      =	$168
    318  10000 ????		01 69	    var41      =	$169
    319  10000 ????		01 6a	    var42      =	$16a
    320  10000 ????		01 6b	    var43      =	$16b
    321  10000 ????		01 6c	    var44      =	$16c
    322  10000 ????		01 6d	    var45      =	$16d
    323  10000 ????		01 6e	    var46      =	$16e
    324  10000 ????		01 6f	    var47      =	$16f
    325  10000 ????		01 70	    var48      =	$170
    326  10000 ????		01 71	    var49      =	$171
    327  10000 ????		01 72	    var50      =	$172
    328  10000 ????		01 73	    var51      =	$173
    329  10000 ????		01 74	    var52      =	$174
    330  10000 ????		01 75	    var53      =	$175
    331  10000 ????		01 76	    var54      =	$176
    332  10000 ????		01 77	    var55      =	$177
    333  10000 ????		01 78	    var56      =	$178
    334  10000 ????		01 79	    var57      =	$179
    335  10000 ????		01 7a	    var58      =	$17a
    336  10000 ????		01 7b	    var59      =	$17b
    337  10000 ????		01 7c	    var60      =	$17c
    338  10000 ????		01 7d	    var61      =	$17d
    339  10000 ????		01 7e	    var62      =	$17e
    340  10000 ????		01 7f	    var63      =	$17f
    341  10000 ????		01 80	    var64      =	$180
    342  10000 ????		01 81	    var65      =	$181
    343  10000 ????		01 82	    var66      =	$182
    344  10000 ????		01 83	    var67      =	$183
    345  10000 ????		01 84	    var68      =	$184
    346  10000 ????		01 85	    var69      =	$185
    347  10000 ????		01 86	    var70      =	$186
    348  10000 ????		01 87	    var71      =	$187
    349  10000 ????		01 88	    var72      =	$188
    350  10000 ????		01 89	    var73      =	$189
    351  10000 ????		01 8a	    var74      =	$18a
    352  10000 ????		01 8b	    var75      =	$18b
    353  10000 ????		01 8c	    var76      =	$18c
    354  10000 ????		01 8d	    var77      =	$18d
    355  10000 ????		01 8e	    var78      =	$18e
    356  10000 ????		01 8f	    var79      =	$18f
    357  10000 ????		01 90	    var80      =	$190
    358  10000 ????		01 91	    var81      =	$191
    359  10000 ????		01 92	    var82      =	$192
    360  10000 ????		01 93	    var83      =	$193
    361  10000 ????		01 94	    var84      =	$194
    362  10000 ????		01 95	    var85      =	$195
    363  10000 ????		01 96	    var86      =	$196
    364  10000 ????		01 97	    var87      =	$197
    365  10000 ????		01 98	    var88      =	$198
    366  10000 ????		01 99	    var89      =	$199
    367  10000 ????		01 9a	    var90      =	$19a
    368  10000 ????		01 9b	    var91      =	$19b
    369  10000 ????		01 9c	    var92      =	$19c
    370  10000 ????		01 9d	    var93      =	$19d
    371  10000 ????		01 9e	    var94      =	$19e
    372  10000 ????		01 9f	    var95      =	$19f
    373  10000 ????		01 a0	    var96      =	$1a0
    374  10000 ????		01 a1	    var97      =	$1a1
    375  10000 ????		01 a2	    var98      =	$1a2
    376  10000 ????		01 a3	    var99      =	$1a3
    377  10000 ????
    378 U01c5 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3					      ifconst	DOUBLEBUFFER
    395 U01b3		       00	   doublebufferminimumframetarget DS	1	; $1B3
    396 U01b4		       00	   doublebufferminimumframeindex DS	1	; $1B4
    397 U01b5					      endif
    398 U01b5
    399 U01b5		       00	   pausedisable DS	1	; $1B5
    400 U01b6		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b7
    402 U01b7				  -	      ifconst	AVOXVOICE
    403 U01b7				  -avoxenable DS	1	; $1B7
    404 U01b7				  -tempavox   DS	1	; $1B8
    405 U01b7					      endif
    406 U01b7
    407 U01b7				  -	      ifconst	MUSICTRACKER
    408 U01b7				  -songtempo  DS	1	; $1B9
    409 U01b7				  -songtick   DS	1	; $1BA
    410 U01b7				  -
    411 U01b7				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b7				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b7				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b7				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b7				  -
    416 U01b7				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b7				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b7				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b7				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b7				  -
    421 U01b7				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b7				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b7				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b7				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b7				  -
    426 U01b7				  -songchannel1busywait DS	1	; $1C7
    427 U01b7				  -songchannel2busywait DS	1	; $1C8
    428 U01b7				  -songchannel3busywait DS	1	; $1C9
    429 U01b7				  -songchannel4busywait DS	1	; $1CA
    430 U01b7				  -
    431 U01b7				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b7				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b7				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b7				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b7					      endif
    436 U01b7
    437 U01b7		       00	   palframes  DS	1	; $1CF
    438 U01b8		       00	   palfastframe DS	1	; $1D0
    439 U01b9
    440 U01b9				  -	      ifconst	MOUSESUPPORT
    441 U01b9				  -port0resolution DS	1	; $1D1
    442 U01b9				  -port1resolution DS	1	; $1D2
    443 U01b9					      else
    444 U01b9				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b9				  -port0resolution DS	1	; $1D1
    446 U01b9				  -port1resolution DS	1	; $1D2
    447 U01b9					      endif
    448 U01b9					      endif
    449 U01b9
    450 U01b9		       00	   port0control DS	1	; $1D3
    451 U01ba		       00	   port1control DS	1	; $1D4
    452 U01bb
    453 U01bb							; port#control values...
    454 U01bb							;	1 = proline
    455 U01bb							;	2 = lightgun
    456 U01bb							;	3 = paddle
    457 U01bb							;	4 = trakball
    458 U01bb							;	5 = vcs joystick
    459 U01bb							;	6 = driving
    460 U01bb							;	7 = keypad
    461 U01bb							;	8 = st mouse/cx80
    462 U01bb							;	9 = amiga mouse
    463 U01bb							;     10 = atarivox
    464 U01bb
    465 U01bb							; controller 0 data...
    466 U01bb		       00	   paddleposition0 DS	1	; $1D5
    467 U01bb		       01 bb	   keypadmatrix0a =	paddleposition0
    468 U01bb		       01 bb	   drivingposition0 =	paddleposition0
    469 U01bb		       01 bb	   trakballx0 =	paddleposition0
    470 U01bb		       01 bb	   mousex0    =	paddleposition0
    471 U01bb		       01 bb	   lighttgunx0 =	paddleposition0
    472 U01bb		       01 bb	   snes2atari0lo =	paddleposition0
    473 U01bc
    474 U01bc							; controller 1 data...
    475 U01bc		       00	   paddleposition2 DS	1	; $1D6
    476 U01bc		       01 bc	   keypadmatrix1a =	paddleposition2
    477 U01bc		       01 bc	   drivingposition1 =	paddleposition2
    478 U01bc		       01 bc	   trakballx1 =	paddleposition2
    479 U01bc		       01 bc	   mousex1    =	paddleposition2
    480 U01bc		       01 bc	   lightgunx1 =	paddleposition2
    481 U01bc		       01 bc	   snes2atari1lo =	paddleposition2
    482 U01bd
    483 U01bd							; controller 0 altdata...
    484 U01bd		       00	   paddleposition1 DS	1	; $1D7
    485 U01bd		       01 bd	   keypadmatrix0b =	paddleposition1
    486 U01bd		       01 bd	   trakbally0 =	paddleposition1
    487 U01bd		       01 bd	   mousey0    =	paddleposition1
    488 U01bd		       01 bd	   lightguny0 =	paddleposition1
    489 U01bd		       01 bd	   snes2atari0hi =	paddleposition1
    490 U01be
    491 U01be							; controller 1 altdata...
    492 U01be		       00	   paddleposition3 DS	1	; $1D8
    493 U01be		       01 be	   keypadmatrix1b =	paddleposition3
    494 U01be		       01 be	   trakbally1 =	paddleposition3
    495 U01be		       01 be	   mousey1    =	paddleposition3
    496 U01be		       01 be	   lightguny1 =	paddleposition3
    497 U01be		       01 be	   snes2atari1hi =	paddleposition3
    498 U01bf
    499 U01bf							; controller state save. for trakball state+dir codes, rotary position codes
    500 U01bf		       00	   controller0statesave DS	1	; $1D9
    501 U01bf		       01 bf	   paddleprevious0 =	controller0statesave
    502 U01bf		       01 bf	   mousecodex0 =	controller0statesave
    503 U01bf		       01 bf	   trakballcodex0 =	controller0statesave
    504 U01bf		       01 bf	   keypadmatrix0c =	controller0statesave
    505 U01bf		       01 bf	   snesdetected0 =	controller0statesave
    506 U01c0
    507 U01c0		       00	   controller1statesave DS	1	; $1DA
    508 U01c0		       01 c0	   paddleprevious2 =	controller1statesave
    509 U01c0		       01 c0	   mousecodex1 =	controller1statesave
    510 U01c0		       01 c0	   trakballcodex1 =	controller1statesave
    511 U01c0		       01 c0	   keypadmatrix1c =	controller1statesave
    512 U01c0		       01 c0	   snesdetected1 =	controller1statesave
    513 U01c1
    514 U01c1		       00	   paddleprevious1 DS	1	; $1DB
    515 U01c1		       01 c1	   keypadmatrix0d =	paddleprevious1
    516 U01c1		       01 c1	   mousecodey0 =	paddleprevious1
    517 U01c1		       01 c1	   trakballcodey0 =	paddleprevious1
    518 U01c2
    519 U01c2		       00	   paddleprevious3 DS	1	; $1DC
    520 U01c2		       01 c2	   keypadmatrix1d =	paddleprevious3
    521 U01c2		       01 c2	   mousecodey1 =	paddleprevious3
    522 U01c2		       01 c2	   trakballcodey1 =	paddleprevious3
    523 U01c3
    524 U01c3				  -	      ifconst	pokeysupport
    525 U01c3				  -pokey1frames DS	1	; $1DD
    526 U01c3				  -pokey1tick DS	1	; $1DE
    527 U01c3				  -pokey2frames DS	1	; $1DF
    528 U01c3				  -pokey2tick DS	1	; $1E0
    529 U01c3				  -pokey3frames DS	1	; $1E1
    530 U01c3				  -pokey3tick DS	1	; $1E2
    531 U01c3				  -pokey4frames DS	1	; $1E3
    532 U01c3				  -pokey4tick DS	1	; $1E4
    533 U01c3				  -pokey1priority DS	1	; $1E5
    534 U01c3				  -pokey1offset DS	1	; $1E6
    535 U01c3				  -pokey2priority DS	1	; $1E7
    536 U01c3				  -pokey2offset DS	1	; $1E8
    537 U01c3				  -pokey3priority DS	1	; $1E9
    538 U01c3				  -pokey3offset DS	1	; $1EA
    539 U01c3				  -pokey4priority DS	1	; $1EB
    540 U01c3				  -pokey4offset DS	1	; $1EC
    541 U01c3					      endif
    542 U01c3
    543 U01c3				  -	      ifconst	pokeykeysupport
    544 U01c3				  -pokeylastkeycode DS	1
    545 U01c3				  -pokeykeycode DS	1
    546 U01c3				  -pokeykeydebounce DS	1
    547 U01c3					      endif
    548 U01c3
    549 U01c3				  -	      ifconst	RMT
    550 U01c3				  -rasterpause DS	1
    551 U01c3					      endif		; RMT
    552 U01c3				  -	      ifconst	RMTVOLUME
    553 U01c3				  -rmtvolume  DS	1
    554 U01c3					      endif		; RMTVOLUME
    555 U01c3				  -	      ifconst	TIAVOLUME
    556 U01c3				  -tiavolume  DS	1
    557 U01c3					      endif		; TIAVOLUME
    558 U01c3
    559 U01c3				  -	      ifconst	FOURBITFADE
    560 U01c3				  -fourbittemp1 DS	1
    561 U01c3				  -fourbitfadevalue DS	1
    562 U01c3				  -fourbittemp1int DS	1
    563 U01c3				  -fourbitfadevalueint DS	1
    564 U01c3					      endif		; FOURBITFADE
    565 U01c3
    566 U01c3				  -	      ifconst	SNES2ATARISUPPORT
    567 U01c3				  -snesport   DS	1
    568 U01c3					      endif
    569 U01c3
    570 U01c3				  -	      ifconst	KEYPADSUPPORT
    571 U01c3				  -keypadcounter DS	1
    572 U01c3					      endif
    573 U01c3
    574 U01c3							; see if we need an interrupthold byte...
    575 U01c3				   INTERRUPTNEEDED SET	0
    576 U01c3					      ifconst	.topscreenroutine
    577 U01c3				   INTERRUPTNEEDED SET	1
    578 U01c3					      endif
    579 U01c3				  -	      ifconst	.bottomscreenroutine
    580 U01c3				  -INTERRUPTNEEDED SET	1
    581 U01c3					      endif
    582 U01c3				  -	      ifconst	.userinterrupt
    583 U01c3				  -INTERRUPTNEEDED SET	1
    584 U01c3					      endif
    585 U01c3					      if	INTERRUPTNEEDED = 1
    586 U01c3		       00	   interrupthold DS	1	; $1ED
    587 U01c4					      endif
    588 U01c4
    589 U01c4					      ifnconst	CANARYOFF
    590 U01c4		       00	   canary     DS	1	; $1EF
    591 U01c5					      endif
    592 U01c5
    593 U01c5
    594 U01c5					      ifnconst	bankswitchmode
   stack allowance: 29 nested subroutines.
    595 U01c5					      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    596 U01c5				  -	      else
    597 U01c5				  -	      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    598 U01c5					      endif
    599 U01c5					      ifnconst	CANARYOFF
   the canary is situated at: $1c4
    600 U01c5					      echo	"  the canary is situated at:",[canary]
    601 U01c5				  -	      else
    602 U01c5				  -	      echo	"  the canary is disabled."
    603 U01c5					      endif
    604 U01c5
    605 U01c5							; $1EE - $1FF reserved for stack
    606 U01c5
    607  10000 ????				       SEG	"GAME"
    608  10000 ????
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    blank_mode =	$00
      7  10000 ????		00 1c	    blank_width_twoscompliment =	$1c
      8  10000 ????		00 04	    blank_width =	$04
      9  10000 ????		00 00	    p1_mode    =	$00
     10  10000 ????		00 1e	    p1_width_twoscompliment =	$1e
     11  10000 ????		00 02	    p1_width   =	$02
     12  10000 ????		00 00	    ex7_mode   =	$00
     13  10000 ????		00 1c	    ex7_width_twoscompliment =	$1c
     14  10000 ????		00 04	    ex7_width  =	$04
     15  10000 ????		00 00	    ex6_mode   =	$00
     16  10000 ????		00 1c	    ex6_width_twoscompliment =	$1c
     17  10000 ????		00 04	    ex6_width  =	$04
     18  10000 ????		00 00	    ex5_mode   =	$00
     19  10000 ????		00 1c	    ex5_width_twoscompliment =	$1c
     20  10000 ????		00 04	    ex5_width  =	$04
     21  10000 ????		00 00	    ex4_mode   =	$00
     22  10000 ????		00 1c	    ex4_width_twoscompliment =	$1c
     23  10000 ????		00 04	    ex4_width  =	$04
     24  10000 ????		00 00	    ex3_mode   =	$00
     25  10000 ????		00 1c	    ex3_width_twoscompliment =	$1c
     26  10000 ????		00 04	    ex3_width  =	$04
     27  10000 ????		00 00	    ex2_mode   =	$00
     28  10000 ????		00 1c	    ex2_width_twoscompliment =	$1c
     29  10000 ????		00 04	    ex2_width  =	$04
     30  10000 ????		00 00	    ex1_mode   =	$00
     31  10000 ????		00 1c	    ex1_width_twoscompliment =	$1c
     32  10000 ????		00 04	    ex1_width  =	$04
     33  10000 ????		00 00	    zonebg80x16_16_mode =	$00
     34  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
     35  10000 ????		00 14	    zonebg80x16_16_width =	$14
     36  10000 ????		00 00	    g16x16_4color8_mode =	$00
     37  10000 ????		00 1c	    g16x16_4color8_width_twoscompliment =	$1c
     38  10000 ????		00 04	    g16x16_4color8_width =	$04
     39  10000 ????		00 00	    g16x16_4color7_mode =	$00
     40  10000 ????		00 1c	    g16x16_4color7_width_twoscompliment =	$1c
     41  10000 ????		00 04	    g16x16_4color7_width =	$04
     42  10000 ????		00 00	    g16x16_4color6_mode =	$00
     43  10000 ????		00 1c	    g16x16_4color6_width_twoscompliment =	$1c
     44  10000 ????		00 04	    g16x16_4color6_width =	$04
     45  10000 ????		00 00	    g16x16_4color5_mode =	$00
     46  10000 ????		00 1c	    g16x16_4color5_width_twoscompliment =	$1c
     47  10000 ????		00 04	    g16x16_4color5_width =	$04
     48  10000 ????		00 00	    g16x16_4color4_mode =	$00
     49  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     50  10000 ????		00 04	    g16x16_4color4_width =	$04
     51  10000 ????		00 00	    g16x16_4color3_mode =	$00
     52  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     53  10000 ????		00 04	    g16x16_4color3_width =	$04
     54  10000 ????		00 00	    g16x16_4color2_mode =	$00
     55  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     56  10000 ????		00 04	    g16x16_4color2_width =	$04
     57  10000 ????		00 00	    g16x16_4color_mode =	$00
     58  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     59  10000 ????		00 04	    g16x16_4color_width =	$04
     60  10000 ????		00 01	    DOUBLEBUFFER =	1
     61  10000 ????		01 45	    wrap       =	var5
     62  10000 ????
     63  10000 ????		01 44	    ex	       =	var4
     64  10000 ????
     65  10000 ????		01 43	    an	       =	var3
     66  10000 ????
     67  10000 ????		01 42	    db	       =	var2
     68  10000 ????
     69  10000 ????		01 41	    bg	       =	var1
     70  10000 ????
     71  10000 ????		00 0f	    font_color1 =	$0f
     72  10000 ????		00 00	    font_color0 =	$00
     73  10000 ????		00 00	    blank_color1 =	0
     74  10000 ????		00 00	    blank_color0 =	$00
     75  10000 ????		00 35	    p1_color3  =	$35
     76  10000 ????		00 07	    p1_color2  =	$07
     77  10000 ????		00 0c	    p1_color1  =	$0c
     78  10000 ????		00 00	    p1_color0  =	$00
     79  10000 ????		00 07	    ex7_color1 =	$07
     80  10000 ????		00 00	    ex7_color0 =	$00
     81  10000 ????		00 00	    ex6_color3 =	0
     82  10000 ????		00 35	    ex6_color2 =	$35
     83  10000 ????		00 07	    ex6_color1 =	$07
     84  10000 ????		00 00	    ex6_color0 =	$00
     85  10000 ????		00 35	    ex5_color3 =	$35
     86  10000 ????		00 0c	    ex5_color2 =	$0c
     87  10000 ????		00 07	    ex5_color1 =	$07
     88  10000 ????		00 00	    ex5_color0 =	$00
     89  10000 ????		00 35	    ex4_color3 =	$35
     90  10000 ????		00 0c	    ex4_color2 =	$0c
     91  10000 ????		00 07	    ex4_color1 =	$07
     92  10000 ????		00 00	    ex4_color0 =	$00
     93  10000 ????		00 35	    ex3_color3 =	$35
     94  10000 ????		00 0c	    ex3_color2 =	$0c
     95  10000 ????		00 07	    ex3_color1 =	$07
     96  10000 ????		00 00	    ex3_color0 =	$00
     97  10000 ????		00 35	    ex2_color3 =	$35
     98  10000 ????		00 0c	    ex2_color2 =	$0c
     99  10000 ????		00 07	    ex2_color1 =	$07
    100  10000 ????		00 00	    ex2_color0 =	$00
    101  10000 ????		00 35	    ex1_color3 =	$35
    102  10000 ????		00 0c	    ex1_color2 =	$0c
    103  10000 ????		00 07	    ex1_color1 =	$07
    104  10000 ????		00 00	    ex1_color0 =	$00
    105  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
    106  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
    107  10000 ????		00 91	    g16x16_4color8_color3 =	$91
    108  10000 ????		00 a8	    g16x16_4color8_color2 =	$a8
    109  10000 ????		00 91	    g16x16_4color8_color1 =	$91
    110  10000 ????		00 00	    g16x16_4color8_color0 =	$00
    111  10000 ????		00 a8	    g16x16_4color7_color3 =	$a8
    112  10000 ????		00 91	    g16x16_4color7_color2 =	$91
    113  10000 ????		00 91	    g16x16_4color7_color1 =	$91
    114  10000 ????		00 00	    g16x16_4color7_color0 =	$00
    115  10000 ????		00 91	    g16x16_4color6_color3 =	$91
    116  10000 ????		00 a8	    g16x16_4color6_color2 =	$a8
    117  10000 ????		00 91	    g16x16_4color6_color1 =	$91
    118  10000 ????		00 00	    g16x16_4color6_color0 =	$00
    119  10000 ????		00 91	    g16x16_4color5_color3 =	$91
    120  10000 ????		00 a8	    g16x16_4color5_color2 =	$a8
    121  10000 ????		00 91	    g16x16_4color5_color1 =	$91
    122  10000 ????		00 00	    g16x16_4color5_color0 =	$00
    123  10000 ????		00 91	    g16x16_4color4_color3 =	$91
    124  10000 ????		00 a8	    g16x16_4color4_color2 =	$a8
    125  10000 ????		00 91	    g16x16_4color4_color1 =	$91
    126  10000 ????		00 00	    g16x16_4color4_color0 =	$00
    127  10000 ????		00 91	    g16x16_4color3_color3 =	$91
    128  10000 ????		00 a8	    g16x16_4color3_color2 =	$a8
    129  10000 ????		00 91	    g16x16_4color3_color1 =	$91
    130  10000 ????		00 00	    g16x16_4color3_color0 =	$00
    131  10000 ????		00 91	    g16x16_4color2_color3 =	$91
    132  10000 ????		00 a8	    g16x16_4color2_color2 =	$a8
    133  10000 ????		00 91	    g16x16_4color2_color1 =	$91
    134  10000 ????		00 00	    g16x16_4color2_color0 =	$00
    135  10000 ????		00 91	    g16x16_4color_color3 =	$91
    136  10000 ????		00 a8	    g16x16_4color_color2 =	$a8
    137  10000 ????		00 91	    g16x16_4color_color1 =	$91
    138  10000 ????		00 00	    g16x16_4color_color0 =	$00
    139  10000 ????		00 01	    ROM48K     =	1
    140  10000 ????		00 01	    plotvalueonscreen =	1
    141  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
    633  10000 ????
    634  10000 ????						; BEADHEADER... disabled for now
    635  10000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    636  10000 ????						; For more BEAD executable info, check out the spec...
    637  10000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    638  10000 ????
    639  10000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    640  10000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    641  10000 ????
    642  10000 ????
    643  10000 ????		00 40	    BDHSC      =	%01000000
    644  10000 ????		00 20	    BDYM       =	%00100000
    645  10000 ????		00 10	    BDPOKEY    =	%00010000
    646  10000 ????		00 08	    BDROF      =	%00001000
    647  10000 ????		00 00	    BD16K      =	%00000000
    648  10000 ????		00 01	    BD32K      =	%00000001
    649  10000 ????		00 02	    BD48K      =	%00000010
    650  10000 ????		00 05	    BD1800     =	%00000101
    651  10000 ????		00 06	    BD4000     =	%00000110
    652  10000 ????
    653  10000 ????			   -	       ifconst	BEADHEADER
    654  10000 ????			   -BEADHARDWARE SET	0
    655  10000 ????			   -	       ifconst	ROM16K
    656  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    657  10000 ????			   -	       endif
    658  10000 ????			   -	       ifconst	ROM32K
    659  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    660  10000 ????			   -	       endif
    661  10000 ????			   -	       ifconst	ROM48K
    662  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    663  10000 ????			   -	       endif
    664  10000 ????			   -	       ifconst	pokeysupport
    665  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    666  10000 ????			   -	       endif
    667  10000 ????			   -	       ifconst	HSSUPPORT
    668  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    669  10000 ????			   -	       endif
    670  10000 ????				       endif
    671  10000 ????
    672  10000 ????						;start address of cart...
    673  10000 ????
    674  10000 ????			    BANK_WAS_SET SET	0
    675  10000 ????
    676  10000 ????			   -	       ifconst	ROM8K
    677  10000 ????			   -	       ORG	$E000,0
    678  10000 ????			   -BANK_WAS_SET SET	1
    679  10000 ????				       endif		; ROM8K
    680  10000 ????
    681  10000 ????			   -	       ifconst	ROM16K
    682  10000 ????			   -	       ORG	$C000,0
    683  10000 ????			   -BANK_WAS_SET SET	1
    684  10000 ????			   -	       ifconst	BEADHEADER
    685  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    686  10000 ????			   -	       ifconst	GAMEDESCRIPTION
    687  10000 ????			   -	       CLC
    688  10000 ????			   -	       BCC	_SKIPDESCRIPTION
    689  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
    690  10000 ????			   -_SKIPDESCRIPTION
    691  10000 ????			   -	       endif		; GAMEDESCRIPTION
    692  10000 ????			   -	       jmp	($FFFC)
    693  10000 ????			   -	       endif		; BEADHEADER
    694  10000 ????				       endif		; ROM16K
    695  10000 ????
    696  10000 ????			   -	       ifconst	ROM32K
    697  10000 ????			   -	       ORG	$8000,0
    698  10000 ????			   -BANK_WAS_SET SET	1
    699  10000 ????			   -	       ifconst	BEADHEADER
    700  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    701  10000 ????			   -	       ifconst	GAMEDESCRIPTION
    702  10000 ????			   -	       CLC
    703  10000 ????			   -	       BCC	_SKIPDESCRIPTION
    704  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
    705  10000 ????			   -_SKIPDESCRIPTION
    706  10000 ????			   -	       endif		; GAMEDESCRIPTION
    707  10000 ????			   -	       jmp	($FFFC)
    708  10000 ????			   -	       endif		; BEADHEADER
    709  10000 ????				       endif		; ROM32K
    710  10000 ????
    711  10000 ????				       ifconst	ROM48K
    712  4000					      ORG	$4000,0
    713  4000				   BANK_WAS_SET SET	1
    714  4000				  -	      ifconst	BEADHEADER
    715  4000				  -	      .byte	$BE,$AD,BEADHARDWARE
    716  4000				  -	      ifconst	GAMEDESCRIPTIONSET
    717  4000				  -	      CLC
    718  4000				  -	      BCC	_SKIPDESCRIPTION
    719  4000				  -	      .byte	GAMEDESCRIPTION,0
    720  4000				  -_SKIPDESCRIPTION
    721  4000				  -	      endif		; GAMEDESCRIPTIONSET
    722  4000				  -	      jmp	($FFFC)
    723  4000					      endif		; BEADHEADER
    724  4000					      endif		; ROM48K
    725  4000
    726  4000				  -	      ifconst	ROM52K
    727  4000				  -BANK_WAS_SET SET	1
    728  4000				  -	      ORG	$3000,0
    729  4000					      endif		; ROM52K
    730  4000
    731  4000				  -	      ifconst	bankswitchmode
    732  4000				  -	      ifconst	ROMAT4K
    733  4000				  -BANK_WAS_SET SET	1
    734  4000				  -	      ORG	$4000,0
    735  4000				  -	      RORG	$4000
    736  4000				  -	      else		; ROMAT4K
    737  4000				  -BANK_WAS_SET SET	1
    738  4000				  -	      ORG	$8000,0
    739  4000				  -	      RORG	$8000
    740  4000				  -	      endif
    741  4000					      endif
    742  4000
    743  4000				  -	      if	BANK_WAS_SET = 0
    744  4000				  -	      ORG	$8000,0	; default is 32K
    745  4000					      endif
    746  4000
    747  4000				   START_OF_ROM SET	.
    748  4000							;7800basic v0.24 Mar  2 2023 18:16:13
    749  4000				   SPACEOVERFLOW SET	0
    750  4000				   game
    751  4000				   .L00 		;;  set zoneheight 16
    752  4000
    753  4000				   .L01 		;;  displaymode 160A
    754  4000
    755  4000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    756  4002		       85 3c		      sta	CTRL
    757  4004
    758  4004		       8d 07 21 	      sta	sCTRL
    759  4007
    760  4007				   .L02 		;;  set plotvalueonscreen on
    761  4007
    762  4007				   .L03 		;;  set romsize 48k
    763  4007
    764  4007				   .
    765  4007							;; 
    766  4007
    767  4007				   .L04 		;;  incgraphic g16x16_4color.png 160A
    768  4007
    769  4007				   .L05 		;;  incgraphic g16x16_4color2.png 160A
    770  4007
    771  4007				   .L06 		;;  incgraphic g16x16_4color3.png 160A
    772  4007
    773  4007				   .L07 		;;  incgraphic g16x16_4color4.png 160A 
    774  4007
    775  4007				   .L08 		;;  incgraphic g16x16_4color5.png 160A
    776  4007
    777  4007				   .L09 		;;  incgraphic g16x16_4color6.png 160A
    778  4007
    779  4007				   .L010		;;  incgraphic g16x16_4color7.png 160A
    780  4007
    781  4007				   .L011		;;  incgraphic g16x16_4color8.png 160A 
    782  4007
    783  4007				   .L012		;;  incgraphic zonebg80x16_16.png 160A 0 2 3 1
    784  4007
    785  4007				   .L013		;;  incgraphic ex1.png 160A
    786  4007
    787  4007				   .L014		;;  incgraphic ex2.png 160A
    788  4007
    789  4007				   .L015		;;  incgraphic ex3.png 160A
    790  4007
    791  4007				   .L016		;;  incgraphic ex4.png 160A
    792  4007
    793  4007				   .L017		;;  incgraphic ex5.png 160A
    794  4007
    795  4007				   .L018		;;  incgraphic ex6.png 160A
    796  4007
    797  4007				   .L019		;;  incgraphic ex7.png 160A
    798  4007
    799  4007				   .L020		;;  incgraphic p1.png 160A
    800  4007
    801  4007				   .L021		;;  incgraphic blank.png 160A
    802  4007
    803  4007				   .L022		;;  incgraphic font.png 160A 
    804  4007
    805  4007				   .
    806  4007							;; 
    807  4007
    808  4007				   .L023		;;  rem font
    809  4007
    810  4007				   .L024		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    811  4007
    812  4007				   .L025		;;  characterset font
    813  4007
    814  4007		       a9 e0		      lda	#>font
    815  4009		       8d 0b 21 	      sta	sCHARBASE
    816  400c
    817  400c		       85 34		      sta	CHARBASE
    818  400e		       a9 60		      lda	#(font_mode | %01100000)
    819  4010		       8d 06 21 	      sta	charactermode
    820  4013
    821  4013				   .
    822  4013							;; 
    823  4013
    824  4013				   .L026		;;  rem blue
    825  4013
    826  4013				   .L027		;;  P0C1 = $90
    827  4013
    828  4013		       a9 90		      LDA	#$90
    829  4015		       85 21		      STA	P0C1
    830  4017				   .L028		;;  P0C2 = $70
    831  4017
    832  4017		       a9 70		      LDA	#$70
    833  4019		       85 22		      STA	P0C2
    834  401b				   .L029		;;  P0C3 = $98
    835  401b
    836  401b		       a9 98		      LDA	#$98
    837  401d		       85 23		      STA	P0C3
    838  401f				   .L030		;;  rem red
    839  401f
    840  401f				   .L031		;;  P1C1 = $20
    841  401f
    842  401f		       a9 20		      LDA	#$20
    843  4021		       85 25		      STA	P1C1
    844  4023				   .L032		;;  P1C2 = $32
    845  4023
    846  4023		       a9 32		      LDA	#$32
    847  4025		       85 26		      STA	P1C2
    848  4027				   .L033		;;  P1C3 = $36
    849  4027
    850  4027		       a9 36		      LDA	#$36
    851  4029		       85 27		      STA	P1C3
    852  402b				   .L034		;;  rem green
    853  402b
    854  402b				   .L035		;;  P2C1 = $C1
    855  402b
    856  402b		       a9 c1		      LDA	#$C1
    857  402d		       85 29		      STA	P2C1
    858  402f				   .L036		;;  P2C2 = $C6
    859  402f
    860  402f		       a9 c6		      LDA	#$C6
    861  4031		       85 2a		      STA	P2C2
    862  4033				   .L037		;;  P2C3 = $CB
    863  4033
    864  4033		       a9 cb		      LDA	#$CB
    865  4035		       85 2b		      STA	P2C3
    866  4037				   .L038		;;  rem purple
    867  4037
    868  4037				   .L039		;;  P3C1 = $50
    869  4037
    870  4037		       a9 50		      LDA	#$50
    871  4039		       85 2d		      STA	P3C1
    872  403b				   .L040		;;  P3C2 = $53
    873  403b
    874  403b		       a9 53		      LDA	#$53
    875  403d		       85 2e		      STA	P3C2
    876  403f				   .L041		;;  P3C3 = $58
    877  403f
    878  403f		       a9 58		      LDA	#$58
    879  4041		       85 2f		      STA	P3C3
    880  4043				   .L042		;;  rem orange
    881  4043
    882  4043				   .L043		;;  P4C1 = $35
    883  4043
    884  4043		       a9 35		      LDA	#$35
    885  4045		       85 31		      STA	P4C1
    886  4047				   .L044		;;  P4C2 = $38
    887  4047
    888  4047		       a9 38		      LDA	#$38
    889  4049		       85 32		      STA	P4C2
    890  404b				   .L045		;;  P4C3 = $3C
    891  404b
    892  404b		       a9 3c		      LDA	#$3C
    893  404d		       85 33		      STA	P4C3
    894  404f				   .L046		;;  rem yellow
    895  404f
    896  404f				   .L047		;;  P5C1 = $15
    897  404f
    898  404f		       a9 15		      LDA	#$15
    899  4051		       85 35		      STA	P5C1
    900  4053				   .L048		;;  P5C2 = $1A
    901  4053
    902  4053		       a9 1a		      LDA	#$1A
    903  4055		       85 36		      STA	P5C2
    904  4057				   .L049		;;  P5C3 = $1E
    905  4057
    906  4057		       a9 1e		      LDA	#$1E
    907  4059		       85 37		      STA	P5C3
    908  405b				   .L050		;;  rem teal
    909  405b
    910  405b				   .L051		;;  P6C1 = $A1
    911  405b
    912  405b		       a9 a1		      LDA	#$A1
    913  405d		       85 39		      STA	P6C1
    914  405f				   .L052		;;  P6C2 = $A6
    915  405f
    916  405f		       a9 a6		      LDA	#$A6
    917  4061		       85 3a		      STA	P6C2
    918  4063				   .L053		;;  P6C3 = $Ac
    919  4063
    920  4063		       a9 ac		      LDA	#$Ac
    921  4065		       85 3b		      STA	P6C3
    922  4067				   .L054		;;  rem white
    923  4067
    924  4067				   .L055		;;  P7C1 = $0F
    925  4067
    926  4067		       a9 0f		      LDA	#$0F
    927  4069		       85 3d		      STA	P7C1
    928  406b				   .L056		;;  P7C2 = $05
    929  406b
    930  406b		       a9 05		      LDA	#$05
    931  406d		       85 3e		      STA	P7C2
    932  406f				   .L057		;;  P7C3 = $09
    933  406f
    934  406f		       a9 09		      LDA	#$09
    935  4071		       85 3f		      STA	P7C3
    936  4073				   .
    937  4073							;; 
    938  4073
    939  4073				   .L058		;;  dim bg  =	var1
    940  4073
    941  4073				   .L059		;;  dim db  =	var2
    942  4073
    943  4073				   .L060		;;  dim an  =	var3
    944  4073
    945  4073				   .L061		;;  dim ex  =	var4
    946  4073
    947  4073				   .L062		;;  dim wrap  =  var5
    948  4073
    949  4073				   .
    950  4073							;; 
    951  4073
    952  4073				   .L063		;;  bg  =  0
    953  4073
    954  4073		       a9 00		      LDA	#0
    955  4075		       8d 41 01 	      STA	bg
    956  4078				   .L064		;;  db  =  0
    957  4078
    958  4078		       a9 00		      LDA	#0
    959  407a		       8d 42 01 	      STA	db
    960  407d				   .L065		;;  an  =  0
    961  407d
    962  407d		       a9 00		      LDA	#0
    963  407f		       8d 43 01 	      STA	an
    964  4082				   .L066		;;  ex  =  0
    965  4082
    966  4082		       a9 00		      LDA	#0
    967  4084		       8d 44 01 	      STA	ex
    968  4087				   .L067		;;  wrap  =  0
    969  4087
    970  4087		       a9 00		      LDA	#0
    971  4089		       8d 45 01 	      STA	wrap
    972  408c				   .
    973  408c							;; 
    974  408c
    975  408c				   .L068		;;  w	=  0
    976  408c
    977  408c		       a9 00		      LDA	#0
    978  408e		       85 fc		      STA	w
    979  4090				   .L069		;;  z	=  0
    980  4090
    981  4090		       a9 00		      LDA	#0
    982  4092		       85 ff		      STA	z
    983  4094				   .
    984  4094							;; 
    985  4094
    986  4094				   ._title
    987  4094							;; _title
    988  4094
    989  4094				   .L070		;;  clearscreen
    990  4094
    991  4094		       20 8f f0 	      jsr	clearscreen
    992  4097				   .L071		;;  plotchars 'demo^1' 7 67 3 1
    993  4097
    994  4097		       4c a0 40 	      JMP	skipalphadata0
    995  409a				   alphadata0
    996  409a		       63		      .byte.b	(<font + $0d)
    997  409b		       64		      .byte.b	(<font + $0e)
    998  409c		       6c		      .byte.b	(<font + $16)
    999  409d		       6e		      .byte.b	(<font + $18)
   1000  409e		       8a		      .byte.b	(<font + $34)
   1001  409f		       57		      .byte.b	(<font + $01)
   1002  40a0				   skipalphadata0
   1003  40a0		       a9 9a		      lda	#<alphadata0
   1004  40a2		       85 42		      sta	temp1
   1005  40a4
   1006  40a4		       a9 40		      lda	#>alphadata0
   1007  40a6		       85 43		      sta	temp2
   1008  40a8
   1009  40a8		       a9 1a		      lda	#26	; width in two's complement
   1010  40aa		       09 e0		      ora	#224	; palette left shifted 5 bits
   1011  40ac		       85 44		      sta	temp3
   1012  40ae		       a9 43		      lda	#67
   1013  40b0		       85 45		      sta	temp4
   1014  40b2
   1015  40b2		       a9 03		      lda	#3
   1016  40b4		       85 46		      sta	temp5
   1017  40b6
   1018  40b6		       20 b3 f3 	      jsr	plotcharacters
   1019  40b9				   .L072		;;  plotchars 'atari^7800^basic^exploration' 1 23 5 1
   1020  40b9
   1021  40b9		       4c d8 40 	      JMP	skipalphadata1
   1022  40bc				   alphadata1
   1023  40bc		       60		      .byte.b	(<font + $0a)
   1024  40bd		       73		      .byte.b	(<font + $1d)
   1025  40be		       60		      .byte.b	(<font + $0a)
   1026  40bf		       71		      .byte.b	(<font + $1b)
   1027  40c0		       68		      .byte.b	(<font + $12)
   1028  40c1		       8a		      .byte.b	(<font + $34)
   1029  40c2		       5d		      .byte.b	(<font + $07)
   1030  40c3		       5e		      .byte.b	(<font + $08)
   1031  40c4		       56		      .byte.b	(<font + $00)
   1032  40c5		       56		      .byte.b	(<font + $00)
   1033  40c6		       8a		      .byte.b	(<font + $34)
   1034  40c7		       61		      .byte.b	(<font + $0b)
   1035  40c8		       60		      .byte.b	(<font + $0a)
   1036  40c9		       72		      .byte.b	(<font + $1c)
   1037  40ca		       68		      .byte.b	(<font + $12)
   1038  40cb		       62		      .byte.b	(<font + $0c)
   1039  40cc		       8a		      .byte.b	(<font + $34)
   1040  40cd		       64		      .byte.b	(<font + $0e)
   1041  40ce		       77		      .byte.b	(<font + $21)
   1042  40cf		       6f		      .byte.b	(<font + $19)
   1043  40d0		       6b		      .byte.b	(<font + $15)
   1044  40d1		       6e		      .byte.b	(<font + $18)
   1045  40d2		       71		      .byte.b	(<font + $1b)
   1046  40d3		       60		      .byte.b	(<font + $0a)
   1047  40d4		       73		      .byte.b	(<font + $1d)
   1048  40d5		       68		      .byte.b	(<font + $12)
   1049  40d6		       6e		      .byte.b	(<font + $18)
   1050  40d7		       6d		      .byte.b	(<font + $17)
   1051  40d8				   skipalphadata1
   1052  40d8		       a9 bc		      lda	#<alphadata1
   1053  40da		       85 42		      sta	temp1
   1054  40dc
   1055  40dc		       a9 40		      lda	#>alphadata1
   1056  40de		       85 43		      sta	temp2
   1057  40e0
   1058  40e0		       a9 04		      lda	#4	; width in two's complement
   1059  40e2		       09 20		      ora	#32	; palette left shifted 5 bits
   1060  40e4		       85 44		      sta	temp3
   1061  40e6		       a9 17		      lda	#23
   1062  40e8		       85 45		      sta	temp4
   1063  40ea
   1064  40ea		       a9 05		      lda	#5
   1065  40ec		       85 46		      sta	temp5
   1066  40ee
   1067  40ee		       20 b3 f3 	      jsr	plotcharacters
   1068  40f1				   .L073		;;  plotchars '160a^zoneheight^16' 7 47 7 1
   1069  40f1
   1070  40f1		       4c 06 41 	      JMP	skipalphadata2
   1071  40f4				   alphadata2
   1072  40f4		       57		      .byte.b	(<font + $01)
   1073  40f5		       5c		      .byte.b	(<font + $06)
   1074  40f6		       56		      .byte.b	(<font + $00)
   1075  40f7		       60		      .byte.b	(<font + $0a)
   1076  40f8		       8a		      .byte.b	(<font + $34)
   1077  40f9		       79		      .byte.b	(<font + $23)
   1078  40fa		       6e		      .byte.b	(<font + $18)
   1079  40fb		       6d		      .byte.b	(<font + $17)
   1080  40fc		       64		      .byte.b	(<font + $0e)
   1081  40fd		       67		      .byte.b	(<font + $11)
   1082  40fe		       64		      .byte.b	(<font + $0e)
   1083  40ff		       68		      .byte.b	(<font + $12)
   1084  4100		       66		      .byte.b	(<font + $10)
   1085  4101		       67		      .byte.b	(<font + $11)
   1086  4102		       73		      .byte.b	(<font + $1d)
   1087  4103		       8a		      .byte.b	(<font + $34)
   1088  4104		       57		      .byte.b	(<font + $01)
   1089  4105		       5c		      .byte.b	(<font + $06)
   1090  4106				   skipalphadata2
   1091  4106		       a9 f4		      lda	#<alphadata2
   1092  4108		       85 42		      sta	temp1
   1093  410a
   1094  410a		       a9 40		      lda	#>alphadata2
   1095  410c		       85 43		      sta	temp2
   1096  410e
   1097  410e		       a9 0e		      lda	#14	; width in two's complement
   1098  4110		       09 e0		      ora	#224	; palette left shifted 5 bits
   1099  4112		       85 44		      sta	temp3
   1100  4114		       a9 2f		      lda	#47
   1101  4116		       85 45		      sta	temp4
   1102  4118
   1103  4118		       a9 07		      lda	#7
   1104  411a		       85 46		      sta	temp5
   1105  411c
   1106  411c		       20 b3 f3 	      jsr	plotcharacters
   1107  411f				   .L074		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen2_init
   1108  411f
   1109  411f		       a9 08		      LDA	#8
   1110  4121		       c5 fc		      CMP	w
   1111  4123		       b0 0c		      BCS	.skipL074
   1112  4125				   .condpart0
   1113  4125		       2c 02 21 	      bit	sINPT1
   1114  4128		       10 07		      BPL	.skip0then
   1115  412a				   .condpart1
   1116  412a		       a9 00		      LDA	#0
   1117  412c		       85 fc		      STA	w
   1118  412e		       4c 3e 41 	      jmp	._screen2_init
   1119  4131
   1120  4131				   .skip0then
   1121  4131				   .skipL074
   1122  4131				   .L075		;;  w	=  w  +  1
   1123  4131
   1124  4131		       a5 fc		      LDA	w
   1125  4133		       18		      CLC
   1126  4134		       69 01		      ADC	#1
   1127  4136		       85 fc		      STA	w
   1128  4138				   .L076		;;  drawscreen
   1129  4138
   1130  4138		       20 cb f0 	      jsr	drawscreen
   1131  413b				   .L077		;;  goto _title
   1132  413b
   1133  413b		       4c 94 40 	      jmp	._title
   1134  413e
   1135  413e				   .
   1136  413e							;; 
   1137  413e
   1138  413e				   .L078		;;  rem background with no animation or doublebuffering
   1139  413e
   1140  413e				   ._screen2_init
   1141  413e							;; _screen2_init
   1142  413e
   1143  413e				   .L079		;;  bg  =  1
   1144  413e
   1145  413e		       a9 01		      LDA	#1
   1146  4140		       8d 41 01 	      STA	bg
   1147  4143				   .L080		;;  db  =  0
   1148  4143
   1149  4143		       a9 00		      LDA	#0
   1150  4145		       8d 42 01 	      STA	db
   1151  4148				   .L081		;;  an  =  0
   1152  4148
   1153  4148		       a9 00		      LDA	#0
   1154  414a		       8d 43 01 	      STA	an
   1155  414d				   .L082		;;  w	=  0
   1156  414d
   1157  414d		       a9 00		      LDA	#0
   1158  414f		       85 fc		      STA	w
   1159  4151				   .L083		;;  gosub _screen_setup
   1160  4151
   1161  4151		       20 b6 42 	      jsr	._screen_setup
   1162  4154
   1163  4154				   ._screen2_loop
   1164  4154							;; _screen2_loop
   1165  4154
   1166  4154				   .L084		;;  gosub _screen
   1167  4154
   1168  4154		       20 e8 42 	      jsr	._screen
   1169  4157
   1170  4157				   .L085		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen3_init
   1171  4157
   1172  4157		       a9 08		      LDA	#8
   1173  4159		       c5 fc		      CMP	w
   1174  415b		       b0 0c		      BCS	.skipL085
   1175  415d				   .condpart2
   1176  415d		       2c 02 21 	      bit	sINPT1
   1177  4160		       10 07		      BPL	.skip2then
   1178  4162				   .condpart3
   1179  4162		       a9 00		      LDA	#0
   1180  4164		       85 fc		      STA	w
   1181  4166		       4c 73 41 	      jmp	._screen3_init
   1182  4169
   1183  4169				   .skip2then
   1184  4169				   .skipL085
   1185  4169				   .L086		;;  w	=  w  +  1
   1186  4169
   1187  4169		       a5 fc		      LDA	w
   1188  416b		       18		      CLC
   1189  416c		       69 01		      ADC	#1
   1190  416e		       85 fc		      STA	w
   1191  4170				   .L087		;;  goto _screen2_loop
   1192  4170
   1193  4170		       4c 54 41 	      jmp	._screen2_loop
   1194  4173
   1195  4173				   .
   1196  4173							;; 
   1197  4173
   1198  4173				   .L088		;;  rem no background with no animation or doublebuffering
   1199  4173
   1200  4173				   ._screen3_init
   1201  4173							;; _screen3_init
   1202  4173
   1203  4173				   .L089		;;  bg  =  0
   1204  4173
   1205  4173		       a9 00		      LDA	#0
   1206  4175		       8d 41 01 	      STA	bg
   1207  4178				   .L090		;;  db  =  0
   1208  4178
   1209  4178		       a9 00		      LDA	#0
   1210  417a		       8d 42 01 	      STA	db
   1211  417d				   .L091		;;  an  =  0
   1212  417d
   1213  417d		       a9 00		      LDA	#0
   1214  417f		       8d 43 01 	      STA	an
   1215  4182				   .L092		;;  w	=  0
   1216  4182
   1217  4182		       a9 00		      LDA	#0
   1218  4184		       85 fc		      STA	w
   1219  4186				   .L093		;;  gosub _screen_setup
   1220  4186
   1221  4186		       20 b6 42 	      jsr	._screen_setup
   1222  4189
   1223  4189				   ._screen3_loop
   1224  4189							;; _screen3_loop
   1225  4189
   1226  4189				   .L094		;;  gosub _screen
   1227  4189
   1228  4189		       20 e8 42 	      jsr	._screen
   1229  418c
   1230  418c				   .L095		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen4_init
   1231  418c
   1232  418c		       a9 08		      LDA	#8
   1233  418e		       c5 fc		      CMP	w
   1234  4190		       b0 0c		      BCS	.skipL095
   1235  4192				   .condpart4
   1236  4192		       2c 02 21 	      bit	sINPT1
   1237  4195		       10 07		      BPL	.skip4then
   1238  4197				   .condpart5
   1239  4197		       a9 00		      LDA	#0
   1240  4199		       85 fc		      STA	w
   1241  419b		       4c a8 41 	      jmp	._screen4_init
   1242  419e
   1243  419e				   .skip4then
   1244  419e				   .skipL095
   1245  419e				   .L096		;;  w	=  w  +  1
   1246  419e
   1247  419e		       a5 fc		      LDA	w
   1248  41a0		       18		      CLC
   1249  41a1		       69 01		      ADC	#1
   1250  41a3		       85 fc		      STA	w
   1251  41a5				   .L097		;;  goto _screen3_loop
   1252  41a5
   1253  41a5		       4c 89 41 	      jmp	._screen3_loop
   1254  41a8
   1255  41a8				   .
   1256  41a8							;; 
   1257  41a8
   1258  41a8				   .L098		;;  rem no background with  animation and no doublebuffering
   1259  41a8
   1260  41a8				   ._screen4_init
   1261  41a8							;; _screen4_init
   1262  41a8
   1263  41a8				   .L099		;;  bg  =  0
   1264  41a8
   1265  41a8		       a9 00		      LDA	#0
   1266  41aa		       8d 41 01 	      STA	bg
   1267  41ad				   .L0100		;;  db  =  0
   1268  41ad
   1269  41ad		       a9 00		      LDA	#0
   1270  41af		       8d 42 01 	      STA	db
   1271  41b2				   .L0101		;;  an  =  1
   1272  41b2
   1273  41b2		       a9 01		      LDA	#1
   1274  41b4		       8d 43 01 	      STA	an
   1275  41b7				   .L0102		;;  w	=  0
   1276  41b7
   1277  41b7		       a9 00		      LDA	#0
   1278  41b9		       85 fc		      STA	w
   1279  41bb				   .L0103		;;  gosub _screen_setup
   1280  41bb
   1281  41bb		       20 b6 42 	      jsr	._screen_setup
   1282  41be
   1283  41be				   ._screen4_loop
   1284  41be							;; _screen4_loop
   1285  41be
   1286  41be				   .L0104		;;  gosub _screen
   1287  41be
   1288  41be		       20 e8 42 	      jsr	._screen
   1289  41c1
   1290  41c1				   .L0105		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen5_init
   1291  41c1
   1292  41c1		       a9 08		      LDA	#8
   1293  41c3		       c5 fc		      CMP	w
   1294  41c5		       b0 0c		      BCS	.skipL0105
   1295  41c7				   .condpart6
   1296  41c7		       2c 02 21 	      bit	sINPT1
   1297  41ca		       10 07		      BPL	.skip6then
   1298  41cc				   .condpart7
   1299  41cc		       a9 00		      LDA	#0
   1300  41ce		       85 fc		      STA	w
   1301  41d0		       4c dd 41 	      jmp	._screen5_init
   1302  41d3
   1303  41d3				   .skip6then
   1304  41d3				   .skipL0105
   1305  41d3				   .L0106		;;  w	=  w  +  1
   1306  41d3
   1307  41d3		       a5 fc		      LDA	w
   1308  41d5		       18		      CLC
   1309  41d6		       69 01		      ADC	#1
   1310  41d8		       85 fc		      STA	w
   1311  41da				   .L0107		;;  goto _screen4_loop
   1312  41da
   1313  41da		       4c be 41 	      jmp	._screen4_loop
   1314  41dd
   1315  41dd				   .
   1316  41dd							;; 
   1317  41dd
   1318  41dd				   .L0108		;;  rem with background with animation and no doublebuffering
   1319  41dd
   1320  41dd				   ._screen5_init
   1321  41dd							;; _screen5_init
   1322  41dd
   1323  41dd				   .L0109		;;  bg  =  1
   1324  41dd
   1325  41dd		       a9 01		      LDA	#1
   1326  41df		       8d 41 01 	      STA	bg
   1327  41e2				   .L0110		;;  db  =  0
   1328  41e2
   1329  41e2		       a9 00		      LDA	#0
   1330  41e4		       8d 42 01 	      STA	db
   1331  41e7				   .L0111		;;  an  =  1
   1332  41e7
   1333  41e7		       a9 01		      LDA	#1
   1334  41e9		       8d 43 01 	      STA	an
   1335  41ec				   .L0112		;;  w	=  0
   1336  41ec
   1337  41ec		       a9 00		      LDA	#0
   1338  41ee		       85 fc		      STA	w
   1339  41f0				   .L0113		;;  gosub _screen_setup
   1340  41f0
   1341  41f0		       20 b6 42 	      jsr	._screen_setup
   1342  41f3
   1343  41f3				   ._screen5_loop
   1344  41f3							;; _screen5_loop
   1345  41f3
   1346  41f3				   .L0114		;;  gosub _screen
   1347  41f3
   1348  41f3		       20 e8 42 	      jsr	._screen
   1349  41f6
   1350  41f6				   .L0115		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen6_init
   1351  41f6
   1352  41f6		       a9 08		      LDA	#8
   1353  41f8		       c5 fc		      CMP	w
   1354  41fa		       b0 0c		      BCS	.skipL0115
   1355  41fc				   .condpart8
   1356  41fc		       2c 02 21 	      bit	sINPT1
   1357  41ff		       10 07		      BPL	.skip8then
   1358  4201				   .condpart9
   1359  4201		       a9 00		      LDA	#0
   1360  4203		       85 fc		      STA	w
   1361  4205		       4c 12 42 	      jmp	._screen6_init
   1362  4208
   1363  4208				   .skip8then
   1364  4208				   .skipL0115
   1365  4208				   .L0116		;;  w	=  w  +  1
   1366  4208
   1367  4208		       a5 fc		      LDA	w
   1368  420a		       18		      CLC
   1369  420b		       69 01		      ADC	#1
   1370  420d		       85 fc		      STA	w
   1371  420f				   .L0117		;;  goto _screen5_loop
   1372  420f
   1373  420f		       4c f3 41 	      jmp	._screen5_loop
   1374  4212
   1375  4212				   .
   1376  4212							;; 
   1377  4212
   1378  4212				   .L0118		;;  rem with no background with animation and with doublebuffering
   1379  4212
   1380  4212				   ._screen6_init
   1381  4212							;; _screen6_init
   1382  4212
   1383  4212				   .L0119		;;  bg  =  0
   1384  4212
   1385  4212		       a9 00		      LDA	#0
   1386  4214		       8d 41 01 	      STA	bg
   1387  4217				   .L0120		;;  db  =  1
   1388  4217
   1389  4217		       a9 01		      LDA	#1
   1390  4219		       8d 42 01 	      STA	db
   1391  421c				   .L0121		;;  an  =  1
   1392  421c
   1393  421c		       a9 01		      LDA	#1
   1394  421e		       8d 43 01 	      STA	an
   1395  4221				   .L0122		;;  w	=  0
   1396  4221
   1397  4221		       a9 00		      LDA	#0
   1398  4223		       85 fc		      STA	w
   1399  4225				   .L0123		;;  gosub _screen_setup
   1400  4225
   1401  4225		       20 b6 42 	      jsr	._screen_setup
   1402  4228
   1403  4228				   ._screen6_loop
   1404  4228							;; _screen6_loop
   1405  4228
   1406  4228				   .L0124		;;  gosub _screen
   1407  4228
   1408  4228		       20 e8 42 	      jsr	._screen
   1409  422b
   1410  422b				   .L0125		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen7_init
   1411  422b
   1412  422b		       a9 08		      LDA	#8
   1413  422d		       c5 fc		      CMP	w
   1414  422f		       b0 0c		      BCS	.skipL0125
   1415  4231				   .condpart10
   1416  4231		       2c 02 21 	      bit	sINPT1
   1417  4234		       10 07		      BPL	.skip10then
   1418  4236				   .condpart11
   1419  4236		       a9 00		      LDA	#0
   1420  4238		       85 fc		      STA	w
   1421  423a		       4c 47 42 	      jmp	._screen7_init
   1422  423d
   1423  423d				   .skip10then
   1424  423d				   .skipL0125
   1425  423d				   .L0126		;;  w	=  w  +  1
   1426  423d
   1427  423d		       a5 fc		      LDA	w
   1428  423f		       18		      CLC
   1429  4240		       69 01		      ADC	#1
   1430  4242		       85 fc		      STA	w
   1431  4244				   .L0127		;;  goto _screen6_loop
   1432  4244
   1433  4244		       4c 28 42 	      jmp	._screen6_loop
   1434  4247
   1435  4247				   .
   1436  4247							;; 
   1437  4247
   1438  4247				   .L0128		;;  rem with background with animation and with doublebuffering
   1439  4247
   1440  4247				   ._screen7_init
   1441  4247							;; _screen7_init
   1442  4247
   1443  4247				   .L0129		;;  bg  =  1
   1444  4247
   1445  4247		       a9 01		      LDA	#1
   1446  4249		       8d 41 01 	      STA	bg
   1447  424c				   .L0130		;;  db  =  1
   1448  424c
   1449  424c		       a9 01		      LDA	#1
   1450  424e		       8d 42 01 	      STA	db
   1451  4251				   .L0131		;;  an  =  1
   1452  4251
   1453  4251		       a9 01		      LDA	#1
   1454  4253		       8d 43 01 	      STA	an
   1455  4256				   .L0132		;;  w	=  0
   1456  4256
   1457  4256		       a9 00		      LDA	#0
   1458  4258		       85 fc		      STA	w
   1459  425a				   .L0133		;;  gosub _screen_setup
   1460  425a
   1461  425a		       20 b6 42 	      jsr	._screen_setup
   1462  425d
   1463  425d				   ._screen7_loop
   1464  425d							;; _screen7_loop
   1465  425d
   1466  425d				   .L0134		;;  gosub _screen
   1467  425d
   1468  425d		       20 e8 42 	      jsr	._screen
   1469  4260
   1470  4260				   .L0135		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen8_init
   1471  4260
   1472  4260		       a9 08		      LDA	#8
   1473  4262		       c5 fc		      CMP	w
   1474  4264		       b0 0c		      BCS	.skipL0135
   1475  4266				   .condpart12
   1476  4266		       2c 02 21 	      bit	sINPT1
   1477  4269		       10 07		      BPL	.skip12then
   1478  426b				   .condpart13
   1479  426b		       a9 00		      LDA	#0
   1480  426d		       85 fc		      STA	w
   1481  426f		       4c 7c 42 	      jmp	._screen8_init
   1482  4272
   1483  4272				   .skip12then
   1484  4272				   .skipL0135
   1485  4272				   .L0136		;;  w	=  w  +  1
   1486  4272
   1487  4272		       a5 fc		      LDA	w
   1488  4274		       18		      CLC
   1489  4275		       69 01		      ADC	#1
   1490  4277		       85 fc		      STA	w
   1491  4279				   .L0137		;;  goto _screen7_loop
   1492  4279
   1493  4279		       4c 5d 42 	      jmp	._screen7_loop
   1494  427c
   1495  427c				   .
   1496  427c							;; 
   1497  427c
   1498  427c				   ._screen8_init
   1499  427c							;; _screen8_init
   1500  427c
   1501  427c				   .L0138		;;  bg  =  1
   1502  427c
   1503  427c		       a9 01		      LDA	#1
   1504  427e		       8d 41 01 	      STA	bg
   1505  4281				   .L0139		;;  db  =  1
   1506  4281
   1507  4281		       a9 01		      LDA	#1
   1508  4283		       8d 42 01 	      STA	db
   1509  4286				   .L0140		;;  an  =  1
   1510  4286
   1511  4286		       a9 01		      LDA	#1
   1512  4288		       8d 43 01 	      STA	an
   1513  428b				   .L0141		;;  ex  =  1
   1514  428b
   1515  428b		       a9 01		      LDA	#1
   1516  428d		       8d 44 01 	      STA	ex
   1517  4290				   .L0142		;;  w	=  0
   1518  4290
   1519  4290		       a9 00		      LDA	#0
   1520  4292		       85 fc		      STA	w
   1521  4294				   .L0143		;;  gosub _screen_setup
   1522  4294
   1523  4294		       20 b6 42 	      jsr	._screen_setup
   1524  4297
   1525  4297				   ._screen8_loop
   1526  4297							;; _screen8_loop
   1527  4297
   1528  4297				   .L0144		;;  gosub _screen
   1529  4297
   1530  4297		       20 e8 42 	      jsr	._screen
   1531  429a
   1532  429a				   .L0145		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen2_init
   1533  429a
   1534  429a		       a9 08		      LDA	#8
   1535  429c		       c5 fc		      CMP	w
   1536  429e		       b0 0c		      BCS	.skipL0145
   1537  42a0				   .condpart14
   1538  42a0		       2c 02 21 	      bit	sINPT1
   1539  42a3		       10 07		      BPL	.skip14then
   1540  42a5				   .condpart15
   1541  42a5		       a9 00		      LDA	#0
   1542  42a7		       85 fc		      STA	w
   1543  42a9		       4c 3e 41 	      jmp	._screen2_init
   1544  42ac
   1545  42ac				   .skip14then
   1546  42ac				   .skipL0145
   1547  42ac				   .L0146		;;  w	=  w  +  1
   1548  42ac
   1549  42ac		       a5 fc		      LDA	w
   1550  42ae		       18		      CLC
   1551  42af		       69 01		      ADC	#1
   1552  42b1		       85 fc		      STA	w
   1553  42b3				   .L0147		;;  goto _screen8_loop
   1554  42b3
   1555  42b3		       4c 97 42 	      jmp	._screen8_loop
   1556  42b6
   1557  42b6				   .
   1558  42b6							;; 
   1559  42b6
   1560  42b6				   .L0148		;;  rem set-up screen vars
   1561  42b6
   1562  42b6				   ._screen_setup
   1563  42b6							;; _screen_setup
   1564  42b6
   1565  42b6				   .L0149		;;  clearscreen
   1566  42b6
   1567  42b6		       20 8f f0 	      jsr	clearscreen
   1568  42b9				   .L0150		;;  if db then doublebuffer on
   1569  42b9
   1570  42b9		       ad 42 01 	      LDA	db
   1571  42bc		       f0 04		      BEQ	.skipL0150
   1572  42be				   .condpart16
   1573  42be		       a9 01		      lda	#1
   1574  42c0		       85 d5		      sta	doublebufferstate
   1575  42c2				   .skipL0150
   1576  42c2				   .L0151		;;  if !db then doublebuffer off
   1577  42c2
   1578  42c2		       ad 42 01 	      LDA	db
   1579  42c5		       d0 03		      BNE	.skipL0151
   1580  42c7				   .condpart17
   1581  42c7		       20 51 f6 	      jsr	doublebufferoff
   1582  42ca				   .skipL0151
   1583  42ca				   .L0152		;;  if bg then gosub drawZoneBG
   1584  42ca
   1585  42ca		       ad 41 01 	      LDA	bg
   1586  42cd		       f0 03		      BEQ	.skipL0152
   1587  42cf				   .condpart18
   1588  42cf		       20 d9 45 	      jsr	.drawZoneBG
   1589  42d2
   1590  42d2				   .skipL0152
   1591  42d2				   .L0153		;;  m	=  0
   1592  42d2
   1593  42d2		       a9 00		      LDA	#0
   1594  42d4		       85 f2		      STA	m
   1595  42d6				   .L0154		;;  n	=  0
   1596  42d6
   1597  42d6		       a9 00		      LDA	#0
   1598  42d8		       85 f3		      STA	n
   1599  42da				   .L0155		;;  c	=  0
   1600  42da
   1601  42da		       a9 00		      LDA	#0
   1602  42dc		       85 e8		      STA	c
   1603  42de				   .L0156		;;  f	=  0
   1604  42de
   1605  42de		       a9 00		      LDA	#0
   1606  42e0		       85 eb		      STA	f
   1607  42e2				   .L0157		;;  wrap  =  0
   1608  42e2
   1609  42e2		       a9 00		      LDA	#0
   1610  42e4		       8d 45 01 	      STA	wrap
   1611  42e7				   .L0158		;;  return
   1612  42e7
   1613  42e7		       60		      RTS
   1614  42e8				   .
   1615  42e8							;; 
   1616  42e8
   1617  42e8				   .L0159		;;  rem draw screen
   1618  42e8
   1619  42e8				   ._screen
   1620  42e8							;; _screen
   1621  42e8
   1622  42e8				   .L0160		;;  if bg then restorescreen
   1623  42e8
   1624  42e8		       ad 41 01 	      LDA	bg
   1625  42eb		       f0 03		      BEQ	.skipL0160
   1626  42ed				   .condpart19
   1627  42ed		       20 a1 f0 	      jsr	restorescreen
   1628  42f0				   .skipL0160
   1629  42f0				   .L0161		;;  if !bg then clearscreen
   1630  42f0
   1631  42f0		       ad 41 01 	      LDA	bg
   1632  42f3		       d0 03		      BNE	.skipL0161
   1633  42f5				   .condpart20
   1634  42f5		       20 8f f0 	      jsr	clearscreen
   1635  42f8				   .skipL0161
   1636  42f8				   .L0162		;;  y	=  0
   1637  42f8
   1638  42f8		       a9 00		      LDA	#0
   1639  42fa		       85 fe		      STA	y
   1640  42fc				   .L0163		;;  x	=  0
   1641  42fc
   1642  42fc		       a9 00		      LDA	#0
   1643  42fe		       85 fd		      STA	x
   1644  4300				   .L0164		;;  c	=  0
   1645  4300
   1646  4300		       a9 00		      LDA	#0
   1647  4302		       85 e8		      STA	c
   1648  4304				   .L0165		;;  for i  =  0 to n
   1649  4304
   1650  4304		       a9 00		      LDA	#0
   1651  4306		       85 ee		      STA	i
   1652  4308				   .L0165fori
   1653  4308				   .L0166		;;  for j  =  0 to m
   1654  4308
   1655  4308		       a9 00		      LDA	#0
   1656  430a		       85 ef		      STA	j
   1657  430c				   .L0166forj
   1658  430c				   .L0167		;;  if ex  =  1  &&  wrap  =  0 then plotsprite ex1 c x y f
   1659  430c
   1660  430c		       ad 44 01 	      LDA	ex
   1661  430f		       c9 01		      CMP	#1
   1662  4311		       d0 33		      BNE	.skipL0167
   1663  4313				   .condpart21
   1664  4313		       ad 45 01 	      LDA	wrap
   1665  4316		       c9 00		      CMP	#0
   1666  4318		       d0 2c		      BNE	.skip21then
   1667  431a				   .condpart22
   1668  431a		       a9 34		      lda	#<ex1
   1669  431c		       a0 04		      ldy	#ex1_width
   1670  431e		       18		      clc
   1671  431f		       f0 05		      beq	plotspritewidthskip3
   1672  4321				   plotspritewidthloop3
   1673  4321		       65 eb		      adc	f
   1674  4323		       88		      dey
   1675  4324		       d0 fb		      bne	plotspritewidthloop3
   1676  4326				   plotspritewidthskip3
   1677  4326		       85 42		      sta	temp1
   1678  4328
   1679  4328		       a9 e0		      lda	#>ex1
   1680  432a		       85 43		      sta	temp2
   1681  432c
   1682  432c		       a5 e8		      lda	c
   1683  432e		       0a		      asl
   1684  432f		       0a		      asl
   1685  4330		       0a		      asl
   1686  4331		       0a		      asl
   1687  4332		       0a		      asl
   1688  4333		       09 1c		      ora	#ex1_width_twoscompliment
   1689  4335		       85 44		      sta	temp3
   1690  4337
   1691  4337		       a5 fd		      lda	x
   1692  4339		       85 45		      sta	temp4
   1693  433b
   1694  433b		       a5 fe		      lda	y
   1695  433d		       85 46		      sta	temp5
   1696  433f
   1697  433f		       a9 40		      lda	#(ex1_mode|%01000000)
   1698  4341		       85 47		      sta	temp6
   1699  4343
   1700  4343		       20 f0 f2 	      jsr	plotsprite
   1701  4346				   .skip21then
   1702  4346				   .skipL0167
   1703  4346				   .L0168		;;  if ex  =  0  &&  wrap  =  0 then plotsprite g16x16_4color c x y f
   1704  4346
   1705  4346		       ad 44 01 	      LDA	ex
   1706  4349		       c9 00		      CMP	#0
   1707  434b		       d0 33		      BNE	.skipL0168
   1708  434d				   .condpart23
   1709  434d		       ad 45 01 	      LDA	wrap
   1710  4350		       c9 00		      CMP	#0
   1711  4352		       d0 2c		      BNE	.skip23then
   1712  4354				   .condpart24
   1713  4354		       a9 00		      lda	#<g16x16_4color
   1714  4356		       a0 04		      ldy	#g16x16_4color_width
   1715  4358		       18		      clc
   1716  4359		       f0 05		      beq	plotspritewidthskip4
   1717  435b				   plotspritewidthloop4
   1718  435b		       65 eb		      adc	f
   1719  435d		       88		      dey
   1720  435e		       d0 fb		      bne	plotspritewidthloop4
   1721  4360				   plotspritewidthskip4
   1722  4360		       85 42		      sta	temp1
   1723  4362
   1724  4362		       a9 e0		      lda	#>g16x16_4color
   1725  4364		       85 43		      sta	temp2
   1726  4366
   1727  4366		       a5 e8		      lda	c
   1728  4368		       0a		      asl
   1729  4369		       0a		      asl
   1730  436a		       0a		      asl
   1731  436b		       0a		      asl
   1732  436c		       0a		      asl
   1733  436d		       09 1c		      ora	#g16x16_4color_width_twoscompliment
   1734  436f		       85 44		      sta	temp3
   1735  4371
   1736  4371		       a5 fd		      lda	x
   1737  4373		       85 45		      sta	temp4
   1738  4375
   1739  4375		       a5 fe		      lda	y
   1740  4377		       85 46		      sta	temp5
   1741  4379
   1742  4379		       a9 40		      lda	#(g16x16_4color_mode|%01000000)
   1743  437b		       85 47		      sta	temp6
   1744  437d
   1745  437d		       20 f0 f2 	      jsr	plotsprite
   1746  4380				   .skip23then
   1747  4380				   .skipL0168
   1748  4380				   .L0169		;;  if wrap  =  1 then plotsprite p1 7 x y 0
   1749  4380
   1750  4380		       ad 45 01 	      LDA	wrap
   1751  4383		       c9 01		      CMP	#1
   1752  4385		       d0 1b		      BNE	.skipL0169
   1753  4387				   .condpart25
   1754  4387		       a9 50		      lda	#<p1
   1755  4389		       85 42		      sta	temp1
   1756  438b
   1757  438b		       a9 e0		      lda	#>p1
   1758  438d		       85 43		      sta	temp2
   1759  438f
   1760  438f		       a9 fe		      lda	#(224|p1_width_twoscompliment)
   1761  4391		       85 44		      sta	temp3
   1762  4393
   1763  4393		       a5 fd		      lda	x
   1764  4395		       85 45		      sta	temp4
   1765  4397
   1766  4397		       a5 fe		      lda	y
   1767  4399		       85 46		      sta	temp5
   1768  439b
   1769  439b		       a9 40		      lda	#(p1_mode|%01000000)
   1770  439d		       85 47		      sta	temp6
   1771  439f
   1772  439f		       20 f0 f2 	      jsr	plotsprite
   1773  43a2				   .skipL0169
   1774  43a2				   .L0170		;;  x	=  x  +  16
   1775  43a2
   1776  43a2		       a5 fd		      LDA	x
   1777  43a4		       18		      CLC
   1778  43a5		       69 10		      ADC	#16
   1779  43a7		       85 fd		      STA	x
   1780  43a9				   .L0171		;;  if x  >  144 then x  =  0	:  wrap  =  1
   1781  43a9
   1782  43a9		       a9 90		      LDA	#144
   1783  43ab		       c5 fd		      CMP	x
   1784  43ad		       b0 09		      BCS	.skipL0171
   1785  43af				   .condpart26
   1786  43af		       a9 00		      LDA	#0
   1787  43b1		       85 fd		      STA	x
   1788  43b3		       a9 01		      LDA	#1
   1789  43b5		       8d 45 01 	      STA	wrap
   1790  43b8				   .skipL0171
   1791  43b8				   .L0172		;;  next
   1792  43b8
   1793  43b8		       a5 ef		      LDA	j
   1794  43ba		       c5 f2		      CMP	m
   1795  43bc		       e6 ef		      INC	j
   1796  43be				  -	      if	((* - .L0166forj) < 127) && ((* - .L0166forj) > -128)
   1797  43be				  -	      bcc	.L0166forj
   1798  43be					      else
   1799  43be		       b0 03		      bcs	.0skipL0166forj
   1800  43c0		       4c 0c 43 	      jmp	.L0166forj
   1801  43c3				   .0skipL0166forj
   1802  43c3					      endif
   1803  43c3				   .L0173		;;  wrap  =  0
   1804  43c3
   1805  43c3		       a9 00		      LDA	#0
   1806  43c5		       8d 45 01 	      STA	wrap
   1807  43c8				   .L0174		;;  x	=  0
   1808  43c8
   1809  43c8		       a9 00		      LDA	#0
   1810  43ca		       85 fd		      STA	x
   1811  43cc				   .L0175		;;  y	=  y  +  16
   1812  43cc
   1813  43cc		       a5 fe		      LDA	y
   1814  43ce		       18		      CLC
   1815  43cf		       69 10		      ADC	#16
   1816  43d1		       85 fe		      STA	y
   1817  43d3				   .L0176		;;  c	=  c  +  1
   1818  43d3
   1819  43d3		       a5 e8		      LDA	c
   1820  43d5		       18		      CLC
   1821  43d6		       69 01		      ADC	#1
   1822  43d8		       85 e8		      STA	c
   1823  43da				   .L0177		;;  if c  >  6 then c	=  0
   1824  43da
   1825  43da		       a9 06		      LDA	#6
   1826  43dc		       c5 e8		      CMP	c
   1827  43de		       b0 04		      BCS	.skipL0177
   1828  43e0				   .condpart27
   1829  43e0		       a9 00		      LDA	#0
   1830  43e2		       85 e8		      STA	c
   1831  43e4				   .skipL0177
   1832  43e4				   .L0178		;;  next
   1833  43e4
   1834  43e4		       a5 ee		      LDA	i
   1835  43e6		       c5 f3		      CMP	n
   1836  43e8		       e6 ee		      INC	i
   1837  43ea				  -	      if	((* - .L0165fori) < 127) && ((* - .L0165fori) > -128)
   1838  43ea				  -	      bcc	.L0165fori
   1839  43ea					      else
   1840  43ea		       b0 03		      bcs	.1skipL0165fori
   1841  43ec		       4c 08 43 	      jmp	.L0165fori
   1842  43ef				   .1skipL0165fori
   1843  43ef					      endif
   1844  43ef				   .L0179		;;  if w  >  8  &&  joy0right then w  = 0  :  m  =  m	+  1
   1845  43ef
   1846  43ef		       a9 08		      LDA	#8
   1847  43f1		       c5 fc		      CMP	w
   1848  43f3		       b0 10		      BCS	.skipL0179
   1849  43f5				   .condpart28
   1850  43f5		       2c 80 02 	      bit	SWCHA
   1851  43f8		       30 0b		      BMI	.skip28then
   1852  43fa				   .condpart29
   1853  43fa		       a9 00		      LDA	#0
   1854  43fc		       85 fc		      STA	w
   1855  43fe		       a5 f2		      LDA	m
   1856  4400		       18		      CLC
   1857  4401		       69 01		      ADC	#1
   1858  4403		       85 f2		      STA	m
   1859  4405				   .skip28then
   1860  4405				   .skipL0179
   1861  4405				   .L0180		;;  if w  >  8  &&  joy0down then w  =  0  :  n  =  n	+  1
   1862  4405
   1863  4405		       a9 08		      LDA	#8
   1864  4407		       c5 fc		      CMP	w
   1865  4409		       b0 12		      BCS	.skipL0180
   1866  440b				   .condpart30
   1867  440b		       a9 20		      lda	#$20
   1868  440d		       2c 80 02 	      bit	SWCHA
   1869  4410		       d0 0b		      BNE	.skip30then
   1870  4412				   .condpart31
   1871  4412		       a9 00		      LDA	#0
   1872  4414		       85 fc		      STA	w
   1873  4416		       a5 f3		      LDA	n
   1874  4418		       18		      CLC
   1875  4419		       69 01		      ADC	#1
   1876  441b		       85 f3		      STA	n
   1877  441d				   .skip30then
   1878  441d				   .skipL0180
   1879  441d				   .L0181		;;  if w  >  8  &&  joy0left then w  = 0  :  m  =  m  -  1
   1880  441d
   1881  441d		       a9 08		      LDA	#8
   1882  441f		       c5 fc		      CMP	w
   1883  4421		       b0 10		      BCS	.skipL0181
   1884  4423				   .condpart32
   1885  4423		       2c 80 02 	      bit	SWCHA
   1886  4426		       70 0b		      BVS	.skip32then
   1887  4428				   .condpart33
   1888  4428		       a9 00		      LDA	#0
   1889  442a		       85 fc		      STA	w
   1890  442c		       a5 f2		      LDA	m
   1891  442e		       38		      SEC
   1892  442f		       e9 01		      SBC	#1
   1893  4431		       85 f2		      STA	m
   1894  4433				   .skip32then
   1895  4433				   .skipL0181
   1896  4433				   .L0182		;;  if w  >  8  &&  joy0up then w  =  0  :  n	=  n  -  1
   1897  4433
   1898  4433		       a9 08		      LDA	#8
   1899  4435		       c5 fc		      CMP	w
   1900  4437		       b0 12		      BCS	.skipL0182
   1901  4439				   .condpart34
   1902  4439		       a9 10		      lda	#$10
   1903  443b		       2c 80 02 	      bit	SWCHA
   1904  443e		       d0 0b		      BNE	.skip34then
   1905  4440				   .condpart35
   1906  4440		       a9 00		      LDA	#0
   1907  4442		       85 fc		      STA	w
   1908  4444		       a5 f3		      LDA	n
   1909  4446		       38		      SEC
   1910  4447		       e9 01		      SBC	#1
   1911  4449		       85 f3		      STA	n
   1912  444b				   .skip34then
   1913  444b				   .skipL0182
   1914  444b				   .L0183		;;  if n  >  24 then n  =  0
   1915  444b
   1916  444b		       a9 18		      LDA	#24
   1917  444d		       c5 f3		      CMP	n
   1918  444f		       b0 04		      BCS	.skipL0183
   1919  4451				   .condpart36
   1920  4451		       a9 00		      LDA	#0
   1921  4453		       85 f3		      STA	n
   1922  4455				   .skipL0183
   1923  4455				   .L0184		;;  if m  >  40 then m  =  0
   1924  4455
   1925  4455		       a9 28		      LDA	#40
   1926  4457		       c5 f2		      CMP	m
   1927  4459		       b0 04		      BCS	.skipL0184
   1928  445b				   .condpart37
   1929  445b		       a9 00		      LDA	#0
   1930  445d		       85 f2		      STA	m
   1931  445f				   .skipL0184
   1932  445f				   .L0185		;;  if an  =  1 then f  =  f  +  1
   1933  445f
   1934  445f		       ad 43 01 	      LDA	an
   1935  4462		       c9 01		      CMP	#1
   1936  4464		       d0 07		      BNE	.skipL0185
   1937  4466				   .condpart38
   1938  4466		       a5 eb		      LDA	f
   1939  4468		       18		      CLC
   1940  4469		       69 01		      ADC	#1
   1941  446b		       85 eb		      STA	f
   1942  446d				   .skipL0185
   1943  446d				   .L0186		;;  if an  =  1  &&  f  >  7 then f  =  0
   1944  446d
   1945  446d		       ad 43 01 	      LDA	an
   1946  4470		       c9 01		      CMP	#1
   1947  4472		       d0 0a		      BNE	.skipL0186
   1948  4474				   .condpart39
   1949  4474		       a9 07		      LDA	#7
   1950  4476		       c5 eb		      CMP	f
   1951  4478		       b0 04		      BCS	.skip39then
   1952  447a				   .condpart40
   1953  447a		       a9 00		      LDA	#0
   1954  447c		       85 eb		      STA	f
   1955  447e				   .skip39then
   1956  447e				   .skipL0186
   1957  447e				   .
   1958  447e							;; 
   1959  447e
   1960  447e				   .L0187		;;  rem plotchars 'joystick to draw fire to next' 7 10 23 1
   1961  447e
   1962  447e				   .L0188		;;  r	=  n  +  1
   1963  447e
   1964  447e		       a5 f3		      LDA	n
   1965  4480		       18		      CLC
   1966  4481		       69 01		      ADC	#1
   1967  4483		       85 f7		      STA	r
   1968  4485				   .L0189		;;  s	=  m  +  1
   1969  4485
   1970  4485		       a5 f2		      LDA	m
   1971  4487		       18		      CLC
   1972  4488		       69 01		      ADC	#1
   1973  448a		       85 f8		      STA	s
   1974  448c				   .
   1975  448c							;; 
   1976  448c
   1977  448c				   .L0190		;;  plotvalue font 4 s 2 8 11
   1978  448c
   1979  448c		       a9 56		      lda	#<font
   1980  448e		       85 42		      sta	temp1
   1981  4490
   1982  4490		       a9 e0		      lda	#>font
   1983  4492		       85 43		      sta	temp2
   1984  4494
   1985  4494		       ad 06 21 	      lda	charactermode
   1986  4497		       85 4a		      sta	temp9
   1987  4499		       a9 60		      lda	#(font_mode | %01100000)
   1988  449b		       8d 06 21 	      sta	charactermode
   1989  449e		       a9 1e		      lda	#30	; width in two's complement
   1990  44a0		       09 80		      ora	#128	; palette left shifted 5 bits
   1991  44a2		       85 44		      sta	temp3
   1992  44a4		       a9 08		      lda	#8
   1993  44a6		       85 45		      sta	temp4
   1994  44a8
   1995  44a8		       a9 0b		      lda	#11
   1996  44aa		       85 46		      sta	temp5
   1997  44ac
   1998  44ac		       a9 02		      lda	#2
   1999  44ae		       85 47		      sta	temp6
   2000  44b0
   2001  44b0		       a9 f8		      lda	#<s
   2002  44b2		       85 48		      sta	temp7
   2003  44b4
   2004  44b4		       a9 00		      lda	#>s
   2005  44b6		       85 49		      sta	temp8
   2006  44b8
   2007  44b8		       20 1d f4 	      jsr	plotvalue
   2008  44b8		       00 01	   USED_PLOTVALUE =	1
   2009  44bb		       a5 4a		      lda	temp9
   2010  44bd		       8d 06 21 	      sta	charactermode
   2011  44c0				   .L0191		;;  plotvalue font 4 r 2 24 11
   2012  44c0
   2013  44c0		       a9 56		      lda	#<font
   2014  44c2		       85 42		      sta	temp1
   2015  44c4
   2016  44c4		       a9 e0		      lda	#>font
   2017  44c6		       85 43		      sta	temp2
   2018  44c8
   2019  44c8		       ad 06 21 	      lda	charactermode
   2020  44cb		       85 4a		      sta	temp9
   2021  44cd		       a9 60		      lda	#(font_mode | %01100000)
   2022  44cf		       8d 06 21 	      sta	charactermode
   2023  44d2		       a9 1e		      lda	#30	; width in two's complement
   2024  44d4		       09 80		      ora	#128	; palette left shifted 5 bits
   2025  44d6		       85 44		      sta	temp3
   2026  44d8		       a9 18		      lda	#24
   2027  44da		       85 45		      sta	temp4
   2028  44dc
   2029  44dc		       a9 0b		      lda	#11
   2030  44de		       85 46		      sta	temp5
   2031  44e0
   2032  44e0		       a9 02		      lda	#2
   2033  44e2		       85 47		      sta	temp6
   2034  44e4
   2035  44e4		       a9 f7		      lda	#<r
   2036  44e6		       85 48		      sta	temp7
   2037  44e8
   2038  44e8		       a9 00		      lda	#>r
   2039  44ea		       85 49		      sta	temp8
   2040  44ec
   2041  44ec		       20 1d f4 	      jsr	plotvalue
   2042  44ec		       00 01	   USED_PLOTVALUE =	1
   2043  44ef		       a5 4a		      lda	temp9
   2044  44f1		       8d 06 21 	      sta	charactermode
   2045  44f4				   .L0192		;;  plotvalue font 4 z 2 40 11
   2046  44f4
   2047  44f4		       a9 56		      lda	#<font
   2048  44f6		       85 42		      sta	temp1
   2049  44f8
   2050  44f8		       a9 e0		      lda	#>font
   2051  44fa		       85 43		      sta	temp2
   2052  44fc
   2053  44fc		       ad 06 21 	      lda	charactermode
   2054  44ff		       85 4a		      sta	temp9
   2055  4501		       a9 60		      lda	#(font_mode | %01100000)
   2056  4503		       8d 06 21 	      sta	charactermode
   2057  4506		       a9 1e		      lda	#30	; width in two's complement
   2058  4508		       09 80		      ora	#128	; palette left shifted 5 bits
   2059  450a		       85 44		      sta	temp3
   2060  450c		       a9 28		      lda	#40
   2061  450e		       85 45		      sta	temp4
   2062  4510
   2063  4510		       a9 0b		      lda	#11
   2064  4512		       85 46		      sta	temp5
   2065  4514
   2066  4514		       a9 02		      lda	#2
   2067  4516		       85 47		      sta	temp6
   2068  4518
   2069  4518		       a9 ff		      lda	#<z
   2070  451a		       85 48		      sta	temp7
   2071  451c
   2072  451c		       a9 00		      lda	#>z
   2073  451e		       85 49		      sta	temp8
   2074  4520
   2075  4520		       20 1d f4 	      jsr	plotvalue
   2076  4520		       00 01	   USED_PLOTVALUE =	1
   2077  4523		       a5 4a		      lda	temp9
   2078  4525		       8d 06 21 	      sta	charactermode
   2079  4528				   .L0193		;;  plotvalue font 4 bg 2 56 11
   2080  4528
   2081  4528		       a9 56		      lda	#<font
   2082  452a		       85 42		      sta	temp1
   2083  452c
   2084  452c		       a9 e0		      lda	#>font
   2085  452e		       85 43		      sta	temp2
   2086  4530
   2087  4530		       ad 06 21 	      lda	charactermode
   2088  4533		       85 4a		      sta	temp9
   2089  4535		       a9 60		      lda	#(font_mode | %01100000)
   2090  4537		       8d 06 21 	      sta	charactermode
   2091  453a		       a9 1e		      lda	#30	; width in two's complement
   2092  453c		       09 80		      ora	#128	; palette left shifted 5 bits
   2093  453e		       85 44		      sta	temp3
   2094  4540		       a9 38		      lda	#56
   2095  4542		       85 45		      sta	temp4
   2096  4544
   2097  4544		       a9 0b		      lda	#11
   2098  4546		       85 46		      sta	temp5
   2099  4548
   2100  4548		       a9 02		      lda	#2
   2101  454a		       85 47		      sta	temp6
   2102  454c
   2103  454c		       a9 41		      lda	#<bg
   2104  454e		       85 48		      sta	temp7
   2105  4550
   2106  4550		       a9 01		      lda	#>bg
   2107  4552		       85 49		      sta	temp8
   2108  4554
   2109  4554		       20 1d f4 	      jsr	plotvalue
   2110  4554		       00 01	   USED_PLOTVALUE =	1
   2111  4557		       a5 4a		      lda	temp9
   2112  4559		       8d 06 21 	      sta	charactermode
   2113  455c				   .L0194		;;  plotvalue font 4 an 2 72 11
   2114  455c
   2115  455c		       a9 56		      lda	#<font
   2116  455e		       85 42		      sta	temp1
   2117  4560
   2118  4560		       a9 e0		      lda	#>font
   2119  4562		       85 43		      sta	temp2
   2120  4564
   2121  4564		       ad 06 21 	      lda	charactermode
   2122  4567		       85 4a		      sta	temp9
   2123  4569		       a9 60		      lda	#(font_mode | %01100000)
   2124  456b		       8d 06 21 	      sta	charactermode
   2125  456e		       a9 1e		      lda	#30	; width in two's complement
   2126  4570		       09 80		      ora	#128	; palette left shifted 5 bits
   2127  4572		       85 44		      sta	temp3
   2128  4574		       a9 48		      lda	#72
   2129  4576		       85 45		      sta	temp4
   2130  4578
   2131  4578		       a9 0b		      lda	#11
   2132  457a		       85 46		      sta	temp5
   2133  457c
   2134  457c		       a9 02		      lda	#2
   2135  457e		       85 47		      sta	temp6
   2136  4580
   2137  4580		       a9 43		      lda	#<an
   2138  4582		       85 48		      sta	temp7
   2139  4584
   2140  4584		       a9 01		      lda	#>an
   2141  4586		       85 49		      sta	temp8
   2142  4588
   2143  4588		       20 1d f4 	      jsr	plotvalue
   2144  4588		       00 01	   USED_PLOTVALUE =	1
   2145  458b		       a5 4a		      lda	temp9
   2146  458d		       8d 06 21 	      sta	charactermode
   2147  4590				   .L0195		;;  plotvalue font 4 db 2 88 11
   2148  4590
   2149  4590		       a9 56		      lda	#<font
   2150  4592		       85 42		      sta	temp1
   2151  4594
   2152  4594		       a9 e0		      lda	#>font
   2153  4596		       85 43		      sta	temp2
   2154  4598
   2155  4598		       ad 06 21 	      lda	charactermode
   2156  459b		       85 4a		      sta	temp9
   2157  459d		       a9 60		      lda	#(font_mode | %01100000)
   2158  459f		       8d 06 21 	      sta	charactermode
   2159  45a2		       a9 1e		      lda	#30	; width in two's complement
   2160  45a4		       09 80		      ora	#128	; palette left shifted 5 bits
   2161  45a6		       85 44		      sta	temp3
   2162  45a8		       a9 58		      lda	#88
   2163  45aa		       85 45		      sta	temp4
   2164  45ac
   2165  45ac		       a9 0b		      lda	#11
   2166  45ae		       85 46		      sta	temp5
   2167  45b0
   2168  45b0		       a9 02		      lda	#2
   2169  45b2		       85 47		      sta	temp6
   2170  45b4
   2171  45b4		       a9 42		      lda	#<db
   2172  45b6		       85 48		      sta	temp7
   2173  45b8
   2174  45b8		       a9 01		      lda	#>db
   2175  45ba		       85 49		      sta	temp8
   2176  45bc
   2177  45bc		       20 1d f4 	      jsr	plotvalue
   2178  45bc		       00 01	   USED_PLOTVALUE =	1
   2179  45bf		       a5 4a		      lda	temp9
   2180  45c1		       8d 06 21 	      sta	charactermode
   2181  45c4				   .
   2182  45c4							;; 
   2183  45c4
   2184  45c4				   .L0196		;;  if db then doublebuffer flip
   2185  45c4
   2186  45c4		       ad 42 01 	      LDA	db
   2187  45c7		       f0 03		      BEQ	.skipL0196
   2188  45c9				   .condpart41
   2189  45c9		       20 d9 f5 	      jsr	flipdisplaybuffer
   2190  45cc				   .skipL0196
   2191  45cc				   .L0197		;;  if !db then drawscreen
   2192  45cc
   2193  45cc		       ad 42 01 	      LDA	db
   2194  45cf		       d0 03		      BNE	.skipL0197
   2195  45d1				   .condpart42
   2196  45d1		       20 cb f0 	      jsr	drawscreen
   2197  45d4				   .skipL0197
   2198  45d4				   .L0198		;;  z	=  0
   2199  45d4
   2200  45d4		       a9 00		      LDA	#0
   2201  45d6		       85 ff		      STA	z
   2202  45d8				   .L0199		;;  return
   2203  45d8
   2204  45d8		       60		      RTS
   2205  45d9				   .
   2206  45d9							;; 
   2207  45d9
   2208  45d9				   .L0200		;;  rem draw sprites with arrow no bg
   2209  45d9
   2210  45d9				   .
   2211  45d9							;; 
   2212  45d9
   2213  45d9				   .
   2214  45d9							;; 
   2215  45d9
   2216  45d9				   .
   2217  45d9							;; 
   2218  45d9
   2219  45d9				   .
   2220  45d9							;; 
   2221  45d9
   2222  45d9				   .
   2223  45d9							;; 
   2224  45d9
   2225  45d9				   .
   2226  45d9							;; 
   2227  45d9
   2228  45d9				   .
   2229  45d9							;; 
   2230  45d9
   2231  45d9				   .
   2232  45d9							;; 
   2233  45d9
   2234  45d9				   .
   2235  45d9							;; 
   2236  45d9
   2237  45d9				   .
   2238  45d9							;; 
   2239  45d9
   2240  45d9				   .
   2241  45d9							;; 
   2242  45d9
   2243  45d9				   .
   2244  45d9							;; 
   2245  45d9
   2246  45d9				   .
   2247  45d9							;; 
   2248  45d9
   2249  45d9				   .
   2250  45d9							;; 
   2251  45d9
   2252  45d9				   .
   2253  45d9							;; 
   2254  45d9
   2255  45d9				   .
   2256  45d9							;; 
   2257  45d9
   2258  45d9				   .
   2259  45d9							;; 
   2260  45d9
   2261  45d9				   .
   2262  45d9							;; 
   2263  45d9
   2264  45d9				   .
   2265  45d9							;; 
   2266  45d9
   2267  45d9				   .
   2268  45d9							;; 
   2269  45d9
   2270  45d9				   .
   2271  45d9							;; 
   2272  45d9
   2273  45d9				   .
   2274  45d9							;; 
   2275  45d9
   2276  45d9				   .
   2277  45d9							;; 
   2278  45d9
   2279  45d9				   .
   2280  45d9							;; 
   2281  45d9
   2282  45d9				   .
   2283  45d9							;; 
   2284  45d9
   2285  45d9				   .
   2286  45d9							;; 
   2287  45d9
   2288  45d9				   .
   2289  45d9							;; 
   2290  45d9
   2291  45d9				   .
   2292  45d9							;; 
   2293  45d9
   2294  45d9				   .
   2295  45d9							;; 
   2296  45d9
   2297  45d9				   .
   2298  45d9							;; 
   2299  45d9
   2300  45d9				   .
   2301  45d9							;; 
   2302  45d9
   2303  45d9				   .
   2304  45d9							;; 
   2305  45d9
   2306  45d9				   .
   2307  45d9							;; 
   2308  45d9
   2309  45d9				   .
   2310  45d9							;; 
   2311  45d9
   2312  45d9				   .
   2313  45d9							;; 
   2314  45d9
   2315  45d9				   .
   2316  45d9							;; 
   2317  45d9
   2318  45d9				   .
   2319  45d9							;; 
   2320  45d9
   2321  45d9				   .
   2322  45d9							;; 
   2323  45d9
   2324  45d9				   .
   2325  45d9							;; 
   2326  45d9
   2327  45d9				   .
   2328  45d9							;; 
   2329  45d9
   2330  45d9				   .
   2331  45d9							;; 
   2332  45d9
   2333  45d9				   .
   2334  45d9							;; 
   2335  45d9
   2336  45d9				   .
   2337  45d9							;; 
   2338  45d9
   2339  45d9				   .
   2340  45d9							;; 
   2341  45d9
   2342  45d9				   .
   2343  45d9							;; 
   2344  45d9
   2345  45d9				   .
   2346  45d9							;; 
   2347  45d9
   2348  45d9				   .
   2349  45d9							;; 
   2350  45d9
   2351  45d9				   .
   2352  45d9							;; 
   2353  45d9
   2354  45d9				   .
   2355  45d9							;; 
   2356  45d9
   2357  45d9				   .
   2358  45d9							;; 
   2359  45d9
   2360  45d9				   .
   2361  45d9							;; 
   2362  45d9
   2363  45d9				   .
   2364  45d9							;; 
   2365  45d9
   2366  45d9				   .
   2367  45d9							;; 
   2368  45d9
   2369  45d9				   .
   2370  45d9							;; 
   2371  45d9
   2372  45d9				   .
   2373  45d9							;; 
   2374  45d9
   2375  45d9				   .
   2376  45d9							;; 
   2377  45d9
   2378  45d9				   .
   2379  45d9							;; 
   2380  45d9
   2381  45d9				   .
   2382  45d9							;; 
   2383  45d9
   2384  45d9				   .
   2385  45d9							;; 
   2386  45d9
   2387  45d9				   .
   2388  45d9							;; 
   2389  45d9
   2390  45d9				   .
   2391  45d9							;; 
   2392  45d9
   2393  45d9				   .
   2394  45d9							;; 
   2395  45d9
   2396  45d9				   .
   2397  45d9							;; 
   2398  45d9
   2399  45d9				   .
   2400  45d9							;; 
   2401  45d9
   2402  45d9				   .
   2403  45d9							;; 
   2404  45d9
   2405  45d9				   .
   2406  45d9							;; 
   2407  45d9
   2408  45d9				   .
   2409  45d9							;; 
   2410  45d9
   2411  45d9				   .
   2412  45d9							;; 
   2413  45d9
   2414  45d9				   .
   2415  45d9							;; 
   2416  45d9
   2417  45d9				   .
   2418  45d9							;; 
   2419  45d9
   2420  45d9				   .
   2421  45d9							;; 
   2422  45d9
   2423  45d9				   .
   2424  45d9							;; 
   2425  45d9
   2426  45d9				   .
   2427  45d9							;; 
   2428  45d9
   2429  45d9				   .
   2430  45d9							;; 
   2431  45d9
   2432  45d9				   .
   2433  45d9							;; 
   2434  45d9
   2435  45d9				   .
   2436  45d9							;; 
   2437  45d9
   2438  45d9				   .
   2439  45d9							;; 
   2440  45d9
   2441  45d9				   .drawZoneBG
   2442  45d9							;; drawZoneBG
   2443  45d9
   2444  45d9				   .L0201		;;  x	=  0
   2445  45d9
   2446  45d9		       a9 00		      LDA	#0
   2447  45db		       85 fd		      STA	x
   2448  45dd				   .L0202		;;  y	=  0
   2449  45dd
   2450  45dd		       a9 00		      LDA	#0
   2451  45df		       85 fe		      STA	y
   2452  45e1				   .L0203		;;  for j  =  0 to 10
   2453  45e1
   2454  45e1		       a9 00		      LDA	#0
   2455  45e3		       85 ef		      STA	j
   2456  45e5				   .L0203forj
   2457  45e5				   .L0204		;;  for i  =  0 to 1
   2458  45e5
   2459  45e5		       a9 00		      LDA	#0
   2460  45e7		       85 ee		      STA	i
   2461  45e9				   .L0204fori
   2462  45e9				   .L0205		;;  plotsprite zonebg80x16_16 7 x y 0
   2463  45e9
   2464  45e9		       a9 20		      lda	#<zonebg80x16_16
   2465  45eb		       85 42		      sta	temp1
   2466  45ed
   2467  45ed		       a9 e0		      lda	#>zonebg80x16_16
   2468  45ef		       85 43		      sta	temp2
   2469  45f1
   2470  45f1		       a9 ec		      lda	#(224|zonebg80x16_16_width_twoscompliment)
   2471  45f3		       85 44		      sta	temp3
   2472  45f5
   2473  45f5		       a5 fd		      lda	x
   2474  45f7		       85 45		      sta	temp4
   2475  45f9
   2476  45f9		       a5 fe		      lda	y
   2477  45fb		       85 46		      sta	temp5
   2478  45fd
   2479  45fd		       a9 40		      lda	#(zonebg80x16_16_mode|%01000000)
   2480  45ff		       85 47		      sta	temp6
   2481  4601
   2482  4601		       20 f0 f2 	      jsr	plotsprite
   2483  4604				   .L0206		;;  x	=  x  +  80
   2484  4604
   2485  4604		       a5 fd		      LDA	x
   2486  4606		       18		      CLC
   2487  4607		       69 50		      ADC	#80
   2488  4609		       85 fd		      STA	x
   2489  460b				   .L0207		;;  next
   2490  460b
   2491  460b		       a5 ee		      LDA	i
   2492  460d		       c9 01		      CMP	#1
   2493  460f		       e6 ee		      INC	i
   2494  4611					      if	((* - .L0204fori) < 127) && ((* - .L0204fori) > -128)
   2495  4611		       90 d6		      bcc	.L0204fori
   2496  4613				  -	      else
   2497  4613				  -	      bcs	.2skipL0204fori
   2498  4613				  -	      jmp	.L0204fori
   2499  4613				  -.2skipL0204fori
   2500  4613					      endif
   2501  4613				   .L0208		;;  x	=  0
   2502  4613
   2503  4613		       a9 00		      LDA	#0
   2504  4615		       85 fd		      STA	x
   2505  4617				   .L0209		;;  y	=  y  +  16
   2506  4617
   2507  4617		       a5 fe		      LDA	y
   2508  4619		       18		      CLC
   2509  461a		       69 10		      ADC	#16
   2510  461c		       85 fe		      STA	y
   2511  461e				   .L0210		;;  next
   2512  461e
   2513  461e		       a5 ef		      LDA	j
   2514  4620		       c9 0a		      CMP	#10
   2515  4622		       e6 ef		      INC	j
   2516  4624					      if	((* - .L0203forj) < 127) && ((* - .L0203forj) > -128)
   2517  4624		       90 bf		      bcc	.L0203forj
   2518  4626				  -	      else
   2519  4626				  -	      bcs	.3skipL0203forj
   2520  4626				  -	      jmp	.L0203forj
   2521  4626				  -.3skipL0203forj
   2522  4626					      endif
   2523  4626				   .L0211		;;  savescreen
   2524  4626
   2525  4626		       20 b3 f0 	      jsr	savescreen
   2526  4629				   .L0212		;;  return
   2527  4629
   2528  4629		       60		      RTS
   2529  462a				   .
   2530  462a							;; 
   2531  462a
   2532  462a				   .topscreenroutine
   2533  462a							;; topscreenroutine
   2534  462a
   2535  462a				   .L0213		;;  z	=  z  +  1
   2536  462a
   2537  462a		       a5 ff		      LDA	z
   2538  462c		       18		      CLC
   2539  462d		       69 01		      ADC	#1
   2540  462f		       85 ff		      STA	z
   2541  4631				   .L0214		;;  return
   2542  4631		       60		      RTS
   2543  4631				   DMAHOLEEND0 SET	.
   2544  4632				   gameend
   2545  4632				   DMAHOLEEND0 SET	.
   39374 bytes of ROM space left in the main area.
   2546  4632					      echo	" ",[($E000 - gameend)]d , "bytes of ROM space left in the main area."
   2547  4632				  -	      if	($E000 - gameend) < 0
   2548  4632				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   2549  4632					      endif
   2550  4632				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   2551  4632				  -	      .byte	0
   2552  4632					      endif
   2553  4632				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   2554  4632
   2555  e000					      ORG	$E000,0	; *************
   2556  e000
   2557  e000		       e0 00	   g16x16_4color =	$E000
   2558  e000
   2559  e000				   g16x16_4color
   2560  e000		       aa aa aa aa	      HEX	aaaaaaaa
   2561  e000		       e0 04	   g16x16_4color2 =	$E004
   2562  e004
   2563  e004				   g16x16_4color2
   2564  e004		       aa aa aa aa	      HEX	aaaaaaaa
   2565  e004		       e0 08	   g16x16_4color3 =	$E008
   2566  e008
   2567  e008				   g16x16_4color3
   2568  e008		       ff ff ff ff	      HEX	ffffffff
   2569  e008		       e0 0c	   g16x16_4color4 =	$E00C
   2570  e00c
   2571  e00c				   g16x16_4color4
   2572  e00c		       ff ff ff ff	      HEX	ffffffff
   2573  e00c		       e0 10	   g16x16_4color5 =	$E010
   2574  e010
   2575  e010				   g16x16_4color5
   2576  e010		       55 55 55 55	      HEX	55555555
   2577  e010		       e0 14	   g16x16_4color6 =	$E014
   2578  e014
   2579  e014				   g16x16_4color6
   2580  e014		       55 55 55 55	      HEX	55555555
   2581  e014		       e0 18	   g16x16_4color7 =	$E018
   2582  e018
   2583  e018				   g16x16_4color7
   2584  e018		       55 55 55 55	      HEX	55555555
   2585  e018		       e0 1c	   g16x16_4color8 =	$E01C
   2586  e01c
   2587  e01c				   g16x16_4color8
   2588  e01c		       00 00 00 00	      HEX	00000000
   2589  e01c		       e0 20	   zonebg80x16_16 =	$E020
   2590  e020
   2591  e020				   zonebg80x16_16
   2592  e020		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2593  e020		       e0 34	   ex1	      =	$E034
   2594  e034
   2595  e034				   ex1
   2596  e034		       00 00 00 00	      HEX	00000000
   2597  e034		       e0 38	   ex2	      =	$E038
   2598  e038
   2599  e038				   ex2
   2600  e038		       00 00 00 00	      HEX	00000000
   2601  e038		       e0 3c	   ex3	      =	$E03C
   2602  e03c
   2603  e03c				   ex3
   2604  e03c		       00 00 00 00	      HEX	00000000
   2605  e03c		       e0 40	   ex4	      =	$E040
   2606  e040
   2607  e040				   ex4
   2608  e040		       00 41 50 00	      HEX	00415000
   2609  e040		       e0 44	   ex5	      =	$E044
   2610  e044
   2611  e044				   ex5
   2612  e044		       31 41 51 00	      HEX	31415100
   2613  e044		       e0 48	   ex6	      =	$E048
   2614  e048
   2615  e048				   ex6
   2616  e048		       00 15 15 00	      HEX	00151500
   2617  e048		       e0 4c	   ex7	      =	$E04C
   2618  e04c
   2619  e04c				   ex7
   2620  e04c		       01 50 55 40	      HEX	01505540
   2621  e04c		       e0 50	   p1	      =	$E050
   2622  e050
   2623  e050				   p1
   2624  e050		       00 00		      HEX	0000
   2625  e050		       e0 52	   blank      =	$E052
   2626  e052
   2627  e052				   blank
   2628  e052		       00 00 00 00	      HEX	00000000
   2629  e052		       e0 56	   font       =	$E056
   2630  e056
   2631  e056				   font
   2632  e056		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2633  e076		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2634  e08b
   2635  e100					      ORG	$E100,0	; *************
   2636  e100
   2637  e100							;g16x16_4color
   2638  e100		       aa aa aa aa	      HEX	aaaaaaaa
   2639  e104							;g16x16_4color2
   2640  e104		       ff ff ff ff	      HEX	ffffffff
   2641  e108							;g16x16_4color3
   2642  e108		       ff ff ff ff	      HEX	ffffffff
   2643  e10c							;g16x16_4color4
   2644  e10c		       55 55 55 55	      HEX	55555555
   2645  e110							;g16x16_4color5
   2646  e110		       55 55 55 55	      HEX	55555555
   2647  e114							;g16x16_4color6
   2648  e114		       00 00 00 00	      HEX	00000000
   2649  e118							;g16x16_4color7
   2650  e118		       55 55 55 55	      HEX	55555555
   2651  e11c							;g16x16_4color8
   2652  e11c		       aa aa aa aa	      HEX	aaaaaaaa
   2653  e120							;zonebg80x16_16
   2654  e120		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2655  e134							;ex1
   2656  e134		       00 00 00 00	      HEX	00000000
   2657  e138							;ex2
   2658  e138		       00 03 00 30	      HEX	00030030
   2659  e13c							;ex3
   2660  e13c		       30 15 40 0c	      HEX	3015400c
   2661  e140							;ex4
   2662  e140		       00 51 25 90	      HEX	00512590
   2663  e144							;ex5
   2664  e144		       01 55 35 53	      HEX	01553553
   2665  e148							;ex6
   2666  e148		       05 65 56 40	      HEX	05655640
   2667  e14c							;ex7
   2668  e14c		       04 00 00 00	      HEX	04000000
   2669  e150							;p1
   2670  e150		       00 00		      HEX	0000
   2671  e152							;blank
   2672  e152		       00 00 00 00	      HEX	00000000
   2673  e156							;font
   2674  e156		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2675  e176		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2676  e18b
   2677  e200					      ORG	$E200,0	; *************
   2678  e200
   2679  e200							;g16x16_4color
   2680  e200		       ff ff ff ff	      HEX	ffffffff
   2681  e204							;g16x16_4color2
   2682  e204		       ff ff ff ff	      HEX	ffffffff
   2683  e208							;g16x16_4color3
   2684  e208		       55 55 55 55	      HEX	55555555
   2685  e20c							;g16x16_4color4
   2686  e20c		       55 55 55 55	      HEX	55555555
   2687  e210							;g16x16_4color5
   2688  e210		       00 00 00 00	      HEX	00000000
   2689  e214							;g16x16_4color6
   2690  e214		       00 00 00 00	      HEX	00000000
   2691  e218							;g16x16_4color7
   2692  e218		       ff ff ff ff	      HEX	ffffffff
   2693  e21c							;g16x16_4color8
   2694  e21c		       aa aa aa aa	      HEX	aaaaaaaa
   2695  e220							;zonebg80x16_16
   2696  e220		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2697  e234							;ex1
   2698  e234		       00 30 00 00	      HEX	00300000
   2699  e238							;ex2
   2700  e238		       0c 14 14 00	      HEX	0c141400
   2701  e23c							;ex3
   2702  e23c		       00 2b 91 00	      HEX	002b9100
   2703  e240							;ex4
   2704  e240		       05 aa 3a 60	      HEX	05aa3a60
   2705  e244							;ex5
   2706  e244		       15 9a a9 10	      HEX	159aa910
   2707  e248							;ex6
   2708  e248		       11 40 14 54	      HEX	11401454
   2709  e24c							;ex7
   2710  e24c		       10 00 00 04	      HEX	10000004
   2711  e250							;p1
   2712  e250		       00 00		      HEX	0000
   2713  e252							;blank
   2714  e252		       00 00 00 00	      HEX	00000000
   2715  e256							;font
   2716  e256		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2717  e276		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2718  e28b
   2719  e300					      ORG	$E300,0	; *************
   2720  e300
   2721  e300							;g16x16_4color
   2722  e300		       ff ff ff ff	      HEX	ffffffff
   2723  e304							;g16x16_4color2
   2724  e304		       55 55 55 55	      HEX	55555555
   2725  e308							;g16x16_4color3
   2726  e308		       55 55 55 55	      HEX	55555555
   2727  e30c							;g16x16_4color4
   2728  e30c		       00 00 00 00	      HEX	00000000
   2729  e310							;g16x16_4color5
   2730  e310		       00 00 00 00	      HEX	00000000
   2731  e314							;g16x16_4color6
   2732  e314		       aa aa aa aa	      HEX	aaaaaaaa
   2733  e318							;g16x16_4color7
   2734  e318		       ff ff ff ff	      HEX	ffffffff
   2735  e31c							;g16x16_4color8
   2736  e31c		       ff ff ff ff	      HEX	ffffffff
   2737  e320							;zonebg80x16_16
   2738  e320		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2739  e334							;ex1
   2740  e334		       00 01 43 00	      HEX	00014300
   2741  e338							;ex2
   2742  e338		       00 29 69 00	      HEX	00296900
   2743  e33c							;ex3
   2744  e33c		       01 85 a2 40	      HEX	0185a240
   2745  e340							;ex4
   2746  e340		       19 12 a4 94	      HEX	1912a494
   2747  e344							;ex5
   2748  e344		       52 79 1a d4	      HEX	52791ad4
   2749  e348							;ex6
   2750  e348		       15 00 00 10	      HEX	15000010
   2751  e34c							;ex7
   2752  e34c		       00 00 00 01	      HEX	00000001
   2753  e350							;p1
   2754  e350		       00 00		      HEX	0000
   2755  e352							;blank
   2756  e352		       00 00 00 00	      HEX	00000000
   2757  e356							;font
   2758  e356		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2759  e376		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2760  e38b
   2761  e400					      ORG	$E400,0	; *************
   2762  e400
   2763  e400							;g16x16_4color
   2764  e400		       55 55 55 55	      HEX	55555555
   2765  e404							;g16x16_4color2
   2766  e404		       55 55 55 55	      HEX	55555555
   2767  e408							;g16x16_4color3
   2768  e408		       00 00 00 00	      HEX	00000000
   2769  e40c							;g16x16_4color4
   2770  e40c		       00 00 00 00	      HEX	00000000
   2771  e410							;g16x16_4color5
   2772  e410		       aa aa aa aa	      HEX	aaaaaaaa
   2773  e414							;g16x16_4color6
   2774  e414		       aa aa aa aa	      HEX	aaaaaaaa
   2775  e418							;g16x16_4color7
   2776  e418		       aa aa aa aa	      HEX	aaaaaaaa
   2777  e41c							;g16x16_4color8
   2778  e41c		       ff ff ff ff	      HEX	ffffffff
   2779  e420							;zonebg80x16_16
   2780  e420		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2781  e434							;ex1
   2782  e434		       00 01 80 00	      HEX	00018000
   2783  e438							;ex2
   2784  e438		       01 95 8a 03	      HEX	01958a03
   2785  e43c							;ex3
   2786  e43c		       04 6a 98 90	      HEX	046a9890
   2787  e440							;ex4
   2788  e440		       62 eb 4a 89	      HEX	62eb4a89
   2789  e444							;ex5
   2790  e444		       5a 94 04 a5	      HEX	5a9404a5
   2791  e448							;ex6
   2792  e448		       54 00 00 16	      HEX	54000016
   2793  e44c							;ex7
   2794  e44c		       40 00 00 01	      HEX	40000001
   2795  e450							;p1
   2796  e450		       00 00		      HEX	0000
   2797  e452							;blank
   2798  e452		       00 00 00 00	      HEX	00000000
   2799  e456							;font
   2800  e456		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2801  e476		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2802  e48b
   2803  e500					      ORG	$E500,0	; *************
   2804  e500
   2805  e500							;g16x16_4color
   2806  e500		       55 55 55 55	      HEX	55555555
   2807  e504							;g16x16_4color2
   2808  e504		       00 00 00 00	      HEX	00000000
   2809  e508							;g16x16_4color3
   2810  e508		       00 00 00 00	      HEX	00000000
   2811  e50c							;g16x16_4color4
   2812  e50c		       aa aa aa aa	      HEX	aaaaaaaa
   2813  e510							;g16x16_4color5
   2814  e510		       aa aa aa aa	      HEX	aaaaaaaa
   2815  e514							;g16x16_4color6
   2816  e514		       ff ff ff ff	      HEX	ffffffff
   2817  e518							;g16x16_4color7
   2818  e518		       aa aa aa aa	      HEX	aaaaaaaa
   2819  e51c							;g16x16_4color8
   2820  e51c		       55 55 55 55	      HEX	55555555
   2821  e520							;zonebg80x16_16
   2822  e520		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2823  e534							;ex1
   2824  e534		       00 da 24 00	      HEX	00da2400
   2825  e538							;ex2
   2826  e538		       06 46 6e 40	      HEX	06466e40
   2827  e53c							;ex3
   2828  e53c		       1a 88 69 e4	      HEX	1a8869e4
   2829  e540							;ex4
   2830  e540		       52 44 1a 6c	      HEX	52441a6c
   2831  e544							;ex5
   2832  e544		       ca 00 00 49	      HEX	ca000049
   2833  e548							;ex6
   2834  e548		       60 00 00 05	      HEX	60000005
   2835  e54c							;ex7
   2836  e54c		       40 00 00 01	      HEX	40000001
   2837  e550							;p1
   2838  e550		       00 00		      HEX	0000
   2839  e552							;blank
   2840  e552		       00 00 00 00	      HEX	00000000
   2841  e556							;font
   2842  e556		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2843  e576		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2844  e58b
   2845  e600					      ORG	$E600,0	; *************
   2846  e600
   2847  e600							;g16x16_4color
   2848  e600		       00 00 00 00	      HEX	00000000
   2849  e604							;g16x16_4color2
   2850  e604		       00 00 00 00	      HEX	00000000
   2851  e608							;g16x16_4color3
   2852  e608		       aa aa aa aa	      HEX	aaaaaaaa
   2853  e60c							;g16x16_4color4
   2854  e60c		       aa aa aa aa	      HEX	aaaaaaaa
   2855  e610							;g16x16_4color5
   2856  e610		       ff ff ff ff	      HEX	ffffffff
   2857  e614							;g16x16_4color6
   2858  e614		       ff ff ff ff	      HEX	ffffffff
   2859  e618							;g16x16_4color7
   2860  e618		       55 55 55 55	      HEX	55555555
   2861  e61c							;g16x16_4color8
   2862  e61c		       55 55 55 55	      HEX	55555555
   2863  e620							;zonebg80x16_16
   2864  e620		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2865  e634							;ex1
   2866  e634		       00 05 b9 00	      HEX	0005b900
   2867  e638							;ex2
   2868  e638		       c5 ae a1 90	      HEX	c5aea190
   2869  e63c							;ex3
   2870  e63c		       07 67 18 90	      HEX	07671890
   2871  e640							;ex4
   2872  e640		       6a 90 07 64	      HEX	6a900764
   2873  e644							;ex5
   2874  e644		       58 40 00 69	      HEX	58400069
   2875  e648							;ex6
   2876  e648		       50 00 00 04	      HEX	50000004
   2877  e64c							;ex7
   2878  e64c		       40 00 00 00	      HEX	40000000
   2879  e650							;p1
   2880  e650		       00 00		      HEX	0000
   2881  e652							;blank
   2882  e652		       00 00 00 00	      HEX	00000000
   2883  e656							;font
   2884  e656		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2885  e676		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2886  e68b
   2887  e700					      ORG	$E700,0	; *************
   2888  e700
   2889  e700							;g16x16_4color
   2890  e700		       00 00 00 00	      HEX	00000000
   2891  e704							;g16x16_4color2
   2892  e704		       aa aa aa aa	      HEX	aaaaaaaa
   2893  e708							;g16x16_4color3
   2894  e708		       aa aa aa aa	      HEX	aaaaaaaa
   2895  e70c							;g16x16_4color4
   2896  e70c		       ff ff ff ff	      HEX	ffffffff
   2897  e710							;g16x16_4color5
   2898  e710		       ff ff ff ff	      HEX	ffffffff
   2899  e714							;g16x16_4color6
   2900  e714		       55 55 55 55	      HEX	55555555
   2901  e718							;g16x16_4color7
   2902  e718		       55 55 55 55	      HEX	55555555
   2903  e71c							;g16x16_4color8
   2904  e71c		       00 00 00 00	      HEX	00000000
   2905  e720							;zonebg80x16_16
   2906  e720		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2907  e734							;ex1
   2908  e734		       00 63 44 00	      HEX	00634400
   2909  e738							;ex2
   2910  e738		       06 28 91 40	      HEX	06289140
   2911  e73c							;ex3
   2912  e73c		       18 a0 ca 10	      HEX	18a0ca10
   2913  e740							;ex4
   2914  e740		       1d 80 02 05	      HEX	1d800205
   2915  e744							;ex5
   2916  e744		       12 00 00 63	      HEX	12000063
   2917  e748							;ex6
   2918  e748		       14 00 00 01	      HEX	14000001
   2919  e74c							;ex7
   2920  e74c		       00 00 00 01	      HEX	00000001
   2921  e750							;p1
   2922  e750		       00 00		      HEX	0000
   2923  e752							;blank
   2924  e752		       00 00 00 00	      HEX	00000000
   2925  e756							;font
   2926  e756		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2927  e776		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2928  e78b
   2929  e800					      ORG	$E800,0	; *************
   2930  e800
   2931  e800							;g16x16_4color
   2932  e800		       aa aa aa aa	      HEX	aaaaaaaa
   2933  e804							;g16x16_4color2
   2934  e804		       aa aa aa aa	      HEX	aaaaaaaa
   2935  e808							;g16x16_4color3
   2936  e808		       ff ff ff ff	      HEX	ffffffff
   2937  e80c							;g16x16_4color4
   2938  e80c		       ff ff ff ff	      HEX	ffffffff
   2939  e810							;g16x16_4color5
   2940  e810		       55 55 55 55	      HEX	55555555
   2941  e814							;g16x16_4color6
   2942  e814		       55 55 55 55	      HEX	55555555
   2943  e818							;g16x16_4color7
   2944  e818		       00 00 00 00	      HEX	00000000
   2945  e81c							;g16x16_4color8
   2946  e81c		       00 00 00 00	      HEX	00000000
   2947  e820							;zonebg80x16_16
   2948  e820		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2949  e834							;ex1
   2950  e834		       00 66 b9 00	      HEX	0066b900
   2951  e838							;ex2
   2952  e838		       01 6a f9 80	      HEX	016af980
   2953  e83c							;ex3
   2954  e83c		       c5 ac 16 c4	      HEX	c5ac16c4
   2955  e840							;ex4
   2956  e840		       16 90 04 64	      HEX	16900464
   2957  e844							;ex5
   2958  e844		       5e 00 00 34	      HEX	5e000034
   2959  e848							;ex6
   2960  e848		       14 00 00 01	      HEX	14000001
   2961  e84c							;ex7
   2962  e84c		       40 00 00 00	      HEX	40000000
   2963  e850							;p1
   2964  e850		       56 00		      HEX	5600
   2965  e852							;blank
   2966  e852		       00 00 00 00	      HEX	00000000
   2967  e856							;font
   2968  e856		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2969  e876		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   2970  e88b
   2971  e900					      ORG	$E900,0	; *************
   2972  e900
   2973  e900							;g16x16_4color
   2974  e900		       aa aa aa aa	      HEX	aaaaaaaa
   2975  e904							;g16x16_4color2
   2976  e904		       ff ff ff ff	      HEX	ffffffff
   2977  e908							;g16x16_4color3
   2978  e908		       ff ff ff ff	      HEX	ffffffff
   2979  e90c							;g16x16_4color4
   2980  e90c		       55 55 55 55	      HEX	55555555
   2981  e910							;g16x16_4color5
   2982  e910		       55 55 55 55	      HEX	55555555
   2983  e914							;g16x16_4color6
   2984  e914		       00 00 00 00	      HEX	00000000
   2985  e918							;g16x16_4color7
   2986  e918		       00 00 00 00	      HEX	00000000
   2987  e91c							;g16x16_4color8
   2988  e91c		       aa aa aa aa	      HEX	aaaaaaaa
   2989  e920							;zonebg80x16_16
   2990  e920		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2991  e934							;ex1
   2992  e934		       03 19 24 00	      HEX	03192400
   2993  e938							;ex2
   2994  e938		       06 7b 69 10	      HEX	067b6910
   2995  e93c							;ex3
   2996  e93c		       04 99 6a 64	      HEX	04996a64
   2997  e940							;ex4
   2998  e940		       62 74 06 64	      HEX	62740664
   2999  e944							;ex5
   3000  e944		       19 40 00 65	      HEX	19400065
   3001  e948							;ex6
   3002  e948		       50 00 00 01	      HEX	50000001
   3003  e94c							;ex7
   3004  e94c		       40 00 00 01	      HEX	40000001
   3005  e950							;p1
   3006  e950		       14 00		      HEX	1400
   3007  e952							;blank
   3008  e952		       00 00 00 00	      HEX	00000000
   3009  e956							;font
   3010  e956		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   3011  e976		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   3012  e98b
   3013  ea00					      ORG	$EA00,0	; *************
   3014  ea00
   3015  ea00							;g16x16_4color
   3016  ea00		       ff ff ff ff	      HEX	ffffffff
   3017  ea04							;g16x16_4color2
   3018  ea04		       ff ff ff ff	      HEX	ffffffff
   3019  ea08							;g16x16_4color3
   3020  ea08		       55 55 55 55	      HEX	55555555
   3021  ea0c							;g16x16_4color4
   3022  ea0c		       55 55 55 55	      HEX	55555555
   3023  ea10							;g16x16_4color5
   3024  ea10		       00 00 00 00	      HEX	00000000
   3025  ea14							;g16x16_4color6
   3026  ea14		       00 00 00 00	      HEX	00000000
   3027  ea18							;g16x16_4color7
   3028  ea18		       ff ff ff ff	      HEX	ffffffff
   3029  ea1c							;g16x16_4color8
   3030  ea1c		       aa aa aa aa	      HEX	aaaaaaaa
   3031  ea20							;zonebg80x16_16
   3032  ea20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   3033  ea34							;ex1
   3034  ea34		       00 05 90 c0	      HEX	000590c0
   3035  ea38							;ex2
   3036  ea38		       05 96 2e 90	      HEX	05962e90
   3037  ea3c							;ex3
   3038  ea3c		       1b 8a 98 50	      HEX	1b8a9850
   3039  ea40							;ex4
   3040  ea40		       66 69 1e a5	      HEX	66691ea5
   3041  ea44							;ex5
   3042  ea44		       5a 50 00 61	      HEX	5a500061
   3043  ea48							;ex6
   3044  ea48		       54 00 00 05	      HEX	54000005
   3045  ea4c							;ex7
   3046  ea4c		       00 00 00 01	      HEX	00000001
   3047  ea50							;p1
   3048  ea50		       15 80		      HEX	1580
   3049  ea52							;blank
   3050  ea52		       00 00 00 00	      HEX	00000000
   3051  ea56							;font
   3052  ea56		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   3053  ea76		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   3054  ea8b
   3055  eb00					      ORG	$EB00,0	; *************
   3056  eb00
   3057  eb00							;g16x16_4color
   3058  eb00		       ff ff ff ff	      HEX	ffffffff
   3059  eb04							;g16x16_4color2
   3060  eb04		       55 55 55 55	      HEX	55555555
   3061  eb08							;g16x16_4color3
   3062  eb08		       55 55 55 55	      HEX	55555555
   3063  eb0c							;g16x16_4color4
   3064  eb0c		       00 00 00 00	      HEX	00000000
   3065  eb10							;g16x16_4color5
   3066  eb10		       00 00 00 00	      HEX	00000000
   3067  eb14							;g16x16_4color6
   3068  eb14		       aa aa aa aa	      HEX	aaaaaaaa
   3069  eb18							;g16x16_4color7
   3070  eb18		       ff ff ff ff	      HEX	ffffffff
   3071  eb1c							;g16x16_4color8
   3072  eb1c		       ff ff ff ff	      HEX	ffffffff
   3073  eb20							;zonebg80x16_16
   3074  eb20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   3075  eb34							;ex1
   3076  eb34		       00 30 40 00	      HEX	00304000
   3077  eb38							;ex2
   3078  eb38		       30 69 9a 40	      HEX	30699a40
   3079  eb3c							;ex3
   3080  eb3c		       05 a5 6d 83	      HEX	05a56d83
   3081  eb40							;ex4
   3082  eb40		       26 9a 68 d8	      HEX	269a68d8
   3083  eb44							;ex5
   3084  eb44		       18 d4 04 69	      HEX	18d40469
   3085  eb48							;ex6
   3086  eb48		       14 00 00 01	      HEX	14000001
   3087  eb4c							;ex7
   3088  eb4c		       40 00 00 01	      HEX	40000001
   3089  eb50							;p1
   3090  eb50		       0d 56		      HEX	0d56
   3091  eb52							;blank
   3092  eb52		       00 00 00 00	      HEX	00000000
   3093  eb56							;font
   3094  eb56		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   3095  eb76		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   3096  eb8b
   3097  ec00					      ORG	$EC00,0	; *************
   3098  ec00
   3099  ec00							;g16x16_4color
   3100  ec00		       55 55 55 55	      HEX	55555555
   3101  ec04							;g16x16_4color2
   3102  ec04		       55 55 55 55	      HEX	55555555
   3103  ec08							;g16x16_4color3
   3104  ec08		       00 00 00 00	      HEX	00000000
   3105  ec0c							;g16x16_4color4
   3106  ec0c		       00 00 00 00	      HEX	00000000
   3107  ec10							;g16x16_4color5
   3108  ec10		       aa aa aa aa	      HEX	aaaaaaaa
   3109  ec14							;g16x16_4color6
   3110  ec14		       aa aa aa aa	      HEX	aaaaaaaa
   3111  ec18							;g16x16_4color7
   3112  ec18		       aa aa aa aa	      HEX	aaaaaaaa
   3113  ec1c							;g16x16_4color8
   3114  ec1c		       ff ff ff ff	      HEX	ffffffff
   3115  ec20							;zonebg80x16_16
   3116  ec20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   3117  ec34							;ex1
   3118  ec34		       00 00 00 00	      HEX	00000000
   3119  ec38							;ex2
   3120  ec38		       00 64 a8 00	      HEX	0064a800
   3121  ec3c							;ex3
   3122  ec3c		       00 6e a2 40	      HEX	006ea240
   3123  ec40							;ex4
   3124  ec40		       1b 26 a6 a4	      HEX	1b26a6a4
   3125  ec44							;ex5
   3126  ec44		       12 a5 5a a4	      HEX	12a55aa4
   3127  ec48							;ex6
   3128  ec48		       11 00 00 14	      HEX	11000014
   3129  ec4c							;ex7
   3130  ec4c		       10 00 00 00	      HEX	10000000
   3131  ec50							;p1
   3132  ec50		       0d 56		      HEX	0d56
   3133  ec52							;blank
   3134  ec52		       00 00 00 00	      HEX	00000000
   3135  ec56							;font
   3136  ec56		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   3137  ec76		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   3138  ec8b
   3139  ed00					      ORG	$ED00,0	; *************
   3140  ed00
   3141  ed00							;g16x16_4color
   3142  ed00		       55 55 55 55	      HEX	55555555
   3143  ed04							;g16x16_4color2
   3144  ed04		       00 00 00 00	      HEX	00000000
   3145  ed08							;g16x16_4color3
   3146  ed08		       00 00 00 00	      HEX	00000000
   3147  ed0c							;g16x16_4color4
   3148  ed0c		       aa aa aa aa	      HEX	aaaaaaaa
   3149  ed10							;g16x16_4color5
   3150  ed10		       aa aa aa aa	      HEX	aaaaaaaa
   3151  ed14							;g16x16_4color6
   3152  ed14		       ff ff ff ff	      HEX	ffffffff
   3153  ed18							;g16x16_4color7
   3154  ed18		       aa aa aa aa	      HEX	aaaaaaaa
   3155  ed1c							;g16x16_4color8
   3156  ed1c		       55 55 55 55	      HEX	55555555
   3157  ed20							;zonebg80x16_16
   3158  ed20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   3159  ed34							;ex1
   3160  ed34		       00 00 00 00	      HEX	00000000
   3161  ed38							;ex2
   3162  ed38		       00 14 14 0c	      HEX	0014140c
   3163  ed3c							;ex3
   3164  ed3c		       00 65 95 03	      HEX	00659503
   3165  ed40							;ex4
   3166  ed40		       16 68 4a 60	      HEX	16684a60
   3167  ed44							;ex5
   3168  ed44		       15 82 a3 54	      HEX	1582a354
   3169  ed48							;ex6
   3170  ed48		       25 51 05 24	      HEX	25510524
   3171  ed4c							;ex7
   3172  ed4c		       00 00 00 04	      HEX	00000004
   3173  ed50							;p1
   3174  ed50		       15 80		      HEX	1580
   3175  ed52							;blank
   3176  ed52		       00 00 00 00	      HEX	00000000
   3177  ed56							;font
   3178  ed56		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   3179  ed76		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   3180  ed8b
   3181  ee00					      ORG	$EE00,0	; *************
   3182  ee00
   3183  ee00							;g16x16_4color
   3184  ee00		       00 00 00 00	      HEX	00000000
   3185  ee04							;g16x16_4color2
   3186  ee04		       00 00 00 00	      HEX	00000000
   3187  ee08							;g16x16_4color3
   3188  ee08		       aa aa aa aa	      HEX	aaaaaaaa
   3189  ee0c							;g16x16_4color4
   3190  ee0c		       aa aa aa aa	      HEX	aaaaaaaa
   3191  ee10							;g16x16_4color5
   3192  ee10		       ff ff ff ff	      HEX	ffffffff
   3193  ee14							;g16x16_4color6
   3194  ee14		       ff ff ff ff	      HEX	ffffffff
   3195  ee18							;g16x16_4color7
   3196  ee18		       55 55 55 55	      HEX	55555555
   3197  ee1c							;g16x16_4color8
   3198  ee1c		       55 55 55 55	      HEX	55555555
   3199  ee20							;zonebg80x16_16
   3200  ee20		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   3201  ee34							;ex1
   3202  ee34		       00 00 00 00	      HEX	00000000
   3203  ee38							;ex2
   3204  ee38		       00 c0 00 00	      HEX	00c00000
   3205  ee3c							;ex3
   3206  ee3c		       c0 10 50 00	      HEX	c0105000
   3207  ee40							;ex4
   3208  ee40		       06 a5 79 40	      HEX	06a57940
   3209  ee44							;ex5
   3210  ee44		       31 55 45 13	      HEX	31554513
   3211  ee48							;ex6
   3212  ee48		       01 15 45 50	      HEX	01154550
   3213  ee4c							;ex7
   3214  ee4c		       05 00 00 10	      HEX	05000010
   3215  ee50							;p1
   3216  ee50		       14 00		      HEX	1400
   3217  ee52							;blank
   3218  ee52		       00 00 00 00	      HEX	00000000
   3219  ee56							;font
   3220  ee56		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   3221  ee76		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   3222  ee8b
   3223  ef00					      ORG	$EF00,0	; *************
   3224  ef00
   3225  ef00							;g16x16_4color
   3226  ef00		       00 00 00 00	      HEX	00000000
   3227  ef04							;g16x16_4color2
   3228  ef04		       aa aa aa aa	      HEX	aaaaaaaa
   3229  ef08							;g16x16_4color3
   3230  ef08		       aa aa aa aa	      HEX	aaaaaaaa
   3231  ef0c							;g16x16_4color4
   3232  ef0c		       ff ff ff ff	      HEX	ffffffff
   3233  ef10							;g16x16_4color5
   3234  ef10		       ff ff ff ff	      HEX	ffffffff
   3235  ef14							;g16x16_4color6
   3236  ef14		       55 55 55 55	      HEX	55555555
   3237  ef18							;g16x16_4color7
   3238  ef18		       55 55 55 55	      HEX	55555555
   3239  ef1c							;g16x16_4color8
   3240  ef1c		       00 00 00 00	      HEX	00000000
   3241  ef20							;zonebg80x16_16
   3242  ef20		       aa aa aa aa*	      HEX	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   3243  ef34							;ex1
   3244  ef34		       00 00 00 00	      HEX	00000000
   3245  ef38							;ex2
   3246  ef38		       00 00 c0 00	      HEX	0000c000
   3247  ef3c							;ex3
   3248  ef3c		       00 00 00 c0	      HEX	000000c0
   3249  ef40							;ex4
   3250  ef40		       00 50 54 00	      HEX	00505400
   3251  ef44							;ex5
   3252  ef44		       01 15 07 40	      HEX	01150740
   3253  ef48							;ex6
   3254  ef48		       00 50 64 40	      HEX	00506440
   3255  ef4c							;ex7
   3256  ef4c		       01 45 45 40	      HEX	01454540
   3257  ef50							;p1
   3258  ef50		       56 00		      HEX	5600
   3259  ef52							;blank
   3260  ef52		       00 00 00 00	      HEX	00000000
   3261  ef56							;font
   3262  ef56		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   3263  ef76		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   3264  ef8b				  -	      if	SPACEOVERFLOW > 0
   3265  ef8b				  -	      echo	""
   3266  ef8b				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   3267  ef8b				  -	      echo	"######## look above for areas with negative ROM space left."
   3268  ef8b				  -	      echo	"######## Aborting assembly."
   3269  ef8b				  -	      ERR
   3270  ef8b					      endif
   3271  ef8b
   3272  ef8b
   3273  ef8b							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3274  ef8b
   3275  ef8b					      ifnconst	bankswitchmode
   3276  ef8b					      if	( * < $f000 )
   3277  f000					      ORG	$F000
   3278  f000					      endif
   3279  f000				  -	      else
   3280  f000				  -	      ifconst	ROM128K
   3281  f000				  -	      if	( * < $f000 )
   3282  f000				  -	      ORG	$27000
   3283  f000				  -	      RORG	$F000
   3284  f000				  -	      endif
   3285  f000				  -	      endif
   3286  f000				  -	      ifconst	ROM144K
   3287  f000				  -	      if	( * < $f000 )
   3288  f000				  -	      ORG	$27000
   3289  f000				  -	      RORG	$F000
   3290  f000				  -	      endif
   3291  f000				  -	      endif
   3292  f000				  -	      ifconst	ROM256K
   3293  f000				  -	      if	( * < $f000 )
   3294  f000				  -	      ORG	$47000
   3295  f000				  -	      RORG	$F000
   3296  f000				  -	      endif
   3297  f000				  -	      endif
   3298  f000				  -	      ifconst	ROM272K
   3299  f000				  -	      if	( * < $f000 )
   3300  f000				  -	      ORG	$47000
   3301  f000				  -	      RORG	$F000
   3302  f000				  -	      endif
   3303  f000				  -	      endif
   3304  f000				  -	      ifconst	ROM512K
   3305  f000				  -	      if	( * < $f000 )
   3306  f000				  -	      ORG	$87000
   3307  f000				  -	      RORG	$F000
   3308  f000				  -	      endif
   3309  f000				  -	      endif
   3310  f000				  -	      ifconst	ROM528K
   3311  f000				  -	      if	( * < $f000 )
   3312  f000				  -	      ORG	$87000
   3313  f000				  -	      RORG	$F000
   3314  f000				  -	      endif
   3315  f000				  -	      endif
   3316  f000					      endif
   3317  f000
   3318  f000							; all of these "modules" have conditional clauses in them, so even though
   3319  f000							; they're always included here, they don't take up rom unless the user
   3320  f000							; explicitly enables support for the feature.
   3321  f000
   3322  f000					      ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  f000					      include	rmtplayer.asm	; requires page alignment, so go first
      1  f000				  -	      ifconst	RMT
      2  f000				  -
      3  f000				  -rmtmodulestart
      4  f000				  -
      5  f000				  -			;*
      6  f000				  -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  f000				  -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  f000				  -			;* http://raster.atari.org
      9  f000				  -			;*
     10  f000				  -			;* Some small changes to allow using this code with DASM cross assembler and
     11  f000				  -			;* to compile for cartridge based systems, like the Atari 5200 or Atari 7800,
     12  f000				  -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  f000				  -			;*
     14  f000				  -			;* Warnings:
     15  f000				  -			;*
     16  f000				  -			;* 1. RMT player routine needs 19 itself reserved bytes in zero page (no accessed
     17  f000				  -			;*    from any other routines) as well as cca 1KB of memory before the "PLAYER"
     18  f000				  -			;*    address for frequency tables and functionary variables. It's:
     19  f000				  -			;*	  a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     20  f000				  -			;*    b) from PLAYER-$380 to PLAYER for mono RMTplayer
     21  f000				  -			;*
     22  f000				  -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER points
     23  f000				  -			;*	  to the start of the frequency tables. The player routines follows after
     24  f000				  -			;*	  that. The variables are now independent and can be located with
     25  f000				  -			;*	  PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     26  f000				  -			;*
     27  f000				  -			;* 2. RMT player routine MUST (!!!) be compiled from the begin of the memory page.
     28  f000				  -			;*    i.e. "PLAYER" address can be $..00 only!
     29  f000				  -			;*
     30  f000				  -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of CPU time.
     31  f000				  -			;*
     32  f000				  -			;*
     33  f000				  -			;* Define the following equates here or in your main code file.
     34  f000				  -			;* Set the values according to the system you compile for.
     35  f000				  -			;*
     36  f000				  -
     37  f000				  -POKEY_BASE equ	pokeyaddress
     38  f000				  -PLAYER_ZP_RAM equ	songchannel1layer1lo	; player routine needs 19 bytes of zero page RAM
     39  f000				  -PLAYER_VAR_RAM equ	RMTRAM	;variables in main RAM - 173 bytes mono - 337 stereo
     40  f000				  -ROM_BASED  equ	1	;using a ROM based system - no self modifying code
     41  f000				  -STEREO8T   equ	0	;0 => compile RMTplayer for mono 4 tracks
     42  f000				  -			;				    ;1 => compile RMTplayer for stereo 8 tracks
     43  f000				  -
     44  f000				  -rmt_ispeed equ	PLAYER_ZP_RAM+19
     45  f000				  -rmt_intcount equ	PLAYER_ZP_RAM+20
     46  f000				  -
     47  f000				  -			;*
     48  f000				  -
     49  f000				  -	      IF	STEREO8T
     50  f000				  -TRACKS     equ	8
     51  f000				  -	      ELSE
     52  f000				  -TRACKS     equ	4
     53  f000				  -	      EIF
     54  f000				  -
     55  f000				  -			;*
     56  f000				  -			;* RMT FEATures definitions
     57  f000				  -			;* For optimizations of RMT player routine to concrete RMT modul only!
     58  f000				  -			;* --------BEGIN--------
     59  f000				  -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     60  f000				  -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
     61  f000				  -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     62  f000				  -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     63  f000				  -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     64  f000				  -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     65  f000				  -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     66  f000				  -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     67  f000				  -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     68  f000				  -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     69  f000				  -			;* PORTAMENTO
     70  f000				  -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     71  f000				  -			;* FILTER
     72  f000				  -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     73  f000				  -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     74  f000				  -FEAT_FILTERG1L equ	1
     75  f000				  -FEAT_FILTERG0R equ	1
     76  f000				  -FEAT_FILTERG1R equ	1
     77  f000				  -			;* BASS16B (i.e. distortion value 6)
     78  f000				  -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and quicker whole RMT routine
     79  f000				  -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     80  f000				  -FEAT_BASS16G3L equ	1
     81  f000				  -FEAT_BASS16G1R equ	1
     82  f000				  -FEAT_BASS16G3R equ	1
     83  f000				  -			;* VOLUME ONLY for particular generators
     84  f000				  -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     85  f000				  -FEAT_VOLUMEONLYG2L equ	1
     86  f000				  -FEAT_VOLUMEONLYG3L equ	1
     87  f000				  -FEAT_VOLUMEONLYG0R equ	1
     88  f000				  -FEAT_VOLUMEONLYG2R equ	1
     89  f000				  -FEAT_VOLUMEONLYG3R equ	1
     90  f000				  -			;* TABLE TYPE (i.e. TABLETYPE=1)
     91  f000				  -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
     92  f000				  -			;* TABLE MODE (i.e. TABLEMODE=1)
     93  f000				  -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
     94  f000				  -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
     95  f000				  -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
     96  f000				  -			;* --------END--------
     97  f000				  -			;*
     98  f000				  -			;*
     99  f000				  -			;* RMT ZeroPage addresses
    100  f000				  -
    101  f000				  -MEMLOC     SET	PLAYER_ZP_RAM
    102  f000				  -p_tis      =	MEMLOC
    103  f000				  -p_instrstable =	MEMLOC
    104  f000				  -MEMLOC     SET	(MEMLOC+2)
    105  f000				  -p_trackslbstable =	MEMLOC
    106  f000				  -MEMLOC     SET	(MEMLOC+2)
    107  f000				  -p_trackshbstable =	MEMLOC
    108  f000				  -MEMLOC     SET	(MEMLOC+2)
    109  f000				  -p_song     =	MEMLOC
    110  f000				  -MEMLOC     SET	(MEMLOC+2)
    111  f000				  -
    112  f000				  -_ns	      =	MEMLOC
    113  f000				  -MEMLOC     SET	(MEMLOC+2)
    114  f000				  -_nr	      =	MEMLOC
    115  f000				  -MEMLOC     SET	(MEMLOC+2)
    116  f000				  -_nt	      =	MEMLOC
    117  f000				  -MEMLOC     SET	(MEMLOC+2)
    118  f000				  -
    119  f000				  -rmtreg1    =	MEMLOC
    120  f000				  -MEMLOC     SET	(MEMLOC+1)
    121  f000				  -rmtreg2    =	MEMLOC
    122  f000				  -MEMLOC     SET	(MEMLOC+1)
    123  f000				  -rmtreg3    =	MEMLOC
    124  f000				  -MEMLOC     SET	(MEMLOC+1)
    125  f000				  -_tmp       =	MEMLOC
    126  f000				  -MEMLOC     SET	(MEMLOC+1)
    127  f000				  -	      IF	FEAT_COMMAND2
    128  f000				  -frqaddcmd2 =	MEMLOC
    129  f000				  -MEMLOC     SET	(MEMLOC+1)
    130  f000				  -	      EIF
    131  f000				  -
    132  f000				  -			;*
    133  f000				  -			;* Variables in main RAM used by player routine.
    134  f000				  -			;* 337 bytes for stereo - 173 bytes for mono
    135  f000				  -			;*
    136  f000				  -
    137  f000				  -MEMLOC     SET	PLAYER_VAR_RAM
    138  f000				  -track_variables =	MEMLOC
    139  f000				  -
    140  f000				  -trackn_db  =	MEMLOC
    141  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    142  f000				  -trackn_hb  =	MEMLOC
    143  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    144  f000				  -trackn_idx =	MEMLOC
    145  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    146  f000				  -trackn_pause =	MEMLOC
    147  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    148  f000				  -trackn_note =	MEMLOC
    149  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    150  f000				  -trackn_volume =	MEMLOC
    151  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    152  f000				  -trackn_distor =	MEMLOC
    153  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    154  f000				  -trackn_shiftfrq =	MEMLOC
    155  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    156  f000				  -
    157  f000				  -	      IF	FEAT_PORTAMENTO
    158  f000				  -trackn_portafrqc =	MEMLOC
    159  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    160  f000				  -trackn_portafrqa =	MEMLOC
    161  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    162  f000				  -trackn_portaspeed =	MEMLOC
    163  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    164  f000				  -trackn_portaspeeda =	MEMLOC
    165  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    166  f000				  -trackn_portadepth =	MEMLOC
    167  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    168  f000				  -	      EIF
    169  f000				  -
    170  f000				  -trackn_instrx2 =	MEMLOC
    171  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    172  f000				  -trackn_instrdb =	MEMLOC
    173  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    174  f000				  -trackn_instrhb =	MEMLOC
    175  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    176  f000				  -trackn_instridx =	MEMLOC
    177  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    178  f000				  -trackn_instrlen =	MEMLOC
    179  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    180  f000				  -trackn_instrlop =	MEMLOC
    181  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    182  f000				  -trackn_instrreachend =	MEMLOC
    183  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    184  f000				  -trackn_volumeslidedepth =	MEMLOC
    185  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    186  f000				  -trackn_volumeslidevalue =	MEMLOC
    187  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    188  f000				  -trackn_volumemin =	MEMLOC
    189  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    190  f000				  -trackn_effdelay =	MEMLOC
    191  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    192  f000				  -trackn_effvibratoa =	MEMLOC
    193  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    194  f000				  -trackn_effvibratobeg =	MEMLOC
    195  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    196  f000				  -trackn_effvibratoend =	MEMLOC
    197  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    198  f000				  -trackn_effshift =	MEMLOC
    199  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    200  f000				  -trackn_tabletypespeed =	MEMLOC
    201  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    202  f000				  -
    203  f000				  -	      IF	FEAT_TABLEMODE
    204  f000				  -trackn_tablemode =	MEMLOC
    205  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    206  f000				  -	      EIF
    207  f000				  -
    208  f000				  -trackn_tablenote =	MEMLOC
    209  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    210  f000				  -
    211  f000				  -trackn_tablea =	MEMLOC
    212  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    213  f000				  -trackn_tableend =	MEMLOC
    214  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    215  f000				  -trackn_tablelop =	MEMLOC
    216  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    217  f000				  -trackn_tablespeeda =	MEMLOC
    218  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    219  f000				  -trackn_command =	MEMLOC
    220  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    221  f000				  -
    222  f000				  -	      IF	FEAT_BASS16
    223  f000				  -trackn_outnote =	MEMLOC
    224  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    225  f000				  -	      EIF
    226  f000				  -	      IF	FEAT_FILTER
    227  f000				  -trackn_filter =	MEMLOC
    228  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    229  f000				  -	      EIF
    230  f000				  -
    231  f000				  -trackn_audf =	MEMLOC
    232  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    233  f000				  -trackn_audc =	MEMLOC
    234  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    235  f000				  -
    236  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    237  f000				  -trackn_audctl =	MEMLOC
    238  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    239  f000				  -	      EIF
    240  f000				  -
    241  f000				  -v_audctl   =	MEMLOC
    242  f000				  -MEMLOC     SET	(MEMLOC+1)
    243  f000				  -v_audctl2  =	MEMLOC
    244  f000				  -MEMLOC     SET	(MEMLOC+1)
    245  f000				  -v_speed    =	MEMLOC
    246  f000				  -MEMLOC     SET	(MEMLOC+1)
    247  f000				  -v_aspeed   =	MEMLOC
    248  f000				  -MEMLOC     SET	(MEMLOC+1)
    249  f000				  -v_bspeed   =	MEMLOC
    250  f000				  -MEMLOC     SET	(MEMLOC+1)
    251  f000				  -v_instrspeed =	MEMLOC
    252  f000				  -MEMLOC     SET	(MEMLOC+1)
    253  f000				  -v_ainstrspeed =	MEMLOC
    254  f000				  -MEMLOC     SET	(MEMLOC+1)
    255  f000				  -v_maxtracklen =	MEMLOC
    256  f000				  -MEMLOC     SET	(MEMLOC+1)
    257  f000				  -v_abeat    =	MEMLOC
    258  f000				  -MEMLOC     SET	(MEMLOC+1)
    259  f000				  -
    260  f000				  -track_endvariables =	MEMLOC
    261  f000				  -
    262  f000				  -			;*
    263  f000				  -			;* Data tables used by player routine.
    264  f000				  -			;*
    265  f000				  -	      ALIGN	256
    266  f000				  -PLAYER     =	.
    267  f000				  -
    268  f000				  -volumetab
    269  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    270  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    271  f000				  -	      dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    272  f000				  -	      dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    273  f000				  -	      dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    274  f000				  -	      dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    275  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    276  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    277  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    278  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    279  f000				  -	      dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    280  f000				  -	      dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    281  f000				  -	      dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    282  f000				  -	      dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    283  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    284  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    285  f000				  -
    286  f000				  -frqtab
    287  f000				  -			;	ERT [<frqtab]!=0	;* frqtab must begin at the memory page bound! (i.e. $..00 address)
    288  f000				  -frqtabbass1
    289  f000				  -	      dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    290  f000				  -	      dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    291  f000				  -	      dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    292  f000				  -	      dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    293  f000				  -frqtabbass2
    294  f000				  -	      dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    295  f000				  -	      dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    296  f000				  -	      dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    297  f000				  -	      dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    298  f000				  -frqtabpure
    299  f000				  -	      dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    300  f000				  -	      dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    301  f000				  -	      dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    302  f000				  -	      dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    303  f000				  -	      IF	FEAT_BASS16
    304  f000				  -frqtabbasshi
    305  f000				  -	      dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    306  f000				  -	      dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    307  f000				  -	      dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    308  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    309  f000				  -	      EIF
    310  f000				  -
    311  f000				  -	      IF	FEAT_BASS16
    312  f000				  -frqtabbasslo
    313  f000				  -	      dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    314  f000				  -	      dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    315  f000				  -	      dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    316  f000				  -	      dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    317  f000				  -	      EIF
    318  f000				  -
    319  f000				  -	      IF	ROM_BASED
    320  f000				  -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    321  f000				  -	      EIF
    322  f000				  -INSTRPAR   equ	12
    323  f000				  -tabbeganddistor
    324  f000				  -	      dc.b	frqtabpure-frqtab,$00
    325  f000				  -	      dc.b	frqtabpure-frqtab,$20
    326  f000				  -	      dc.b	frqtabpure-frqtab,$40
    327  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    328  f000				  -	      dc.b	frqtabpure-frqtab,$80
    329  f000				  -	      dc.b	frqtabpure-frqtab,$a0
    330  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    331  f000				  -	      dc.b	frqtabbass2-frqtab,$c0
    332  f000				  -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    333  f000				  -vib0       dc.b	0
    334  f000				  -vib1       dc.b	1,-1,-1,1
    335  f000				  -vib2       dc.b	1,0,-1,-1,0,1
    336  f000				  -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    337  f000				  -vibx
    338  f000				  -emptytrack
    339  f000				  -	      dc.b	62,0
    340  f000				  -
    341  f000				  -			;*
    342  f000				  -			;* Set of RMT main vectors:
    343  f000				  -			;*
    344  f000				  -RASTERMUSICTRACKER
    345  f000				  -	      jmp	rmt_init
    346  f000				  -	      jmp	rmt_play
    347  f000				  -	      jmp	rmt_p3
    348  f000				  -	      jmp	rmt_silence
    349  f000				  -	      jmp	SetPokey
    350  f000				  -rmt_init
    351  f000				  -	      stx	_ns
    352  f000				  -	      sty	_ns+1
    353  f000				  -	      pha
    354  f000				  -	      IF	track_endvariables-track_variables>255
    355  f000				  -	      ldy	#0
    356  f000				  -	      tya
    357  f000				  -rmtri0     sta	track_variables,y
    358  f000				  -	      sta	track_endvariables-$100,y
    359  f000				  -	      iny
    360  f000				  -	      bne	rmtri0
    361  f000				  -	      ELSE
    362  f000				  -	      ldy	#track_endvariables-track_variables
    363  f000				  -	      lda	#0
    364  f000				  -rmtri0     sta	track_variables-1,y
    365  f000				  -	      dey
    366  f000				  -	      bne	rmtri0
    367  f000				  -	      EIF
    368  f000				  -	      ldy	#4
    369  f000				  -	      lda	(_ns),y
    370  f000				  -	      sta	v_maxtracklen
    371  f000				  -	      iny
    372  f000				  -	      lda	(_ns),y
    373  f000				  -	      sta	v_speed
    374  f000				  -	      iny
    375  f000				  -	      lda	(_ns),y
    376  f000				  -	      sta	v_instrspeed
    377  f000				  -	      sta	v_ainstrspeed
    378  f000				  -	      ldy	#8
    379  f000				  -rmtri1     lda	(_ns),y
    380  f000				  -	      sta	p_tis-8,y
    381  f000				  -	      iny
    382  f000				  -	      cpy	#8+8
    383  f000				  -	      bne	rmtri1
    384  f000				  -	      pla
    385  f000				  -	      pha
    386  f000				  -	      IF	STEREO8T
    387  f000				  -	      asl
    388  f000				  -	      asl
    389  f000				  -	      asl
    390  f000				  -	      clc
    391  f000				  -	      adc	p_song
    392  f000				  -	      sta	p_song
    393  f000				  -	      pla
    394  f000				  -	      and	#$e0
    395  f000				  -	      asl
    396  f000				  -	      rol
    397  f000				  -	      rol
    398  f000				  -	      rol
    399  f000				  -	      ELSE
    400  f000				  -	      asl
    401  f000				  -	      asl
    402  f000				  -	      clc
    403  f000				  -	      adc	p_song
    404  f000				  -	      sta	p_song
    405  f000				  -	      pla
    406  f000				  -	      and	#$c0
    407  f000				  -	      asl
    408  f000				  -	      rol
    409  f000				  -	      rol
    410  f000				  -	      EIF
    411  f000				  -	      adc	p_song+1
    412  f000				  -	      sta	p_song+1
    413  f000				  -	      jsr	GetSongLine
    414  f000				  -	      jsr	GetTrackLine
    415  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    416  f000				  -	      jsr	rmt_silence
    417  f000				  -	      lda	v_instrspeed
    418  f000				  -	      rts
    419  f000				  -rmt_silence
    420  f000				  -	      IF	STEREO8T
    421  f000				  -	      lda	#0
    422  f000				  -	      sta	POKEY_BASE+$08
    423  f000				  -	      sta	POKEY_BASE_S+$08
    424  f000				  -	      ldy	#3
    425  f000				  -	      sty	POKEY_BASE+$0f
    426  f000				  -	      sty	POKEY_BASE_S+$0f
    427  f000				  -	      ldy	#8
    428  f000				  -rmtsi1     sta	POKEY_BASE+$00,y
    429  f000				  -	      sta	POKEY_BASE_S+$00,y
    430  f000				  -	      dey
    431  f000				  -	      bpl	rmtsi1
    432  f000				  -	      ELSE
    433  f000				  -	      lda	#0
    434  f000				  -	      sta	POKEY_BASE+$08
    435  f000				  -	      ldy	#3
    436  f000				  -	      sty	POKEY_BASE+$0f
    437  f000				  -	      ldy	#8
    438  f000				  -rmtsi1     sta	POKEY_BASE+$00,y
    439  f000				  -	      dey
    440  f000				  -	      bpl	rmtsi1
    441  f000				  -	      EIF
    442  f000				  -	      rts
    443  f000				  -GetSongLine
    444  f000				  -	      ldx	#0
    445  f000				  -	      stx	v_abeat
    446  f000				  -rmtnn0
    447  f000				  -	      ldx	#0
    448  f000				  -rmtnn1     txa
    449  f000				  -	      tay
    450  f000				  -	      lda	(p_song),y
    451  f000				  -	      cmp	#$fe
    452  f000				  -	      bcs	rmtnn2
    453  f000				  -	      tay
    454  f000				  -	      lda	(p_trackslbstable),y
    455  f000				  -	      sta	trackn_db,x
    456  f000				  -	      lda	(p_trackshbstable),y
    457  f000				  -rmtnn1a    sta	trackn_hb,x
    458  f000				  -	      lda	#0
    459  f000				  -	      sta	trackn_idx,x
    460  f000				  -	      lda	#1
    461  f000				  -	      sta	trackn_pause,x
    462  f000				  -	      lda	#$80
    463  f000				  -	      sta	trackn_instrx2,x
    464  f000				  -	      inx
    465  f000				  -	      cpx	#TRACKS
    466  f000				  -	      bne	rmtnn1
    467  f000				  -	      lda	p_song
    468  f000				  -	      clc
    469  f000				  -	      adc	#TRACKS
    470  f000				  -	      sta	p_song
    471  f000				  -	      bcc	rmtnn1b
    472  f000				  -	      inc	p_song+1
    473  f000				  -rmtnn1b
    474  f000				  -	      rts
    475  f000				  -rmtnn2
    476  f000				  -	      beq	rmtnn3
    477  f000				  -rmtnn2a    lda	#<emptytrack
    478  f000				  -	      sta	trackn_db,x
    479  f000				  -	      lda	#>emptytrack
    480  f000				  -	      jmp	rmtnn1a
    481  f000				  -rmtnn3
    482  f000				  -	      ldy	#2
    483  f000				  -	      lda	(p_song),y
    484  f000				  -	      tax
    485  f000				  -	      iny
    486  f000				  -	      lda	(p_song),y
    487  f000				  -	      sta	p_song+1
    488  f000				  -	      stx	p_song
    489  f000				  -	      jmp	rmtnn0
    490  f000				  -GetTrackLine
    491  f000				  -rmtoo0
    492  f000				  -rmtoo0a
    493  f000				  -	      lda	v_speed
    494  f000				  -	      sta	v_bspeed
    495  f000				  -	      ldx	#0
    496  f000				  -rmtoo1
    497  f000				  -	      lda	trackn_pause,x
    498  f000				  -	      beq	rmtoo1x
    499  f000				  -	      dec	trackn_pause,x
    500  f000				  -	      bne	rmtoo1x
    501  f000				  -	      inc	trackn_pause,x
    502  f000				  -rmtoo1b
    503  f000				  -	      lda	trackn_db,x
    504  f000				  -	      sta	_ns
    505  f000				  -	      lda	trackn_hb,x
    506  f000				  -	      sta	_ns+1
    507  f000				  -rmtoo1i
    508  f000				  -	      ldy	trackn_idx,x
    509  f000				  -	      lda	(_ns),y
    510  f000				  -	      sta	rmtreg1
    511  f000				  -	      iny
    512  f000				  -	      lda	(_ns),y
    513  f000				  -	      sta	rmtreg2
    514  f000				  -	      iny
    515  f000				  -	      tya
    516  f000				  -	      sta	trackn_idx,x
    517  f000				  -	      lda	rmtreg1
    518  f000				  -	      and	#$3f
    519  f000				  -	      cmp	#61
    520  f000				  -	      beq	rmtoo1a
    521  f000				  -	      bcs	rmtoo2
    522  f000				  -	      sta	trackn_note,x
    523  f000				  -	      IF	FEAT_BASS16
    524  f000				  -	      sta	trackn_outnote,x
    525  f000				  -	      EIF
    526  f000				  -	      lda	rmtreg2
    527  f000				  -	      lsr
    528  f000				  -	      and	#$3f*2
    529  f000				  -	      sta	trackn_instrx2,x
    530  f000				  -rmtoo1a    lda	rmtreg2
    531  f000				  -	      lsr
    532  f000				  -	      ror	rmtreg1
    533  f000				  -	      lsr
    534  f000				  -	      ror	rmtreg1
    535  f000				  -	      lda	rmtreg1
    536  f000				  -	      and	#$f0
    537  f000				  -	      sta	trackn_volume,x
    538  f000				  -rmtoo1x
    539  f000				  -	      inx
    540  f000				  -	      cpx	#TRACKS
    541  f000				  -	      bne	rmtoo1
    542  f000				  -	      lda	v_bspeed
    543  f000				  -	      sta	v_speed
    544  f000				  -	      sta	v_aspeed
    545  f000				  -	      rts
    546  f000				  -rmtoo2
    547  f000				  -	      cmp	#63
    548  f000				  -	      beq	rmtoo63
    549  f000				  -	      lda	rmtreg1
    550  f000				  -	      and	#$c0
    551  f000				  -	      beq	rmtoo62_b
    552  f000				  -	      asl
    553  f000				  -	      rol
    554  f000				  -	      rol
    555  f000				  -	      sta	trackn_pause,x
    556  f000				  -	      dec	trackn_idx,x
    557  f000				  -	      jmp	rmtoo1x
    558  f000				  -rmtoo62_b
    559  f000				  -	      lda	rmtreg2
    560  f000				  -	      sta	trackn_pause,x
    561  f000				  -	      jmp	rmtoo1x
    562  f000				  -rmtoo63
    563  f000				  -	      lda	rmtreg1
    564  f000				  -	      bmi	rmtoo63_1X
    565  f000				  -	      lda	rmtreg2
    566  f000				  -	      sta	v_bspeed
    567  f000				  -	      jmp	rmtoo1i
    568  f000				  -rmtoo63_1X
    569  f000				  -	      cmp	#255
    570  f000				  -	      beq	rmtoo63_11
    571  f000				  -	      lda	rmtreg2
    572  f000				  -	      sta	trackn_idx,x
    573  f000				  -	      jmp	rmtoo1i
    574  f000				  -rmtoo63_11
    575  f000				  -	      jsr	GetSongLine
    576  f000				  -	      jmp	rmtoo0
    577  f000				  -InitOfNewSetInstrumentsOnly
    578  f000				  -	      ldx	#0
    579  f000				  -p2x1       ldy	trackn_instrx2,x
    580  f000				  -	      bmi	p2x2
    581  f000				  -	      jsr	SetUpInstrumentY2
    582  f000				  -	      lda	#$80
    583  f000				  -	      sta	trackn_instrx2,x
    584  f000				  -p2x2
    585  f000				  -	      inx
    586  f000				  -	      cpx	#TRACKS
    587  f000				  -	      bne	p2x1
    588  f000				  -	      rts
    589  f000				  -rmt_play
    590  f000				  -rmt_p0
    591  f000				  -	      jsr	SetPokey
    592  f000				  -rmt_p1
    593  f000				  -	      dec	v_ainstrspeed
    594  f000				  -	      beq	rmtp1a
    595  f000				  -	      jmp	rmt_p3
    596  f000				  -rmtp1a
    597  f000				  -	      lda	v_instrspeed
    598  f000				  -	      sta	v_ainstrspeed
    599  f000				  -rmt_p2
    600  f000				  -	      dec	v_aspeed
    601  f000				  -	      bne	rmt_p3
    602  f000				  -	      inc	v_abeat
    603  f000				  -	      lda	v_abeat
    604  f000				  -	      cmp	v_maxtracklen
    605  f000				  -	      bne	rmtp2o2
    606  f000				  -	      jsr	GetSongLine
    607  f000				  -rmtp2o2
    608  f000				  -	      jsr	GetTrackLine
    609  f000				  -	      jmp	rmt_p2X
    610  f000				  -go_ppnext  jmp	ppnext
    611  f000				  -rmt_p2X
    612  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    613  f000				  -rmt_p3
    614  f000				  -	      lda	#>frqtab
    615  f000				  -	      sta	_nr+1
    616  f000				  -	      ldx	#0
    617  f000				  -rmtpp1
    618  f000				  -	      lda	trackn_instrhb,x
    619  f000				  -	      beq	go_ppnext
    620  f000				  -	      sta	_ns+1
    621  f000				  -	      lda	trackn_instrdb,x
    622  f000				  -	      sta	_ns
    623  f000				  -	      ldy	trackn_instridx,x
    624  f000				  -	      lda	(_ns),y
    625  f000				  -	      sta	rmtreg1
    626  f000				  -	      iny
    627  f000				  -	      lda	(_ns),y
    628  f000				  -	      sta	rmtreg2
    629  f000				  -	      iny
    630  f000				  -	      lda	(_ns),y
    631  f000				  -	      sta	rmtreg3
    632  f000				  -	      iny
    633  f000				  -	      tya
    634  f000				  -	      cmp	trackn_instrlen,x
    635  f000				  -	      bcc	rmtpp2
    636  f000				  -	      beq	rmtpp2
    637  f000				  -	      lda	#$80
    638  f000				  -	      sta	trackn_instrreachend,x
    639  f000				  -rmtpp1b
    640  f000				  -	      lda	trackn_instrlop,x
    641  f000				  -rmtpp2     sta	trackn_instridx,x
    642  f000				  -	      lda	rmtreg1
    643  f000				  -	      IF	STEREO8T
    644  f000				  -	      cpx	#4
    645  f000				  -	      bcc	rmtpp2s
    646  f000				  -	      lsr
    647  f000				  -	      lsr
    648  f000				  -	      lsr
    649  f000				  -	      lsr
    650  f000				  -rmtpp2s
    651  f000				  -	      EIF
    652  f000				  -	      and	#$0f
    653  f000				  -	      ora	trackn_volume,x
    654  f000				  -	      tay
    655  f000				  -	      lda	volumetab,y
    656  f000				  -	      pha
    657  f000				  -	      lda	rmtreg2
    658  f000				  -	      and	#$0e
    659  f000				  -	      tay
    660  f000				  -	      lda	tabbeganddistor,y
    661  f000				  -	      sta	_nr
    662  f000				  -	      pla
    663  f000				  -	      ora	tabbeganddistor+1,y
    664  f000				  -	      sta	trackn_audc,x
    665  f000				  -	      jmp	InstrumentsEffects
    666  f000				  -returnfromInstrumentsEffects
    667  f000				  -	      IF	FEAT_COMMAND2
    668  f000				  -	      lda	#0
    669  f000				  -	      sta	frqaddcmd2
    670  f000				  -	      EIF
    671  f000				  -	      lda	rmtreg2
    672  f000				  -	      sta	trackn_command,x
    673  f000				  -	      and	#$70
    674  f000				  -	      lsr
    675  f000				  -	      lsr
    676  f000				  -	      IF	ROM_BASED
    677  f000				  -	      lsr
    678  f000				  -	      tay
    679  f000				  -	      lda	rts_tab+1,y
    680  f000				  -	      pha
    681  f000				  -	      lda	rts_tab,y
    682  f000				  -	      pha
    683  f000				  -	      rts
    684  f000				  -	      ELSE
    685  f000				  -	      sta	jmx+1
    686  f000				  -jmx	      bcc	*
    687  f000				  -	      jmp	cmd0
    688  f000				  -	      nop
    689  f000				  -	      jmp	cmd1
    690  f000				  -	      nop
    691  f000				  -	      jmp	cmd2
    692  f000				  -	      nop
    693  f000				  -	      jmp	cmd3
    694  f000				  -	      nop
    695  f000				  -	      jmp	cmd4
    696  f000				  -	      nop
    697  f000				  -	      jmp	cmd5
    698  f000				  -	      nop
    699  f000				  -	      jmp	cmd6
    700  f000				  -	      nop
    701  f000				  -	      jmp	cmd7
    702  f000				  -	      EIF
    703  f000				  -cmd0
    704  f000				  -	      lda	trackn_note,x
    705  f000				  -	      clc
    706  f000				  -	      adc	rmtreg3
    707  f000				  -cmd0a
    708  f000				  -	      IF	FEAT_TABLETYPE
    709  f000				  -	      ldy	trackn_tabletypespeed,x
    710  f000				  -	      bmi	cmd0b
    711  f000				  -	      EIF
    712  f000				  -	      clc
    713  f000				  -	      adc	trackn_tablenote,x
    714  f000				  -	      cmp	#61
    715  f000				  -	      bcc	cmd0a1
    716  f000				  -	      lda	#0
    717  f000				  -	      sta	trackn_audc,x
    718  f000				  -	      lda	#63
    719  f000				  -cmd0a1
    720  f000				  -	      IF	FEAT_BASS16
    721  f000				  -	      sta	trackn_outnote,x
    722  f000				  -	      EIF
    723  f000				  -	      tay
    724  f000				  -	      lda	(_nr),y
    725  f000				  -	      clc
    726  f000				  -	      adc	trackn_shiftfrq,x
    727  f000				  -	      IF	FEAT_COMMAND2
    728  f000				  -	      clc
    729  f000				  -	      adc	frqaddcmd2
    730  f000				  -	      EIF
    731  f000				  -	      sta	trackn_audf,x
    732  f000				  -	      jmp	rmtpp9
    733  f000				  -	      IF	FEAT_TABLETYPE
    734  f000				  -cmd0b
    735  f000				  -	      cmp	#61
    736  f000				  -	      bcc	cmd0b1
    737  f000				  -	      lda	#0
    738  f000				  -	      sta	trackn_audc,x
    739  f000				  -	      lda	#63
    740  f000				  -cmd0b1
    741  f000				  -	      tay
    742  f000				  -	      lda	trackn_shiftfrq,x
    743  f000				  -	      clc
    744  f000				  -	      adc	trackn_tablenote,x
    745  f000				  -	      clc
    746  f000				  -	      adc	(_nr),y
    747  f000				  -	      IF	FEAT_COMMAND2
    748  f000				  -	      clc
    749  f000				  -	      adc	frqaddcmd2
    750  f000				  -	      EIF
    751  f000				  -	      sta	trackn_audf,x
    752  f000				  -	      jmp	rmtpp9
    753  f000				  -	      EIF
    754  f000				  -cmd1
    755  f000				  -	      IF	FEAT_COMMAND1
    756  f000				  -	      lda	rmtreg3
    757  f000				  -	      sta	trackn_audf,x
    758  f000				  -	      jmp	rmtpp9
    759  f000				  -	      EIF
    760  f000				  -cmd2
    761  f000				  -	      IF	FEAT_COMMAND2
    762  f000				  -	      lda	rmtreg3
    763  f000				  -	      sta	frqaddcmd2
    764  f000				  -	      lda	trackn_note,x
    765  f000				  -	      jmp	cmd0a
    766  f000				  -	      EIF
    767  f000				  -cmd3
    768  f000				  -	      IF	FEAT_COMMAND3
    769  f000				  -	      lda	trackn_note,x
    770  f000				  -	      clc
    771  f000				  -	      adc	rmtreg3
    772  f000				  -	      sta	trackn_note,x
    773  f000				  -	      jmp	cmd0a
    774  f000				  -	      EIF
    775  f000				  -cmd4
    776  f000				  -	      IF	FEAT_COMMAND4
    777  f000				  -	      lda	trackn_shiftfrq,x
    778  f000				  -	      clc
    779  f000				  -	      adc	rmtreg3
    780  f000				  -	      sta	trackn_shiftfrq,x
    781  f000				  -	      lda	trackn_note,x
    782  f000				  -	      jmp	cmd0a
    783  f000				  -	      EIF
    784  f000				  -cmd5
    785  f000				  -	      IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    786  f000				  -	      IF	FEAT_TABLETYPE
    787  f000				  -	      lda	trackn_tabletypespeed,x
    788  f000				  -	      bpl	cmd5a1
    789  f000				  -	      ldy	trackn_note,x
    790  f000				  -	      lda	(_nr),y
    791  f000				  -	      clc
    792  f000				  -	      adc	trackn_tablenote,x
    793  f000				  -	      jmp	cmd5ax
    794  f000				  -	      EIF
    795  f000				  -cmd5a1
    796  f000				  -	      lda	trackn_note,x
    797  f000				  -	      clc
    798  f000				  -	      adc	trackn_tablenote,x
    799  f000				  -	      cmp	#61
    800  f000				  -	      bcc	cmd5a2
    801  f000				  -	      lda	#63
    802  f000				  -cmd5a2
    803  f000				  -	      tay
    804  f000				  -	      lda	(_nr),y
    805  f000				  -cmd5ax
    806  f000				  -	      sta	trackn_portafrqc,x
    807  f000				  -	      ldy	rmtreg3
    808  f000				  -	      bne	cmd5a
    809  f000				  -	      sta	trackn_portafrqa,x
    810  f000				  -cmd5a
    811  f000				  -	      tya
    812  f000				  -	      lsr
    813  f000				  -	      lsr
    814  f000				  -	      lsr
    815  f000				  -	      lsr
    816  f000				  -	      sta	trackn_portaspeed,x
    817  f000				  -	      sta	trackn_portaspeeda,x
    818  f000				  -	      lda	rmtreg3
    819  f000				  -	      and	#$0f
    820  f000				  -	      sta	trackn_portadepth,x
    821  f000				  -	      lda	trackn_note,x
    822  f000				  -	      jmp	cmd0a
    823  f000				  -	      ELSE
    824  f000				  -	      IF	FEAT_COMMAND5
    825  f000				  -	      jmp	rmtpp9
    826  f000				  -	      EIF
    827  f000				  -	      EIF
    828  f000				  -cmd6
    829  f000				  -	      IF	FEAT_COMMAND6&&FEAT_FILTER
    830  f000				  -	      lda	rmtreg3
    831  f000				  -	      clc
    832  f000				  -	      adc	trackn_filter,x
    833  f000				  -	      sta	trackn_filter,x
    834  f000				  -	      lda	trackn_note,x
    835  f000				  -	      jmp	cmd0a
    836  f000				  -	      ELSE
    837  f000				  -	      IF	FEAT_COMMAND6
    838  f000				  -	      jmp	rmtpp9
    839  f000				  -	      EIF
    840  f000				  -	      EIF
    841  f000				  -cmd7
    842  f000				  -	      IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    843  f000				  -	      IF	FEAT_COMMAND7SETNOTE
    844  f000				  -	      lda	rmtreg3
    845  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    846  f000				  -	      cmp	#$80
    847  f000				  -	      beq	cmd7a
    848  f000				  -	      EIF
    849  f000				  -	      sta	trackn_note,x
    850  f000				  -	      jmp	cmd0a
    851  f000				  -	      EIF
    852  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    853  f000				  -cmd7a
    854  f000				  -	      lda	trackn_audc,x
    855  f000				  -	      ora	#$f0
    856  f000				  -	      sta	trackn_audc,x
    857  f000				  -	      lda	trackn_note,x
    858  f000				  -	      jmp	cmd0a
    859  f000				  -	      EIF
    860  f000				  -	      EIF
    861  f000				  -rmtpp9
    862  f000				  -	      IF	FEAT_PORTAMENTO
    863  f000				  -	      lda	trackn_portaspeeda,x
    864  f000				  -	      beq	rmtpp10
    865  f000				  -	      sec
    866  f000				  -	      sbc	#1
    867  f000				  -	      sta	trackn_portaspeeda,x
    868  f000				  -	      bne	rmtpp10
    869  f000				  -	      lda	trackn_portaspeed,x
    870  f000				  -	      sta	trackn_portaspeeda,x
    871  f000				  -	      lda	trackn_portafrqa,x
    872  f000				  -	      cmp	trackn_portafrqc,x
    873  f000				  -	      beq	rmtpp10
    874  f000				  -	      bcs	pps1
    875  f000				  -	      adc	trackn_portadepth,x
    876  f000				  -	      bcs	pps8
    877  f000				  -	      cmp	trackn_portafrqc,x
    878  f000				  -	      bcs	pps8
    879  f000				  -	      jmp	pps9
    880  f000				  -pps1
    881  f000				  -	      sbc	trackn_portadepth,x
    882  f000				  -	      bcc	pps8
    883  f000				  -	      cmp	trackn_portafrqc,x
    884  f000				  -	      bcs	pps9
    885  f000				  -pps8
    886  f000				  -	      lda	trackn_portafrqc,x
    887  f000				  -pps9
    888  f000				  -	      sta	trackn_portafrqa,x
    889  f000				  -rmtpp10
    890  f000				  -	      lda	rmtreg2
    891  f000				  -	      and	#$01
    892  f000				  -	      beq	rmtpp11
    893  f000				  -	      lda	trackn_portafrqa,x
    894  f000				  -	      clc
    895  f000				  -	      adc	trackn_shiftfrq,x
    896  f000				  -	      sta	trackn_audf,x
    897  f000				  -rmtpp11
    898  f000				  -	      EIF
    899  f000				  -ppnext
    900  f000				  -	      inx
    901  f000				  -	      cpx	#TRACKS
    902  f000				  -	      beq	rmt_p4
    903  f000				  -	      jmp	rmtpp1
    904  f000				  -rmt_p4
    905  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    906  f000				  -	      ldx	#3
    907  f000				  -	      lda	#0
    908  f000				  -qq0	      ora	trackn_audctl,x
    909  f000				  -	      dex
    910  f000				  -	      bpl	qq0
    911  f000				  -	      sta	v_audctl
    912  f000				  -qq1
    913  f000				  -	      ldx	v_audctl
    914  f000				  -	      ELSE
    915  f000				  -	      ldx	#0
    916  f000				  -	      stx	v_audctl
    917  f000				  -	      EIF
    918  f000				  -	      IF	FEAT_FILTER
    919  f000				  -	      IF	FEAT_FILTERG0L
    920  f000				  -	      lda	trackn_command+0
    921  f000				  -	      bpl	qq2
    922  f000				  -	      lda	trackn_audc+0
    923  f000				  -	      and	#$0f
    924  f000				  -	      beq	qq2
    925  f000				  -	      lda	trackn_audf+0
    926  f000				  -	      clc
    927  f000				  -	      adc	trackn_filter+0
    928  f000				  -	      sta	trackn_audf+2
    929  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
    930  f000				  -	      lda	trackn_audc+2
    931  f000				  -	      and	#$10
    932  f000				  -	      bne	qq1a
    933  f000				  -	      EIF
    934  f000				  -	      lda	#0
    935  f000				  -	      sta	trackn_audc+2
    936  f000				  -qq1a
    937  f000				  -	      txa
    938  f000				  -	      ora	#4
    939  f000				  -	      tax
    940  f000				  -	      EIF
    941  f000				  -qq2
    942  f000				  -	      IF	FEAT_FILTERG1L
    943  f000				  -	      lda	trackn_command+1
    944  f000				  -	      bpl	qq3
    945  f000				  -	      lda	trackn_audc+1
    946  f000				  -	      and	#$0f
    947  f000				  -	      beq	qq3
    948  f000				  -	      lda	trackn_audf+1
    949  f000				  -	      clc
    950  f000				  -	      adc	trackn_filter+1
    951  f000				  -	      sta	trackn_audf+3
    952  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
    953  f000				  -	      lda	trackn_audc+3
    954  f000				  -	      and	#$10
    955  f000				  -	      bne	qq2a
    956  f000				  -	      EIF
    957  f000				  -	      lda	#0
    958  f000				  -	      sta	trackn_audc+3
    959  f000				  -qq2a
    960  f000				  -	      txa
    961  f000				  -	      ora	#2
    962  f000				  -	      tax
    963  f000				  -	      EIF
    964  f000				  -qq3
    965  f000				  -	      IF	FEAT_FILTERG0L||FEAT_FILTERG1L
    966  f000				  -	      cpx	v_audctl
    967  f000				  -	      bne	qq5
    968  f000				  -	      EIF
    969  f000				  -	      EIF
    970  f000				  -	      IF	FEAT_BASS16
    971  f000				  -	      IF	FEAT_BASS16G1L
    972  f000				  -	      lda	trackn_command+1
    973  f000				  -	      and	#$0e
    974  f000				  -	      cmp	#6
    975  f000				  -	      bne	qq4
    976  f000				  -	      lda	trackn_audc+1
    977  f000				  -	      and	#$0f
    978  f000				  -	      beq	qq4
    979  f000				  -	      ldy	trackn_outnote+1
    980  f000				  -	      lda	frqtabbasslo,y
    981  f000				  -	      sta	trackn_audf+0
    982  f000				  -	      lda	frqtabbasshi,y
    983  f000				  -	      sta	trackn_audf+1
    984  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
    985  f000				  -	      lda	trackn_audc+0
    986  f000				  -	      and	#$10
    987  f000				  -	      bne	qq3a
    988  f000				  -	      EIF
    989  f000				  -	      lda	#0
    990  f000				  -	      sta	trackn_audc+0
    991  f000				  -qq3a
    992  f000				  -	      txa
    993  f000				  -	      ora	#$50
    994  f000				  -	      tax
    995  f000				  -	      EIF
    996  f000				  -qq4
    997  f000				  -	      IF	FEAT_BASS16G3L
    998  f000				  -	      lda	trackn_command+3
    999  f000				  -	      and	#$0e
   1000  f000				  -	      cmp	#6
   1001  f000				  -	      bne	qq5
   1002  f000				  -	      lda	trackn_audc+3
   1003  f000				  -	      and	#$0f
   1004  f000				  -	      beq	qq5
   1005  f000				  -	      ldy	trackn_outnote+3
   1006  f000				  -	      lda	frqtabbasslo,y
   1007  f000				  -	      sta	trackn_audf+2
   1008  f000				  -	      lda	frqtabbasshi,y
   1009  f000				  -	      sta	trackn_audf+3
   1010  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1011  f000				  -	      lda	trackn_audc+2
   1012  f000				  -	      and	#$10
   1013  f000				  -	      bne	qq4a
   1014  f000				  -	      EIF
   1015  f000				  -	      lda	#0
   1016  f000				  -	      sta	trackn_audc+2
   1017  f000				  -qq4a
   1018  f000				  -	      txa
   1019  f000				  -	      ora	#$28
   1020  f000				  -	      tax
   1021  f000				  -	      EIF
   1022  f000				  -	      EIF
   1023  f000				  -qq5
   1024  f000				  -	      stx	v_audctl
   1025  f000				  -	      IF	STEREO8T
   1026  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1027  f000				  -	      ldx	#3
   1028  f000				  -	      lda	#0
   1029  f000				  -qs0	      ora	trackn_audctl+4,x
   1030  f000				  -	      dex
   1031  f000				  -	      bpl	qs0
   1032  f000				  -	      sta	v_audctl2
   1033  f000				  -qs1
   1034  f000				  -	      ldx	v_audctl2
   1035  f000				  -	      ELSE
   1036  f000				  -	      ldx	#0
   1037  f000				  -	      stx	v_audctl2
   1038  f000				  -	      EIF
   1039  f000				  -	      IF	FEAT_FILTER
   1040  f000				  -	      IF	FEAT_FILTERG0R
   1041  f000				  -	      lda	trackn_command+0+4
   1042  f000				  -	      bpl	qs2
   1043  f000				  -	      lda	trackn_audc+0+4
   1044  f000				  -	      and	#$0f
   1045  f000				  -	      beq	qs2
   1046  f000				  -	      lda	trackn_audf+0+4
   1047  f000				  -	      clc
   1048  f000				  -	      adc	trackn_filter+0+4
   1049  f000				  -	      sta	trackn_audf+2+4
   1050  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1051  f000				  -	      lda	trackn_audc+2+4
   1052  f000				  -	      and	#$10
   1053  f000				  -	      bne	qs1a
   1054  f000				  -	      EIF
   1055  f000				  -	      lda	#0
   1056  f000				  -	      sta	trackn_audc+2+4
   1057  f000				  -qs1a
   1058  f000				  -	      txa
   1059  f000				  -	      ora	#4
   1060  f000				  -	      tax
   1061  f000				  -	      EIF
   1062  f000				  -qs2
   1063  f000				  -	      IF	FEAT_FILTERG1R
   1064  f000				  -	      lda	trackn_command+1+4
   1065  f000				  -	      bpl	qs3
   1066  f000				  -	      lda	trackn_audc+1+4
   1067  f000				  -	      and	#$0f
   1068  f000				  -	      beq	qs3
   1069  f000				  -	      lda	trackn_audf+1+4
   1070  f000				  -	      clc
   1071  f000				  -	      adc	trackn_filter+1+4
   1072  f000				  -	      sta	trackn_audf+3+4
   1073  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1074  f000				  -	      lda	trackn_audc+3+4
   1075  f000				  -	      and	#$10
   1076  f000				  -	      bne	qs2a
   1077  f000				  -	      EIF
   1078  f000				  -	      lda	#0
   1079  f000				  -	      sta	trackn_audc+3+4
   1080  f000				  -qs2a
   1081  f000				  -	      txa
   1082  f000				  -	      ora	#2
   1083  f000				  -	      tax
   1084  f000				  -	      EIF
   1085  f000				  -qs3
   1086  f000				  -	      IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1087  f000				  -	      cpx	v_audctl2
   1088  f000				  -	      bne	qs5
   1089  f000				  -	      EIF
   1090  f000				  -	      EIF
   1091  f000				  -	      IF	FEAT_BASS16
   1092  f000				  -	      IF	FEAT_BASS16G1R
   1093  f000				  -	      lda	trackn_command+1+4
   1094  f000				  -	      and	#$0e
   1095  f000				  -	      cmp	#6
   1096  f000				  -	      bne	qs4
   1097  f000				  -	      lda	trackn_audc+1+4
   1098  f000				  -	      and	#$0f
   1099  f000				  -	      beq	qs4
   1100  f000				  -	      ldy	trackn_outnote+1+4
   1101  f000				  -	      lda	frqtabbasslo,y
   1102  f000				  -	      sta	trackn_audf+0+4
   1103  f000				  -	      lda	frqtabbasshi,y
   1104  f000				  -	      sta	trackn_audf+1+4
   1105  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1106  f000				  -	      lda	trackn_audc+0+4
   1107  f000				  -	      and	#$10
   1108  f000				  -	      bne	qs3a
   1109  f000				  -	      EIF
   1110  f000				  -	      lda	#0
   1111  f000				  -	      sta	trackn_audc+0+4
   1112  f000				  -qs3a
   1113  f000				  -	      txa
   1114  f000				  -	      ora	#$50
   1115  f000				  -	      tax
   1116  f000				  -	      EIF
   1117  f000				  -qs4
   1118  f000				  -	      IF	FEAT_BASS16G3R
   1119  f000				  -	      lda	trackn_command+3+4
   1120  f000				  -	      and	#$0e
   1121  f000				  -	      cmp	#6
   1122  f000				  -	      bne	qs5
   1123  f000				  -	      lda	trackn_audc+3+4
   1124  f000				  -	      and	#$0f
   1125  f000				  -	      beq	qs5
   1126  f000				  -	      ldy	trackn_outnote+3+4
   1127  f000				  -	      lda	frqtabbasslo,y
   1128  f000				  -	      sta	trackn_audf+2+4
   1129  f000				  -	      lda	frqtabbasshi,y
   1130  f000				  -	      sta	trackn_audf+3+4
   1131  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1132  f000				  -	      lda	trackn_audc+2+4
   1133  f000				  -	      and	#$10
   1134  f000				  -	      bne	qs4a
   1135  f000				  -	      EIF
   1136  f000				  -	      lda	#0
   1137  f000				  -	      sta	trackn_audc+2+4
   1138  f000				  -qs4a
   1139  f000				  -	      txa
   1140  f000				  -	      ora	#$28
   1141  f000				  -	      tax
   1142  f000				  -	      EIF
   1143  f000				  -	      EIF
   1144  f000				  -qs5
   1145  f000				  -	      stx	v_audctl2
   1146  f000				  -	      EIF
   1147  f000				  -rmt_p5
   1148  f000				  -	      lda	v_ainstrspeed
   1149  f000				  -	      rts
   1150  f000				  -SetPokey
   1151  f000				  -	      IF	STEREO8T
   1152  f000				  -	      ldy	v_audctl2
   1153  f000				  -	      lda	trackn_audf+0+4
   1154  f000				  -	      ldx	trackn_audf+0
   1155  f000				  -	      sta	POKEY_BASE_S+$00
   1156  f000				  -	      stx	POKEY_BASE+$00
   1157  f000				  -	      lda	trackn_audc+0+4
   1158  f000				  -	      ldx	trackn_audc+0
   1159  f000				  -	      sta	POKEY_BASE_S+$01
   1160  f000				  -	      stx	POKEY_BASE+$01
   1161  f000				  -	      lda	trackn_audf+1+4
   1162  f000				  -	      ldx	trackn_audf+1
   1163  f000				  -	      sta	POKEY_BASE_S+$02
   1164  f000				  -	      stx	POKEY_BASE+$02
   1165  f000				  -	      lda	trackn_audc+1+4
   1166  f000				  -	      ldx	trackn_audc+1
   1167  f000				  -	      sta	POKEY_BASE_S+$03
   1168  f000				  -	      stx	POKEY_BASE+$03
   1169  f000				  -	      lda	trackn_audf+2+4
   1170  f000				  -	      ldx	trackn_audf+2
   1171  f000				  -	      sta	POKEY_BASE_S+$04
   1172  f000				  -	      stx	POKEY_BASE+$04
   1173  f000				  -	      lda	trackn_audc+2+4
   1174  f000				  -	      ldx	trackn_audc+2
   1175  f000				  -	      sta	POKEY_BASE_S+$05
   1176  f000				  -	      stx	POKEY_BASE+$05
   1177  f000				  -	      lda	trackn_audf+3+4
   1178  f000				  -	      ldx	trackn_audf+3
   1179  f000				  -	      sta	POKEY_BASE_S+$06
   1180  f000				  -	      stx	POKEY_BASE+$06
   1181  f000				  -	      lda	trackn_audc+3+4
   1182  f000				  -	      ldx	trackn_audc+3
   1183  f000				  -	      sta	POKEY_BASE_S+$07
   1184  f000				  -	      stx	POKEY_BASE+$07
   1185  f000				  -	      lda	v_audctl
   1186  f000				  -	      sty	POKEY_BASE_S+$08
   1187  f000				  -	      sta	POKEY_BASE+$08
   1188  f000				  -	      ELSE
   1189  f000				  -
   1190  f000				  -	      ifconst	RMTVOLUME
   1191  f000				  -	      lda	rmtvolume
   1192  f000				  -	      sta	fourbitfadevalueint
   1193  f000				  -	      endif
   1194  f000				  -	      ldy	v_audctl
   1195  f000				  -	      ldx	trackn_audf+0
   1196  f000				  -	      lda	trackn_audc+0
   1197  f000				  -	      ifconst	RMTVOLUME
   1198  f000				  -	      jsr	fourbitfadeint
   1199  f000				  -	      endif
   1200  f000				  -	      stx	POKEY_BASE+$00+0
   1201  f000				  -	      stx	POKEY_BASE+$00+0
   1202  f000				  -	      sta	POKEY_BASE+$01+0
   1203  f000				  -	      sta	POKEY_BASE+$01+0
   1204  f000				  -
   1205  f000				  -	      ldx	trackn_audf+1
   1206  f000				  -	      lda	trackn_audc+1
   1207  f000				  -	      ifconst	RMTVOLUME
   1208  f000				  -	      jsr	fourbitfadeint
   1209  f000				  -	      endif
   1210  f000				  -	      stx	POKEY_BASE+$00+2
   1211  f000				  -	      stx	POKEY_BASE+$00+2
   1212  f000				  -	      sta	POKEY_BASE+$01+2
   1213  f000				  -	      sta	POKEY_BASE+$01+2
   1214  f000				  -
   1215  f000				  -	      ldx	trackn_audf+2
   1216  f000				  -	      lda	trackn_audc+2
   1217  f000				  -	      ifconst	RMTVOLUME
   1218  f000				  -	      jsr	fourbitfadeint
   1219  f000				  -	      endif
   1220  f000				  -	      stx	POKEY_BASE+$00+4
   1221  f000				  -	      stx	POKEY_BASE+$00+4
   1222  f000				  -	      sta	POKEY_BASE+$01+4
   1223  f000				  -	      sta	POKEY_BASE+$01+4
   1224  f000				  -
   1225  f000				  -	      ldx	trackn_audf+3
   1226  f000				  -	      lda	trackn_audc+3
   1227  f000				  -	      ifconst	RMTVOLUME
   1228  f000				  -	      jsr	fourbitfadeint
   1229  f000				  -	      endif
   1230  f000				  -	      stx	POKEY_BASE+$00+6
   1231  f000				  -	      stx	POKEY_BASE+$00+6
   1232  f000				  -	      sta	POKEY_BASE+$01+6
   1233  f000				  -	      sta	POKEY_BASE+$01+6
   1234  f000				  -
   1235  f000				  -	      sty	POKEY_BASE+$08
   1236  f000				  -	      sty	POKEY_BASE+$08
   1237  f000				  -
   1238  f000				  -	      EIF
   1239  f000				  -	      rts
   1240  f000				  -SetUpInstrumentY2
   1241  f000				  -	      lda	(p_instrstable),y
   1242  f000				  -	      sta	trackn_instrdb,x
   1243  f000				  -	      sta	_nt
   1244  f000				  -	      iny
   1245  f000				  -	      lda	(p_instrstable),y
   1246  f000				  -	      sta	trackn_instrhb,x
   1247  f000				  -	      sta	_nt+1
   1248  f000				  -	      ldy	#0
   1249  f000				  -	      lda	(_nt),y
   1250  f000				  -	      sta	trackn_tableend,x
   1251  f000				  -	      clc
   1252  f000				  -	      adc	#1
   1253  f000				  -	      sta	trackn_instridx,x
   1254  f000				  -	      iny
   1255  f000				  -	      lda	(_nt),y
   1256  f000				  -	      sta	trackn_tablelop,x
   1257  f000				  -	      iny
   1258  f000				  -	      lda	(_nt),y
   1259  f000				  -	      sta	trackn_instrlen,x
   1260  f000				  -	      iny
   1261  f000				  -	      lda	(_nt),y
   1262  f000				  -	      sta	trackn_instrlop,x
   1263  f000				  -	      iny
   1264  f000				  -	      lda	(_nt),y
   1265  f000				  -	      sta	trackn_tabletypespeed,x
   1266  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1267  f000				  -	      and	#$3f
   1268  f000				  -	      EIF
   1269  f000				  -	      sta	trackn_tablespeeda,x
   1270  f000				  -	      IF	FEAT_TABLEMODE
   1271  f000				  -	      lda	(_nt),y
   1272  f000				  -	      and	#$40
   1273  f000				  -	      sta	trackn_tablemode,x
   1274  f000				  -	      EIF
   1275  f000				  -	      iny
   1276  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1277  f000				  -	      lda	(_nt),y
   1278  f000				  -	      sta	trackn_audctl,x
   1279  f000				  -	      EIF
   1280  f000				  -	      iny
   1281  f000				  -	      lda	(_nt),y
   1282  f000				  -	      sta	trackn_volumeslidedepth,x
   1283  f000				  -	      iny
   1284  f000				  -	      lda	(_nt),y
   1285  f000				  -	      sta	trackn_volumemin,x
   1286  f000				  -	      iny
   1287  f000				  -	      lda	(_nt),y
   1288  f000				  -	      sta	trackn_effdelay,x
   1289  f000				  -	      iny
   1290  f000				  -	      lda	(_nt),y
   1291  f000				  -	      tay
   1292  f000				  -	      lda	vibtabbeg,y
   1293  f000				  -	      sta	trackn_effvibratoa,x
   1294  f000				  -	      sta	trackn_effvibratobeg,x
   1295  f000				  -	      lda	vibtabbeg+1,y
   1296  f000				  -	      sta	trackn_effvibratoend,x
   1297  f000				  -	      ldy	#10
   1298  f000				  -	      lda	(_nt),y
   1299  f000				  -	      sta	trackn_effshift,x
   1300  f000				  -	      lda	#128
   1301  f000				  -	      sta	trackn_volumeslidevalue,x
   1302  f000				  -	      lda	#0
   1303  f000				  -	      sta	trackn_instrreachend,x
   1304  f000				  -	      sta	trackn_shiftfrq,x
   1305  f000				  -	      lda	#INSTRPAR
   1306  f000				  -	      sta	trackn_tablea,x
   1307  f000				  -	      tay
   1308  f000				  -	      lda	(_nt),y
   1309  f000				  -	      sta	trackn_tablenote,x
   1310  f000				  -	      IF	FEAT_FILTER
   1311  f000				  -	      lda	#1
   1312  f000				  -	      sta	trackn_filter,x
   1313  f000				  -	      EIF
   1314  f000				  -	      rts
   1315  f000				  -InstrumentsEffects
   1316  f000				  -	      lda	trackn_effdelay,x
   1317  f000				  -	      beq	ei2
   1318  f000				  -	      tay
   1319  f000				  -	      dey
   1320  f000				  -	      bne	ei1
   1321  f000				  -	      lda	trackn_shiftfrq,x
   1322  f000				  -	      clc
   1323  f000				  -	      adc	trackn_effshift,x
   1324  f000				  -	      clc
   1325  f000				  -	      ldy	trackn_effvibratoa,x
   1326  f000				  -	      adc	vib0,y
   1327  f000				  -	      sta	trackn_shiftfrq,x
   1328  f000				  -	      iny
   1329  f000				  -	      tya
   1330  f000				  -	      cmp	trackn_effvibratoend,x
   1331  f000				  -	      bne	ei1a
   1332  f000				  -	      lda	trackn_effvibratobeg,x
   1333  f000				  -ei1a
   1334  f000				  -	      sta	trackn_effvibratoa,x
   1335  f000				  -	      jmp	ei2
   1336  f000				  -ei1
   1337  f000				  -	      tya
   1338  f000				  -	      sta	trackn_effdelay,x
   1339  f000				  -ei2
   1340  f000				  -	      lda	trackn_tableend,x
   1341  f000				  -	      cmp	#INSTRPAR
   1342  f000				  -	      beq	ei3
   1343  f000				  -	      lda	trackn_tablespeeda,x
   1344  f000				  -	      bpl	ei2f
   1345  f000				  -ei2c
   1346  f000				  -	      lda	trackn_tablea,x
   1347  f000				  -	      clc
   1348  f000				  -	      adc	#1
   1349  f000				  -	      cmp	trackn_tableend,x
   1350  f000				  -	      bcc	ei2a
   1351  f000				  -	      beq	ei2a
   1352  f000				  -	      lda	trackn_tablelop,x
   1353  f000				  -ei2a
   1354  f000				  -	      sta	trackn_tablea,x
   1355  f000				  -	      lda	trackn_instrdb,x
   1356  f000				  -	      sta	_nt
   1357  f000				  -	      lda	trackn_instrhb,x
   1358  f000				  -	      sta	_nt+1
   1359  f000				  -	      ldy	trackn_tablea,x
   1360  f000				  -	      lda	(_nt),y
   1361  f000				  -	      IF	FEAT_TABLEMODE
   1362  f000				  -	      ldy	trackn_tablemode,x
   1363  f000				  -	      beq	ei2e
   1364  f000				  -	      clc
   1365  f000				  -	      adc	trackn_tablenote,x
   1366  f000				  -ei2e
   1367  f000				  -	      EIF
   1368  f000				  -	      sta	trackn_tablenote,x
   1369  f000				  -	      lda	trackn_tabletypespeed,x
   1370  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1371  f000				  -	      and	#$3f
   1372  f000				  -	      EIF
   1373  f000				  -ei2f
   1374  f000				  -	      sec
   1375  f000				  -	      sbc	#1
   1376  f000				  -	      sta	trackn_tablespeeda,x
   1377  f000				  -ei3
   1378  f000				  -	      lda	trackn_instrreachend,x
   1379  f000				  -	      bpl	ei4
   1380  f000				  -	      lda	trackn_volume,x
   1381  f000				  -	      beq	ei4
   1382  f000				  -	      cmp	trackn_volumemin,x
   1383  f000				  -	      beq	ei4
   1384  f000				  -	      bcc	ei4
   1385  f000				  -	      tay
   1386  f000				  -	      lda	trackn_volumeslidevalue,x
   1387  f000				  -	      clc
   1388  f000				  -	      adc	trackn_volumeslidedepth,x
   1389  f000				  -	      sta	trackn_volumeslidevalue,x
   1390  f000				  -	      bcc	ei4
   1391  f000				  -	      tya
   1392  f000				  -	      sbc	#16
   1393  f000				  -	      sta	trackn_volume,x
   1394  f000				  -ei4
   1395  f000				  -	      jmp	returnfromInstrumentsEffects
   1396  f000				  -
   1397  f000				  -rmtmoduleend
   1398  f000				  -	      echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1399  f000				  -	      echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1400  f000				  -
   1401  f000					      endif		; RMT
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3324  f000					      endif
   3325  f000					      ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  f000					      include	7800vox.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000							; AtariVox 7800basic wrapper
      4  f000
      5  f000							; to be called with
      6  f000							; A=# of bytes
      7  f000							;
      8  f000
      9  f000				  -	      ifconst	HSSUPPORT
     10  f000				  -
     11  f000				  -_7800voxstart
     12  f000				  -
     13  f000				  -AVoxReadBytes
     14  f000				  -	      sta	temp8
     15  f000				  -	      jsr	i2c_startwrite
     16  f000				  -	      bcs	eeprom_error
     17  f000				  -
     18  f000				  -	      lda	HSVoxHi
     19  f000				  -	      jsr	i2c_txbyte
     20  f000				  -	      lda	HSVoxLo
     21  f000				  -	      jsr	i2c_txbyte
     22  f000				  -	      jsr	i2c_stopwrite
     23  f000				  -
     24  f000				  -	      jsr	i2c_startread
     25  f000				  -
     26  f000				  -	      ldx	#0
     27  f000				  -AVoxReadBytesLoop
     28  f000				  -	      jsr	i2c_rxbyte
     29  f000				  -	      sta	eeprombuffer,x
     30  f000				  -	      inx
     31  f000				  -	      cpx	temp8
     32  f000				  -	      bne	AVoxReadBytesLoop
     33  f000				  -	      jsr	i2c_stopread
     34  f000				  -	      lda	#0
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -			; to be called with
     38  f000				  -			; A=# of bytes
     39  f000				  -			;
     40  f000				  -
     41  f000				  -AVoxWriteBytes
     42  f000				  -	      sta	temp8
     43  f000				  -	      jsr	i2c_startwrite
     44  f000				  -	      bcs	eeprom_error
     45  f000				  -
     46  f000				  -	      lda	HSVoxHi
     47  f000				  -	      jsr	i2c_txbyte
     48  f000				  -	      lda	HSVoxLo
     49  f000				  -	      jsr	i2c_txbyte
     50  f000				  -
     51  f000				  -	      ldx	#$00
     52  f000				  -AVoxWriteBytesLoop
     53  f000				  -	      lda	eeprombuffer,x
     54  f000				  -	      jsr	i2c_txbyte
     55  f000				  -	      inx
     56  f000				  -	      cpx	temp8
     57  f000				  -	      bne	AVoxWriteBytesLoop
     58  f000				  -	      jsr	i2c_stopwrite
     59  f000				  -
     60  f000				  -	      lda	#0
     61  f000				  -	      rts
     62  f000				  -
     63  f000				  -eeprom_error
     64  f000				  -	      lda	#$ff
     65  f000				  -	      rts
     66  f000				  -
     67  f000				  -AVoxDetect
     68  f000				  -
     69  f000				  -	      jsr	i2c_startwrite
     70  f000				  -	      bcs	eeprom_error
     71  f000				  -	      lda	#$30
     72  f000				  -	      jsr	i2c_txbyte
     73  f000				  -	      lda	#$00
     74  f000				  -	      jsr	i2c_txbyte
     75  f000				  -	      jsr	i2c_stopwrite
     76  f000				  -	      rts
     77  f000				  -
     78  f000				  -	      include	"i2c7800.inc"
     79  f000				  -	      I2C_SUBS	temp9
     80  f000				  -
     81  f000				  -_7800voxend
     82  f000				  -
     83  f000				  -	      echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  f000				  -
     85  f000					      endif
     86  f000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3327  f000					      endif
   3328  f000					      ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  f000					      include	pokeysound.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	pokeysupport
      5  f000				  -
      6  f000				  -pokeysoundmodulestart
      7  f000				  -
      8  f000				  -mutepokey
      9  f000				  -	      lda	#0
     10  f000				  -	      ldy	#7
     11  f000				  -mutepokeyloop
     12  f000				  -	      sta	pokey1pointlo,y
     13  f000				  -	      sta	(pokeybaselo),y
     14  f000				  -	      dey
     15  f000				  -	      bpl	mutepokeyloop
     16  f000				  -	      rts
     17  f000				  -
     18  f000				  -checkpokeyplaying
     19  f000				  -	      ldx	#6
     20  f000				  -checkpokeyplayingloop
     21  f000				  -	      lda	pokey1pointlo,x
     22  f000				  -	      ora	pokey1pointhi,x
     23  f000				  -	      beq	pokeychannelinactive
     24  f000				  -	      jsr	playpokeysfxA	; x=channel*2
     25  f000				  -pokeychannelinactive
     26  f000				  -	      dex
     27  f000				  -	      dex
     28  f000				  -	      bpl	checkpokeyplayingloop
     29  f000				  -	      rts
     30  f000				  -
     31  f000				  -playpokeysfxA
     32  f000				  -	      txa
     33  f000				  -	      tay
     34  f000				  -	      lda	pokey1tick,x
     35  f000				  -	      beq	playpokeysfxAcont
     36  f000				  -	      sec
     37  f000				  -	      sbc	#1
     38  f000				  -	      sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  f000				  -	      rts
     40  f000				  -
     41  f000				  -playpokeysfxAcont
     42  f000				  -	      lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  f000				  -	      sta	pokey1tick,x
     44  f000				  -
     45  f000				  -	      lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  f000				  -	      beq	playpokeysfxAcont2
     47  f000				  -	      sec
     48  f000				  -	      sbc	#1
     49  f000				  -	      sta	pokey1priority,x
     50  f000				  -playpokeysfxAcont2
     51  f000				  -
     52  f000				  -			; *** FREQUENCY
     53  f000				  -	      lda	(pokey1pointlo,x)
     54  f000				  -	      sta	inttemp1
     55  f000				  -	      clc
     56  f000				  -	      adc	pokey1offset,x	; take into account any pitch modification
     57  f000				  -	      sta	(pokeybaselo),y	; PAUDF0,0
     58  f000				  -
     59  f000				  -			;advance the data pointer +1
     60  f000				  -	      inc	pokey1pointlo,x
     61  f000				  -	      bne	skippokeyhiinc1
     62  f000				  -	      inc	pokey1pointhi,x
     63  f000				  -skippokeyhiinc1
     64  f000				  -
     65  f000				  -			; *** WAVE
     66  f000				  -	      lda	(pokey1pointlo,x)
     67  f000				  -	      asl
     68  f000				  -	      asl
     69  f000				  -	      asl
     70  f000				  -	      asl		; x16
     71  f000				  -
     72  f000				  -			;advance the data pointer +1
     73  f000				  -	      inc	pokey1pointlo,x
     74  f000				  -	      bne	skippokeyhiinc2
     75  f000				  -	      inc	pokey1pointhi,x
     76  f000				  -skippokeyhiinc2
     77  f000				  -
     78  f000				  -	      ora	(pokey1pointlo,x)
     79  f000				  -	      iny
     80  f000				  -	      sta	(pokeybaselo),y
     81  f000				  -
     82  f000				  -	      ora	inttemp1	; check if F|C|V=0
     83  f000				  -	      beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  f000				  -
     85  f000				  -			; advance the pointer +1, on to the next sound chunk
     86  f000				  -	      inc	pokey1pointlo,x
     87  f000				  -	      bne	skippokeyhiinc3
     88  f000				  -	      inc	pokey1pointhi,x
     89  f000				  -skippokeyhiinc3
     90  f000				  -	      rts
     91  f000				  -
     92  f000				  -zeropokeypoint
     93  f000				  -	      sta	pokey1pointlo,x
     94  f000				  -	      sta	pokey1pointhi,x
     95  f000				  -	      sta	pokey1priority,x
     96  f000				  -	      rts
     97  f000				  -
     98  f000				  -schedulepokeysfx
     99  f000				  -	      ldx	#6
    100  f000				  -schedulepokeysfxloop
    101  f000				  -	      lda	pokey1pointlo,x
    102  f000				  -	      ora	pokey1pointhi,x
    103  f000				  -	      bne	schedulespokeysearch
    104  f000				  -	      jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  f000				  -schedulespokeysearch
    106  f000				  -	      dex
    107  f000				  -	      dex
    108  f000				  -	      bpl	schedulepokeysfxloop
    109  f000				  -
    110  f000				  -			; if we're here, all 4 channels are presently playing a sound...
    111  f000				  -	      ldy	#1
    112  f000				  -	      lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  f000				  -	      bne	schedulepokeysfxcont1
    114  f000				  -	      rts		; ...and skip it if it's 0 priority
    115  f000				  -schedulepokeysfxcont1
    116  f000				  -
    117  f000				  -			; figure out which current sound has the lowest priority...
    118  f000				  -	      lda	#0
    119  f000				  -	      sta	temp8
    120  f000				  -	      lda	pokey1priority
    121  f000				  -	      sta	temp9
    122  f000				  -	      ldx	#6
    123  f000				  -findlowprioritypokeyloop
    124  f000				  -	      lda	pokey1priority,x
    125  f000				  -	      cmp	temp9
    126  f000				  -	      bcs	findlowprioritypokeyloopcontinue
    127  f000				  -	      sta	temp9
    128  f000				  -	      stx	temp8
    129  f000				  -findlowprioritypokeyloopcontinue
    130  f000				  -	      dex
    131  f000				  -	      dex
    132  f000				  -	      bne	findlowprioritypokeyloop
    133  f000				  -	      ldx	temp8	; the low priority channel we'll interrupt
    134  f000				  -
    135  f000				  -schedulepokeyX
    136  f000				  -			;called with X=2*pokey channel to play on...
    137  f000				  -	      ldy	#1	; get priority and sound-resolution (in frames)
    138  f000				  -	      lda	(sfxinstrumentlo),y
    139  f000				  -	      sta	pokey1priority,x
    140  f000				  -	      iny
    141  f000				  -	      lda	(sfxinstrumentlo),y
    142  f000				  -	      sta	pokey1frames,x
    143  f000				  -
    144  f000				  -	      lda	sfxinstrumentlo
    145  f000				  -	      clc
    146  f000				  -	      adc	#3
    147  f000				  -	      sta	pokey1pointlo,x
    148  f000				  -	      lda	sfxinstrumenthi
    149  f000				  -	      adc	#0
    150  f000				  -	      sta	pokey1pointhi,x
    151  f000				  -	      lda	sfxpitchoffset
    152  f000				  -	      sta	pokey1offset,x
    153  f000				  -	      lda	#0
    154  f000				  -	      sta	pokey1tick,x
    155  f000				  -	      rts
    156  f000				  -
    157  f000				  -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  f000				  -			; and the standard $4000 location.
    159  f000				  -			; if pokey the pokey is present, this routine will reset it.
    160  f000				  -	      ifconst	pokeyaddress
    161  f000				  -detectpokeylocation
    162  f000				  -	      lda	#<pokeyaddress
    163  f000				  -	      sta	pokeybaselo
    164  f000				  -	      lda	#>pokeyaddress
    165  f000				  -	      sta	pokeybasehi
    166  f000				  -	      lda	#$ff
    167  f000				  -	      sta	pokeydetected
    168  f000				  -
    169  f000				  -	      if	pokeyaddress = $450
    170  f000				  -	      lda	XCTRL1s
    171  f000				  -	      ora	#%00010100
    172  f000				  -	      sta	XCTRL1s
    173  f000				  -	      sta	XCTRL1
    174  f000				  -	      endif
    175  f000				  -
    176  f000				  -
    177  f000				  -	      lda	#0
    178  f000				  -	      ldy	#15
    179  f000				  -clearpokeyloop
    180  f000				  -	      sta	(pokeybase),y
    181  f000				  -	      dey
    182  f000				  -	      bpl	clearpokeyloop
    183  f000				  -			; take pokey out of reset...
    184  f000				  -	      ldy	#PSKCTL
    185  f000				  -	      lda	#3
    186  f000				  -	      sta	(pokeybase),y
    187  f000				  -	      ldy	#PAUDCTL
    188  f000				  -	      lda	#0
    189  f000				  -	      sta	(pokeybase),y
    190  f000				  -	      rts
    191  f000				  -	      else		; !pokeyaddress
    192  f000				  -detectpokeylocation
    193  f000				  -			;XBoard/XM...
    194  f000				  -	      ldx	#2
    195  f000				  -detectpokeyloop
    196  f000				  -	      lda	XCTRL1s
    197  f000				  -	      ora	#%00010100
    198  f000				  -	      and	POKEYXMMASK,x
    199  f000				  -	      sta	XCTRL1s
    200  f000				  -	      sta	XCTRL1
    201  f000				  -
    202  f000				  -	      lda	POKEYCHECKLO,x
    203  f000				  -	      sta	pokeybaselo
    204  f000				  -	      lda	POKEYCHECKHI,x
    205  f000				  -	      sta	pokeybasehi
    206  f000				  -	      jsr	checkforpokey
    207  f000				  -	      lda	pokeydetected
    208  f000				  -	      beq	foundpokeychip
    209  f000				  -	      dex
    210  f000				  -	      bpl	detectpokeyloop
    211  f000				  -foundpokeychip
    212  f000				  -	      eor	#$ff	; invert state for 7800basic if...then test
    213  f000				  -	      sta	pokeydetected
    214  f000				  -	      rts
    215  f000				  -
    216  f000				  -POKEYXMMASK
    217  f000				  -			;     XM POKEY on    XM POKEY off   XM POKEY off
    218  f000				  -	      .byte	%11111111, %11101111, %11101111
    219  f000				  -
    220  f000				  -POKEYCHECKLO
    221  f000				  -	      .byte	<$0450, <$0450, <$4000
    222  f000				  -POKEYCHECKHI
    223  f000				  -	      .byte	>$0450, >$0450, >$4000
    224  f000				  -
    225  f000				  -checkforpokey
    226  f000				  -	      ldy	#$0f
    227  f000				  -	      lda	#$00
    228  f000				  -	      sta	pokeydetected	; start off by assuming pokey will be detected
    229  f000				  -resetpokeyregistersloop
    230  f000				  -	      sta	(pokeybase),y
    231  f000				  -	      dey
    232  f000				  -	      bpl	resetpokeyregistersloop
    233  f000				  -
    234  f000				  -	      ldy	#PAUDCTL
    235  f000				  -	      sta	(pokeybase),y
    236  f000				  -	      ldy	#PSKCTL
    237  f000				  -	      sta	(pokeybase),y
    238  f000				  -
    239  f000				  -			; let the dust settle...
    240  f000				  -	      nop
    241  f000				  -	      nop
    242  f000				  -	      nop
    243  f000				  -
    244  f000				  -	      lda	#4
    245  f000				  -	      sta	temp9
    246  f000				  -pokeycheckloop1
    247  f000				  -			; we're in reset, so the RANDOM register should read $ff...
    248  f000				  -	      ldy	#PRANDOM
    249  f000				  -	      lda	(pokeybase),y
    250  f000				  -	      cmp	#$ff
    251  f000				  -	      bne	nopokeydetected
    252  f000				  -	      dec	temp9
    253  f000				  -	      bne	pokeycheckloop1
    254  f000				  -
    255  f000				  -			; take pokey out of reset...
    256  f000				  -	      ldy	#PSKCTL
    257  f000				  -	      lda	#3
    258  f000				  -	      sta	(pokeybase),y
    259  f000				  -	      ldy	#PAUDCTL
    260  f000				  -	      lda	#0
    261  f000				  -	      sta	(pokeybase),y
    262  f000				  -
    263  f000				  -			; let the dust settle again...
    264  f000				  -	      nop
    265  f000				  -	      nop
    266  f000				  -	      nop
    267  f000				  -
    268  f000				  -	      lda	#4
    269  f000				  -	      sta	temp9
    270  f000				  -pokeycheckloop2
    271  f000				  -			; we're out of reset, so RANDOM should read non-$ff...
    272  f000				  -	      ldy	#PRANDOM
    273  f000				  -	      lda	(pokeybase),y
    274  f000				  -	      cmp	#$ff
    275  f000				  -	      beq	skippokeycheckreturn
    276  f000				  -	      rts
    277  f000				  -skippokeycheckreturn
    278  f000				  -	      dec	temp9
    279  f000				  -	      bne	pokeycheckloop2
    280  f000				  -nopokeydetected
    281  f000				  -	      dec	pokeydetected	; pokeydetected=#$ff
    282  f000				  -	      rts
    283  f000				  -
    284  f000				  -	      endif		; !pokeyaddress
    285  f000				  -
    286  f000				  -pokeysoundmoduleend
    287  f000				  -
    288  f000				  -	      echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes)"
    289  f000				  -
    290  f000					      endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3330  f000					      endif
   3331  f000					      ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  f000					      include	tracker.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	MUSICTRACKER
      5  f000				  -
      6  f000				  -trackerstart
      7  f000				  -
      8  f000				  -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  f000				  -			; ** the player operates on a 16th note grid.
     10  f000				  -
     11  f000				  -servicesongover
     12  f000				  -	      rts
     13  f000				  -servicesong
     14  f000				  -	      lda	songtempo
     15  f000				  -	      beq	servicesongover	; ** if song is off/paused then return
     16  f000				  -servicesongcontinue
     17  f000				  -	      lda	sfxschedulelock
     18  f000				  -	      sta	sfxschedulemissed
     19  f000				  -	      bne	servicesongover
     20  f000				  -	      lda	songtempo
     21  f000				  -	      clc
     22  f000				  -	      adc	songtick	; add songtempo to songtick until it rolls over
     23  f000				  -	      sta	songtick	; this is how we break away from 50/60Hz timing.
     24  f000				  -	      bcc	servicesongover
     25  f000				  -			; ** if we're here a new 16th note has passed
     26  f000				  -			; ** check if a new note is due on any of the 4 channels
     27  f000				  -servicesongredo
     28  f000				  -	      ldx	#3
     29  f000				  -checkchannelloop
     30  f000				  -	      dec	songchannel1busywait,x
     31  f000				  -	      bpl	carryoncheckingchannel
     32  f000				  -	      txa
     33  f000				  -	      pha		; save X for the loop
     34  f000				  -	      jsr	processsongdata
     35  f000				  -	      pla		; restore X for the loop
     36  f000				  -	      tax
     37  f000				  -carryoncheckingchannel
     38  f000				  -	      dex
     39  f000				  -	      bpl	checkchannelloop
     40  f000				  -	      lda	inactivechannelcount
     41  f000				  -	      cmp	#15
     42  f000				  -	      bne	skipstopsong
     43  f000				  -	      lda	songloops
     44  f000				  -	      bne	doasongloop
     45  f000				  -			;lda #0
     46  f000				  -	      sta	songtempo	; all channels are done. stop the song
     47  f000				  -	      rts
     48  f000				  -doasongloop
     49  f000				  -	      bmi	skipsongloopadjust
     50  f000				  -	      dec	songloops
     51  f000				  -skipsongloopadjust
     52  f000				  -	      jsr	setsongchannels
     53  f000				  -	      jmp	servicesongredo
     54  f000				  -skipstopsong
     55  f000				  -	      rts
     56  f000				  -
     57  f000				  -processsongdata
     58  f000				  -			; channel needs processing
     59  f000				  -			; X=channel #
     60  f000				  -
     61  f000				  -	      txa
     62  f000				  -	      clc
     63  f000				  -	      adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     64  f000				  -	      tay
     65  f000				  -
     66  f000				  -
     67  f000				  -			; ** indirect x is cumbersome with mult-byte commands.
     68  f000				  -			; ** setup a pointer to the song data for indirect y addressing.
     69  f000				  -	      lda	songchannel1layer1lo,y
     70  f000				  -	      sta	songdatalo
     71  f000				  -	      lda	songchannel1layer1hi,y
     72  f000				  -	      sta	songdatahi
     73  f000				  -	      ora	songdatalo
     74  f000				  -	      bne	channelhasdata
     75  f000				  -			;channel data is pointing at $0000
     76  f000				  -	      lda	#$7F
     77  f000				  -	      sta	songchannel1busywait,x	; skip a bunch of notes
     78  f000				  -setchannelcountbits
     79  f000				  -	      lda	channel2bits,x
     80  f000				  -	      ora	inactivechannelcount
     81  f000				  -	      sta	inactivechannelcount
     82  f000				  -	      rts
     83  f000				  -channelhasdata
     84  f000				  -
     85  f000				  -	      sty	songstackindex
     86  f000				  -	      ldy	#0
     87  f000				  -	      lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     88  f000				  -	      cmp	#$ff
     89  f000				  -	      bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     90  f000				  -	      jmp	handlechannelEOD
     91  f000				  -
     92  f000				  -carryoncheckingdatatype
     93  f000				  -	      and	#$F0
     94  f000				  -	      cmp	#$C0
     95  f000				  -	      beq	handlechannelrest	; 0000XXXX=rest
     96  f000				  -	      cmp	#$F0
     97  f000				  -	      beq	handlemultibytecommand
     98  f000				  -	      cmp	#$D0
     99  f000				  -	      beq	handlesemiup
    100  f000				  -	      cmp	#$E0
    101  f000				  -	      beq	handlesemidown
    102  f000				  -handlenotedata
    103  f000				  -			; ** TODO: note playing is a terrible choice for fall-through
    104  f000				  -
    105  f000				  -			; ** its simple note data, prepare arguments for schedulesfx
    106  f000				  -
    107  f000				  -			; ** set the note length
    108  f000				  -	      lda	(songdatalo),y
    109  f000				  -	      and	#$0F
    110  f000				  -	      sta	songchannel1busywait,x
    111  f000				  -
    112  f000				  -			; ** load the instrument
    113  f000				  -	      lda	songchannel1instrumentlo,x
    114  f000				  -	      sta	sfxinstrumentlo
    115  f000				  -	      lda	songchannel1instrumenthi,x
    116  f000				  -	      sta	sfxinstrumenthi
    117  f000				  -
    118  f000				  -			; ** get the note, and transpose
    119  f000				  -	      lda	(songdatalo),y
    120  f000				  -	      lsr
    121  f000				  -	      lsr
    122  f000				  -	      lsr
    123  f000				  -	      lsr
    124  f000				  -	      clc
    125  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    126  f000				  -			; ** its up the respective SFX scheduler to handle and save the note data
    127  f000				  -	      sta	sfxnoteindex
    128  f000				  -
    129  f000				  -	      lda	#0
    130  f000				  -	      sta	sfxpitchoffset
    131  f000				  -
    132  f000				  -	      jsr	schedulesfx
    133  f000				  -
    134  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    135  f000				  -
    136  f000				  -handlechannelrest
    137  f000				  -			; ** set the note length
    138  f000				  -	      lda	(songdatalo),y
    139  f000				  -	      and	#$0F
    140  f000				  -	      sta	songchannel1busywait,x
    141  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    142  f000				  -
    143  f000				  -handlesemiup
    144  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    145  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    146  f000				  -	      clc
    147  f000				  -handlesemidownentry
    148  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    149  f000				  -	      sta	songchannel1transpose,x
    150  f000				  -	      jsr	advancethesongpointer1byte
    151  f000				  -	      jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    152  f000				  -
    153  f000				  -handlesemidown
    154  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    155  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    156  f000				  -	      eor	#$ff	; ** its easier if we negate it, and then add it instead.
    157  f000				  -	      sec
    158  f000				  -	      jmp	handlesemidownentry
    159  f000				  -
    160  f000				  -handlemultibytecommand
    161  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    162  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    163  f000				  -	      cmp	#$08	; ** load new instrument?
    164  f000				  -	      bne	nothandleinstrumentchange
    165  f000				  -handleinstrumentchange
    166  f000				  -	      iny
    167  f000				  -	      lda	(songdatalo),y
    168  f000				  -	      sta	songchannel1instrumentlo,x
    169  f000				  -	      iny
    170  f000				  -	      lda	(songdatalo),y
    171  f000				  -	      sta	songchannel1instrumenthi,x
    172  f000				  -	      lda	#3
    173  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    174  f000				  -	      jmp	processsongdata
    175  f000				  -
    176  f000				  -nothandleinstrumentchange
    177  f000				  -	      cmp	#$09	; ** absolute tempo change?
    178  f000				  -	      bne	nothandletempochange
    179  f000				  -	      lda	#0
    180  f000				  -	      sta	songtempo
    181  f000				  -handlerelativetempochange
    182  f000				  -	      iny
    183  f000				  -	      lda	(songdatalo),y
    184  f000				  -	      clc
    185  f000				  -	      adc	songtempo
    186  f000				  -	      sta	songtempo
    187  f000				  -	      lda	#2
    188  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    189  f000				  -	      jmp	processsongdata
    190  f000				  -
    191  f000				  -nothandletempochange
    192  f000				  -	      cmp	#$0A	; ** relative tempo change?:
    193  f000				  -	      beq	handlerelativetempochange
    194  f000				  -	      cmp	#$0B	; ** octave/semi change?
    195  f000				  -	      beq	handleoctavesemichange
    196  f000				  -handlepatterndata
    197  f000				  -			; ** if we're here its a pattern/loop "subroutine"
    198  f000				  -			; ** move the channel's "stack" pointer and populate the new stack level
    199  f000				  -
    200  f000				  -	      lda	#4
    201  f000				  -	      clc
    202  f000				  -	      adc	songchannel1stackdepth,x
    203  f000				  -	      sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    204  f000				  -
    205  f000				  -	      stx	inttemp6	; about to invalidate x. save it.
    206  f000				  -	      lda	songstackindex
    207  f000				  -	      adc	#4
    208  f000				  -	      tax
    209  f000				  -
    210  f000				  -	      lda	(songdatalo),y
    211  f000				  -	      and	#$7
    212  f000				  -	      sta	songchannel1layer1loops,x
    213  f000				  -	      iny
    214  f000				  -	      lda	(songdatalo),y
    215  f000				  -	      sta	songchannel1layer1lo,x
    216  f000				  -	      iny
    217  f000				  -	      lda	(songdatalo),y
    218  f000				  -	      sta	songchannel1layer1hi,x
    219  f000				  -
    220  f000				  -	      ldx	inttemp6	; restore x with the channel #
    221  f000				  -
    222  f000				  -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    223  f000				  -	      lda	#3
    224  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    225  f000				  -
    226  f000				  -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    227  f000				  -	      jmp	processsongdata
    228  f000				  -
    229  f000				  -handlechannelEOD
    230  f000				  -			; ** check if there are loops remaining on the pattern
    231  f000				  -	      stx	inttemp6
    232  f000				  -	      ldx	songstackindex
    233  f000				  -	      dec	songchannel1layer1loops,x
    234  f000				  -	      bmi	handlechannelEODnoloop
    235  f000				  -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    236  f000				  -	      iny
    237  f000				  -	      lda	(songdatalo),y
    238  f000				  -	      sta	songchannel1layer1lo,x
    239  f000				  -	      iny
    240  f000				  -	      lda	(songdatalo),y
    241  f000				  -	      sta	songchannel1layer1hi,x
    242  f000				  -	      ldx	inttemp6
    243  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    244  f000				  -
    245  f000				  -handlechannelEODnoloop
    246  f000				  -			; this pattern/loop is done playing. "pop" the stack
    247  f000				  -	      ldx	inttemp6
    248  f000				  -	      lda	songchannel1stackdepth,x
    249  f000				  -	      beq	handlerootchannelEOD
    250  f000				  -	      sec
    251  f000				  -	      sbc	#4
    252  f000				  -	      sta	songchannel1stackdepth,x
    253  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    254  f000				  -
    255  f000				  -handlerootchannelEOD
    256  f000				  -			; this channel is done. point it to $ff data so we no longer process this channel.
    257  f000				  -	      lda	#0
    258  f000				  -	      sta	songchannel1layer1lo,x
    259  f000				  -	      sta	songchannel1layer1hi,x
    260  f000				  -	      sta	songchannel1busywait,x
    261  f000				  -	      jmp	setchannelcountbits
    262  f000				  -	      rts
    263  f000				  -
    264  f000				  -nothandlepatternchange
    265  f000				  -handleoctavesemichange
    266  f000				  -	      iny
    267  f000				  -	      lda	(songdatalo),y
    268  f000				  -	      sta	songchannel1transpose,x
    269  f000				  -	      lda	#2
    270  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    271  f000				  -	      jmp	processsongdata
    272  f000				  -
    273  f000				  -advancethesongpointer1byte
    274  f000				  -	      txa
    275  f000				  -	      ldx	songstackindex
    276  f000				  -	      inc	songchannel1layer1lo,x
    277  f000				  -	      bne	skiphiadvancethesongpointer1byte
    278  f000				  -	      inc	songchannel1layer1hi,x
    279  f000				  -skiphiadvancethesongpointer1byte
    280  f000				  -	      tax
    281  f000				  -	      rts
    282  f000				  -
    283  f000				  -advancethesongpointerNbytes
    284  f000				  -			; entered with A=# of byte to advance
    285  f000				  -	      stx	inttemp6
    286  f000				  -	      ldx	songstackindex
    287  f000				  -	      clc
    288  f000				  -	      adc	songchannel1layer1lo,x
    289  f000				  -	      sta	songchannel1layer1lo,x
    290  f000				  -	      lda	#0
    291  f000				  -	      adc	songchannel1layer1hi,x
    292  f000				  -	      sta	songchannel1layer1hi,x
    293  f000				  -	      ldx	inttemp6
    294  f000				  -	      rts
    295  f000				  -
    296  f000				  -clearsongmemory
    297  f000				  -	      lda	#0
    298  f000				  -	      ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    299  f000				  -clearsongmemoryloop1
    300  f000				  -	      sta	songchannel1layer1lo,x
    301  f000				  -	      dex
    302  f000				  -	      bpl	clearsongmemoryloop1
    303  f000				  -
    304  f000				  -	      ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    305  f000				  -clearsongmemoryloop2
    306  f000				  -	      sta	songchannel1layer1loops,x
    307  f000				  -	      dex
    308  f000				  -	      bpl	clearsongmemoryloop2
    309  f000				  -
    310  f000				  -	      lda	#$ff
    311  f000				  -	      ldx	#3
    312  f000				  -clearsongmemoryloop3
    313  f000				  -	      sta	songchannel1busywait,x
    314  f000				  -	      dex
    315  f000				  -	      bpl	clearsongmemoryloop3
    316  f000				  -	      rts
    317  f000				  -
    318  f000				  -setsongchannels
    319  f000				  -	      jsr	clearsongmemory
    320  f000				  -	      ldy	#7
    321  f000				  -	      ldx	#3
    322  f000				  -setsongchannelsloop
    323  f000				  -	      lda	(songpointerlo),y
    324  f000				  -	      sta	songchannel1layer1hi,x
    325  f000				  -	      dey
    326  f000				  -	      lda	(songpointerlo),y
    327  f000				  -	      sta	songchannel1layer1lo,x
    328  f000				  -	      dex
    329  f000				  -	      dey
    330  f000				  -	      bpl	setsongchannelsloop
    331  f000				  -	      rts
    332  f000				  -
    333  f000				  -channel2bits
    334  f000				  -	      .byte	1,2,4,8
    335  f000				  -
    336  f000				  -tiatrackeroctavenotes
    337  f000				  -	      ifconst	BUZZBASS
    338  f000				  -LOWC       =	15
    339  f000				  -	      else
    340  f000				  -LOWC       =	14
    341  f000				  -	      endif
    342  f000				  -			; ****** ELECTRONIC (0 to 11)
    343  f000				  -	      .byte	LOWC,20	; c0	 16.1Hz
    344  f000				  -	      .byte	LOWC,18	; c#0
    345  f000				  -	      .byte	LOWC,17	; d0
    346  f000				  -	      .byte	LOWC,16	; d#0
    347  f000				  -	      .byte	LOWC,15	; e0
    348  f000				  -	      .byte	LOWC,14	; f0  (very off)
    349  f000				  -	      .byte	LOWC,14	; f#0
    350  f000				  -	      .byte	LOWC,13	; g0
    351  f000				  -	      .byte	LOWC,12	; g#0
    352  f000				  -	      .byte	LOWC,11	; a0
    353  f000				  -	      .byte	LOWC,11	; a#0 (very off)
    354  f000				  -	      .byte	LOWC,10	; b0	 30.7Hz
    355  f000				  -
    356  f000				  -			; ****** SLIGHTLY BUZZY (12 to 23)
    357  f000				  -	      .byte	6,30	; c1	 32.7Hz
    358  f000				  -	      .byte	6,28	; c#1
    359  f000				  -	      .byte	6,27	; d1
    360  f000				  -	      .byte	6,25	; d#1
    361  f000				  -	      .byte	6,24	; e1
    362  f000				  -	      .byte	6,22	; f1
    363  f000				  -	      .byte	6,21	; f#1
    364  f000				  -	      .byte	6,20	; g1
    365  f000				  -	      .byte	6,18	; g#1
    366  f000				  -	      .byte	6,17	; a1
    367  f000				  -	      .byte	6,16	; a#1
    368  f000				  -	      .byte	6,15	; b1	 63.4Hz
    369  f000				  -
    370  f000				  -			; ****** BUZZY (24 to 39)
    371  f000				  -	      .byte	1,31	; c2	 65.5
    372  f000				  -	      .byte	1,30	; c#2	 67.6
    373  f000				  -	      .byte	1,27	; d2	 72.3
    374  f000				  -	      .byte	1,26	; d#2	 77.6
    375  f000				  -	      .byte	1,24	; e2
    376  f000				  -	      .byte	1,23	; f2
    377  f000				  -	      .byte	1,22	; f#2
    378  f000				  -	      .byte	1,20	; g2
    379  f000				  -	      .byte	1,19	; g#2
    380  f000				  -	      .byte	1,18	; a2
    381  f000				  -	      .byte	1,17	; a#2
    382  f000				  -	      .byte	1,16	; b2
    383  f000				  -	      .byte	1,15	; c3	126.8Hz
    384  f000				  -	      .byte	1,14	; c#3
    385  f000				  -	      .byte	1,13	; d3	149.7Hz
    386  f000				  -	      .byte	1,12	; d#3	161.2Hz (very off)
    387  f000				  -			; ****** PURE (40 to 71) - best key is A3 Major
    388  f000				  -	      .byte	12,31	; e3	163.8Hz
    389  f000				  -	      .byte	12,29	; f3
    390  f000				  -	      .byte	12,28	; f#3
    391  f000				  -	      .byte	12,26	; g3
    392  f000				  -	      .byte	12,24	; g#3
    393  f000				  -	      .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    394  f000				  -	      .byte	12,22	; a#3
    395  f000				  -	      .byte	12,20	; b3
    396  f000				  -	      .byte	12,19	; c4  (middle C)
    397  f000				  -	      .byte	12,18	; c#4
    398  f000				  -	      .byte	12,17	; d4
    399  f000				  -	      .byte	12,16	; d#4
    400  f000				  -	      .byte	12,15	; e4
    401  f000				  -	      .byte	12,14	; f4
    402  f000				  -	      .byte	12,13	; f#4
    403  f000				  -	      .byte	12,12	; g4  (very off)
    404  f000				  -	      .byte	12,12	; g#4
    405  f000				  -	      .byte	12,11	; a4
    406  f000				  -	      .byte	12,10	; a#4
    407  f000				  -	      .byte	4,31	; b4
    408  f000				  -	      .byte	4,29	; c5
    409  f000				  -	      .byte	4,28	; c#5
    410  f000				  -	      .byte	4,26	; d5
    411  f000				  -	      .byte	4,24	; d#5
    412  f000				  -	      .byte	4,23	; e5
    413  f000				  -	      .byte	4,22	; f5
    414  f000				  -	      .byte	4,20	; f#5
    415  f000				  -	      .byte	4,19	; g5
    416  f000				  -	      .byte	4,18	; g#5
    417  f000				  -	      .byte	4,17	; a5
    418  f000				  -	      .byte	4,16	; a#5
    419  f000				  -	      .byte	4,15	; b5
    420  f000				  -
    421  f000				  -			; ****** TUNED WIND (72 to 83)
    422  f000				  -	      .byte	8,30	; c
    423  f000				  -	      .byte	8,28	; c#
    424  f000				  -	      .byte	8,27	; d
    425  f000				  -	      .byte	8,25	; d#
    426  f000				  -	      .byte	8,24	; e
    427  f000				  -	      .byte	8,22	; f
    428  f000				  -	      .byte	8,21	; f#
    429  f000				  -	      .byte	8,20	; g
    430  f000				  -	      .byte	8,18	; g#
    431  f000				  -	      .byte	8,17	; a
    432  f000				  -	      .byte	8,16	; a#
    433  f000				  -	      .byte	8,15	; b
    434  f000				  -
    435  f000				  -	      include	"tiadrumkit.asm"
    436  f000				  -
    437  f000				  -trackerend
    438  f000				  -
    439  f000				  -	      echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    440  f000				  -
    441  f000					      endif		;MUSICTRACKER
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3333  f000					      endif
   3334  f000					      ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  f000					      include	hiscore.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	HSSUPPORT
      4  f000				  -
      5  f000				  -	      ifconst	BANKSETROM
      6  f000				  -	      ifconst	isBANKSETBANK
      7  f000				  -HSCHARSHERE =	1
      8  f000				  -	      endif
      9  f000				  -	      else		; !BANKSETROM so embed the character strings
     10  f000				  -HSCHARSHERE =	1
     11  f000				  -	      endif
     12  f000				  -
     13  f000				  -	      ifnconst	isBANKSETBANK
     14  f000				  -hiscorestart
     15  f000				  -
     16  f000				  -detectatarivoxeeprom
     17  f000				  -hiscoremodulestart
     18  f000				  -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  f000				  -	      jsr	AVoxDetect
     20  f000				  -	      eor	#$ff	; invert for easy 7800basic if...then logic
     21  f000				  -	      sta	avoxdetected
     22  f000				  -	      lda	#$0
     23  f000				  -	      sta	SWACNT
     24  f000				  -	      lda	avoxdetected
     25  f000				  -	      rts
     26  f000				  -
     27  f000				  -detecthsc
     28  f000				  -			; check for the HSC ROM signature...
     29  f000				  -	      lda	XCTRL1s
     30  f000				  -	      ora	#%00001100
     31  f000				  -	      sta	XCTRL1s
     32  f000				  -	      sta	XCTRL1
     33  f000				  -	      lda	$3900
     34  f000				  -	      eor	#$C6
     35  f000				  -	      bne	detecthscfail
     36  f000				  -	      lda	$3904
     37  f000				  -	      eor	#$FE
     38  f000				  -	      bne	detecthscfail
     39  f000				  -			; check if it's initialized...
     40  f000				  -	      ldy	#0
     41  f000				  -	      lda	#$ff
     42  f000				  -checkhscinit
     43  f000				  -	      and	$1000,y
     44  f000				  -	      dey
     45  f000				  -	      bpl	checkhscinit
     46  f000				  -	      cmp	#$ff
     47  f000				  -	      bne	hscisalreadyinit
     48  f000				  -			; if we're here, we need to do a minimal HSC init...
     49  f000				  -	      ldy	#$28
     50  f000				  -hscinitloop1
     51  f000				  -	      lda	hscheader,y
     52  f000				  -	      sta	$1000,y
     53  f000				  -	      dey
     54  f000				  -	      bpl	hscinitloop1
     55  f000				  -	      ldy	#$89
     56  f000				  -	      lda	#$7F
     57  f000				  -hscinitloop2
     58  f000				  -	      sta	$10B3,y
     59  f000				  -	      dey
     60  f000				  -	      cpy	#$ff
     61  f000				  -	      bne	hscinitloop2
     62  f000				  -hscisalreadyinit
     63  f000				  -	      lda	#$ff
     64  f000				  -	      rts
     65  f000				  -hscheader
     66  f000				  -	      .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     67  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     68  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     69  f000				  -detecthscfail
     70  f000				  -	      lda	XCTRL1s
     71  f000				  -	      and	#%11110111
     72  f000				  -	      sta	XCTRL1s
     73  f000				  -	      lda	#0
     74  f000				  -	      rts
     75  f000				  -	      endif		; isBANKSETBANK
     76  f000				  -
     77  f000				  -	      ifnconst	hiscorefont
     78  f000				  -	      echo	""
     79  f000				  -	      echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     80  f000				  -	      echo	" NOT imported with incgraphic. The high score display code"
     81  f000				  -	      echo	" has been omitted from this build."
     82  f000				  -	      echo	""
     83  f000				  -	      else		; hiscorefont
     84  f000				  -	      ifnconst	isBANKSETBANK
     85  f000				  -hscdrawscreen
     86  f000				  -
     87  f000				  -			; we use 20 lines on a 24 line display
     88  f000				  -			; HSSCOREY to dynamically centers based on
     89  f000				  -			;HSSCOREY = 0
     90  f000				  -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     91  f000				  -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     92  f000				  -
     93  f000				  -	      ifconst	HSSCORESIZE
     94  f000				  -SCORESIZE  =	HSSCORESIZE
     95  f000				  -	      else
     96  f000				  -SCORESIZE  =	6
     97  f000				  -	      endif
     98  f000				  -
     99  f000				  -			;save shadow registers for later return...
    100  f000				  -	      lda	sCTRL
    101  f000				  -	      sta	ssCTRL
    102  f000				  -	      lda	sCHARBASE
    103  f000				  -	      sta	ssCHARBASE
    104  f000				  -	      lda	#$60
    105  f000				  -	      sta	charactermode
    106  f000				  -	      jsr	drawwait
    107  f000				  -	      jsr	blacken320colors
    108  f000				  -	      jsr	clearscreen
    109  f000				  -
    110  f000				  -			;set the character base to the HSC font
    111  f000				  -	      lda	#>hiscorefont
    112  f000				  -	      sta	CHARBASE
    113  f000				  -	      sta	sCHARBASE
    114  f000				  -	      lda	#%01000011	;Enable DMA, mode=320A
    115  f000				  -	      sta	CTRL
    116  f000				  -	      sta	sCTRL
    117  f000				  -
    118  f000				  -	      lda	#60
    119  f000				  -	      sta	hsjoydebounce
    120  f000				  -
    121  f000				  -	      lda	#0
    122  f000				  -	      sta	hscursorx
    123  f000				  -	      sta	framecounter
    124  f000				  -	      ifnconst	HSCOLORCHASESTART
    125  f000				  -	      lda	#$8D	; default is blue. why not?
    126  f000				  -	      else
    127  f000				  -	      lda	#HSCOLORCHASESTART
    128  f000				  -	      endif
    129  f000				  -	      sta	hscolorchaseindex
    130  f000				  -
    131  f000				  -	      lda	#$0F
    132  f000				  -	      sta	P0C2	; base text is white
    133  f000				  -
    134  f000				  -	      jsr	hschasecolors
    135  f000				  -			; ** plot all of the initials
    136  f000				  -	      lda	#<HSRAMInitials
    137  f000				  -	      sta	temp1	; charmaplo
    138  f000				  -	      lda	#>HSRAMInitials
    139  f000				  -	      sta	temp2	; charmaphi
    140  f000				  -	      lda	#32+29	; palette=0-29 | 32-(width=3)
    141  f000				  -	      sta	temp3	; palette/width
    142  f000				  -	      lda	#104
    143  f000				  -	      sta	temp4	; X
    144  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    145  f000				  -	      sta	temp5	; Y
    146  f000				  -plothsinitialsloop
    147  f000				  -	      jsr	plotcharacters
    148  f000				  -	      clc
    149  f000				  -	      lda	temp3
    150  f000				  -	      adc	#32
    151  f000				  -	      sta	temp3
    152  f000				  -	      inc	temp5
    153  f000				  -	      if	WZONEHEIGHT = 8
    154  f000				  -	      inc	temp5
    155  f000				  -	      endif
    156  f000				  -	      clc
    157  f000				  -	      lda	#3
    158  f000				  -	      adc	temp1
    159  f000				  -	      sta	temp1
    160  f000				  -	      cmp	#(<(HSRAMInitials+15))
    161  f000				  -	      bcc	plothsinitialsloop
    162  f000				  -
    163  f000				  -	      ifconst	HSGAMENAMELEN
    164  f000				  -			;plot the game name...
    165  f000				  -	      lda	#<HSGAMENAMEtable
    166  f000				  -	      sta	temp1	; charmaplo
    167  f000				  -	      lda	#>HSGAMENAMEtable
    168  f000				  -	      sta	temp2	; charmaphi
    169  f000				  -	      lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    170  f000				  -	      sta	temp3	; palette/width
    171  f000				  -	      lda	#(80-(HSGAMENAMELEN*2))
    172  f000				  -	      sta	temp4	; X
    173  f000				  -	      lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    174  f000				  -	      sta	temp5	; Y
    175  f000				  -	      jsr	plotcharacters
    176  f000				  -	      endif		; HSGAMENAMELEN
    177  f000				  -
    178  f000				  -			;plot "difficulty"...
    179  f000				  -	      ldy	gamedifficulty
    180  f000				  -	      ifnconst	HSNOLEVELNAMES
    181  f000				  -	      lda	highscoredifficultytextlo,y
    182  f000				  -	      sta	temp1
    183  f000				  -	      lda	highscoredifficultytexthi,y
    184  f000				  -	      sta	temp2
    185  f000				  -	      sec
    186  f000				  -	      lda	#32
    187  f000				  -	      sbc	highscoredifficultytextlen,y
    188  f000				  -	      sta	temp3	; palette/width
    189  f000				  -	      sec
    190  f000				  -	      lda	#40
    191  f000				  -	      sbc	highscoredifficultytextlen,y
    192  f000				  -	      asl
    193  f000				  -	      sta	temp4	; X
    194  f000				  -	      else
    195  f000				  -	      lda	#<HSHIGHSCOREStext
    196  f000				  -	      sta	temp1	; charmaplo
    197  f000				  -	      lda	#>HSHIGHSCOREStext
    198  f000				  -	      sta	temp2	; charmaphi
    199  f000				  -	      lda	#(32-11)	; palette=0*29 | 32-(width=3)
    200  f000				  -	      sta	temp3	; palette/width
    201  f000				  -	      lda	#(80-(11*2))
    202  f000				  -	      sta	temp4	; X
    203  f000				  -	      endif		; HSNOLEVELNAMES
    204  f000				  -
    205  f000				  -	      lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    206  f000				  -	      sta	temp5	; Y
    207  f000				  -	      jsr	plotcharacters
    208  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    209  f000				  -	      bne	carronwithscoreevaluation
    210  f000				  -	      jmp	donoscoreevaluation
    211  f000				  -carronwithscoreevaluation
    212  f000				  -	      dey
    213  f000				  -	      lda	highscorelabeltextlo,y
    214  f000				  -	      sta	temp1
    215  f000				  -	      lda	highscorelabeltexthi,y
    216  f000				  -	      sta	temp2
    217  f000				  -	      sec
    218  f000				  -	      lda	#(32-15)	; palette=0*29 | 32-(width=3)
    219  f000				  -	      sta	temp3	; palette/width
    220  f000				  -	      lda	highscorelabeladjust1,y
    221  f000				  -	      sta	temp4	; X
    222  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    223  f000				  -	      sta	temp5	; Y
    224  f000				  -	      jsr	plotcharacters
    225  f000				  -
    226  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    227  f000				  -	      dey
    228  f000				  -			;plot the current player score...
    229  f000				  -	      lda	#(32-SCORESIZE)	; palette=0*32
    230  f000				  -	      sta	temp3	; palette/width
    231  f000				  -	      lda	highscorelabeladjust2,y
    232  f000				  -	      sta	temp4	; X
    233  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    234  f000				  -	      sta	temp5	; Y
    235  f000				  -
    236  f000				  -	      lda	scorevarlo,y
    237  f000				  -	      sta	temp7	; score variable lo
    238  f000				  -	      lda	scorevarhi,y
    239  f000				  -	      sta	temp8	; score variable hi
    240  f000				  -
    241  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    242  f000				  -	      sta	temp9
    243  f000				  -
    244  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    245  f000				  -	      sta	temp1	; charmaplo
    246  f000				  -	      lda	#>(hiscorefont+33)
    247  f000				  -	      sta	temp2	; charmaphi
    248  f000				  -	      lda	#SCORESIZE
    249  f000				  -	      sta	temp6
    250  f000				  -	      ifnconst	DOUBLEWIDE
    251  f000				  -	      jsr	plotvalue
    252  f000				  -	      else
    253  f000				  -	      jsr	plotvaluedw
    254  f000				  -	      endif
    255  f000				  -
    256  f000				  -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    257  f000				  -
    258  f000				  -	      ifconst	HSGAMERANKS
    259  f000				  -
    260  f000				  -	      ldx	#$ff	; start at 0 after the inx...
    261  f000				  -comparescore2rankloop
    262  f000				  -	      inx
    263  f000				  -	      ldy	#0
    264  f000				  -	      lda	rankvalue_0,x
    265  f000				  -	      cmp	(temp7),y
    266  f000				  -	      bcc	score2rankloopdone
    267  f000				  -	      bne	comparescore2rankloop
    268  f000				  -	      iny
    269  f000				  -	      lda	rankvalue_1,x
    270  f000				  -	      cmp	(temp7),y
    271  f000				  -	      bcc	score2rankloopdone
    272  f000				  -	      bne	comparescore2rankloop
    273  f000				  -	      iny
    274  f000				  -	      lda	(temp7),y
    275  f000				  -	      cmp	rankvalue_2,x
    276  f000				  -	      bcs	score2rankloopdone
    277  f000				  -	      jmp	comparescore2rankloop
    278  f000				  -score2rankloopdone
    279  f000				  -	      stx	hsnewscorerank
    280  f000				  -
    281  f000				  -	      lda	ranklabello,x
    282  f000				  -	      sta	temp1
    283  f000				  -	      lda	ranklabelhi,x
    284  f000				  -	      sta	temp2
    285  f000				  -	      sec
    286  f000				  -	      lda	#32	; palette=0*29 | 32-(width=3)
    287  f000				  -	      sbc	ranklabellengths,x
    288  f000				  -	      sta	temp3	; palette/width
    289  f000				  -	      sec
    290  f000				  -	      lda	#(40+6)
    291  f000				  -	      sbc	ranklabellengths,x
    292  f000				  -	      asl
    293  f000				  -	      sta	temp4	; X
    294  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    295  f000				  -	      sta	temp5	; Y
    296  f000				  -	      jsr	plotcharacters
    297  f000				  -
    298  f000				  -	      ldx	hsnewscorerank
    299  f000				  -
    300  f000				  -	      lda	#<highscoreranklabel
    301  f000				  -	      sta	temp1
    302  f000				  -	      lda	#>highscoreranklabel
    303  f000				  -	      sta	temp2
    304  f000				  -
    305  f000				  -	      lda	#(32-5)	; palette=0*29 | 32-(width=3)
    306  f000				  -	      sta	temp3	; palette/width
    307  f000				  -	      lda	#(40-6)
    308  f000				  -	      sec
    309  f000				  -	      sbc	ranklabellengths,x
    310  f000				  -	      asl
    311  f000				  -	      sta	temp4	; X
    312  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    313  f000				  -	      sta	temp5	; Y
    314  f000				  -	      jsr	plotcharacters
    315  f000				  -	      endif		; HSGAMERANKS
    316  f000				  -
    317  f000				  -
    318  f000				  -			; ** which line did this player beat?
    319  f000				  -	      lda	#$ff
    320  f000				  -	      sta	hsnewscoreline
    321  f000				  -	      ldx	#$fd
    322  f000				  -comparescoreadd2x
    323  f000				  -	      inx
    324  f000				  -comparescoreadd1x
    325  f000				  -	      inx
    326  f000				  -comparescore2lineloop
    327  f000				  -	      inc	hsnewscoreline
    328  f000				  -	      inx		; initialrun, x=0
    329  f000				  -	      cpx	#15
    330  f000				  -	      beq	nohighscoreforyou
    331  f000				  -	      ldy	#0
    332  f000				  -	      lda	HSRAMScores,x
    333  f000				  -	      cmp	(temp7),y	; first score digit
    334  f000				  -	      bcc	score2lineloopdonedel1x
    335  f000				  -	      bne	comparescoreadd2x
    336  f000				  -	      iny
    337  f000				  -	      inx
    338  f000				  -	      lda	HSRAMScores,x
    339  f000				  -	      cmp	(temp7),y
    340  f000				  -	      bcc	score2lineloopdonedel2x
    341  f000				  -	      bne	comparescoreadd1x
    342  f000				  -	      iny
    343  f000				  -	      inx
    344  f000				  -	      lda	(temp7),y
    345  f000				  -	      cmp	HSRAMScores,x
    346  f000				  -	      bcs	score2lineloopdonedel3x
    347  f000				  -	      jmp	comparescore2lineloop
    348  f000				  -nohighscoreforyou
    349  f000				  -	      lda	#$ff
    350  f000				  -	      sta	hsnewscoreline
    351  f000				  -	      sta	countdownseconds
    352  f000				  -	      jmp	donoscoreevaluation
    353  f000				  -score2lineloopdonedel3x
    354  f000				  -	      dex
    355  f000				  -score2lineloopdonedel2x
    356  f000				  -	      dex
    357  f000				  -score2lineloopdonedel1x
    358  f000				  -	      dex
    359  f000				  -
    360  f000				  -			; 0 1 2
    361  f000				  -			; 3 4 5
    362  f000				  -			; 6 7 8
    363  f000				  -			; 9 0 1
    364  f000				  -			; 2 3 4
    365  f000				  -
    366  f000				  -	      stx	temp9
    367  f000				  -	      cpx	#11
    368  f000				  -	      beq	postsortscoresuploop
    369  f000				  -	      ldx	#11
    370  f000				  -sortscoresuploop
    371  f000				  -	      lda	HSRAMScores,x
    372  f000				  -	      sta	HSRAMScores+3,x
    373  f000				  -	      lda	HSRAMInitials,x
    374  f000				  -	      sta	HSRAMInitials+3,x
    375  f000				  -	      dex
    376  f000				  -	      cpx	temp9
    377  f000				  -	      bne	sortscoresuploop
    378  f000				  -postsortscoresuploop
    379  f000				  -
    380  f000				  -			;stick the score and cleared initials in the slot...
    381  f000				  -	      inx
    382  f000				  -	      ldy	#0
    383  f000				  -	      sty	hsinitialhold
    384  f000				  -	      lda	(temp7),y
    385  f000				  -	      sta	HSRAMScores,x
    386  f000				  -	      iny
    387  f000				  -	      lda	(temp7),y
    388  f000				  -	      sta	HSRAMScores+1,x
    389  f000				  -	      iny
    390  f000				  -	      lda	(temp7),y
    391  f000				  -	      sta	HSRAMScores+2,x
    392  f000				  -	      lda	#0
    393  f000				  -	      sta	HSRAMInitials,x
    394  f000				  -	      lda	#29
    395  f000				  -	      sta	HSRAMInitials+1,x
    396  f000				  -	      sta	HSRAMInitials+2,x
    397  f000				  -
    398  f000				  -	      stx	hsinitialpos
    399  f000				  -
    400  f000				  -	      ifconst	vox_highscore
    401  f000				  -	      lda	<#vox_highscore
    402  f000				  -	      sta	speech_addr
    403  f000				  -	      lda	>#vox_highscore
    404  f000				  -	      sta	speech_addr+1
    405  f000				  -	      endif		; vox_highscore
    406  f000				  -	      ifconst	sfx_highscore
    407  f000				  -	      lda	<#sfx_highscore
    408  f000				  -	      sta	temp1
    409  f000				  -	      lda	>#sfx_highscore
    410  f000				  -	      sta	temp2
    411  f000				  -	      lda	#0
    412  f000				  -	      sta	temp3
    413  f000				  -	      jsr	schedulesfx
    414  f000				  -	      endif		; sfx_highscore
    415  f000				  -	      ifconst	songdatastart_song_highscore
    416  f000				  -	      lda	#<songchanneltable_song_highscore
    417  f000				  -	      sta	songpointerlo
    418  f000				  -	      lda	#>songchanneltable_song_highscore
    419  f000				  -	      sta	songpointerhi
    420  f000				  -	      lda	#73
    421  f000				  -	      sta	songtempo
    422  f000				  -	      jsr	setsongchannels
    423  f000				  -	      endif		; songdatastart_song_highscore
    424  f000				  -
    425  f000				  -
    426  f000				  -donoscoreevaluation
    427  f000				  -
    428  f000				  -	      lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    429  f000				  -	      sta	temp3	; palette/width
    430  f000				  -	      lda	#(72+(4*(6-SCORESIZE)))
    431  f000				  -	      sta	temp4	; X
    432  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    433  f000				  -	      sta	temp5	; Y
    434  f000				  -	      lda	#<HSRAMScores
    435  f000				  -	      sta	temp7	; score variable lo
    436  f000				  -	      lda	#>HSRAMScores
    437  f000				  -	      sta	temp8	; score variable hi
    438  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    439  f000				  -	      sta	temp9
    440  f000				  -plothsscoresloop
    441  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    442  f000				  -	      sta	temp1	; charmaplo
    443  f000				  -	      lda	#>(hiscorefont+33)
    444  f000				  -	      sta	temp2	; charmaphi
    445  f000				  -	      lda	#6
    446  f000				  -	      sta	temp6
    447  f000				  -	      ifnconst	DOUBLEWIDE
    448  f000				  -	      jsr	plotvalue
    449  f000				  -	      else
    450  f000				  -	      jsr	plotvaluedw
    451  f000				  -	      endif
    452  f000				  -	      clc
    453  f000				  -	      lda	temp3
    454  f000				  -	      adc	#32
    455  f000				  -	      sta	temp3
    456  f000				  -	      inc	temp5
    457  f000				  -	      if	WZONEHEIGHT = 8
    458  f000				  -	      inc	temp5
    459  f000				  -	      endif
    460  f000				  -	      clc
    461  f000				  -	      lda	#3
    462  f000				  -	      adc	temp7
    463  f000				  -	      sta	temp7
    464  f000				  -	      cmp	#(<(HSRAMScores+15))
    465  f000				  -	      bcc	plothsscoresloop
    466  f000				  -plothsindex
    467  f000				  -	      lda	#32+31	; palette=0*32 | 32-(width=1)
    468  f000				  -	      sta	temp3	; palette/width
    469  f000				  -	      lda	#44
    470  f000				  -	      sta	temp4	; X
    471  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    472  f000				  -	      sta	temp5	; Y
    473  f000				  -	      lda	#<hsgameslotnumbers
    474  f000				  -	      sta	temp7	; score variable lo
    475  f000				  -	      lda	#>hsgameslotnumbers
    476  f000				  -	      sta	temp8	; score variable hi
    477  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    478  f000				  -	      sta	temp9
    479  f000				  -plothsindexloop
    480  f000				  -	      lda	#<(hiscorefont+33)
    481  f000				  -	      sta	temp1	; charmaplo
    482  f000				  -	      lda	#>(hiscorefont+33)
    483  f000				  -	      sta	temp2	; charmaphi
    484  f000				  -	      lda	#1
    485  f000				  -	      sta	temp6	; number of characters
    486  f000				  -	      ifnconst	DOUBLEWIDE
    487  f000				  -	      jsr	plotvalue
    488  f000				  -	      else
    489  f000				  -	      jsr	plotvaluedw
    490  f000				  -	      endif
    491  f000				  -	      clc
    492  f000				  -	      lda	temp3
    493  f000				  -	      adc	#32
    494  f000				  -	      sta	temp3
    495  f000				  -	      inc	temp5
    496  f000				  -	      if	WZONEHEIGHT = 8
    497  f000				  -	      inc	temp5
    498  f000				  -	      endif
    499  f000				  -	      inc	temp7
    500  f000				  -	      lda	temp7
    501  f000				  -	      cmp	#(<(hsgameslotnumbers+5))
    502  f000				  -	      bcc	plothsindexloop
    503  f000				  -
    504  f000				  -	      jsr	savescreen
    505  f000				  -	      ifnconst	HSSECONDS
    506  f000				  -	      lda	#6
    507  f000				  -	      else
    508  f000				  -	      lda	#HSSECONDS
    509  f000				  -	      endif
    510  f000				  -
    511  f000				  -	      sta	countdownseconds
    512  f000				  -
    513  f000				  -keepdisplayinghs
    514  f000				  -	      jsr	restorescreen
    515  f000				  -
    516  f000				  -	      jsr	setuphsinpt1
    517  f000				  -
    518  f000				  -	      lda	hsnewscoreline
    519  f000				  -	      bpl	carryonkeepdisplayinghs
    520  f000				  -	      jmp	skipenterscorecontrol
    521  f000				  -carryonkeepdisplayinghs
    522  f000				  -
    523  f000				  -
    524  f000				  -	      ifnconst	HSSECONDS
    525  f000				  -	      lda	#6
    526  f000				  -	      else
    527  f000				  -	      lda	#HSSECONDS
    528  f000				  -	      endif
    529  f000				  -
    530  f000				  -	      sta	countdownseconds
    531  f000				  -
    532  f000				  -			;plot the "cursor" initial sprite...
    533  f000				  -	      lda	hsinitialhold
    534  f000				  -
    535  f000				  -	      sta	temp1
    536  f000				  -	      lda	#>(hiscorefont+32)
    537  f000				  -	      sta	temp2
    538  f000				  -	      lda	#31	; palette=0*32 | 32-(width=1)
    539  f000				  -	      sta	temp3	; palette/width
    540  f000				  -	      lda	hscursorx
    541  f000				  -	      asl
    542  f000				  -	      asl
    543  f000				  -	      clc
    544  f000				  -	      adc	#104
    545  f000				  -	      sta	temp4	; X
    546  f000				  -	      lda	hsnewscoreline
    547  f000				  -	      asl
    548  f000				  -	      asl
    549  f000				  -	      asl
    550  f000				  -	      asl
    551  f000				  -	      adc	#((3*16)+HSCURSORY)
    552  f000				  -	      sta	temp5	; Y
    553  f000				  -	      lda	#%01000000
    554  f000				  -	      sta	temp6
    555  f000				  -	      jsr	plotsprite
    556  f000				  -
    557  f000				  -	      ldx	hscursorx
    558  f000				  -	      ldy	hsdisplaymode
    559  f000				  -	      ifnconst	.HSup
    560  f000				  -	      lda	SWCHA
    561  f000				  -	      cpy	#3
    562  f000				  -	      bne	hsskipadjustjoystick1
    563  f000				  -	      asl
    564  f000				  -	      asl
    565  f000				  -	      asl
    566  f000				  -	      asl
    567  f000				  -hsskipadjustjoystick1
    568  f000				  -	      sta	hsswcha
    569  f000				  -	      else		; there are user-defined routines!
    570  f000				  -	      jsr	.HSdown
    571  f000				  -	      lda	hsreturn	; b0
    572  f000				  -	      asl
    573  f000				  -	      pha
    574  f000				  -	      jsr	.HSup
    575  f000				  -	      pla
    576  f000				  -	      ora	hsreturn
    577  f000				  -	      asl
    578  f000				  -	      asl
    579  f000				  -	      asl
    580  f000				  -	      asl
    581  f000				  -	      eor	#$FF
    582  f000				  -	      sta	hsswcha
    583  f000				  -	      endif
    584  f000				  -	      lda	SWCHB
    585  f000				  -	      and	#%00000010
    586  f000				  -	      bne	hsskipselectswitch
    587  f000				  -	      lda	#%00010000
    588  f000				  -	      sta	hsswcha
    589  f000				  -	      bne	hsdodebouncecheck
    590  f000				  -hsskipselectswitch
    591  f000				  -	      lda	hsswcha
    592  f000				  -	      and	#%00110000
    593  f000				  -	      cmp	#%00110000
    594  f000				  -	      beq	hsjoystickskipped
    595  f000				  -hsdodebouncecheck
    596  f000				  -	      lda	hsjoydebounce
    597  f000				  -	      beq	hsdontdebounce
    598  f000				  -	      jmp	hspostjoystick
    599  f000				  -hsdontdebounce
    600  f000				  -	      ldx	#1	; small tick sound
    601  f000				  -	      jsr	playhssfx
    602  f000				  -	      lda	hsswcha
    603  f000				  -	      and	#%00110000
    604  f000				  -	      ldx	hscursorx
    605  f000				  -	      cmp	#%00100000	; check down
    606  f000				  -	      bne	hsjoycheckup
    607  f000				  -	      ldy	hsinitialhold
    608  f000				  -	      cpx	#0
    609  f000				  -	      bne	skipavoid31_1
    610  f000				  -	      cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    611  f000				  -	      bne	skipavoid31_1
    612  f000				  -	      dey
    613  f000				  -skipavoid31_1
    614  f000				  -	      dey
    615  f000				  -	      jmp	hssetdebounce
    616  f000				  -hsjoycheckup
    617  f000				  -	      cmp	#%00010000	; check up
    618  f000				  -	      bne	hsjoystickskipped
    619  f000				  -	      ldy	hsinitialhold
    620  f000				  -	      cpx	#0
    621  f000				  -	      bne	skipavoid31_2
    622  f000				  -	      cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    623  f000				  -	      bne	skipavoid31_2
    624  f000				  -	      iny
    625  f000				  -skipavoid31_2
    626  f000				  -	      iny
    627  f000				  -hssetdebounce
    628  f000				  -	      tya
    629  f000				  -	      and	#31
    630  f000				  -	      sta	hsinitialhold
    631  f000				  -	      lda	#15
    632  f000				  -	      sta	hsjoydebounce
    633  f000				  -	      bne	hspostjoystick
    634  f000				  -hsjoystickskipped
    635  f000				  -			; check the fire button only when the stick isn't engaged
    636  f000				  -	      lda	hsinpt1
    637  f000				  -	      bpl	hsbuttonskipped
    638  f000				  -	      lda	hsjoydebounce
    639  f000				  -	      bne	hspostjoystick
    640  f000				  -hsfiredontdebounce
    641  f000				  -	      lda	hsinitialhold
    642  f000				  -	      cmp	#31
    643  f000				  -	      beq	hsmovecursorback
    644  f000				  -	      inc	hscursorx
    645  f000				  -	      inc	hsinitialpos
    646  f000				  -	      lda	hscursorx
    647  f000				  -	      cmp	#3
    648  f000				  -	      bne	skiphsentryisdone
    649  f000				  -	      lda	#0
    650  f000				  -	      sta	framecounter
    651  f000				  -	      lda	#$ff
    652  f000				  -	      sta	hsnewscoreline
    653  f000				  -	      dec	hsinitialpos
    654  f000				  -	      bne	skiphsentryisdone
    655  f000				  -hsmovecursorback
    656  f000				  -	      lda	hscursorx
    657  f000				  -	      beq	skiphsmovecursorback
    658  f000				  -	      lda	#29
    659  f000				  -	      ldx	hsinitialpos
    660  f000				  -	      sta	HSRAMInitials,x
    661  f000				  -	      dec	hsinitialpos
    662  f000				  -	      dec	hscursorx
    663  f000				  -	      dex
    664  f000				  -	      lda	HSRAMInitials,x
    665  f000				  -	      sta	hsinitialhold
    666  f000				  -skiphsmovecursorback
    667  f000				  -skiphsentryisdone
    668  f000				  -	      ldx	#0
    669  f000				  -	      jsr	playhssfx
    670  f000				  -	      lda	#20
    671  f000				  -	      sta	hsjoydebounce
    672  f000				  -	      bne	hspostjoystick
    673  f000				  -
    674  f000				  -hsbuttonskipped
    675  f000				  -	      lda	#0
    676  f000				  -	      sta	hsjoydebounce
    677  f000				  -hspostjoystick
    678  f000				  -
    679  f000				  -	      ldx	hsinitialpos
    680  f000				  -	      lda	hsinitialhold
    681  f000				  -	      sta	HSRAMInitials,x
    682  f000				  -
    683  f000				  -	      jmp	skiphschasecolors
    684  f000				  -
    685  f000				  -skipenterscorecontrol
    686  f000				  -	      jsr	hschasecolors
    687  f000				  -	      jsr	setuphsinpt1
    688  f000				  -	      lda	hsjoydebounce
    689  f000				  -	      bne	skiphschasecolors
    690  f000				  -	      lda	hsinpt1
    691  f000				  -	      bmi	returnfromhs
    692  f000				  -skiphschasecolors
    693  f000				  -
    694  f000				  -	      jsr	drawscreen
    695  f000				  -
    696  f000				  -	      lda	countdownseconds
    697  f000				  -	      beq	returnfromhs
    698  f000				  -	      jmp	keepdisplayinghs
    699  f000				  -returnfromhs
    700  f000				  -
    701  f000				  -	      ifconst	songdatastart_song_highscore
    702  f000				  -	      lda	hsdisplaymode
    703  f000				  -	      beq	skipclearHSCsong
    704  f000				  -	      lda	#0
    705  f000				  -	      sta	songtempo
    706  f000				  -skipclearHSCsong
    707  f000				  -	      endif
    708  f000				  -	      jsr	drawwait
    709  f000				  -	      jsr	clearscreen
    710  f000				  -	      lda	#0
    711  f000				  -	      ldy	#7
    712  f000				  -	      jsr	blacken320colors
    713  f000				  -	      lda	ssCTRL
    714  f000				  -	      sta	sCTRL
    715  f000				  -	      lda	ssCHARBASE
    716  f000				  -	      sta	sCHARBASE
    717  f000				  -	      rts
    718  f000				  -
    719  f000				  -setuphsinpt1
    720  f000				  -	      lda	#$ff
    721  f000				  -	      sta	hsinpt1
    722  f000				  -	      lda	hsjoydebounce
    723  f000				  -	      beq	skipdebounceadjust
    724  f000				  -	      dec	hsjoydebounce
    725  f000				  -	      bne	skipstorefirebuttonstatus
    726  f000				  -skipdebounceadjust
    727  f000				  -	      lda	SWCHB
    728  f000				  -	      and	#%00000001
    729  f000				  -	      bne	hscheckresetover
    730  f000				  -	      lda	#$ff
    731  f000				  -	      sta	hsinpt1
    732  f000				  -	      rts
    733  f000				  -hscheckresetover
    734  f000				  -	      ifnconst	.HSup
    735  f000				  -	      ldx	hsdisplaymode
    736  f000				  -	      cpx	#3
    737  f000				  -	      bne	hsskipadjustjoyfire1
    738  f000				  -	      lda	sINPT3
    739  f000				  -	      jmp	hsskipadjustjoyfire1done
    740  f000				  -hsskipadjustjoyfire1
    741  f000				  -	      lda	sINPT1
    742  f000				  -hsskipadjustjoyfire1done
    743  f000				  -	      sta	hsinpt1
    744  f000				  -	      else		; there are user-defined routines!
    745  f000				  -	      jsr	.HSselect
    746  f000				  -	      lda	hsreturn
    747  f000				  -	      ror		; carry
    748  f000				  -	      ror		; b7
    749  f000				  -	      sta	hsinpt1
    750  f000				  -	      endif	.HSup
    751  f000				  -skipstorefirebuttonstatus
    752  f000				  -	      rts
    753  f000				  -
    754  f000				  -blacken320colors
    755  f000				  -	      ldy	#7
    756  f000				  -blacken320colorsloop
    757  f000				  -	      sta	P0C2,y
    758  f000				  -	      dey
    759  f000				  -	      bpl	blacken320colorsloop
    760  f000				  -	      rts
    761  f000				  -
    762  f000				  -hschasecolors
    763  f000				  -	      lda	framecounter
    764  f000				  -	      and	#3
    765  f000				  -	      bne	hschasecolorsreturn
    766  f000				  -	      inc	hscolorchaseindex
    767  f000				  -	      lda	hscolorchaseindex
    768  f000				  -
    769  f000				  -	      sta	P5C2
    770  f000				  -	      sbc	#$02
    771  f000				  -	      sta	P4C2
    772  f000				  -	      sbc	#$02
    773  f000				  -	      sta	P3C2
    774  f000				  -	      sbc	#$02
    775  f000				  -	      sta	P2C2
    776  f000				  -	      sbc	#$02
    777  f000				  -	      sta	P1C2
    778  f000				  -hschasecolorsreturn
    779  f000				  -	      rts
    780  f000				  -
    781  f000				  -playhssfx
    782  f000				  -	      lda	hssfx_lo,x
    783  f000				  -	      sta	temp1
    784  f000				  -	      lda	hssfx_hi,x
    785  f000				  -	      sta	temp2
    786  f000				  -	      lda	#0
    787  f000				  -	      sta	temp3
    788  f000				  -	      jmp	schedulesfx
    789  f000				  -
    790  f000				  -hssfx_lo
    791  f000				  -	      .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    792  f000				  -hssfx_hi
    793  f000				  -	      .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    794  f000				  -
    795  f000				  -sfx_hsletterpositionchange
    796  f000				  -	      .byte	$10,$18,$00
    797  f000				  -	      .byte	$02,$06,$08
    798  f000				  -	      .byte	$02,$06,$04
    799  f000				  -	      .byte	$00,$00,$00
    800  f000				  -sfx_hslettertick
    801  f000				  -	      .byte	$10,$18,$00
    802  f000				  -	      .byte	$00,$00,$0a
    803  f000				  -	      .byte	$00,$00,$00
    804  f000				  -
    805  f000				  -highscorelabeladjust1
    806  f000				  -	      .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    807  f000				  -highscorelabeladjust2
    808  f000				  -	      .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    809  f000				  -
    810  f000				  -scorevarlo
    811  f000				  -	      .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    812  f000				  -scorevarhi
    813  f000				  -	      .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    814  f000				  -
    815  f000				  -	      endif		; !isBANKSETBANK
    816  f000				  -
    817  f000				  -	      ifnconst	HSNOLEVELNAMES
    818  f000				  -	      ifnconst	isBANKSETBANK
    819  f000				  -highscoredifficultytextlo
    820  f000				  -	      .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    821  f000				  -highscoredifficultytexthi
    822  f000				  -	      .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    823  f000				  -	      endif		; !isBANKSETBANK
    824  f000				  -
    825  f000				  -	      ifnconst	HSCUSTOMLEVELNAMES
    826  f000				  -	      ifnconst	isBANKSETBANK
    827  f000				  -highscoredifficultytextlen
    828  f000				  -	      .byte	22, 30, 26, 24
    829  f000				  -	      endif		; !isBANKSETBANK
    830  f000				  -
    831  f000				  -	      ifconst	HSCHARSHERE
    832  f000				  -
    833  f000				  -easylevelname
    834  f000				  -	      .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    835  f000				  -mediumlevelname
    836  f000				  -	      .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    837  f000				  -hardlevelname
    838  f000				  -	      .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    839  f000				  -expertlevelname
    840  f000				  -	      .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    841  f000				  -	      endif		; HSCHARSHERE
    842  f000				  -	      else		; HSCUSTOMLEVELNAMES
    843  f000				  -	      include	"7800hsgamediffnames.asm"
    844  f000				  -	      endif		; HSCUSTOMLEVELNAMES
    845  f000				  -	      else		; HSNOLEVELNAMES
    846  f000				  -	      ifconst	HSCHARSHERE
    847  f000				  -HSHIGHSCOREStext
    848  f000				  -	      .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    849  f000				  -	      endif		; HSCHARSHERE
    850  f000				  -	      endif		; HSNOLEVELNAMES
    851  f000				  -
    852  f000				  -	      ifnconst	isBANKSETBANK
    853  f000				  -highscorelabeltextlo
    854  f000				  -	      .byte	<player0label, <player1label, <player2label, <player2label
    855  f000				  -highscorelabeltexthi
    856  f000				  -	      .byte	>player0label, >player1label, >player2label, >player2label
    857  f000				  -	      endif		; !isBANKSETBANK
    858  f000				  -
    859  f000				  -	      ifconst	HSCHARSHERE
    860  f000				  -player0label
    861  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    862  f000				  -
    863  f000				  -player1label
    864  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    865  f000				  -
    866  f000				  -player2label
    867  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    868  f000				  -	      endif		; HSCHARSHERE
    869  f000				  -
    870  f000				  -
    871  f000				  -	      ifconst	HSGAMENAMELEN
    872  f000				  -	      ifconst	HSCHARSHERE
    873  f000				  -HSGAMENAMEtable
    874  f000				  -	      include	"7800hsgamename.asm"
    875  f000				  -	      endif		; HSCHARSHERE
    876  f000				  -	      endif		; HSGAMENAMELEN
    877  f000				  -	      ifconst	HSGAMERANKS
    878  f000				  -	      include	"7800hsgameranks.asm"
    879  f000				  -	      ifconst	HSCHARSHERE
    880  f000				  -highscoreranklabel
    881  f000				  -	      .byte	$11,$00,$0d,$0a,$1a
    882  f000				  -	      endif		; HSCHARSHERE
    883  f000				  -	      endif		; HSGAMERANKS
    884  f000				  -
    885  f000				  -			;ensure our table doesn't wrap a page...
    886  f000				  -	      if	((<*)>251)
    887  f000				  -	      align	256
    888  f000				  -	      endif
    889  f000				  -hsgameslotnumbers
    890  f000				  -	      .byte	33,34,35,36,37
    891  f000				  -	      endif		; hiscorefont
    892  f000				  -
    893  f000				  -
    894  f000				  -	      ifnconst	isBANKSETBANK
    895  f000				  -loaddifficultytable
    896  f000				  -	      lda	gamedifficulty
    897  f000				  -	      and	#$03	; ensure the user hasn't selected an invalid difficulty
    898  f000				  -	      sta	gamedifficulty
    899  f000				  -	      cmp	hsdifficulty	; check game difficulty is the same as RAM table
    900  f000				  -	      bne	loaddifficultytablecontinue1
    901  f000				  -	      rts		; this high score difficulty table is already loaded
    902  f000				  -loaddifficultytablecontinue1
    903  f000				  -	      lda	gamedifficulty
    904  f000				  -	      sta	hsdifficulty
    905  f000				  -			;we need to check the device for the table
    906  f000				  -	      lda	hsdevice
    907  f000				  -	      bne	loaddifficultytablecontinue2
    908  f000				  -			; there's no save device. clear out this table.
    909  f000				  -	      jmp	cleardifficultytablemem
    910  f000				  -loaddifficultytablecontinue2
    911  f000				  -	      lda	hsdevice
    912  f000				  -	      and	#1
    913  f000				  -	      beq	memdeviceisntHSC
    914  f000				  -	      jmp	loaddifficultytableHSC
    915  f000				  -memdeviceisntHSC
    916  f000				  -	      jmp	loaddifficultytableAVOX
    917  f000				  -
    918  f000				  -savedifficultytable
    919  f000				  -			;*** we need to check which device we should use...
    920  f000				  -	      lda	hsdevice
    921  f000				  -	      bne	savedifficultytablerealdevice
    922  f000				  -	      rts		; its a ram device
    923  f000				  -savedifficultytablerealdevice
    924  f000				  -	      and	#1
    925  f000				  -	      beq	savememdeviceisntHSC
    926  f000				  -	      jmp	savedifficultytableHSC
    927  f000				  -savememdeviceisntHSC
    928  f000				  -	      jmp	savedifficultytableAVOX
    929  f000				  -
    930  f000				  -savedifficultytableAVOX
    931  f000				  -			; the load call already setup the memory structure and atarivox memory location
    932  f000				  -	      jsr	savealoadedHSCtablecontinue
    933  f000				  -savedifficultytableAVOXskipconvert
    934  f000				  -	      lda	#HSIDHI
    935  f000				  -	      sta	eeprombuffer
    936  f000				  -	      lda	#HSIDLO
    937  f000				  -	      sta	eeprombuffer+1
    938  f000				  -	      lda	hsdifficulty
    939  f000				  -	      sta	eeprombuffer+2
    940  f000				  -	      lda	#32
    941  f000				  -	      jsr	AVoxWriteBytes
    942  f000				  -	      rts
    943  f000				  -
    944  f000				  -savedifficultytableHSC
    945  f000				  -			;we always load a table before reaching here, so the
    946  f000				  -			;memory structures from the load should be intact...
    947  f000				  -	      ldy	hsgameslot
    948  f000				  -	      bpl	savealoadedHSCtable
    949  f000				  -	      rts
    950  f000				  -savealoadedHSCtable
    951  f000				  -	      lda	HSCGameDifficulty,y
    952  f000				  -	      cmp	#$7F
    953  f000				  -	      bne	savealoadedHSCtablecontinue
    954  f000				  -	      jsr	initializeHSCtableentry
    955  f000				  -savealoadedHSCtablecontinue
    956  f000				  -			;convert our RAM table to HSC format and write it out...
    957  f000				  -	      ldy	#0
    958  f000				  -	      ldx	#0
    959  f000				  -savedifficultytableScores
    960  f000				  -
    961  f000				  -	      lda	HSRAMInitials,x
    962  f000				  -	      sta	temp3
    963  f000				  -	      lda	HSRAMInitials+1,x
    964  f000				  -	      sta	temp4
    965  f000				  -	      lda	HSRAMInitials+2,x
    966  f000				  -	      sta	temp5
    967  f000				  -	      jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    968  f000				  -
    969  f000				  -	      lda	temp1
    970  f000				  -	      sta	(HSGameTableLo),y
    971  f000				  -	      iny
    972  f000				  -	      lda	temp2
    973  f000				  -	      sta	(HSGameTableLo),y
    974  f000				  -	      iny
    975  f000				  -
    976  f000				  -	      lda	HSRAMScores,x
    977  f000				  -	      sta	(HSGameTableLo),y
    978  f000				  -	      iny
    979  f000				  -	      lda	HSRAMScores+1,x
    980  f000				  -	      sta	(HSGameTableLo),y
    981  f000				  -	      iny
    982  f000				  -	      lda	HSRAMScores+2,x
    983  f000				  -	      sta	(HSGameTableLo),y
    984  f000				  -	      iny
    985  f000				  -	      inx
    986  f000				  -	      inx
    987  f000				  -	      inx		; +3
    988  f000				  -	      cpx	#15
    989  f000				  -	      bne	savedifficultytableScores
    990  f000				  -	      rts
    991  f000				  -
    992  f000				  -loaddifficultytableHSC
    993  f000				  -			; routine responsible for loading the difficulty table from HSC
    994  f000				  -	      jsr	findindexHSC
    995  f000				  -	      ldy	hsgameslot
    996  f000				  -	      lda	HSCGameDifficulty,y
    997  f000				  -	      cmp	#$7F
    998  f000				  -	      bne	loaddifficultytableHSCcontinue
    999  f000				  -			;there was an error. use a new RAM table instead...
   1000  f000				  -	      jsr	initializeHSCtableentry
   1001  f000				  -	      jmp	cleardifficultytablemem
   1002  f000				  -loaddifficultytableHSCcontinue
   1003  f000				  -			; parse the data into the HS memory...
   1004  f000				  -	      ldy	#0
   1005  f000				  -	      ldx	#0
   1006  f000				  -loaddifficultytableScores
   1007  f000				  -	      lda	(HSGameTableLo),y
   1008  f000				  -	      sta	temp1
   1009  f000				  -	      iny
   1010  f000				  -	      lda	(HSGameTableLo),y
   1011  f000				  -	      sta	temp2
   1012  f000				  -	      jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1013  f000				  -	      iny
   1014  f000				  -	      lda	(HSGameTableLo),y
   1015  f000				  -	      sta	HSRAMScores,x
   1016  f000				  -	      lda	temp3
   1017  f000				  -	      sta	HSRAMInitials,x
   1018  f000				  -	      inx
   1019  f000				  -	      iny
   1020  f000				  -	      lda	(HSGameTableLo),y
   1021  f000				  -	      sta	HSRAMScores,x
   1022  f000				  -	      lda	temp4
   1023  f000				  -	      sta	HSRAMInitials,x
   1024  f000				  -	      inx
   1025  f000				  -	      iny
   1026  f000				  -	      lda	(HSGameTableLo),y
   1027  f000				  -	      sta	HSRAMScores,x
   1028  f000				  -	      lda	temp5
   1029  f000				  -	      sta	HSRAMInitials,x
   1030  f000				  -	      inx
   1031  f000				  -	      iny
   1032  f000				  -	      cpx	#15
   1033  f000				  -	      bne	loaddifficultytableScores
   1034  f000				  -	      rts
   1035  f000				  -
   1036  f000				  -decodeHSCInitials
   1037  f000				  -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1038  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1039  f000				  -	      lda	#0
   1040  f000				  -	      sta	temp4
   1041  f000				  -	      lda	temp1
   1042  f000				  -	      and	#%00011111
   1043  f000				  -	      sta	temp3
   1044  f000				  -
   1045  f000				  -	      lda	temp2
   1046  f000				  -	      and	#%00011111
   1047  f000				  -	      sta	temp5
   1048  f000				  -
   1049  f000				  -	      lda	temp1
   1050  f000				  -	      asl
   1051  f000				  -	      rol	temp4
   1052  f000				  -	      asl
   1053  f000				  -	      rol	temp4
   1054  f000				  -	      asl
   1055  f000				  -	      rol	temp4
   1056  f000				  -	      lda	temp2
   1057  f000				  -	      asl
   1058  f000				  -	      rol	temp4
   1059  f000				  -	      asl
   1060  f000				  -	      rol	temp4
   1061  f000				  -	      rts
   1062  f000				  -encodeHSCInitials
   1063  f000				  -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1064  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1065  f000				  -			; start with packing temp1...
   1066  f000				  -	      lda	temp4
   1067  f000				  -	      and	#%00011100
   1068  f000				  -	      sta	temp1
   1069  f000				  -	      asl	temp1
   1070  f000				  -	      asl	temp1
   1071  f000				  -	      asl	temp1
   1072  f000				  -	      lda	temp3
   1073  f000				  -	      and	#%00011111
   1074  f000				  -	      ora	temp1
   1075  f000				  -	      sta	temp1
   1076  f000				  -			; ...temp1 is now packed, on to temp2...
   1077  f000				  -	      lda	temp5
   1078  f000				  -	      asl
   1079  f000				  -	      asl
   1080  f000				  -	      ror	temp4
   1081  f000				  -	      ror
   1082  f000				  -	      ror	temp4
   1083  f000				  -	      ror
   1084  f000				  -	      sta	temp2
   1085  f000				  -	      rts
   1086  f000				  -
   1087  f000				  -findindexHSCerror
   1088  f000				  -			;the HSC is stuffed. return the bad slot flag
   1089  f000				  -	      ldy	#$ff
   1090  f000				  -	      sty	hsgameslot
   1091  f000				  -	      rts
   1092  f000				  -
   1093  f000				  -findindexHSC
   1094  f000				  -HSCGameID1 =	$1029
   1095  f000				  -HSCGameID2 =	$106E
   1096  f000				  -HSCGameDifficulty =	$10B3
   1097  f000				  -HSCGameIndex =	$10F8
   1098  f000				  -			; routine responsible for finding the game index from HSC
   1099  f000				  -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1100  f000				  -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1101  f000				  -	      ldy	#69	; start +1 to account for the dey
   1102  f000				  -findindexHSCloop
   1103  f000				  -	      dey
   1104  f000				  -	      bmi	findindexHSCerror
   1105  f000				  -	      lda	HSCGameDifficulty,y
   1106  f000				  -	      cmp	#$7F
   1107  f000				  -	      beq	findourindexHSC
   1108  f000				  -	      cmp	gamedifficulty
   1109  f000				  -	      bne	findindexHSCloop
   1110  f000				  -	      lda	HSCGameID1,y
   1111  f000				  -	      cmp	#HSIDHI
   1112  f000				  -	      bne	findindexHSCloop
   1113  f000				  -	      lda	HSCGameID2,y
   1114  f000				  -	      cmp	#HSIDLO
   1115  f000				  -	      bne	findindexHSCloop
   1116  f000				  -findourindexHSC
   1117  f000				  -			; if we're here we found our index in the table
   1118  f000				  -			; or we found the first empty one
   1119  f000				  -	      sty	hsgameslot
   1120  f000				  -	      jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1121  f000				  -	      rts
   1122  f000				  -
   1123  f000				  -
   1124  f000				  -initializeHSCtableentry
   1125  f000				  -	      ldy	hsgameslot
   1126  f000				  -			; we need to make a new entry...
   1127  f000				  -	      lda	#HSIDHI
   1128  f000				  -	      sta	HSCGameID1,y
   1129  f000				  -	      lda	#HSIDLO
   1130  f000				  -	      sta	HSCGameID2,y
   1131  f000				  -	      lda	gamedifficulty
   1132  f000				  -	      sta	HSCGameDifficulty,y
   1133  f000				  -	      ldx	#0
   1134  f000				  -fixHSDGameDifficultylistLoop
   1135  f000				  -	      inx
   1136  f000				  -	      txa
   1137  f000				  -	      sta	HSCGameIndex,y
   1138  f000				  -	      iny
   1139  f000				  -	      cpy	#69
   1140  f000				  -	      bne	fixHSDGameDifficultylistLoop
   1141  f000				  -	      rts
   1142  f000				  -
   1143  f000				  -setupHSCGamepointer
   1144  f000				  -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1145  f000				  -	      lda	#$17
   1146  f000				  -	      sta	HSGameTableHi
   1147  f000				  -	      lda	#$FA
   1148  f000				  -	      sta	HSGameTableLo
   1149  f000				  -setupHSCGamepointerLoop
   1150  f000				  -	      lda	HSGameTableLo
   1151  f000				  -	      sec
   1152  f000				  -	      sbc	#25
   1153  f000				  -	      sta	HSGameTableLo
   1154  f000				  -	      lda	HSGameTableHi
   1155  f000				  -	      sbc	#0
   1156  f000				  -	      sta	HSGameTableHi
   1157  f000				  -	      iny
   1158  f000				  -	      cpy	#69
   1159  f000				  -	      bne	setupHSCGamepointerLoop
   1160  f000				  -	      rts
   1161  f000				  -
   1162  f000				  -loaddifficultytableAVOX
   1163  f000				  -			; routine responsible for loading the difficulty table from Avox
   1164  f000				  -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1165  f000				  -	      lda	#>(eeprombuffer+3)
   1166  f000				  -	      sta	HSGameTableHi
   1167  f000				  -	      lda	#<(eeprombuffer+3)
   1168  f000				  -	      sta	HSGameTableLo
   1169  f000				  -
   1170  f000				  -			; the start location in EEPROM, subtract 32...
   1171  f000				  -	      lda	#$5F
   1172  f000				  -	      sta	HSVoxHi
   1173  f000				  -	      lda	#$E0
   1174  f000				  -	      sta	HSVoxLo
   1175  f000				  -	      lda	#0
   1176  f000				  -	      sta	temp1
   1177  f000				  -loaddifficultytableAVOXloop
   1178  f000				  -	      inc	temp1
   1179  f000				  -	      beq	loaddifficultytableAVOXfull
   1180  f000				  -	      clc
   1181  f000				  -	      lda	HSVoxLo
   1182  f000				  -	      adc	#32
   1183  f000				  -	      sta	HSVoxLo
   1184  f000				  -	      lda	HSVoxHi
   1185  f000				  -	      adc	#0
   1186  f000				  -	      sta	HSVoxHi
   1187  f000				  -	      lda	#3
   1188  f000				  -	      jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1189  f000				  -	      lda	eeprombuffer
   1190  f000				  -	      cmp	#$FF
   1191  f000				  -	      beq	loaddifficultytableAVOXempty
   1192  f000				  -	      cmp	#HSIDHI
   1193  f000				  -	      bne	loaddifficultytableAVOXloop
   1194  f000				  -	      lda	eeprombuffer+1
   1195  f000				  -	      cmp	#HSIDLO
   1196  f000				  -	      bne	loaddifficultytableAVOXloop
   1197  f000				  -	      lda	eeprombuffer+2
   1198  f000				  -	      cmp	gamedifficulty
   1199  f000				  -	      bne	loaddifficultytableAVOXloop
   1200  f000				  -loaddifficultytableAVOXdone
   1201  f000				  -	      lda	#32
   1202  f000				  -	      jsr	AVoxReadBytes
   1203  f000				  -	      jsr	loaddifficultytableHSCcontinue
   1204  f000				  -	      rts
   1205  f000				  -loaddifficultytableAVOXfull
   1206  f000				  -	      lda	#0
   1207  f000				  -	      sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1208  f000				  -loaddifficultytableAVOXempty
   1209  f000				  -	      jmp	cleardifficultytablemem
   1210  f000				  -	      rts
   1211  f000				  -
   1212  f000				  -cleardifficultytablemem
   1213  f000				  -	      ldy	#29
   1214  f000				  -	      lda	#0
   1215  f000				  -cleardifficultytablememloop
   1216  f000				  -	      sta	HSRAMTable,y
   1217  f000				  -	      dey
   1218  f000				  -	      bpl	cleardifficultytablememloop
   1219  f000				  -	      rts
   1220  f000				  -hiscoremoduleend
   1221  f000				  -
   1222  f000				  -	      ifconst	DOUBLEWIDE
   1223  f000				  -plotvaluedw
   1224  f000				  -plotdigitcount =	temp6
   1225  f000				  -	      lda	#0
   1226  f000				  -	      tay
   1227  f000				  -	      ldx	valbufend
   1228  f000				  -
   1229  f000				  -	      lda	plotdigitcount
   1230  f000				  -	      and	#1
   1231  f000				  -	      beq	pvnibble2chardw
   1232  f000				  -	      lda	#0
   1233  f000				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   1234  f000				  -	      beq	pvnibble2char_skipnibbledw
   1235  f000				  -
   1236  f000				  -pvnibble2chardw
   1237  f000				  -			; high nibble...
   1238  f000				  -	      lda	(temp7),y
   1239  f000				  -	      and	#$f0
   1240  f000				  -	      lsr
   1241  f000				  -	      lsr
   1242  f000				  -	      lsr
   1243  f000				  -	      lsr
   1244  f000				  -
   1245  f000				  -	      clc
   1246  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1247  f000				  -	      sta	VALBUFFER,x
   1248  f000				  -	      inx
   1249  f000				  -	      dec	plotdigitcount
   1250  f000				  -pvnibble2char_skipnibbledw
   1251  f000				  -			; low nibble...
   1252  f000				  -	      lda	(temp7),y
   1253  f000				  -	      and	#$0f
   1254  f000				  -	      clc
   1255  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1256  f000				  -	      sta	VALBUFFER,x
   1257  f000				  -	      inx
   1258  f000				  -	      iny
   1259  f000				  -
   1260  f000				  -	      dec	plotdigitcount
   1261  f000				  -	      bne	pvnibble2chardw
   1262  f000				  -			;point to the start of our valuebuffer
   1263  f000				  -	      clc
   1264  f000				  -	      lda	#<VALBUFFER
   1265  f000				  -	      adc	valbufend
   1266  f000				  -	      sta	temp1
   1267  f000				  -	      lda	#>VALBUFFER
   1268  f000				  -	      adc	#0
   1269  f000				  -	      sta	temp2
   1270  f000				  -
   1271  f000				  -			;advance valbufend to the end of our value buffer
   1272  f000				  -	      stx	valbufend
   1273  f000				  -
   1274  f000				  -	      ifnconst	plotvalueonscreen
   1275  f000				  -	      jmp	plotcharacters
   1276  f000				  -	      else
   1277  f000				  -	      jmp	plotcharacterslive
   1278  f000				  -	      endif
   1279  f000				  -	      endif		; DOUBLEWIDE
   1280  f000				  -
   1281  f000				  -hiscoreend
   1282  f000				  -	      echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1283  f000				  -	      endif		; !isBANKSETBANK
   1284  f000					      endif		; HSSUPPORT
   1285  f000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3336  f000					      endif
   3337  f000					      ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  f000					      include	fourbitfade.asm
      1  f000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  f000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  f000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  f000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  f000							; **	      other registers are preserved
      6  f000
      7  f000				  -	      ifconst	FOURBITFADE
      8  f000				  -
      9  f000				  -			; non-interrupt routine
     10  f000				  -
     11  f000				  -fourbitfade
     12  f000				  -	      sty	fourbittemp1
     13  f000				  -	      pha
     14  f000				  -	      and	#$0F
     15  f000				  -	      ora	fourbitfadevalue
     16  f000				  -	      tay
     17  f000				  -	      pla
     18  f000				  -	      and	#$F0
     19  f000				  -	      ora	fourbitfadelut,y
     20  f000				  -	      ldy	fourbittemp1	; restore Y
     21  f000				  -	      rts
     22  f000				  -
     23  f000				  -			; interrupt routine
     24  f000				  -
     25  f000				  -fourbitfadeint
     26  f000				  -	      sty	fourbittemp1int
     27  f000				  -	      pha
     28  f000				  -	      and	#$0F
     29  f000				  -	      ora	fourbitfadevalueint
     30  f000				  -	      tay
     31  f000				  -	      pla
     32  f000				  -	      and	#$F0
     33  f000				  -	      ora	fourbitfadelut,y
     34  f000				  -	      ldy	fourbittemp1int	; restore Y
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -fourbitfadelut
     38  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  f000				  -	      .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  f000				  -	      .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  f000				  -	      .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  f000				  -	      .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  f000				  -	      .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  f000				  -	      .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  f000				  -
     55  f000				  -fourbitfadeend
     56  f000				  -
     57  f000				  -	      echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes)"
     58  f000				  -
     59  f000					      endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\160A_16pixelzone.bas.asm
   3339  f000					      endif
   3340  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3341  f000
   3342  f000							;standard routimes needed for pretty much all games
   3343  f000
   3344  f000							; some definitions used with "set debug color"
   3345  f000		       00 91	   DEBUGCALC  =	$91
   3346  f000		       00 41	   DEBUGWASTE =	$41
   3347  f000		       00 c1	   DEBUGDRAW  =	$C1
   3348  f000
   3349  f000							;NMI and IRQ handlers
   3350  f000				   NMI
   3351  f000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   3352  f000		       48		      pha		; save A
   3353  f001		       d8		      cld
   3354  f002		       a5 4d		      lda	visibleover
   3355  f004		       49 ff		      eor	#255
   3356  f006		       85 4d		      sta	visibleover
   3357  f008				  -	      ifconst	DEBUGINTERRUPT
   3358  f008				  -	      and	#$93
   3359  f008				  -	      sta	BACKGRND
   3360  f008					      endif
   3361  f008		       8a		      txa		; save X
   3362  f009		       48		      pha
   3363  f00a		       98		      tya		; save Y
   3364  f00b		       48		      pha
   3365  f00c		       ce b2 01 	      dec	interruptindex
   3366  f00f		       d0 03		      bne	skipreallyoffvisible
   3367  f011		       4c 7b f0 	      jmp	reallyoffvisible
   3368  f014				   skipreallyoffvisible
   3369  f014		       a5 4d		      lda	visibleover
   3370  f016		       d0 03		      bne	carryontopscreenroutine
   3371  f018				  -	      ifconst	.bottomscreenroutine
   3372  f018				  -	      lda	interrupthold
   3373  f018				  -	      beq	skipbottomroutine
   3374  f018				  -	      jsr	.bottomscreenroutine
   3375  f018				  -skipbottomroutine
   3376  f018					      endif
   3377  f018		       4c 89 f0 	      jmp	NMIexit
   3378  f01b				   carryontopscreenroutine
   3379  f01b					      ifconst	.topscreenroutine
   3380  f01b		       ad c3 01 	      lda	interrupthold
   3381  f01e		       f0 03		      beq	skiptoproutine
   3382  f020		       20 2a 46 	      jsr	.topscreenroutine
   3383  f023				   skiptoproutine
   3384  f023					      endif
   3385  f023					      ifnconst	CANARYOFF
   3386  f023		       ad c4 01 	      lda	canary
   3387  f026		       f0 07		      beq	skipcanarytriggered
   3388  f028		       a9 45		      lda	#$45
   3389  f02a		       85 20		      sta	BACKGRND
   3390  f02c		       4c 73 f0 	      jmp	skipbrkolorset	; common crash dump routine, if available
   3391  f02f				   skipcanarytriggered
   3392  f02f					      endif
   3393  f02f
   3394  f02f		       ee 3e 21 	      inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   3395  f032
   3396  f032							; ** Other important routines that need to regularly run, and can run onscreen.
   3397  f032							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   3398  f032
   3399  f032				  -	      ifconst	LONGCONTROLLERREAD
   3400  f032				  -longcontrollerreads		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   3401  f032				  -	      ldy	port1control
   3402  f032				  -	      lda	longreadtype,y
   3403  f032				  -	      beq	LLRET1
   3404  f032				  -	      tay
   3405  f032				  -	      lda	longreadroutinehiP1,y
   3406  f032				  -	      sta	inttemp4
   3407  f032				  -	      lda	longreadroutineloP1,y
   3408  f032				  -	      sta	inttemp3
   3409  f032				  -	      jmp	(inttemp3)
   3410  f032				  -LLRET1
   3411  f032				  -	      ldy	port0control
   3412  f032				  -	      lda	longreadtype,y
   3413  f032				  -	      beq	LLRET0
   3414  f032				  -	      tay
   3415  f032				  -	      lda	longreadroutinehiP0,y
   3416  f032				  -	      sta	inttemp4
   3417  f032				  -	      lda	longreadroutineloP0,y
   3418  f032				  -	      sta	inttemp3
   3419  f032				  -	      jmp	(inttemp3)
   3420  f032				  -LLRET0
   3421  f032				  -
   3422  f032				  -
   3423  f032				  -	      ifconst	PADDLERANGE
   3424  f032				  -TIMEVAL    =	PADDLERANGE
   3425  f032				  -	      else
   3426  f032				  -TIMEVAL    =	160
   3427  f032				  -	      endif
   3428  f032				  -TIMEOFFSET =	10
   3429  f032				  -
   3430  f032					      endif		; LONGCONTROLLERREAD
   3431  f032
   3432  f032
   3433  f032		       20 0e f2 	      jsr	servicesfxchannels
   3434  f035				  -	      ifconst	MUSICTRACKER
   3435  f035				  -	      jsr	servicesong
   3436  f035					      endif		; MUSICTRACKER
   3437  f035				  -	      ifconst	RMT
   3438  f035				  -	      lda	rasterpause
   3439  f035				  -	      beq	skiprasterupdate
   3440  f035				  -	      jsr	RASTERMUSICTRACKER+3
   3441  f035				  -skiprasterupdate
   3442  f035				  -RMT_Iend
   3443  f035					      endif
   3444  f035
   3445  f035		       ee a4 01 	      inc	framecounter
   3446  f038		       ad a4 01 	      lda	framecounter
   3447  f03b		       29 3f		      and	#63
   3448  f03d		       d0 08		      bne	skipcountdownseconds
   3449  f03f		       ad a5 01 	      lda	countdownseconds
   3450  f042		       f0 03		      beq	skipcountdownseconds
   3451  f044		       ce a5 01 	      dec	countdownseconds
   3452  f047				   skipcountdownseconds
   3453  f047
   3454  f047		       a2 01		      ldx	#1
   3455  f049				   buttonreadloop
   3456  f049		       8a		      txa
   3457  f04a		       48		      pha
   3458  f04b		       bc b9 01 	      ldy	port0control,x
   3459  f04e		       b9 eb f1 	      lda	buttonhandlerlo,y
   3460  f051		       85 da		      sta	inttemp3
   3461  f053		       b9 df f1 	      lda	buttonhandlerhi,y
   3462  f056		       85 db		      sta	inttemp4
   3463  f058		       05 da		      ora	inttemp3
   3464  f05a		       f0 03		      beq	buttonreadloopreturn
   3465  f05c		       6c da 00 	      jmp	(inttemp3)
   3466  f05f				   buttonreadloopreturn
   3467  f05f		       68		      pla
   3468  f060		       aa		      tax
   3469  f061		       ca		      dex
   3470  f062		       10 e5		      bpl	buttonreadloop
   3471  f064
   3472  f064							;ifconst KEYPADSUPPORT
   3473  f064							;  jsr keypadrowselect
   3474  f064							;endif ; KEYPADSUPPORT
   3475  f064
   3476  f064
   3477  f064					      ifconst	DOUBLEBUFFER
   3478  f064		       ad b4 01 	      lda	doublebufferminimumframeindex
   3479  f067		       f0 03		      beq	skipdoublebufferminimumframeindexadjust
   3480  f069		       ce b4 01 	      dec	doublebufferminimumframeindex
   3481  f06c				   skipdoublebufferminimumframeindexadjust
   3482  f06c					      endif
   3483  f06c
   3484  f06c		       4c 89 f0 	      jmp	NMIexit
   3485  f06f
   3486  f06f				   IRQ			; the only source of non-nmi interrupt should be the BRK opcode.
   3487  f06f					      ifnconst	BREAKPROTECTOFF
   3488  f06f		       a9 1a		      lda	#$1A
   3489  f071		       85 20		      sta	BACKGRND
   3490  f073				   skipbrkolorset
   3491  f073				   skipbrkdetected
   3492  f073		       a9 60		      lda	#$60
   3493  f075		       8d 07 21 	      sta	sCTRL
   3494  f078		       85 3c		      sta	CTRL
   3495  f07a					      ifnconst	hiscorefont
   3496  f07a		       02		      .byte.b	$02	; KIL/JAM
   3497  f07b				  -	      else		; hiscorefont is present
   3498  f07b				  -	      ifconst	CRASHDUMP
   3499  f07b				  -	      bit	MSTAT
   3500  f07b				  -	      bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   3501  f07b				  -
   3502  f07b				  -	      ifconst	dumpbankswitch
   3503  f07b				  -	      lda	dumpbankswitch
   3504  f07b				  -	      pha
   3505  f07b				  -	      endif
   3506  f07b				  -
   3507  f07b				  -			; bankswitch if needed, to get to the hiscore font
   3508  f07b				  -	      ifconst	bankswitchmode
   3509  f07b				  -	      ifconst	included.hiscore.asm.bank
   3510  f07b				  -	      ifconst	MCPDEVCART
   3511  f07b				  -	      lda	#($18 | included.hiscore.asm.bank)
   3512  f07b				  -	      sta	$3000
   3513  f07b				  -	      else
   3514  f07b				  -	      lda	#(included.hiscore.asm.bank)
   3515  f07b				  -	      sta	$8000
   3516  f07b				  -	      endif
   3517  f07b				  -	      endif		; included.hiscore.asm.bank
   3518  f07b				  -	      endif		; bankswitchmode
   3519  f07b				  -
   3520  f07b				  -	      ifconst	DOUBLEBUFFER
   3521  f07b				  -			;turn off double-buffering, if on...
   3522  f07b				  -	      lda	#>DLLMEM
   3523  f07b				  -	      sta	DPPH
   3524  f07b				  -	      lda	#<DLLMEM
   3525  f07b				  -	      sta	DPPL
   3526  f07b				  -	      endif
   3527  f07b				  -
   3528  f07b				  -	      lda	#$00
   3529  f07b				  -	      sta	P0C2
   3530  f07b				  -
   3531  f07b				  -			;update the second-from-top DL...
   3532  f07b				  -	      ldy	#8
   3533  f07b				  -NMIupdatetopDL
   3534  f07b				  -	      lda	show2700,y
   3535  f07b				  -	      sta	ZONE1ADDRESS,y
   3536  f07b				  -	      dey
   3537  f07b				  -	      bpl	NMIupdatetopDL
   3538  f07b				  -
   3539  f07b				  -			; the hiscore font is present, so we try to output the stack
   3540  f07b				  -	      ldy	#0
   3541  f07b				  -copystackloop
   3542  f07b				  -	      pla
   3543  f07b				  -	      pha
   3544  f07b				  -	      lsr
   3545  f07b				  -	      lsr
   3546  f07b				  -	      lsr
   3547  f07b				  -	      lsr
   3548  f07b				  -	      tax
   3549  f07b				  -	      lda	hiscorehexlut,x
   3550  f07b				  -	      sta	$2700,y
   3551  f07b				  -	      iny
   3552  f07b				  -
   3553  f07b				  -	      pla
   3554  f07b				  -	      and	#$0F
   3555  f07b				  -	      tax
   3556  f07b				  -	      lda	hiscorehexlut,x
   3557  f07b				  -	      sta	$2700,y
   3558  f07b				  -	      iny
   3559  f07b				  -
   3560  f07b				  -	      lda	#27	; period
   3561  f07b				  -	      sta	$2700,y
   3562  f07b				  -	      iny
   3563  f07b				  -
   3564  f07b				  -	      cpy	#30
   3565  f07b				  -	      bne	copystackloop
   3566  f07b				  -
   3567  f07b				  -	      lda	#>hiscorefont
   3568  f07b				  -	      sta	CHARBASE
   3569  f07b				  -	      sta	sCHARBASE
   3570  f07b				  -	      lda	#%01000011	;Enable DMA, mode=320A
   3571  f07b				  -	      sta	CTRL
   3572  f07b				  -	      sta	sCTRL
   3573  f07b				  -	      .byte	$02	; KIL/JAM
   3574  f07b				  -hiscorehexlut
   3575  f07b				  -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   3576  f07b				  -	      .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   3577  f07b				  -show2700
   3578  f07b				  -			;	 lo   mode	   hi	width=29  x   EODL
   3579  f07b				  -	      .byte	$00, %01100000, $27, 3, 20, 0,0,0
   3580  f07b				  -	      else		; CRASHDUMP
   3581  f07b				  -	      .byte	$02	; KIL/JAM
   3582  f07b				  -	      endif		; crashdump
   3583  f07b					      endif		; hiscorefont
   3584  f07b				  -	      else
   3585  f07b				  -	      RTI
   3586  f07b					      endif
   3587  f07b
   3588  f07b				  -	      ifconst	LONGCONTROLLERREAD
   3589  f07b				  -
   3590  f07b				  -longreadtype
   3591  f07b				  -	      .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   3592  f07b				  -	      .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   3593  f07b				  -	      .byte	3, 3, 0, 0	; STMOUSE  AMOUSE    ATARIVOX	SNES
   3594  f07b				  -
   3595  f07b				  -longreadroutineloP0
   3596  f07b				  -	      .byte	<LLRET0	;  0 = no routine
   3597  f07b				  -	      .byte	<paddleport0update	;  1 = paddle
   3598  f07b				  -	      .byte	<trakball0update	;  2 = trakball
   3599  f07b				  -	      .byte	<mouse0update	;  3 = mouse
   3600  f07b				  -
   3601  f07b				  -longreadroutinehiP0
   3602  f07b				  -	      .byte	>LLRET0	;  0 = no routine
   3603  f07b				  -	      .byte	>paddleport0update	;  1 = paddle
   3604  f07b				  -	      .byte	>trakball0update	;  2 = trackball
   3605  f07b				  -	      .byte	>mouse0update	;  3 = mouse
   3606  f07b				  -
   3607  f07b				  -longreadroutineloP1
   3608  f07b				  -	      .byte	<LLRET1	;  0 = no routine
   3609  f07b				  -	      .byte	<paddleport1update	;  1 = paddle
   3610  f07b				  -	      .byte	<trakball1update	;  2 = trakball
   3611  f07b				  -	      .byte	<mouse1update	;  3 = mouse
   3612  f07b				  -
   3613  f07b				  -longreadroutinehiP1
   3614  f07b				  -	      .byte	>LLRET1	;  0 = no routine
   3615  f07b				  -	      .byte	>paddleport1update	;  1 = paddle
   3616  f07b				  -	      .byte	>trakball1update	;  2 = trackball
   3617  f07b				  -	      .byte	>mouse1update	;  3 = mouse
   3618  f07b				  -
   3619  f07b				  -
   3620  f07b				  -SETTIM64T
   3621  f07b				  -	      bne	skipdefaulttime
   3622  f07b				  -	      ifnconst	PADDLESMOOTHINGOFF
   3623  f07b				  -	      lda	#(TIMEVAL+TIMEOFFSET+1)
   3624  f07b				  -	      else
   3625  f07b				  -	      lda	#(TIMEVAL+TIMEOFFSET)
   3626  f07b				  -	      endif
   3627  f07b				  -skipdefaulttime
   3628  f07b				  -	      tay
   3629  f07b				  -	      dey
   3630  f07b				  -.setTIM64Tloop
   3631  f07b				  -	      sta	TIM64T
   3632  f07b				  -	      cpy	INTIM
   3633  f07b				  -	      bne	.setTIM64Tloop
   3634  f07b				  -	      rts
   3635  f07b					      endif		; LONGCONTROLLERREAD
   3636  f07b
   3637  f07b				   reallyoffvisible
   3638  f07b		       85 24		      sta	WSYNC
   3639  f07d
   3640  f07d		       a9 00		      lda	#0
   3641  f07f		       85 4d		      sta	visibleover
   3642  f081				  -	      ifconst	DEBUGINTERRUPT
   3643  f081				  -	      sta	BACKGRND
   3644  f081					      endif
   3645  f081
   3646  f081		       a9 03		      lda	#3
   3647  f083		       8d b2 01 	      sta	interruptindex
   3648  f086
   3649  f086		       20 80 f1 	      jsr	uninterruptableroutines
   3650  f089
   3651  f089				  -	      ifconst	.userinterrupt
   3652  f089				  -	      lda	interrupthold
   3653  f089				  -	      beq	skipuserintroutine
   3654  f089				  -	      jsr	.userinterrupt
   3655  f089				  -skipuserintroutine
   3656  f089					      endif
   3657  f089
   3658  f089				  -	      ifconst	KEYPADSUPPORT
   3659  f089				  -	      jsr	keypadcolumnread
   3660  f089				  -	      jsr	keypadrowselect
   3661  f089					      endif
   3662  f089
   3663  f089				   NMIexit
   3664  f089		       68		      pla
   3665  f08a		       a8		      tay
   3666  f08b		       68		      pla
   3667  f08c		       aa		      tax
   3668  f08d		       68		      pla
   3669  f08e		       40		      RTI
   3670  f08f
   3671  f08f				   clearscreen
   3672  f08f		       a2 0b		      ldx	#(WZONECOUNT-1)
   3673  f091		       a9 00		      lda	#0
   3674  f093				   clearscreenloop
   3675  f093		       95 65		      sta	dlend,x
   3676  f095		       ca		      dex
   3677  f096		       10 fb		      bpl	clearscreenloop
   3678  f098		       a9 00		      lda	#0
   3679  f09a		       8d ad 01 	      sta	valbufend	; clear the bcd value buffer
   3680  f09d		       8d ae 01 	      sta	valbufendsave
   3681  f0a0		       60		      rts
   3682  f0a1
   3683  f0a1				   restorescreen
   3684  f0a1		       a2 0b		      ldx	#(WZONECOUNT-1)
   3685  f0a3		       a9 00		      lda	#0
   3686  f0a5				   restorescreenloop
   3687  f0a5		       b5 82		      lda	dlendsave,x
   3688  f0a7		       95 65		      sta	dlend,x
   3689  f0a9		       ca		      dex
   3690  f0aa		       10 f9		      bpl	restorescreenloop
   3691  f0ac		       ad ae 01 	      lda	valbufendsave
   3692  f0af		       8d ad 01 	      sta	valbufend
   3693  f0b2		       60		      rts
   3694  f0b3
   3695  f0b3				   savescreen
   3696  f0b3		       a2 0b		      ldx	#(WZONECOUNT-1)
   3697  f0b5				   savescreenloop
   3698  f0b5		       b5 65		      lda	dlend,x
   3699  f0b7		       95 82		      sta	dlendsave,x
   3700  f0b9		       ca		      dex
   3701  f0ba		       10 f9		      bpl	savescreenloop
   3702  f0bc		       ad ad 01 	      lda	valbufend
   3703  f0bf		       8d ae 01 	      sta	valbufendsave
   3704  f0c2					      ifconst	DOUBLEBUFFER
   3705  f0c2		       a5 d5		      lda	doublebufferstate
   3706  f0c4		       f0 04		      beq	savescreenrts
   3707  f0c6		       a9 01		      lda	#1
   3708  f0c8		       85 d7		      sta	doublebufferbufferdirty
   3709  f0ca				   savescreenrts
   3710  f0ca					      endif		; DOUBLEBUFFER
   3711  f0ca		       60		      rts
   3712  f0cb
   3713  f0cb				   drawscreen
   3714  f0cb
   3715  f0cb					      ifconst	interrupthold
   3716  f0cb		       a9 ff		      lda	#$FF
   3717  f0cd		       8d c3 01 	      sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   3718  f0d0					      endif
   3719  f0d0
   3720  f0d0		       a9 00		      lda	#0
   3721  f0d2		       85 42		      sta	temp1	; not B&W if we're here...
   3722  f0d4
   3723  f0d4				   drawscreenwait
   3724  f0d4		       a5 4d		      lda	visibleover
   3725  f0d6		       d0 fc		      bne	drawscreenwait	; make sure the visible screen isn't being drawn
   3726  f0d8
   3727  f0d8							;restore some registers in case the game changed them mid-screen...
   3728  f0d8		       ad 07 21 	      lda	sCTRL
   3729  f0db		       05 42		      ora	temp1
   3730  f0dd		       85 3c		      sta	CTRL
   3731  f0df		       ad 0b 21 	      lda	sCHARBASE
   3732  f0e2		       85 34		      sta	CHARBASE
   3733  f0e4
   3734  f0e4							;ensure all of the display list is terminated...
   3735  f0e4		       20 5d f1 	      jsr	terminatedisplaylist
   3736  f0e7
   3737  f0e7					      ifnconst	pauseroutineoff
   3738  f0e7		       20 f2 f0 	      jsr	pauseroutine
   3739  f0ea					      endif		; pauseroutineoff
   3740  f0ea
   3741  f0ea							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   3742  f0ea							; delaying a full frame, but still allowing time for basic calculations.
   3743  f0ea				   visiblescreenstartedwait
   3744  f0ea		       a5 4d		      lda	visibleover
   3745  f0ec		       f0 fc		      beq	visiblescreenstartedwait
   3746  f0ee				   visiblescreenstartedwaitdone
   3747  f0ee		       ce 3e 21 	      dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   3748  f0f1		       60		      rts
   3749  f0f2
   3750  f0f2					      ifnconst	pauseroutineoff
   3751  f0f2							; check to see if pause was pressed and released
   3752  f0f2				   pauseroutine
   3753  f0f2		       ad b5 01 	      lda	pausedisable
   3754  f0f5		       d0 55		      bne	leavepauseroutine
   3755  f0f7		       a9 08		      lda	#8
   3756  f0f9		       2c 82 02 	      bit	SWCHB
   3757  f0fc		       f0 30		      beq	pausepressed
   3758  f0fe
   3759  f0fe					      ifnconst	SOFTPAUSEOFF
   3760  f0fe					      ifnconst	SOFTRESETASPAUSEOFF
   3761  f0fe					      ifnconst	MOUSESUPPORT
   3762  f0fe					      ifnconst	TRAKBALLSUPPORT
   3763  f0fe		       ad b9 01 	      lda	port0control
   3764  f101		       c9 0b		      cmp	#11
   3765  f103		       d0 07		      bne	skipsoftpause
   3766  f105		       ad 80 02 	      lda	SWCHA	; then check the soft "RESET" joysick code...
   3767  f108		       29 70		      and	#%01110000	; _LDU
   3768  f10a		       f0 22		      beq	pausepressed
   3769  f10c				   skipsoftpause
   3770  f10c					      endif
   3771  f10c					      endif
   3772  f10c					      endif
   3773  f10c					      endif
   3774  f10c				  -	      ifconst	SNES0PAUSE
   3775  f10c				  -	      lda	port0control
   3776  f10c				  -	      cmp	#11
   3777  f10c				  -	      bne	skipsnes0pause
   3778  f10c				  -	      lda	snesdetected0
   3779  f10c				  -	      beq	skipsnes0pause
   3780  f10c				  -	      lda	snes2atari0hi
   3781  f10c				  -	      and	#%00010000
   3782  f10c				  -	      beq	pausepressed
   3783  f10c				  -skipsnes0pause
   3784  f10c					      endif
   3785  f10c				  -	      ifconst	SNES1PAUSE
   3786  f10c				  -
   3787  f10c				  -	      lda	port1control
   3788  f10c				  -	      cmp	#11
   3789  f10c				  -	      bne	skipsnes1pause
   3790  f10c				  -	      lda	snesdetected1
   3791  f10c				  -	      beq	skipsnes1pause
   3792  f10c				  -	      lda	snes2atari1hi
   3793  f10c				  -	      and	#%00010000
   3794  f10c				  -	      beq	pausepressed
   3795  f10c				  -skipsnes1pause
   3796  f10c					      endif
   3797  f10c				  -	      ifconst	SNESNPAUSE
   3798  f10c				  -	      ldx	snesport
   3799  f10c				  -	      lda	port0control,x
   3800  f10c				  -	      cmp	#11
   3801  f10c				  -	      bne	skipsnesNpause
   3802  f10c				  -	      lda	snesdetected0,x
   3803  f10c				  -	      beq	skipsnesNpause
   3804  f10c				  -	      lda	snes2atari0hi,x
   3805  f10c				  -	      and	#%00010000
   3806  f10c				  -	      beq	pausepressed
   3807  f10c				  -skipsnesNpause
   3808  f10c					      endif
   3809  f10c
   3810  f10c							;pause isn't pressed
   3811  f10c		       a9 00		      lda	#0
   3812  f10e		       8d ac 01 	      sta	pausebuttonflag	; clear pause hold state in case its set
   3813  f111
   3814  f111							;check if we're in an already paused state
   3815  f111		       ad 00 21 	      lda	pausestate
   3816  f114		       f0 36		      beq	leavepauseroutine	; nope, leave
   3817  f116
   3818  f116		       c9 01		      cmp	#1	; last frame was the start of pausing
   3819  f118		       f0 2b		      beq	enterpausestate2	; move from state 1 to 2
   3820  f11a
   3821  f11a		       c9 02		      cmp	#2
   3822  f11c		       f0 34		      beq	carryonpausing
   3823  f11e
   3824  f11e							;pausestate must be >2, which means we're ending an unpause 
   3825  f11e		       a9 00		      lda	#0
   3826  f120		       8d ac 01 	      sta	pausebuttonflag
   3827  f123		       8d 00 21 	      sta	pausestate
   3828  f126		       ad 07 21 	      lda	sCTRL
   3829  f129		       85 3c		      sta	CTRL
   3830  f12b		       4c 4c f1 	      jmp	leavepauseroutine
   3831  f12e
   3832  f12e				   pausepressed
   3833  f12e							;pause is pressed
   3834  f12e		       ad ac 01 	      lda	pausebuttonflag
   3835  f131		       c9 ff		      cmp	#$ff
   3836  f133		       f0 1d		      beq	carryonpausing
   3837  f135
   3838  f135							;its a new press, increment the state
   3839  f135		       ee 00 21 	      inc	pausestate
   3840  f138
   3841  f138							;silence volume at the start and end of pausing
   3842  f138		       a9 00		      lda	#0
   3843  f13a		       85 19		      sta	AUDV0
   3844  f13c		       85 1a		      sta	AUDV1
   3845  f13e
   3846  f13e				  -	      ifconst	pokeysupport
   3847  f13e				  -	      ldy	#7
   3848  f13e				  -pausesilencepokeyaudioloop
   3849  f13e				  -	      sta	(pokeybase),y
   3850  f13e				  -	      dey
   3851  f13e				  -	      bpl	pausesilencepokeyaudioloop
   3852  f13e					      endif		; pokeysupport
   3853  f13e
   3854  f13e		       a9 ff		      lda	#$ff
   3855  f140		       8d ac 01 	      sta	pausebuttonflag
   3856  f143		       d0 0d		      bne	carryonpausing
   3857  f145
   3858  f145				   enterpausestate2
   3859  f145		       a9 02		      lda	#2
   3860  f147		       8d 00 21 	      sta	pausestate
   3861  f14a		       d0 06		      bne	carryonpausing
   3862  f14c				   leavepauseroutine
   3863  f14c		       ad 07 21 	      lda	sCTRL
   3864  f14f		       85 3c		      sta	CTRL
   3865  f151		       60		      rts
   3866  f152				   carryonpausing
   3867  f152				  -	      ifconst	.pause
   3868  f152				  -	      jsr	.pause
   3869  f152					      endif		; .pause
   3870  f152		       ad 07 21 	      lda	sCTRL
   3871  f155		       09 80		      ora	#%10000000	; turn off colorburst during pause...
   3872  f157		       85 3c		      sta	CTRL
   3873  f159		       4c f2 f0 	      jmp	pauseroutine
   3874  f15c					      endif		; pauseroutineoff
   3875  f15c
   3876  f15c
   3877  f15c					      ifconst	DOUBLEBUFFER
   3878  f15c				   skipterminatedisplaylistreturn
   3879  f15c		       60		      rts
   3880  f15d					      endif		; DOUBLEBUFFER
   3881  f15d				   terminatedisplaylist
   3882  f15d					      ifconst	DOUBLEBUFFER
   3883  f15d		       a5 d5		      lda	doublebufferstate
   3884  f15f		       d0 fb		      bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   3885  f161					      endif		; DOUBLEBUFFER
   3886  f161				   terminatedisplaybuffer
   3887  f161							;add DL end entry on each DL
   3888  f161		       a2 0b		      ldx	#(WZONECOUNT-1)
   3889  f163				   dlendloop
   3890  f163		       bd 2a f7 	      lda	DLPOINTL,x
   3891  f166					      ifconst	DOUBLEBUFFER
   3892  f166		       18		      clc
   3893  f167		       65 d6		      adc	doublebufferdloffset
   3894  f169					      endif		; DOUBLEBUFFER
   3895  f169		       85 63		      sta	dlpnt
   3896  f16b		       bd 1e f7 	      lda	DLPOINTH,x
   3897  f16e					      ifconst	DOUBLEBUFFER
   3898  f16e		       69 00		      adc	#0
   3899  f170					      endif		; DOUBLEBUFFER
   3900  f170		       85 64		      sta	dlpnt+1
   3901  f172		       b4 65		      ldy	dlend,x
   3902  f174		       a9 00		      lda	#$00
   3903  f176				   dlendmoreloops
   3904  f176		       c8		      iny
   3905  f177		       91 63		      sta	(dlpnt),y
   3906  f179				  -	      ifconst	FRAMESKIPGLITCHFIXWEAK
   3907  f179				  -	      cpy	#DLLASTOBJ+1
   3908  f179				  -	      beq	dlendthiszonedone
   3909  f179				  -	      iny
   3910  f179				  -	      iny
   3911  f179				  -	      iny
   3912  f179				  -	      iny
   3913  f179				  -	      iny
   3914  f179				  -	      sta	(dlpnt),y
   3915  f179				  -dlendthiszonedone
   3916  f179					      endif	FRAMESKIPGLITCHFIXWEAK
   3917  f179				  -	      ifconst	FRAMESKIPGLITCHFIX
   3918  f179				  -	      iny
   3919  f179				  -	      iny
   3920  f179				  -	      iny
   3921  f179				  -	      iny
   3922  f179				  -	      cpy	#DLLASTOBJ-1
   3923  f179				  -	      bcc	dlendmoreloops
   3924  f179					      endif		; FRAMESKIPGLITCHFIX
   3925  f179		       ca		      dex
   3926  f17a		       10 e7		      bpl	dlendloop
   3927  f17c
   3928  f17c					      ifnconst	pauseroutineoff
   3929  f17c		       20 f2 f0 	      jsr	pauseroutine
   3930  f17f					      endif		; pauseroutineoff
   3931  f17f		       60		      rts
   3932  f180
   3933  f180				   uninterruptableroutines
   3934  f180							; this is for routines that must happen off the visible screen, each frame.
   3935  f180
   3936  f180				  -	      ifconst	AVOXVOICE
   3937  f180				  -	      jsr	serviceatarivoxqueue
   3938  f180					      endif
   3939  f180
   3940  f180		       a9 00		      lda	#0
   3941  f182		       8d b8 01 	      sta	palfastframe
   3942  f185		       ad 09 21 	      lda	paldetected
   3943  f188		       f0 10		      beq	skippalframeadjusting
   3944  f18a							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   3945  f18a		       ae b7 01 	      ldx	palframes
   3946  f18d		       e8		      inx
   3947  f18e		       e0 05		      cpx	#5
   3948  f190		       d0 05		      bne	palframeskipdone
   3949  f192		       ee b8 01 	      inc	palfastframe
   3950  f195		       a2 00		      ldx	#0
   3951  f197				   palframeskipdone
   3952  f197		       8e b7 01 	      stx	palframes
   3953  f19a				   skippalframeadjusting
   3954  f19a
   3955  f19a				  -	      ifconst	MUSICTRACKER
   3956  f19a				  -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   3957  f19a				  -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   3958  f19a				  -			; If that happens, we try again here. Chances are very small we'll run into the same
   3959  f19a				  -			; problem twice, and if we do, we just drop a musical note or two.
   3960  f19a				  -	      lda	sfxschedulemissed
   3961  f19a				  -	      beq	servicesongwasnotmissed
   3962  f19a				  -	      jsr	servicesong
   3963  f19a				  -servicesongwasnotmissed
   3964  f19a					      endif		; MUSICTRACKER
   3965  f19a
   3966  f19a				  -	      ifconst	RMT
   3967  f19a				  -	      lda	palfastframe
   3968  f19a				  -	      beq	skiprasterupdate2
   3969  f19a				  -	      lda	rasterpause
   3970  f19a				  -	      beq	skiprasterupdate2
   3971  f19a				  -	      jsr	RASTERMUSICTRACKER+3
   3972  f19a				  -skiprasterupdate2
   3973  f19a					      endif
   3974  f19a
   3975  f19a
   3976  f19a		       60		      rts
   3977  f19b
   3978  f19b				   serviceatarivoxqueue
   3979  f19b				  -	      ifconst	AVOXVOICE
   3980  f19b				  -	      lda	voxlock
   3981  f19b				  -	      bne	skipvoxprocessing	; the vox is in the middle of speech address update
   3982  f19b				  -skipvoxqueuesizedec
   3983  f19b				  -	      jmp	processavoxvoice
   3984  f19b				  -skipvoxprocessing
   3985  f19b				  -	      rts
   3986  f19b				  -
   3987  f19b				  -processavoxvoice
   3988  f19b				  -	      ifconst	HSSUPPORT
   3989  f19b				  -			; ** we skip speech if hi-score is on and no vox was detected
   3990  f19b				  -			; ** this is to avoid later collision with snes pads.
   3991  f19b				  -	      lda	hsdevice
   3992  f19b				  -	      and	#2
   3993  f19b				  -	      beq	processavoxvoicereturn
   3994  f19b				  -	      endif		; HSSUPPORT
   3995  f19b				  -	      lda	avoxenable
   3996  f19b				  -	      bne	avoxfixport
   3997  f19b				  -	      SPKOUT	tempavox
   3998  f19b				  -	      rts
   3999  f19b				  -avoxfixport
   4000  f19b				  -	      lda	#0	; restore the port to all bits as inputs...
   4001  f19b				  -	      sta	CTLSWA
   4002  f19b				  -	      rts
   4003  f19b				  -silenceavoxvoice
   4004  f19b				  -	      SPEAK	avoxsilentdata
   4005  f19b				  -processavoxvoicereturn
   4006  f19b				  -	      rts
   4007  f19b				  -avoxsilentdata
   4008  f19b				  -	      .byte	31,255
   4009  f19b					      else
   4010  f19b		       60		      rts
   4011  f19c					      endif		; AVOXVOICE
   4012  f19c
   4013  f19c				   joybuttonhandler
   4014  f19c		       8a		      txa
   4015  f19d		       0a		      asl
   4016  f19e		       a8		      tay
   4017  f19f		       b9 08 00 	      lda	INPT0,y
   4018  f1a2		       4a		      lsr
   4019  f1a3		       9d 02 21 	      sta	sINPT1,x
   4020  f1a6		       b9 09 00 	      lda	INPT1,y
   4021  f1a9		       29 80		      and	#%10000000
   4022  f1ab		       1d 02 21 	      ora	sINPT1,x
   4023  f1ae		       9d 02 21 	      sta	sINPT1,x
   4024  f1b1
   4025  f1b1		       b5 0c		      lda	INPT4,x
   4026  f1b3		       30 19		      bmi	.skip1bjoyfirecheck
   4027  f1b5							;one button joystick is down
   4028  f1b5		       49 80		      eor	#%10000000
   4029  f1b7		       9d 02 21 	      sta	sINPT1,x
   4030  f1ba
   4031  f1ba		       ad b1 01 	      lda	joybuttonmode
   4032  f1bd		       3d d1 f1 	      and	twobuttonmask,x
   4033  f1c0		       f0 0c		      beq	.skip1bjoyfirecheck
   4034  f1c2		       ad b1 01 	      lda	joybuttonmode
   4035  f1c5		       1d d1 f1 	      ora	twobuttonmask,x
   4036  f1c8		       8d b1 01 	      sta	joybuttonmode
   4037  f1cb		       8d 82 02 	      sta	SWCHB
   4038  f1ce				   .skip1bjoyfirecheck
   4039  f1ce		       4c 5f f0 	      jmp	buttonreadloopreturn
   4040  f1d1
   4041  f1d1				   twobuttonmask
   4042  f1d1		       04 10		      .byte.b	%00000100,%00010000
   4043  f1d3
   4044  f1d3				  -	      ifconst	SNES2ATARISUPPORT
   4045  f1d3				  -
   4046  f1d3				  -SNES_CLOCK_PORT_BIT
   4047  f1d3				  -	      .byte	$10,$01
   4048  f1d3				  -SNES_CTLSWA_MASK
   4049  f1d3				  -	      .byte	$30,$03
   4050  f1d3				  -SNES_CTLSWA_SIGNAL
   4051  f1d3				  -	      .byte	$C0,$0C
   4052  f1d3				  -SWCHA_DIRMASK
   4053  f1d3				  -	      .byte	$F0,$0F
   4054  f1d3				  -SWCHA_INVDIRMASK
   4055  f1d3				  -	      .byte	$0F,$F0
   4056  f1d3				  -
   4057  f1d3				  -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
   4058  f1d3				  -SNES_AUTODETECT
   4059  f1d3				  -	      ifconst	HSSUPPORT
   4060  f1d3				  -			; ** an atarivox might be plugged in, so we skip scanning the second
   4061  f1d3				  -			; ** port for a snes if vox was detected...
   4062  f1d3				  -	      lda	hsdevice	; b1 high means atarivox/savekey was detected
   4063  f1d3				  -	      lsr
   4064  f1d3				  -	      and	#1
   4065  f1d3				  -	      eor	#1
   4066  f1d3				  -	      tax
   4067  f1d3				  -	      else
   4068  f1d3				  -	      ldx	#1
   4069  f1d3				  -	      endif		; HSSUPPORT
   4070  f1d3				  -
   4071  f1d3				  -SNES_AUTODETECT_LOOP
   4072  f1d3				  -	      lda	#1	; proline
   4073  f1d3				  -	      sta	port0control,x
   4074  f1d3				  -	      jsr	setportforinput
   4075  f1d3				  -	      jsr	setonebuttonmode
   4076  f1d3				  -	      jsr	SNES_READ
   4077  f1d3				  -	      lda	snesdetected0,x
   4078  f1d3				  -	      bne	SNES_AUTODETECT_FOUND
   4079  f1d3				  -			; detection failed
   4080  f1d3				  -	      jsr	setportforinput
   4081  f1d3				  -	      jsr	settwobuttonmode
   4082  f1d3				  -	      dex
   4083  f1d3				  -	      bpl	SNES_AUTODETECT_LOOP
   4084  f1d3				  -	      rts
   4085  f1d3				  -SNES_AUTODETECT_FOUND
   4086  f1d3				  -	      lda	#11	; formally set the snes controller
   4087  f1d3				  -	      sta	port0control,x
   4088  f1d3				  -	      stx	snesport
   4089  f1d3				  -	      rts
   4090  f1d3					      endif		; SNES2ATARISUPPORT
   4091  f1d3
   4092  f1d3				   snes2atarihandler
   4093  f1d3				  -	      ifconst	SNES2ATARISUPPORT
   4094  f1d3				  -SNES2ATARI
   4095  f1d3				  -	      jsr	SNES_READ
   4096  f1d3				  -	      jmp	buttonreadloopreturn
   4097  f1d3				  -
   4098  f1d3				  -SNES_READ
   4099  f1d3				  -			; x=0 for left port, x=1 for right
   4100  f1d3				  -
   4101  f1d3				  -			; Start by checking if any port directions are pressed. 
   4102  f1d3				  -			; Abort the autodetect for this port if so, as snes2atari doesn't ground any 
   4103  f1d3				  -			; direction pins. if directions are pressed and the port is changed to output,
   4104  f1d3				  -			; that means the output is direct-shorted, and nobody seems to know if riot's
   4105  f1d3				  -			; output mode has current protection.
   4106  f1d3				  -
   4107  f1d3				  -	      lda	SWCHA
   4108  f1d3				  -	      ora	SWCHA_INVDIRMASK,x
   4109  f1d3				  -	      eor	SWCHA_DIRMASK,x
   4110  f1d3				  -	      bne	SNES_READ_cont1
   4111  f1d3				  -	      jmp	SNES_ABORT
   4112  f1d3				  -SNES_READ_cont1
   4113  f1d3				  -
   4114  f1d3				  -	      lda	port0control,x
   4115  f1d3				  -	      cmp	#11	; snes
   4116  f1d3				  -	      bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
   4117  f1d3				  -	      lda	snesdetected0,x
   4118  f1d3				  -	      bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
   4119  f1d3				  -snes2atari_signal_go
   4120  f1d3				  -	      jsr	SNES2ATARI_SIGNAL
   4121  f1d3				  -snes2atari_signal_skip
   4122  f1d3				  -
   4123  f1d3				  -			;lda SNES_CTLSWA_MASK,x
   4124  f1d3				  -
   4125  f1d3				  -	      lda	CTLSWA
   4126  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4127  f1d3				  -	      ora	SNES_CTLSWA_MASK,x
   4128  f1d3				  -	      sta	CTLSWA	; enable pins UP/DOWN to work as outputs
   4129  f1d3				  -
   4130  f1d3				  -	      lda	SWCHA
   4131  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4132  f1d3				  -	      ora	SNES_CTLSWA_MASK,x
   4133  f1d3				  -
   4134  f1d3				  -	      sta	SWCHA	; latch+clock high
   4135  f1d3				  -	      nop
   4136  f1d3				  -	      nop
   4137  f1d3				  -	      nop
   4138  f1d3				  -	      nop
   4139  f1d3				  -	      nop
   4140  f1d3				  -	      nop
   4141  f1d3				  -	      nop
   4142  f1d3				  -	      lda	SWCHA
   4143  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4144  f1d3				  -	      sta	SWCHA	; latch and clock low
   4145  f1d3				  -	      ldy	#16	; 16 bits 
   4146  f1d3				  -SNES2ATARILOOP
   4147  f1d3				  -	      rol	INPT4,x	; sample data into carry
   4148  f1d3				  -	      lda	SWCHA
   4149  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4150  f1d3				  -	      ora	SNES_CLOCK_PORT_BIT,x
   4151  f1d3				  -	      sta	SWCHA	; clock low
   4152  f1d3				  -	      rol	snes2atari0lo,x
   4153  f1d3				  -	      rol	snes2atari0hi,x
   4154  f1d3				  -	      lda	SWCHA
   4155  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4156  f1d3				  -	      sta	SWCHA	; latch and clock low
   4157  f1d3				  -	      dey		; next bit
   4158  f1d3				  -	      bne	SNES2ATARILOOP
   4159  f1d3				  -	      rol	INPT4,x	; 17th bit should be lo if controller is there.
   4160  f1d3				  -	      rol		; 17th snes bit into A low bit
   4161  f1d3				  -	      eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
   4162  f1d3				  -	      and	#1
   4163  f1d3				  -	      sta	snesdetected0,x
   4164  f1d3				  -	      beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
   4165  f1d3				  -	      stx	snesport	; snesport keeps the index of the latest autodetected controller
   4166  f1d3				  -	      lda	SWCHA
   4167  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4168  f1d3				  -	      ora	SNES_CLOCK_PORT_BIT,x
   4169  f1d3				  -SNES_STOP_CLOCK
   4170  f1d3				  -	      sta	SWCHA	; clock low
   4171  f1d3				  -	      lda	CTLSWA
   4172  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4173  f1d3				  -	      ora	SNES_CLOCK_PORT_BIT,x
   4174  f1d3				  -	      sta	CTLSWA	; set port bits to input avoid conflict with other drivers
   4175  f1d3				  -	      rts
   4176  f1d3				  -SNES_ABORT
   4177  f1d3				  -	      sta	snesdetected0,x
   4178  f1d3				  -	      rts
   4179  f1d3				  -SNES2ATARI_SIGNAL
   4180  f1d3				  -			; signal to SNES2ATARI++ that we want SNES mode...
   4181  f1d3				  -	      lda	CTLSWA
   4182  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4183  f1d3				  -	      ora	SNES_CTLSWA_SIGNAL,x
   4184  f1d3				  -	      sta	CTLSWA
   4185  f1d3				  -	      lda	CTLSWA
   4186  f1d3				  -	      and	SWCHA_INVDIRMASK,x	; preserve othr nibble
   4187  f1d3				  -	      sta	SWCHA
   4188  f1d3				  -	      ldy	#0
   4189  f1d3				  -SNES_SIGNAL_LOOP
   4190  f1d3				  -	      dey
   4191  f1d3				  -	      bne	SNES_SIGNAL_LOOP
   4192  f1d3				  -	      lda	SWCHA
   4193  f1d3				  -	      ora	SWCHA_DIRMASK,x
   4194  f1d3				  -	      sta	SWCHA
   4195  f1d3				  -	      rts
   4196  f1d3					      endif
   4197  f1d3
   4198  f1d3				   gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   4199  f1d3				  -	      ifconst	LIGHTGUNSUPPORT
   4200  f1d3				  -	      cpx	#0
   4201  f1d3				  -	      bne	secondportgunhandler
   4202  f1d3				  -firstportgunhandler
   4203  f1d3				  -	      lda	SWCHA
   4204  f1d3				  -	      asl
   4205  f1d3				  -	      asl
   4206  f1d3				  -	      asl		; shift D4 to D7
   4207  f1d3				  -	      and	#%10000000
   4208  f1d3				  -	      eor	#%10000000
   4209  f1d3				  -	      sta	sINPT1
   4210  f1d3				  -	      jmp	buttonreadloopreturn
   4211  f1d3				  -secondportgunhandler
   4212  f1d3				  -	      lda	SWCHA
   4213  f1d3				  -	      lsr		; shift D0 into carry
   4214  f1d3				  -	      lsr		; shift carry into D7
   4215  f1d3				  -	      and	#%10000000
   4216  f1d3				  -	      eor	#%10000000
   4217  f1d3				  -	      sta	sINPT3
   4218  f1d3				  -	      jmp	buttonreadloopreturn
   4219  f1d3					      endif		; LIGHTGUNSUPPORT
   4220  f1d3
   4221  f1d3				   controlsusing2buttoncode
   4222  f1d3		       00		      .byte.b	0	; 00=no controller plugged in
   4223  f1d4		       01		      .byte.b	1	; 01=proline joystick
   4224  f1d5		       00		      .byte.b	0	; 02=lightgun
   4225  f1d6		       00		      .byte.b	0	; 03=paddle
   4226  f1d7		       01		      .byte.b	1	; 04=trakball
   4227  f1d8		       01		      .byte.b	1	; 05=vcs joystick
   4228  f1d9		       01		      .byte.b	1	; 06=driving control
   4229  f1da		       00		      .byte.b	0	; 07=keypad control
   4230  f1db		       00		      .byte.b	0	; 08=st mouse/cx80
   4231  f1dc		       00		      .byte.b	0	; 09=amiga mouse
   4232  f1dd		       01		      .byte.b	1	; 10=atarivox
   4233  f1de		       00		      .byte.b	0	; 11=snes2atari
   4234  f1df
   4235  f1df				   buttonhandlerhi
   4236  f1df		       00		      .byte.b	0	; 00=no controller plugged in
   4237  f1e0		       f1		      .byte.b	>joybuttonhandler	; 01=proline joystick
   4238  f1e1		       f1		      .byte.b	>gunbuttonhandler	; 02=lightgun
   4239  f1e2		       f6		      .byte.b	>paddlebuttonhandler	; 03=paddle
   4240  f1e3		       f1		      .byte.b	>joybuttonhandler	; 04=trakball
   4241  f1e4		       f1		      .byte.b	>joybuttonhandler	; 05=vcs joystick
   4242  f1e5		       f1		      .byte.b	>joybuttonhandler	; 06=driving control
   4243  f1e6		       00		      .byte.b	0	; 07=keypad
   4244  f1e7		       f6		      .byte.b	>mousebuttonhandler	; 08=st mouse
   4245  f1e8		       f6		      .byte.b	>mousebuttonhandler	; 09=amiga mouse
   4246  f1e9		       f1		      .byte.b	>joybuttonhandler	; 10=atarivox
   4247  f1ea		       f1		      .byte.b	>snes2atarihandler	; 11=snes
   4248  f1eb				   buttonhandlerlo
   4249  f1eb		       00		      .byte.b	0	; 00=no controller plugged in
   4250  f1ec		       9c		      .byte.b	<joybuttonhandler	; 01=proline joystick
   4251  f1ed		       d3		      .byte.b	<gunbuttonhandler	; 02=lightgun 
   4252  f1ee		       67		      .byte.b	<paddlebuttonhandler	; 03=paddle
   4253  f1ef		       9c		      .byte.b	<joybuttonhandler	; 04=trakball
   4254  f1f0		       9c		      .byte.b	<joybuttonhandler	; 05=vcs joystick
   4255  f1f1		       9c		      .byte.b	<joybuttonhandler	; 06=driving control
   4256  f1f2		       00		      .byte.b	0	; 07=keypad
   4257  f1f3		       67		      .byte.b	<mousebuttonhandler	; 08=st mouse
   4258  f1f4		       67		      .byte.b	<mousebuttonhandler	; 09=amiga mouse
   4259  f1f5		       9c		      .byte.b	<joybuttonhandler	; 10=atarivox
   4260  f1f6		       d3		      .byte.b	<snes2atarihandler	; 11=snes
   4261  f1f7
   4262  f1f7				   drawwait
   4263  f1f7		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4264  f1f9		       30 fc		      bmi	drawwait	; make sure the visible screen isn't being drawn
   4265  f1fb		       60		      rts
   4266  f1fc
   4267  f1fc				   drawoverwait
   4268  f1fc		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4269  f1fe		       10 fc		      bpl	drawoverwait	; make sure the visible screen is being drawn
   4270  f200		       60		      rts
   4271  f201
   4272  f201
   4273  f201				   mutetia
   4274  f201		       a9 00		      lda	#0
   4275  f203		       a2 03		      ldx	#3
   4276  f205				   mutetialoop
   4277  f205		       95 4e		      sta	sfx1pointlo,x
   4278  f207		       95 17		      sta	AUDF0,x
   4279  f209		       ca		      dex
   4280  f20a		       10 f9		      bpl	mutetialoop
   4281  f20c		       60		      rts
   4282  f20d
   4283  f20d				   servicesfxchannelsdone
   4284  f20d					      ifnconst	pokeysupport
   4285  f20d		       60		      rts
   4286  f20e				  -	      else
   4287  f20e				  -	      jmp	checkpokeyplaying
   4288  f20e					      endif
   4289  f20e				   servicesfxchannels
   4290  f20e		       a2 ff		      ldx	#255
   4291  f210				   servicesfxchannelsloop
   4292  f210		       e8		      inx
   4293  f211					      ifnconst	TIASFXMONO
   4294  f211		       e0 02		      cpx	#2
   4295  f213				  -	      else
   4296  f213				  -	      cpx	#1
   4297  f213					      endif
   4298  f213		       f0 f8		      beq	servicesfxchannelsdone
   4299  f215
   4300  f215		       a5 de		      lda	sfxschedulelock	; =1 if locked
   4301  f217		       d0 f4		      bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   4302  f219
   4303  f219		       b5 4e		      lda	sfx1pointlo,x
   4304  f21b		       85 dc		      sta	inttemp5
   4305  f21d		       15 50		      ora	sfx1pointhi,x
   4306  f21f		       f0 ef		      beq	servicesfxchannelsloop
   4307  f221		       b5 50		      lda	sfx1pointhi,x
   4308  f223		       85 dd		      sta	inttemp6
   4309  f225
   4310  f225		       b5 58		      lda	sfx1tick,x
   4311  f227		       f0 05		      beq	servicesfx_cont1	; this chunk is over, load the next!
   4312  f229		       d6 58		      dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   4313  f22b		       4c 10 f2 	      jmp	servicesfxchannelsloop
   4314  f22e				   servicesfx_cont1
   4315  f22e
   4316  f22e		       a0 01		      ldy	#1	; check to see if they're changing the frame countdown
   4317  f230		       b1 dc		      lda	(inttemp5),y
   4318  f232		       c9 10		      cmp	#$10
   4319  f234		       d0 1b		      bne	servicesfx_cont1a
   4320  f236		       a0 02		      ldy	#2
   4321  f238		       b1 dc		      lda	(inttemp5),y
   4322  f23a		       95 56		      sta	sfx1frames,x	; change the frame countdown
   4323  f23c		       a9 00		      lda	#0
   4324  f23e		       95 58		      sta	sfx1tick,x
   4325  f240							; advance the sound pointer by 3...
   4326  f240		       b5 4e		      lda	sfx1pointlo,x
   4327  f242		       18		      clc
   4328  f243		       69 03		      adc	#3
   4329  f245		       95 4e		      sta	sfx1pointlo,x
   4330  f247		       b5 50		      lda	sfx1pointhi,x
   4331  f249		       69 00		      adc	#0
   4332  f24b		       95 50		      sta	sfx1pointhi,x
   4333  f24d							; and then fetch another sample for this channel...
   4334  f24d		       ca		      dex
   4335  f24e		       4c 10 f2 	      jmp	servicesfxchannelsloop
   4336  f251				   servicesfx_cont1a
   4337  f251
   4338  f251		       b5 56		      lda	sfx1frames,x	; set the frame countdown for this sound chunk
   4339  f253		       95 58		      sta	sfx1tick,x
   4340  f255
   4341  f255		       b5 52		      lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   4342  f257		       f0 02		      beq	servicesfx_cont2
   4343  f259		       d6 52		      dec	sfx1priority,x
   4344  f25b				   servicesfx_cont2
   4345  f25b
   4346  f25b		       a0 00		      ldy	#0	; play the sound
   4347  f25d		       b1 dc		      lda	(inttemp5),y
   4348  f25f		       85 d8		      sta	inttemp1
   4349  f261
   4350  f261				  -	      ifconst	MUSICTRACKER
   4351  f261				  -	      lda	sfx1notedata,x
   4352  f261				  -	      beq	exitmusictracker	; exit if this isn't a pitched instrument
   4353  f261				  -	      ldy	#0
   4354  f261				  -	      sty	inttemp2
   4355  f261				  -	      clc
   4356  f261				  -	      adc	(inttemp5),y
   4357  f261				  -	      asl		; x2
   4358  f261				  -	      tay
   4359  f261				  -	      lda	tiatrackeroctavenotes,y
   4360  f261				  -	      sta	AUDC0,x
   4361  f261				  -	      iny
   4362  f261				  -	      lda	tiatrackeroctavenotes,y
   4363  f261				  -	      sta	AUDF0,x
   4364  f261				  -	      ldy	#1
   4365  f261				  -	      jmp	sfxvolumeentrypt
   4366  f261				  -exitmusictracker
   4367  f261				  -	      lda	inttemp1
   4368  f261					      endif		; MUSICTRACKER
   4369  f261
   4370  f261		       18		      clc
   4371  f262		       75 54		      adc	sfx1poffset,x	; take into account any pitch modification
   4372  f264		       95 17		      sta	AUDF0,x
   4373  f266		       c8		      iny
   4374  f267		       b1 dc		      lda	(inttemp5),y
   4375  f269		       95 15		      sta	AUDC0,x
   4376  f26b		       85 d9		      sta	inttemp2
   4377  f26d		       c8		      iny
   4378  f26e				   sfxvolumeentrypt
   4379  f26e				  -	      ifconst	TIAVOLUME
   4380  f26e				  -	      lda	tiavolume
   4381  f26e				  -	      asl
   4382  f26e				  -	      asl
   4383  f26e				  -	      asl
   4384  f26e				  -	      asl
   4385  f26e				  -	      sta	fourbitfadevalueint
   4386  f26e					      endif		; TIAVOLUME
   4387  f26e		       b1 dc		      lda	(inttemp5),y
   4388  f270				  -	      ifconst	TIAVOLUME
   4389  f270				  -	      jsr	fourbitfadeint
   4390  f270					      endif		; TIAVOLUME
   4391  f270		       95 19		      sta	AUDV0,x
   4392  f272		       c9 10		      cmp	#$10
   4393  f274		       b0 19		      bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   4394  f276
   4395  f276		       05 d9		      ora	inttemp2
   4396  f278		       05 d8		      ora	inttemp1	; check if F|C|V=0
   4397  f27a		       f0 23		      beq	zerosfx	; if so, we're at the end of the sound.
   4398  f27c
   4399  f27c				   advancesfxpointer
   4400  f27c							; advance the pointer to the next sound chunk
   4401  f27c		       c8		      iny
   4402  f27d		       84 da		      sty	inttemp3
   4403  f27f		       18		      clc
   4404  f280		       b5 4e		      lda	sfx1pointlo,x
   4405  f282		       65 da		      adc	inttemp3
   4406  f284		       95 4e		      sta	sfx1pointlo,x
   4407  f286		       b5 50		      lda	sfx1pointhi,x
   4408  f288		       69 00		      adc	#0
   4409  f28a		       95 50		      sta	sfx1pointhi,x
   4410  f28c		       4c 10 f2 	      jmp	servicesfxchannelsloop
   4411  f28f
   4412  f28f				   sfxsoundloop
   4413  f28f		       48		      pha
   4414  f290		       b5 52		      lda	sfx1priority,x
   4415  f292		       d0 04		      bne	sfxsoundloop_carryon
   4416  f294		       68		      pla		; fix the stack before we go
   4417  f295		       4c 7c f2 	      jmp	advancesfxpointer
   4418  f298				   sfxsoundloop_carryon
   4419  f298		       68		      pla
   4420  f299		       29 f0		      and	#$F0
   4421  f29b		       4a		      lsr
   4422  f29c		       4a		      lsr
   4423  f29d		       4a		      lsr
   4424  f29e		       4a		      lsr
   4425  f29f
   4426  f29f				   zerosfx
   4427  f29f		       95 4e		      sta	sfx1pointlo,x
   4428  f2a1		       95 50		      sta	sfx1pointhi,x
   4429  f2a3		       95 52		      sta	sfx1priority,x
   4430  f2a5		       4c 10 f2 	      jmp	servicesfxchannelsloop
   4431  f2a8
   4432  f2a8
   4433  f2a8				   schedulesfx
   4434  f2a8							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   4435  f2a8		       a0 00		      ldy	#0
   4436  f2aa		       b1 e0		      lda	(sfxinstrumentlo),y
   4437  f2ac				  -	      ifconst	pokeysupport
   4438  f2ac				  -	      cmp	#$20	; POKEY?
   4439  f2ac				  -	      bne	scheduletiasfx
   4440  f2ac				  -	      jmp	schedulepokeysfx
   4441  f2ac					      endif
   4442  f2ac				   scheduletiasfx
   4443  f2ac							;cmp #$10 ; TIA?
   4444  f2ac							;beq continuescheduletiasfx
   4445  f2ac							; rts ; unhandled!!! 
   4446  f2ac				   continuescheduletiasfx
   4447  f2ac					      ifnconst	TIASFXMONO
   4448  f2ac		       a5 4e		      lda	sfx1pointlo
   4449  f2ae		       05 50		      ora	sfx1pointhi
   4450  f2b0		       f0 13		      beq	schedulesfx1	;if channel 1 is idle, use it
   4451  f2b2		       a5 4f		      lda	sfx2pointlo
   4452  f2b4		       05 51		      ora	sfx2pointhi
   4453  f2b6		       f0 11		      beq	schedulesfx2	;if channel 2 is idle, use it
   4454  f2b8							; Both channels are scheduled. 
   4455  f2b8		       a0 01		      ldy	#1
   4456  f2ba		       b1 e0		      lda	(sfxinstrumentlo),y
   4457  f2bc		       d0 01		      bne	interruptsfx
   4458  f2be		       60		      rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   4459  f2bf				   interruptsfx
   4460  f2bf							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   4461  f2bf		       a5 52		      lda	sfx1priority
   4462  f2c1		       c5 53		      cmp	sfx2priority
   4463  f2c3		       b0 04		      bcs	schedulesfx2
   4464  f2c5					      endif		; !TIASFXMONO
   4465  f2c5
   4466  f2c5				   schedulesfx1
   4467  f2c5		       a2 00		      ldx	#0	; channel 1
   4468  f2c7					      ifnconst	TIASFXMONO
   4469  f2c7		       f0 02		      beq	skipschedulesfx2
   4470  f2c9				   schedulesfx2
   4471  f2c9		       a2 01		      ldx	#1	; channel 2
   4472  f2cb				   skipschedulesfx2
   4473  f2cb					      endif		; !TIASFXMONO
   4474  f2cb
   4475  f2cb				  -	      ifconst	MUSICTRACKER
   4476  f2cb				  -	      lda	sfxnoteindex
   4477  f2cb				  -	      bpl	skipdrumkitoverride
   4478  f2cb				  -	      and	#$7F	; subtract 128
   4479  f2cb				  -	      sec
   4480  f2cb				  -	      sbc	#4	; drums start at 132, i.e. octave 10
   4481  f2cb				  -	      asl
   4482  f2cb				  -	      tay
   4483  f2cb				  -	      lda	tiadrumkitdefinition,y
   4484  f2cb				  -	      sta	sfxinstrumentlo
   4485  f2cb				  -	      iny
   4486  f2cb				  -	      lda	tiadrumkitdefinition,y
   4487  f2cb				  -	      sta	sfxinstrumenthi
   4488  f2cb				  -	      lda	#0
   4489  f2cb				  -	      sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   4490  f2cb				  -skipdrumkitoverride
   4491  f2cb					      endif		; MUSICTRACKER
   4492  f2cb		       a0 01		      ldy	#1	; get priority and sound-resolution (in frames)
   4493  f2cd		       b1 e0		      lda	(sfxinstrumentlo),y
   4494  f2cf		       95 52		      sta	sfx1priority,x
   4495  f2d1		       c8		      iny
   4496  f2d2		       b1 e0		      lda	(sfxinstrumentlo),y
   4497  f2d4		       95 56		      sta	sfx1frames,x
   4498  f2d6		       a5 e0		      lda	sfxinstrumentlo
   4499  f2d8		       18		      clc
   4500  f2d9		       69 03		      adc	#3
   4501  f2db		       95 4e		      sta	sfx1pointlo,x
   4502  f2dd		       a5 e1		      lda	sfxinstrumenthi
   4503  f2df		       69 00		      adc	#0
   4504  f2e1		       95 50		      sta	sfx1pointhi,x
   4505  f2e3		       a5 e2		      lda	sfxpitchoffset
   4506  f2e5		       95 54		      sta	sfx1poffset,x
   4507  f2e7		       a9 00		      lda	#0
   4508  f2e9		       95 58		      sta	sfx1tick,x
   4509  f2eb		       a5 e3		      lda	sfxnoteindex
   4510  f2ed		       95 cd		      sta	sfx1notedata,x
   4511  f2ef		       60		      rts
   4512  f2f0
   4513  f2f0				   plotsprite
   4514  f2f0					      ifnconst	NODRAWWAIT
   4515  f2f0					      ifconst	DOUBLEBUFFER
   4516  f2f0		       a5 d5		      lda	doublebufferstate
   4517  f2f2		       d0 04		      bne	skipplotspritewait
   4518  f2f4					      endif		; DOUBLEBUFFER
   4519  f2f4				  -	      ifconst	DEBUGWAITCOLOR
   4520  f2f4				  -	      lda	#$41
   4521  f2f4				  -	      sta	BACKGRND
   4522  f2f4					      endif
   4523  f2f4				   plotspritewait
   4524  f2f4		       a5 4d		      lda	visibleover
   4525  f2f6		       d0 fc		      bne	plotspritewait
   4526  f2f8				   skipplotspritewait
   4527  f2f8				  -	      ifconst	DEBUGWAITCOLOR
   4528  f2f8				  -	      lda	#$0
   4529  f2f8				  -	      sta	BACKGRND
   4530  f2f8					      endif
   4531  f2f8					      endif
   4532  f2f8
   4533  f2f8							;arguments: 
   4534  f2f8							; temp1=lo graphicdata 
   4535  f2f8							; temp2=hi graphicdata 
   4536  f2f8							; temp3=palette | width byte
   4537  f2f8							; temp4=x
   4538  f2f8							; temp5=y
   4539  f2f8							; temp6=mode
   4540  f2f8		       a5 46		      lda	temp5	;Y position
   4541  f2fa		       4a		      lsr		; 2 - Divide by 8 or 16
   4542  f2fb		       4a		      lsr		; 2
   4543  f2fc		       4a		      lsr		; 2
   4544  f2fd					      if	WZONEHEIGHT = 16
   4545  f2fd		       4a		      lsr		; 2
   4546  f2fe					      endif
   4547  f2fe
   4548  f2fe		       aa		      tax
   4549  f2ff
   4550  f2ff					      ifnconst	NOLIMITCHECKING
   4551  f2ff
   4552  f2ff							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   4553  f2ff
   4554  f2ff		       c9 0c		      cmp	#WZONECOUNT
   4555  f301
   4556  f301		       90 0a		      bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   4557  f303							; otherwise, check to see if the bottom half is in zone 0...
   4558  f303
   4559  f303					      if	WZONEHEIGHT = 16
   4560  f303		       c9 0f		      cmp	#15
   4561  f305				  -	      else
   4562  f305				  -	      cmp	#31
   4563  f305					      endif
   4564  f305
   4565  f305		       d0 05		      bne	exitplotsprite1
   4566  f307		       a2 00		      ldx	#0
   4567  f309		       4c 47 f3 	      jmp	continueplotsprite2
   4568  f30c				   exitplotsprite1
   4569  f30c		       60		      rts
   4570  f30d
   4571  f30d				   continueplotsprite1
   4572  f30d					      endif
   4573  f30d
   4574  f30d		       bd 2a f7 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   4575  f310					      ifconst	DOUBLEBUFFER
   4576  f310		       18		      clc
   4577  f311		       65 d6		      adc	doublebufferdloffset
   4578  f313					      endif		; DOUBLEBUFFER
   4579  f313		       85 63		      sta	dlpnt
   4580  f315		       bd 1e f7 	      lda	DLPOINTH,x
   4581  f318					      ifconst	DOUBLEBUFFER
   4582  f318		       69 00		      adc	#0
   4583  f31a					      endif		; DOUBLEBUFFER
   4584  f31a		       85 64		      sta	dlpnt+1
   4585  f31c
   4586  f31c							;Create DL entry for upper part of sprite
   4587  f31c
   4588  f31c		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4589  f31e
   4590  f31e				  -	      ifconst	CHECKOVERWRITE
   4591  f31e				  -	      cpy	#DLLASTOBJ
   4592  f31e				  -	      beq	checkcontinueplotsprite2
   4593  f31e				  -continueplotsprite1a
   4594  f31e					      endif
   4595  f31e
   4596  f31e		       a5 42		      lda	temp1	; graphic data, lo byte
   4597  f320		       91 63		      sta	(dlpnt),y	;Low byte of data address
   4598  f322
   4599  f322					      ifnconst	ATOMICSPRITEUPDATE
   4600  f322		       c8		      iny
   4601  f323		       a5 47		      lda	temp6
   4602  f325		       91 63		      sta	(dlpnt),y
   4603  f327				  -	      else
   4604  f327				  -	      iny
   4605  f327				  -	      sty	temp8
   4606  f327					      endif
   4607  f327
   4608  f327		       c8		      iny
   4609  f328
   4610  f328		       a5 46		      lda	temp5	;Y position
   4611  f32a		       29 0f		      and	#(WZONEHEIGHT - 1)
   4612  f32c		       c9 01		      cmp	#1	; clear carry if our sprite is just in this zone
   4613  f32e		       05 43		      ora	temp2	; graphic data, hi byte
   4614  f330		       91 63		      sta	(dlpnt),y
   4615  f332
   4616  f332
   4617  f332		       c8		      iny
   4618  f333		       a5 44		      lda	temp3	;palette|width
   4619  f335		       91 63		      sta	(dlpnt),y
   4620  f337
   4621  f337		       c8		      iny
   4622  f338		       a5 45		      lda	temp4	;Horizontal position
   4623  f33a		       91 63		      sta	(dlpnt),y
   4624  f33c
   4625  f33c		       c8		      iny
   4626  f33d		       94 65		      sty	dlend,x
   4627  f33f
   4628  f33f				  -	      ifconst	ALWAYSTERMINATE
   4629  f33f				  -	      iny
   4630  f33f				  -	      lda	#0
   4631  f33f				  -	      sta	(dlpnt),y
   4632  f33f					      endif
   4633  f33f
   4634  f33f				  -	      ifconst	ATOMICSPRITEUPDATE
   4635  f33f				  -	      ldy	temp8
   4636  f33f				  -	      lda	temp6
   4637  f33f				  -	      sta	(dlpnt),y
   4638  f33f					      endif
   4639  f33f
   4640  f33f				   checkcontinueplotsprite2
   4641  f33f
   4642  f33f		       90 38		      bcc	doneSPDL	;branch if the sprite was fully in the last zone
   4643  f341
   4644  f341							;Create DL entry for lower part of sprite
   4645  f341
   4646  f341		       e8		      inx		;Next region
   4647  f342
   4648  f342					      ifnconst	NOLIMITCHECKING
   4649  f342		       e0 0c		      cpx	#WZONECOUNT
   4650  f344
   4651  f344		       90 01		      bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   4652  f346		       60		      rts
   4653  f347				   continueplotsprite2
   4654  f347					      endif
   4655  f347
   4656  f347		       bd 2a f7 	      lda	DLPOINTL,x	;Get pointer to next DL
   4657  f34a					      ifconst	DOUBLEBUFFER
   4658  f34a		       18		      clc
   4659  f34b		       65 d6		      adc	doublebufferdloffset
   4660  f34d					      endif		; DOUBLEBUFFER
   4661  f34d		       85 63		      sta	dlpnt
   4662  f34f		       bd 1e f7 	      lda	DLPOINTH,x
   4663  f352					      ifconst	DOUBLEBUFFER
   4664  f352		       69 00		      adc	#0
   4665  f354					      endif		; DOUBLEBUFFER
   4666  f354		       85 64		      sta	dlpnt+1
   4667  f356		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4668  f358
   4669  f358				  -	      ifconst	CHECKOVERWRITE
   4670  f358				  -	      cpy	#DLLASTOBJ
   4671  f358				  -	      bne	continueplotsprite2a
   4672  f358				  -	      rts
   4673  f358				  -continueplotsprite2a
   4674  f358					      endif
   4675  f358
   4676  f358		       a5 42		      lda	temp1	; graphic data, lo byte
   4677  f35a		       91 63		      sta	(dlpnt),y
   4678  f35c
   4679  f35c					      ifnconst	ATOMICSPRITEUPDATE
   4680  f35c		       c8		      iny
   4681  f35d		       a5 47		      lda	temp6
   4682  f35f		       91 63		      sta	(dlpnt),y
   4683  f361				  -	      else
   4684  f361				  -	      iny
   4685  f361				  -	      sty	temp8
   4686  f361					      endif
   4687  f361
   4688  f361		       c8		      iny
   4689  f362
   4690  f362		       a5 46		      lda	temp5	;Y position
   4691  f364		       0b 0f		      anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   4692  f366		       05 43		      ora	temp2	; graphic data, hi byte
   4693  f368		       e9 0f		      sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   4694  f36a		       91 63		      sta	(dlpnt),y
   4695  f36c
   4696  f36c		       c8		      iny
   4697  f36d
   4698  f36d		       a5 44		      lda	temp3	;palette|width
   4699  f36f		       91 63		      sta	(dlpnt),y
   4700  f371
   4701  f371		       c8		      iny
   4702  f372
   4703  f372		       a5 45		      lda	temp4	;Horizontal position
   4704  f374		       91 63		      sta	(dlpnt),y
   4705  f376
   4706  f376		       c8		      iny
   4707  f377		       94 65		      sty	dlend,x
   4708  f379
   4709  f379				  -	      ifconst	ALWAYSTERMINATE
   4710  f379				  -	      iny
   4711  f379				  -	      lda	#0
   4712  f379				  -	      sta	(dlpnt),y
   4713  f379					      endif
   4714  f379
   4715  f379				  -	      ifconst	ATOMICSPRITEUPDATE
   4716  f379				  -	      ldy	temp8
   4717  f379				  -	      lda	temp6
   4718  f379				  -	      sta	(dlpnt),y
   4719  f379					      endif
   4720  f379
   4721  f379				   doneSPDL
   4722  f379		       60		      rts
   4723  f37a
   4724  f37a
   4725  f37a				   lockzonex
   4726  f37a				  -	      ifconst	ZONELOCKS
   4727  f37a				  -	      ldy	dlend,x
   4728  f37a				  -	      cpy	#DLLASTOBJ
   4729  f37a				  -	      beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   4730  f37a				  -	      lda	DLPOINTL,x
   4731  f37a				  -	      ifconst	DOUBLEBUFFER
   4732  f37a				  -	      clc
   4733  f37a				  -	      adc	doublebufferdloffset
   4734  f37a				  -	      endif		; DOUBLEBUFFER
   4735  f37a				  -	      sta	dlpnt
   4736  f37a				  -	      lda	DLPOINTH,x
   4737  f37a				  -	      ifconst	DOUBLEBUFFER
   4738  f37a				  -	      adc	#0
   4739  f37a				  -	      endif		; DOUBLEBUFFER
   4740  f37a				  -	      sta	dlpnt+1
   4741  f37a				  -	      iny
   4742  f37a				  -	      lda	#0
   4743  f37a				  -	      sta	(dlpnt),y
   4744  f37a				  -	      dey
   4745  f37a				  -	      tya
   4746  f37a				  -	      ldy	#(DLLASTOBJ-1)
   4747  f37a				  -	      sta	(dlpnt),y
   4748  f37a				  -	      iny
   4749  f37a				  -	      sty	dlend,x
   4750  f37a				  -lockzonexreturn
   4751  f37a				  -	      rts
   4752  f37a					      endif		; ZONELOCKS
   4753  f37a				   unlockzonex
   4754  f37a				  -	      ifconst	ZONELOCKS
   4755  f37a				  -	      ldy	dlend,x
   4756  f37a				  -	      cpy	#DLLASTOBJ
   4757  f37a				  -	      bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   4758  f37a				  -	      lda	DLPOINTL,x
   4759  f37a				  -	      ifconst	DOUBLEBUFFER
   4760  f37a				  -	      clc
   4761  f37a				  -	      adc	doublebufferdloffset
   4762  f37a				  -	      endif		; DOUBLEBUFFER
   4763  f37a				  -	      sta	dlpnt
   4764  f37a				  -	      lda	DLPOINTH,x
   4765  f37a				  -	      ifconst	DOUBLEBUFFER
   4766  f37a				  -	      adc	#0
   4767  f37a				  -	      endif		; DOUBLEBUFFER
   4768  f37a				  -	      sta	dlpnt+1
   4769  f37a				  -	      dey
   4770  f37a				  -			;ldy #(DLLASTOBJ-1)
   4771  f37a				  -	      lda	(dlpnt),y
   4772  f37a				  -	      tay
   4773  f37a				  -	      sty	dlend,x
   4774  f37a				  -unlockzonexreturn
   4775  f37a					      endif		; ZONELOCKS
   4776  f37a		       60		      rts
   4777  f37b
   4778  f37b				   plotcharloop
   4779  f37b							; ** read from a data indirectly pointed to from temp8,temp9
   4780  f37b							; ** format is: lo_data, hi_data, palette|width, x, y
   4781  f37b							; ** format ends with lo_data | hi_data = 0
   4782  f37b
   4783  f37b					      ifconst	DOUBLEBUFFER
   4784  f37b		       a5 d5		      lda	doublebufferstate
   4785  f37d		       d0 04		      bne	skipplotcharloopwait
   4786  f37f					      endif		; DOUBLEBUFFER
   4787  f37f				  -	      ifconst	DEBUGWAITCOLOR
   4788  f37f				  -	      lda	#$61
   4789  f37f				  -	      sta	BACKGRND
   4790  f37f					      endif
   4791  f37f				   plotcharloopwait
   4792  f37f		       a5 4d		      lda	visibleover
   4793  f381		       d0 fc		      bne	plotcharloopwait
   4794  f383				  -	      ifconst	DEBUGWAITCOLOR
   4795  f383				  -	      lda	#0
   4796  f383				  -	      sta	BACKGRND
   4797  f383					      endif
   4798  f383				   skipplotcharloopwait
   4799  f383				   plotcharlooploop
   4800  f383		       a0 00		      ldy	#0
   4801  f385		       b1 49		      lda	(temp8),y
   4802  f387		       85 42		      sta	temp1
   4803  f389		       c8		      iny
   4804  f38a		       b1 49		      lda	(temp8),y
   4805  f38c		       85 43		      sta	temp2
   4806  f38e		       05 42		      ora	temp1
   4807  f390		       d0 01		      bne	plotcharloopcontinue
   4808  f392							;the pointer=0, so return
   4809  f392		       60		      rts
   4810  f393				   plotcharloopcontinue
   4811  f393		       c8		      iny
   4812  f394		       b1 49		      lda	(temp8),y
   4813  f396		       85 44		      sta	temp3
   4814  f398		       c8		      iny
   4815  f399		       b1 49		      lda	(temp8),y
   4816  f39b		       85 45		      sta	temp4
   4817  f39d		       c8		      iny
   4818  f39e		       b1 49		      lda	(temp8),y
   4819  f3a0							;sta temp5 ; not needed with our late entry.
   4820  f3a0		       20 bd f3 	      jsr	plotcharactersskipentry
   4821  f3a3		       a5 49		      lda	temp8
   4822  f3a5		       18		      clc
   4823  f3a6		       69 05		      adc	#5
   4824  f3a8		       85 49		      sta	temp8
   4825  f3aa		       a5 4a		      lda	temp9
   4826  f3ac		       69 00		      adc	#0
   4827  f3ae		       85 4a		      sta	temp9
   4828  f3b0		       4c 83 f3 	      jmp	plotcharlooploop
   4829  f3b3
   4830  f3b3				   plotcharacters
   4831  f3b3					      ifconst	DOUBLEBUFFER
   4832  f3b3		       a5 d5		      lda	doublebufferstate
   4833  f3b5		       d0 04		      bne	skipplotcharacterswait
   4834  f3b7					      endif		; DOUBLEBUFFER
   4835  f3b7				  -	      ifconst	DEBUGWAITCOLOR
   4836  f3b7				  -	      lda	#$41
   4837  f3b7				  -	      sta	BACKGRND
   4838  f3b7					      endif
   4839  f3b7				   plotcharacterswait
   4840  f3b7		       a5 4d		      lda	visibleover
   4841  f3b9		       d0 fc		      bne	plotcharacterswait
   4842  f3bb				  -	      ifconst	DEBUGWAITCOLOR
   4843  f3bb				  -	      sta	BACKGRND
   4844  f3bb					      endif
   4845  f3bb				   skipplotcharacterswait
   4846  f3bb							;arguments: 
   4847  f3bb							; temp1=lo charactermap
   4848  f3bb							; temp2=hi charactermap
   4849  f3bb							; temp3=palette | width byte
   4850  f3bb							; temp4=x
   4851  f3bb							; temp5=y
   4852  f3bb
   4853  f3bb		       a5 46		      lda	temp5	;Y position
   4854  f3bd
   4855  f3bd				   plotcharactersskipentry
   4856  f3bd
   4857  f3bd							;ifconst ZONEHEIGHT
   4858  f3bd							; if ZONEHEIGHT = 16
   4859  f3bd							; and #$0F
   4860  f3bd							; endif
   4861  f3bd							; if ZONEHEIGHT = 8
   4862  f3bd							; and #$1F
   4863  f3bd							; endif
   4864  f3bd							;else
   4865  f3bd							; and #$0F
   4866  f3bd							;endif
   4867  f3bd
   4868  f3bd		       aa		      tax
   4869  f3be		       bd 2a f7 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4870  f3c1					      ifconst	DOUBLEBUFFER
   4871  f3c1		       18		      clc
   4872  f3c2		       65 d6		      adc	doublebufferdloffset
   4873  f3c4					      endif		; DOUBLEBUFFER
   4874  f3c4		       85 63		      sta	dlpnt
   4875  f3c6		       bd 1e f7 	      lda	DLPOINTH,x
   4876  f3c9					      ifconst	DOUBLEBUFFER
   4877  f3c9		       69 00		      adc	#0
   4878  f3cb					      endif		; DOUBLEBUFFER
   4879  f3cb		       85 64		      sta	dlpnt+1
   4880  f3cd
   4881  f3cd							;Create DL entry for the characters
   4882  f3cd
   4883  f3cd		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4884  f3cf
   4885  f3cf				  -	      ifconst	CHECKOVERWRITE
   4886  f3cf				  -	      cpy	#DLLASTOBJ
   4887  f3cf				  -	      bne	continueplotcharacters
   4888  f3cf				  -	      rts
   4889  f3cf				  -continueplotcharacters
   4890  f3cf					      endif
   4891  f3cf
   4892  f3cf		       a5 42		      lda	temp1	; character map data, lo byte
   4893  f3d1		       91 63		      sta	(dlpnt),y	;(1) store low address
   4894  f3d3
   4895  f3d3		       c8		      iny
   4896  f3d4		       ad 06 21 	      lda	charactermode
   4897  f3d7		       91 63		      sta	(dlpnt),y	;(2) store mode
   4898  f3d9
   4899  f3d9		       c8		      iny
   4900  f3da		       a5 43		      lda	temp2	; character map, hi byte
   4901  f3dc		       91 63		      sta	(dlpnt),y	;(3) store high address
   4902  f3de
   4903  f3de		       c8		      iny
   4904  f3df		       a5 44		      lda	temp3	;palette|width
   4905  f3e1		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   4906  f3e3
   4907  f3e3		       c8		      iny
   4908  f3e4		       a5 45		      lda	temp4	;Horizontal position
   4909  f3e6		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   4910  f3e8
   4911  f3e8		       c8		      iny
   4912  f3e9		       94 65		      sty	dlend,x	; save display list end byte
   4913  f3eb		       60		      rts
   4914  f3ec
   4915  f3ec
   4916  f3ec					      ifconst	plotvalueonscreen
   4917  f3ec				   plotcharacterslive
   4918  f3ec							; a version of plotcharacters that draws live and minimally disrupts the screen...
   4919  f3ec
   4920  f3ec							;arguments: 
   4921  f3ec							; temp1=lo charactermap
   4922  f3ec							; temp2=hi charactermap
   4923  f3ec							; temp3=palette | width byte
   4924  f3ec							; temp4=x
   4925  f3ec							; temp5=y
   4926  f3ec
   4927  f3ec		       a5 46		      lda	temp5	;Y position
   4928  f3ee
   4929  f3ee		       aa		      tax
   4930  f3ef		       bd 2a f7 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4931  f3f2					      ifconst	DOUBLEBUFFER
   4932  f3f2		       18		      clc
   4933  f3f3		       65 d6		      adc	doublebufferdloffset
   4934  f3f5					      endif		; DOUBLEBUFFER
   4935  f3f5		       85 63		      sta	dlpnt
   4936  f3f7		       bd 1e f7 	      lda	DLPOINTH,x
   4937  f3fa					      ifconst	DOUBLEBUFFER
   4938  f3fa		       69 00		      adc	#0
   4939  f3fc					      endif		; DOUBLEBUFFER
   4940  f3fc		       85 64		      sta	dlpnt+1
   4941  f3fe
   4942  f3fe							;Create DL entry for the characters
   4943  f3fe
   4944  f3fe		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4945  f400
   4946  f400				  -	      ifconst	CHECKOVERWRITE
   4947  f400				  -	      cpy	#DLLASTOBJ
   4948  f400				  -	      bne	continueplotcharacterslive
   4949  f400				  -	      rts
   4950  f400				  -continueplotcharacterslive
   4951  f400					      endif
   4952  f400
   4953  f400		       a5 42		      lda	temp1	; character map data, lo byte
   4954  f402		       91 63		      sta	(dlpnt),y	;(1) store low address
   4955  f404
   4956  f404		       c8		      iny
   4957  f405							; we don't add the second byte yet, since the charmap could briefly
   4958  f405							; render without a proper character map address, width, or position.
   4959  f405		       ad 06 21 	      lda	charactermode
   4960  f408		       91 63		      sta	(dlpnt),y	;(2) store mode
   4961  f40a
   4962  f40a		       c8		      iny
   4963  f40b		       a5 43		      lda	temp2	; character map, hi byte
   4964  f40d		       91 63		      sta	(dlpnt),y	;(3) store high address
   4965  f40f
   4966  f40f		       c8		      iny
   4967  f410		       a5 44		      lda	temp3	;palette|width
   4968  f412		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   4969  f414
   4970  f414		       c8		      iny
   4971  f415		       a5 45		      lda	temp4	;Horizontal position
   4972  f417		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   4973  f419
   4974  f419		       c8		      iny
   4975  f41a		       94 65		      sty	dlend,x	; save display list end byte
   4976  f41c
   4977  f41c		       60		      rts
   4978  f41d					      endif		;plotcharacterslive
   4979  f41d
   4980  f41d					      ifconst	USED_PLOTVALUE
   4981  f41d				   plotvalue
   4982  f41d							; calling 7800basic command:
   4983  f41d							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4984  f41d							; ...displays the variable as BCD digits
   4985  f41d							;
   4986  f41d							; asm sub arguments: 
   4987  f41d							; temp1=lo charactermap
   4988  f41d							; temp2=hi charactermap
   4989  f41d							; temp3=palette | width byte
   4990  f41d							; temp4=x
   4991  f41d							; temp5=y
   4992  f41d							; temp6=number of digits
   4993  f41d							; temp7=lo variable
   4994  f41d							; temp8=hi variable
   4995  f41d							; temp9=character mode
   4996  f41d
   4997  f41d		       00 47	   plotdigitcount =	temp6
   4998  f41d
   4999  f41d				  -	      ifconst	ZONELOCKS
   5000  f41d				  -	      ldx	temp5
   5001  f41d				  -	      ldy	dlend,x
   5002  f41d				  -	      cpy	#DLLASTOBJ
   5003  f41d				  -	      bne	carryonplotvalue
   5004  f41d				  -	      rts
   5005  f41d				  -carryonplotvalue
   5006  f41d					      endif
   5007  f41d
   5008  f41d		       a9 00		      lda	#0
   5009  f41f		       a8		      tay
   5010  f420		       ae ad 01 	      ldx	valbufend
   5011  f423
   5012  f423		       a5 47		      lda	plotdigitcount
   5013  f425		       29 01		      and	#1
   5014  f427		       f0 07		      beq	pvnibble2char
   5015  f429		       a9 00		      lda	#0
   5016  f42b		       9d 00 20 	      sta	VALBUFFER,x	; just in case we skip this digit
   5017  f42e		       f0 11		      beq	pvnibble2char_skipnibble
   5018  f430
   5019  f430				   pvnibble2char
   5020  f430							; high nibble...
   5021  f430		       b1 48		      lda	(temp7),y
   5022  f432		       29 f0		      and	#$f0
   5023  f434		       4a		      lsr
   5024  f435		       4a		      lsr
   5025  f436		       4a		      lsr
   5026  f437					      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5027  f437		       4a		      lsr
   5028  f438					      endif
   5029  f438
   5030  f438		       18		      clc
   5031  f439		       65 42		      adc	temp1	; add the offset to character graphics to our value
   5032  f43b		       9d 00 20 	      sta	VALBUFFER,x
   5033  f43e		       e8		      inx
   5034  f43f		       c6 47		      dec	plotdigitcount
   5035  f441
   5036  f441				   pvnibble2char_skipnibble
   5037  f441							; low nibble...
   5038  f441		       b1 48		      lda	(temp7),y
   5039  f443		       29 0f		      and	#$0f
   5040  f445				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5041  f445				  -	      asl
   5042  f445					      endif
   5043  f445		       18		      clc
   5044  f446		       65 42		      adc	temp1	; add the offset to character graphics to our value
   5045  f448		       9d 00 20 	      sta	VALBUFFER,x
   5046  f44b		       e8		      inx
   5047  f44c		       c8		      iny
   5048  f44d
   5049  f44d		       c6 47		      dec	plotdigitcount
   5050  f44f		       d0 df		      bne	pvnibble2char
   5051  f451
   5052  f451							;point to the start of our valuebuffer
   5053  f451		       18		      clc
   5054  f452		       a9 00		      lda	#<VALBUFFER
   5055  f454		       6d ad 01 	      adc	valbufend
   5056  f457		       85 42		      sta	temp1
   5057  f459		       a9 20		      lda	#>VALBUFFER
   5058  f45b		       69 00		      adc	#0
   5059  f45d		       85 43		      sta	temp2
   5060  f45f
   5061  f45f							;advance valbufend to the end of our value buffer
   5062  f45f		       8e ad 01 	      stx	valbufend
   5063  f462
   5064  f462				  -	      ifnconst	plotvalueonscreen
   5065  f462				  -	      jmp	plotcharacters
   5066  f462					      else
   5067  f462		       4c ec f3 	      jmp	plotcharacterslive
   5068  f465					      endif
   5069  f465
   5070  f465					      endif		; USED_PLOTVALUE
   5071  f465
   5072  f465
   5073  f465				  -	      ifconst	USED_PLOTVALUEEXTRA
   5074  f465				  -plotdigitcount =	temp6
   5075  f465				  -plotvalueextra
   5076  f465				  -			; calling 7800basic command:
   5077  f465				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   5078  f465				  -			; ...displays the variable as BCD digits
   5079  f465				  -			;
   5080  f465				  -			; asm sub arguments: 
   5081  f465				  -			; temp1=lo charactermap
   5082  f465				  -			; temp2=hi charactermap
   5083  f465				  -			; temp3=palette | width byte
   5084  f465				  -			; temp4=x
   5085  f465				  -			; temp5=y
   5086  f465				  -			; temp6=number of digits
   5087  f465				  -			; temp7=lo variable
   5088  f465				  -			; temp8=hi variable
   5089  f465				  -
   5090  f465				  -	      lda	#0
   5091  f465				  -	      tay
   5092  f465				  -	      ldx	valbufend
   5093  f465				  -	      ifnconst	plotvalueonscreen
   5094  f465				  -	      sta	VALBUFFER,x
   5095  f465				  -	      endif
   5096  f465				  -
   5097  f465				  -	      lda	plotdigitcount
   5098  f465				  -	      and	#1
   5099  f465				  -
   5100  f465				  -	      bne	pvnibble2char_skipnibbleextra
   5101  f465				  -
   5102  f465				  -pvnibble2charextra
   5103  f465				  -			; high nibble...
   5104  f465				  -	      lda	(temp7),y
   5105  f465				  -	      and	#$f0
   5106  f465				  -	      lsr
   5107  f465				  -	      lsr
   5108  f465				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5109  f465				  -	      lsr
   5110  f465				  -	      endif
   5111  f465				  -	      clc
   5112  f465				  -	      adc	temp1	; add the offset to character graphics to our value
   5113  f465				  -	      sta	VALBUFFER,x
   5114  f465				  -	      inx
   5115  f465				  -
   5116  f465				  -			; second half of the digit
   5117  f465				  -	      clc
   5118  f465				  -	      adc	#1
   5119  f465				  -	      sta	VALBUFFER,x
   5120  f465				  -	      inx
   5121  f465				  -
   5122  f465				  -pvnibble2char_skipnibbleextra
   5123  f465				  -			; low nibble...
   5124  f465				  -	      lda	(temp7),y
   5125  f465				  -	      and	#$0f
   5126  f465				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5127  f465				  -	      asl
   5128  f465				  -	      endif
   5129  f465				  -	      asl
   5130  f465				  -
   5131  f465				  -	      clc
   5132  f465				  -	      adc	temp1	; add the offset to character graphics to our value
   5133  f465				  -	      sta	VALBUFFER,x
   5134  f465				  -	      inx
   5135  f465				  -
   5136  f465				  -	      clc
   5137  f465				  -	      adc	#1
   5138  f465				  -	      sta	VALBUFFER,x
   5139  f465				  -	      inx
   5140  f465				  -	      iny
   5141  f465				  -
   5142  f465				  -	      dec	plotdigitcount
   5143  f465				  -	      bne	pvnibble2charextra
   5144  f465				  -
   5145  f465				  -			;point to the start of our valuebuffer
   5146  f465				  -	      clc
   5147  f465				  -	      lda	#<VALBUFFER
   5148  f465				  -	      adc	valbufend
   5149  f465				  -	      sta	temp1
   5150  f465				  -	      lda	#>VALBUFFER
   5151  f465				  -	      adc	#0
   5152  f465				  -	      sta	temp2
   5153  f465				  -
   5154  f465				  -			;advance valbufend to the end of our value buffer
   5155  f465				  -	      stx	valbufend
   5156  f465				  -
   5157  f465				  -	      ifnconst	plotvalueonscreen
   5158  f465				  -	      jmp	plotcharacters
   5159  f465				  -	      else
   5160  f465				  -	      jmp	plotcharacterslive
   5161  f465				  -	      endif
   5162  f465					      endif		; USED_PLOTVALUEEXTRA
   5163  f465
   5164  f465				   boxcollision
   5165  f465				  -	      ifconst	BOXCOLLISION
   5166  f465				  -			; the worst case cycle-time for the code below is 43 cycles.
   5167  f465				  -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   5168  f465				  -
   5169  f465				  -			;__boxx1 = accumulator
   5170  f465				  -			;__boxy1 = y
   5171  f465				  -__boxw1    =	temp3
   5172  f465				  -__boxh1    =	temp4
   5173  f465				  -
   5174  f465				  -__boxx2    =	temp5
   5175  f465				  -__boxy2    =	temp6
   5176  f465				  -__boxw2    =	temp7
   5177  f465				  -__boxh2    =	temp8
   5178  f465				  -
   5179  f465				  -DoXCollisionCheck
   5180  f465				  -			;lda __boxx1 ; skipped. already in the accumulator
   5181  f465				  -	      cmp	__boxx2	;3
   5182  f465				  -	      bcs	X1isbiggerthanX2	;2/3
   5183  f465				  -X2isbiggerthanX1
   5184  f465				  -			; carry is clear
   5185  f465				  -	      adc	__boxw1	;3
   5186  f465				  -	      cmp	__boxx2	;3
   5187  f465				  -	      bcs	DoYCollisionCheck	;3/2
   5188  f465				  -	      rts		;6 - carry clear, no collision
   5189  f465				  -X1isbiggerthanX2
   5190  f465				  -	      clc		;2
   5191  f465				  -	      sbc	__boxw2	;3
   5192  f465				  -	      cmp	__boxx2	;3
   5193  f465				  -	      bcs	noboxcollision	;3/2
   5194  f465				  -DoYCollisionCheck
   5195  f465				  -	      tya		; 2 ; use to be "lda __boxy1"
   5196  f465				  -	      cmp	__boxy2	;3
   5197  f465				  -	      bcs	Y1isbiggerthanY2	;3/2
   5198  f465				  -Y2isbiggerthanY1
   5199  f465				  -			; carry is clear
   5200  f465				  -	      adc	__boxh1	;3
   5201  f465				  -	      cmp	__boxy2	;3
   5202  f465				  -	      rts		;6 
   5203  f465				  -Y1isbiggerthanY2
   5204  f465				  -	      clc		;2
   5205  f465				  -	      sbc	__boxh2	;3
   5206  f465				  -	      cmp	__boxy2	;3
   5207  f465				  -	      bcs	noboxcollision	;3/2
   5208  f465				  -yesboxcollision
   5209  f465				  -	      sec		;2
   5210  f465				  -	      rts		;6
   5211  f465				  -noboxcollision
   5212  f465				  -	      clc		;2
   5213  f465				  -	      rts		;6
   5214  f465					      endif		; BOXCOLLISION
   5215  f465
   5216  f465				   randomize
   5217  f465		       a5 40		      lda	rand
   5218  f467		       4a		      lsr
   5219  f468		       26 41		      rol	rand16
   5220  f46a		       90 02		      bcc	noeor
   5221  f46c		       49 b4		      eor	#$B4
   5222  f46e				   noeor
   5223  f46e		       85 40		      sta	rand
   5224  f470		       45 41		      eor	rand16
   5225  f472		       60		      rts
   5226  f473
   5227  f473							; *** bcd conversion routine courtesy Omegamatrix
   5228  f473							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   5229  f473				   converttobcd
   5230  f473							;value to convert is in the accumulator
   5231  f473		       85 42		      sta	temp1
   5232  f475		       4a		      lsr
   5233  f476		       65 42		      adc	temp1
   5234  f478		       6a		      ror
   5235  f479		       4a		      lsr
   5236  f47a		       4a		      lsr
   5237  f47b		       65 42		      adc	temp1
   5238  f47d		       6a		      ror
   5239  f47e		       65 42		      adc	temp1
   5240  f480		       6a		      ror
   5241  f481		       4a		      lsr
   5242  f482		       29 3c		      and	#$3C
   5243  f484		       85 43		      sta	temp2
   5244  f486		       4a		      lsr
   5245  f487		       65 43		      adc	temp2
   5246  f489		       65 42		      adc	temp1
   5247  f48b		       60		      rts		; return the result in the accumulator
   5248  f48c
   5249  f48c							; Y and A contain multiplicands, result in A
   5250  f48c				   mul8
   5251  f48c		       84 42		      sty	temp1
   5252  f48e		       85 43		      sta	temp2
   5253  f490		       a9 00		      lda	#0
   5254  f492				   reptmul8
   5255  f492		       46 43		      lsr	temp2
   5256  f494		       90 03		      bcc	skipmul8
   5257  f496		       18		      clc
   5258  f497		       65 42		      adc	temp1
   5259  f499							;bcs donemul8 might save cycles?
   5260  f499				   skipmul8
   5261  f499							;beq donemul8 might save cycles?
   5262  f499		       06 42		      asl	temp1
   5263  f49b		       d0 f5		      bne	reptmul8
   5264  f49d				   donemul8
   5265  f49d		       60		      rts
   5266  f49e
   5267  f49e				   div8
   5268  f49e							; A=numerator Y=denominator, result in A
   5269  f49e		       c0 02		      cpy	#2
   5270  f4a0		       90 0a		      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   5271  f4a2		       84 42		      sty	temp1
   5272  f4a4		       a0 ff		      ldy	#$ff
   5273  f4a6				   div8loop
   5274  f4a6		       e5 42		      sbc	temp1
   5275  f4a8		       c8		      iny
   5276  f4a9		       b0 fb		      bcs	div8loop
   5277  f4ab				   div8end
   5278  f4ab		       98		      tya
   5279  f4ac							; result in A
   5280  f4ac		       60		      rts
   5281  f4ad
   5282  f4ad							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   5283  f4ad				   mul16
   5284  f4ad		       84 42		      sty	temp1
   5285  f4af		       85 43		      sta	temp2
   5286  f4b1
   5287  f4b1		       a9 00		      lda	#0
   5288  f4b3		       a2 08		      ldx	#8
   5289  f4b5		       46 42		      lsr	temp1
   5290  f4b7				   mul16_1
   5291  f4b7		       90 03		      bcc	mul16_2
   5292  f4b9		       18		      clc
   5293  f4ba		       65 43		      adc	temp2
   5294  f4bc				   mul16_2
   5295  f4bc		       6a		      ror
   5296  f4bd		       66 42		      ror	temp1
   5297  f4bf		       ca		      dex
   5298  f4c0		       d0 f5		      bne	mul16_1
   5299  f4c2		       85 43		      sta	temp2
   5300  f4c4		       60		      rts
   5301  f4c5
   5302  f4c5							; div int/int
   5303  f4c5							; numerator in A, denom in temp1
   5304  f4c5							; returns with quotient in A, remainder in temp1
   5305  f4c5				   div16
   5306  f4c5		       85 43		      sta	temp2
   5307  f4c7		       84 42		      sty	temp1
   5308  f4c9		       a9 00		      lda	#0
   5309  f4cb		       a2 08		      ldx	#8
   5310  f4cd		       06 43		      asl	temp2
   5311  f4cf				   div16_1
   5312  f4cf		       2a		      rol
   5313  f4d0		       c5 42		      cmp	temp1
   5314  f4d2		       90 02		      bcc	div16_2
   5315  f4d4		       e5 42		      sbc	temp1
   5316  f4d6				   div16_2
   5317  f4d6		       26 43		      rol	temp2
   5318  f4d8		       ca		      dex
   5319  f4d9		       d0 f4		      bne	div16_1
   5320  f4db		       85 42		      sta	temp1
   5321  f4dd		       a5 43		      lda	temp2
   5322  f4df		       60		      rts
   5323  f4e0
   5324  f4e0				  -	      ifconst	bankswitchmode
   5325  f4e0				  -BS_jsr
   5326  f4e0				  -	      ifconst	dumpbankswitch
   5327  f4e0				  -	      sta	dumpbankswitch
   5328  f4e0				  -	      endif
   5329  f4e0				  -	      ifconst	MCPDEVCART
   5330  f4e0				  -	      ora	#$18
   5331  f4e0				  -	      sta	$3000
   5332  f4e0				  -	      else
   5333  f4e0				  -	      sta	$8000
   5334  f4e0				  -	      endif
   5335  f4e0				  -	      pla
   5336  f4e0				  -	      tax
   5337  f4e0				  -	      pla
   5338  f4e0				  -	      rts
   5339  f4e0				  -
   5340  f4e0				  -BS_return
   5341  f4e0				  -	      pla		; bankswitch bank
   5342  f4e0				  -	      ifconst	dumpbankswitch
   5343  f4e0				  -	      sta	dumpbankswitch
   5344  f4e0				  -	      endif
   5345  f4e0				  -	      ifconst	BANKRAM
   5346  f4e0				  -	      sta	currentbank
   5347  f4e0				  -	      ora	currentrambank
   5348  f4e0				  -	      endif
   5349  f4e0				  -	      ifconst	MCPDEVCART
   5350  f4e0				  -	      ora	#$18
   5351  f4e0				  -	      sta	$3000
   5352  f4e0				  -	      else
   5353  f4e0				  -	      sta	$8000
   5354  f4e0				  -	      endif
   5355  f4e0				  -	      pla		; bankswitch $0 flag
   5356  f4e0				  -	      rts
   5357  f4e0					      endif
   5358  f4e0
   5359  f4e0				   checkselectswitch
   5360  f4e0		       ad 82 02 	      lda	SWCHB	; first check the real select switch...
   5361  f4e3		       29 02		      and	#%00000010
   5362  f4e5					      ifnconst	SOFTPAUSEOFF
   5363  f4e5					      ifnconst	MOUSESUPPORT
   5364  f4e5					      ifnconst	TRAKBALLSUPPORT
   5365  f4e5		       f0 0f		      beq	checkselectswitchreturn	; switch is pressed
   5366  f4e7		       ad b9 01 	      lda	port0control
   5367  f4ea		       c9 0b		      cmp	#11
   5368  f4ec		       d0 03		      bne	checkselectsoftswitch
   5369  f4ee		       a9 ff		      lda	#$ff
   5370  f4f0		       60		      rts
   5371  f4f1				   checkselectsoftswitch
   5372  f4f1		       ad 80 02 	      lda	SWCHA	; then check the soft "select" joysick code...
   5373  f4f4		       29 b0		      and	#%10110000	; R_DU
   5374  f4f6					      endif		; TRAKBALLSUPPORT
   5375  f4f6					      endif		; MOUSESUPPORT
   5376  f4f6					      endif		; SOFTPAUSEOFF
   5377  f4f6				   checkselectswitchreturn
   5378  f4f6		       60		      rts
   5379  f4f7
   5380  f4f7				   checkresetswitch
   5381  f4f7		       ad 82 02 	      lda	SWCHB	; first check the real reset switch...
   5382  f4fa		       29 01		      and	#%00000001
   5383  f4fc					      ifnconst	SOFTPAUSEOFF
   5384  f4fc					      ifnconst	MOUSESUPPORT
   5385  f4fc					      ifnconst	TRAKBALLSUPPORT
   5386  f4fc		       f0 0f		      beq	checkresetswitchreturn	; switch is pressed
   5387  f4fe		       ad b9 01 	      lda	port0control
   5388  f501		       c9 0b		      cmp	#11
   5389  f503		       d0 03		      bne	checkresetsoftswitch
   5390  f505		       a9 ff		      lda	#$ff
   5391  f507		       60		      rts
   5392  f508				   checkresetsoftswitch
   5393  f508		       ad 80 02 	      lda	SWCHA	; then check the soft "reset" joysick code...
   5394  f50b		       29 70		      and	#%01110000	; _LDU
   5395  f50d					      endif		; TRAKBALLSUPPORT
   5396  f50d					      endif		; MOUSESUPPORT
   5397  f50d					      endif		; SOFTPAUSEOFF
   5398  f50d				   checkresetswitchreturn
   5399  f50d		       60		      rts
   5400  f50e
   5401  f50e				  -	      ifconst	FINESCROLLENABLED
   5402  f50e				  -finescrolldlls
   5403  f50e				  -	      ldx	temp1	; first DLL index x3
   5404  f50e				  -	      lda	DLLMEM,x
   5405  f50e				  -	      and	#%11110000
   5406  f50e				  -	      ora	finescrolly
   5407  f50e				  -	      sta	DLLMEM,x
   5408  f50e				  -
   5409  f50e				  -	      ldx	temp2	; last DLL index x3
   5410  f50e				  -	      lda	DLLMEM,x
   5411  f50e				  -	      and	#%11110000
   5412  f50e				  -	      ora	finescrolly
   5413  f50e				  -	      eor	#(WZONEHEIGHT-1)
   5414  f50e				  -	      sta	DLLMEM,x
   5415  f50e				  -	      rts
   5416  f50e					      endif		; FINESCROLLENABLED
   5417  f50e
   5418  f50e				  -	      ifconst	USED_ADJUSTVISIBLE
   5419  f50e				  -adjustvisible
   5420  f50e				  -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   5421  f50e				  -	      jsr	waitforvblankstart	; ensure vblank just started
   5422  f50e				  -	      ldx	visibleDLLstart
   5423  f50e				  -findfirstinterrupt
   5424  f50e				  -	      lda	DLLMEM,x
   5425  f50e				  -	      bmi	foundfirstinterrupt
   5426  f50e				  -	      inx
   5427  f50e				  -	      inx
   5428  f50e				  -	      inx
   5429  f50e				  -	      bne	findfirstinterrupt
   5430  f50e				  -foundfirstinterrupt
   5431  f50e				  -	      and	#%01111111	; clear the interrupt bit
   5432  f50e				  -	      sta	DLLMEM,x
   5433  f50e				  -	      ifconst	DOUBLEBUFFER
   5434  f50e				  -	      sta	DLLMEM+DBOFFSET,x
   5435  f50e				  -	      endif		; DOUBLEBUFFER
   5436  f50e				  -	      ldx	overscanDLLstart
   5437  f50e				  -findlastinterrupt
   5438  f50e				  -	      lda	DLLMEM,x
   5439  f50e				  -	      bmi	foundlastinterrupt
   5440  f50e				  -	      dex
   5441  f50e				  -	      dex
   5442  f50e				  -	      dex
   5443  f50e				  -	      bne	findlastinterrupt
   5444  f50e				  -foundlastinterrupt
   5445  f50e				  -	      and	#%01111111	; clear the interrupt bit
   5446  f50e				  -	      sta	DLLMEM,x
   5447  f50e				  -	      ifconst	DOUBLEBUFFER
   5448  f50e				  -	      sta	DLLMEM+DBOFFSET,x
   5449  f50e				  -	      endif		; DOUBLEBUFFER
   5450  f50e				  -			;now we need to set the new interrupts
   5451  f50e				  -	      clc
   5452  f50e				  -	      lda	temp1
   5453  f50e				  -	      adc	visibleDLLstart
   5454  f50e				  -	      tax
   5455  f50e				  -	      lda	DLLMEM,x
   5456  f50e				  -	      ora	#%10000000
   5457  f50e				  -	      sta	DLLMEM,x
   5458  f50e				  -	      ifconst	DOUBLEBUFFER
   5459  f50e				  -	      sta	DLLMEM+DBOFFSET,x
   5460  f50e				  -	      endif		; DOUBLEBUFFER
   5461  f50e				  -	      clc
   5462  f50e				  -	      lda	temp2
   5463  f50e				  -	      adc	visibleDLLstart
   5464  f50e				  -	      tax
   5465  f50e				  -	      lda	DLLMEM,x
   5466  f50e				  -	      ora	#%10000000
   5467  f50e				  -	      sta	DLLMEM,x
   5468  f50e				  -	      ifconst	DOUBLEBUFFER
   5469  f50e				  -	      sta	DLLMEM+DBOFFSET,x
   5470  f50e				  -	      endif		; DOUBLEBUFFER
   5471  f50e				  -	      jsr	vblankresync
   5472  f50e				  -	      rts
   5473  f50e					      endif		; USED_ADJUSTVISIBLE
   5474  f50e
   5475  f50e				   vblankresync
   5476  f50e		       20 cf f5 	      jsr	waitforvblankstart	; ensure vblank just started
   5477  f511		       a9 00		      lda	#0
   5478  f513		       85 4d		      sta	visibleover
   5479  f515		       a9 03		      lda	#3
   5480  f517		       8d b2 01 	      sta	interruptindex
   5481  f51a		       60		      rts
   5482  f51b
   5483  f51b				   createallgamedlls
   5484  f51b		       a2 00		      ldx	#0
   5485  f51d		       a9 19		      lda	#NVLINES
   5486  f51f		       ac 09 21 	      ldy	paldetected
   5487  f522		       f0 03		      beq	skipcreatePALpadding
   5488  f524		       18		      clc
   5489  f525		       69 15		      adc	#21
   5490  f527				   skipcreatePALpadding
   5491  f527		       20 65 f5 	      jsr	createnonvisibledlls
   5492  f52a		       8e 3c 21 	      stx	visibleDLLstart
   5493  f52d		       20 9f f5 	      jsr	createvisiblezones
   5494  f530		       8e 3d 21 	      stx	overscanDLLstart
   5495  f533				   createallgamedllscontinue
   5496  f533		       a9 50		      lda	#(NVLINES+55)	; extras for PAL
   5497  f535		       20 65 f5 	      jsr	createnonvisibledlls
   5498  f538
   5499  f538		       ae 3c 21 	      ldx	visibleDLLstart
   5500  f53b		       bd 00 18 	      lda	DLLMEM,x
   5501  f53e		       09 80		      ora	#%10000000	; NMI 1 - start of visible screen
   5502  f540		       9d 00 18 	      sta	DLLMEM,x
   5503  f543					      ifconst	DOUBLEBUFFER
   5504  f543		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5505  f546					      endif		; DOUBLEBUFFER
   5506  f546
   5507  f546		       ae 3d 21 	      ldx	overscanDLLstart
   5508  f549		       bd 00 18 	      lda	DLLMEM,x
   5509  f54c		       09 83		      ora	#%10000011	; NMI 2 - end of visible screen
   5510  f54e		       29 f3		      and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   5511  f550		       9d 00 18 	      sta	DLLMEM,x
   5512  f553					      ifconst	DOUBLEBUFFER
   5513  f553		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5514  f556					      endif		; DOUBLEBUFFER
   5515  f556
   5516  f556		       e8		      inx
   5517  f557		       e8		      inx
   5518  f558		       e8		      inx
   5519  f559
   5520  f559		       bd 00 18 	      lda	DLLMEM,x
   5521  f55c		       09 80		      ora	#%10000000	; NMI 3 - deeper overscan
   5522  f55e		       9d 00 18 	      sta	DLLMEM,x
   5523  f561					      ifconst	DOUBLEBUFFER
   5524  f561		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5525  f564					      endif		; DOUBLEBUFFER
   5526  f564
   5527  f564		       60		      rts
   5528  f565
   5529  f565				   createnonvisibledlls
   5530  f565		       85 42		      sta	temp1
   5531  f567		       4a		      lsr
   5532  f568		       4a		      lsr
   5533  f569		       4a		      lsr
   5534  f56a		       4a		      lsr		; /16
   5535  f56b		       f0 09		      beq	skipcreatenonvisibledlls1loop
   5536  f56d		       a8		      tay
   5537  f56e				   createnonvisibledlls1loop
   5538  f56e		       a9 4f		      lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   5539  f570		       20 85 f5 	      jsr	createblankdllentry
   5540  f573		       88		      dey
   5541  f574		       d0 f8		      bne	createnonvisibledlls1loop
   5542  f576				   skipcreatenonvisibledlls1loop
   5543  f576		       a5 42		      lda	temp1
   5544  f578		       29 0f		      and	#%00001111
   5545  f57a		       f0 08		      beq	createnonvisibledllsreturn
   5546  f57c		       38		      sec
   5547  f57d		       e9 01		      sbc	#1
   5548  f57f		       09 40		      ora	#%01000000
   5549  f581		       20 85 f5 	      jsr	createblankdllentry
   5550  f584				   createnonvisibledllsreturn
   5551  f584		       60		      rts
   5552  f585
   5553  f585				   createblankdllentry
   5554  f585		       9d 00 18 	      sta	DLLMEM,x
   5555  f588					      ifconst	DOUBLEBUFFER
   5556  f588		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5557  f58b					      endif		; DOUBLEBUFFER
   5558  f58b		       e8		      inx
   5559  f58c		       a9 21		      lda	#$21	; blank
   5560  f58e		       9d 00 18 	      sta	DLLMEM,x
   5561  f591					      ifconst	DOUBLEBUFFER
   5562  f591		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5563  f594					      endif		; DOUBLEBUFFER
   5564  f594		       e8		      inx
   5565  f595		       a9 00		      lda	#$00
   5566  f597		       9d 00 18 	      sta	DLLMEM,x
   5567  f59a					      ifconst	DOUBLEBUFFER
   5568  f59a		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5569  f59d					      endif		; DOUBLEBUFFER
   5570  f59d		       e8		      inx
   5571  f59e		       60		      rts
   5572  f59f
   5573  f59f				   createvisiblezones
   5574  f59f		       a0 00		      ldy	#0
   5575  f5a1				   createvisiblezonesloop
   5576  f5a1		       b9 36 f7 	      lda.w	DLHEIGHT,y
   5577  f5a4		       09 40		      ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   5578  f5a6		       9d 00 18 	      sta	DLLMEM,x
   5579  f5a9					      ifconst	DOUBLEBUFFER
   5580  f5a9		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5581  f5ac					      endif		; DOUBLEBUFFER
   5582  f5ac		       e8		      inx
   5583  f5ad		       b9 1e f7 	      lda	DLPOINTH,y
   5584  f5b0				  -	      ifconst	BANKSET_DL_IN_CARTRAM
   5585  f5b0				  -			; with bankset cart ram, we added $8000 to the DL address so plot functions would hit the write-address
   5586  f5b0				  -			; but now we need to subtract that $8000 location to give Maria the normal address
   5587  f5b0				  -	      sec
   5588  f5b0				  -	      sbc	#$80
   5589  f5b0					      endif		; BANKSET_DL_IN_CARTRAM
   5590  f5b0		       9d 00 18 	      sta	DLLMEM,x
   5591  f5b3					      ifconst	DOUBLEBUFFER
   5592  f5b3		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5593  f5b6					      endif		; DOUBLEBUFFER
   5594  f5b6		       e8		      inx
   5595  f5b7		       b9 2a f7 	      lda	DLPOINTL,y
   5596  f5ba		       9d 00 18 	      sta	DLLMEM,x
   5597  f5bd					      ifconst	DOUBLEBUFFER
   5598  f5bd		       18		      clc
   5599  f5be		       69 48		      adc	#DOUBLEBUFFEROFFSET
   5600  f5c0		       9d 70 18 	      sta	DLLMEM+DBOFFSET,x
   5601  f5c3		       90 03		      bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   5602  f5c5		       fe 6f 18 	      inc	DLLMEM+DBOFFSET-1,x
   5603  f5c8				   skiphidoublebufferadjust
   5604  f5c8					      endif		; DOUBLEBUFFER
   5605  f5c8		       e8		      inx
   5606  f5c9		       c8		      iny
   5607  f5ca		       c0 0c		      cpy	#WZONECOUNT
   5608  f5cc		       d0 d3		      bne	createvisiblezonesloop
   5609  f5ce		       60		      rts
   5610  f5cf
   5611  f5cf				   waitforvblankstart
   5612  f5cf				   vblankendwait
   5613  f5cf		       24 28		      BIT	MSTAT
   5614  f5d1		       30 fc		      bmi	vblankendwait
   5615  f5d3				   vblankstartwait
   5616  f5d3		       24 28		      BIT	MSTAT
   5617  f5d5		       10 fc		      bpl	vblankstartwait
   5618  f5d7		       60		      rts
   5619  f5d8
   5620  f5d8					      ifconst	DOUBLEBUFFER
   5621  f5d8				   flipdisplaybufferreturn
   5622  f5d8		       60		      rts
   5623  f5d9				   flipdisplaybuffer
   5624  f5d9					      ifconst	interrupthold
   5625  f5d9		       a9 ff		      lda	#$FF
   5626  f5db		       8d c3 01 	      sta	interrupthold
   5627  f5de					      endif
   5628  f5de		       a5 d5		      lda	doublebufferstate
   5629  f5e0		       f0 f6		      beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   5630  f5e2
   5631  f5e2		       20 61 f1 	      jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   5632  f5e5
   5633  f5e5		       a5 d5		      lda	doublebufferstate
   5634  f5e7		       4a		      lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   5635  f5e8		       aa		      tax
   5636  f5e9
   5637  f5e9							; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   5638  f5e9
   5639  f5e9				   flipdisplaybufferwait1
   5640  f5e9		       a5 4d		      lda	visibleover
   5641  f5eb		       f0 fc		      beq	flipdisplaybufferwait1
   5642  f5ed
   5643  f5ed				   flipdisplaybufferwait
   5644  f5ed		       a5 4d		      lda	visibleover
   5645  f5ef		       d0 fc		      bne	flipdisplaybufferwait
   5646  f5f1
   5647  f5f1		       ad b3 01 	      lda	doublebufferminimumframetarget
   5648  f5f4		       f0 0b		      beq	skipminimumframecode
   5649  f5f6		       ad b4 01 	      lda	doublebufferminimumframeindex
   5650  f5f9		       d0 ee		      bne	flipdisplaybufferwait1
   5651  f5fb		       ad b3 01 	      lda	doublebufferminimumframetarget
   5652  f5fe		       8d b4 01 	      sta	doublebufferminimumframeindex
   5653  f601				   skipminimumframecode
   5654  f601
   5655  f601		       bd 61 f6 	      lda	DLLMEMLutHi,x
   5656  f604		       85 2c		      sta	DPPH
   5657  f606		       bd 5f f6 	      lda	DLLMEMLutLo,x
   5658  f609		       85 30		      sta	DPPL
   5659  f60b
   5660  f60b		       bd 63 f6 	      lda	NewPageflipstate,x
   5661  f60e		       85 d5		      sta	doublebufferstate
   5662  f610		       bd 65 f6 	      lda	NewPageflipoffset,x
   5663  f613		       85 d6		      sta	doublebufferdloffset
   5664  f615
   5665  f615					      ifnconst	BANKSET_DL_IN_CARTRAM
   5666  f615		       a5 d7		      lda	doublebufferbufferdirty
   5667  f617		       f0 bf		      beq	flipdisplaybufferreturn
   5668  f619
   5669  f619							; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   5670  f619							; To make savescreen work with the new working buffer, we need to copy over the saved objects
   5671  f619							; from the displayed buffer to the working buffer...
   5672  f619
   5673  f619		       a5 d6		      lda	doublebufferdloffset
   5674  f61b		       49 48		      eor	#DOUBLEBUFFEROFFSET
   5675  f61d		       85 47		      sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   5676  f61f
   5677  f61f		       a2 0b		      ldx	#(WZONECOUNT-1)
   5678  f621				   copybufferzoneloop
   5679  f621
   5680  f621		       bd 2a f7 	      lda	DLPOINTL,x
   5681  f624		       18		      clc
   5682  f625		       65 d6		      adc	doublebufferdloffset
   5683  f627		       85 42		      sta	temp1
   5684  f629		       bd 1e f7 	      lda	DLPOINTH,x
   5685  f62c		       69 00		      adc	#0
   5686  f62e		       85 43		      sta	temp2
   5687  f630
   5688  f630		       bd 2a f7 	      lda	DLPOINTL,x
   5689  f633		       18		      clc
   5690  f634		       65 47		      adc	temp6
   5691  f636		       85 44		      sta	temp3
   5692  f638		       bd 1e f7 	      lda	DLPOINTH,x
   5693  f63b		       69 00		      adc	#0
   5694  f63d		       85 45		      sta	temp4
   5695  f63f
   5696  f63f		       b5 82		      lda	dlendsave,x
   5697  f641		       a8		      tay
   5698  f642				   copybuffercharsloop
   5699  f642		       b1 44		      lda	(temp3),y
   5700  f644		       91 42		      sta	(temp1),y
   5701  f646		       88		      dey
   5702  f647		       10 f9		      bpl	copybuffercharsloop
   5703  f649		       ca		      dex
   5704  f64a		       10 d5		      bpl	copybufferzoneloop
   5705  f64c		       a9 00		      lda	#0
   5706  f64e		       85 d7		      sta	doublebufferbufferdirty
   5707  f650					      endif		; ! BANKSET_DL_IN_CARTRAM
   5708  f650		       60		      rts
   5709  f651
   5710  f651				   doublebufferoff
   5711  f651		       a9 01		      lda	#1
   5712  f653		       85 d5		      sta	doublebufferstate
   5713  f655		       20 d9 f5 	      jsr	flipdisplaybuffer
   5714  f658		       a9 00		      lda	#0
   5715  f65a		       85 d5		      sta	doublebufferstate
   5716  f65c		       85 d6		      sta	doublebufferdloffset
   5717  f65e		       60		      rts
   5718  f65f
   5719  f65f				   DLLMEMLutLo
   5720  f65f		       00 70		      .byte.b	<DLLMEM,<(DLLMEM+DBOFFSET)
   5721  f661				   DLLMEMLutHi
   5722  f661		       18 18		      .byte.b	>DLLMEM,>(DLLMEM+DBOFFSET)
   5723  f663				   NewPageflipstate
   5724  f663		       03 01		      .byte.b	3,1
   5725  f665				   NewPageflipoffset
   5726  f665		       48 00		      .byte.b	DOUBLEBUFFEROFFSET,0
   5727  f667
   5728  f667					      endif		; DOUBLEBUFFER
   5729  f667
   5730  f667				  -	      ifconst	MOUSESUPPORT
   5731  f667				  -
   5732  f667				  -rotationalcompare
   5733  f667				  -			; old =   00	  01	  10	 11
   5734  f667				  -	      .byte	$00, $01, $ff, $00	; new=00
   5735  f667				  -	      .byte	$ff, $00, $00, $01	; new=01
   5736  f667				  -	      .byte	$01, $00, $00, $ff	; new=10
   5737  f667				  -	      .byte	$00, $ff, $01, $00	; new=11
   5738  f667				  -
   5739  f667				  -			;  0000YyXx st mouse
   5740  f667				  -
   5741  f667				  -			;  0000xyXY amiga mouse
   5742  f667				  -
   5743  f667				  -	      ifconst	MOUSEXONLY
   5744  f667				  -amigatoataribits		; swap bits 1 and 4...
   5745  f667				  -	      .byte	%0000, %0000, %0010, %0010
   5746  f667				  -	      .byte	%0000, %0000, %0010, %0010
   5747  f667				  -	      .byte	%0001, %0001, %0011, %0011
   5748  f667				  -	      .byte	%0001, %0001, %0011, %0011
   5749  f667				  -
   5750  f667				  -			; null change bits
   5751  f667				  -	      .byte	%0000, %0001, %0010, %0011
   5752  f667				  -	      .byte	%0000, %0001, %0010, %0011
   5753  f667				  -	      .byte	%0000, %0001, %0010, %0011
   5754  f667				  -	      .byte	%0000, %0001, %0010, %0011
   5755  f667				  -
   5756  f667				  -	      else		; !MOUSEXONLY
   5757  f667				  -
   5758  f667				  -amigatoataribits		; swap bits 1 and 4...
   5759  f667				  -	      .byte	%0000, %1000, %0010, %1010
   5760  f667				  -	      .byte	%0100, %1100, %0110, %1110
   5761  f667				  -	      .byte	%0001, %1001, %0011, %1011
   5762  f667				  -	      .byte	%0101, %1101, %0111, %1111
   5763  f667				  -			; null change bits
   5764  f667				  -	      .byte	%0000, %0001, %0010, %0011
   5765  f667				  -	      .byte	%0100, %0101, %0110, %0111
   5766  f667				  -	      .byte	%1000, %1001, %1010, %1011
   5767  f667				  -	      .byte	%1100, %1101, %1110, %1111
   5768  f667				  -	      endif		; !MOUSEXONLY
   5769  f667				  -
   5770  f667					      endif		; MOUSESUPPORT
   5771  f667
   5772  f667				   mouse0update
   5773  f667				  -	      ifconst	MOUSE0SUPPORT
   5774  f667				  -
   5775  f667				  -mousetableselect =	inttemp2
   5776  f667				  -mousexdelta =	inttemp3
   5777  f667				  -mouseydelta =	inttemp4
   5778  f667				  -lastSWCHA  =	inttemp6
   5779  f667				  -
   5780  f667				  -			;  0000YyXx st mouse
   5781  f667				  -			;  0000xyXY amiga mouse
   5782  f667				  -
   5783  f667				  -	      lda	#$ff
   5784  f667				  -	      sta	lastSWCHA
   5785  f667				  -
   5786  f667				  -	      ldy	port0control
   5787  f667				  -
   5788  f667				  -	      lda	#%00010000
   5789  f667				  -	      cpy	#9	; AMIGA?
   5790  f667				  -	      bne	skipamigabitsfix0
   5791  f667				  -	      lda	#0
   5792  f667				  -skipamigabitsfix0
   5793  f667				  -	      sta	mousetableselect
   5794  f667				  -	      ifconst	DRIVINGBOOST
   5795  f667				  -	      cpy	#6	; DRIVING?
   5796  f667				  -	      bne	skipdriving0setup
   5797  f667				  -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   5798  f667				  -			; trails the actual mousex0, so we can smoothly interpolate toward
   5799  f667				  -			; the actual position. This actual position is stored in mousey0 
   5800  f667				  -			; after the driver has run.
   5801  f667				  -	      ldx	mousex0
   5802  f667				  -	      lda	mousey0
   5803  f667				  -	      stx	mousey0
   5804  f667				  -	      sta	mousex0
   5805  f667				  -skipdriving0setup
   5806  f667				  -	      endif		; DRIVINGBOOST
   5807  f667				  -
   5808  f667				  -	      lda	#0
   5809  f667				  -	      sta	mousexdelta
   5810  f667				  -	      sta	mouseydelta
   5811  f667				  -
   5812  f667				  -	      ifnconst	MOUSETIME
   5813  f667				  -	      ifnconst	MOUSEXONLY
   5814  f667				  -	      lda	#180	; minimum for x+y
   5815  f667				  -	      else
   5816  f667				  -	      lda	#100	; minimum for just x
   5817  f667				  -	      endif
   5818  f667				  -	      else
   5819  f667				  -	      lda	#MOUSETIME
   5820  f667				  -	      endif
   5821  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   5822  f667				  -
   5823  f667				  -mouse0updateloop
   5824  f667				  -	      lda	SWCHA
   5825  f667				  -	      asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   5826  f667				  -	      cmp	lastSWCHA
   5827  f667				  -	      beq	mouse0loopcondition
   5828  f667				  -	      sta	lastSWCHA
   5829  f667				  -	      lsr
   5830  f667				  -	      lsr
   5831  f667				  -	      lsr
   5832  f667				  -
   5833  f667				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   5834  f667				  -
   5835  f667				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   5836  f667				  -			;  0000YyXx st mouse
   5837  f667				  -			;  0000xyXY amiga mouse
   5838  f667				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   5839  f667				  -	      tay
   5840  f667				  -	      lax	amigatoataribits,y
   5841  f667				  -
   5842  f667				  -	      ifnconst	MOUSEXONLY
   5843  f667				  -			; first the Y...
   5844  f667				  -	      and	#%00001100
   5845  f667				  -	      ora	mousecodey0
   5846  f667				  -	      tay
   5847  f667				  -	      lda	rotationalcompare,y
   5848  f667				  -	      clc
   5849  f667				  -	      adc	mouseydelta
   5850  f667				  -	      sta	mouseydelta
   5851  f667				  -	      tya
   5852  f667				  -	      lsr
   5853  f667				  -	      lsr
   5854  f667				  -	      sta	mousecodey0
   5855  f667				  -	      txa
   5856  f667				  -			; ...then the X...
   5857  f667				  -	      and	#%00000011
   5858  f667				  -	      tax
   5859  f667				  -	      endif		; !MOUSEXONLY
   5860  f667				  -
   5861  f667				  -	      asl
   5862  f667				  -	      asl
   5863  f667				  -	      ora	mousecodex0
   5864  f667				  -	      tay
   5865  f667				  -	      lda	rotationalcompare,y
   5866  f667				  -	      adc	mousexdelta	; carry was clear by previous ASL
   5867  f667				  -	      sta	mousexdelta
   5868  f667				  -	      stx	mousecodex0
   5869  f667				  -mouse0loopcondition
   5870  f667				  -	      lda	TIMINT
   5871  f667				  -	      bpl	mouse0updateloop
   5872  f667				  -
   5873  f667				  -			; *** adapt to selected device resolution. 
   5874  f667				  -	      ldx	port0control
   5875  f667				  -
   5876  f667				  -	      ifconst	PRECISIONMOUSING
   5877  f667				  -	      ldy	port0resolution
   5878  f667				  -	      bne	mouse0halveddone
   5879  f667				  -	      cpx	#6	; half-resolution is no good for driving wheels
   5880  f667				  -	      beq	mouse0halveddone
   5881  f667				  -			; resolution=0 is half mouse resolution, necessary for precision 
   5882  f667				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   5883  f667				  -
   5884  f667				  -	      lda	mousexdelta
   5885  f667				  -	      cmp	#$80
   5886  f667				  -	      ror		; do a signed divide by 2.
   5887  f667				  -	      clc
   5888  f667				  -	      adc	mousex0
   5889  f667				  -	      sta	mousex0
   5890  f667				  -	      ifnconst	MOUSEXONLY
   5891  f667				  -	      lda	mouseydelta
   5892  f667				  -	      clc
   5893  f667				  -	      adc	mousey0
   5894  f667				  -	      sta	mousey0
   5895  f667				  -	      endif
   5896  f667				  -			; at half resolution we just exit after updating x and y
   5897  f667				  -	      jmp	LLRET0
   5898  f667				  -mouse0halveddone
   5899  f667				  -	      endif		; PRECISIONMOUSING
   5900  f667				  -
   5901  f667				  -	      ifnconst	MOUSEXONLY
   5902  f667				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   5903  f667				  -	      ldy	port0resolution
   5904  f667				  -	      dey
   5905  f667				  -	      lda	#0
   5906  f667				  -mousey0resolutionfix
   5907  f667				  -	      clc
   5908  f667				  -	      adc	mouseydelta
   5909  f667				  -	      dey
   5910  f667				  -	      bpl	mousey0resolutionfix
   5911  f667				  -	      clc
   5912  f667				  -	      adc	mousey0
   5913  f667				  -	      sta	mousey0
   5914  f667				  -	      endif		; MOUSEXONLY
   5915  f667				  -
   5916  f667				  -	      ldy	port0resolution
   5917  f667				  -	      dey
   5918  f667				  -	      lda	#0
   5919  f667				  -mousex0resolutionfix
   5920  f667				  -	      clc
   5921  f667				  -	      adc	mousexdelta
   5922  f667				  -	      dey
   5923  f667				  -	      bpl	mousex0resolutionfix
   5924  f667				  -	      ifnconst	DRIVINGBOOST
   5925  f667				  -	      clc
   5926  f667				  -	      adc	mousex0
   5927  f667				  -	      sta	mousex0
   5928  f667				  -	      else
   5929  f667				  -	      cpx	#6
   5930  f667				  -	      beq	carryonmouse0boost
   5931  f667				  -	      clc
   5932  f667				  -	      adc	mousex0
   5933  f667				  -	      sta	mousex0
   5934  f667				  -	      jmp	LLRET0
   5935  f667				  -carryonmouse0boost
   5936  f667				  -	      sta	mousexdelta
   5937  f667				  -	      clc
   5938  f667				  -	      adc	mousecodey0
   5939  f667				  -	      sta	mousecodey0
   5940  f667				  -	      clc
   5941  f667				  -	      adc	mousex0
   5942  f667				  -	      tay		; save the target X
   5943  f667				  -	      adc	mousey0	; average in the smoothly-trailing X
   5944  f667				  -	      ror
   5945  f667				  -	      sta	mousex0	; mousex0 now has the smoothly trailing X
   5946  f667				  -	      sty	mousey0	; and mousey0 has the the target X
   5947  f667				  -
   5948  f667				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   5949  f667				  -			; A has mousex0, the smoothly trailing X
   5950  f667				  -	      sbc	mousey0	; less the target X
   5951  f667				  -	      bpl	skipabsolutedrive0
   5952  f667				  -	      eor	#$ff
   5953  f667				  -skipabsolutedrive0
   5954  f667				  -	      cmp	#64	; just an unreasonably large change
   5955  f667				  -	      bcc	skipdrivewrapfix0
   5956  f667				  -	      sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   5957  f667				  -skipdrivewrapfix0
   5958  f667				  -
   5959  f667				  -			; get rid of the tweening if the distance travelled was very small
   5960  f667				  -	      lda	mousexdelta
   5961  f667				  -	      cmp	port0resolution
   5962  f667				  -	      bcs	skipbetweenfix0
   5963  f667				  -	      lda	mousex0
   5964  f667				  -	      sta	mousey0
   5965  f667				  -skipbetweenfix0
   5966  f667				  -
   5967  f667				  -drivingboostreductioncheck0
   5968  f667				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   5969  f667				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   5970  f667				  -			; negated again because truncation during BCD math results in 
   5971  f667				  -			; differing magnitudes, depending if the value is  +ve or -ve.
   5972  f667				  -driving0fix
   5973  f667				  -	      lax	mousecodey0
   5974  f667				  -	      cmp	#$80
   5975  f667				  -	      bcs	driving0skipnegate1
   5976  f667				  -	      eor	#$FF
   5977  f667				  -	      adc	#1
   5978  f667				  -	      sta	mousecodey0
   5979  f667				  -driving0skipnegate1
   5980  f667				  -	      cmp	#$80
   5981  f667				  -	      ror
   5982  f667				  -	      cmp	#$80
   5983  f667				  -	      ror
   5984  f667				  -	      cmp	#$80
   5985  f667				  -	      ror
   5986  f667				  -	      sta	inttemp1
   5987  f667				  -	      lda	mousecodey0
   5988  f667				  -	      sec
   5989  f667				  -	      sbc	inttemp1
   5990  f667				  -	      cpx	#$80
   5991  f667				  -	      bcs	driving0skipnegate2
   5992  f667				  -	      eor	#$FF
   5993  f667				  -	      adc	#1
   5994  f667				  -driving0skipnegate2
   5995  f667				  -	      sta	mousecodey0
   5996  f667				  -drivingboostdone0
   5997  f667				  -	      endif		; DRIVINGBOOST
   5998  f667				  -
   5999  f667				  -	      jmp	LLRET0
   6000  f667				  -
   6001  f667					      endif		; MOUSE0SUPPORT
   6002  f667
   6003  f667				   mouse1update
   6004  f667				  -	      ifconst	MOUSE1SUPPORT
   6005  f667				  -
   6006  f667				  -mousetableselect =	inttemp2
   6007  f667				  -mousexdelta =	inttemp3
   6008  f667				  -mouseydelta =	inttemp4
   6009  f667				  -lastSWCHA  =	inttemp6
   6010  f667				  -
   6011  f667				  -			;  0000YyXx st mouse
   6012  f667				  -			;  0000xyXY amiga mouse
   6013  f667				  -
   6014  f667				  -	      lda	#$ff
   6015  f667				  -	      sta	lastSWCHA
   6016  f667				  -
   6017  f667				  -	      ldy	port1control
   6018  f667				  -
   6019  f667				  -	      lda	#%00010000
   6020  f667				  -	      cpy	#9	; AMIGA?
   6021  f667				  -	      bne	skipamigabitsfix1
   6022  f667				  -	      lda	#0
   6023  f667				  -skipamigabitsfix1
   6024  f667				  -	      sta	mousetableselect
   6025  f667				  -	      ifconst	DRIVINGBOOST
   6026  f667				  -	      cpy	#6	; DRIVING?
   6027  f667				  -	      bne	skipdriving1setup
   6028  f667				  -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   6029  f667				  -			; trails the actual mousex1, so we can smoothly interpolate toward
   6030  f667				  -			; the actual position. This actual position is stored in mousey1 
   6031  f667				  -			; after the driver has run.
   6032  f667				  -	      ldx	mousex1
   6033  f667				  -	      lda	mousey1
   6034  f667				  -	      stx	mousey1
   6035  f667				  -	      sta	mousex1
   6036  f667				  -skipdriving1setup
   6037  f667				  -	      endif		; DRIVINGBOOST
   6038  f667				  -
   6039  f667				  -	      lda	#0
   6040  f667				  -	      sta	mousexdelta
   6041  f667				  -	      sta	mouseydelta
   6042  f667				  -
   6043  f667				  -	      ifnconst	MOUSETIME
   6044  f667				  -	      ifnconst	MOUSEXONLY
   6045  f667				  -	      lda	#180	; minimum for x+y
   6046  f667				  -	      else
   6047  f667				  -	      lda	#100	; minimum for just x
   6048  f667				  -	      endif
   6049  f667				  -	      else
   6050  f667				  -	      lda	#MOUSETIME
   6051  f667				  -	      endif
   6052  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   6053  f667				  -
   6054  f667				  -mouse1updateloop
   6055  f667				  -	      lda	SWCHA
   6056  f667				  -	      and	#%00001111
   6057  f667				  -	      cmp	lastSWCHA
   6058  f667				  -	      beq	mouse1loopcondition
   6059  f667				  -	      sta	lastSWCHA
   6060  f667				  -
   6061  f667				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   6062  f667				  -
   6063  f667				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   6064  f667				  -			;  0000YyXx st mouse
   6065  f667				  -			;  0000xyXY amiga mouse
   6066  f667				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   6067  f667				  -	      tay
   6068  f667				  -	      lax	amigatoataribits,y
   6069  f667				  -
   6070  f667				  -	      ifnconst	MOUSEXONLY
   6071  f667				  -			; first the Y...
   6072  f667				  -	      and	#%00001100
   6073  f667				  -	      ora	mousecodey1
   6074  f667				  -	      tay
   6075  f667				  -	      lda	rotationalcompare,y
   6076  f667				  -	      clc
   6077  f667				  -	      adc	mouseydelta
   6078  f667				  -	      sta	mouseydelta
   6079  f667				  -	      tya
   6080  f667				  -	      lsr
   6081  f667				  -	      lsr
   6082  f667				  -	      sta	mousecodey1
   6083  f667				  -	      txa
   6084  f667				  -			; ...then the X...
   6085  f667				  -	      and	#%00000011
   6086  f667				  -	      tax
   6087  f667				  -	      endif		; !MOUSEXONLY
   6088  f667				  -
   6089  f667				  -	      asl
   6090  f667				  -	      asl
   6091  f667				  -	      ora	mousecodex1
   6092  f667				  -	      tay
   6093  f667				  -	      lda	rotationalcompare,y
   6094  f667				  -	      adc	mousexdelta	; carry was clear by previous ASL
   6095  f667				  -	      sta	mousexdelta
   6096  f667				  -	      stx	mousecodex1
   6097  f667				  -mouse1loopcondition
   6098  f667				  -	      lda	TIMINT
   6099  f667				  -	      bpl	mouse1updateloop
   6100  f667				  -
   6101  f667				  -			; *** adapt to selected device resolution. 
   6102  f667				  -	      ldx	port1control
   6103  f667				  -
   6104  f667				  -	      ifconst	PRECISIONMOUSING
   6105  f667				  -	      ldy	port1resolution
   6106  f667				  -	      bne	mouse1halveddone
   6107  f667				  -	      cpx	#6	; half-resolution is no good for driving wheels
   6108  f667				  -	      beq	mouse1halveddone
   6109  f667				  -			; resolution=0 is half mouse resolution, necessary for precision 
   6110  f667				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   6111  f667				  -
   6112  f667				  -	      lda	mousexdelta
   6113  f667				  -	      cmp	#$80
   6114  f667				  -	      ror		; do a signed divide by 2.
   6115  f667				  -	      clc
   6116  f667				  -	      adc	mousex1
   6117  f667				  -	      sta	mousex1
   6118  f667				  -	      ifnconst	MOUSEXONLY
   6119  f667				  -	      lda	mouseydelta
   6120  f667				  -	      clc
   6121  f667				  -	      adc	mousey1
   6122  f667				  -	      sta	mousey1
   6123  f667				  -	      endif
   6124  f667				  -			; at half resolution we just exit after updating x and y
   6125  f667				  -	      jmp	LLRET1
   6126  f667				  -mouse1halveddone
   6127  f667				  -	      endif		; PRECISIONMOUSING
   6128  f667				  -
   6129  f667				  -	      ifnconst	MOUSEXONLY
   6130  f667				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   6131  f667				  -	      ldy	port1resolution
   6132  f667				  -	      dey
   6133  f667				  -	      lda	#0
   6134  f667				  -mousey1resolutionfix
   6135  f667				  -	      clc
   6136  f667				  -	      adc	mouseydelta
   6137  f667				  -	      dey
   6138  f667				  -	      bpl	mousey1resolutionfix
   6139  f667				  -	      clc
   6140  f667				  -	      adc	mousey1
   6141  f667				  -	      sta	mousey1
   6142  f667				  -	      endif		; MOUSEXONLY
   6143  f667				  -
   6144  f667				  -	      ldy	port1resolution
   6145  f667				  -	      dey
   6146  f667				  -	      lda	#0
   6147  f667				  -mousex1resolutionfix
   6148  f667				  -	      clc
   6149  f667				  -	      adc	mousexdelta
   6150  f667				  -	      dey
   6151  f667				  -	      bpl	mousex1resolutionfix
   6152  f667				  -	      ifnconst	DRIVINGBOOST
   6153  f667				  -	      clc
   6154  f667				  -	      adc	mousex1
   6155  f667				  -	      sta	mousex1
   6156  f667				  -	      else
   6157  f667				  -	      cpx	#6
   6158  f667				  -	      beq	carryonmouse1boost
   6159  f667				  -	      clc
   6160  f667				  -	      adc	mousex1
   6161  f667				  -	      sta	mousex1
   6162  f667				  -	      jmp	LLRET1
   6163  f667				  -carryonmouse1boost
   6164  f667				  -	      sta	mousexdelta
   6165  f667				  -	      clc
   6166  f667				  -	      adc	mousecodey1
   6167  f667				  -	      sta	mousecodey1
   6168  f667				  -	      clc
   6169  f667				  -	      adc	mousex1
   6170  f667				  -	      tay		; save the target X
   6171  f667				  -	      adc	mousey1	; average in the smoothly-trailing X
   6172  f667				  -	      ror
   6173  f667				  -	      sta	mousex1	; mousex0 now has the smoothly trailing X
   6174  f667				  -	      sty	mousey1	; and mousey0 has the the target X
   6175  f667				  -
   6176  f667				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   6177  f667				  -			; A has mousex1, the smoothly trailing X
   6178  f667				  -	      sbc	mousey1	; less the target X
   6179  f667				  -	      bpl	skipabsolutedrive1
   6180  f667				  -	      eor	#$ff
   6181  f667				  -skipabsolutedrive1
   6182  f667				  -	      cmp	#64	; just an unreasonably large change
   6183  f667				  -	      bcc	skipdrivewrapfix1
   6184  f667				  -	      sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   6185  f667				  -skipdrivewrapfix1
   6186  f667				  -
   6187  f667				  -			; get rid of the tweening if the distance travelled was very small
   6188  f667				  -	      lda	mousexdelta
   6189  f667				  -	      cmp	port1resolution
   6190  f667				  -	      bcs	skipbetweenfix1
   6191  f667				  -	      lda	mousex1
   6192  f667				  -	      sta	mousey1
   6193  f667				  -skipbetweenfix1
   6194  f667				  -
   6195  f667				  -drivingboostreductioncheck1
   6196  f667				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   6197  f667				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   6198  f667				  -			; negated again because truncation during BCD math results in 
   6199  f667				  -			; differing magnitudes, depending if the value is  +ve or -ve.
   6200  f667				  -driving1fix
   6201  f667				  -	      lax	mousecodey1
   6202  f667				  -	      cmp	#$80
   6203  f667				  -	      bcs	driving0skipnegate1
   6204  f667				  -	      eor	#$FF
   6205  f667				  -	      adc	#1
   6206  f667				  -	      sta	mousecodey1
   6207  f667				  -driving0skipnegate1
   6208  f667				  -	      cmp	#$80
   6209  f667				  -	      ror
   6210  f667				  -	      cmp	#$80
   6211  f667				  -	      ror
   6212  f667				  -	      cmp	#$80
   6213  f667				  -	      ror
   6214  f667				  -	      sta	inttemp1
   6215  f667				  -	      lda	mousecodey1
   6216  f667				  -	      sec
   6217  f667				  -	      sbc	inttemp1
   6218  f667				  -	      cpx	#$80
   6219  f667				  -	      bcs	driving1skipnegate2
   6220  f667				  -	      eor	#$FF
   6221  f667				  -	      adc	#1
   6222  f667				  -driving1skipnegate2
   6223  f667				  -	      sta	mousecodey1
   6224  f667				  -drivingboostdone1
   6225  f667				  -	      endif		; DRIVINGBOOST
   6226  f667				  -
   6227  f667				  -	      jmp	LLRET1
   6228  f667				  -
   6229  f667					      endif		; MOUSE1SUPPORT
   6230  f667
   6231  f667
   6232  f667				   trakball0update
   6233  f667				  -	      ifconst	TRAKBALL0SUPPORT
   6234  f667				  -	      ifnconst	TRAKTIME
   6235  f667				  -	      ifnconst	TRAKXONLY
   6236  f667				  -	      lda	#180	; minimum for x+y
   6237  f667				  -	      else		;  !TRAKXONLY
   6238  f667				  -	      lda	#100	; minimum for just x
   6239  f667				  -	      endif		; !TRAKXONLY
   6240  f667				  -	      else		; !TRAKTIME
   6241  f667				  -	      lda	#TRAKTIME
   6242  f667				  -	      endif		; !TRAKTIME
   6243  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   6244  f667				  -	      ldx	#0
   6245  f667				  -	      ifnconst	TRAKXONLY
   6246  f667				  -	      ldy	#0
   6247  f667				  -	      endif		;  TRAKXONLY
   6248  f667				  -trakball0updateloop
   6249  f667				  -	      lda	SWCHA
   6250  f667				  -	      and	#%00110000
   6251  f667				  -	      cmp	trakballcodex0
   6252  f667				  -	      sta	trakballcodex0
   6253  f667				  -	      beq	trakball0movementXdone
   6254  f667				  -	      and	#%00010000
   6255  f667				  -	      beq	trakball0negativeX
   6256  f667				  -trakball0positiveX
   6257  f667				  -			;(2 from beq)
   6258  f667				  -	      inx		; 2
   6259  f667				  -	      jmp	trakball0movementXdone	; 3
   6260  f667				  -trakball0negativeX
   6261  f667				  -			;(3 from beq)
   6262  f667				  -	      dex		; 2
   6263  f667				  -	      nop		; 2
   6264  f667				  -trakball0movementXdone
   6265  f667				  -
   6266  f667				  -	      ifnconst	TRAKXONLY
   6267  f667				  -	      lda	SWCHA
   6268  f667				  -	      and	#%11000000
   6269  f667				  -	      cmp	trakballcodey0
   6270  f667				  -	      sta	trakballcodey0
   6271  f667				  -	      beq	trakball0movementYdone
   6272  f667				  -	      and	#%01000000
   6273  f667				  -	      beq	trakball0negativeY
   6274  f667				  -trakball0positiveY
   6275  f667				  -			;(2 from beq)
   6276  f667				  -	      iny		; 2
   6277  f667				  -	      jmp	trakball0movementYdone	; 3
   6278  f667				  -trakball0negativeY
   6279  f667				  -			;(3 from beq)
   6280  f667				  -	      dey		; 2
   6281  f667				  -	      nop		; 2
   6282  f667				  -trakball0movementYdone
   6283  f667				  -	      endif		; !TRAKXONLY
   6284  f667				  -
   6285  f667				  -	      lda	TIMINT
   6286  f667				  -	      bpl	trakball0updateloop
   6287  f667				  -	      lda	#0
   6288  f667				  -	      cpx	#0
   6289  f667				  -	      beq	trakball0skipXadjust
   6290  f667				  -	      clc
   6291  f667				  -trakball0Xloop
   6292  f667				  -	      adc	port0resolution
   6293  f667				  -	      dex
   6294  f667				  -	      bne	trakball0Xloop
   6295  f667				  -	      clc
   6296  f667				  -	      adc	trakballx0
   6297  f667				  -	      sta	trakballx0
   6298  f667				  -trakball0skipXadjust
   6299  f667				  -	      ifnconst	TRAKXONLY
   6300  f667				  -	      lda	#0
   6301  f667				  -	      cpy	#0
   6302  f667				  -	      beq	trakball0skipYadjust
   6303  f667				  -	      clc
   6304  f667				  -trakball0yloop
   6305  f667				  -	      adc	port0resolution
   6306  f667				  -	      dey
   6307  f667				  -	      bne	trakball0yloop
   6308  f667				  -	      clc
   6309  f667				  -	      adc	trakbally0
   6310  f667				  -	      sta	trakbally0
   6311  f667				  -trakball0skipYadjust
   6312  f667				  -	      endif		; !TRAKXONLY
   6313  f667				  -
   6314  f667				  -	      jmp	LLRET0
   6315  f667					      endif
   6316  f667
   6317  f667
   6318  f667
   6319  f667				   trakball1update
   6320  f667				  -	      ifconst	TRAKBALL1SUPPORT
   6321  f667				  -	      ifnconst	TRAKTIME
   6322  f667				  -	      ifnconst	TRAKXONLY
   6323  f667				  -	      lda	#180	; minimum for x+y
   6324  f667				  -	      else		;  !TRAKXONLY
   6325  f667				  -	      lda	#100	; minimum for just x
   6326  f667				  -	      endif		; !TRAKXONLY
   6327  f667				  -	      else		; !TRAKTIME
   6328  f667				  -	      lda	#TRAKTIME
   6329  f667				  -	      endif		; !TRAKTIME
   6330  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   6331  f667				  -	      ldx	#0
   6332  f667				  -	      ifnconst	TRAKXONLY
   6333  f667				  -	      ldy	#0
   6334  f667				  -	      endif		;  TRAKXONLY
   6335  f667				  -trakball1updateloop
   6336  f667				  -	      lda	SWCHA
   6337  f667				  -	      and	#%00000011
   6338  f667				  -	      cmp	trakballcodex1
   6339  f667				  -	      sta	trakballcodex1
   6340  f667				  -	      beq	trakball1movementXdone
   6341  f667				  -	      and	#%00000001
   6342  f667				  -	      beq	trakball1negativeX
   6343  f667				  -trakball1positiveX
   6344  f667				  -			;(2 from beq)
   6345  f667				  -	      inx		; 2
   6346  f667				  -	      jmp	trakball1movementXdone	; 3
   6347  f667				  -trakball1negativeX
   6348  f667				  -			;(3 from beq)
   6349  f667				  -	      dex		; 2
   6350  f667				  -	      nop		; 2
   6351  f667				  -trakball1movementXdone
   6352  f667				  -
   6353  f667				  -	      ifnconst	TRAKXONLY
   6354  f667				  -	      lda	SWCHA
   6355  f667				  -	      and	#%00001100
   6356  f667				  -	      cmp	trakballcodey1
   6357  f667				  -	      sta	trakballcodey1
   6358  f667				  -	      beq	trakball1movementYdone
   6359  f667				  -	      and	#%00000100
   6360  f667				  -	      beq	trakball1negativeY
   6361  f667				  -trakball1positiveY
   6362  f667				  -			;(2 from beq)
   6363  f667				  -	      iny		; 2
   6364  f667				  -	      jmp	trakball1movementYdone	; 3
   6365  f667				  -trakball1negativeY
   6366  f667				  -			;(3 from beq)
   6367  f667				  -	      dey		; 2
   6368  f667				  -	      nop		; 2
   6369  f667				  -trakball1movementYdone
   6370  f667				  -	      endif		; !TRAKXONLY
   6371  f667				  -
   6372  f667				  -	      lda	TIMINT
   6373  f667				  -	      bpl	trakball1updateloop
   6374  f667				  -	      lda	#0
   6375  f667				  -	      cpx	#0
   6376  f667				  -	      beq	trakball1skipXadjust
   6377  f667				  -	      clc
   6378  f667				  -trakball1Xloop
   6379  f667				  -	      adc	port1resolution
   6380  f667				  -	      dex
   6381  f667				  -	      bne	trakball1Xloop
   6382  f667				  -	      clc
   6383  f667				  -	      adc	trakballx1
   6384  f667				  -	      sta	trakballx1
   6385  f667				  -trakball1skipXadjust
   6386  f667				  -	      ifnconst	TRAKXONLY
   6387  f667				  -	      lda	#0
   6388  f667				  -	      cpy	#0
   6389  f667				  -	      beq	trakball1skipYadjust
   6390  f667				  -	      clc
   6391  f667				  -trakball1yloop
   6392  f667				  -	      adc	port1resolution
   6393  f667				  -	      dey
   6394  f667				  -	      bne	trakball1yloop
   6395  f667				  -	      clc
   6396  f667				  -	      adc	trakbally1
   6397  f667				  -	      sta	trakbally1
   6398  f667				  -trakball1skipYadjust
   6399  f667				  -	      endif		; !TRAKXONLY
   6400  f667				  -
   6401  f667				  -	      jmp	LLRET1
   6402  f667					      endif
   6403  f667
   6404  f667
   6405  f667				   paddleport0update
   6406  f667				  -	      ifconst	PADDLE0SUPPORT
   6407  f667				  -	      lda	#6
   6408  f667				  -	      sta	VBLANK	; start charging the paddle caps
   6409  f667				  -	      lda	#0	; use PADDLE timing
   6410  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   6411  f667				  -
   6412  f667				  -paddleport0updateloop
   6413  f667				  -	      lda	INPT0
   6414  f667				  -	      bmi	skippaddle0setposition
   6415  f667				  -	      sty	paddleposition0
   6416  f667				  -skippaddle0setposition
   6417  f667				  -	      ifconst	TWOPADDLESUPPORT
   6418  f667				  -	      lda	INPT1
   6419  f667				  -	      bmi	skippaddle1setposition
   6420  f667				  -	      sty	paddleposition1
   6421  f667				  -skippaddle1setposition
   6422  f667				  -	      endif
   6423  f667				  -	      ldy	INTIM
   6424  f667				  -	      cpy	#TIMEOFFSET
   6425  f667				  -	      bcs	paddleport0updateloop
   6426  f667				  -
   6427  f667				  -	      lda	#%10000110
   6428  f667				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6429  f667				  -	      sec
   6430  f667				  -	      lda	paddleposition0
   6431  f667				  -	      sbc	#TIMEOFFSET
   6432  f667				  -	      ifconst	PADDLESCALEX2
   6433  f667				  -	      asl
   6434  f667				  -	      endif
   6435  f667				  -
   6436  f667				  -	      ifnconst	PADDLESMOOTHINGOFF
   6437  f667				  -	      clc
   6438  f667				  -	      adc	paddleprevious0
   6439  f667				  -	      ror
   6440  f667				  -	      sta	paddleprevious0
   6441  f667				  -	      endif
   6442  f667				  -
   6443  f667				  -	      sta	paddleposition0
   6444  f667				  -
   6445  f667				  -	      ifconst	TWOPADDLESUPPORT
   6446  f667				  -	      sec
   6447  f667				  -	      lda	paddleposition1
   6448  f667				  -	      sbc	#TIMEOFFSET
   6449  f667				  -	      ifconst	PADDLESCALEX2
   6450  f667				  -	      asl
   6451  f667				  -	      endif
   6452  f667				  -
   6453  f667				  -	      ifnconst	PADDLESMOOTHINGOFF
   6454  f667				  -	      clc
   6455  f667				  -	      adc	paddleprevious1
   6456  f667				  -	      ror
   6457  f667				  -	      sta	paddleprevious1
   6458  f667				  -	      endif
   6459  f667				  -	      sta	paddleposition1
   6460  f667				  -	      endif		; TWOPADDLESUPPORT
   6461  f667				  -
   6462  f667				  -	      jmp	LLRET0
   6463  f667					      endif
   6464  f667
   6465  f667				   paddleport1update
   6466  f667				  -	      ifconst	PADDLE1SUPPORT
   6467  f667				  -	      lda	#6
   6468  f667				  -	      sta	VBLANK	; start charging the paddle caps
   6469  f667				  -
   6470  f667				  -	      lda	#0	; use PADDLE timing
   6471  f667				  -	      jsr	SETTIM64T	; INTIM is in Y
   6472  f667				  -
   6473  f667				  -paddleport1updateloop
   6474  f667				  -	      lda	INPT2
   6475  f667				  -	      bmi	skippaddle2setposition
   6476  f667				  -	      sty	paddleposition2
   6477  f667				  -skippaddle2setposition
   6478  f667				  -	      ifconst	TWOPADDLESUPPORT
   6479  f667				  -	      lda	INPT3
   6480  f667				  -	      bmi	skippaddle3setposition
   6481  f667				  -	      sty	paddleposition3
   6482  f667				  -skippaddle3setposition
   6483  f667				  -	      endif
   6484  f667				  -	      ldy	INTIM
   6485  f667				  -	      cpy	#TIMEOFFSET
   6486  f667				  -	      bcs	paddleport1updateloop
   6487  f667				  -
   6488  f667				  -	      lda	#%10000110
   6489  f667				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6490  f667				  -	      sec
   6491  f667				  -	      lda	paddleposition2
   6492  f667				  -	      sbc	#TIMEOFFSET
   6493  f667				  -	      ifconst	PADDLESCALEX2
   6494  f667				  -	      asl
   6495  f667				  -	      endif
   6496  f667				  -
   6497  f667				  -	      ifnconst	PADDLESMOOTHINGOFF
   6498  f667				  -	      clc
   6499  f667				  -	      adc	paddleprevious2
   6500  f667				  -	      ror
   6501  f667				  -	      sta	paddleprevious2
   6502  f667				  -	      endif
   6503  f667				  -
   6504  f667				  -	      sta	paddleposition2
   6505  f667				  -
   6506  f667				  -	      ifconst	TWOPADDLESUPPORT
   6507  f667				  -	      sec
   6508  f667				  -	      lda	paddleposition3
   6509  f667				  -	      sbc	#TIMEOFFSET
   6510  f667				  -	      ifconst	PADDLESCALEX2
   6511  f667				  -	      asl
   6512  f667				  -	      endif
   6513  f667				  -
   6514  f667				  -	      ifnconst	PADDLESMOOTHINGOFF
   6515  f667				  -	      clc
   6516  f667				  -	      adc	paddleprevious3
   6517  f667				  -	      ror
   6518  f667				  -	      sta	paddleprevious3
   6519  f667				  -	      endif
   6520  f667				  -	      sta	paddleposition3
   6521  f667				  -	      endif		; TWOPADDLESUPPORT
   6522  f667				  -
   6523  f667				  -	      jmp	LLRET1
   6524  f667					      endif
   6525  f667
   6526  f667
   6527  f667				   paddlebuttonhandler		; outside of conditional, for button-handler LUT
   6528  f667				  -	      ifconst	PADDLESUPPORT
   6529  f667				  -			; x=0|1 for port, rather than paddle #. 
   6530  f667				  -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   6531  f667				  -			; game wants to support 2 paddles, up to the game to instead test the 
   6532  f667				  -			; joystick right+left directions instead.
   6533  f667				  -	      lda	SWCHA	; top of nibble is first paddle button
   6534  f667				  -	      cpx	#0	; port 0?
   6535  f667				  -	      beq	skippaddleport2shift
   6536  f667				  -	      asl		; shift second port to upper nibble
   6537  f667				  -	      asl
   6538  f667				  -	      asl
   6539  f667				  -	      asl
   6540  f667				  -skippaddleport2shift
   6541  f667				  -	      and	#%10000000
   6542  f667				  -	      eor	#%10000000	; invert
   6543  f667				  -	      sta	sINPT1,x
   6544  f667				  -	      jmp	buttonreadloopreturn
   6545  f667					      endif		; PADDLESUPPORT
   6546  f667
   6547  f667				   mousebuttonhandler		; outside of conditional, for button-handler LUT
   6548  f667				  -	      ifconst	MOUSESUPPORT
   6549  f667				  -			; stick the mouse buttons in the correct shadow register...
   6550  f667				  -	      txa
   6551  f667				  -	      asl
   6552  f667				  -	      tay		; y=x*2
   6553  f667				  -	      lda	INPT4,x
   6554  f667				  -	      eor	#%10000000
   6555  f667				  -	      lsr
   6556  f667				  -	      sta	sINPT1,x
   6557  f667				  -
   6558  f667				  -	      lda	INPT1,y
   6559  f667				  -	      and	#%10000000
   6560  f667				  -	      eor	#%10000000
   6561  f667				  -	      ora	sINPT1,x
   6562  f667				  -	      sta	sINPT1,x
   6563  f667				  -	      jmp	buttonreadloopreturn
   6564  f667					      endif		; MOUSESUPPORT
   6565  f667
   6566  f667				  -	      ifconst	KEYPADSUPPORT
   6567  f667				  -			; ** select keypad rows 0 to 3 over 4 frames...
   6568  f667				  -keypadrowselect
   6569  f667				  -	      inc	keypadcounter
   6570  f667				  -	      ldy	#0
   6571  f667				  -	      lda	port0control
   6572  f667				  -	      cmp	#7
   6573  f667				  -	      bne	skipport0val
   6574  f667				  -	      iny		; y=y+1
   6575  f667				  -skipport0val
   6576  f667				  -	      lda	port1control
   6577  f667				  -	      cmp	#7
   6578  f667				  -	      bne	skipport1val
   6579  f667				  -	      iny
   6580  f667				  -	      iny		; y=y+2
   6581  f667				  -skipport1val
   6582  f667				  -	      cpy	#0
   6583  f667				  -	      beq	exitkeypadrowselect
   6584  f667				  -	      lda	keyrowdirectionmask,y
   6585  f667				  -	      sta	CTLSWA
   6586  f667				  -	      tya
   6587  f667				  -	      asl
   6588  f667				  -	      asl
   6589  f667				  -	      sta	inttemp1
   6590  f667				  -	      lda	keypadcounter
   6591  f667				  -	      and	#3
   6592  f667				  -	      ora	inttemp1
   6593  f667				  -	      tax
   6594  f667				  -	      lda	keyrowselectvalue,x
   6595  f667				  -	      sta	SWCHA
   6596  f667				  -exitkeypadrowselect
   6597  f667				  -	      rts
   6598  f667				  -
   6599  f667				  -keyrowdirectionmask
   6600  f667				  -	      .byte	#%00000000	; 0 : port0=input  port1=input
   6601  f667				  -	      .byte	#%11110000	; 1 : port0=output port1=input
   6602  f667				  -	      .byte	#%00001111	; 2 : port0=input  port1=output
   6603  f667				  -	      .byte	#%11111111	; 3 : port0=output port1=output
   6604  f667				  -
   6605  f667				  -keyrowselectvalue
   6606  f667				  -	      .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   6607  f667				  -	      .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   6608  f667				  -	      .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   6609  f667				  -	      .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   6610  f667					      endif		;  KEYPADSUPPORT
   6611  f667
   6612  f667				  -	      ifconst	KEYPADSUPPORT
   6613  f667				  -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   6614  f667				  -keypadcolumnread
   6615  f667				  -	      lda	port0control
   6616  f667				  -	      cmp	#7
   6617  f667				  -	      bne	skipkeypadcolumnread0
   6618  f667				  -	      lda	keypadcounter
   6619  f667				  -	      and	#3
   6620  f667				  -	      asl		; x2 because keypad variables are interleaved
   6621  f667				  -	      tax
   6622  f667				  -	      lda	#0
   6623  f667				  -	      sta	keypadmatrix0a,x
   6624  f667				  -	      lda	INPT0
   6625  f667				  -	      cmp	#$80
   6626  f667				  -	      rol	keypadmatrix0a,x
   6627  f667				  -	      lda	INPT1
   6628  f667				  -	      cmp	#$80
   6629  f667				  -	      rol	keypadmatrix0a,x
   6630  f667				  -	      lda	INPT4
   6631  f667				  -	      cmp	#$80
   6632  f667				  -	      rol	keypadmatrix0a,x
   6633  f667				  -	      lda	keypadmatrix0a,x
   6634  f667				  -	      eor	#%00000111
   6635  f667				  -	      sta	keypadmatrix0a,x
   6636  f667				  -skipkeypadcolumnread0
   6637  f667				  -
   6638  f667				  -	      lda	port1control
   6639  f667				  -	      cmp	#7
   6640  f667				  -	      bne	skipkeypadcolumnread1
   6641  f667				  -	      lda	keypadcounter
   6642  f667				  -	      and	#3
   6643  f667				  -	      asl		; x2 because keypad variables are interleaved
   6644  f667				  -	      tax
   6645  f667				  -	      lda	#0
   6646  f667				  -	      sta	keypadmatrix1a,x
   6647  f667				  -	      rol	keypadmatrix1a,x
   6648  f667				  -	      lda	INPT2
   6649  f667				  -	      cmp	#$80
   6650  f667				  -	      rol	keypadmatrix1a,x
   6651  f667				  -	      lda	INPT3
   6652  f667				  -	      cmp	#$80
   6653  f667				  -	      rol	keypadmatrix1a,x
   6654  f667				  -	      lda	INPT5
   6655  f667				  -	      cmp	#$80
   6656  f667				  -	      rol	keypadmatrix1a,x
   6657  f667				  -	      lda	keypadmatrix1a,x
   6658  f667				  -	      eor	#%00000111
   6659  f667				  -	      sta	keypadmatrix1a,x
   6660  f667				  -skipkeypadcolumnread1
   6661  f667				  -	      rts
   6662  f667					      endif		; KEYPADSUPPORT
   6663  f667
   6664  f667				   setportforinput
   6665  f667		       a5 e4		      lda	CTLSWAs
   6666  f669		       3d 72 f6 	      and	allpinsinputlut,x
   6667  f66c		       85 e4		      sta	CTLSWAs
   6668  f66e		       8d 81 02 	      sta	CTLSWA
   6669  f671		       60		      rts
   6670  f672
   6671  f672				   allpinsinputlut
   6672  f672		       0f f0		      .byte.b	$0F, $F0
   6673  f674
   6674  f674				   setonebuttonmode
   6675  f674		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   6676  f676		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   6677  f678		       a9 14		      lda	#$14
   6678  f67a		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   6679  f67d		       a5 e5		      lda	CTLSWBs
   6680  f67f		       1d 88 f6 	      ora	thisjoy2buttonbit,x
   6681  f682		       85 e5		      sta	CTLSWBs
   6682  f684		       8d 82 02 	      sta	SWCHB	; turn off the 2-button disable bits
   6683  f687		       60		      rts
   6684  f688
   6685  f688				   thisjoy2buttonbit
   6686  f688		       04 10		      .byte.b	$04, $10
   6687  f68a
   6688  f68a				   settwobuttonmode
   6689  f68a		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   6690  f68c		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   6691  f68e		       a9 14		      lda	#$14
   6692  f690		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   6693  f693		       a5 e5		      lda	CTLSWBs
   6694  f695		       3d 9e f6 	      and	thisjoy2buttonmask,x
   6695  f698		       85 e5		      sta	CTLSWBs
   6696  f69a		       8d 82 02 	      sta	SWCHB
   6697  f69d		       60		      rts
   6698  f69e
   6699  f69e				   thisjoy2buttonmask
   6700  f69e		       fb ef		      .byte.b	$fb, $ef
   6701  f6a0
   6702  f6a0							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6703  f6a0
   6704  f6a0				   START
   6705  f6a0				   start
   6706  f6a0
   6707  f6a0							;******** more or less the Atari recommended startup procedure
   6708  f6a0
   6709  f6a0		       78		      sei
   6710  f6a1		       d8		      cld
   6711  f6a2
   6712  f6a2					      ifnconst	NOTIALOCK
   6713  f6a2		       a9 07		      lda	#$07
   6714  f6a4				  -	      else
   6715  f6a4				  -	      lda	#$06
   6716  f6a4					      endif
   6717  f6a4		       85 01		      sta	INPTCTRL	;lock 7800 into 7800 mode
   6718  f6a6		       a9 7f		      lda	#$7F
   6719  f6a8		       85 3c		      sta	CTRL	;disable DMA
   6720  f6aa		       a9 00		      lda	#$00
   6721  f6ac		       85 38		      sta	OFFSET
   6722  f6ae					      ifnconst	NOTIALOCK
   6723  f6ae		       85 01		      sta	INPTCTRL
   6724  f6b0		       85 20		      sta	BACKGRND	; black default, in case a flash cart is using something else
   6725  f6b2					      endif
   6726  f6b2		       a2 ff		      ldx	#$FF
   6727  f6b4		       9a		      txs
   6728  f6b5
   6729  f6b5							;************** Clear Memory
   6730  f6b5
   6731  f6b5							; ** Clear 1800-27FF, pg0+pg1 memory.
   6732  f6b5				   ClearMemPages
   6733  f6b5		       a9 00		      lda	#0
   6734  f6b7		       a8		      tay		; y=0
   6735  f6b8		       85 80		      sta	$80
   6736  f6ba		       a2 18		      ldx	#$18
   6737  f6bc				   ClearMemPagesLoop
   6738  f6bc		       86 81		      stx	$81	; needed for when we step on ZP memory
   6739  f6be		       91 80		      sta	($80),y	;Store data
   6740  f6c0		       c8		      iny		;Next byte
   6741  f6c1		       d0 f9		      bne	ClearMemPagesLoop
   6742  f6c3		       e8		      inx
   6743  f6c4		       e0 28		      cpx	#$28
   6744  f6c6		       d0 f4		      bne	ClearMemPagesLoop
   6745  f6c8		       85 81		      sta	$81
   6746  f6ca
   6747  f6ca							;seed random number with hopefully-random timer value
   6748  f6ca		       a9 01		      lda	#1
   6749  f6cc		       0d 84 02 	      ora	INTIM
   6750  f6cf		       85 40		      sta	rand
   6751  f6d1
   6752  f6d1							; detect the console type...
   6753  f6d1				   pndetectvblankstart
   6754  f6d1		       a5 28		      lda	MSTAT
   6755  f6d3		       10 fc		      bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   6756  f6d5				   pndetectvblankover
   6757  f6d5		       a5 28		      lda	MSTAT
   6758  f6d7		       30 fc		      bmi	pndetectvblankover	;  then wait for it to be over
   6759  f6d9		       a0 00		      ldy	#$00
   6760  f6db		       a2 00		      ldx	#$00
   6761  f6dd				   pndetectvblankhappening
   6762  f6dd		       a5 28		      lda	MSTAT
   6763  f6df		       30 07		      bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   6764  f6e1		       85 24		      sta	WSYNC
   6765  f6e3		       85 24		      sta	WSYNC
   6766  f6e5		       e8		      inx
   6767  f6e6		       d0 f5		      bne	pndetectvblankhappening
   6768  f6e8				   pndetectinvblank
   6769  f6e8		       e0 7d		      cpx	#125
   6770  f6ea		       90 02		      bcc	pndetecispal
   6771  f6ec		       a0 01		      ldy	#$01
   6772  f6ee				   pndetecispal
   6773  f6ee		       8c 09 21 	      sty	paldetected
   6774  f6f1
   6775  f6f1		       20 1b f5 	      jsr	createallgamedlls
   6776  f6f4
   6777  f6f4		       a9 18		      lda	#>DLLMEM
   6778  f6f6		       85 2c		      sta	DPPH
   6779  f6f8		       a9 00		      lda	#<DLLMEM
   6780  f6fa		       85 30		      sta	DPPL
   6781  f6fc
   6782  f6fc				  -	      ifconst	pokeysupport
   6783  f6fc				  -			; pokey support is compiled in, so try to detect it...
   6784  f6fc				  -	      jsr	detectpokeylocation
   6785  f6fc					      endif
   6786  f6fc
   6787  f6fc		       a9 01		      lda	#1	; default for port 0 and 1 is a regular joystick
   6788  f6fe		       8d b9 01 	      sta	port0control
   6789  f701		       8d ba 01 	      sta	port1control
   6790  f704
   6791  f704							;Setup port A to read mode
   6792  f704							;lda #$00
   6793  f704							;sta SWCHA
   6794  f704							;sta CTLSWA
   6795  f704
   6796  f704				  -	      ifconst	HSSUPPORT
   6797  f704				  -	      ifconst	bankswitchmode
   6798  f704				  -	      ifconst	included.hiscore.asm.bank
   6799  f704				  -	      ifconst	MCPDEVCART
   6800  f704				  -	      lda	#($18 | included.hiscore.asm.bank)
   6801  f704				  -	      ifconst	dumpbankswitch
   6802  f704				  -	      sta	dumpbankswitch
   6803  f704				  -	      endif
   6804  f704				  -	      sta	$3000
   6805  f704				  -	      else
   6806  f704				  -	      lda	#(included.hiscore.asm.bank)
   6807  f704				  -	      ifconst	dumpbankswitch
   6808  f704				  -	      sta	dumpbankswitch
   6809  f704				  -	      endif
   6810  f704				  -	      sta	$8000
   6811  f704				  -	      endif
   6812  f704				  -	      endif		; included.hiscore.asm.bank
   6813  f704				  -	      endif		; bankswitchmode
   6814  f704				  -			; try to detect HSC
   6815  f704				  -	      jsr	detecthsc
   6816  f704				  -	      and	#1
   6817  f704				  -	      sta	hsdevice
   6818  f704				  -skipHSCdetect
   6819  f704				  -			; try to detect AtariVox eeprom
   6820  f704				  -	      jsr	detectatarivoxeeprom
   6821  f704				  -	      and	#2
   6822  f704				  -	      ora	hsdevice
   6823  f704				  -	      cmp	#3
   6824  f704				  -	      bne	storeAinhsdevice
   6825  f704				  -			; For now, we tie break by giving HSC priority over AtariVox.
   6826  f704				  -			; Later we should check each device's priority byte if set, instead, 
   6827  f704				  -	      lda	#2
   6828  f704				  -storeAinhsdevice
   6829  f704				  -	      sta	hsdevice
   6830  f704				  -	      lda	#$ff
   6831  f704				  -	      sta	hsdifficulty
   6832  f704				  -	      sta	hsgameslot
   6833  f704				  -	      sta	hsnewscoreline
   6834  f704					      endif		; HSSUPPORT
   6835  f704
   6836  f704				  -	      ifconst	AVOXVOICE
   6837  f704				  -	      jsr	silenceavoxvoice
   6838  f704					      endif
   6839  f704
   6840  f704				  -	      ifconst	RMT
   6841  f704				  -	      ifconst	RMTVOLUME
   6842  f704				  -	      lda	#$F0	; default to full RMT volume
   6843  f704				  -	      sta	rmtvolume
   6844  f704				  -	      ifconst	TIAVOLUME
   6845  f704				  -	      sta	tiavolume
   6846  f704				  -	      endif		; TIAVOLUME
   6847  f704				  -	      endif		; RMTVOLUME
   6848  f704					      else		; !RMT
   6849  f704				  -	      ifconst	TIAVOLUME
   6850  f704				  -	      lda	#$F0	; default to full TIA volume
   6851  f704				  -	      sta	tiavolume
   6852  f704					      endif		; TIAVOLUME
   6853  f704					      endif		; RMT
   6854  f704
   6855  f704				  -	      ifconst	bankswitchmode
   6856  f704				  -			; we need to switch to the first bank as a default. this needs to
   6857  f704				  -			; happen before DMA, in case there's a topscreenroutine in bank 0
   6858  f704				  -	      ifconst	MCPDEVCART
   6859  f704				  -	      lda	#$18	; xxx11nnn - switch to bank 0
   6860  f704				  -	      ifconst	dumpbankswitch
   6861  f704				  -	      sta	dumpbankswitch
   6862  f704				  -	      endif
   6863  f704				  -	      sta	$3000
   6864  f704				  -	      else
   6865  f704				  -	      lda	#0
   6866  f704				  -	      ifconst	dumpbankswitch
   6867  f704				  -	      sta	dumpbankswitch
   6868  f704				  -	      endif
   6869  f704				  -	      sta	$8000
   6870  f704				  -	      endif
   6871  f704					      endif
   6872  f704
   6873  f704							; CTRL 76543210
   6874  f704							; 7 colorburst kill
   6875  f704							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   6876  f704							; 4 character width 1=2 byte chars, 0=1 byte chars
   6877  f704							; 3 border control 0=background color border, 1=black border
   6878  f704							; 2 kangaroo mode 0=transparency, 1=kangaroo
   6879  f704							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   6880  f704
   6881  f704				  -	      ifconst	DOUBLEWIDE
   6882  f704				  -	      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   6883  f704					      else
   6884  f704		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   6885  f706					      endif
   6886  f706
   6887  f706		       20 cf f5 	      jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   6888  f709
   6889  f709		       85 3c		      sta	CTRL
   6890  f70b		       8d 07 21 	      sta	sCTRL
   6891  f70e
   6892  f70e		       20 0e f5 	      jsr	vblankresync
   6893  f711
   6894  f711		       a2 01		      ldx	#1
   6895  f713		       20 8a f6 	      jsr	settwobuttonmode
   6896  f716		       a2 00		      ldx	#0
   6897  f718		       20 8a f6 	      jsr	settwobuttonmode
   6898  f71b
   6899  f71b					      ifnconst	.altgamestart
   6900  f71b		       4c 00 40 	      jmp	game
   6901  f71e				  -	      else
   6902  f71e				  -	      jmp	.altgamestart
   6903  f71e					      endif
   6904  f71e
   6905  f71e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6906  f71e
   6907  f71e							;************** Setup DLL entries
   6908  f71e
   6909  f71e							; setup some working definitions, to avoid ifnconst mess elsewhere...
   6910  f71e					      ifnconst	SCREENHEIGHT
   6911  f71e		       00 c0	   WSCREENHEIGHT =	192
   6912  f71e				  -	      else
   6913  f71e				  -WSCREENHEIGHT =	SCREENHEIGHT
   6914  f71e					      endif
   6915  f71e
   6916  f71e				  -	      ifnconst	ZONEHEIGHT
   6917  f71e				  -WZONEHEIGHT =	16
   6918  f71e					      else
   6919  f71e		       00 10	   WZONEHEIGHT =	ZONEHEIGHT
   6920  f71e					      endif
   6921  f71e
   6922  f71e					      ifnconst	ZONECOUNT
   6923  f71e		       00 0c	   WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   6924  f71e				  -	      else
   6925  f71e				  -WZONECOUNT =	ZONECOUNT
   6926  f71e					      endif
   6927  f71e
   6928  f71e							; top of the frame, non-visible lines. this is based on NTSC,
   6929  f71e							; but we add in extra NV lines at the end of the display to ensure
   6930  f71e							; our PAL friends can play the game without it crashing.
   6931  f71e		       00 19	   NVLINES    =	((243-WSCREENHEIGHT)/2)
   6932  f71e
   6933  f71e					      ifnconst	DLMEMSTART
   6934  f71e				  -	      ifnconst	DOUBLEBUFFER
   6935  f71e				  -WDLMEMSTART =	$1880
   6936  f71e					      else
   6937  f71e		       18 e0	   WDLMEMSTART =	$18E0
   6938  f71e					      endif		; DOUBLEBUFFER
   6939  f71e				  -	      else
   6940  f71e				  -WDLMEMSTART =	DLMEMSTART
   6941  f71e					      endif
   6942  f71e
   6943  f71e					      ifnconst	DLMEMEND
   6944  f71e				  -	      ifconst	EXTRADLMEMORY
   6945  f71e				  -WDLMEMEND  =	$23FF
   6946  f71e					      else
   6947  f71e		       1f ff	   WDLMEMEND  =	$1FFF
   6948  f71e					      endif
   6949  f71e				  -	      else
   6950  f71e				  -WDLMEMEND  =	DLMEMEND
   6951  f71e					      endif
   6952  f71e
   6953  f71e
   6954  f71e		       07 20	   WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   6955  f71e
   6956  f71e				  -	      ifnconst	DOUBLEBUFFER
   6957  f71e				  -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   6958  f71e					      else
   6959  f71e		       00 46	   DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   6960  f71e					      endif
   6961  f71e
   6962  f71e		       00 48	   TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   6963  f71e				  -	      if	TDOUBLEBUFFEROFFSET > 255
   6964  f71e				  -DOUBLEBUFFEROFFSET =	255
   6965  f71e					      else
   6966  f71e		       00 48	   DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   6967  f71e					      endif
   6968  f71e
   6969  f71e				  -	      ifconst	EXTRADLMEMORY
   6970  f71e				  -SECONDDLHALFSTART SET	$2300
   6971  f71e					      endif
   6972  f71e
   6973  f71e				   DLPOINTH
   6974  f71e				   DLINDEX    SET	0
   6975  f71e					      REPEAT	WZONECOUNT
   6976  f71e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f71e				  -	      ifconst	EXTRADLMEMORY
   6978  f71e				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f71e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f71e				  -	      else
   6981  f71e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f71e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f71e				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f71e				  -	      endif
   6985  f71e				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f71e					      endif		; EXTRADLMEMORY
   6987  f71e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f71e		       18		      .byte.b	>TMPMEMADDRESS
   6989  f71e				   DLINDEX    SET	DLINDEX + 1
   6975  f71e					      REPEND
   6976  f71e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f71f				  -	      ifconst	EXTRADLMEMORY
   6978  f71f				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f71f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f71f				  -	      else
   6981  f71f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f71f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f71f				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f71f				  -	      endif
   6985  f71f				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f71f					      endif		; EXTRADLMEMORY
   6987  f71f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f71f		       19		      .byte.b	>TMPMEMADDRESS
   6989  f71f				   DLINDEX    SET	DLINDEX + 1
   6975  f71f					      REPEND
   6976  f71f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f720				  -	      ifconst	EXTRADLMEMORY
   6978  f720				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f720				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f720				  -	      else
   6981  f720				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f720				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f720				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f720				  -	      endif
   6985  f720				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f720					      endif		; EXTRADLMEMORY
   6987  f720							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f720		       1a		      .byte.b	>TMPMEMADDRESS
   6989  f720				   DLINDEX    SET	DLINDEX + 1
   6975  f720					      REPEND
   6976  f720				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f721				  -	      ifconst	EXTRADLMEMORY
   6978  f721				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f721				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f721				  -	      else
   6981  f721				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f721				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f721				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f721				  -	      endif
   6985  f721				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f721					      endif		; EXTRADLMEMORY
   6987  f721							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f721		       1a		      .byte.b	>TMPMEMADDRESS
   6989  f721				   DLINDEX    SET	DLINDEX + 1
   6975  f721					      REPEND
   6976  f721				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f722				  -	      ifconst	EXTRADLMEMORY
   6978  f722				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f722				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f722				  -	      else
   6981  f722				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f722				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f722				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f722				  -	      endif
   6985  f722				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f722					      endif		; EXTRADLMEMORY
   6987  f722							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f722		       1b		      .byte.b	>TMPMEMADDRESS
   6989  f722				   DLINDEX    SET	DLINDEX + 1
   6975  f722					      REPEND
   6976  f722				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f723				  -	      ifconst	EXTRADLMEMORY
   6978  f723				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f723				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f723				  -	      else
   6981  f723				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f723				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f723				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f723				  -	      endif
   6985  f723				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f723					      endif		; EXTRADLMEMORY
   6987  f723							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f723		       1b		      .byte.b	>TMPMEMADDRESS
   6989  f723				   DLINDEX    SET	DLINDEX + 1
   6975  f723					      REPEND
   6976  f723				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f724				  -	      ifconst	EXTRADLMEMORY
   6978  f724				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f724				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f724				  -	      else
   6981  f724				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f724				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f724				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f724				  -	      endif
   6985  f724				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f724					      endif		; EXTRADLMEMORY
   6987  f724							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f724		       1c		      .byte.b	>TMPMEMADDRESS
   6989  f724				   DLINDEX    SET	DLINDEX + 1
   6975  f724					      REPEND
   6976  f724				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f725				  -	      ifconst	EXTRADLMEMORY
   6978  f725				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f725				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f725				  -	      else
   6981  f725				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f725				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f725				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f725				  -	      endif
   6985  f725				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f725					      endif		; EXTRADLMEMORY
   6987  f725							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f725		       1d		      .byte.b	>TMPMEMADDRESS
   6989  f725				   DLINDEX    SET	DLINDEX + 1
   6975  f725					      REPEND
   6976  f725				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f726				  -	      ifconst	EXTRADLMEMORY
   6978  f726				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f726				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f726				  -	      else
   6981  f726				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f726				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f726				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f726				  -	      endif
   6985  f726				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f726					      endif		; EXTRADLMEMORY
   6987  f726							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f726		       1d		      .byte.b	>TMPMEMADDRESS
   6989  f726				   DLINDEX    SET	DLINDEX + 1
   6975  f726					      REPEND
   6976  f726				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f727				  -	      ifconst	EXTRADLMEMORY
   6978  f727				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f727				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f727				  -	      else
   6981  f727				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f727				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f727				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f727				  -	      endif
   6985  f727				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f727					      endif		; EXTRADLMEMORY
   6987  f727							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f727		       1e		      .byte.b	>TMPMEMADDRESS
   6989  f727				   DLINDEX    SET	DLINDEX + 1
   6975  f727					      REPEND
   6976  f727				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f728				  -	      ifconst	EXTRADLMEMORY
   6978  f728				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f728				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f728				  -	      else
   6981  f728				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f728				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f728				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f728				  -	      endif
   6985  f728				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f728					      endif		; EXTRADLMEMORY
   6987  f728							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f728		       1e		      .byte.b	>TMPMEMADDRESS
   6989  f728				   DLINDEX    SET	DLINDEX + 1
   6975  f728					      REPEND
   6976  f728				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6977  f729				  -	      ifconst	EXTRADLMEMORY
   6978  f729				  -	      if	TMPMEMADDRESS > $1FFF
   6979  f729				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6980  f729				  -	      else
   6981  f729				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6982  f729				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6983  f729				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6984  f729				  -	      endif
   6985  f729				  -	      endif		; TMPMEMADDRESS > $1FFF
   6986  f729					      endif		; EXTRADLMEMORY
   6987  f729							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6988  f729		       1f		      .byte.b	>TMPMEMADDRESS
   6989  f729				   DLINDEX    SET	DLINDEX + 1
   6990  f72a					      REPEND
   6991  f72a
   6992  f72a				  -	      ifconst	EXTRADLMEMORY
   6993  f72a				  -	      echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   6994  f72a					      endif
   6995  f72a
   6996  f72a
   6997  f72a				   DLPOINTL
   6998  f72a				   DLINDEX    SET	0
   6999  f72a					      REPEAT	WZONECOUNT
   7000  f72a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72a				  -	      ifconst	EXTRADLMEMORY
   7002  f72a				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72a				  -	      else
   7005  f72a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72a				  -	      endif
   7008  f72a				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72a					      endif		; EXTRADLMEMORY
   7010  f72a		       e0		      .byte.b	<TMPMEMADDRESS
   7011  f72a				   DLINDEX    SET	DLINDEX + 1
   6999  f72a					      REPEND
   7000  f72a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72b				  -	      ifconst	EXTRADLMEMORY
   7002  f72b				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72b				  -	      else
   7005  f72b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72b				  -	      endif
   7008  f72b				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72b					      endif		; EXTRADLMEMORY
   7010  f72b		       78		      .byte.b	<TMPMEMADDRESS
   7011  f72b				   DLINDEX    SET	DLINDEX + 1
   6999  f72b					      REPEND
   7000  f72b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72c				  -	      ifconst	EXTRADLMEMORY
   7002  f72c				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72c				  -	      else
   7005  f72c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72c				  -	      endif
   7008  f72c				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72c					      endif		; EXTRADLMEMORY
   7010  f72c		       10		      .byte.b	<TMPMEMADDRESS
   7011  f72c				   DLINDEX    SET	DLINDEX + 1
   6999  f72c					      REPEND
   7000  f72c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72d				  -	      ifconst	EXTRADLMEMORY
   7002  f72d				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72d				  -	      else
   7005  f72d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72d				  -	      endif
   7008  f72d				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72d					      endif		; EXTRADLMEMORY
   7010  f72d		       a8		      .byte.b	<TMPMEMADDRESS
   7011  f72d				   DLINDEX    SET	DLINDEX + 1
   6999  f72d					      REPEND
   7000  f72d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72e				  -	      ifconst	EXTRADLMEMORY
   7002  f72e				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72e				  -	      else
   7005  f72e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72e				  -	      endif
   7008  f72e				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72e					      endif		; EXTRADLMEMORY
   7010  f72e		       40		      .byte.b	<TMPMEMADDRESS
   7011  f72e				   DLINDEX    SET	DLINDEX + 1
   6999  f72e					      REPEND
   7000  f72e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f72f				  -	      ifconst	EXTRADLMEMORY
   7002  f72f				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f72f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f72f				  -	      else
   7005  f72f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f72f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f72f				  -	      endif
   7008  f72f				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f72f					      endif		; EXTRADLMEMORY
   7010  f72f		       d8		      .byte.b	<TMPMEMADDRESS
   7011  f72f				   DLINDEX    SET	DLINDEX + 1
   6999  f72f					      REPEND
   7000  f72f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f730				  -	      ifconst	EXTRADLMEMORY
   7002  f730				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f730				  -	      else
   7005  f730				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f730				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f730				  -	      endif
   7008  f730				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f730					      endif		; EXTRADLMEMORY
   7010  f730		       70		      .byte.b	<TMPMEMADDRESS
   7011  f730				   DLINDEX    SET	DLINDEX + 1
   6999  f730					      REPEND
   7000  f730				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f731				  -	      ifconst	EXTRADLMEMORY
   7002  f731				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f731				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f731				  -	      else
   7005  f731				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f731				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f731				  -	      endif
   7008  f731				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f731					      endif		; EXTRADLMEMORY
   7010  f731		       08		      .byte.b	<TMPMEMADDRESS
   7011  f731				   DLINDEX    SET	DLINDEX + 1
   6999  f731					      REPEND
   7000  f731				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f732				  -	      ifconst	EXTRADLMEMORY
   7002  f732				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f732				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f732				  -	      else
   7005  f732				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f732				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f732				  -	      endif
   7008  f732				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f732					      endif		; EXTRADLMEMORY
   7010  f732		       a0		      .byte.b	<TMPMEMADDRESS
   7011  f732				   DLINDEX    SET	DLINDEX + 1
   6999  f732					      REPEND
   7000  f732				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f733				  -	      ifconst	EXTRADLMEMORY
   7002  f733				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f733				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f733				  -	      else
   7005  f733				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f733				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f733				  -	      endif
   7008  f733				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f733					      endif		; EXTRADLMEMORY
   7010  f733		       38		      .byte.b	<TMPMEMADDRESS
   7011  f733				   DLINDEX    SET	DLINDEX + 1
   6999  f733					      REPEND
   7000  f733				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f734				  -	      ifconst	EXTRADLMEMORY
   7002  f734				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f734				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f734				  -	      else
   7005  f734				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f734				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f734				  -	      endif
   7008  f734				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f734					      endif		; EXTRADLMEMORY
   7010  f734		       d0		      .byte.b	<TMPMEMADDRESS
   7011  f734				   DLINDEX    SET	DLINDEX + 1
   6999  f734					      REPEND
   7000  f734				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7001  f735				  -	      ifconst	EXTRADLMEMORY
   7002  f735				  -	      if	TMPMEMADDRESS > $1FFF
   7003  f735				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7004  f735				  -	      else
   7005  f735				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7006  f735				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7007  f735				  -	      endif
   7008  f735				  -	      endif		; TMPMEMADDRESS > $1FFF
   7009  f735					      endif		; EXTRADLMEMORY
   7010  f735		       68		      .byte.b	<TMPMEMADDRESS
   7011  f735				   DLINDEX    SET	DLINDEX + 1
   7012  f736					      REPEND
   7013  f736
   7014  f736
   7015  f736				   DLINDEX    SET	0
   7016  f736					      REPEAT	WZONECOUNT
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       18 e0	   ZONE0ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       19 78	   ZONE1ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1a 10	   ZONE2ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1a a8	   ZONE3ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1b 40	   ZONE4ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1b d8	   ZONE5ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1c 70	   ZONE6ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1d 08	   ZONE7ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1d a0	   ZONE8ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1e 38	   ZONE9ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1e d0	   ZONE10ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7016  f736					      REPEND
   7017  f736				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   7018  f736				  -	      ifconst	EXTRADLMEMORY
   7019  f736				  -	      if	TMPMEMADDRESS > $1FFF
   7020  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7021  f736				  -	      else
   7022  f736				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   7023  f736				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   7024  f736				  -	      endif
   7025  f736				  -	      endif		; TMPMEMADDRESS > $1FFF
   7026  f736					      endif		; EXTRADLMEMORY
   7027  f736
   7028  f736		       1f 68	   ZONE11ADDRESS =	TMPMEMADDRESS
   7029  f736
   7030  f736				   DLINDEX    SET	DLINDEX + 1
   7031  f736					      REPEND
   7032  f736
   7033  f736
     $18e0 to $1fff used as zone memory, allowing 14 display objects per zone.
   7034  f736					      echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   7035  f736
   7036  f736				   DLHEIGHT
   7037  f736					      REPEAT	WZONECOUNT
   7038  f736		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f736					      REPEND
   7038  f737		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f737					      REPEND
   7038  f738		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f738					      REPEND
   7038  f739		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f739					      REPEND
   7038  f73a		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73a					      REPEND
   7038  f73b		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73b					      REPEND
   7038  f73c		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73c					      REPEND
   7038  f73d		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73d					      REPEND
   7038  f73e		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73e					      REPEND
   7038  f73f		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f73f					      REPEND
   7038  f740		       0f		      .byte.b	(WZONEHEIGHT-1)
   7037  f740					      REPEND
   7038  f741		       0f		      .byte.b	(WZONEHEIGHT-1)
   7039  f742					      REPEND
   7040  f742
   7041  f742							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7042  f742
   7043  f742							; a simple guard, than ensures the 7800basic code hasn't
   7044  f742							; spilled into the encryption area...
     2108 bytes left in the 7800basic reserved area.
   7045  f742					      echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   7046  f742				  -	      if	(*>$FF7D)
   7047  f742				  -	      ERR		; abort the assembly
   7048  f742					      endif
   7049  f742							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7050  f742
   7051  f742				  -	      ifconst	DEV
   7052  f742				  -	      ifnconst	ZONEHEIGHT
   7053  f742				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7054  f742				  -	      else
   7055  f742				  -	      if	ZONEHEIGHT = 8
   7056  f742				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7057  f742				  -	      else
   7058  f742				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7059  f742				  -	      endif
   7060  f742				  -	      endif
   7061  f742					      endif
   7062  f742
   7063  f742				  -	      if	START_OF_ROM = .
   7064  f742				  -	      .byte	0
   7065  f742					      endif
   7066  f742				   START_OF_ROM SET	0
   7067  f742
   7068  f742							; FF7E/FF7F contains the 7800basic crc checksum word
   7069  f742
   7070  f742							; FF80 - FFF7 contains the 7800 encryption key 
   7071  f742
   7072  f742					      ifnconst	bankswitchmode
   7073  fff8					      ORG	$FFF8
   7074  fff8				  -	      else
   7075  fff8				  -	      ifconst	ROM128K
   7076  fff8				  -	      ORG	$27FF8
   7077  fff8				  -	      RORG	$FFF8
   7078  fff8				  -	      endif
   7079  fff8				  -	      ifconst	ROM144K
   7080  fff8				  -	      ORG	$27FF8
   7081  fff8				  -	      RORG	$FFF8
   7082  fff8				  -	      endif
   7083  fff8				  -	      ifconst	ROM256K
   7084  fff8				  -	      ORG	$47FF8
   7085  fff8				  -	      RORG	$FFF8
   7086  fff8				  -	      endif
   7087  fff8				  -	      ifconst	ROM272K
   7088  fff8				  -	      ORG	$47FF8
   7089  fff8				  -	      RORG	$FFF8
   7090  fff8				  -	      endif
   7091  fff8				  -	      ifconst	ROM512K
   7092  fff8				  -	      ORG	$87FF8
   7093  fff8				  -	      RORG	$FFF8
   7094  fff8				  -	      endif
   7095  fff8				  -	      ifconst	ROM528K
   7096  fff8				  -	      ORG	$87FF8
   7097  fff8				  -	      RORG	$FFF8
   7098  fff8				  -	      endif
   7099  fff8					      endif
   7100  fff8
   7101  fff8
   7102  fff8		       ff		      .byte.b	$FF	; region verification. $FF=all regions
   7103  fff9		       f7		      .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   7104  fffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   7105  fffa
   7106  fffa							;Vectors
   7107  fffa		       00 f0		      .word.w	NMI
   7108  fffc		       a0 f6		      .word.w	START
   7109  fffe		       6f f0		      .word.w	IRQ
   7110  10000
