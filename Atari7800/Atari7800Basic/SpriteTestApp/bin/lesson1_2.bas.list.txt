------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm LEVEL 1 PASS 3
      1  10000 ????						; MACRO.H
      2  10000 ????
      3  10000 ????						; Based on the 2600 macro.h file.
      4  10000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  10000 ????						; has been adapted to give accurate results on the 7800.
      6  10000 ????
      7  10000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  10000 ????
      9  10000 ????						; Available macros...
     10  10000 ????						;   SLEEP n		 - sleep for n cycles
     11  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  10000 ????
     13  10000 ????						;-------------------------------------------------------------------------------
     14  10000 ????						; SLEEP duration
     15  10000 ????						; Original author: Thomas Jentzsch
     16  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  10000 ????						; useful for code where precise timing is required.
     18  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  10000 ????
     22  10000 ????				       MAC	sleep
     23  10000 ????			    .CYCLES    SET	{1}
     24  10000 ????
     25  10000 ????				       IF	.CYCLES < 2
     26  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  10000 ????				       ERR
     28  10000 ????				       ENDIF
     29  10000 ????
     30  10000 ????				       IF	.CYCLES & 1
     31  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  10000 ????				       nop	$80
     33  10000 ????				       ELSE
     34  10000 ????				       bit	$80
     35  10000 ????				       ENDIF
     36  10000 ????			    .CYCLES    SET	.CYCLES - 3
     37  10000 ????				       ENDIF
     38  10000 ????
     39  10000 ????				       REPEAT	.CYCLES / 2
     40  10000 ????				       nop
     41  10000 ????				       REPEND
     42  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  10000 ????
     44  10000 ????						;-------------------------------------------------------
     45  10000 ????						; SET_POINTER
     46  10000 ????						; Original author: Manuel Rotschkar
     47  10000 ????						;
     48  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     49  10000 ????						;
     50  10000 ????						; Usage: SET_POINTER pointer, address
     51  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     52  10000 ????						;
     53  10000 ????						; Note: Alters the accumulator, NZ flags
     54  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
     55  10000 ????						; IN 2: absolute address
     56  10000 ????
     57  10000 ????				       MAC	set_pointer
     58  10000 ????			    .POINTER   SET	{1}
     59  10000 ????			    .ADDRESS   SET	{2}
     60  10000 ????
     61  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
     62  10000 ????				       STA	.POINTER	; Store in pointer
     63  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
     64  10000 ????				       STA	.POINTER+1	; Store in pointer+1
     65  10000 ????
     66  10000 ????				       ENDM
     67  10000 ????
     68  10000 ????						; EOF
     69  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
     70  10000 ????
     71  10000 ????						; 7800MACRO.H
     72  10000 ????
     73  10000 ????						;-------------------------------------------------------
     74  10000 ????						; BOXCOLLISIONCHECK
     75  10000 ????						; author: Mike Saarna
     76  10000 ????						;
     77  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
     78  10000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
     79  10000 ????						; 
     80  10000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
     81  10000 ????						;
     82  10000 ????
     83  10000 ????				       MAC	boxcollisioncheck
     84  10000 ????			    .boxx1     SET	{1}
     85  10000 ????			    .boxy1     SET	{2}
     86  10000 ????			    .boxw1     SET	{3}
     87  10000 ????			    .boxh1     SET	{4}
     88  10000 ????			    .boxx2     SET	{5}
     89  10000 ????			    .boxy2     SET	{6}
     90  10000 ????			    .boxw2     SET	{7}
     91  10000 ????			    .boxh2     SET	{8}
     92  10000 ????
     93  10000 ????			    .DoXCollisionCheck
     94  10000 ????				       lda	.boxx1	;3
     95  10000 ????				       cmp	.boxx2	;2
     96  10000 ????				       bcs	.X1isbiggerthanX2	;2/3
     97  10000 ????			    .X2isbiggerthanX1
     98  10000 ????				       adc	#.boxw1	;2
     99  10000 ????				       cmp	.boxx2	;3
    100  10000 ????				       bcs	.DoYCollisionCheck	;3/2
    101  10000 ????				       bcc	.noboxcollision	;3
    102  10000 ????			    .X1isbiggerthanX2
    103  10000 ????				       clc		;2
    104  10000 ????				       sbc	#.boxw2	;2
    105  10000 ????				       cmp	.boxx2	;3
    106  10000 ????				       bcs	.noboxcollision	;3/2
    107  10000 ????			    .DoYCollisionCheck
    108  10000 ????				       lda	.boxy1	;3
    109  10000 ????				       cmp	.boxy2	;3
    110  10000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    111  10000 ????			    .Y2isbiggerthanY1
    112  10000 ????				       adc	#.boxh1	;2
    113  10000 ????				       cmp	.boxy2	;3
    114  10000 ????				       jmp	.checkdone	;6 
    115  10000 ????			    .Y1isbiggerthanY2
    116  10000 ????				       clc		;2
    117  10000 ????				       sbc	#.boxh2	;2
    118  10000 ????				       cmp	.boxy2	;3
    119  10000 ????				       bcs	.noboxcollision	;3/2
    120  10000 ????			    .boxcollision
    121  10000 ????				       sec		;2
    122  10000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    123  10000 ????			    .noboxcollision
    124  10000 ????				       clc		;2
    125  10000 ????			    .checkdone
    126  10000 ????
    127  10000 ????				       ENDM
    128  10000 ????
    129  10000 ????				       MAC	median3
    130  10000 ????
    131  10000 ????						; A median filter (for smoothing paddle jitter)
    132  10000 ????						;   this macro takes the current paddle value, compares it to historic
    133  10000 ????						;   values, and replaces the current paddle value with the median.
    134  10000 ????						; 
    135  10000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    136  10000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    137  10000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    138  10000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    139  10000 ????						;	  the previous values, and update with the median value.
    140  10000 ????						;
    141  10000 ????						; returns: CURRENT (modified to contain median value)
    142  10000 ????						;
    143  10000 ????						; author: Mike Saarna (aka RevEng)
    144  10000 ????
    145  10000 ????			    .MedianBytes SET	{1}
    146  10000 ????			    .NewValue  SET	{2}
    147  10000 ????
    148  10000 ????				       lda	#0
    149  10000 ????				       ldy	.NewValue
    150  10000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    151  10000 ????
    152  10000 ????						; build an index from relative size comparisons between our 3 values.
    153  10000 ????				       cpy	.MedianBytes
    154  10000 ????				       rol
    155  10000 ????				       cpy	.MedianBytes+1
    156  10000 ????				       rol
    157  10000 ????				       ldy	.MedianBytes
    158  10000 ????				       cpy	.MedianBytes+1
    159  10000 ????				       rol
    160  10000 ????				       tay
    161  10000 ????
    162  10000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    163  10000 ????				       lda	.MedianBytes,x
    164  10000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    165  10000 ????
    166  10000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    167  10000 ????						; newest byte (.MedianBytes+2) empty for next time.
    168  10000 ????				       lda	.MedianBytes+1
    169  10000 ????				       sta	.MedianBytes
    170  10000 ????				       lda	.MedianBytes+2
    171  10000 ????				       sta	.MedianBytes+1
    172  10000 ????				       ifnconst	MedianOrderLUT
    173  10000 ????				       jmp	MedianOrderLUTend
    174  10000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    175  10000 ????				       .byte	0	; 0  B2 < B0 < B1
    176  10000 ????				       .byte	1	; 1  B2 < B1 < B0
    177  10000 ????				       .byte	2	; 2   impossible 
    178  10000 ????				       .byte	2	; 3  B1 < B2 < B0
    179  10000 ????				       .byte	2	; 4  B0 < B2 < B1
    180  10000 ????				       .byte	2	; 5   impossible 
    181  10000 ????				       .byte	1	; 6  B0 < B1 < B2
    182  10000 ????				       .byte	0	; 7  B1 < B0 < B2
    183  10000 ????			    MedianOrderLUTend
    184  10000 ????				       endif
    185  10000 ????				       ENDM
    186  10000 ????
    187  10000 ????						; EOF
    188  10000 ????						;
    189  10000 ????						; speakjet.inc
    190  10000 ????						;
    191  10000 ????						;
    192  10000 ????						; AtariVox Speech Synth Driver
    193  10000 ????						;
    194  10000 ????						; By Alex Herbert, 2004
    195  10000 ????						;
    196  10000 ????
    197  10000 ????
    198  10000 ????
    199  10000 ????
    200  10000 ????						; Constants
    201  10000 ????
    202  10000 ????
    203  10000 ????		00 01	    SERIAL_OUTMASK equ	$01
    204  10000 ????		00 02	    SERIAL_RDYMASK equ	$02
    205  10000 ????
    206  10000 ????
    207  10000 ????
    208  10000 ????						; Macros
    209  10000 ????
    210  10000 ????				       mac	spkout
    211  10000 ????
    212  10000 ????						; check buffer-full status
    213  10000 ????				       lda	SWCHA
    214  10000 ????				       and	#SERIAL_RDYMASK
    215  10000 ????				       beq	.speech_done
    216  10000 ????
    217  10000 ????						; get next speech byte
    218  10000 ????				       ldy	#$00
    219  10000 ????				       lda	(speech_addr),y
    220  10000 ????
    221  10000 ????						; invert data and check for end of string
    222  10000 ????				       eor	#$ff
    223  10000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    224  10000 ????				       beq	.speech_done
    225  10000 ????				       sta	{1}
    226  10000 ????
    227  10000 ????						; increment speech pointer
    228  10000 ????				       inc	speech_addr
    229  10000 ????				       bne	.incaddr_skip
    230  10000 ????				       inc	speech_addr+1
    231  10000 ????			    .incaddr_skip
    232  10000 ????
    233  10000 ????						; output byte as serial data
    234  10000 ????
    235  10000 ????				       sec		; start bit
    236  10000 ????			    .byteout_loop
    237  10000 ????						; put carry flag into bit 0 of SWACNT, perserving other bits
    238  10000 ????				       lda	SWACNT	; 4
    239  10000 ????				       and	#$fe	; 2 6
    240  10000 ????				       adc	#$00	; 2 8
    241  10000 ????				       sta	SWACNT	; 4 12
    242  10000 ????
    243  10000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    244  10000 ????				       cpy	#$09	; 2 14
    245  10000 ????				       beq	.speech_done	; 2 16
    246  10000 ????				       iny		; 2 18
    247  10000 ????
    248  10000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    249  10000 ????						; to match the original baud rate...
    250  10000 ????						;ldx	  #$07 ; 2600
    251  10000 ????				       ldx	#$0D
    252  10000 ????
    253  10000 ????			    .delay_loop
    254  10000 ????				       dex		; 
    255  10000 ????				       bne	.delay_loop	; 36 54
    256  10000 ????
    257  10000 ????						; shift next data bit into carry
    258  10000 ????				       lsr	{1}	; 5 59
    259  10000 ????
    260  10000 ????						; and loop (branch always taken)
    261  10000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    262  10000 ????
    263  10000 ????			    .speech_done
    264  10000 ????
    265  10000 ????				       endm
    266  10000 ????
    267  10000 ????
    268  10000 ????				       mac	speak
    269  10000 ????
    270  10000 ????				       lda	#<{1}
    271  10000 ????				       sta	speech_addr
    272  10000 ????				       lda	#>{1}
    273  10000 ????				       sta	speech_addr+1
    274  10000 ????
    275  10000 ????				       endm
    276  10000 ????
    277  10000 ????
    278  10000 ????
    279  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    280  10000 ????
    281  10000 ????				       processor	6502
    282  10000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; 7800.h
      4  10000 ????						; Version 1.0, 2019/12/13
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at https://github.com/dasm-assembler/dasm
     10  10000 ????
     11  10000 ????
     12  10000 ????						; ******************** 7800 Hardware Adresses ***************************
     13  10000 ????						;
     14  10000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  10000 ????						;
     16  10000 ????						;	  00 -   1F	TIA REGISTERS
     17  10000 ????						;	  20 -   3F	MARIA REGISTERS
     18  10000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  10000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  10000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  10000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  10000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  10000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  10000 ????						;	 240 -  27F	???
     25  10000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  10000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  10000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  10000 ????						;	 340 -  3FF	???
     29  10000 ????						;	 400 -  47F	unused address space
     30  10000 ????						;	 480 -  4FF	RIOT RAM
     31  10000 ????						;	 500 -  57F	unused address space
     32  10000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  10000 ????						;	 600 - 17FF	unused address space
     34  10000 ????						;	1800 - 203F	RAM
     35  10000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  10000 ????						;	2100 - 213F	RAM
     37  10000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  10000 ????						;	2200 - 27FF	RAM
     39  10000 ????						;	2800 - 2FFF	mirror of 1800-27ff
     40  10000 ????						;	3000 - 3FFF	unused address space
     41  10000 ????						;	4000 - FF7F	potential cartridge address space
     42  10000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  10000 ????						;	FFFA - FFFF	6502 VECTORS
     44  10000 ????
     45  10000 ????
     46  10000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  10000 ????
     48  10000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  10000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  10000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     51  10000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     52  10000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     53  10000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     54  10000 ????
     55  10000 ????						; ** some common alternate names for INPT0/1/2/3
     56  10000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     57  10000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     58  10000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     59  10000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     60  10000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     61  10000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     62  10000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     63  10000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     64  10000 ????
     65  10000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     66  10000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     67  10000 ????
     68  10000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     69  10000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     70  10000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     71  10000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     72  10000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     73  10000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     74  10000 ????
     75  10000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     76  10000 ????
     77  10000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     78  10000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     79  10000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     80  10000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     81  10000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     82  10000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     83  10000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     84  10000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     85  10000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     86  10000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     87  10000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     88  10000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     89  10000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     90  10000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     91  10000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     92  10000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     93  10000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     94  10000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     95  10000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     96  10000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     97  10000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
     98  10000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
     99  10000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    100  10000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    101  10000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    102  10000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    103  10000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    104  10000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    105  10000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    106  10000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    107  10000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    108  10000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    109  10000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    110  10000 ????
    111  10000 ????
    112  10000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    113  10000 ????
    114  10000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    115  10000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    116  10000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    117  10000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    118  10000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    119  10000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    120  10000 ????
    121  10000 ????		02 84	    INTIM      =	$284	;Iterval Timer Read			       read-only
    122  10000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    123  10000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    124  10000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    125  10000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    126  10000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    127  10000 ????
    128  10000 ????						;XM
    129  10000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    130  10000 ????		04 70	    XCTRL1     =	$470
    131  10000 ????		04 78	    XCTRL2     =	$478
    132  10000 ????		04 7c	    XCTRL3     =	$47c
    133  10000 ????		04 71	    XCTRL4     =	$471
    134  10000 ????		04 72	    XCTRL5     =	$472
    135  10000 ????
    136  10000 ????						; Pokey register relative locations, since its base may be different
    137  10000 ????						; depending on the hardware.
    138  10000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    139  10000 ????		00 01	    PAUDC0     =	$1
    140  10000 ????		00 02	    PAUDF1     =	$2
    141  10000 ????		00 03	    PAUDC1     =	$3
    142  10000 ????		00 04	    PAUDF2     =	$4
    143  10000 ????		00 05	    PAUDC2     =	$5
    144  10000 ????		00 06	    PAUDF3     =	$6
    145  10000 ????		00 07	    PAUDC3     =	$7
    146  10000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    147  10000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    148  10000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    zonebg80x16_16_mode =	$00
      7  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
      8  10000 ????		00 14	    zonebg80x16_16_width =	$14
      9  10000 ????		00 00	    g16x16_4color4_mode =	$00
     10  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     11  10000 ????		00 04	    g16x16_4color4_width =	$04
     12  10000 ????		00 00	    g16x16_4color3_mode =	$00
     13  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     14  10000 ????		00 04	    g16x16_4color3_width =	$04
     15  10000 ????		00 00	    g16x16_4color2_mode =	$00
     16  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     17  10000 ????		00 04	    g16x16_4color2_width =	$04
     18  10000 ????		00 00	    g16x16_4color_mode =	$00
     19  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     20  10000 ????		00 04	    g16x16_4color_width =	$04
     21  10000 ????		00 0f	    font_color1 =	$0f
     22  10000 ????		00 00	    font_color0 =	$00
     23  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
     24  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
     25  10000 ????		00 00	    g16x16_4color4_color1 =	0
     26  10000 ????		00 00	    g16x16_4color4_color0 =	$00
     27  10000 ????		00 91	    g16x16_4color3_color1 =	$91
     28  10000 ????		00 00	    g16x16_4color3_color0 =	$00
     29  10000 ????		00 00	    g16x16_4color2_color3 =	0
     30  10000 ????		00 91	    g16x16_4color2_color2 =	$91
     31  10000 ????		00 91	    g16x16_4color2_color1 =	$91
     32  10000 ????		00 00	    g16x16_4color2_color0 =	$00
     33  10000 ????		00 a8	    g16x16_4color_color3 =	$a8
     34  10000 ????		00 91	    g16x16_4color_color2 =	$91
     35  10000 ????		00 91	    g16x16_4color_color1 =	$91
     36  10000 ????		00 00	    g16x16_4color_color0 =	$00
     37  10000 ????		00 01	    ROM48K     =	1
     38  10000 ????		00 01	    plotvalueonscreen =	1
     39  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  10000 ????
      7  10000 ????						;************ 7800 overall RAM map **************
      8  10000 ????
      9  10000 ????						;	   40-FF	 zero page RAM
     10  10000 ????						;	  140-1FF	 RAM (stack)
     11  10000 ????						;	 1800-203F	 RAM
     12  10000 ????						;	 2100-213F	 RAM
     13  10000 ????						;	 2200-27FF	 RAM
     14  10000 ????
     15  10000 ????						;************ 7800basic RAM usage map **************
     16  10000 ????
     17  10000 ????						;	   40-FF	 numerous defines, listed below
     18  10000 ????						;	  140-1FF	 RAM (stack)
     19  10000 ????
     20  10000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  10000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  10000 ????
     23  10000 ????						;	 2000-203F	 Reserved
     24  10000 ????						;	 2100-213F	 Reserved
     25  10000 ????						;	 2200-27FF	 Free
     26  10000 ????
     27  10000 ????		1f e0	    eeprombuffer =	$1FE0
     28  10000 ????		18 00	    DLLMEM     =	$1800
     29  10000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  10000 ????
     31  10000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  10000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  10000 ????				       else
     34  10000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  10000 ????				       endif
     36  10000 ????
     37  10000 ????
     38  10000 ????		21 00	    pausestate =	$2100
     39  10000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  10000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  10000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  10000 ????		21 04	    currentbank =	$2104
     43  10000 ????
     44  10000 ????		21 05	    currentrambank =	$2105
     45  10000 ????		21 06	    charactermode =	$2106
     46  10000 ????		21 07	    sCTRL      =	$2107
     47  10000 ????		21 08	    pokeydetected =	$2108
     48  10000 ????		21 09	    paldetected =	$2109
     49  10000 ????		21 0a	    avoxdetected =	$210A
     50  10000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  10000 ????
     52  10000 ????		21 0c	    hsdevice   =	$210C
     53  10000 ????		21 0d	    hsdifficulty =	$210D
     54  10000 ????		21 0e	    hserror    =	$210E
     55  10000 ????		21 0f	    hsgameslot =	$210F
     56  10000 ????		21 10	    hsnewscoreline =	$2110
     57  10000 ????		21 11	    hsnewscorerank =	$2111
     58  10000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  10000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  10000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  10000 ????
     62  10000 ????		21 31	    ssCTRL     =	$2131
     63  10000 ????		21 32	    ssCHARBASE =	$2132
     64  10000 ????		21 33	    hsdisplaymode =	$2133
     65  10000 ????		21 34	    gamedifficulty =	$2134
     66  10000 ????		21 35	    hsinitialpos =	$2135
     67  10000 ????		21 36	    hsinitialhold =	$2136
     68  10000 ????		21 37	    hscursorx  =	$2137
     69  10000 ????		21 38	    hsjoydebounce =	$2138
     70  10000 ????		21 39	    hsswcha    =	$2139
     71  10000 ????		21 3a	    hsinpt1    =	$213A
     72  10000 ????		21 3b	    hscolorchaseindex =	$213B
     73  10000 ????		21 3c	    visibleDLLstart =	$213C
     74  10000 ????		21 3d	    overscanDLLstart =	$213D
     75  10000 ????		21 3e	    frameslost =	$213E
     76  10000 ????
     77  10000 ????
     78  10000 ????		00 40	    rand       =	$40
     79  10000 ????		00 41	    rand16     =	$41
     80  10000 ????		00 42	    temp1      =	$42
     81  10000 ????		00 43	    temp2      =	$43
     82  10000 ????		00 44	    temp3      =	$44
     83  10000 ????		00 45	    temp4      =	$45
     84  10000 ????		00 46	    temp5      =	$46
     85  10000 ????		00 47	    temp6      =	$47
     86  10000 ????		00 48	    temp7      =	$48
     87  10000 ????		00 49	    temp8      =	$49
     88  10000 ????		00 4a	    temp9      =	$4a
     89  10000 ????
     90  10000 ????		00 4b	    pokeybase  =	$4b
     91  10000 ????		00 4b	    pokeybaselo =	$4b
     92  10000 ????		00 4c	    pokeybasehi =	$4c
     93  10000 ????
     94  10000 ????		00 4d	    visibleover =	$4d
     95  10000 ????
     96  10000 ????		00 4e	    sfx1pointlo =	$4e
     97  10000 ????		00 4f	    sfx2pointlo =	$4f
     98  10000 ????		00 50	    sfx1pointhi =	$50
     99  10000 ????		00 51	    sfx2pointhi =	$51
    100  10000 ????
    101  10000 ????		00 52	    sfx1priority =	$52
    102  10000 ????		00 53	    sfx2priority =	$53
    103  10000 ????		00 54	    sfx1poffset =	$54
    104  10000 ????		00 55	    sfx2poffset =	$55
    105  10000 ????
    106  10000 ????		00 56	    sfx1frames =	$56
    107  10000 ????		00 57	    sfx2frames =	$57
    108  10000 ????		00 58	    sfx1tick   =	$58
    109  10000 ????		00 59	    sfx2tick   =	$59
    110  10000 ????
    111  10000 ????		00 5a	    tempmath   =	$5a
    112  10000 ????
    113  10000 ????		00 5b	    pokey1pointlo =	$5b
    114  10000 ????		00 5c	    pokey1pointhi =	$5c
    115  10000 ????		00 5d	    pokey2pointlo =	$5d
    116  10000 ????		00 5e	    pokey2pointhi =	$5e
    117  10000 ????		00 5f	    pokey3pointlo =	$5f
    118  10000 ????		00 60	    pokey3pointhi =	$60
    119  10000 ????		00 61	    pokey4pointlo =	$61
    120  10000 ????		00 62	    pokey4pointhi =	$62
    121  10000 ????
    122  10000 ????		00 63	    dlpnt      =	$63	; to $64
    123  10000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    124  10000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    125  10000 ????
    126  10000 ????		00 9f	    speech_addr =	$9f
    127  10000 ????		00 a0	    speech_addr_hi =	$a0
    128  10000 ????
    129  10000 ????		00 a1	    HSGameTableLo =	$a1
    130  10000 ????		00 a2	    HSGameTableHi =	$a2
    131  10000 ????		00 a3	    HSVoxHi    =	$a3
    132  10000 ????		00 a4	    HSVoxLo    =	$a4
    133  10000 ????
    134  10000 ????						;channel pointers
    135  10000 ????
    136  10000 ????		00 a5	    songchannel1layer1lo =	$a5
    137  10000 ????		00 a6	    songchannel2layer1lo =	$a6
    138  10000 ????		00 a7	    songchannel3layer1lo =	$a7
    139  10000 ????		00 a8	    songchannel4layer1lo =	$a8
    140  10000 ????
    141  10000 ????		00 a9	    songchannel1layer2lo =	$a9
    142  10000 ????		00 aa	    songchannel2layer2lo =	$aA
    143  10000 ????		00 ab	    songchannel3layer2lo =	$aB
    144  10000 ????		00 ac	    songchannel4layer2lo =	$aC
    145  10000 ????
    146  10000 ????		00 ad	    songchannel1layer3lo =	$aD
    147  10000 ????		00 ae	    songchannel2layer3lo =	$aE
    148  10000 ????		00 af	    songchannel3layer3lo =	$aF
    149  10000 ????		00 b0	    songchannel4layer3lo =	$b0
    150  10000 ????
    151  10000 ????		00 b1	    songchannel1layer1hi =	$b1
    152  10000 ????		00 b2	    songchannel2layer1hi =	$b2
    153  10000 ????		00 b3	    songchannel3layer1hi =	$b3
    154  10000 ????		00 b4	    songchannel4layer1hi =	$b4
    155  10000 ????
    156  10000 ????		00 b5	    songchannel1layer2hi =	$b5
    157  10000 ????		00 b6	    songchannel2layer2hi =	$b6
    158  10000 ????		00 b7	    songchannel3layer2hi =	$b7
    159  10000 ????		00 b8	    songchannel4layer2hi =	$b8
    160  10000 ????
    161  10000 ????		00 b9	    songchannel1layer3hi =	$b9
    162  10000 ????		00 ba	    songchannel2layer3hi =	$bA
    163  10000 ????		00 bb	    songchannel3layer3hi =	$bB
    164  10000 ????		00 bc	    songchannel4layer3hi =	$bC
    165  10000 ????
    166  10000 ????		00 bd	    songdatalo =	$bd
    167  10000 ????		00 be	    songdatahi =	$be
    168  10000 ????
    169  10000 ????		00 bf	    inactivechannelcount =	$bf
    170  10000 ????
    171  10000 ????
    172  10000 ????		00 c0	    songchannel1transpose =	$c0
    173  10000 ????		00 c1	    songchannel2transpose =	$c1
    174  10000 ????		00 c2	    songchannel3transpose =	$c2
    175  10000 ????		00 c3	    songchannel4transpose =	$c3
    176  10000 ????
    177  10000 ????		00 c4	    songstackindex =	$c4
    178  10000 ????
    179  10000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  10000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  10000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  10000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  10000 ????
    184  10000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  10000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  10000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  10000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  10000 ????
    189  10000 ????		00 cd	    sfx1notedata =	$cd
    190  10000 ????		00 ce	    sfx2notedata =	$ce
    191  10000 ????
    192  10000 ????		00 cf	    songloops  =	$cf
    193  10000 ????
    194  10000 ????		00 d0	    songpointerlo =	$D0
    195  10000 ????		00 d1	    songpointerhi =	$D1
    196  10000 ????
    197  10000 ????		00 d2	    voxlock    =	$D2
    198  10000 ????		00 d3	    voxqueuesize =	$D3
    199  10000 ????
    200  10000 ????		00 d4	    vblankroutines =	$D4
    201  10000 ????
    202  10000 ????		00 d5	    doublebufferstate =	$D5
    203  10000 ????		00 d6	    doublebufferdloffset =	$D6
    204  10000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  10000 ????
    206  10000 ????		00 d8	    inttemp1   =	$D8
    207  10000 ????		00 d9	    inttemp2   =	$D9
    208  10000 ????		00 da	    inttemp3   =	$DA
    209  10000 ????		00 db	    inttemp4   =	$DB
    210  10000 ????		00 dc	    inttemp5   =	$DC
    211  10000 ????		00 dd	    inttemp6   =	$DD
    212  10000 ????
    213  10000 ????		00 de	    sfxschedulelock =	$DE
    214  10000 ????		00 df	    sfxschedulemissed =	$DF
    215  10000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  10000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  10000 ????		00 e2	    sfxpitchoffset =	$E2
    218  10000 ????		00 e3	    sfxnoteindex =	$E3
    219  10000 ????
    220  10000 ????		00 e4	    CTLSWAs    =	$E4
    221  10000 ????		00 e5	    CTLSWBs    =	$E5
    222  10000 ????
    223  10000 ????		00 e6	    A	       =	$e6
    224  10000 ????		00 e6	    a	       =	$e6
    225  10000 ????		00 e7	    B	       =	$e7
    226  10000 ????		00 e7	    b	       =	$e7
    227  10000 ????		00 e8	    C	       =	$e8
    228  10000 ????		00 e8	    c	       =	$e8
    229  10000 ????		00 e9	    D	       =	$e9
    230  10000 ????		00 e9	    d	       =	$e9
    231  10000 ????		00 ea	    E	       =	$ea
    232  10000 ????		00 ea	    e	       =	$ea
    233  10000 ????		00 eb	    F	       =	$eb
    234  10000 ????		00 eb	    f	       =	$eb
    235  10000 ????		00 ec	    G	       =	$ec
    236  10000 ????		00 ec	    g	       =	$ec
    237  10000 ????		00 ed	    H	       =	$ed
    238  10000 ????		00 ed	    h	       =	$ed
    239  10000 ????		00 ee	    I	       =	$ee
    240  10000 ????		00 ee	    i	       =	$ee
    241  10000 ????		00 ef	    J	       =	$ef
    242  10000 ????		00 ef	    j	       =	$ef
    243  10000 ????		00 f0	    K	       =	$f0
    244  10000 ????		00 f0	    k	       =	$f0
    245  10000 ????		00 f1	    L	       =	$f1
    246  10000 ????		00 f1	    l	       =	$f1
    247  10000 ????		00 f2	    M	       =	$f2
    248  10000 ????		00 f2	    m	       =	$f2
    249  10000 ????		00 f3	    N	       =	$f3
    250  10000 ????		00 f3	    n	       =	$f3
    251  10000 ????		00 f4	    O	       =	$f4
    252  10000 ????		00 f4	    o	       =	$f4
    253  10000 ????		00 f5	    P	       =	$f5
    254  10000 ????		00 f5	    p	       =	$f5
    255  10000 ????		00 f6	    Q	       =	$f6
    256  10000 ????		00 f6	    q	       =	$f6
    257  10000 ????		00 f7	    R	       =	$f7
    258  10000 ????		00 f7	    r	       =	$f7
    259  10000 ????		00 f8	    S	       =	$f8
    260  10000 ????		00 f8	    s	       =	$f8
    261  10000 ????		00 f9	    T	       =	$f9
    262  10000 ????		00 f9	    t	       =	$f9
    263  10000 ????		00 fa	    U	       =	$fa
    264  10000 ????		00 fa	    u	       =	$fa
    265  10000 ????		00 fb	    V	       =	$fb
    266  10000 ????		00 fb	    v	       =	$fb
    267  10000 ????		00 fc	    W	       =	$fc
    268  10000 ????		00 fc	    w	       =	$fc
    269  10000 ????		00 fd	    X	       =	$fd
    270  10000 ????		00 fd	    x	       =	$fd
    271  10000 ????		00 fe	    Y	       =	$fe
    272  10000 ????		00 fe	    y	       =	$fe
    273  10000 ????		00 ff	    Z	       =	$ff
    274  10000 ????		00 ff	    z	       =	$ff
    275  10000 ????
    276  10000 ????						; var0-var99 variables use the top of the stack
    277  10000 ????		01 40	    var0       =	$140
    278  10000 ????		01 41	    var1       =	$141
    279  10000 ????		01 42	    var2       =	$142
    280  10000 ????		01 43	    var3       =	$143
    281  10000 ????		01 44	    var4       =	$144
    282  10000 ????		01 45	    var5       =	$145
    283  10000 ????		01 46	    var6       =	$146
    284  10000 ????		01 47	    var7       =	$147
    285  10000 ????		01 48	    var8       =	$148
    286  10000 ????		01 49	    var9       =	$149
    287  10000 ????		01 4a	    var10      =	$14a
    288  10000 ????		01 4b	    var11      =	$14b
    289  10000 ????		01 4c	    var12      =	$14c
    290  10000 ????		01 4d	    var13      =	$14d
    291  10000 ????		01 4e	    var14      =	$14e
    292  10000 ????		01 4f	    var15      =	$14f
    293  10000 ????		01 50	    var16      =	$150
    294  10000 ????		01 51	    var17      =	$151
    295  10000 ????		01 52	    var18      =	$152
    296  10000 ????		01 53	    var19      =	$153
    297  10000 ????		01 54	    var20      =	$154
    298  10000 ????		01 55	    var21      =	$155
    299  10000 ????		01 56	    var22      =	$156
    300  10000 ????		01 57	    var23      =	$157
    301  10000 ????		01 58	    var24      =	$158
    302  10000 ????		01 59	    var25      =	$159
    303  10000 ????		01 5a	    var26      =	$15a
    304  10000 ????		01 5b	    var27      =	$15b
    305  10000 ????		01 5c	    var28      =	$15c
    306  10000 ????		01 5d	    var29      =	$15d
    307  10000 ????		01 5e	    var30      =	$15e
    308  10000 ????		01 5f	    var31      =	$15f
    309  10000 ????		01 60	    var32      =	$160
    310  10000 ????		01 61	    var33      =	$161
    311  10000 ????		01 62	    var34      =	$162
    312  10000 ????		01 63	    var35      =	$163
    313  10000 ????		01 64	    var36      =	$164
    314  10000 ????		01 65	    var37      =	$165
    315  10000 ????		01 66	    var38      =	$166
    316  10000 ????		01 67	    var39      =	$167
    317  10000 ????		01 68	    var40      =	$168
    318  10000 ????		01 69	    var41      =	$169
    319  10000 ????		01 6a	    var42      =	$16a
    320  10000 ????		01 6b	    var43      =	$16b
    321  10000 ????		01 6c	    var44      =	$16c
    322  10000 ????		01 6d	    var45      =	$16d
    323  10000 ????		01 6e	    var46      =	$16e
    324  10000 ????		01 6f	    var47      =	$16f
    325  10000 ????		01 70	    var48      =	$170
    326  10000 ????		01 71	    var49      =	$171
    327  10000 ????		01 72	    var50      =	$172
    328  10000 ????		01 73	    var51      =	$173
    329  10000 ????		01 74	    var52      =	$174
    330  10000 ????		01 75	    var53      =	$175
    331  10000 ????		01 76	    var54      =	$176
    332  10000 ????		01 77	    var55      =	$177
    333  10000 ????		01 78	    var56      =	$178
    334  10000 ????		01 79	    var57      =	$179
    335  10000 ????		01 7a	    var58      =	$17a
    336  10000 ????		01 7b	    var59      =	$17b
    337  10000 ????		01 7c	    var60      =	$17c
    338  10000 ????		01 7d	    var61      =	$17d
    339  10000 ????		01 7e	    var62      =	$17e
    340  10000 ????		01 7f	    var63      =	$17f
    341  10000 ????		01 80	    var64      =	$180
    342  10000 ????		01 81	    var65      =	$181
    343  10000 ????		01 82	    var66      =	$182
    344  10000 ????		01 83	    var67      =	$183
    345  10000 ????		01 84	    var68      =	$184
    346  10000 ????		01 85	    var69      =	$185
    347  10000 ????		01 86	    var70      =	$186
    348  10000 ????		01 87	    var71      =	$187
    349  10000 ????		01 88	    var72      =	$188
    350  10000 ????		01 89	    var73      =	$189
    351  10000 ????		01 8a	    var74      =	$18a
    352  10000 ????		01 8b	    var75      =	$18b
    353  10000 ????		01 8c	    var76      =	$18c
    354  10000 ????		01 8d	    var77      =	$18d
    355  10000 ????		01 8e	    var78      =	$18e
    356  10000 ????		01 8f	    var79      =	$18f
    357  10000 ????		01 90	    var80      =	$190
    358  10000 ????		01 91	    var81      =	$191
    359  10000 ????		01 92	    var82      =	$192
    360  10000 ????		01 93	    var83      =	$193
    361  10000 ????		01 94	    var84      =	$194
    362  10000 ????		01 95	    var85      =	$195
    363  10000 ????		01 96	    var86      =	$196
    364  10000 ????		01 97	    var87      =	$197
    365  10000 ????		01 98	    var88      =	$198
    366  10000 ????		01 99	    var89      =	$199
    367  10000 ????		01 9a	    var90      =	$19a
    368  10000 ????		01 9b	    var91      =	$19b
    369  10000 ????		01 9c	    var92      =	$19c
    370  10000 ????		01 9d	    var93      =	$19d
    371  10000 ????		01 9e	    var94      =	$19e
    372  10000 ????		01 9f	    var95      =	$19f
    373  10000 ????		01 a0	    var96      =	$1a0
    374  10000 ????		01 a1	    var97      =	$1a1
    375  10000 ????		01 a2	    var98      =	$1a2
    376  10000 ????		01 a3	    var99      =	$1a3
    377  10000 ????
    378  10000 ????		01 a4	    framecounter =	$1A4
    379  10000 ????		01 a5	    countdownseconds =	$1A5
    380  10000 ????		01 a6	    score0     =	$1A6	; $1A7 $1A8
    381  10000 ????		01 a9	    score1     =	$1A9	; $1AA $1AB
    382  10000 ????		01 ac	    pausebuttonflag =	$1AC
    383  10000 ????		01 ad	    valbufend  =	$1AD
    384  10000 ????		01 ae	    valbufendsave =	$1AE
    385  10000 ????		01 af	    finescrollx =	$1AF
    386  10000 ????		01 b0	    finescrolly =	$1B0
    387  10000 ????		01 b1	    joybuttonmode =	$1B1	; used to track any joysticks that were changed to one-button mode
    388  10000 ????		01 b2	    interruptindex =	$1B2
    389  10000 ????		01 b3	    tempavox   =	$1B3
    390  10000 ????		01 b4	    doublebufferminimumframetarget =	$1B4
    391  10000 ????		01 b5	    doublebufferminimumframeindex =	$1B5
    392  10000 ????		01 b6	    pausedisable =	$1B6
    393  10000 ????		01 b7	    XCTRL1s    =	$1B7
    394  10000 ????		01 b8	    spritecount =	$1B8
    395  10000 ????		01 b9	    avoxenable =	$1B9
    396  10000 ????
    397  10000 ????		01 ba	    pokey1frames =	$1BA
    398  10000 ????		01 bb	    pokey1tick =	$1BB
    399  10000 ????		01 bc	    pokey2frames =	$1BC
    400  10000 ????		01 bd	    pokey2tick =	$1BD
    401  10000 ????		01 be	    pokey3frames =	$1BE
    402  10000 ????		01 bf	    pokey3tick =	$1BF
    403  10000 ????		01 c0	    pokey4frames =	$1C0
    404  10000 ????		01 c1	    pokey4tick =	$1C1
    405  10000 ????		01 c2	    pokey1priority =	$1C2
    406  10000 ????		01 c3	    pokey1offset =	$1C3
    407  10000 ????		01 c4	    pokey2priority =	$1C4
    408  10000 ????		01 c5	    pokey2offset =	$1C5
    409  10000 ????		01 c6	    pokey3priority =	$1C6
    410  10000 ????		01 c7	    pokey3offset =	$1C7
    411  10000 ????		01 c8	    pokey4priority =	$1C8
    412  10000 ????		01 c9	    pokey4offset =	$1C9
    413  10000 ????
    414  10000 ????		01 ca	    songtempo  =	$1CA
    415  10000 ????		01 cb	    songtick   =	$1CB
    416  10000 ????
    417  10000 ????		01 cc	    songchannel1layer1loops =	$1CC
    418  10000 ????		01 cd	    songchannel2layer1loops =	$1CD
    419  10000 ????		01 ce	    songchannel3layer1loops =	$1CE
    420  10000 ????		01 cf	    songchannel4layer1loops =	$1CF
    421  10000 ????
    422  10000 ????		01 d0	    songchannel1layer2loops =	$1D0
    423  10000 ????		01 d1	    songchannel2layer2loops =	$1D1
    424  10000 ????		01 d2	    songchannel3layer2loops =	$1D2
    425  10000 ????		01 d3	    songchannel4layer2loops =	$1D3
    426  10000 ????
    427  10000 ????		01 d4	    songchannel1layer3loops =	$1D4
    428  10000 ????		01 d5	    songchannel2layer3loops =	$1D5
    429  10000 ????		01 d6	    songchannel3layer3loops =	$1D6
    430  10000 ????		01 d7	    songchannel4layer3loops =	$1D7
    431  10000 ????
    432  10000 ????		01 d8	    songchannel1busywait =	$1D8
    433  10000 ????		01 d9	    songchannel2busywait =	$1D9
    434  10000 ????		01 da	    songchannel3busywait =	$1DA
    435  10000 ????		01 db	    songchannel4busywait =	$1DB
    436  10000 ????
    437  10000 ????		01 dc	    songchannel1stackdepth =	$1DC
    438  10000 ????		01 dd	    songchannel2stackdepth =	$1DD
    439  10000 ????		01 de	    songchannel3stackdepth =	$1DE
    440  10000 ????		01 df	    songchannel4stackdepth =	$1DF
    441  10000 ????
    442  10000 ????		01 e0	    palframes  =	$1E0
    443  10000 ????		01 e1	    palfastframe =	$1E1
    444  10000 ????
    445  10000 ????		01 e2	    port0control =	$1E2
    446  10000 ????		01 e3	    port1control =	$1E3
    447  10000 ????
    448  10000 ????						; port#control values...
    449  10000 ????						;	1 = proline
    450  10000 ????						;	2 = lightgun
    451  10000 ????						;	3 = paddle
    452  10000 ????						;	4 = trakball
    453  10000 ????						;	5 = vcs joystick
    454  10000 ????						;	6 = driving
    455  10000 ????						;	7 = keypad
    456  10000 ????						;	8 = st mouse/cx80
    457  10000 ????						;	9 = amiga mouse
    458  10000 ????						;     10 = atarivox
    459  10000 ????
    460  10000 ????						; controller 0 data...
    461  10000 ????		01 e4	    paddleposition0 =	$1E4
    462  10000 ????		01 e4	    keypadmatrix0a =	$1E4
    463  10000 ????		01 e4	    drivingposition0 =	$1E4
    464  10000 ????		01 e4	    trakballx0 =	$1E4
    465  10000 ????		01 e4	    mousex0    =	$1E4
    466  10000 ????		01 e4	    lighttgunx0 =	$1E4
    467  10000 ????
    468  10000 ????						; controller 1 data...
    469  10000 ????		01 e5	    paddleposition2 =	$1E5
    470  10000 ????		01 e5	    keypadmatrix1a =	$1E5
    471  10000 ????		01 e5	    drivingposition1 =	$1E5
    472  10000 ????		01 e5	    trakballx1 =	$1E5
    473  10000 ????		01 e5	    mousex1    =	$1E5
    474  10000 ????		01 e5	    lightgunx1 =	$1E5
    475  10000 ????
    476  10000 ????						; controller 0 altdata...
    477  10000 ????		01 e6	    paddleposition1 =	$1E6
    478  10000 ????		01 e6	    keypadmatrix0b =	$1E6
    479  10000 ????		01 e6	    trakbally0 =	$1E6
    480  10000 ????		01 e6	    mousey0    =	$1E6
    481  10000 ????		01 e6	    lightguny0 =	$1E6
    482  10000 ????
    483  10000 ????						; controller 1 altdata...
    484  10000 ????		01 e7	    paddleposition3 =	$1E7
    485  10000 ????		01 e7	    keypadmatrix1b =	$1E7
    486  10000 ????		01 e7	    trakbally1 =	$1E7
    487  10000 ????		01 e7	    mousey1    =	$1E7
    488  10000 ????		01 e7	    lightguny1 =	$1E7
    489  10000 ????
    490  10000 ????						; controller state save. for trakball state+dir codes, rotary position codes
    491  10000 ????		01 e8	    controller0statesave =	$1E8
    492  10000 ????		01 e8	    mousecodex0 =	$1E8
    493  10000 ????		01 e8	    trakballcodex0 =	$1E8
    494  10000 ????		01 e8	    keypadmatrix0c =	$1E8
    495  10000 ????
    496  10000 ????		01 e9	    controller1statesave =	$1E9
    497  10000 ????		01 e9	    mousecodex1 =	$1E9
    498  10000 ????		01 e9	    trakballcodex1 =	$1E9
    499  10000 ????		01 e9	    keypadmatrix1c =	$1E9
    500  10000 ????
    501  10000 ????		01 ea	    keypadmatrix0d =	$1EA
    502  10000 ????		01 ea	    mousecodey0 =	$1EA
    503  10000 ????		01 ea	    trakballcodey0 =	$1EA
    504  10000 ????
    505  10000 ????		01 eb	    keypadmatrix1d =	$1EB
    506  10000 ????		01 eb	    mousecodey1 =	$1EB
    507  10000 ????		01 eb	    trakballcodey1 =	$1EB
    508  10000 ????
    509  10000 ????		01 ec	    genesisdetected0 =	$1EC
    510  10000 ????		01 ed	    genesisdetected1 =	$1ED
    511  10000 ????
    512  10000 ????						; $1EE - $1FF reserved for stack
    513  10000 ????
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 00	    font_mode  =	$00
      4  10000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  10000 ????		00 35	    font_width =	$35
      6  10000 ????		00 00	    zonebg80x16_16_mode =	$00
      7  10000 ????		00 0c	    zonebg80x16_16_width_twoscompliment =	$0c
      8  10000 ????		00 14	    zonebg80x16_16_width =	$14
      9  10000 ????		00 00	    g16x16_4color4_mode =	$00
     10  10000 ????		00 1c	    g16x16_4color4_width_twoscompliment =	$1c
     11  10000 ????		00 04	    g16x16_4color4_width =	$04
     12  10000 ????		00 00	    g16x16_4color3_mode =	$00
     13  10000 ????		00 1c	    g16x16_4color3_width_twoscompliment =	$1c
     14  10000 ????		00 04	    g16x16_4color3_width =	$04
     15  10000 ????		00 00	    g16x16_4color2_mode =	$00
     16  10000 ????		00 1c	    g16x16_4color2_width_twoscompliment =	$1c
     17  10000 ????		00 04	    g16x16_4color2_width =	$04
     18  10000 ????		00 00	    g16x16_4color_mode =	$00
     19  10000 ????		00 1c	    g16x16_4color_width_twoscompliment =	$1c
     20  10000 ????		00 04	    g16x16_4color_width =	$04
     21  10000 ????		00 0f	    font_color1 =	$0f
     22  10000 ????		00 00	    font_color0 =	$00
     23  10000 ????		00 08	    zonebg80x16_16_color1 =	$08
     24  10000 ????		00 00	    zonebg80x16_16_color0 =	$00
     25  10000 ????		00 00	    g16x16_4color4_color1 =	0
     26  10000 ????		00 00	    g16x16_4color4_color0 =	$00
     27  10000 ????		00 91	    g16x16_4color3_color1 =	$91
     28  10000 ????		00 00	    g16x16_4color3_color0 =	$00
     29  10000 ????		00 00	    g16x16_4color2_color3 =	0
     30  10000 ????		00 91	    g16x16_4color2_color2 =	$91
     31  10000 ????		00 91	    g16x16_4color2_color1 =	$91
     32  10000 ????		00 00	    g16x16_4color2_color0 =	$00
     33  10000 ????		00 a8	    g16x16_4color_color3 =	$a8
     34  10000 ????		00 91	    g16x16_4color_color2 =	$91
     35  10000 ????		00 91	    g16x16_4color_color1 =	$91
     36  10000 ????		00 00	    g16x16_4color_color0 =	$00
     37  10000 ????		00 01	    ROM48K     =	1
     38  10000 ????		00 01	    plotvalueonscreen =	1
     39  10000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
    285  10000 ????
    286  10000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    287  10000 ????						; For more BEAD executable info, check out the spec...
    288  10000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    289  10000 ????
    290  10000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    291  10000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    292  10000 ????
    293  10000 ????		00 40	    BDHSC      =	%01000000
    294  10000 ????		00 20	    BDYM       =	%00100000
    295  10000 ????		00 10	    BDPOKEY    =	%00010000
    296  10000 ????		00 08	    BDROF      =	%00001000
    297  10000 ????		00 00	    BD16K      =	%00000000
    298  10000 ????		00 01	    BD32K      =	%00000001
    299  10000 ????		00 02	    BD48K      =	%00000010
    300  10000 ????		00 05	    BD1800     =	%00000101
    301  10000 ????		00 06	    BD4000     =	%00000110
    302  10000 ????
    303  10000 ????			   -	       ifconst	ROM16K
    304  10000 ????			   -BEADHEADER =	1
    305  10000 ????				       endif
    306  10000 ????			   -	       ifconst	ROM32K
    307  10000 ????			   -BEADHEADER =	1
    308  10000 ????				       endif
    309  10000 ????				       ifconst	ROM48K
    310  10000 ????		00 01	    BEADHEADER =	1
    311  10000 ????				       endif
    312  10000 ????
    313  10000 ????				       ifconst	BEADHEADER
    314  10000 ????			    BEADHARDWARE SET	0
    315  10000 ????			   -	       ifconst	ROM16K
    316  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    317  10000 ????				       endif
    318  10000 ????			   -	       ifconst	ROM32K
    319  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    320  10000 ????				       endif
    321  10000 ????				       ifconst	ROM48K
    322  10000 ????			    BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    323  10000 ????				       endif
    324  10000 ????			   -	       ifconst	pokeysupport
    325  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    326  10000 ????				       endif
    327  10000 ????			   -	       ifconst	HSSUPPORT
    328  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    329  10000 ????				       endif
    330  10000 ????				       endif
    331  10000 ????
    332  10000 ????						;start address of cart...
    333  10000 ????				       ifconst	ROM48K
    334  4000					      ORG	$4000,0
    335  4000					      ifconst	BEADHEADER
    336  4000		       be ad 02 	      .byte.b	$BE,$AD,BEADHARDWARE
    337  4003					      ifconst	GAMEDESCRIPTIONSET
    338  4003		       18		      CLC
    339  4004		       90 0a		      BCC	_SKIPDESCRIPTION
    340  4006		       54 65 73 74*	      .byte.b	GAMEDESCRIPTION,0
    341  4010				   _SKIPDESCRIPTION
    342  4010					      endif
    343  4010		       6c fc ff 	      jmp	($FFFC)
    344  4013					      endif
    345  4013				  -	      else
    346  4013				  -	      ifconst	bankswitchmode
    347  4013				  -	      ifconst	ROMAT4K
    348  4013				  -	      ORG	$4000,0
    349  4013				  -	      RORG	$4000
    350  4013				  -	      else
    351  4013				  -	      ORG	$8000,0
    352  4013				  -	      RORG	$8000
    353  4013				  -	      endif
    354  4013				  -	      else		; not bankswitchmode
    355  4013				  -	      ifconst	ROM16K
    356  4013				  -	      ORG	$C000,0
    357  4013				  -	      ifconst	BEADHEADER
    358  4013				  -	      .byte	$BE,$AD,BEADHARDWARE
    359  4013				  -	      ifconst	GAMEDESCRIPTION
    360  4013				  -	      CLC
    361  4013				  -	      BCC	_SKIPDESCRIPTION
    362  4013				  -	      .byte	GAMEDESCRIPTION,0
    363  4013				  -_SKIPDESCRIPTION
    364  4013				  -	      endif
    365  4013				  -	      jmp	($FFFC)
    366  4013				  -	      endif
    367  4013				  -	      else
    368  4013				  -	      ifconst	ROM8K
    369  4013				  -	      ORG	$E000,0
    370  4013				  -	      else
    371  4013				  -	      ORG	$8000,0
    372  4013				  -	      ifconst	BEADHEADER
    373  4013				  -	      .byte	$BE,$AD,BEADHARDWARE
    374  4013				  -	      ifconst	GAMEDESCRIPTION
    375  4013				  -	      CLC
    376  4013				  -	      BCC	_SKIPDESCRIPTION
    377  4013				  -	      .byte	GAMEDESCRIPTION,0
    378  4013				  -_SKIPDESCRIPTION
    379  4013				  -	      endif
    380  4013				  -	      jmp	($FFFC)
    381  4013				  -	      endif
    382  4013				  -	      endif
    383  4013				  -	      endif
    384  4013				  -	      endif
    385  4013					      endif
    386  4013
    387  4013				   game
    388  4013				   .L00 		;;  set zoneheight 16
    389  4013
    390  4013				   .L01 		;;  displaymode 160A
    391  4013
    392  4013		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    393  4015		       85 3c		      sta	CTRL
    394  4017
    395  4017		       8d 07 21 	      sta	sCTRL
    396  401a
    397  401a				   .L02 		;;  set plotvalueonscreen on
    398  401a
    399  401a				   .L03 		;;  set romsize 48k
    400  401a
    401  401a				   .
    402  401a							;; 
    403  401a
    404  401a				   .L04 		;;  incgraphic g16x16_4color.png 160A
    405  401a
    406  401a				   .L05 		;;  incgraphic g16x16_4color2.png 160A
    407  401a
    408  401a				   .L06 		;;  incgraphic g16x16_4color3.png 160A
    409  401a
    410  401a				   .L07 		;;  incgraphic g16x16_4color4.png 160A 
    411  401a
    412  401a				   .L08 		;;  incgraphic zonebg80x16_16.png 160A
    413  401a
    414  401a				   .L09 		;;  incgraphic font.png 160A
    415  401a
    416  401a				   .
    417  401a							;; 
    418  401a
    419  401a				   .L010		;;  rem font
    420  401a
    421  401a				   .L011		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    422  401a
    423  401a				   .L012		;;  characterset font
    424  401a
    425  401a		       a9 e0		      lda	#>font
    426  401c		       85 34		      sta	CHARBASE
    427  401e		       8d 0b 21 	      sta	sCHARBASE
    428  4021
    429  4021		       a9 60		      lda	#(font_mode | %01100000)
    430  4023		       8d 06 21 	      sta	charactermode
    431  4026
    432  4026				   .
    433  4026							;; 
    434  4026
    435  4026				   .L013		;;  rem blue
    436  4026
    437  4026				   .L014		;;  P0C1 = $90
    438  4026
    439  4026		       a9 90		      LDA	#$90
    440  4028		       85 21		      STA	P0C1
    441  402a				   .L015		;;  P0C2 = $70
    442  402a
    443  402a		       a9 70		      LDA	#$70
    444  402c		       85 22		      STA	P0C2
    445  402e				   .L016		;;  P0C3 = $98
    446  402e
    447  402e		       a9 98		      LDA	#$98
    448  4030		       85 23		      STA	P0C3
    449  4032				   .L017		;;  rem red
    450  4032
    451  4032				   .L018		;;  P1C1 = $20
    452  4032
    453  4032		       a9 20		      LDA	#$20
    454  4034		       85 25		      STA	P1C1
    455  4036				   .L019		;;  P1C2 = $32
    456  4036
    457  4036		       a9 32		      LDA	#$32
    458  4038		       85 26		      STA	P1C2
    459  403a				   .L020		;;  P1C3 = $36
    460  403a
    461  403a		       a9 36		      LDA	#$36
    462  403c		       85 27		      STA	P1C3
    463  403e				   .L021		;;  rem green
    464  403e
    465  403e				   .L022		;;  P2C1 = $C1
    466  403e
    467  403e		       a9 c1		      LDA	#$C1
    468  4040		       85 29		      STA	P2C1
    469  4042				   .L023		;;  P2C2 = $C6
    470  4042
    471  4042		       a9 c6		      LDA	#$C6
    472  4044		       85 2a		      STA	P2C2
    473  4046				   .L024		;;  P2C3 = $CB
    474  4046
    475  4046		       a9 cb		      LDA	#$CB
    476  4048		       85 2b		      STA	P2C3
    477  404a				   .L025		;;  rem purple
    478  404a
    479  404a				   .L026		;;  P3C1 = $50
    480  404a
    481  404a		       a9 50		      LDA	#$50
    482  404c		       85 2d		      STA	P3C1
    483  404e				   .L027		;;  P3C2 = $53
    484  404e
    485  404e		       a9 53		      LDA	#$53
    486  4050		       85 2e		      STA	P3C2
    487  4052				   .L028		;;  P3C3 = $58
    488  4052
    489  4052		       a9 58		      LDA	#$58
    490  4054		       85 2f		      STA	P3C3
    491  4056				   .L029		;;  rem orange
    492  4056
    493  4056				   .L030		;;  P4C1 = $35
    494  4056
    495  4056		       a9 35		      LDA	#$35
    496  4058		       85 31		      STA	P4C1
    497  405a				   .L031		;;  P4C2 = $38
    498  405a
    499  405a		       a9 38		      LDA	#$38
    500  405c		       85 32		      STA	P4C2
    501  405e				   .L032		;;  P4C3 = $3C
    502  405e
    503  405e		       a9 3c		      LDA	#$3C
    504  4060		       85 33		      STA	P4C3
    505  4062				   .L033		;;  rem yellow
    506  4062
    507  4062				   .L034		;;  P5C1 = $15
    508  4062
    509  4062		       a9 15		      LDA	#$15
    510  4064		       85 35		      STA	P5C1
    511  4066				   .L035		;;  P5C2 = $1A
    512  4066
    513  4066		       a9 1a		      LDA	#$1A
    514  4068		       85 36		      STA	P5C2
    515  406a				   .L036		;;  P5C3 = $1E
    516  406a
    517  406a		       a9 1e		      LDA	#$1E
    518  406c		       85 37		      STA	P5C3
    519  406e				   .L037		;;  rem teal
    520  406e
    521  406e				   .L038		;;  P6C1 = $A1
    522  406e
    523  406e		       a9 a1		      LDA	#$A1
    524  4070		       85 39		      STA	P6C1
    525  4072				   .L039		;;  P6C2 = $A6
    526  4072
    527  4072		       a9 a6		      LDA	#$A6
    528  4074		       85 3a		      STA	P6C2
    529  4076				   .L040		;;  P6C3 = $Ac
    530  4076
    531  4076		       a9 ac		      LDA	#$Ac
    532  4078		       85 3b		      STA	P6C3
    533  407a				   .L041		;;  rem white
    534  407a
    535  407a				   .L042		;;  P7C1 = $0F
    536  407a
    537  407a		       a9 0f		      LDA	#$0F
    538  407c		       85 3d		      STA	P7C1
    539  407e				   .L043		;;  P7C2 = $05
    540  407e
    541  407e		       a9 05		      LDA	#$05
    542  4080		       85 3e		      STA	P7C2
    543  4082				   .L044		;;  P7C3 = $09
    544  4082
    545  4082		       a9 09		      LDA	#$09
    546  4084		       85 3f		      STA	P7C3
    547  4086				   .
    548  4086							;; 
    549  4086
    550  4086				   .L045		;;  rem lesson 1
    551  4086
    552  4086				   .L046		;;  w	=  0
    553  4086
    554  4086		       a9 00		      LDA	#0
    555  4088		       85 fc		      STA	w
    556  408a				   ._title
    557  408a							;; _title
    558  408a
    559  408a				   .L047		;;  clearscreen
    560  408a
    561  408a		       20 77 f0 	      jsr	clearscreen
    562  408d				   .L048		;;  plotchars 'demo^1' 7 67 4 1
    563  408d
    564  408d		       4c 96 40 	      JMP	skipalphadata0
    565  4090				   alphadata0
    566  4090		       31		      .byte.b	(<font + $0d)
    567  4091		       32		      .byte.b	(<font + $0e)
    568  4092		       3a		      .byte.b	(<font + $16)
    569  4093		       3c		      .byte.b	(<font + $18)
    570  4094		       58		      .byte.b	(<font + $34)
    571  4095		       25		      .byte.b	(<font + $01)
    572  4096				   skipalphadata0
    573  4096		       a9 90		      lda	#<alphadata0
    574  4098		       85 42		      sta	temp1
    575  409a
    576  409a		       a9 40		      lda	#>alphadata0
    577  409c		       85 43		      sta	temp2
    578  409e
    579  409e		       a9 1a		      lda	#26	; width in two's complement
    580  40a0		       09 e0		      ora	#224	; palette left shifted 5 bits
    581  40a2		       85 44		      sta	temp3
    582  40a4		       a9 43		      lda	#67
    583  40a6		       85 45		      sta	temp4
    584  40a8
    585  40a8		       a9 04		      lda	#4
    586  40aa		       85 46		      sta	temp5
    587  40ac
    588  40ac		       20 43 f3 	      jsr	plotcharacters
    589  40af				   .L049		;;  plotchars 'atari^7800^basic^exploration' 1 23 6 1
    590  40af
    591  40af		       4c ce 40 	      JMP	skipalphadata1
    592  40b2				   alphadata1
    593  40b2		       2e		      .byte.b	(<font + $0a)
    594  40b3		       41		      .byte.b	(<font + $1d)
    595  40b4		       2e		      .byte.b	(<font + $0a)
    596  40b5		       3f		      .byte.b	(<font + $1b)
    597  40b6		       36		      .byte.b	(<font + $12)
    598  40b7		       58		      .byte.b	(<font + $34)
    599  40b8		       2b		      .byte.b	(<font + $07)
    600  40b9		       2c		      .byte.b	(<font + $08)
    601  40ba		       24		      .byte.b	(<font + $00)
    602  40bb		       24		      .byte.b	(<font + $00)
    603  40bc		       58		      .byte.b	(<font + $34)
    604  40bd		       2f		      .byte.b	(<font + $0b)
    605  40be		       2e		      .byte.b	(<font + $0a)
    606  40bf		       40		      .byte.b	(<font + $1c)
    607  40c0		       36		      .byte.b	(<font + $12)
    608  40c1		       30		      .byte.b	(<font + $0c)
    609  40c2		       58		      .byte.b	(<font + $34)
    610  40c3		       32		      .byte.b	(<font + $0e)
    611  40c4		       45		      .byte.b	(<font + $21)
    612  40c5		       3d		      .byte.b	(<font + $19)
    613  40c6		       39		      .byte.b	(<font + $15)
    614  40c7		       3c		      .byte.b	(<font + $18)
    615  40c8		       3f		      .byte.b	(<font + $1b)
    616  40c9		       2e		      .byte.b	(<font + $0a)
    617  40ca		       41		      .byte.b	(<font + $1d)
    618  40cb		       36		      .byte.b	(<font + $12)
    619  40cc		       3c		      .byte.b	(<font + $18)
    620  40cd		       3b		      .byte.b	(<font + $17)
    621  40ce				   skipalphadata1
    622  40ce		       a9 b2		      lda	#<alphadata1
    623  40d0		       85 42		      sta	temp1
    624  40d2
    625  40d2		       a9 40		      lda	#>alphadata1
    626  40d4		       85 43		      sta	temp2
    627  40d6
    628  40d6		       a9 04		      lda	#4	; width in two's complement
    629  40d8		       09 20		      ora	#32	; palette left shifted 5 bits
    630  40da		       85 44		      sta	temp3
    631  40dc		       a9 17		      lda	#23
    632  40de		       85 45		      sta	temp4
    633  40e0
    634  40e0		       a9 06		      lda	#6
    635  40e2		       85 46		      sta	temp5
    636  40e4
    637  40e4		       20 43 f3 	      jsr	plotcharacters
    638  40e7				   .L050		;;  plotchars '160a^zoneheight^16' 7 47 8 1
    639  40e7
    640  40e7		       4c fc 40 	      JMP	skipalphadata2
    641  40ea				   alphadata2
    642  40ea		       25		      .byte.b	(<font + $01)
    643  40eb		       2a		      .byte.b	(<font + $06)
    644  40ec		       24		      .byte.b	(<font + $00)
    645  40ed		       2e		      .byte.b	(<font + $0a)
    646  40ee		       58		      .byte.b	(<font + $34)
    647  40ef		       47		      .byte.b	(<font + $23)
    648  40f0		       3c		      .byte.b	(<font + $18)
    649  40f1		       3b		      .byte.b	(<font + $17)
    650  40f2		       32		      .byte.b	(<font + $0e)
    651  40f3		       35		      .byte.b	(<font + $11)
    652  40f4		       32		      .byte.b	(<font + $0e)
    653  40f5		       36		      .byte.b	(<font + $12)
    654  40f6		       34		      .byte.b	(<font + $10)
    655  40f7		       35		      .byte.b	(<font + $11)
    656  40f8		       41		      .byte.b	(<font + $1d)
    657  40f9		       58		      .byte.b	(<font + $34)
    658  40fa		       25		      .byte.b	(<font + $01)
    659  40fb		       2a		      .byte.b	(<font + $06)
    660  40fc				   skipalphadata2
    661  40fc		       a9 ea		      lda	#<alphadata2
    662  40fe		       85 42		      sta	temp1
    663  4100
    664  4100		       a9 40		      lda	#>alphadata2
    665  4102		       85 43		      sta	temp2
    666  4104
    667  4104		       a9 0e		      lda	#14	; width in two's complement
    668  4106		       09 e0		      ora	#224	; palette left shifted 5 bits
    669  4108		       85 44		      sta	temp3
    670  410a		       a9 2f		      lda	#47
    671  410c		       85 45		      sta	temp4
    672  410e
    673  410e		       a9 08		      lda	#8
    674  4110		       85 46		      sta	temp5
    675  4112
    676  4112		       20 43 f3 	      jsr	plotcharacters
    677  4115				   .L051		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen2_setup
    678  4115
    679  4115		       a9 08		      LDA	#8
    680  4117		       c5 fc		      CMP	w
    681  4119		       b0 0c		      BCS	.skipL051
    682  411b				   .condpart0
    683  411b		       2c 02 21 	      bit	sINPT1
    684  411e		       10 07		      BPL	.skip0then
    685  4120				   .condpart1
    686  4120		       a9 00		      LDA	#0
    687  4122		       85 fc		      STA	w
    688  4124		       4c 34 41 	      jmp	._screen2_setup
    689  4127
    690  4127				   .skip0then
    691  4127				   .skipL051
    692  4127				   .L052		;;  w	=  w  +  1
    693  4127
    694  4127		       a5 fc		      LDA	w
    695  4129		       18		      CLC
    696  412a		       69 01		      ADC	#1
    697  412c		       85 fc		      STA	w
    698  412e				   .L053		;;  drawscreen
    699  412e
    700  412e		       20 ab f0 	      jsr	drawscreen
    701  4131				   .L054		;;  goto _title
    702  4131
    703  4131		       4c 8a 40 	      jmp	._title
    704  4134
    705  4134				   .
    706  4134							;; 
    707  4134
    708  4134				   .L055		;;  rem draw sprites with arrow with bg
    709  4134
    710  4134				   ._screen2_setup
    711  4134							;; _screen2_setup
    712  4134
    713  4134				   .L056		;;  clearscreen
    714  4134
    715  4134		       20 77 f0 	      jsr	clearscreen
    716  4137				   .L057		;;  gosub drawZoneBG
    717  4137
    718  4137		       20 78 46 	      jsr	.drawZoneBG
    719  413a
    720  413a				   .L058		;;  m	=  0
    721  413a
    722  413a		       a9 00		      LDA	#0
    723  413c		       85 f2		      STA	m
    724  413e				   .L059		;;  n	=  0
    725  413e
    726  413e		       a9 00		      LDA	#0
    727  4140		       85 f3		      STA	n
    728  4142				   .L060		;;  c	=  0
    729  4142
    730  4142		       a9 00		      LDA	#0
    731  4144		       85 e8		      STA	c
    732  4146				   ._screen2
    733  4146							;; _screen2
    734  4146
    735  4146				   .L061		;;  restorescreen
    736  4146
    737  4146		       20 89 f0 	      jsr	restorescreen
    738  4149				   .L062		;;  y	=  0
    739  4149
    740  4149		       a9 00		      LDA	#0
    741  414b		       85 fe		      STA	y
    742  414d				   .L063		;;  x	=  0
    743  414d
    744  414d		       a9 00		      LDA	#0
    745  414f		       85 fd		      STA	x
    746  4151				   .L064		;;  c	=  0
    747  4151
    748  4151		       a9 00		      LDA	#0
    749  4153		       85 e8		      STA	c
    750  4155				   .L065		;;  for i  =  0 to n
    751  4155
    752  4155		       a9 00		      LDA	#0
    753  4157		       85 ee		      STA	i
    754  4159				   .L065fori
    755  4159				   .L066		;;  for j  =  0 to m
    756  4159
    757  4159		       a9 00		      LDA	#0
    758  415b		       85 ef		      STA	j
    759  415d				   .L066forj
    760  415d				   .L067		;;  plotsprite g16x16_4color c x y 0
    761  415d
    762  415d		       a9 00		      lda	#<g16x16_4color
    763  415f		       85 42		      sta	temp1
    764  4161
    765  4161		       a9 e0		      lda	#>g16x16_4color
    766  4163		       85 43		      sta	temp2
    767  4165
    768  4165		       a5 e8		      lda	c
    769  4167		       0a		      asl
    770  4168		       0a		      asl
    771  4169		       0a		      asl
    772  416a		       0a		      asl
    773  416b		       0a		      asl
    774  416c		       09 1c		      ora	#g16x16_4color_width_twoscompliment
    775  416e		       85 44		      sta	temp3
    776  4170
    777  4170		       a5 fd		      lda	x
    778  4172		       85 45		      sta	temp4
    779  4174
    780  4174		       a5 fe		      lda	y
    781  4176		       85 46		      sta	temp5
    782  4178
    783  4178		       a9 40		      lda	#(g16x16_4color_mode|%01000000)
    784  417a		       85 47		      sta	temp6
    785  417c
    786  417c		       20 8b f2 	      jsr	plotsprite
    787  417f				   .L068		;;  x	=  x  +  16
    788  417f
    789  417f		       a5 fd		      LDA	x
    790  4181		       18		      CLC
    791  4182		       69 10		      ADC	#16
    792  4184		       85 fd		      STA	x
    793  4186				   .L069		;;  next
    794  4186
    795  4186		       a5 ef		      LDA	j
    796  4188		       c5 f2		      CMP	m
    797  418a		       e6 ef		      INC	j
    798  418c					      if	((* - .L066forj) < 127) && ((* - .L066forj) > -128)
    799  418c		       90 cf		      bcc	.L066forj
    800  418e				  -	      else
    801  418e				  -	      bcs	.0skipL066forj
    802  418e				  -	      jmp	.L066forj
    803  418e				  -.0skipL066forj
    804  418e					      endif
    805  418e				   .L070		;;  x	=  0
    806  418e
    807  418e		       a9 00		      LDA	#0
    808  4190		       85 fd		      STA	x
    809  4192				   .L071		;;  y	=  y  +  16
    810  4192
    811  4192		       a5 fe		      LDA	y
    812  4194		       18		      CLC
    813  4195		       69 10		      ADC	#16
    814  4197		       85 fe		      STA	y
    815  4199				   .L072		;;  c	=  c  +  1
    816  4199
    817  4199		       a5 e8		      LDA	c
    818  419b		       18		      CLC
    819  419c		       69 01		      ADC	#1
    820  419e		       85 e8		      STA	c
    821  41a0				   .L073		;;  if c  >  6 then c	=  0
    822  41a0
    823  41a0		       a9 06		      LDA	#6
    824  41a2		       c5 e8		      CMP	c
    825  41a4		       b0 04		      BCS	.skipL073
    826  41a6				   .condpart2
    827  41a6		       a9 00		      LDA	#0
    828  41a8		       85 e8		      STA	c
    829  41aa				   .skipL073
    830  41aa				   .L074		;;  next
    831  41aa
    832  41aa		       a5 ee		      LDA	i
    833  41ac		       c5 f3		      CMP	n
    834  41ae		       e6 ee		      INC	i
    835  41b0					      if	((* - .L065fori) < 127) && ((* - .L065fori) > -128)
    836  41b0		       90 a7		      bcc	.L065fori
    837  41b2				  -	      else
    838  41b2				  -	      bcs	.1skipL065fori
    839  41b2				  -	      jmp	.L065fori
    840  41b2				  -.1skipL065fori
    841  41b2					      endif
    842  41b2				   .L075		;;  if w  >  8  &&  joy0right then w  = 0  :  m  =  m	+  1
    843  41b2
    844  41b2		       a9 08		      LDA	#8
    845  41b4		       c5 fc		      CMP	w
    846  41b6		       b0 10		      BCS	.skipL075
    847  41b8				   .condpart3
    848  41b8		       2c 80 02 	      bit	SWCHA
    849  41bb		       30 0b		      BMI	.skip3then
    850  41bd				   .condpart4
    851  41bd		       a9 00		      LDA	#0
    852  41bf		       85 fc		      STA	w
    853  41c1		       a5 f2		      LDA	m
    854  41c3		       18		      CLC
    855  41c4		       69 01		      ADC	#1
    856  41c6		       85 f2		      STA	m
    857  41c8				   .skip3then
    858  41c8				   .skipL075
    859  41c8				   .L076		;;  if w  >  8  &&  joy0down then w  =  0  :  n  =  n	+  1
    860  41c8
    861  41c8		       a9 08		      LDA	#8
    862  41ca		       c5 fc		      CMP	w
    863  41cc		       b0 12		      BCS	.skipL076
    864  41ce				   .condpart5
    865  41ce		       a9 20		      lda	#$20
    866  41d0		       2c 80 02 	      bit	SWCHA
    867  41d3		       d0 0b		      BNE	.skip5then
    868  41d5				   .condpart6
    869  41d5		       a9 00		      LDA	#0
    870  41d7		       85 fc		      STA	w
    871  41d9		       a5 f3		      LDA	n
    872  41db		       18		      CLC
    873  41dc		       69 01		      ADC	#1
    874  41de		       85 f3		      STA	n
    875  41e0				   .skip5then
    876  41e0				   .skipL076
    877  41e0				   .L077		;;  if w  >  8  &&  joy0left then w  = 0  :  m  =  m  -  1
    878  41e0
    879  41e0		       a9 08		      LDA	#8
    880  41e2		       c5 fc		      CMP	w
    881  41e4		       b0 10		      BCS	.skipL077
    882  41e6				   .condpart7
    883  41e6		       2c 80 02 	      bit	SWCHA
    884  41e9		       70 0b		      BVS	.skip7then
    885  41eb				   .condpart8
    886  41eb		       a9 00		      LDA	#0
    887  41ed		       85 fc		      STA	w
    888  41ef		       a5 f2		      LDA	m
    889  41f1		       38		      SEC
    890  41f2		       e9 01		      SBC	#1
    891  41f4		       85 f2		      STA	m
    892  41f6				   .skip7then
    893  41f6				   .skipL077
    894  41f6				   .L078		;;  if w  >  8  &&  joy0up then w  =  0  :  n	=  n  -  1
    895  41f6
    896  41f6		       a9 08		      LDA	#8
    897  41f8		       c5 fc		      CMP	w
    898  41fa		       b0 12		      BCS	.skipL078
    899  41fc				   .condpart9
    900  41fc		       a9 10		      lda	#$10
    901  41fe		       2c 80 02 	      bit	SWCHA
    902  4201		       d0 0b		      BNE	.skip9then
    903  4203				   .condpart10
    904  4203		       a9 00		      LDA	#0
    905  4205		       85 fc		      STA	w
    906  4207		       a5 f3		      LDA	n
    907  4209		       38		      SEC
    908  420a		       e9 01		      SBC	#1
    909  420c		       85 f3		      STA	n
    910  420e				   .skip9then
    911  420e				   .skipL078
    912  420e				   .L079		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen3_setup
    913  420e
    914  420e		       a9 08		      LDA	#8
    915  4210		       c5 fc		      CMP	w
    916  4212		       b0 0c		      BCS	.skipL079
    917  4214				   .condpart11
    918  4214		       2c 02 21 	      bit	sINPT1
    919  4217		       10 07		      BPL	.skip11then
    920  4219				   .condpart12
    921  4219		       a9 00		      LDA	#0
    922  421b		       85 fc		      STA	w
    923  421d		       4c ef 42 	      jmp	._screen3_setup
    924  4220
    925  4220				   .skip11then
    926  4220				   .skipL079
    927  4220				   .L080		;;  w	=  w  +  1
    928  4220
    929  4220		       a5 fc		      LDA	w
    930  4222		       18		      CLC
    931  4223		       69 01		      ADC	#1
    932  4225		       85 fc		      STA	w
    933  4227				   .L081		;;  if n  >  24 then n  =  0
    934  4227
    935  4227		       a9 18		      LDA	#24
    936  4229		       c5 f3		      CMP	n
    937  422b		       b0 04		      BCS	.skipL081
    938  422d				   .condpart13
    939  422d		       a9 00		      LDA	#0
    940  422f		       85 f3		      STA	n
    941  4231				   .skipL081
    942  4231				   .L082		;;  if m  >  20 then m  =  0
    943  4231
    944  4231		       a9 14		      LDA	#20
    945  4233		       c5 f2		      CMP	m
    946  4235		       b0 04		      BCS	.skipL082
    947  4237				   .condpart14
    948  4237		       a9 00		      LDA	#0
    949  4239		       85 f2		      STA	m
    950  423b				   .skipL082
    951  423b				   .L083		;;  r	=  n  +  1
    952  423b
    953  423b		       a5 f3		      LDA	n
    954  423d		       18		      CLC
    955  423e		       69 01		      ADC	#1
    956  4240		       85 f7		      STA	r
    957  4242				   .L084		;;  s	=  m  +  1
    958  4242
    959  4242		       a5 f2		      LDA	m
    960  4244		       18		      CLC
    961  4245		       69 01		      ADC	#1
    962  4247		       85 f8		      STA	s
    963  4249				   .L085		;;  plotvalue font 7 s 2 10 11 doublewide
    964  4249
    965  4249		       a9 24		      lda	#<font
    966  424b		       85 42		      sta	temp1
    967  424d
    968  424d		       a9 e0		      lda	#>font
    969  424f		       85 43		      sta	temp2
    970  4251
    971  4251		       ad 06 21 	      lda	charactermode
    972  4254		       85 4a		      sta	temp9
    973  4256		       a9 60		      lda	#(font_mode | %01100000)
    974  4258		       8d 06 21 	      sta	charactermode
    975  425b		       a9 1e		      lda	#30	; width in two's complement
    976  425d		       09 e0		      ora	#224	; palette left shifted 5 bits
    977  425f		       85 44		      sta	temp3
    978  4261		       a9 0a		      lda	#10
    979  4263		       85 45		      sta	temp4
    980  4265
    981  4265		       a9 0b		      lda	#11
    982  4267		       85 46		      sta	temp5
    983  4269
    984  4269		       a9 02		      lda	#2
    985  426b		       85 47		      sta	temp6
    986  426d
    987  426d		       a9 f8		      lda	#<s
    988  426f		       85 48		      sta	temp7
    989  4271
    990  4271		       a9 00		      lda	#>s
    991  4273		       85 49		      sta	temp8
    992  4275
    993  4275		       20 9f f3 	      jsr	plotvalue
    994  4275		       00 01	   USED_PLOTVALUE =	1
    995  4278		       a5 4a		      lda	temp9
    996  427a		       8d 06 21 	      sta	charactermode
    997  427d				   .L086		;;  plotvalue font 7 r 2 20 11 doublewide
    998  427d
    999  427d		       a9 24		      lda	#<font
   1000  427f		       85 42		      sta	temp1
   1001  4281
   1002  4281		       a9 e0		      lda	#>font
   1003  4283		       85 43		      sta	temp2
   1004  4285
   1005  4285		       ad 06 21 	      lda	charactermode
   1006  4288		       85 4a		      sta	temp9
   1007  428a		       a9 60		      lda	#(font_mode | %01100000)
   1008  428c		       8d 06 21 	      sta	charactermode
   1009  428f		       a9 1e		      lda	#30	; width in two's complement
   1010  4291		       09 e0		      ora	#224	; palette left shifted 5 bits
   1011  4293		       85 44		      sta	temp3
   1012  4295		       a9 14		      lda	#20
   1013  4297		       85 45		      sta	temp4
   1014  4299
   1015  4299		       a9 0b		      lda	#11
   1016  429b		       85 46		      sta	temp5
   1017  429d
   1018  429d		       a9 02		      lda	#2
   1019  429f		       85 47		      sta	temp6
   1020  42a1
   1021  42a1		       a9 f7		      lda	#<r
   1022  42a3		       85 48		      sta	temp7
   1023  42a5
   1024  42a5		       a9 00		      lda	#>r
   1025  42a7		       85 49		      sta	temp8
   1026  42a9
   1027  42a9		       20 9f f3 	      jsr	plotvalue
   1028  42a9		       00 01	   USED_PLOTVALUE =	1
   1029  42ac		       a5 4a		      lda	temp9
   1030  42ae		       8d 06 21 	      sta	charactermode
   1031  42b1				   .L087		;;  plotvalue font 7 z 2 30 11 doublewide
   1032  42b1
   1033  42b1		       a9 24		      lda	#<font
   1034  42b3		       85 42		      sta	temp1
   1035  42b5
   1036  42b5		       a9 e0		      lda	#>font
   1037  42b7		       85 43		      sta	temp2
   1038  42b9
   1039  42b9		       ad 06 21 	      lda	charactermode
   1040  42bc		       85 4a		      sta	temp9
   1041  42be		       a9 60		      lda	#(font_mode | %01100000)
   1042  42c0		       8d 06 21 	      sta	charactermode
   1043  42c3		       a9 1e		      lda	#30	; width in two's complement
   1044  42c5		       09 e0		      ora	#224	; palette left shifted 5 bits
   1045  42c7		       85 44		      sta	temp3
   1046  42c9		       a9 1e		      lda	#30
   1047  42cb		       85 45		      sta	temp4
   1048  42cd
   1049  42cd		       a9 0b		      lda	#11
   1050  42cf		       85 46		      sta	temp5
   1051  42d1
   1052  42d1		       a9 02		      lda	#2
   1053  42d3		       85 47		      sta	temp6
   1054  42d5
   1055  42d5		       a9 ff		      lda	#<z
   1056  42d7		       85 48		      sta	temp7
   1057  42d9
   1058  42d9		       a9 00		      lda	#>z
   1059  42db		       85 49		      sta	temp8
   1060  42dd
   1061  42dd		       20 9f f3 	      jsr	plotvalue
   1062  42dd		       00 01	   USED_PLOTVALUE =	1
   1063  42e0		       a5 4a		      lda	temp9
   1064  42e2		       8d 06 21 	      sta	charactermode
   1065  42e5				   .L088		;;  drawscreen
   1066  42e5
   1067  42e5		       20 ab f0 	      jsr	drawscreen
   1068  42e8				   .L089		;;  z	=  0
   1069  42e8
   1070  42e8		       a9 00		      LDA	#0
   1071  42ea		       85 ff		      STA	z
   1072  42ec				   .L090		;;  goto _screen2
   1073  42ec
   1074  42ec		       4c 46 41 	      jmp	._screen2
   1075  42ef
   1076  42ef				   .
   1077  42ef							;; 
   1078  42ef
   1079  42ef				   .L091		;;  rem draw sprites with arrow no bg
   1080  42ef
   1081  42ef				   ._screen3_setup
   1082  42ef							;; _screen3_setup
   1083  42ef
   1084  42ef				   .L092		;;  m	=  0
   1085  42ef
   1086  42ef		       a9 00		      LDA	#0
   1087  42f1		       85 f2		      STA	m
   1088  42f3				   .L093		;;  n	=  0
   1089  42f3
   1090  42f3		       a9 00		      LDA	#0
   1091  42f5		       85 f3		      STA	n
   1092  42f7				   .L094		;;  c	=  0
   1093  42f7
   1094  42f7		       a9 00		      LDA	#0
   1095  42f9		       85 e8		      STA	c
   1096  42fb				   ._screen3
   1097  42fb							;; _screen3
   1098  42fb
   1099  42fb				   .L095		;;  clearscreen
   1100  42fb
   1101  42fb		       20 77 f0 	      jsr	clearscreen
   1102  42fe				   .L096		;;  y	=  0
   1103  42fe
   1104  42fe		       a9 00		      LDA	#0
   1105  4300		       85 fe		      STA	y
   1106  4302				   .L097		;;  x	=  0
   1107  4302
   1108  4302		       a9 00		      LDA	#0
   1109  4304		       85 fd		      STA	x
   1110  4306				   .L098		;;  c	=  0
   1111  4306
   1112  4306		       a9 00		      LDA	#0
   1113  4308		       85 e8		      STA	c
   1114  430a				   .L099		;;  for i  =  0 to n
   1115  430a
   1116  430a		       a9 00		      LDA	#0
   1117  430c		       85 ee		      STA	i
   1118  430e				   .L099fori
   1119  430e				   .L0100		;;  for j  =  0 to m
   1120  430e
   1121  430e		       a9 00		      LDA	#0
   1122  4310		       85 ef		      STA	j
   1123  4312				   .L0100forj
   1124  4312				   .L0101		;;  plotsprite g16x16_4color c x y 0
   1125  4312
   1126  4312		       a9 00		      lda	#<g16x16_4color
   1127  4314		       85 42		      sta	temp1
   1128  4316
   1129  4316		       a9 e0		      lda	#>g16x16_4color
   1130  4318		       85 43		      sta	temp2
   1131  431a
   1132  431a		       a5 e8		      lda	c
   1133  431c		       0a		      asl
   1134  431d		       0a		      asl
   1135  431e		       0a		      asl
   1136  431f		       0a		      asl
   1137  4320		       0a		      asl
   1138  4321		       09 1c		      ora	#g16x16_4color_width_twoscompliment
   1139  4323		       85 44		      sta	temp3
   1140  4325
   1141  4325		       a5 fd		      lda	x
   1142  4327		       85 45		      sta	temp4
   1143  4329
   1144  4329		       a5 fe		      lda	y
   1145  432b		       85 46		      sta	temp5
   1146  432d
   1147  432d		       a9 40		      lda	#(g16x16_4color_mode|%01000000)
   1148  432f		       85 47		      sta	temp6
   1149  4331
   1150  4331		       20 8b f2 	      jsr	plotsprite
   1151  4334				   .L0102		;;  x	=  x  +  16
   1152  4334
   1153  4334		       a5 fd		      LDA	x
   1154  4336		       18		      CLC
   1155  4337		       69 10		      ADC	#16
   1156  4339		       85 fd		      STA	x
   1157  433b				   .L0103		;;  next
   1158  433b
   1159  433b		       a5 ef		      LDA	j
   1160  433d		       c5 f2		      CMP	m
   1161  433f		       e6 ef		      INC	j
   1162  4341					      if	((* - .L0100forj) < 127) && ((* - .L0100forj) > -128)
   1163  4341		       90 cf		      bcc	.L0100forj
   1164  4343				  -	      else
   1165  4343				  -	      bcs	.2skipL0100forj
   1166  4343				  -	      jmp	.L0100forj
   1167  4343				  -.2skipL0100forj
   1168  4343					      endif
   1169  4343				   .L0104		;;  x	=  0
   1170  4343
   1171  4343		       a9 00		      LDA	#0
   1172  4345		       85 fd		      STA	x
   1173  4347				   .L0105		;;  y	=  y  +  16
   1174  4347
   1175  4347		       a5 fe		      LDA	y
   1176  4349		       18		      CLC
   1177  434a		       69 10		      ADC	#16
   1178  434c		       85 fe		      STA	y
   1179  434e				   .L0106		;;  c	=  c  +  1
   1180  434e
   1181  434e		       a5 e8		      LDA	c
   1182  4350		       18		      CLC
   1183  4351		       69 01		      ADC	#1
   1184  4353		       85 e8		      STA	c
   1185  4355				   .L0107		;;  if c  >  6 then c	=  0
   1186  4355
   1187  4355		       a9 06		      LDA	#6
   1188  4357		       c5 e8		      CMP	c
   1189  4359		       b0 04		      BCS	.skipL0107
   1190  435b				   .condpart15
   1191  435b		       a9 00		      LDA	#0
   1192  435d		       85 e8		      STA	c
   1193  435f				   .skipL0107
   1194  435f				   .L0108		;;  next
   1195  435f
   1196  435f		       a5 ee		      LDA	i
   1197  4361		       c5 f3		      CMP	n
   1198  4363		       e6 ee		      INC	i
   1199  4365					      if	((* - .L099fori) < 127) && ((* - .L099fori) > -128)
   1200  4365		       90 a7		      bcc	.L099fori
   1201  4367				  -	      else
   1202  4367				  -	      bcs	.3skipL099fori
   1203  4367				  -	      jmp	.L099fori
   1204  4367				  -.3skipL099fori
   1205  4367					      endif
   1206  4367				   .L0109		;;  if w  >  8  &&  joy0right then w  = 0  :  m  =  m	+  1
   1207  4367
   1208  4367		       a9 08		      LDA	#8
   1209  4369		       c5 fc		      CMP	w
   1210  436b		       b0 10		      BCS	.skipL0109
   1211  436d				   .condpart16
   1212  436d		       2c 80 02 	      bit	SWCHA
   1213  4370		       30 0b		      BMI	.skip16then
   1214  4372				   .condpart17
   1215  4372		       a9 00		      LDA	#0
   1216  4374		       85 fc		      STA	w
   1217  4376		       a5 f2		      LDA	m
   1218  4378		       18		      CLC
   1219  4379		       69 01		      ADC	#1
   1220  437b		       85 f2		      STA	m
   1221  437d				   .skip16then
   1222  437d				   .skipL0109
   1223  437d				   .L0110		;;  if w  >  8  &&  joy0down then w  =  0  :  n  =  n	+  1
   1224  437d
   1225  437d		       a9 08		      LDA	#8
   1226  437f		       c5 fc		      CMP	w
   1227  4381		       b0 12		      BCS	.skipL0110
   1228  4383				   .condpart18
   1229  4383		       a9 20		      lda	#$20
   1230  4385		       2c 80 02 	      bit	SWCHA
   1231  4388		       d0 0b		      BNE	.skip18then
   1232  438a				   .condpart19
   1233  438a		       a9 00		      LDA	#0
   1234  438c		       85 fc		      STA	w
   1235  438e		       a5 f3		      LDA	n
   1236  4390		       18		      CLC
   1237  4391		       69 01		      ADC	#1
   1238  4393		       85 f3		      STA	n
   1239  4395				   .skip18then
   1240  4395				   .skipL0110
   1241  4395				   .L0111		;;  if w  >  8  &&  joy0left then w  = 0  :  m  =  m  -  1
   1242  4395
   1243  4395		       a9 08		      LDA	#8
   1244  4397		       c5 fc		      CMP	w
   1245  4399		       b0 10		      BCS	.skipL0111
   1246  439b				   .condpart20
   1247  439b		       2c 80 02 	      bit	SWCHA
   1248  439e		       70 0b		      BVS	.skip20then
   1249  43a0				   .condpart21
   1250  43a0		       a9 00		      LDA	#0
   1251  43a2		       85 fc		      STA	w
   1252  43a4		       a5 f2		      LDA	m
   1253  43a6		       38		      SEC
   1254  43a7		       e9 01		      SBC	#1
   1255  43a9		       85 f2		      STA	m
   1256  43ab				   .skip20then
   1257  43ab				   .skipL0111
   1258  43ab				   .L0112		;;  if w  >  8  &&  joy0up then w  =  0  :  n	=  n  -  1
   1259  43ab
   1260  43ab		       a9 08		      LDA	#8
   1261  43ad		       c5 fc		      CMP	w
   1262  43af		       b0 12		      BCS	.skipL0112
   1263  43b1				   .condpart22
   1264  43b1		       a9 10		      lda	#$10
   1265  43b3		       2c 80 02 	      bit	SWCHA
   1266  43b6		       d0 0b		      BNE	.skip22then
   1267  43b8				   .condpart23
   1268  43b8		       a9 00		      LDA	#0
   1269  43ba		       85 fc		      STA	w
   1270  43bc		       a5 f3		      LDA	n
   1271  43be		       38		      SEC
   1272  43bf		       e9 01		      SBC	#1
   1273  43c1		       85 f3		      STA	n
   1274  43c3				   .skip22then
   1275  43c3				   .skipL0112
   1276  43c3				   .L0113		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen4_setup
   1277  43c3
   1278  43c3		       a9 08		      LDA	#8
   1279  43c5		       c5 fc		      CMP	w
   1280  43c7		       b0 0c		      BCS	.skipL0113
   1281  43c9				   .condpart24
   1282  43c9		       2c 02 21 	      bit	sINPT1
   1283  43cc		       10 07		      BPL	.skip24then
   1284  43ce				   .condpart25
   1285  43ce		       a9 00		      LDA	#0
   1286  43d0		       85 fc		      STA	w
   1287  43d2		       4c a4 44 	      jmp	._screen4_setup
   1288  43d5
   1289  43d5				   .skip24then
   1290  43d5				   .skipL0113
   1291  43d5				   .L0114		;;  w	=  w  +  1
   1292  43d5
   1293  43d5		       a5 fc		      LDA	w
   1294  43d7		       18		      CLC
   1295  43d8		       69 01		      ADC	#1
   1296  43da		       85 fc		      STA	w
   1297  43dc				   .L0115		;;  if n  >  24 then n  =  0
   1298  43dc
   1299  43dc		       a9 18		      LDA	#24
   1300  43de		       c5 f3		      CMP	n
   1301  43e0		       b0 04		      BCS	.skipL0115
   1302  43e2				   .condpart26
   1303  43e2		       a9 00		      LDA	#0
   1304  43e4		       85 f3		      STA	n
   1305  43e6				   .skipL0115
   1306  43e6				   .L0116		;;  if m  >  20 then m  =  0
   1307  43e6
   1308  43e6		       a9 14		      LDA	#20
   1309  43e8		       c5 f2		      CMP	m
   1310  43ea		       b0 04		      BCS	.skipL0116
   1311  43ec				   .condpart27
   1312  43ec		       a9 00		      LDA	#0
   1313  43ee		       85 f2		      STA	m
   1314  43f0				   .skipL0116
   1315  43f0				   .L0117		;;  r	=  n  +  1
   1316  43f0
   1317  43f0		       a5 f3		      LDA	n
   1318  43f2		       18		      CLC
   1319  43f3		       69 01		      ADC	#1
   1320  43f5		       85 f7		      STA	r
   1321  43f7				   .L0118		;;  s	=  m  +  1
   1322  43f7
   1323  43f7		       a5 f2		      LDA	m
   1324  43f9		       18		      CLC
   1325  43fa		       69 01		      ADC	#1
   1326  43fc		       85 f8		      STA	s
   1327  43fe				   .L0119		;;  plotvalue font 7 s 2 10 11 doublewide
   1328  43fe
   1329  43fe		       a9 24		      lda	#<font
   1330  4400		       85 42		      sta	temp1
   1331  4402
   1332  4402		       a9 e0		      lda	#>font
   1333  4404		       85 43		      sta	temp2
   1334  4406
   1335  4406		       ad 06 21 	      lda	charactermode
   1336  4409		       85 4a		      sta	temp9
   1337  440b		       a9 60		      lda	#(font_mode | %01100000)
   1338  440d		       8d 06 21 	      sta	charactermode
   1339  4410		       a9 1e		      lda	#30	; width in two's complement
   1340  4412		       09 e0		      ora	#224	; palette left shifted 5 bits
   1341  4414		       85 44		      sta	temp3
   1342  4416		       a9 0a		      lda	#10
   1343  4418		       85 45		      sta	temp4
   1344  441a
   1345  441a		       a9 0b		      lda	#11
   1346  441c		       85 46		      sta	temp5
   1347  441e
   1348  441e		       a9 02		      lda	#2
   1349  4420		       85 47		      sta	temp6
   1350  4422
   1351  4422		       a9 f8		      lda	#<s
   1352  4424		       85 48		      sta	temp7
   1353  4426
   1354  4426		       a9 00		      lda	#>s
   1355  4428		       85 49		      sta	temp8
   1356  442a
   1357  442a		       20 9f f3 	      jsr	plotvalue
   1358  442a		       00 01	   USED_PLOTVALUE =	1
   1359  442d		       a5 4a		      lda	temp9
   1360  442f		       8d 06 21 	      sta	charactermode
   1361  4432				   .L0120		;;  plotvalue font 7 r 2 20 11 doublewide
   1362  4432
   1363  4432		       a9 24		      lda	#<font
   1364  4434		       85 42		      sta	temp1
   1365  4436
   1366  4436		       a9 e0		      lda	#>font
   1367  4438		       85 43		      sta	temp2
   1368  443a
   1369  443a		       ad 06 21 	      lda	charactermode
   1370  443d		       85 4a		      sta	temp9
   1371  443f		       a9 60		      lda	#(font_mode | %01100000)
   1372  4441		       8d 06 21 	      sta	charactermode
   1373  4444		       a9 1e		      lda	#30	; width in two's complement
   1374  4446		       09 e0		      ora	#224	; palette left shifted 5 bits
   1375  4448		       85 44		      sta	temp3
   1376  444a		       a9 14		      lda	#20
   1377  444c		       85 45		      sta	temp4
   1378  444e
   1379  444e		       a9 0b		      lda	#11
   1380  4450		       85 46		      sta	temp5
   1381  4452
   1382  4452		       a9 02		      lda	#2
   1383  4454		       85 47		      sta	temp6
   1384  4456
   1385  4456		       a9 f7		      lda	#<r
   1386  4458		       85 48		      sta	temp7
   1387  445a
   1388  445a		       a9 00		      lda	#>r
   1389  445c		       85 49		      sta	temp8
   1390  445e
   1391  445e		       20 9f f3 	      jsr	plotvalue
   1392  445e		       00 01	   USED_PLOTVALUE =	1
   1393  4461		       a5 4a		      lda	temp9
   1394  4463		       8d 06 21 	      sta	charactermode
   1395  4466				   .L0121		;;  plotvalue font 7 z 2 30 11 doublewide
   1396  4466
   1397  4466		       a9 24		      lda	#<font
   1398  4468		       85 42		      sta	temp1
   1399  446a
   1400  446a		       a9 e0		      lda	#>font
   1401  446c		       85 43		      sta	temp2
   1402  446e
   1403  446e		       ad 06 21 	      lda	charactermode
   1404  4471		       85 4a		      sta	temp9
   1405  4473		       a9 60		      lda	#(font_mode | %01100000)
   1406  4475		       8d 06 21 	      sta	charactermode
   1407  4478		       a9 1e		      lda	#30	; width in two's complement
   1408  447a		       09 e0		      ora	#224	; palette left shifted 5 bits
   1409  447c		       85 44		      sta	temp3
   1410  447e		       a9 1e		      lda	#30
   1411  4480		       85 45		      sta	temp4
   1412  4482
   1413  4482		       a9 0b		      lda	#11
   1414  4484		       85 46		      sta	temp5
   1415  4486
   1416  4486		       a9 02		      lda	#2
   1417  4488		       85 47		      sta	temp6
   1418  448a
   1419  448a		       a9 ff		      lda	#<z
   1420  448c		       85 48		      sta	temp7
   1421  448e
   1422  448e		       a9 00		      lda	#>z
   1423  4490		       85 49		      sta	temp8
   1424  4492
   1425  4492		       20 9f f3 	      jsr	plotvalue
   1426  4492		       00 01	   USED_PLOTVALUE =	1
   1427  4495		       a5 4a		      lda	temp9
   1428  4497		       8d 06 21 	      sta	charactermode
   1429  449a				   .L0122		;;  drawscreen
   1430  449a
   1431  449a		       20 ab f0 	      jsr	drawscreen
   1432  449d				   .L0123		;;  z	=  0
   1433  449d
   1434  449d		       a9 00		      LDA	#0
   1435  449f		       85 ff		      STA	z
   1436  44a1				   .L0124		;;  goto _screen3
   1437  44a1
   1438  44a1		       4c fb 42 	      jmp	._screen3
   1439  44a4
   1440  44a4				   .
   1441  44a4							;; 
   1442  44a4
   1443  44a4				   .L0125		;;  rem draw sprites with arrow no bg animated
   1444  44a4
   1445  44a4				   .
   1446  44a4							;; 
   1447  44a4
   1448  44a4				   ._screen4_setup
   1449  44a4							;; _screen4_setup
   1450  44a4
   1451  44a4				   .L0126		;;  m	=  0
   1452  44a4
   1453  44a4		       a9 00		      LDA	#0
   1454  44a6		       85 f2		      STA	m
   1455  44a8				   .L0127		;;  n	=  0
   1456  44a8
   1457  44a8		       a9 00		      LDA	#0
   1458  44aa		       85 f3		      STA	n
   1459  44ac				   .L0128		;;  c	=  0
   1460  44ac
   1461  44ac		       a9 00		      LDA	#0
   1462  44ae		       85 e8		      STA	c
   1463  44b0				   .L0129		;;  f	=  0
   1464  44b0
   1465  44b0		       a9 00		      LDA	#0
   1466  44b2		       85 eb		      STA	f
   1467  44b4				   ._screen4
   1468  44b4							;; _screen4
   1469  44b4
   1470  44b4				   .L0130		;;  clearscreen
   1471  44b4
   1472  44b4		       20 77 f0 	      jsr	clearscreen
   1473  44b7				   .L0131		;;  y	=  0
   1474  44b7
   1475  44b7		       a9 00		      LDA	#0
   1476  44b9		       85 fe		      STA	y
   1477  44bb				   .L0132		;;  x	=  0
   1478  44bb
   1479  44bb		       a9 00		      LDA	#0
   1480  44bd		       85 fd		      STA	x
   1481  44bf				   .L0133		;;  c	=  0
   1482  44bf
   1483  44bf		       a9 00		      LDA	#0
   1484  44c1		       85 e8		      STA	c
   1485  44c3				   .L0134		;;  for i  =  0 to n
   1486  44c3
   1487  44c3		       a9 00		      LDA	#0
   1488  44c5		       85 ee		      STA	i
   1489  44c7				   .L0134fori
   1490  44c7				   .L0135		;;  for j  =  0 to m
   1491  44c7
   1492  44c7		       a9 00		      LDA	#0
   1493  44c9		       85 ef		      STA	j
   1494  44cb				   .L0135forj
   1495  44cb				   .L0136		;;  plotsprite g16x16_4color c x y f
   1496  44cb
   1497  44cb		       a9 00		      lda	#<g16x16_4color
   1498  44cd		       a0 04		      ldy	#g16x16_4color_width
   1499  44cf		       18		      clc
   1500  44d0		       f0 05		      beq	plotspritewidthskip3
   1501  44d2				   plotspritewidthloop3
   1502  44d2		       65 eb		      adc	f
   1503  44d4		       88		      dey
   1504  44d5		       d0 fb		      bne	plotspritewidthloop3
   1505  44d7				   plotspritewidthskip3
   1506  44d7		       85 42		      sta	temp1
   1507  44d9
   1508  44d9		       a9 e0		      lda	#>g16x16_4color
   1509  44db		       85 43		      sta	temp2
   1510  44dd
   1511  44dd		       a5 e8		      lda	c
   1512  44df		       0a		      asl
   1513  44e0		       0a		      asl
   1514  44e1		       0a		      asl
   1515  44e2		       0a		      asl
   1516  44e3		       0a		      asl
   1517  44e4		       09 1c		      ora	#g16x16_4color_width_twoscompliment
   1518  44e6		       85 44		      sta	temp3
   1519  44e8
   1520  44e8		       a5 fd		      lda	x
   1521  44ea		       85 45		      sta	temp4
   1522  44ec
   1523  44ec		       a5 fe		      lda	y
   1524  44ee		       85 46		      sta	temp5
   1525  44f0
   1526  44f0		       a9 40		      lda	#(g16x16_4color_mode|%01000000)
   1527  44f2		       85 47		      sta	temp6
   1528  44f4
   1529  44f4		       20 8b f2 	      jsr	plotsprite
   1530  44f7				   .L0137		;;  x	=  x  +  16
   1531  44f7
   1532  44f7		       a5 fd		      LDA	x
   1533  44f9		       18		      CLC
   1534  44fa		       69 10		      ADC	#16
   1535  44fc		       85 fd		      STA	x
   1536  44fe				   .L0138		;;  next
   1537  44fe
   1538  44fe		       a5 ef		      LDA	j
   1539  4500		       c5 f2		      CMP	m
   1540  4502		       e6 ef		      INC	j
   1541  4504					      if	((* - .L0135forj) < 127) && ((* - .L0135forj) > -128)
   1542  4504		       90 c5		      bcc	.L0135forj
   1543  4506				  -	      else
   1544  4506				  -	      bcs	.4skipL0135forj
   1545  4506				  -	      jmp	.L0135forj
   1546  4506				  -.4skipL0135forj
   1547  4506					      endif
   1548  4506				   .L0139		;;  x	=  0
   1549  4506
   1550  4506		       a9 00		      LDA	#0
   1551  4508		       85 fd		      STA	x
   1552  450a				   .L0140		;;  y	=  y  +  16
   1553  450a
   1554  450a		       a5 fe		      LDA	y
   1555  450c		       18		      CLC
   1556  450d		       69 10		      ADC	#16
   1557  450f		       85 fe		      STA	y
   1558  4511				   .L0141		;;  c	=  c  +  1
   1559  4511
   1560  4511		       a5 e8		      LDA	c
   1561  4513		       18		      CLC
   1562  4514		       69 01		      ADC	#1
   1563  4516		       85 e8		      STA	c
   1564  4518				   .L0142		;;  if c  >  6 then c	=  0
   1565  4518
   1566  4518		       a9 06		      LDA	#6
   1567  451a		       c5 e8		      CMP	c
   1568  451c		       b0 04		      BCS	.skipL0142
   1569  451e				   .condpart28
   1570  451e		       a9 00		      LDA	#0
   1571  4520		       85 e8		      STA	c
   1572  4522				   .skipL0142
   1573  4522				   .L0143		;;  next
   1574  4522
   1575  4522		       a5 ee		      LDA	i
   1576  4524		       c5 f3		      CMP	n
   1577  4526		       e6 ee		      INC	i
   1578  4528					      if	((* - .L0134fori) < 127) && ((* - .L0134fori) > -128)
   1579  4528		       90 9d		      bcc	.L0134fori
   1580  452a				  -	      else
   1581  452a				  -	      bcs	.5skipL0134fori
   1582  452a				  -	      jmp	.L0134fori
   1583  452a				  -.5skipL0134fori
   1584  452a					      endif
   1585  452a				   .L0144		;;  if w  >  8  &&  joy0right then w  = 0  :  m  =  m	+  1
   1586  452a
   1587  452a		       a9 08		      LDA	#8
   1588  452c		       c5 fc		      CMP	w
   1589  452e		       b0 10		      BCS	.skipL0144
   1590  4530				   .condpart29
   1591  4530		       2c 80 02 	      bit	SWCHA
   1592  4533		       30 0b		      BMI	.skip29then
   1593  4535				   .condpart30
   1594  4535		       a9 00		      LDA	#0
   1595  4537		       85 fc		      STA	w
   1596  4539		       a5 f2		      LDA	m
   1597  453b		       18		      CLC
   1598  453c		       69 01		      ADC	#1
   1599  453e		       85 f2		      STA	m
   1600  4540				   .skip29then
   1601  4540				   .skipL0144
   1602  4540				   .L0145		;;  if w  >  8  &&  joy0down then w  =  0  :  n  =  n	+  1
   1603  4540
   1604  4540		       a9 08		      LDA	#8
   1605  4542		       c5 fc		      CMP	w
   1606  4544		       b0 12		      BCS	.skipL0145
   1607  4546				   .condpart31
   1608  4546		       a9 20		      lda	#$20
   1609  4548		       2c 80 02 	      bit	SWCHA
   1610  454b		       d0 0b		      BNE	.skip31then
   1611  454d				   .condpart32
   1612  454d		       a9 00		      LDA	#0
   1613  454f		       85 fc		      STA	w
   1614  4551		       a5 f3		      LDA	n
   1615  4553		       18		      CLC
   1616  4554		       69 01		      ADC	#1
   1617  4556		       85 f3		      STA	n
   1618  4558				   .skip31then
   1619  4558				   .skipL0145
   1620  4558				   .L0146		;;  if w  >  8  &&  joy0left then w  = 0  :  m  =  m  -  1
   1621  4558
   1622  4558		       a9 08		      LDA	#8
   1623  455a		       c5 fc		      CMP	w
   1624  455c		       b0 10		      BCS	.skipL0146
   1625  455e				   .condpart33
   1626  455e		       2c 80 02 	      bit	SWCHA
   1627  4561		       70 0b		      BVS	.skip33then
   1628  4563				   .condpart34
   1629  4563		       a9 00		      LDA	#0
   1630  4565		       85 fc		      STA	w
   1631  4567		       a5 f2		      LDA	m
   1632  4569		       38		      SEC
   1633  456a		       e9 01		      SBC	#1
   1634  456c		       85 f2		      STA	m
   1635  456e				   .skip33then
   1636  456e				   .skipL0146
   1637  456e				   .L0147		;;  if w  >  8  &&  joy0up then w  =  0  :  n	=  n  -  1
   1638  456e
   1639  456e		       a9 08		      LDA	#8
   1640  4570		       c5 fc		      CMP	w
   1641  4572		       b0 12		      BCS	.skipL0147
   1642  4574				   .condpart35
   1643  4574		       a9 10		      lda	#$10
   1644  4576		       2c 80 02 	      bit	SWCHA
   1645  4579		       d0 0b		      BNE	.skip35then
   1646  457b				   .condpart36
   1647  457b		       a9 00		      LDA	#0
   1648  457d		       85 fc		      STA	w
   1649  457f		       a5 f3		      LDA	n
   1650  4581		       38		      SEC
   1651  4582		       e9 01		      SBC	#1
   1652  4584		       85 f3		      STA	n
   1653  4586				   .skip35then
   1654  4586				   .skipL0147
   1655  4586				   .L0148		;;  if w  >  8  &&  joy0fire then w  =  0  :  goto _screen4
   1656  4586
   1657  4586		       a9 08		      LDA	#8
   1658  4588		       c5 fc		      CMP	w
   1659  458a		       b0 0c		      BCS	.skipL0148
   1660  458c				   .condpart37
   1661  458c		       2c 02 21 	      bit	sINPT1
   1662  458f		       10 07		      BPL	.skip37then
   1663  4591				   .condpart38
   1664  4591		       a9 00		      LDA	#0
   1665  4593		       85 fc		      STA	w
   1666  4595		       4c b4 44 	      jmp	._screen4
   1667  4598
   1668  4598				   .skip37then
   1669  4598				   .skipL0148
   1670  4598				   .L0149		;;  w	=  w  +  1
   1671  4598
   1672  4598		       a5 fc		      LDA	w
   1673  459a		       18		      CLC
   1674  459b		       69 01		      ADC	#1
   1675  459d		       85 fc		      STA	w
   1676  459f				   .L0150		;;  f	=  f  +  1
   1677  459f
   1678  459f		       a5 eb		      LDA	f
   1679  45a1		       18		      CLC
   1680  45a2		       69 01		      ADC	#1
   1681  45a4		       85 eb		      STA	f
   1682  45a6				   .L0151		;;  if f  >  3 then f	=  0
   1683  45a6
   1684  45a6		       a9 03		      LDA	#3
   1685  45a8		       c5 eb		      CMP	f
   1686  45aa		       b0 04		      BCS	.skipL0151
   1687  45ac				   .condpart39
   1688  45ac		       a9 00		      LDA	#0
   1689  45ae		       85 eb		      STA	f
   1690  45b0				   .skipL0151
   1691  45b0				   .L0152		;;  if n  >  24 then n  =  0
   1692  45b0
   1693  45b0		       a9 18		      LDA	#24
   1694  45b2		       c5 f3		      CMP	n
   1695  45b4		       b0 04		      BCS	.skipL0152
   1696  45b6				   .condpart40
   1697  45b6		       a9 00		      LDA	#0
   1698  45b8		       85 f3		      STA	n
   1699  45ba				   .skipL0152
   1700  45ba				   .L0153		;;  if m  >  20 then m  =  0
   1701  45ba
   1702  45ba		       a9 14		      LDA	#20
   1703  45bc		       c5 f2		      CMP	m
   1704  45be		       b0 04		      BCS	.skipL0153
   1705  45c0				   .condpart41
   1706  45c0		       a9 00		      LDA	#0
   1707  45c2		       85 f2		      STA	m
   1708  45c4				   .skipL0153
   1709  45c4				   .L0154		;;  r	=  n  +  1
   1710  45c4
   1711  45c4		       a5 f3		      LDA	n
   1712  45c6		       18		      CLC
   1713  45c7		       69 01		      ADC	#1
   1714  45c9		       85 f7		      STA	r
   1715  45cb				   .L0155		;;  s	=  m  +  1
   1716  45cb
   1717  45cb		       a5 f2		      LDA	m
   1718  45cd		       18		      CLC
   1719  45ce		       69 01		      ADC	#1
   1720  45d0		       85 f8		      STA	s
   1721  45d2				   .L0156		;;  plotvalue font 7 s 2 10 11 doublewide
   1722  45d2
   1723  45d2		       a9 24		      lda	#<font
   1724  45d4		       85 42		      sta	temp1
   1725  45d6
   1726  45d6		       a9 e0		      lda	#>font
   1727  45d8		       85 43		      sta	temp2
   1728  45da
   1729  45da		       ad 06 21 	      lda	charactermode
   1730  45dd		       85 4a		      sta	temp9
   1731  45df		       a9 60		      lda	#(font_mode | %01100000)
   1732  45e1		       8d 06 21 	      sta	charactermode
   1733  45e4		       a9 1e		      lda	#30	; width in two's complement
   1734  45e6		       09 e0		      ora	#224	; palette left shifted 5 bits
   1735  45e8		       85 44		      sta	temp3
   1736  45ea		       a9 0a		      lda	#10
   1737  45ec		       85 45		      sta	temp4
   1738  45ee
   1739  45ee		       a9 0b		      lda	#11
   1740  45f0		       85 46		      sta	temp5
   1741  45f2
   1742  45f2		       a9 02		      lda	#2
   1743  45f4		       85 47		      sta	temp6
   1744  45f6
   1745  45f6		       a9 f8		      lda	#<s
   1746  45f8		       85 48		      sta	temp7
   1747  45fa
   1748  45fa		       a9 00		      lda	#>s
   1749  45fc		       85 49		      sta	temp8
   1750  45fe
   1751  45fe		       20 9f f3 	      jsr	plotvalue
   1752  45fe		       00 01	   USED_PLOTVALUE =	1
   1753  4601		       a5 4a		      lda	temp9
   1754  4603		       8d 06 21 	      sta	charactermode
   1755  4606				   .L0157		;;  plotvalue font 7 r 2 20 11 doublewide
   1756  4606
   1757  4606		       a9 24		      lda	#<font
   1758  4608		       85 42		      sta	temp1
   1759  460a
   1760  460a		       a9 e0		      lda	#>font
   1761  460c		       85 43		      sta	temp2
   1762  460e
   1763  460e		       ad 06 21 	      lda	charactermode
   1764  4611		       85 4a		      sta	temp9
   1765  4613		       a9 60		      lda	#(font_mode | %01100000)
   1766  4615		       8d 06 21 	      sta	charactermode
   1767  4618		       a9 1e		      lda	#30	; width in two's complement
   1768  461a		       09 e0		      ora	#224	; palette left shifted 5 bits
   1769  461c		       85 44		      sta	temp3
   1770  461e		       a9 14		      lda	#20
   1771  4620		       85 45		      sta	temp4
   1772  4622
   1773  4622		       a9 0b		      lda	#11
   1774  4624		       85 46		      sta	temp5
   1775  4626
   1776  4626		       a9 02		      lda	#2
   1777  4628		       85 47		      sta	temp6
   1778  462a
   1779  462a		       a9 f7		      lda	#<r
   1780  462c		       85 48		      sta	temp7
   1781  462e
   1782  462e		       a9 00		      lda	#>r
   1783  4630		       85 49		      sta	temp8
   1784  4632
   1785  4632		       20 9f f3 	      jsr	plotvalue
   1786  4632		       00 01	   USED_PLOTVALUE =	1
   1787  4635		       a5 4a		      lda	temp9
   1788  4637		       8d 06 21 	      sta	charactermode
   1789  463a				   .L0158		;;  plotvalue font 7 z 2 30 11 doublewide
   1790  463a
   1791  463a		       a9 24		      lda	#<font
   1792  463c		       85 42		      sta	temp1
   1793  463e
   1794  463e		       a9 e0		      lda	#>font
   1795  4640		       85 43		      sta	temp2
   1796  4642
   1797  4642		       ad 06 21 	      lda	charactermode
   1798  4645		       85 4a		      sta	temp9
   1799  4647		       a9 60		      lda	#(font_mode | %01100000)
   1800  4649		       8d 06 21 	      sta	charactermode
   1801  464c		       a9 1e		      lda	#30	; width in two's complement
   1802  464e		       09 e0		      ora	#224	; palette left shifted 5 bits
   1803  4650		       85 44		      sta	temp3
   1804  4652		       a9 1e		      lda	#30
   1805  4654		       85 45		      sta	temp4
   1806  4656
   1807  4656		       a9 0b		      lda	#11
   1808  4658		       85 46		      sta	temp5
   1809  465a
   1810  465a		       a9 02		      lda	#2
   1811  465c		       85 47		      sta	temp6
   1812  465e
   1813  465e		       a9 ff		      lda	#<z
   1814  4660		       85 48		      sta	temp7
   1815  4662
   1816  4662		       a9 00		      lda	#>z
   1817  4664		       85 49		      sta	temp8
   1818  4666
   1819  4666		       20 9f f3 	      jsr	plotvalue
   1820  4666		       00 01	   USED_PLOTVALUE =	1
   1821  4669		       a5 4a		      lda	temp9
   1822  466b		       8d 06 21 	      sta	charactermode
   1823  466e				   .L0159		;;  drawscreen
   1824  466e
   1825  466e		       20 ab f0 	      jsr	drawscreen
   1826  4671				   .L0160		;;  z	=  0
   1827  4671
   1828  4671		       a9 00		      LDA	#0
   1829  4673		       85 ff		      STA	z
   1830  4675				   .L0161		;;  goto _screen4
   1831  4675
   1832  4675		       4c b4 44 	      jmp	._screen4
   1833  4678
   1834  4678				   .
   1835  4678							;; 
   1836  4678
   1837  4678				   .drawZoneBG
   1838  4678							;; drawZoneBG
   1839  4678
   1840  4678				   .L0162		;;  x	=  0
   1841  4678
   1842  4678		       a9 00		      LDA	#0
   1843  467a		       85 fd		      STA	x
   1844  467c				   .L0163		;;  y	=  0
   1845  467c
   1846  467c		       a9 00		      LDA	#0
   1847  467e		       85 fe		      STA	y
   1848  4680				   .L0164		;;  for j  =  0 to 12
   1849  4680
   1850  4680		       a9 00		      LDA	#0
   1851  4682		       85 ef		      STA	j
   1852  4684				   .L0164forj
   1853  4684				   .L0165		;;  for i  =  0 to 1
   1854  4684
   1855  4684		       a9 00		      LDA	#0
   1856  4686		       85 ee		      STA	i
   1857  4688				   .L0165fori
   1858  4688				   .L0166		;;  plotsprite zonebg80x16_16 7 x y 0
   1859  4688
   1860  4688		       a9 10		      lda	#<zonebg80x16_16
   1861  468a		       85 42		      sta	temp1
   1862  468c
   1863  468c		       a9 e0		      lda	#>zonebg80x16_16
   1864  468e		       85 43		      sta	temp2
   1865  4690
   1866  4690		       a9 ec		      lda	#(224|zonebg80x16_16_width_twoscompliment)
   1867  4692		       85 44		      sta	temp3
   1868  4694
   1869  4694		       a5 fd		      lda	x
   1870  4696		       85 45		      sta	temp4
   1871  4698
   1872  4698		       a5 fe		      lda	y
   1873  469a		       85 46		      sta	temp5
   1874  469c
   1875  469c		       a9 40		      lda	#(zonebg80x16_16_mode|%01000000)
   1876  469e		       85 47		      sta	temp6
   1877  46a0
   1878  46a0		       20 8b f2 	      jsr	plotsprite
   1879  46a3				   .L0167		;;  x	=  x  +  80
   1880  46a3
   1881  46a3		       a5 fd		      LDA	x
   1882  46a5		       18		      CLC
   1883  46a6		       69 50		      ADC	#80
   1884  46a8		       85 fd		      STA	x
   1885  46aa				   .L0168		;;  next
   1886  46aa
   1887  46aa		       a5 ee		      LDA	i
   1888  46ac		       c9 01		      CMP	#1
   1889  46ae		       e6 ee		      INC	i
   1890  46b0					      if	((* - .L0165fori) < 127) && ((* - .L0165fori) > -128)
   1891  46b0		       90 d6		      bcc	.L0165fori
   1892  46b2				  -	      else
   1893  46b2				  -	      bcs	.6skipL0165fori
   1894  46b2				  -	      jmp	.L0165fori
   1895  46b2				  -.6skipL0165fori
   1896  46b2					      endif
   1897  46b2				   .L0169		;;  x	=  0
   1898  46b2
   1899  46b2		       a9 00		      LDA	#0
   1900  46b4		       85 fd		      STA	x
   1901  46b6				   .L0170		;;  y	=  y  +  16
   1902  46b6
   1903  46b6		       a5 fe		      LDA	y
   1904  46b8		       18		      CLC
   1905  46b9		       69 10		      ADC	#16
   1906  46bb		       85 fe		      STA	y
   1907  46bd				   .L0171		;;  next
   1908  46bd
   1909  46bd		       a5 ef		      LDA	j
   1910  46bf		       c9 0c		      CMP	#12
   1911  46c1		       e6 ef		      INC	j
   1912  46c3					      if	((* - .L0164forj) < 127) && ((* - .L0164forj) > -128)
   1913  46c3		       90 bf		      bcc	.L0164forj
   1914  46c5				  -	      else
   1915  46c5				  -	      bcs	.7skipL0164forj
   1916  46c5				  -	      jmp	.L0164forj
   1917  46c5				  -.7skipL0164forj
   1918  46c5					      endif
   1919  46c5				   .L0172		;;  savescreen
   1920  46c5
   1921  46c5		       20 9b f0 	      jsr	savescreen
   1922  46c8				   .L0173		;;  return
   1923  46c8
   1924  46c8		       60		      RTS
   1925  46c9				   .
   1926  46c9							;; 
   1927  46c9
   1928  46c9				   .topscreenroutine
   1929  46c9							;; topscreenroutine
   1930  46c9
   1931  46c9				   .L0174		;;  z	=  z  +  1
   1932  46c9
   1933  46c9		       a5 ff		      LDA	z
   1934  46cb		       18		      CLC
   1935  46cc		       69 01		      ADC	#1
   1936  46ce		       85 ff		      STA	z
   1937  46d0				   .L0175		;;  return
   1938  46d0		       60		      RTS
   1939  46d0				   DMAHOLEEND0 SET	.
   1940  46d1				   gameend
   1941  46d1				   DMAHOLEEND0 SET	.
   39215 bytes of ROM space left in the main area.
   1942  46d1					      echo	" ",[($E000 - gameend)]d , "bytes of ROM space left in the main area."
   1943  46d1
   1944  e000					      ORG	$E000,0	; *************
   1945  e000
   1946  e000				   g16x16_4color
   1947  e000		       55 55 55 55	      HEX	55555555
   1948  e004				   g16x16_4color2
   1949  e004		       00 00 00 00	      HEX	00000000
   1950  e008				   g16x16_4color3
   1951  e008		       00 00 00 00	      HEX	00000000
   1952  e00c				   g16x16_4color4
   1953  e00c		       00 00 00 00	      HEX	00000000
   1954  e010				   zonebg80x16_16
   1955  e010		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   1956  e024				   font
   1957  e024		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1958  e044		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1959  e059
   1960  e100					      ORG	$E100,0	; *************
   1961  e100
   1962  e100							;g16x16_4color
   1963  e100		       55 55 55 55	      HEX	55555555
   1964  e104							;g16x16_4color2
   1965  e104		       00 00 00 00	      HEX	00000000
   1966  e108							;g16x16_4color3
   1967  e108		       00 00 00 00	      HEX	00000000
   1968  e10c							;g16x16_4color4
   1969  e10c		       00 00 00 00	      HEX	00000000
   1970  e110							;zonebg80x16_16
   1971  e110		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   1972  e124							;font
   1973  e124		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1974  e144		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1975  e159
   1976  e200					      ORG	$E200,0	; *************
   1977  e200
   1978  e200							;g16x16_4color
   1979  e200		       5a aa aa a5	      HEX	5aaaaaa5
   1980  e204							;g16x16_4color2
   1981  e204		       05 55 55 50	      HEX	05555550
   1982  e208							;g16x16_4color3
   1983  e208		       00 00 00 00	      HEX	00000000
   1984  e20c							;g16x16_4color4
   1985  e20c		       00 00 00 00	      HEX	00000000
   1986  e210							;zonebg80x16_16
   1987  e210		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   1988  e224							;font
   1989  e224		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1990  e244		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1991  e259
   1992  e300					      ORG	$E300,0	; *************
   1993  e300
   1994  e300							;g16x16_4color
   1995  e300		       5a aa aa a5	      HEX	5aaaaaa5
   1996  e304							;g16x16_4color2
   1997  e304		       05 55 55 50	      HEX	05555550
   1998  e308							;g16x16_4color3
   1999  e308		       00 00 00 00	      HEX	00000000
   2000  e30c							;g16x16_4color4
   2001  e30c		       00 00 00 00	      HEX	00000000
   2002  e310							;zonebg80x16_16
   2003  e310		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2004  e324							;font
   2005  e324		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2006  e344		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2007  e359
   2008  e400					      ORG	$E400,0	; *************
   2009  e400
   2010  e400							;g16x16_4color
   2011  e400		       5a ff ff a5	      HEX	5affffa5
   2012  e404							;g16x16_4color2
   2013  e404		       05 aa aa 50	      HEX	05aaaa50
   2014  e408							;g16x16_4color3
   2015  e408		       00 55 55 00	      HEX	00555500
   2016  e40c							;g16x16_4color4
   2017  e40c		       00 00 00 00	      HEX	00000000
   2018  e410							;zonebg80x16_16
   2019  e410		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2020  e424							;font
   2021  e424		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2022  e444		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2023  e459
   2024  e500					      ORG	$E500,0	; *************
   2025  e500
   2026  e500							;g16x16_4color
   2027  e500		       5a ff ff a5	      HEX	5affffa5
   2028  e504							;g16x16_4color2
   2029  e504		       05 aa aa 50	      HEX	05aaaa50
   2030  e508							;g16x16_4color3
   2031  e508		       00 55 55 00	      HEX	00555500
   2032  e50c							;g16x16_4color4
   2033  e50c		       00 00 00 00	      HEX	00000000
   2034  e510							;zonebg80x16_16
   2035  e510		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2036  e524							;font
   2037  e524		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2038  e544		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2039  e559
   2040  e600					      ORG	$E600,0	; *************
   2041  e600
   2042  e600							;g16x16_4color
   2043  e600		       5a ff ff a5	      HEX	5affffa5
   2044  e604							;g16x16_4color2
   2045  e604		       05 aa aa 50	      HEX	05aaaa50
   2046  e608							;g16x16_4color3
   2047  e608		       00 55 55 00	      HEX	00555500
   2048  e60c							;g16x16_4color4
   2049  e60c		       00 00 00 00	      HEX	00000000
   2050  e610							;zonebg80x16_16
   2051  e610		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2052  e624							;font
   2053  e624		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2054  e644		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2055  e659
   2056  e700					      ORG	$E700,0	; *************
   2057  e700
   2058  e700							;g16x16_4color
   2059  e700		       5a ff ff a5	      HEX	5affffa5
   2060  e704							;g16x16_4color2
   2061  e704		       05 aa aa 50	      HEX	05aaaa50
   2062  e708							;g16x16_4color3
   2063  e708		       00 55 55 00	      HEX	00555500
   2064  e70c							;g16x16_4color4
   2065  e70c		       00 00 00 00	      HEX	00000000
   2066  e710							;zonebg80x16_16
   2067  e710		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2068  e724							;font
   2069  e724		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2070  e744		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2071  e759
   2072  e800					      ORG	$E800,0	; *************
   2073  e800
   2074  e800							;g16x16_4color
   2075  e800		       5a ff ff a5	      HEX	5affffa5
   2076  e804							;g16x16_4color2
   2077  e804		       05 aa aa 50	      HEX	05aaaa50
   2078  e808							;g16x16_4color3
   2079  e808		       00 55 55 00	      HEX	00555500
   2080  e80c							;g16x16_4color4
   2081  e80c		       00 00 00 00	      HEX	00000000
   2082  e810							;zonebg80x16_16
   2083  e810		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2084  e824							;font
   2085  e824		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2086  e844		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   2087  e859
   2088  e900					      ORG	$E900,0	; *************
   2089  e900
   2090  e900							;g16x16_4color
   2091  e900		       5a ff ff a5	      HEX	5affffa5
   2092  e904							;g16x16_4color2
   2093  e904		       05 aa aa 50	      HEX	05aaaa50
   2094  e908							;g16x16_4color3
   2095  e908		       00 55 55 00	      HEX	00555500
   2096  e90c							;g16x16_4color4
   2097  e90c		       00 00 00 00	      HEX	00000000
   2098  e910							;zonebg80x16_16
   2099  e910		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2100  e924							;font
   2101  e924		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   2102  e944		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   2103  e959
   2104  ea00					      ORG	$EA00,0	; *************
   2105  ea00
   2106  ea00							;g16x16_4color
   2107  ea00		       5a ff ff a5	      HEX	5affffa5
   2108  ea04							;g16x16_4color2
   2109  ea04		       05 aa aa 50	      HEX	05aaaa50
   2110  ea08							;g16x16_4color3
   2111  ea08		       00 55 55 00	      HEX	00555500
   2112  ea0c							;g16x16_4color4
   2113  ea0c		       00 00 00 00	      HEX	00000000
   2114  ea10							;zonebg80x16_16
   2115  ea10		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2116  ea24							;font
   2117  ea24		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   2118  ea44		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   2119  ea59
   2120  eb00					      ORG	$EB00,0	; *************
   2121  eb00
   2122  eb00							;g16x16_4color
   2123  eb00		       5a ff ff a5	      HEX	5affffa5
   2124  eb04							;g16x16_4color2
   2125  eb04		       05 aa aa 50	      HEX	05aaaa50
   2126  eb08							;g16x16_4color3
   2127  eb08		       00 55 55 00	      HEX	00555500
   2128  eb0c							;g16x16_4color4
   2129  eb0c		       00 00 00 00	      HEX	00000000
   2130  eb10							;zonebg80x16_16
   2131  eb10		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2132  eb24							;font
   2133  eb24		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   2134  eb44		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   2135  eb59
   2136  ec00					      ORG	$EC00,0	; *************
   2137  ec00
   2138  ec00							;g16x16_4color
   2139  ec00		       5a aa aa a5	      HEX	5aaaaaa5
   2140  ec04							;g16x16_4color2
   2141  ec04		       05 55 55 50	      HEX	05555550
   2142  ec08							;g16x16_4color3
   2143  ec08		       00 00 00 00	      HEX	00000000
   2144  ec0c							;g16x16_4color4
   2145  ec0c		       00 00 00 00	      HEX	00000000
   2146  ec10							;zonebg80x16_16
   2147  ec10		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2148  ec24							;font
   2149  ec24		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   2150  ec44		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   2151  ec59
   2152  ed00					      ORG	$ED00,0	; *************
   2153  ed00
   2154  ed00							;g16x16_4color
   2155  ed00		       5a aa aa a5	      HEX	5aaaaaa5
   2156  ed04							;g16x16_4color2
   2157  ed04		       05 55 55 50	      HEX	05555550
   2158  ed08							;g16x16_4color3
   2159  ed08		       00 00 00 00	      HEX	00000000
   2160  ed0c							;g16x16_4color4
   2161  ed0c		       00 00 00 00	      HEX	00000000
   2162  ed10							;zonebg80x16_16
   2163  ed10		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2164  ed24							;font
   2165  ed24		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   2166  ed44		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   2167  ed59
   2168  ee00					      ORG	$EE00,0	; *************
   2169  ee00
   2170  ee00							;g16x16_4color
   2171  ee00		       55 55 55 55	      HEX	55555555
   2172  ee04							;g16x16_4color2
   2173  ee04		       00 00 00 00	      HEX	00000000
   2174  ee08							;g16x16_4color3
   2175  ee08		       00 00 00 00	      HEX	00000000
   2176  ee0c							;g16x16_4color4
   2177  ee0c		       00 00 00 00	      HEX	00000000
   2178  ee10							;zonebg80x16_16
   2179  ee10		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000
   2180  ee24							;font
   2181  ee24		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   2182  ee44		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   2183  ee59
   2184  ef00					      ORG	$EF00,0	; *************
   2185  ef00
   2186  ef00							;g16x16_4color
   2187  ef00		       55 55 55 55	      HEX	55555555
   2188  ef04							;g16x16_4color2
   2189  ef04		       00 00 00 00	      HEX	00000000
   2190  ef08							;g16x16_4color3
   2191  ef08		       00 00 00 00	      HEX	00000000
   2192  ef0c							;g16x16_4color4
   2193  ef0c		       00 00 00 00	      HEX	00000000
   2194  ef10							;zonebg80x16_16
   2195  ef10		       55 55 55 55*	      HEX	5555555555555555555555555555555555555555
   2196  ef24							;font
   2197  ef24		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   2198  ef44		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   2199  ef59
   2200  ef59
   2201  ef59							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2202  ef59
   2203  ef59					      ifnconst	bankswitchmode
   2204  ef59					      if	( * < $f000 )
   2205  f000					      ORG	$F000
   2206  f000					      endif
   2207  f000				  -	      else
   2208  f000				  -	      ifconst	ROM128K
   2209  f000				  -	      if	( * < $f000 )
   2210  f000				  -	      ORG	$27000
   2211  f000				  -	      RORG	$F000
   2212  f000				  -	      endif
   2213  f000				  -	      endif
   2214  f000				  -	      ifconst	ROM144K
   2215  f000				  -	      if	( * < $f000 )
   2216  f000				  -	      ORG	$27000
   2217  f000				  -	      RORG	$F000
   2218  f000				  -	      endif
   2219  f000				  -	      endif
   2220  f000				  -	      ifconst	ROM256K
   2221  f000				  -	      if	( * < $f000 )
   2222  f000				  -	      ORG	$47000
   2223  f000				  -	      RORG	$F000
   2224  f000				  -	      endif
   2225  f000				  -	      endif
   2226  f000				  -	      ifconst	ROM272K
   2227  f000				  -	      if	( * < $f000 )
   2228  f000				  -	      ORG	$47000
   2229  f000				  -	      RORG	$F000
   2230  f000				  -	      endif
   2231  f000				  -	      endif
   2232  f000				  -	      ifconst	ROM512K
   2233  f000				  -	      if	( * < $f000 )
   2234  f000				  -	      ORG	$87000
   2235  f000				  -	      RORG	$F000
   2236  f000				  -	      endif
   2237  f000				  -	      endif
   2238  f000				  -	      ifconst	ROM528K
   2239  f000				  -	      if	( * < $f000 )
   2240  f000				  -	      ORG	$87000
   2241  f000				  -	      RORG	$F000
   2242  f000				  -	      endif
   2243  f000				  -	      endif
   2244  f000					      endif
   2245  f000
   2246  f000							; all of these "modules" have conditional clauses in them, so even though
   2247  f000							; they're always included here, they don't take up rom unless the user
   2248  f000							; explicitly enables support for the feature.
   2249  f000
   2250  f000					      ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  f000					      include	7800vox.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000							; AtariVox 7800basic wrapper
      4  f000
      5  f000							; to be called with
      6  f000							; A=# of bytes
      7  f000							;
      8  f000
      9  f000				  -	      ifconst	HSSUPPORT
     10  f000				  -
     11  f000				  -AVoxReadBytes
     12  f000				  -	      sta	temp8
     13  f000				  -	      jsr	i2c_startwrite
     14  f000				  -	      bcs	eeprom_error
     15  f000				  -
     16  f000				  -	      lda	HSVoxHi
     17  f000				  -	      jsr	i2c_txbyte
     18  f000				  -	      lda	HSVoxLo
     19  f000				  -	      jsr	i2c_txbyte
     20  f000				  -	      jsr	i2c_stopwrite
     21  f000				  -
     22  f000				  -	      jsr	i2c_startread
     23  f000				  -
     24  f000				  -	      ldx	#0
     25  f000				  -AVoxReadBytesLoop
     26  f000				  -	      jsr	i2c_rxbyte
     27  f000				  -	      sta	eeprombuffer,x
     28  f000				  -	      inx
     29  f000				  -	      cpx	temp8
     30  f000				  -	      bne	AVoxReadBytesLoop
     31  f000				  -	      jsr	i2c_stopread
     32  f000				  -	      lda	#0
     33  f000				  -	      rts
     34  f000				  -
     35  f000				  -			; to be called with
     36  f000				  -			; A=# of bytes
     37  f000				  -			;
     38  f000				  -
     39  f000				  -AVoxWriteBytes
     40  f000				  -	      sta	temp8
     41  f000				  -	      jsr	i2c_startwrite
     42  f000				  -	      bcs	eeprom_error
     43  f000				  -
     44  f000				  -	      lda	HSVoxHi
     45  f000				  -	      jsr	i2c_txbyte
     46  f000				  -	      lda	HSVoxLo
     47  f000				  -	      jsr	i2c_txbyte
     48  f000				  -
     49  f000				  -	      ldx	#$00
     50  f000				  -AVoxWriteBytesLoop
     51  f000				  -	      lda	eeprombuffer,x
     52  f000				  -	      jsr	i2c_txbyte
     53  f000				  -	      inx
     54  f000				  -	      cpx	temp8
     55  f000				  -	      bne	AVoxWriteBytesLoop
     56  f000				  -	      jsr	i2c_stopwrite
     57  f000				  -
     58  f000				  -	      lda	#0
     59  f000				  -	      rts
     60  f000				  -
     61  f000				  -eeprom_error
     62  f000				  -	      lda	#$ff
     63  f000				  -	      rts
     64  f000				  -
     65  f000				  -AVoxDetect
     66  f000				  -
     67  f000				  -	      jsr	i2c_startwrite
     68  f000				  -	      bcs	eeprom_error
     69  f000				  -	      lda	#$30
     70  f000				  -	      jsr	i2c_txbyte
     71  f000				  -	      lda	#$00
     72  f000				  -	      jsr	i2c_txbyte
     73  f000				  -	      jsr	i2c_stopwrite
     74  f000				  -	      rts
     75  f000				  -
     76  f000				  -	      include	"i2c7800.inc"
     77  f000				  -	      I2C_SUBS	temp9
     78  f000				  -
     79  f000					      endif
     80  f000
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
   2252  f000					      endif
   2253  f000					      ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  f000					      include	pokeysound.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	pokeysupport
      5  f000				  -
      6  f000				  -pokeysoundmodulestart
      7  f000				  -
      8  f000				  -mutepokey
      9  f000				  -	      lda	#0
     10  f000				  -	      ldy	#7
     11  f000				  -mutepokeyloop
     12  f000				  -	      sta	pokey1pointlo,y
     13  f000				  -	      sta	(pokeybaselo),y
     14  f000				  -	      dey
     15  f000				  -	      bpl	mutepokeyloop
     16  f000				  -	      rts
     17  f000				  -
     18  f000				  -checkpokeyplaying
     19  f000				  -	      ldx	#6
     20  f000				  -checkpokeyplayingloop
     21  f000				  -	      lda	pokey1pointlo,x
     22  f000				  -	      ora	pokey1pointhi,x
     23  f000				  -	      beq	pokeychannelinactive
     24  f000				  -	      jsr	playpokeysfxA	; x=channel*2
     25  f000				  -pokeychannelinactive
     26  f000				  -	      dex
     27  f000				  -	      dex
     28  f000				  -	      bpl	checkpokeyplayingloop
     29  f000				  -	      rts
     30  f000				  -
     31  f000				  -playpokeysfxA
     32  f000				  -	      txa
     33  f000				  -	      tay
     34  f000				  -	      lda	pokey1tick,x
     35  f000				  -	      beq	playpokeysfxAcont
     36  f000				  -	      sec
     37  f000				  -	      sbc	#1
     38  f000				  -	      sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  f000				  -	      rts
     40  f000				  -
     41  f000				  -playpokeysfxAcont
     42  f000				  -	      lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  f000				  -	      sta	pokey1tick,x
     44  f000				  -
     45  f000				  -	      lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  f000				  -	      beq	playpokeysfxAcont2
     47  f000				  -	      sec
     48  f000				  -	      sbc	#1
     49  f000				  -	      sta	pokey1priority,x
     50  f000				  -playpokeysfxAcont2
     51  f000				  -
     52  f000				  -			; *** FREQUENCY
     53  f000				  -	      lda	(pokey1pointlo,x)
     54  f000				  -	      sta	temp1
     55  f000				  -	      clc
     56  f000				  -	      adc	pokey1offset,x	; take into account any pitch modification
     57  f000				  -	      sta	(pokeybaselo),y	; PAUDF0,0
     58  f000				  -
     59  f000				  -			;advance the data pointer +1
     60  f000				  -	      inc	pokey1pointlo,x
     61  f000				  -	      bne	skippokeyhiinc1
     62  f000				  -	      inc	pokey1pointhi,x
     63  f000				  -skippokeyhiinc1
     64  f000				  -
     65  f000				  -			; *** WAVE
     66  f000				  -	      lda	(pokey1pointlo,x)
     67  f000				  -	      asl
     68  f000				  -	      asl
     69  f000				  -	      asl
     70  f000				  -	      asl		; x16
     71  f000				  -
     72  f000				  -			;advance the data pointer +1
     73  f000				  -	      inc	pokey1pointlo,x
     74  f000				  -	      bne	skippokeyhiinc2
     75  f000				  -	      inc	pokey1pointhi,x
     76  f000				  -skippokeyhiinc2
     77  f000				  -
     78  f000				  -	      ora	(pokey1pointlo,x)
     79  f000				  -	      iny
     80  f000				  -	      sta	(pokeybaselo),y
     81  f000				  -
     82  f000				  -	      ora	temp1	; check if F|C|V=0
     83  f000				  -	      beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  f000				  -
     85  f000				  -			; advance the pointer +1, on to the next sound chunk
     86  f000				  -	      inc	pokey1pointlo,x
     87  f000				  -	      bne	skippokeyhiinc3
     88  f000				  -	      inc	pokey1pointhi,x
     89  f000				  -skippokeyhiinc3
     90  f000				  -	      rts
     91  f000				  -
     92  f000				  -zeropokeypoint
     93  f000				  -	      sta	pokey1pointlo,x
     94  f000				  -	      sta	pokey1pointhi,x
     95  f000				  -	      sta	pokey1priority,x
     96  f000				  -	      rts
     97  f000				  -
     98  f000				  -schedulepokeysfx
     99  f000				  -	      ldx	#6
    100  f000				  -schedulepokeysfxloop
    101  f000				  -	      lda	pokey1pointlo,x
    102  f000				  -	      ora	pokey1pointhi,x
    103  f000				  -	      bne	schedulespokeysearch
    104  f000				  -	      jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  f000				  -schedulespokeysearch
    106  f000				  -	      dex
    107  f000				  -	      dex
    108  f000				  -	      bpl	schedulepokeysfxloop
    109  f000				  -
    110  f000				  -			; if we're here, all 4 channels are presently playing a sound...
    111  f000				  -	      ldy	#1
    112  f000				  -	      lda	(temp1),y	; peek at the priority of this sfx...
    113  f000				  -	      bne	schedulepokeysfxcont1
    114  f000				  -	      rts		; ...and skip it if it's 0 priority
    115  f000				  -schedulepokeysfxcont1
    116  f000				  -
    117  f000				  -			; figure out which current sound has the lowest priority...
    118  f000				  -	      lda	#0
    119  f000				  -	      sta	temp8
    120  f000				  -	      lda	pokey1priority
    121  f000				  -	      sta	temp9
    122  f000				  -	      ldx	#6
    123  f000				  -findlowprioritypokeyloop
    124  f000				  -	      lda	pokey1priority,x
    125  f000				  -	      cmp	temp9
    126  f000				  -	      bcs	findlowprioritypokeyloopcontinue
    127  f000				  -	      sta	temp9
    128  f000				  -	      stx	temp8
    129  f000				  -findlowprioritypokeyloopcontinue
    130  f000				  -	      dex
    131  f000				  -	      dex
    132  f000				  -	      bne	findlowprioritypokeyloop
    133  f000				  -	      ldx	temp8	; the low priority channel we'll interrupt
    134  f000				  -
    135  f000				  -schedulepokeyX
    136  f000				  -			;called with X=2*pokey channel to play on...
    137  f000				  -	      ldy	#1	; get priority and sound-resolution (in frames)
    138  f000				  -	      lda	(temp1),y
    139  f000				  -	      sta	pokey1priority,x
    140  f000				  -	      iny
    141  f000				  -	      lda	(temp1),y
    142  f000				  -	      sta	pokey1frames,x
    143  f000				  -
    144  f000				  -	      lda	temp1
    145  f000				  -	      clc
    146  f000				  -	      adc	#3
    147  f000				  -	      sta	pokey1pointlo,x
    148  f000				  -	      lda	temp2
    149  f000				  -	      adc	#0
    150  f000				  -	      sta	pokey1pointhi,x
    151  f000				  -	      lda	temp3
    152  f000				  -	      sta	pokey1offset,x
    153  f000				  -	      lda	#0
    154  f000				  -	      sta	pokey1tick,x
    155  f000				  -	      rts
    156  f000				  -
    157  f000				  -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  f000				  -			; and the standard $4000 location.
    159  f000				  -			; if pokey the pokey is present, this routine will reset it.
    160  f000				  -
    161  f000				  -detectpokeylocation
    162  f000				  -			;XBoard/XM...
    163  f000				  -	      ldx	#2
    164  f000				  -detectpokeyloop
    165  f000				  -	      lda	XCTRL1s
    166  f000				  -	      ora	#%00010100
    167  f000				  -	      and	POKEYXMMASK,x
    168  f000				  -	      sta	XCTRL1s
    169  f000				  -	      sta	XCTRL1
    170  f000				  -
    171  f000				  -	      lda	POKEYCHECKLO,x
    172  f000				  -	      sta	pokeybaselo
    173  f000				  -	      lda	POKEYCHECKHI,x
    174  f000				  -	      sta	pokeybasehi
    175  f000				  -	      jsr	checkforpokey
    176  f000				  -	      lda	pokeydetected
    177  f000				  -	      beq	foundpokeychip
    178  f000				  -	      dex
    179  f000				  -	      bpl	detectpokeyloop
    180  f000				  -foundpokeychip
    181  f000				  -	      eor	#$ff	; invert state for 7800basic if...then test
    182  f000				  -	      sta	pokeydetected
    183  f000				  -	      rts
    184  f000				  -
    185  f000				  -POKEYXMMASK
    186  f000				  -			;     XM POKEY on    XM POKEY off   XM POKEY off
    187  f000				  -	      .byte	%11111111, %11101111, %11101111
    188  f000				  -
    189  f000				  -POKEYCHECKLO
    190  f000				  -	      .byte	<$0450, <$0450, <$4000
    191  f000				  -POKEYCHECKHI
    192  f000				  -	      .byte	>$0450, >$0450, >$4000
    193  f000				  -
    194  f000				  -checkforpokey
    195  f000				  -	      ldy	#$0f
    196  f000				  -	      lda	#$00
    197  f000				  -	      sta	pokeydetected	; start off by assuming pokey will be detected
    198  f000				  -resetpokeyregistersloop
    199  f000				  -	      sta	(pokeybase),y
    200  f000				  -	      dey
    201  f000				  -	      bpl	resetpokeyregistersloop
    202  f000				  -
    203  f000				  -	      ldy	#PAUDCTL
    204  f000				  -	      sta	(pokeybase),y
    205  f000				  -	      ldy	#PSKCTL
    206  f000				  -	      sta	(pokeybase),y
    207  f000				  -
    208  f000				  -			; let the dust settle...
    209  f000				  -	      nop
    210  f000				  -	      nop
    211  f000				  -	      nop
    212  f000				  -
    213  f000				  -	      lda	#4
    214  f000				  -	      sta	temp9
    215  f000				  -pokeycheckloop1
    216  f000				  -			; we're in reset, so the RANDOM register should read $ff...
    217  f000				  -	      ldy	#PRANDOM
    218  f000				  -	      lda	(pokeybase),y
    219  f000				  -	      cmp	#$ff
    220  f000				  -	      bne	nopokeydetected
    221  f000				  -	      dec	temp9
    222  f000				  -	      bne	pokeycheckloop1
    223  f000				  -
    224  f000				  -			; take pokey out of reset...
    225  f000				  -	      ldy	#PSKCTL
    226  f000				  -	      lda	#3
    227  f000				  -	      sta	(pokeybase),y
    228  f000				  -	      ldy	#PAUDCTL
    229  f000				  -	      lda	#0
    230  f000				  -	      sta	(pokeybase),y
    231  f000				  -
    232  f000				  -			; let the dust settle again...
    233  f000				  -	      nop
    234  f000				  -	      nop
    235  f000				  -	      nop
    236  f000				  -
    237  f000				  -	      lda	#4
    238  f000				  -	      sta	temp9
    239  f000				  -pokeycheckloop2
    240  f000				  -			; we're out of reset, so RANDOM should read non-$ff...
    241  f000				  -	      ldy	#PRANDOM
    242  f000				  -	      lda	(pokeybase),y
    243  f000				  -	      cmp	#$ff
    244  f000				  -	      beq	skippokeycheckreturn
    245  f000				  -	      rts
    246  f000				  -skippokeycheckreturn
    247  f000				  -	      dec	temp9
    248  f000				  -	      bne	pokeycheckloop2
    249  f000				  -nopokeydetected
    250  f000				  -	      dec	pokeydetected	; pokeydetected=#$ff
    251  f000				  -	      rts
    252  f000				  -
    253  f000				  -pokeysoundmoduleend
    254  f000				  -
    255  f000				  -	      echo	"  pokeysound assembly: ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes"
    256  f000				  -
    257  f000					      endif
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
   2255  f000					      endif
   2256  f000					      ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  f000					      include	tracker.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	MUSICTRACKER
      5  f000				  -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      6  f000				  -			; ** the player operates on a 16th note grid.
      7  f000				  -
      8  f000				  -servicesongover
      9  f000				  -	      rts
     10  f000				  -servicesong
     11  f000				  -	      lda	songtempo
     12  f000				  -	      beq	servicesongover	; ** if song is off/paused then return
     13  f000				  -servicesongcontinue
     14  f000				  -	      lda	sfxschedulelock
     15  f000				  -	      sta	sfxschedulemissed
     16  f000				  -	      bne	servicesongover
     17  f000				  -	      lda	songtempo
     18  f000				  -	      clc
     19  f000				  -	      adc	songtick	; add songtempo to songtick until it rolls over
     20  f000				  -	      sta	songtick	; this is how we break away from 50/60Hz timing.
     21  f000				  -	      bcc	servicesongover
     22  f000				  -			; ** if we're here a new 16th note has passed
     23  f000				  -			; ** check if a new note is due on any of the 4 channels
     24  f000				  -servicesongredo
     25  f000				  -	      ldx	#3
     26  f000				  -checkchannelloop
     27  f000				  -	      dec	songchannel1busywait,x
     28  f000				  -	      bpl	carryoncheckingchannel
     29  f000				  -	      txa
     30  f000				  -	      pha		; save X for the loop
     31  f000				  -	      jsr	processsongdata
     32  f000				  -	      pla		; restore X for the loop
     33  f000				  -	      tax
     34  f000				  -carryoncheckingchannel
     35  f000				  -	      dex
     36  f000				  -	      bpl	checkchannelloop
     37  f000				  -	      lda	inactivechannelcount
     38  f000				  -	      cmp	#15
     39  f000				  -	      bne	skipstopsong
     40  f000				  -	      lda	songloops
     41  f000				  -	      bne	doasongloop
     42  f000				  -			;lda #0
     43  f000				  -	      sta	songtempo	; all channels are done. stop the song
     44  f000				  -	      rts
     45  f000				  -doasongloop
     46  f000				  -	      bmi	skipsongloopadjust
     47  f000				  -	      dec	songloops
     48  f000				  -skipsongloopadjust
     49  f000				  -	      jsr	setsongchannels
     50  f000				  -	      jmp	servicesongredo
     51  f000				  -skipstopsong
     52  f000				  -	      rts
     53  f000				  -
     54  f000				  -processsongdata
     55  f000				  -			; channel needs processing
     56  f000				  -			; X=channel #
     57  f000				  -
     58  f000				  -	      txa
     59  f000				  -	      clc
     60  f000				  -	      adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     61  f000				  -	      tay
     62  f000				  -
     63  f000				  -
     64  f000				  -			; ** indirect x is cumbersome with mult-byte commands.
     65  f000				  -			; ** setup a pointer to the song data for indirect y addressing.
     66  f000				  -	      lda	songchannel1layer1lo,y
     67  f000				  -	      sta	songdatalo
     68  f000				  -	      lda	songchannel1layer1hi,y
     69  f000				  -	      sta	songdatahi
     70  f000				  -	      ora	songdatalo
     71  f000				  -	      bne	channelhasdata
     72  f000				  -			;channel data is pointing at $0000
     73  f000				  -	      lda	#$7F
     74  f000				  -	      sta	songchannel1busywait,x	; skip a bunch of notes
     75  f000				  -setchannelcountbits
     76  f000				  -	      lda	channel2bits,x
     77  f000				  -	      ora	inactivechannelcount
     78  f000				  -	      sta	inactivechannelcount
     79  f000				  -	      rts
     80  f000				  -channelhasdata
     81  f000				  -
     82  f000				  -	      sty	songstackindex
     83  f000				  -	      ldy	#0
     84  f000				  -	      lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     85  f000				  -	      cmp	#$ff
     86  f000				  -	      bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     87  f000				  -	      jmp	handlechannelEOD
     88  f000				  -
     89  f000				  -carryoncheckingdatatype
     90  f000				  -	      and	#$F0
     91  f000				  -	      cmp	#$C0
     92  f000				  -	      beq	handlechannelrest	; 0000XXXX=rest
     93  f000				  -	      cmp	#$F0
     94  f000				  -	      beq	handlemultibytecommand
     95  f000				  -	      cmp	#$D0
     96  f000				  -	      beq	handlesemiup
     97  f000				  -	      cmp	#$E0
     98  f000				  -	      beq	handlesemidown
     99  f000				  -handlenotedata
    100  f000				  -			; ** TODO: note playing is a terrible choice for fall-through
    101  f000				  -
    102  f000				  -			; ** its simple note data, prepare arguments for schedulesfx
    103  f000				  -
    104  f000				  -			; ** set the note length
    105  f000				  -	      lda	(songdatalo),y
    106  f000				  -	      and	#$0F
    107  f000				  -	      sta	songchannel1busywait,x
    108  f000				  -
    109  f000				  -			; ** load the instrument
    110  f000				  -	      lda	songchannel1instrumentlo,x
    111  f000				  -	      sta	sfxinstrumentlo
    112  f000				  -	      lda	songchannel1instrumenthi,x
    113  f000				  -	      sta	sfxinstrumenthi
    114  f000				  -
    115  f000				  -			; ** get the note, and transpose
    116  f000				  -	      lda	(songdatalo),y
    117  f000				  -	      lsr
    118  f000				  -	      lsr
    119  f000				  -	      lsr
    120  f000				  -	      lsr
    121  f000				  -	      clc
    122  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    123  f000				  -			; ** its up the respective SFX scheduler to handle and save the note data
    124  f000				  -	      sta	sfxnoteindex
    125  f000				  -
    126  f000				  -	      lda	#0
    127  f000				  -	      sta	sfxpitchoffset
    128  f000				  -
    129  f000				  -	      jsr	schedulesfx
    130  f000				  -
    131  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    132  f000				  -
    133  f000				  -handlechannelrest
    134  f000				  -			; ** set the note length
    135  f000				  -	      lda	(songdatalo),y
    136  f000				  -	      and	#$0F
    137  f000				  -	      sta	songchannel1busywait,x
    138  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  f000				  -
    140  f000				  -handlesemiup
    141  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    142  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    143  f000				  -	      clc
    144  f000				  -handlesemidownentry
    145  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    146  f000				  -	      sta	songchannel1transpose,x
    147  f000				  -	      jsr	advancethesongpointer1byte
    148  f000				  -	      jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    149  f000				  -
    150  f000				  -handlesemidown
    151  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    152  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    153  f000				  -	      eor	#$ff	; ** its easier if we negate it, and then add it instead.
    154  f000				  -	      sec
    155  f000				  -	      jmp	handlesemidownentry
    156  f000				  -
    157  f000				  -handlemultibytecommand
    158  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  f000				  -	      cmp	#$08	; ** load new instrument?
    161  f000				  -	      bne	nothandleinstrumentchange
    162  f000				  -handleinstrumentchange
    163  f000				  -	      iny
    164  f000				  -	      lda	(songdatalo),y
    165  f000				  -	      sta	songchannel1instrumentlo,x
    166  f000				  -	      iny
    167  f000				  -	      lda	(songdatalo),y
    168  f000				  -	      sta	songchannel1instrumenthi,x
    169  f000				  -	      lda	#3
    170  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    171  f000				  -	      jmp	processsongdata
    172  f000				  -
    173  f000				  -nothandleinstrumentchange
    174  f000				  -	      cmp	#$09	; ** absolute tempo change?
    175  f000				  -	      bne	nothandletempochange
    176  f000				  -	      lda	#0
    177  f000				  -	      sta	songtempo
    178  f000				  -handlerelativetempochange
    179  f000				  -	      iny
    180  f000				  -	      lda	(songdatalo),y
    181  f000				  -	      clc
    182  f000				  -	      adc	songtempo
    183  f000				  -	      sta	songtempo
    184  f000				  -	      lda	#2
    185  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    186  f000				  -	      jmp	processsongdata
    187  f000				  -
    188  f000				  -nothandletempochange
    189  f000				  -	      cmp	#$0A	; ** relative tempo change?:
    190  f000				  -	      beq	handlerelativetempochange
    191  f000				  -	      cmp	#$0B	; ** octave/semi change?
    192  f000				  -	      beq	handleoctavesemichange
    193  f000				  -handlepatterndata
    194  f000				  -			; ** if we're here its a pattern/loop "subroutine"
    195  f000				  -			; ** move the channel's "stack" pointer and populate the new stack level
    196  f000				  -
    197  f000				  -	      lda	#4
    198  f000				  -	      clc
    199  f000				  -	      adc	songchannel1stackdepth,x
    200  f000				  -	      sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    201  f000				  -
    202  f000				  -	      stx	inttemp6	; about to invalidate x. save it.
    203  f000				  -	      lda	songstackindex
    204  f000				  -	      adc	#4
    205  f000				  -	      tax
    206  f000				  -
    207  f000				  -	      lda	(songdatalo),y
    208  f000				  -	      and	#$7
    209  f000				  -	      sta	songchannel1layer1loops,x
    210  f000				  -	      iny
    211  f000				  -	      lda	(songdatalo),y
    212  f000				  -	      sta	songchannel1layer1lo,x
    213  f000				  -	      iny
    214  f000				  -	      lda	(songdatalo),y
    215  f000				  -	      sta	songchannel1layer1hi,x
    216  f000				  -
    217  f000				  -	      ldx	inttemp6	; restore x with the channel #
    218  f000				  -
    219  f000				  -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    220  f000				  -	      lda	#3
    221  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    222  f000				  -
    223  f000				  -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    224  f000				  -	      jmp	processsongdata
    225  f000				  -
    226  f000				  -handlechannelEOD
    227  f000				  -			; ** check if there are loops remaining on the pattern
    228  f000				  -	      stx	inttemp6
    229  f000				  -	      ldx	songstackindex
    230  f000				  -	      dec	songchannel1layer1loops,x
    231  f000				  -	      bmi	handlechannelEODnoloop
    232  f000				  -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    233  f000				  -	      iny
    234  f000				  -	      lda	(songdatalo),y
    235  f000				  -	      sta	songchannel1layer1lo,x
    236  f000				  -	      iny
    237  f000				  -	      lda	(songdatalo),y
    238  f000				  -	      sta	songchannel1layer1hi,x
    239  f000				  -	      ldx	inttemp6
    240  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    241  f000				  -
    242  f000				  -handlechannelEODnoloop
    243  f000				  -			; this pattern/loop is done playing. "pop" the stack
    244  f000				  -	      ldx	inttemp6
    245  f000				  -	      lda	songchannel1stackdepth,x
    246  f000				  -	      beq	handlerootchannelEOD
    247  f000				  -	      sec
    248  f000				  -	      sbc	#4
    249  f000				  -	      sta	songchannel1stackdepth,x
    250  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    251  f000				  -
    252  f000				  -handlerootchannelEOD
    253  f000				  -			; this channel is done. point it to $ff data so we no longer process this channel.
    254  f000				  -	      lda	#0
    255  f000				  -	      sta	songchannel1layer1lo,x
    256  f000				  -	      sta	songchannel1layer1hi,x
    257  f000				  -	      sta	songchannel1busywait,x
    258  f000				  -	      jmp	setchannelcountbits
    259  f000				  -	      rts
    260  f000				  -
    261  f000				  -nothandlepatternchange
    262  f000				  -handleoctavesemichange
    263  f000				  -	      iny
    264  f000				  -	      lda	(songdatalo),y
    265  f000				  -	      sta	songchannel1transpose,x
    266  f000				  -	      lda	#2
    267  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    268  f000				  -	      jmp	processsongdata
    269  f000				  -
    270  f000				  -advancethesongpointer1byte
    271  f000				  -	      txa
    272  f000				  -	      ldx	songstackindex
    273  f000				  -	      inc	songchannel1layer1lo,x
    274  f000				  -	      bne	skiphiadvancethesongpointer1byte
    275  f000				  -	      inc	songchannel1layer1hi,x
    276  f000				  -skiphiadvancethesongpointer1byte
    277  f000				  -	      tax
    278  f000				  -	      rts
    279  f000				  -
    280  f000				  -advancethesongpointerNbytes
    281  f000				  -			; entered with A=# of byte to advance
    282  f000				  -	      stx	inttemp6
    283  f000				  -	      ldx	songstackindex
    284  f000				  -	      clc
    285  f000				  -	      adc	songchannel1layer1lo,x
    286  f000				  -	      sta	songchannel1layer1lo,x
    287  f000				  -	      lda	#0
    288  f000				  -	      adc	songchannel1layer1hi,x
    289  f000				  -	      sta	songchannel1layer1hi,x
    290  f000				  -	      ldx	inttemp6
    291  f000				  -	      rts
    292  f000				  -
    293  f000				  -clearsongmemory
    294  f000				  -	      lda	#0
    295  f000				  -	      ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    296  f000				  -clearsongmemoryloop1
    297  f000				  -	      sta	songchannel1layer1lo,x
    298  f000				  -	      dex
    299  f000				  -	      bpl	clearsongmemoryloop1
    300  f000				  -
    301  f000				  -	      ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    302  f000				  -clearsongmemoryloop2
    303  f000				  -	      sta	songchannel1layer1loops,x
    304  f000				  -	      dex
    305  f000				  -	      bpl	clearsongmemoryloop2
    306  f000				  -
    307  f000				  -	      lda	#$ff
    308  f000				  -	      ldx	#3
    309  f000				  -clearsongmemoryloop3
    310  f000				  -	      sta	songchannel1busywait,x
    311  f000				  -	      dex
    312  f000				  -	      bpl	clearsongmemoryloop3
    313  f000				  -	      rts
    314  f000				  -
    315  f000				  -setsongchannels
    316  f000				  -	      jsr	clearsongmemory
    317  f000				  -	      ldy	#7
    318  f000				  -	      ldx	#3
    319  f000				  -setsongchannelsloop
    320  f000				  -	      lda	(songpointerlo),y
    321  f000				  -	      sta	songchannel1layer1hi,x
    322  f000				  -	      dey
    323  f000				  -	      lda	(songpointerlo),y
    324  f000				  -	      sta	songchannel1layer1lo,x
    325  f000				  -	      dex
    326  f000				  -	      dey
    327  f000				  -	      bpl	setsongchannelsloop
    328  f000				  -	      rts
    329  f000				  -
    330  f000				  -channel2bits
    331  f000				  -	      .byte	1,2,4,8
    332  f000				  -
    333  f000				  -tiatrackeroctavenotes
    334  f000				  -	      ifconst	BUZZBASS
    335  f000				  -LOWC       =	15
    336  f000				  -	      else
    337  f000				  -LOWC       =	14
    338  f000				  -	      endif
    339  f000				  -			; ****** ELECTRONIC (0 to 11)
    340  f000				  -	      .byte	LOWC,20	; c0	 16.1Hz
    341  f000				  -	      .byte	LOWC,18	; c#0
    342  f000				  -	      .byte	LOWC,17	; d0
    343  f000				  -	      .byte	LOWC,16	; d#0
    344  f000				  -	      .byte	LOWC,15	; e0
    345  f000				  -	      .byte	LOWC,14	; f0  (very off)
    346  f000				  -	      .byte	LOWC,14	; f#0
    347  f000				  -	      .byte	LOWC,13	; g0
    348  f000				  -	      .byte	LOWC,12	; g#0
    349  f000				  -	      .byte	LOWC,11	; a0
    350  f000				  -	      .byte	LOWC,11	; a#0 (very off)
    351  f000				  -	      .byte	LOWC,10	; b0	 30.7Hz
    352  f000				  -
    353  f000				  -			; ****** SLIGHTLY BUZZY (12 to 23)
    354  f000				  -	      .byte	6,30	; c1	 32.7Hz
    355  f000				  -	      .byte	6,28	; c#1
    356  f000				  -	      .byte	6,27	; d1
    357  f000				  -	      .byte	6,25	; d#1
    358  f000				  -	      .byte	6,24	; e1
    359  f000				  -	      .byte	6,22	; f1
    360  f000				  -	      .byte	6,21	; f#1
    361  f000				  -	      .byte	6,20	; g1
    362  f000				  -	      .byte	6,18	; g#1
    363  f000				  -	      .byte	6,17	; a1
    364  f000				  -	      .byte	6,16	; a#1
    365  f000				  -	      .byte	6,15	; b1	 63.4Hz
    366  f000				  -
    367  f000				  -			; ****** BUZZY (24 to 39)
    368  f000				  -	      .byte	1,31	; c2	 65.5
    369  f000				  -	      .byte	1,30	; c#2	 67.6
    370  f000				  -	      .byte	1,27	; d2	 72.3
    371  f000				  -	      .byte	1,26	; d#2	 77.6
    372  f000				  -	      .byte	1,24	; e2
    373  f000				  -	      .byte	1,23	; f2
    374  f000				  -	      .byte	1,22	; f#2
    375  f000				  -	      .byte	1,20	; g2
    376  f000				  -	      .byte	1,19	; g#2
    377  f000				  -	      .byte	1,18	; a2
    378  f000				  -	      .byte	1,17	; a#2
    379  f000				  -	      .byte	1,16	; b2
    380  f000				  -	      .byte	1,15	; c3	126.8Hz
    381  f000				  -	      .byte	1,14	; c#3
    382  f000				  -	      .byte	1,13	; d3	149.7Hz
    383  f000				  -	      .byte	1,12	; d#3	161.2Hz (very off)
    384  f000				  -			; ****** PURE (40 to 71) - best key is A3 Major
    385  f000				  -	      .byte	12,31	; e3	163.8Hz
    386  f000				  -	      .byte	12,29	; f3
    387  f000				  -	      .byte	12,28	; f#3
    388  f000				  -	      .byte	12,26	; g3
    389  f000				  -	      .byte	12,24	; g#3
    390  f000				  -	      .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    391  f000				  -	      .byte	12,22	; a#3
    392  f000				  -	      .byte	12,20	; b3
    393  f000				  -	      .byte	12,19	; c4  (middle C)
    394  f000				  -	      .byte	12,18	; c#4
    395  f000				  -	      .byte	12,17	; d4
    396  f000				  -	      .byte	12,16	; d#4
    397  f000				  -	      .byte	12,15	; e4
    398  f000				  -	      .byte	12,14	; f4
    399  f000				  -	      .byte	12,13	; f#4
    400  f000				  -	      .byte	12,12	; g4  (very off)
    401  f000				  -	      .byte	12,12	; g#4
    402  f000				  -	      .byte	12,11	; a4
    403  f000				  -	      .byte	12,10	; a#4
    404  f000				  -	      .byte	4,31	; b4
    405  f000				  -	      .byte	4,29	; c5
    406  f000				  -	      .byte	4,28	; c#5
    407  f000				  -	      .byte	4,26	; d5
    408  f000				  -	      .byte	4,24	; d#5
    409  f000				  -	      .byte	4,23	; e5
    410  f000				  -	      .byte	4,22	; f5
    411  f000				  -	      .byte	4,20	; f#5
    412  f000				  -	      .byte	4,19	; g5
    413  f000				  -	      .byte	4,18	; g#5
    414  f000				  -	      .byte	4,17	; a5
    415  f000				  -	      .byte	4,16	; a#5
    416  f000				  -	      .byte	4,15	; b5
    417  f000				  -
    418  f000				  -			; ****** TUNED WIND (72 to 83)
    419  f000				  -	      .byte	8,30	; c
    420  f000				  -	      .byte	8,28	; c#
    421  f000				  -	      .byte	8,27	; d
    422  f000				  -	      .byte	8,25	; d#
    423  f000				  -	      .byte	8,24	; e
    424  f000				  -	      .byte	8,22	; f
    425  f000				  -	      .byte	8,21	; f#
    426  f000				  -	      .byte	8,20	; g
    427  f000				  -	      .byte	8,18	; g#
    428  f000				  -	      .byte	8,17	; a
    429  f000				  -	      .byte	8,16	; a#
    430  f000				  -	      .byte	8,15	; b
    431  f000				  -
    432  f000				  -	      include	"tiadrumkit.asm"
    433  f000				  -
    434  f000					      endif		;MUSICTRACKER
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
   2258  f000					      endif
   2259  f000					      ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  f000					      include	hiscore.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	HSSUPPORT
      4  f000				  -detectatarivoxeeprom
      5  f000				  -hiscoremodulestart
      6  f000				  -			; do a test to see if atarivox eeprom can be accessed, and save results
      7  f000				  -	      jsr	AVoxDetect
      8  f000				  -	      eor	#$ff	; invert for easy 7800basic if...then logic
      9  f000				  -	      sta	avoxdetected
     10  f000				  -	      lda	#$0
     11  f000				  -	      sta	SWACNT
     12  f000				  -	      lda	avoxdetected
     13  f000				  -	      rts
     14  f000				  -
     15  f000				  -detecthsc
     16  f000				  -			; check for the HSC ROM signature...
     17  f000				  -	      lda	XCTRL1s
     18  f000				  -	      ora	#%00001100
     19  f000				  -	      sta	XCTRL1s
     20  f000				  -	      sta	XCTRL1
     21  f000				  -	      lda	$3900
     22  f000				  -	      cmp	#$C6
     23  f000				  -	      bne	detecthscfail
     24  f000				  -	      lda	$3904
     25  f000				  -	      cmp	#$FE
     26  f000				  -	      bne	detecthscfail
     27  f000				  -			; check if it's initialized...
     28  f000				  -	      ldy	#0
     29  f000				  -	      lda	#$ff
     30  f000				  -checkhscinit
     31  f000				  -	      and	$1000,y
     32  f000				  -	      dey
     33  f000				  -	      bpl	checkhscinit
     34  f000				  -	      cmp	#$ff
     35  f000				  -	      bne	hscisalreadyinit
     36  f000				  -			; if we're here, we need to do a minimal HSC init...
     37  f000				  -	      ldy	#$28
     38  f000				  -hscinitloop1
     39  f000				  -	      lda	hscheader,y
     40  f000				  -	      sta	$1000,y
     41  f000				  -	      dey
     42  f000				  -	      bpl	hscinitloop1
     43  f000				  -	      ldy	#$89
     44  f000				  -	      lda	#$7F
     45  f000				  -hscinitloop2
     46  f000				  -	      sta	$10B3,y
     47  f000				  -	      dey
     48  f000				  -	      cpy	#$ff
     49  f000				  -	      bne	hscinitloop2
     50  f000				  -hscisalreadyinit
     51  f000				  -	      lda	#$ff
     52  f000				  -	      rts
     53  f000				  -hscheader
     54  f000				  -	      .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     55  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     56  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     57  f000				  -detecthscfail
     58  f000				  -	      lda	XCTRL1s
     59  f000				  -	      and	#%11110111
     60  f000				  -	      sta	XCTRL1s
     61  f000				  -	      lda	#0
     62  f000				  -	      rts
     63  f000					      endif		; HSSUPPORT
     64  f000
     65  f000				  -	      ifconst	HSSUPPORT
     66  f000				  -	      ifnconst	hiscorefont
     67  f000				  -	      echo	""
     68  f000				  -	      echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     69  f000				  -	      echo	" NOT imported with incgraphic. The high score display code"
     70  f000				  -	      echo	" has been omitted from this build."
     71  f000				  -	      echo	""
     72  f000				  -	      else
     73  f000				  -hscdrawscreen
     74  f000				  -
     75  f000				  -			; we use 20 lines on a 24 line display
     76  f000				  -			; HSSCOREY to dynamically centers based on
     77  f000				  -			;HSSCOREY = 0
     78  f000				  -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     79  f000				  -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     80  f000				  -
     81  f000				  -	      ifconst	HSSCORESIZE
     82  f000				  -SCORESIZE  =	HSSCORESIZE
     83  f000				  -	      else
     84  f000				  -SCORESIZE  =	6
     85  f000				  -	      endif
     86  f000				  -
     87  f000				  -			;save shadow registers for later return...
     88  f000				  -	      lda	sCTRL
     89  f000				  -	      sta	ssCTRL
     90  f000				  -	      lda	sCHARBASE
     91  f000				  -	      sta	ssCHARBASE
     92  f000				  -	      lda	#$60
     93  f000				  -	      sta	charactermode
     94  f000				  -	      jsr	drawwait
     95  f000				  -	      jsr	blacken320colors
     96  f000				  -	      jsr	clearscreen
     97  f000				  -
     98  f000				  -			;set the character base to the HSC font
     99  f000				  -	      lda	#>hiscorefont
    100  f000				  -	      sta	CHARBASE
    101  f000				  -	      sta	sCHARBASE
    102  f000				  -	      lda	#%01000011	;Enable DMA, mode=320A
    103  f000				  -	      sta	CTRL
    104  f000				  -	      sta	sCTRL
    105  f000				  -
    106  f000				  -	      lda	#60
    107  f000				  -	      sta	hsjoydebounce
    108  f000				  -
    109  f000				  -	      lda	#0
    110  f000				  -	      sta	hscursorx
    111  f000				  -	      sta	framecounter
    112  f000				  -	      ifnconst	HSCOLORCHASESTART
    113  f000				  -	      lda	#$8D	; default is blue. why not?
    114  f000				  -	      else
    115  f000				  -	      lda	#HSCOLORCHASESTART
    116  f000				  -	      endif
    117  f000				  -	      sta	hscolorchaseindex
    118  f000				  -
    119  f000				  -	      lda	#$0F
    120  f000				  -	      sta	P0C2	; base text is white
    121  f000				  -
    122  f000				  -	      jsr	hschasecolors
    123  f000				  -			; ** plot all of the initials
    124  f000				  -	      lda	#<HSRAMInitials
    125  f000				  -	      sta	temp1	; charmaplo
    126  f000				  -	      lda	#>HSRAMInitials
    127  f000				  -	      sta	temp2	; charmaphi
    128  f000				  -	      lda	#32+29	; palette=0-29 | 32-(width=3)
    129  f000				  -	      sta	temp3	; palette/width
    130  f000				  -	      lda	#104
    131  f000				  -	      sta	temp4	; X
    132  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    133  f000				  -	      sta	temp5	; Y
    134  f000				  -plothsinitialsloop
    135  f000				  -	      jsr	plotcharacters
    136  f000				  -	      clc
    137  f000				  -	      lda	temp3
    138  f000				  -	      adc	#32
    139  f000				  -	      sta	temp3
    140  f000				  -	      inc	temp5
    141  f000				  -	      if	WZONEHEIGHT = 8
    142  f000				  -	      inc	temp5
    143  f000				  -	      endif
    144  f000				  -	      clc
    145  f000				  -	      lda	#3
    146  f000				  -	      adc	temp1
    147  f000				  -	      sta	temp1
    148  f000				  -	      cmp	#(<(HSRAMInitials+15))
    149  f000				  -	      bcc	plothsinitialsloop
    150  f000				  -
    151  f000				  -	      ifconst	HSGAMENAMELEN
    152  f000				  -			;plot the game name...
    153  f000				  -	      lda	#<HSGAMENAMEtable
    154  f000				  -	      sta	temp1	; charmaplo
    155  f000				  -	      lda	#>HSGAMENAMEtable
    156  f000				  -	      sta	temp2	; charmaphi
    157  f000				  -	      lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    158  f000				  -	      sta	temp3	; palette/width
    159  f000				  -	      lda	#(80-(HSGAMENAMELEN*2))
    160  f000				  -	      sta	temp4	; X
    161  f000				  -	      lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    162  f000				  -	      sta	temp5	; Y
    163  f000				  -	      jsr	plotcharacters
    164  f000				  -	      endif		; HSGAMENAMELEN
    165  f000				  -
    166  f000				  -			;plot "difficulty"...
    167  f000				  -	      ldy	gamedifficulty
    168  f000				  -	      ifnconst	HSNOLEVELNAMES
    169  f000				  -	      lda	highscoredifficultytextlo,y
    170  f000				  -	      sta	temp1
    171  f000				  -	      lda	highscoredifficultytexthi,y
    172  f000				  -	      sta	temp2
    173  f000				  -	      sec
    174  f000				  -	      lda	#32
    175  f000				  -	      sbc	highscoredifficultytextlen,y
    176  f000				  -	      sta	temp3	; palette/width
    177  f000				  -	      sec
    178  f000				  -	      lda	#40
    179  f000				  -	      sbc	highscoredifficultytextlen,y
    180  f000				  -	      asl
    181  f000				  -	      sta	temp4	; X
    182  f000				  -	      else
    183  f000				  -	      lda	#<HSHIGHSCOREStext
    184  f000				  -	      sta	temp1	; charmaplo
    185  f000				  -	      lda	#>HSHIGHSCOREStext
    186  f000				  -	      sta	temp2	; charmaphi
    187  f000				  -	      lda	#(32-11)	; palette=0*29 | 32-(width=3)
    188  f000				  -	      sta	temp3	; palette/width
    189  f000				  -	      lda	#(80-(11*2))
    190  f000				  -	      sta	temp4	; X
    191  f000				  -	      endif		; HSNOLEVELNAMES
    192  f000				  -
    193  f000				  -	      lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    194  f000				  -	      sta	temp5	; Y
    195  f000				  -	      jsr	plotcharacters
    196  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    197  f000				  -	      bne	carronwithscoreevaluation
    198  f000				  -	      jmp	donoscoreevaluation
    199  f000				  -carronwithscoreevaluation
    200  f000				  -	      dey
    201  f000				  -	      lda	highscorelabeltextlo,y
    202  f000				  -	      sta	temp1
    203  f000				  -	      lda	highscorelabeltexthi,y
    204  f000				  -	      sta	temp2
    205  f000				  -	      sec
    206  f000				  -	      lda	#(32-15)	; palette=0*29 | 32-(width=3)
    207  f000				  -	      sta	temp3	; palette/width
    208  f000				  -	      lda	highscorelabeladjust1,y
    209  f000				  -	      sta	temp4	; X
    210  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    211  f000				  -	      sta	temp5	; Y
    212  f000				  -	      jsr	plotcharacters
    213  f000				  -
    214  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    215  f000				  -	      dey
    216  f000				  -			;plot the current player score...
    217  f000				  -	      lda	#(32-SCORESIZE)	; palette=0*32
    218  f000				  -	      sta	temp3	; palette/width
    219  f000				  -	      lda	highscorelabeladjust2,y
    220  f000				  -	      sta	temp4	; X
    221  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    222  f000				  -	      sta	temp5	; Y
    223  f000				  -
    224  f000				  -	      lda	scorevarlo,y
    225  f000				  -	      sta	temp7	; score variable lo
    226  f000				  -	      lda	scorevarhi,y
    227  f000				  -	      sta	temp8	; score variable hi
    228  f000				  -
    229  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    230  f000				  -	      sta	temp9
    231  f000				  -
    232  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    233  f000				  -	      sta	temp1	; charmaplo
    234  f000				  -	      lda	#>(hiscorefont+33)
    235  f000				  -	      sta	temp2	; charmaphi
    236  f000				  -	      lda	#SCORESIZE
    237  f000				  -	      sta	temp6
    238  f000				  -	      ifnconst	DOUBLEWIDE
    239  f000				  -	      jsr	plotvalue
    240  f000				  -	      else
    241  f000				  -	      jsr	plotvaluedw
    242  f000				  -	      endif
    243  f000				  -
    244  f000				  -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    245  f000				  -
    246  f000				  -	      ifconst	HSGAMERANKS
    247  f000				  -
    248  f000				  -	      ldx	#$ff	; start at 0 after the inx...
    249  f000				  -comparescore2rankloop
    250  f000				  -	      inx
    251  f000				  -	      ldy	#0
    252  f000				  -	      lda	rankvalue_0,x
    253  f000				  -	      cmp	(temp7),y
    254  f000				  -	      bcc	score2rankloopdone
    255  f000				  -	      bne	comparescore2rankloop
    256  f000				  -	      iny
    257  f000				  -	      lda	rankvalue_1,x
    258  f000				  -	      cmp	(temp7),y
    259  f000				  -	      bcc	score2rankloopdone
    260  f000				  -	      bne	comparescore2rankloop
    261  f000				  -	      iny
    262  f000				  -	      lda	(temp7),y
    263  f000				  -	      cmp	rankvalue_2,x
    264  f000				  -	      bcs	score2rankloopdone
    265  f000				  -	      jmp	comparescore2rankloop
    266  f000				  -score2rankloopdone
    267  f000				  -	      stx	hsnewscorerank
    268  f000				  -
    269  f000				  -	      lda	ranklabello,x
    270  f000				  -	      sta	temp1
    271  f000				  -	      lda	ranklabelhi,x
    272  f000				  -	      sta	temp2
    273  f000				  -	      sec
    274  f000				  -	      lda	#32	; palette=0*29 | 32-(width=3)
    275  f000				  -	      sbc	ranklabellengths,x
    276  f000				  -	      sta	temp3	; palette/width
    277  f000				  -	      sec
    278  f000				  -	      lda	#(40+6)
    279  f000				  -	      sbc	ranklabellengths,x
    280  f000				  -	      asl
    281  f000				  -	      sta	temp4	; X
    282  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    283  f000				  -	      sta	temp5	; Y
    284  f000				  -	      jsr	plotcharacters
    285  f000				  -
    286  f000				  -	      ldx	hsnewscorerank
    287  f000				  -
    288  f000				  -	      lda	#<highscoreranklabel
    289  f000				  -	      sta	temp1
    290  f000				  -	      lda	#>highscoreranklabel
    291  f000				  -	      sta	temp2
    292  f000				  -
    293  f000				  -	      lda	#(32-5)	; palette=0*29 | 32-(width=3)
    294  f000				  -	      sta	temp3	; palette/width
    295  f000				  -	      lda	#(40-6)
    296  f000				  -	      sec
    297  f000				  -	      sbc	ranklabellengths,x
    298  f000				  -	      asl
    299  f000				  -	      sta	temp4	; X
    300  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    301  f000				  -	      sta	temp5	; Y
    302  f000				  -	      jsr	plotcharacters
    303  f000				  -	      endif
    304  f000				  -
    305  f000				  -
    306  f000				  -			; ** which line did this player beat?
    307  f000				  -	      lda	#$ff
    308  f000				  -	      sta	hsnewscoreline
    309  f000				  -	      ldx	#$fd
    310  f000				  -comparescoreadd2x
    311  f000				  -	      inx
    312  f000				  -comparescoreadd1x
    313  f000				  -	      inx
    314  f000				  -comparescore2lineloop
    315  f000				  -	      inc	hsnewscoreline
    316  f000				  -	      inx		; initialrun, x=0
    317  f000				  -	      cpx	#15
    318  f000				  -	      beq	nohighscoreforyou
    319  f000				  -	      ldy	#0
    320  f000				  -	      lda	HSRAMScores,x
    321  f000				  -	      cmp	(temp7),y	; first score digit
    322  f000				  -	      bcc	score2lineloopdonedel1x
    323  f000				  -	      bne	comparescoreadd2x
    324  f000				  -	      iny
    325  f000				  -	      inx
    326  f000				  -	      lda	HSRAMScores,x
    327  f000				  -	      cmp	(temp7),y
    328  f000				  -	      bcc	score2lineloopdonedel2x
    329  f000				  -	      bne	comparescoreadd1x
    330  f000				  -	      iny
    331  f000				  -	      inx
    332  f000				  -	      lda	(temp7),y
    333  f000				  -	      cmp	HSRAMScores,x
    334  f000				  -	      bcs	score2lineloopdonedel3x
    335  f000				  -	      jmp	comparescore2lineloop
    336  f000				  -nohighscoreforyou
    337  f000				  -	      lda	#$ff
    338  f000				  -	      sta	hsnewscoreline
    339  f000				  -	      sta	countdownseconds
    340  f000				  -	      jmp	donoscoreevaluation
    341  f000				  -score2lineloopdonedel3x
    342  f000				  -	      dex
    343  f000				  -score2lineloopdonedel2x
    344  f000				  -	      dex
    345  f000				  -score2lineloopdonedel1x
    346  f000				  -	      dex
    347  f000				  -
    348  f000				  -			; 0 1 2
    349  f000				  -			; 3 4 5
    350  f000				  -			; 6 7 8
    351  f000				  -			; 9 0 1
    352  f000				  -			; 2 3 4
    353  f000				  -
    354  f000				  -	      stx	temp9
    355  f000				  -	      cpx	#11
    356  f000				  -	      beq	postsortscoresuploop
    357  f000				  -	      ldx	#11
    358  f000				  -sortscoresuploop
    359  f000				  -	      lda	HSRAMScores,x
    360  f000				  -	      sta	HSRAMScores+3,x
    361  f000				  -	      lda	HSRAMInitials,x
    362  f000				  -	      sta	HSRAMInitials+3,x
    363  f000				  -	      dex
    364  f000				  -	      cpx	temp9
    365  f000				  -	      bne	sortscoresuploop
    366  f000				  -postsortscoresuploop
    367  f000				  -
    368  f000				  -			;stick the score and cleared initials in the slot...
    369  f000				  -	      inx
    370  f000				  -	      ldy	#0
    371  f000				  -	      sty	hsinitialhold
    372  f000				  -	      lda	(temp7),y
    373  f000				  -	      sta	HSRAMScores,x
    374  f000				  -	      iny
    375  f000				  -	      lda	(temp7),y
    376  f000				  -	      sta	HSRAMScores+1,x
    377  f000				  -	      iny
    378  f000				  -	      lda	(temp7),y
    379  f000				  -	      sta	HSRAMScores+2,x
    380  f000				  -	      lda	#0
    381  f000				  -	      sta	HSRAMInitials,x
    382  f000				  -	      lda	#29
    383  f000				  -	      sta	HSRAMInitials+1,x
    384  f000				  -	      sta	HSRAMInitials+2,x
    385  f000				  -
    386  f000				  -	      stx	hsinitialpos
    387  f000				  -
    388  f000				  -	      ifconst	vox_highscore
    389  f000				  -	      lda	<#vox_highscore
    390  f000				  -	      sta	speech_addr
    391  f000				  -	      lda	>#vox_highscore
    392  f000				  -	      sta	speech_addr+1
    393  f000				  -	      endif
    394  f000				  -	      ifconst	sfx_highscore
    395  f000				  -	      lda	<#sfx_highscore
    396  f000				  -	      sta	temp1
    397  f000				  -	      lda	>#sfx_highscore
    398  f000				  -	      sta	temp2
    399  f000				  -	      lda	#0
    400  f000				  -	      sta	temp3
    401  f000				  -	      jsr	schedulesfx
    402  f000				  -	      endif
    403  f000				  -	      ifconst	songdatastart_song_highscore
    404  f000				  -	      lda	#<songchanneltable_song_highscore
    405  f000				  -	      sta	songpointerlo
    406  f000				  -	      lda	#>songchanneltable_song_highscore
    407  f000				  -	      sta	songpointerhi
    408  f000				  -	      lda	#73
    409  f000				  -	      sta	songtempo
    410  f000				  -	      jsr	setsongchannels
    411  f000				  -	      endif
    412  f000				  -
    413  f000				  -
    414  f000				  -donoscoreevaluation
    415  f000				  -
    416  f000				  -	      lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    417  f000				  -	      sta	temp3	; palette/width
    418  f000				  -	      lda	#(72+(4*(6-SCORESIZE)))
    419  f000				  -	      sta	temp4	; X
    420  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    421  f000				  -	      sta	temp5	; Y
    422  f000				  -	      lda	#<HSRAMScores
    423  f000				  -	      sta	temp7	; score variable lo
    424  f000				  -	      lda	#>HSRAMScores
    425  f000				  -	      sta	temp8	; score variable hi
    426  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    427  f000				  -	      sta	temp9
    428  f000				  -plothsscoresloop
    429  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    430  f000				  -	      sta	temp1	; charmaplo
    431  f000				  -	      lda	#>(hiscorefont+33)
    432  f000				  -	      sta	temp2	; charmaphi
    433  f000				  -	      lda	#6
    434  f000				  -	      sta	temp6
    435  f000				  -	      ifnconst	DOUBLEWIDE
    436  f000				  -	      jsr	plotvalue
    437  f000				  -	      else
    438  f000				  -	      jsr	plotvaluedw
    439  f000				  -	      endif
    440  f000				  -	      clc
    441  f000				  -	      lda	temp3
    442  f000				  -	      adc	#32
    443  f000				  -	      sta	temp3
    444  f000				  -	      inc	temp5
    445  f000				  -	      if	WZONEHEIGHT = 8
    446  f000				  -	      inc	temp5
    447  f000				  -	      endif
    448  f000				  -	      clc
    449  f000				  -	      lda	#3
    450  f000				  -	      adc	temp7
    451  f000				  -	      sta	temp7
    452  f000				  -	      cmp	#(<(HSRAMScores+15))
    453  f000				  -	      bcc	plothsscoresloop
    454  f000				  -plothsindex
    455  f000				  -	      lda	#32+31	; palette=0*32 | 32-(width=1)
    456  f000				  -	      sta	temp3	; palette/width
    457  f000				  -	      lda	#44
    458  f000				  -	      sta	temp4	; X
    459  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    460  f000				  -	      sta	temp5	; Y
    461  f000				  -	      lda	#<hsgameslotnumbers
    462  f000				  -	      sta	temp7	; score variable lo
    463  f000				  -	      lda	#>hsgameslotnumbers
    464  f000				  -	      sta	temp8	; score variable hi
    465  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    466  f000				  -	      sta	temp9
    467  f000				  -plothsindexloop
    468  f000				  -	      lda	#<(hiscorefont+33)
    469  f000				  -	      sta	temp1	; charmaplo
    470  f000				  -	      lda	#>(hiscorefont+33)
    471  f000				  -	      sta	temp2	; charmaphi
    472  f000				  -	      lda	#1
    473  f000				  -	      sta	temp6	; number of characters
    474  f000				  -	      ifnconst	DOUBLEWIDE
    475  f000				  -	      jsr	plotvalue
    476  f000				  -	      else
    477  f000				  -	      jsr	plotvaluedw
    478  f000				  -	      endif
    479  f000				  -	      clc
    480  f000				  -	      lda	temp3
    481  f000				  -	      adc	#32
    482  f000				  -	      sta	temp3
    483  f000				  -	      inc	temp5
    484  f000				  -	      if	WZONEHEIGHT = 8
    485  f000				  -	      inc	temp5
    486  f000				  -	      endif
    487  f000				  -	      inc	temp7
    488  f000				  -	      lda	temp7
    489  f000				  -	      cmp	#(<(hsgameslotnumbers+5))
    490  f000				  -	      bcc	plothsindexloop
    491  f000				  -
    492  f000				  -	      jsr	savescreen
    493  f000				  -	      ifnconst	HSSECONDS
    494  f000				  -	      lda	#6
    495  f000				  -	      else
    496  f000				  -	      lda	#HSSECONDS
    497  f000				  -	      endif
    498  f000				  -
    499  f000				  -	      sta	countdownseconds
    500  f000				  -
    501  f000				  -keepdisplayinghs
    502  f000				  -	      jsr	restorescreen
    503  f000				  -
    504  f000				  -	      jsr	setuphsinpt1
    505  f000				  -
    506  f000				  -	      lda	hsnewscoreline
    507  f000				  -	      bpl	carryonkeepdisplayinghs
    508  f000				  -	      jmp	skipenterscorecontrol
    509  f000				  -carryonkeepdisplayinghs
    510  f000				  -
    511  f000				  -
    512  f000				  -	      ifnconst	HSSECONDS
    513  f000				  -	      lda	#6
    514  f000				  -	      else
    515  f000				  -	      lda	#HSSECONDS
    516  f000				  -	      endif
    517  f000				  -
    518  f000				  -	      sta	countdownseconds
    519  f000				  -
    520  f000				  -			;plot the "cursor" initial sprite...
    521  f000				  -	      lda	hsinitialhold
    522  f000				  -
    523  f000				  -	      sta	temp1
    524  f000				  -	      lda	#>(hiscorefont+32)
    525  f000				  -	      sta	temp2
    526  f000				  -	      lda	#31	; palette=0*32 | 32-(width=1)
    527  f000				  -	      sta	temp3	; palette/width
    528  f000				  -	      lda	hscursorx
    529  f000				  -	      asl
    530  f000				  -	      asl
    531  f000				  -	      clc
    532  f000				  -	      adc	#104
    533  f000				  -	      sta	temp4	; X
    534  f000				  -	      lda	hsnewscoreline
    535  f000				  -	      asl
    536  f000				  -	      asl
    537  f000				  -	      asl
    538  f000				  -	      asl
    539  f000				  -	      adc	#((3*16)+HSCURSORY)
    540  f000				  -	      sta	temp5	; Y
    541  f000				  -	      lda	#%01000000
    542  f000				  -	      sta	temp6
    543  f000				  -	      jsr	plotsprite
    544  f000				  -
    545  f000				  -	      ldx	hscursorx
    546  f000				  -	      ldy	hsdisplaymode
    547  f000				  -	      lda	SWCHA
    548  f000				  -	      cpy	#3
    549  f000				  -	      bne	hsskipadjustjoystick1
    550  f000				  -	      asl
    551  f000				  -	      asl
    552  f000				  -	      asl
    553  f000				  -	      asl
    554  f000				  -hsskipadjustjoystick1
    555  f000				  -	      sta	hsswcha
    556  f000				  -	      and	#%00110000
    557  f000				  -	      cmp	#%00110000
    558  f000				  -	      beq	hsjoystickskipped
    559  f000				  -	      lda	hsjoydebounce
    560  f000				  -	      beq	hsdontdebounce
    561  f000				  -	      jmp	hspostjoystick
    562  f000				  -hsdontdebounce
    563  f000				  -	      ldx	#1	; small tick sound
    564  f000				  -	      jsr	playhssfx
    565  f000				  -	      lda	hsswcha
    566  f000				  -	      and	#%00110000
    567  f000				  -	      ldx	hscursorx
    568  f000				  -	      cmp	#%00100000	; check down
    569  f000				  -	      bne	hsjoycheckup
    570  f000				  -	      ldy	hsinitialhold
    571  f000				  -	      cpx	#0
    572  f000				  -	      bne	skipavoid31_1
    573  f000				  -	      cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    574  f000				  -	      bne	skipavoid31_1
    575  f000				  -	      dey
    576  f000				  -skipavoid31_1
    577  f000				  -	      dey
    578  f000				  -	      jmp	hssetdebounce
    579  f000				  -hsjoycheckup
    580  f000				  -	      cmp	#%00010000	; check up
    581  f000				  -	      bne	hsjoystickskipped
    582  f000				  -	      ldy	hsinitialhold
    583  f000				  -	      cpx	#0
    584  f000				  -	      bne	skipavoid31_2
    585  f000				  -	      cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    586  f000				  -	      bne	skipavoid31_2
    587  f000				  -	      iny
    588  f000				  -skipavoid31_2
    589  f000				  -	      iny
    590  f000				  -hssetdebounce
    591  f000				  -	      tya
    592  f000				  -	      and	#31
    593  f000				  -	      sta	hsinitialhold
    594  f000				  -	      lda	#15
    595  f000				  -	      sta	hsjoydebounce
    596  f000				  -	      bne	hspostjoystick
    597  f000				  -hsjoystickskipped
    598  f000				  -			; check the fire button only when the stick isn't engaged
    599  f000				  -	      lda	hsinpt1
    600  f000				  -	      bpl	hsbuttonskipped
    601  f000				  -	      lda	hsjoydebounce
    602  f000				  -	      beq	hsfiredontdebounce
    603  f000				  -	      bne	hspostjoystick
    604  f000				  -hsfiredontdebounce
    605  f000				  -	      lda	hsinitialhold
    606  f000				  -	      cmp	#31
    607  f000				  -	      beq	hsmovecursorback
    608  f000				  -	      inc	hscursorx
    609  f000				  -	      inc	hsinitialpos
    610  f000				  -	      lda	hscursorx
    611  f000				  -	      cmp	#3
    612  f000				  -	      bne	skiphsentryisdone
    613  f000				  -	      lda	#0
    614  f000				  -	      sta	framecounter
    615  f000				  -	      lda	#$ff
    616  f000				  -	      sta	hsnewscoreline
    617  f000				  -	      dec	hsinitialpos
    618  f000				  -	      bne	skiphsentryisdone
    619  f000				  -hsmovecursorback
    620  f000				  -	      lda	hscursorx
    621  f000				  -	      beq	skiphsmovecursorback
    622  f000				  -	      lda	#29
    623  f000				  -	      ldx	hsinitialpos
    624  f000				  -	      sta	HSRAMInitials,x
    625  f000				  -	      dec	hsinitialpos
    626  f000				  -	      dec	hscursorx
    627  f000				  -	      dex
    628  f000				  -	      lda	HSRAMInitials,x
    629  f000				  -	      sta	hsinitialhold
    630  f000				  -skiphsmovecursorback
    631  f000				  -skiphsentryisdone
    632  f000				  -	      ldx	#0
    633  f000				  -	      jsr	playhssfx
    634  f000				  -	      lda	#20
    635  f000				  -	      sta	hsjoydebounce
    636  f000				  -	      bne	hspostjoystick
    637  f000				  -
    638  f000				  -hsbuttonskipped
    639  f000				  -	      lda	#0
    640  f000				  -	      sta	hsjoydebounce
    641  f000				  -hspostjoystick
    642  f000				  -
    643  f000				  -	      ldx	hsinitialpos
    644  f000				  -	      lda	hsinitialhold
    645  f000				  -	      sta	HSRAMInitials,x
    646  f000				  -
    647  f000				  -	      jmp	skiphschasecolors
    648  f000				  -
    649  f000				  -skipenterscorecontrol
    650  f000				  -	      jsr	hschasecolors
    651  f000				  -	      jsr	setuphsinpt1
    652  f000				  -	      lda	hsjoydebounce
    653  f000				  -	      bne	skiphschasecolors
    654  f000				  -	      lda	hsinpt1
    655  f000				  -	      bmi	returnfromhs
    656  f000				  -skiphschasecolors
    657  f000				  -
    658  f000				  -	      jsr	drawscreen
    659  f000				  -
    660  f000				  -	      lda	countdownseconds
    661  f000				  -	      beq	returnfromhs
    662  f000				  -	      jmp	keepdisplayinghs
    663  f000				  -returnfromhs
    664  f000				  -
    665  f000				  -	      ifconst	songdatastart_song_highscore
    666  f000				  -	      lda	hsdisplaymode
    667  f000				  -	      beq	skipclearHSCsong
    668  f000				  -	      lda	#0
    669  f000				  -	      sta	songtempo
    670  f000				  -skipclearHSCsong
    671  f000				  -	      endif
    672  f000				  -	      jsr	drawwait
    673  f000				  -	      jsr	clearscreen
    674  f000				  -	      lda	#0
    675  f000				  -	      ldy	#7
    676  f000				  -	      jsr	blacken320colors
    677  f000				  -	      lda	ssCTRL
    678  f000				  -	      sta	sCTRL
    679  f000				  -	      lda	ssCHARBASE
    680  f000				  -	      sta	sCHARBASE
    681  f000				  -	      rts
    682  f000				  -
    683  f000				  -setuphsinpt1
    684  f000				  -	      lda	#$ff
    685  f000				  -	      sta	hsinpt1
    686  f000				  -	      lda	hsjoydebounce
    687  f000				  -	      beq	skipdebounceadjust
    688  f000				  -	      dec	hsjoydebounce
    689  f000				  -	      bne	skipstorefirebuttonstatus
    690  f000				  -skipdebounceadjust
    691  f000				  -	      ldx	hsdisplaymode
    692  f000				  -	      cpx	#3
    693  f000				  -	      bne	hsskipadjustjoyfire1
    694  f000				  -	      lda	sINPT3
    695  f000				  -	      jmp	hsskipadjustjoyfire1done
    696  f000				  -hsskipadjustjoyfire1
    697  f000				  -	      lda	sINPT1
    698  f000				  -hsskipadjustjoyfire1done
    699  f000				  -	      sta	hsinpt1
    700  f000				  -skipstorefirebuttonstatus
    701  f000				  -	      rts
    702  f000				  -
    703  f000				  -blacken320colors
    704  f000				  -	      ldy	#7
    705  f000				  -blacken320colorsloop
    706  f000				  -	      sta	P0C2,y
    707  f000				  -	      dey
    708  f000				  -	      bpl	blacken320colorsloop
    709  f000				  -	      rts
    710  f000				  -
    711  f000				  -hschasecolors
    712  f000				  -	      lda	framecounter
    713  f000				  -	      and	#3
    714  f000				  -	      bne	hschasecolorsreturn
    715  f000				  -	      inc	hscolorchaseindex
    716  f000				  -	      lda	hscolorchaseindex
    717  f000				  -
    718  f000				  -	      sta	P5C2
    719  f000				  -	      sbc	#$02
    720  f000				  -	      sta	P4C2
    721  f000				  -	      sbc	#$02
    722  f000				  -	      sta	P3C2
    723  f000				  -	      sbc	#$02
    724  f000				  -	      sta	P2C2
    725  f000				  -	      sbc	#$02
    726  f000				  -	      sta	P1C2
    727  f000				  -hschasecolorsreturn
    728  f000				  -	      rts
    729  f000				  -
    730  f000				  -playhssfx
    731  f000				  -	      lda	hssfx_lo,x
    732  f000				  -	      sta	temp1
    733  f000				  -	      lda	hssfx_hi,x
    734  f000				  -	      sta	temp2
    735  f000				  -	      lda	#0
    736  f000				  -	      sta	temp3
    737  f000				  -	      jmp	schedulesfx
    738  f000				  -
    739  f000				  -hssfx_lo
    740  f000				  -	      .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    741  f000				  -hssfx_hi
    742  f000				  -	      .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    743  f000				  -
    744  f000				  -sfx_hsletterpositionchange
    745  f000				  -	      .byte	$10,$18,$00
    746  f000				  -	      .byte	$02,$06,$08
    747  f000				  -	      .byte	$02,$06,$04
    748  f000				  -	      .byte	$00,$00,$00
    749  f000				  -sfx_hslettertick
    750  f000				  -	      .byte	$10,$18,$00
    751  f000				  -	      .byte	$00,$00,$0a
    752  f000				  -	      .byte	$00,$00,$00
    753  f000				  -
    754  f000				  -highscorelabeladjust1
    755  f000				  -	      .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    756  f000				  -highscorelabeladjust2
    757  f000				  -	      .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    758  f000				  -
    759  f000				  -scorevarlo
    760  f000				  -	      .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    761  f000				  -scorevarhi
    762  f000				  -	      .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    763  f000				  -
    764  f000				  -	      ifnconst	HSNOLEVELNAMES
    765  f000				  -highscoredifficultytextlo
    766  f000				  -	      .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    767  f000				  -highscoredifficultytexthi
    768  f000				  -	      .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    769  f000				  -	      ifnconst	HSCUSTOMLEVELNAMES
    770  f000				  -highscoredifficultytextlen
    771  f000				  -	      .byte	22, 30, 26, 24
    772  f000				  -
    773  f000				  -easylevelname
    774  f000				  -	      .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    775  f000				  -mediumlevelname
    776  f000				  -	      .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    777  f000				  -hardlevelname
    778  f000				  -	      .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    779  f000				  -expertlevelname
    780  f000				  -	      .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    781  f000				  -	      else
    782  f000				  -	      include	"7800hsgamediffnames.asm"
    783  f000				  -	      endif		; HSCUSTOMLEVELNAMES
    784  f000				  -	      else
    785  f000				  -HSHIGHSCOREStext
    786  f000				  -	      .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    787  f000				  -	      endif		; HSNOLEVELNAMES
    788  f000				  -
    789  f000				  -highscorelabeltextlo
    790  f000				  -	      .byte	<player0label, <player1label, <player2label
    791  f000				  -highscorelabeltexthi
    792  f000				  -	      .byte	>player0label, >player1label, >player2label
    793  f000				  -
    794  f000				  -player0label
    795  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    796  f000				  -
    797  f000				  -player1label
    798  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    799  f000				  -
    800  f000				  -player2label
    801  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    802  f000				  -
    803  f000				  -
    804  f000				  -	      ifconst	HSGAMENAMELEN
    805  f000				  -HSGAMENAMEtable
    806  f000				  -	      include	"7800hsgamename.asm"
    807  f000				  -	      endif
    808  f000				  -	      ifconst	HSGAMERANKS
    809  f000				  -	      include	"7800hsgameranks.asm"
    810  f000				  -highscoreranklabel
    811  f000				  -	      .byte	$11,$00,$0d,$0a,$1a
    812  f000				  -	      endif
    813  f000				  -
    814  f000				  -			;ensure our table doesn't wrap a page...
    815  f000				  -	      if	((<*)>251)
    816  f000				  -	      align	256
    817  f000				  -	      endif
    818  f000				  -hsgameslotnumbers
    819  f000				  -	      .byte	33,34,35,36,37
    820  f000				  -	      endif
    821  f000				  -
    822  f000				  -loaddifficultytable
    823  f000				  -	      lda	gamedifficulty
    824  f000				  -	      and	#$03	; ensure the user hasn't selected an invalid difficulty
    825  f000				  -	      sta	gamedifficulty
    826  f000				  -	      cmp	hsdifficulty	; check game difficulty is the same as RAM table
    827  f000				  -	      bne	loaddifficultytablecontinue1
    828  f000				  -	      rts		; this high score difficulty table is already loaded
    829  f000				  -loaddifficultytablecontinue1
    830  f000				  -	      lda	gamedifficulty
    831  f000				  -	      sta	hsdifficulty
    832  f000				  -			;we need to check the device for the table
    833  f000				  -	      lda	hsdevice
    834  f000				  -	      bne	loaddifficultytablecontinue2
    835  f000				  -			; there's no save device. clear out this table.
    836  f000				  -	      jmp	cleardifficultytablemem
    837  f000				  -loaddifficultytablecontinue2
    838  f000				  -	      lda	hsdevice
    839  f000				  -	      and	#1
    840  f000				  -	      beq	memdeviceisntHSC
    841  f000				  -	      jmp	loaddifficultytableHSC
    842  f000				  -memdeviceisntHSC
    843  f000				  -	      jmp	loaddifficultytableAVOX
    844  f000				  -
    845  f000				  -savedifficultytable
    846  f000				  -			;*** we need to check wich device we should use...
    847  f000				  -	      lda	hsdevice
    848  f000				  -	      bne	savedifficultytablerealdevice
    849  f000				  -	      rts		; its a ram device
    850  f000				  -savedifficultytablerealdevice
    851  f000				  -	      and	#1
    852  f000				  -	      beq	savememdeviceisntHSC
    853  f000				  -	      jmp	savedifficultytableHSC
    854  f000				  -savememdeviceisntHSC
    855  f000				  -	      jmp	savedifficultytableAVOX
    856  f000				  -
    857  f000				  -savedifficultytableAVOX
    858  f000				  -			; the load call already setup the memory structure and atarivox memory location
    859  f000				  -	      jsr	savealoadedHSCtablecontinue
    860  f000				  -savedifficultytableAVOXskipconvert
    861  f000				  -	      lda	#HSIDHI
    862  f000				  -	      sta	eeprombuffer
    863  f000				  -	      lda	#HSIDLO
    864  f000				  -	      sta	eeprombuffer+1
    865  f000				  -	      lda	hsdifficulty
    866  f000				  -	      sta	eeprombuffer+2
    867  f000				  -	      lda	#32
    868  f000				  -	      jsr	AVoxWriteBytes
    869  f000				  -	      rts
    870  f000				  -
    871  f000				  -savedifficultytableHSC
    872  f000				  -			;we always load a table before reaching here, so the
    873  f000				  -			;memory structures from the load should be intact...
    874  f000				  -	      ldy	hsgameslot
    875  f000				  -	      bpl	savealoadedHSCtable
    876  f000				  -	      rts
    877  f000				  -savealoadedHSCtable
    878  f000				  -	      lda	HSCGameDifficulty,y
    879  f000				  -	      cmp	#$7F
    880  f000				  -	      bne	savealoadedHSCtablecontinue
    881  f000				  -	      jsr	initializeHSCtableentry
    882  f000				  -savealoadedHSCtablecontinue
    883  f000				  -			;convert our RAM table to HSC format and write it out...
    884  f000				  -	      ldy	#0
    885  f000				  -	      ldx	#0
    886  f000				  -savedifficultytableScores
    887  f000				  -
    888  f000				  -	      lda	HSRAMInitials,x
    889  f000				  -	      sta	temp3
    890  f000				  -	      lda	HSRAMInitials+1,x
    891  f000				  -	      sta	temp4
    892  f000				  -	      lda	HSRAMInitials+2,x
    893  f000				  -	      sta	temp5
    894  f000				  -	      jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    895  f000				  -
    896  f000				  -	      lda	temp1
    897  f000				  -	      sta	(HSGameTableLo),y
    898  f000				  -	      iny
    899  f000				  -	      lda	temp2
    900  f000				  -	      sta	(HSGameTableLo),y
    901  f000				  -	      iny
    902  f000				  -
    903  f000				  -	      lda	HSRAMScores,x
    904  f000				  -	      sta	(HSGameTableLo),y
    905  f000				  -	      iny
    906  f000				  -	      lda	HSRAMScores+1,x
    907  f000				  -	      sta	(HSGameTableLo),y
    908  f000				  -	      iny
    909  f000				  -	      lda	HSRAMScores+2,x
    910  f000				  -	      sta	(HSGameTableLo),y
    911  f000				  -	      iny
    912  f000				  -	      inx
    913  f000				  -	      inx
    914  f000				  -	      inx		; +3
    915  f000				  -	      cpx	#15
    916  f000				  -	      bne	savedifficultytableScores
    917  f000				  -	      rts
    918  f000				  -
    919  f000				  -loaddifficultytableHSC
    920  f000				  -			; routine responsible for loading the difficulty table from HSC
    921  f000				  -	      jsr	findindexHSC
    922  f000				  -	      ldy	hsgameslot
    923  f000				  -	      lda	HSCGameDifficulty,y
    924  f000				  -	      cmp	#$7F
    925  f000				  -	      bne	loaddifficultytableHSCcontinue
    926  f000				  -			;there was an error. use a new RAM table instead...
    927  f000				  -	      jmp	cleardifficultytablemem
    928  f000				  -loaddifficultytableHSCcontinue
    929  f000				  -			; parse the data into the HS memory...
    930  f000				  -	      ldy	#0
    931  f000				  -	      ldx	#0
    932  f000				  -loaddifficultytableScores
    933  f000				  -	      lda	(HSGameTableLo),y
    934  f000				  -	      sta	temp1
    935  f000				  -	      iny
    936  f000				  -	      lda	(HSGameTableLo),y
    937  f000				  -	      sta	temp2
    938  f000				  -	      jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    939  f000				  -	      iny
    940  f000				  -	      lda	(HSGameTableLo),y
    941  f000				  -	      sta	HSRAMScores,x
    942  f000				  -	      lda	temp3
    943  f000				  -	      sta	HSRAMInitials,x
    944  f000				  -	      inx
    945  f000				  -	      iny
    946  f000				  -	      lda	(HSGameTableLo),y
    947  f000				  -	      sta	HSRAMScores,x
    948  f000				  -	      lda	temp4
    949  f000				  -	      sta	HSRAMInitials,x
    950  f000				  -	      inx
    951  f000				  -	      iny
    952  f000				  -	      lda	(HSGameTableLo),y
    953  f000				  -	      sta	HSRAMScores,x
    954  f000				  -	      lda	temp5
    955  f000				  -	      sta	HSRAMInitials,x
    956  f000				  -	      inx
    957  f000				  -	      iny
    958  f000				  -	      cpx	#15
    959  f000				  -	      bne	loaddifficultytableScores
    960  f000				  -	      rts
    961  f000				  -
    962  f000				  -decodeHSCInitials
    963  f000				  -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    964  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
    965  f000				  -	      lda	#0
    966  f000				  -	      sta	temp4
    967  f000				  -	      lda	temp1
    968  f000				  -	      and	#%00011111
    969  f000				  -	      sta	temp3
    970  f000				  -
    971  f000				  -	      lda	temp2
    972  f000				  -	      and	#%00011111
    973  f000				  -	      sta	temp5
    974  f000				  -
    975  f000				  -	      lda	temp1
    976  f000				  -	      asl
    977  f000				  -	      rol	temp4
    978  f000				  -	      asl
    979  f000				  -	      rol	temp4
    980  f000				  -	      asl
    981  f000				  -	      rol	temp4
    982  f000				  -	      lda	temp2
    983  f000				  -	      asl
    984  f000				  -	      rol	temp4
    985  f000				  -	      asl
    986  f000				  -	      rol	temp4
    987  f000				  -	      rts
    988  f000				  -encodeHSCInitials
    989  f000				  -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    990  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
    991  f000				  -			; start with packing temp1...
    992  f000				  -	      lda	temp4
    993  f000				  -	      and	#%00011100
    994  f000				  -	      sta	temp1
    995  f000				  -	      asl	temp1
    996  f000				  -	      asl	temp1
    997  f000				  -	      asl	temp1
    998  f000				  -	      lda	temp3
    999  f000				  -	      and	#%00011111
   1000  f000				  -	      ora	temp1
   1001  f000				  -	      sta	temp1
   1002  f000				  -			; ...temp1 is now packed, on to temp2...
   1003  f000				  -	      lda	temp5
   1004  f000				  -	      asl
   1005  f000				  -	      asl
   1006  f000				  -	      ror	temp4
   1007  f000				  -	      ror
   1008  f000				  -	      ror	temp4
   1009  f000				  -	      ror
   1010  f000				  -	      sta	temp2
   1011  f000				  -	      rts
   1012  f000				  -
   1013  f000				  -findindexHSCerror
   1014  f000				  -			;the HSC is stuffed. return the bad slot flag
   1015  f000				  -	      ldy	#$ff
   1016  f000				  -	      sty	hsgameslot
   1017  f000				  -	      rts
   1018  f000				  -
   1019  f000				  -findindexHSC
   1020  f000				  -HSCGameID1 =	$1029
   1021  f000				  -HSCGameID2 =	$106E
   1022  f000				  -HSCGameDifficulty =	$10B3
   1023  f000				  -HSCGameIndex =	$10F8
   1024  f000				  -			; routine responsible for finding the game index from HSC
   1025  f000				  -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1026  f000				  -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1027  f000				  -	      ldy	#69	; start +1 to account for the dey
   1028  f000				  -findindexHSCloop
   1029  f000				  -	      dey
   1030  f000				  -	      bmi	findindexHSCerror
   1031  f000				  -	      lda	HSCGameDifficulty,y
   1032  f000				  -	      cmp	#$7F
   1033  f000				  -	      beq	findourindexHSC
   1034  f000				  -	      cmp	gamedifficulty
   1035  f000				  -	      bne	findindexHSCloop
   1036  f000				  -	      lda	HSCGameID1,y
   1037  f000				  -	      cmp	#HSIDHI
   1038  f000				  -	      bne	findindexHSCloop
   1039  f000				  -	      lda	HSCGameID2,y
   1040  f000				  -	      cmp	#HSIDLO
   1041  f000				  -	      bne	findindexHSCloop
   1042  f000				  -findourindexHSC
   1043  f000				  -			; if we're here we found our index in the table
   1044  f000				  -			; or we found the first empty one
   1045  f000				  -	      sty	hsgameslot
   1046  f000				  -	      jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1047  f000				  -	      rts
   1048  f000				  -
   1049  f000				  -
   1050  f000				  -initializeHSCtableentry
   1051  f000				  -	      ldy	hsgameslot
   1052  f000				  -			; we need to make a new entry...
   1053  f000				  -	      lda	#HSIDHI
   1054  f000				  -	      sta	HSCGameID1,y
   1055  f000				  -	      lda	#HSIDLO
   1056  f000				  -	      sta	HSCGameID2,y
   1057  f000				  -	      lda	gamedifficulty
   1058  f000				  -	      sta	HSCGameDifficulty,y
   1059  f000				  -	      ldx	#0
   1060  f000				  -fixHSDGameDifficultylistLoop
   1061  f000				  -	      inx
   1062  f000				  -	      txa
   1063  f000				  -	      sta	HSCGameIndex,y
   1064  f000				  -	      iny
   1065  f000				  -	      cpy	#69
   1066  f000				  -	      bne	fixHSDGameDifficultylistLoop
   1067  f000				  -	      rts
   1068  f000				  -
   1069  f000				  -setupHSCGamepointer
   1070  f000				  -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1071  f000				  -	      lda	#$17
   1072  f000				  -	      sta	HSGameTableHi
   1073  f000				  -	      lda	#$FA
   1074  f000				  -	      sta	HSGameTableLo
   1075  f000				  -setupHSCGamepointerLoop
   1076  f000				  -	      lda	HSGameTableLo
   1077  f000				  -	      sec
   1078  f000				  -	      sbc	#25
   1079  f000				  -	      sta	HSGameTableLo
   1080  f000				  -	      lda	HSGameTableHi
   1081  f000				  -	      sbc	#0
   1082  f000				  -	      sta	HSGameTableHi
   1083  f000				  -	      iny
   1084  f000				  -	      cpy	#69
   1085  f000				  -	      bne	setupHSCGamepointerLoop
   1086  f000				  -	      rts
   1087  f000				  -
   1088  f000				  -loaddifficultytableAVOX
   1089  f000				  -			; routine responsible for loading the difficulty table from Avox
   1090  f000				  -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1091  f000				  -	      lda	#>(eeprombuffer+3)
   1092  f000				  -	      sta	HSGameTableHi
   1093  f000				  -	      lda	#<(eeprombuffer+3)
   1094  f000				  -	      sta	HSGameTableLo
   1095  f000				  -
   1096  f000				  -			; the start location in EEPROM, subtract 32...
   1097  f000				  -	      lda	#$5F
   1098  f000				  -	      sta	HSVoxHi
   1099  f000				  -	      lda	#$E0
   1100  f000				  -	      sta	HSVoxLo
   1101  f000				  -	      lda	#0
   1102  f000				  -	      sta	temp1
   1103  f000				  -loaddifficultytableAVOXloop
   1104  f000				  -	      inc	temp1
   1105  f000				  -	      beq	loaddifficultytableAVOXfull
   1106  f000				  -	      clc
   1107  f000				  -	      lda	HSVoxLo
   1108  f000				  -	      adc	#32
   1109  f000				  -	      sta	HSVoxLo
   1110  f000				  -	      lda	HSVoxHi
   1111  f000				  -	      adc	#0
   1112  f000				  -	      sta	HSVoxHi
   1113  f000				  -	      lda	#3
   1114  f000				  -	      jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1115  f000				  -	      lda	eeprombuffer
   1116  f000				  -	      cmp	#$FF
   1117  f000				  -	      beq	loaddifficultytableAVOXempty
   1118  f000				  -	      cmp	#HSIDHI
   1119  f000				  -	      bne	loaddifficultytableAVOXloop
   1120  f000				  -	      lda	eeprombuffer+1
   1121  f000				  -	      cmp	#HSIDLO
   1122  f000				  -	      bne	loaddifficultytableAVOXloop
   1123  f000				  -	      lda	eeprombuffer+2
   1124  f000				  -	      cmp	gamedifficulty
   1125  f000				  -	      bne	loaddifficultytableAVOXloop
   1126  f000				  -loaddifficultytableAVOXdone
   1127  f000				  -	      lda	#32
   1128  f000				  -	      jsr	AVoxReadBytes
   1129  f000				  -	      jsr	loaddifficultytableHSCcontinue
   1130  f000				  -	      rts
   1131  f000				  -loaddifficultytableAVOXfull
   1132  f000				  -	      lda	#0
   1133  f000				  -	      sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1134  f000				  -loaddifficultytableAVOXempty
   1135  f000				  -	      jmp	cleardifficultytablemem
   1136  f000				  -	      rts
   1137  f000				  -
   1138  f000				  -cleardifficultytablemem
   1139  f000				  -	      ldy	#29
   1140  f000				  -	      lda	#0
   1141  f000				  -cleardifficultytablememloop
   1142  f000				  -	      sta	HSRAMTable,y
   1143  f000				  -	      dey
   1144  f000				  -	      bpl	cleardifficultytablememloop
   1145  f000				  -	      rts
   1146  f000				  -hiscoremoduleend
   1147  f000				  -
   1148  f000				  -	      echo	"  hiscore assembly: ",[(hiscoremoduleend-hiscoremodulestart)]d," bytes"
   1149  f000				  -
   1150  f000				  -	      ifconst	DOUBLEWIDE
   1151  f000				  -plotvaluedw
   1152  f000				  -plotdigitcount =	temp6
   1153  f000				  -	      lda	#0
   1154  f000				  -	      tay
   1155  f000				  -	      ldx	valbufend
   1156  f000				  -
   1157  f000				  -	      lda	plotdigitcount
   1158  f000				  -	      and	#1
   1159  f000				  -	      beq	pvnibble2chardw
   1160  f000				  -	      lda	#0
   1161  f000				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   1162  f000				  -	      beq	pvnibble2char_skipnibbledw
   1163  f000				  -
   1164  f000				  -pvnibble2chardw
   1165  f000				  -			; high nibble...
   1166  f000				  -	      lda	(temp7),y
   1167  f000				  -	      and	#$f0
   1168  f000				  -	      lsr
   1169  f000				  -	      lsr
   1170  f000				  -	      lsr
   1171  f000				  -	      lsr
   1172  f000				  -
   1173  f000				  -	      clc
   1174  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1175  f000				  -	      sta	VALBUFFER,x
   1176  f000				  -	      inx
   1177  f000				  -	      dec	plotdigitcount
   1178  f000				  -pvnibble2char_skipnibbledw
   1179  f000				  -			; low nibble...
   1180  f000				  -	      lda	(temp7),y
   1181  f000				  -	      and	#$0f
   1182  f000				  -	      clc
   1183  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1184  f000				  -	      sta	VALBUFFER,x
   1185  f000				  -	      inx
   1186  f000				  -	      iny
   1187  f000				  -
   1188  f000				  -	      dec	plotdigitcount
   1189  f000				  -	      bne	pvnibble2chardw
   1190  f000				  -			;point to the start of our valuebuffer
   1191  f000				  -	      clc
   1192  f000				  -	      lda	#<VALBUFFER
   1193  f000				  -	      adc	valbufend
   1194  f000				  -	      sta	temp1
   1195  f000				  -	      lda	#>VALBUFFER
   1196  f000				  -	      adc	#0
   1197  f000				  -	      sta	temp2
   1198  f000				  -
   1199  f000				  -			;advance valbufend to the end of our value buffer
   1200  f000				  -	      stx	valbufend
   1201  f000				  -
   1202  f000				  -	      ifnconst	plotvalueonscreen
   1203  f000				  -	      jmp	plotcharacters
   1204  f000				  -	      else
   1205  f000				  -	      jmp	plotcharacterslive
   1206  f000				  -	      endif
   1207  f000				  -	      endif		; DOUBLEWIDE
   1208  f000				  -
   1209  f000					      endif		; HSSUPPORT
   1210  f000
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\lessons\lesson1_gfx_modes\lesson1_2.bas.asm
   2261  f000					      endif
   2262  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2263  f000
   2264  f000							;standard routimes needed for pretty much all games
   2265  f000
   2266  f000							; some definitions used with "set debug color"
   2267  f000		       00 91	   DEBUGCALC  =	$91
   2268  f000		       00 41	   DEBUGWASTE =	$41
   2269  f000		       00 c1	   DEBUGDRAW  =	$C1
   2270  f000
   2271  f000							;NMI and IRQ handlers
   2272  f000				   NMI
   2273  f000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   2274  f000		       48		      pha		; save A
   2275  f001		       a5 4d		      lda	visibleover
   2276  f003		       49 ff		      eor	#255
   2277  f005		       85 4d		      sta	visibleover
   2278  f007				  -	      ifconst	DEBUGINTERRUPT
   2279  f007				  -	      and	#$93
   2280  f007				  -	      sta	BACKGRND
   2281  f007					      endif
   2282  f007		       ce b2 01 	      dec	interruptindex
   2283  f00a		       d0 03		      bne	skipreallyoffvisible
   2284  f00c		       4c 5e f0 	      jmp	reallyoffvisible
   2285  f00f				   skipreallyoffvisible
   2286  f00f		       a5 4d		      lda	visibleover
   2287  f011		       f0 49		      beq	skiptopscreenroutine
   2288  f013		       8a		      txa		; save X+Y
   2289  f014		       48		      pha
   2290  f015		       98		      tya
   2291  f016		       48		      pha
   2292  f017		       d8		      cld
   2293  f018					      ifconst	.topscreenroutine
   2294  f018		       20 c9 46 	      jsr	.topscreenroutine
   2295  f01b					      endif
   2296  f01b		       ee 3e 21 	      inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   2297  f01e
   2298  f01e							; ** Other important routines that need to regularly run, and can run onscreen.
   2299  f01e							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   2300  f01e
   2301  f01e				   longcontrollerreads		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   2302  f01e				  -	      ifconst	LONGCONTROLLERREAD
   2303  f01e				  -	      lda	#$38
   2304  f01e				  -	      ifconst	LONGDEBUG
   2305  f01e				  -	      sta	BACKGRND
   2306  f01e				  -	      endif
   2307  f01e				  -	      sta	inttemp6
   2308  f01e				  -
   2309  f01e				  -longreadlineloop
   2310  f01e				  -	      ldx	#1
   2311  f01e				  -longreadloop
   2312  f01e				  -	      ldy	port0control,x
   2313  f01e				  -	      lda	longreadroutinelo,y
   2314  f01e				  -	      sta	inttemp3
   2315  f01e				  -	      lda	longreadroutinehi,y
   2316  f01e				  -	      sta	inttemp4
   2317  f01e				  -	      ora	inttemp3
   2318  f01e				  -	      beq	longreadloopreturn
   2319  f01e				  -	      jmp	(inttemp3)
   2320  f01e				  -longreadloopreturn
   2321  f01e				  -	      dex
   2322  f01e				  -	      bpl	longreadloop
   2323  f01e				  -	      dec	inttemp6
   2324  f01e				  -	      sta	WSYNC
   2325  f01e				  -	      bne	longreadlineloop
   2326  f01e				  -
   2327  f01e				  -	      ifconst	LONGDEBUG
   2328  f01e				  -	      lda	#$00
   2329  f01e				  -	      sta	BACKGRND
   2330  f01e				  -	      endif
   2331  f01e					      endif		; LONGCONTROLLERREAD
   2332  f01e
   2333  f01e		       20 d0 f1 	      jsr	servicesfxchannels
   2334  f021				  -	      ifconst	MUSICTRACKER
   2335  f021				  -	      jsr	servicesong
   2336  f021					      endif		; MUSICTRACKER
   2337  f021
   2338  f021		       ee a4 01 	      inc	framecounter
   2339  f024		       ad a4 01 	      lda	framecounter
   2340  f027		       29 3f		      and	#63
   2341  f029		       d0 08		      bne	skipcountdownseconds
   2342  f02b		       ad a5 01 	      lda	countdownseconds
   2343  f02e		       f0 03		      beq	skipcountdownseconds
   2344  f030		       ce a5 01 	      dec	countdownseconds
   2345  f033				   skipcountdownseconds
   2346  f033
   2347  f033		       a2 01		      ldx	#1
   2348  f035				   buttonreadloop
   2349  f035		       8a		      txa
   2350  f036		       48		      pha
   2351  f037		       bc e2 01 	      ldy	port0control,x
   2352  f03a		       b9 b3 f1 	      lda	buttonhandlerlo,y
   2353  f03d		       85 da		      sta	inttemp3
   2354  f03f		       b9 a8 f1 	      lda	buttonhandlerhi,y
   2355  f042		       85 db		      sta	inttemp4
   2356  f044		       05 da		      ora	inttemp3
   2357  f046		       f0 03		      beq	buttonreadloopreturn
   2358  f048		       6c da 00 	      jmp	(inttemp3)
   2359  f04b				   buttonreadloopreturn
   2360  f04b		       68		      pla
   2361  f04c		       aa		      tax
   2362  f04d		       ca		      dex
   2363  f04e		       10 e5		      bpl	buttonreadloop
   2364  f050
   2365  f050				  -	      ifconst	DRIVINGSUPPORT
   2366  f050				  -	      jsr	drivingupdate
   2367  f050					      endif		; DRIVINGSUPPORT
   2368  f050				  -	      ifconst	KEYPADSUPPORT
   2369  f050				  -	      jsr	keypadrowselect
   2370  f050					      endif		; KEYPADSUPPORT
   2371  f050
   2372  f050
   2373  f050		       ad b5 01 	      lda	doublebufferminimumframeindex
   2374  f053		       f0 03		      beq	skipdoublebufferminimumframeindexadjust
   2375  f055		       ce b5 01 	      dec	doublebufferminimumframeindex
   2376  f058				   skipdoublebufferminimumframeindexadjust
   2377  f058
   2378  f058		       68		      pla
   2379  f059		       a8		      tay
   2380  f05a		       68		      pla
   2381  f05b		       aa		      tax
   2382  f05c				   skiptopscreenroutine
   2383  f05c		       68		      pla
   2384  f05d				   IRQ
   2385  f05d		       40		      RTI
   2386  f05e
   2387  f05e				  -	      ifconst	LONGCONTROLLERREAD
   2388  f05e				  -longreadroutinelo
   2389  f05e				  -			;	  NONE		PROLINE        LIGHTGUN      PADDLE
   2390  f05e				  -	      .byte	0, 0, 0, 0
   2391  f05e				  -			;	  TRKBALL	VCS STICK      DRIVING	     KEYPAD
   2392  f05e				  -	      .byte	0, 0, 0, 0
   2393  f05e				  -			;	  STMOUSE	AMOUSE	       ATARIVOX
   2394  f05e				  -	      .byte	<mouseupdate, <mouseupdate, 0
   2395  f05e				  -
   2396  f05e				  -longreadroutinehi
   2397  f05e				  -			;	  NONE		PROLINE        LIGHTGUN      PADDLE
   2398  f05e				  -	      .byte	0, 0, 0, 0
   2399  f05e				  -			;	  TRKBALL	VCS STICK      DRIVING	     KEYPAD
   2400  f05e				  -	      .byte	0, 0, 0, 0
   2401  f05e				  -			;	  STMOUSE	AMOUSE	       ATARIVOX
   2402  f05e				  -	      .byte	>mouseupdate, >mouseupdate, 0
   2403  f05e				  -nullroutine
   2404  f05e				  -	      rts
   2405  f05e					      endif		; LONGCONTROLLERREAD
   2406  f05e
   2407  f05e				   reallyoffvisible
   2408  f05e		       85 24		      sta	WSYNC
   2409  f060
   2410  f060		       a9 00		      lda	#0
   2411  f062		       85 4d		      sta	visibleover
   2412  f064				  -	      ifconst	DEBUGINTERRUPT
   2413  f064				  -	      sta	BACKGRND
   2414  f064					      endif
   2415  f064
   2416  f064		       a9 03		      lda	#3
   2417  f066		       8d b2 01 	      sta	interruptindex
   2418  f069
   2419  f069		       8a		      txa
   2420  f06a		       48		      pha
   2421  f06b		       98		      tya
   2422  f06c		       48		      pha
   2423  f06d		       d8		      cld
   2424  f06e
   2425  f06e		       20 4a f1 	      jsr	uninterruptableroutines
   2426  f071
   2427  f071				  -	      ifconst	.userinterrupt
   2428  f071				  -	      jsr	.userinterrupt
   2429  f071					      endif
   2430  f071
   2431  f071				  -	      ifconst	KEYPADSUPPORT
   2432  f071				  -	      jsr	keypadcolumnread
   2433  f071					      endif
   2434  f071
   2435  f071		       68		      pla
   2436  f072		       a8		      tay
   2437  f073		       68		      pla
   2438  f074		       aa		      tax
   2439  f075		       68		      pla
   2440  f076		       40		      RTI
   2441  f077
   2442  f077				   clearscreen
   2443  f077		       a2 0b		      ldx	#(WZONECOUNT-1)
   2444  f079		       a9 00		      lda	#0
   2445  f07b				   clearscreenloop
   2446  f07b		       95 65		      sta	dlend,x
   2447  f07d		       ca		      dex
   2448  f07e		       10 fb		      bpl	clearscreenloop
   2449  f080		       a9 00		      lda	#0
   2450  f082		       8d ad 01 	      sta	valbufend	; clear the bcd value buffer
   2451  f085		       8d ae 01 	      sta	valbufendsave
   2452  f088		       60		      rts
   2453  f089
   2454  f089				   restorescreen
   2455  f089		       a2 0b		      ldx	#(WZONECOUNT-1)
   2456  f08b		       a9 00		      lda	#0
   2457  f08d				   restorescreenloop
   2458  f08d		       b5 82		      lda	dlendsave,x
   2459  f08f		       95 65		      sta	dlend,x
   2460  f091		       ca		      dex
   2461  f092		       10 f9		      bpl	restorescreenloop
   2462  f094		       ad ae 01 	      lda	valbufendsave
   2463  f097		       8d ad 01 	      sta	valbufend
   2464  f09a		       60		      rts
   2465  f09b
   2466  f09b				   savescreen
   2467  f09b		       a2 0b		      ldx	#(WZONECOUNT-1)
   2468  f09d				   savescreenloop
   2469  f09d		       b5 65		      lda	dlend,x
   2470  f09f		       95 82		      sta	dlendsave,x
   2471  f0a1		       ca		      dex
   2472  f0a2		       10 f9		      bpl	savescreenloop
   2473  f0a4		       ad ad 01 	      lda	valbufend
   2474  f0a7		       8d ae 01 	      sta	valbufendsave
   2475  f0aa				  -	      ifconst	DOUBLEBUFFER
   2476  f0aa				  -	      lda	doublebufferstate
   2477  f0aa				  -	      beq	savescreenrts
   2478  f0aa				  -	      lda	#1
   2479  f0aa				  -	      sta	doublebufferbufferdirty
   2480  f0aa				  -savescreenrts
   2481  f0aa					      endif		; DOUBLEBUFFER
   2482  f0aa		       60		      rts
   2483  f0ab
   2484  f0ab				   drawscreen
   2485  f0ab
   2486  f0ab		       a9 00		      lda	#0
   2487  f0ad		       85 42		      sta	temp1	; not B&W if we're here...
   2488  f0af
   2489  f0af				   drawscreenwait
   2490  f0af		       a5 4d		      lda	visibleover
   2491  f0b1		       d0 fc		      bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2492  f0b3
   2493  f0b3							;restore some registers in case the game changed them mid-screen...
   2494  f0b3		       ad 07 21 	      lda	sCTRL
   2495  f0b6		       05 42		      ora	temp1
   2496  f0b8		       85 3c		      sta	CTRL
   2497  f0ba		       ad 0b 21 	      lda	sCHARBASE
   2498  f0bd		       85 34		      sta	CHARBASE
   2499  f0bf
   2500  f0bf							;ensure all of the display list is terminated...
   2501  f0bf		       20 30 f1 	      jsr	terminatedisplaylist
   2502  f0c2
   2503  f0c2					      ifnconst	pauseroutineoff
   2504  f0c2		       20 cd f0 	      jsr	pauseroutine
   2505  f0c5					      endif		; pauseroutineoff
   2506  f0c5
   2507  f0c5							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2508  f0c5							; delaying a full frame, but still allowing time for basic calculations.
   2509  f0c5				   visiblescreenstartedwait
   2510  f0c5		       a5 4d		      lda	visibleover
   2511  f0c7		       f0 fc		      beq	visiblescreenstartedwait
   2512  f0c9				   visiblescreenstartedwaitdone
   2513  f0c9		       ce 3e 21 	      dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2514  f0cc		       60		      rts
   2515  f0cd
   2516  f0cd					      ifnconst	pauseroutineoff
   2517  f0cd							; check to see if pause was pressed and released
   2518  f0cd				   pauseroutine
   2519  f0cd		       ad b6 01 	      lda	pausedisable
   2520  f0d0		       d0 4e		      bne	leavepauseroutine
   2521  f0d2		       a9 08		      lda	#8
   2522  f0d4		       2c 82 02 	      bit	SWCHB
   2523  f0d7		       f0 29		      beq	pausepressed
   2524  f0d9
   2525  f0d9					      ifnconst	SOFTRESETASPAUSEOFF
   2526  f0d9					      ifnconst	MOUSESUPPORT
   2527  f0d9		       ad 80 02 	      lda	SWCHA	; then check the soft "RESET" joysick code...
   2528  f0dc		       29 70		      and	#%01110000	; _LDU
   2529  f0de		       f0 22		      beq	pausepressed
   2530  f0e0					      endif
   2531  f0e0					      endif
   2532  f0e0
   2533  f0e0							;pause isn't pressed
   2534  f0e0		       a9 00		      lda	#0
   2535  f0e2		       8d ac 01 	      sta	pausebuttonflag	; clear pause hold state in case its set
   2536  f0e5
   2537  f0e5							;check if we're in an already paused state
   2538  f0e5		       ad 00 21 	      lda	pausestate
   2539  f0e8		       f0 36		      beq	leavepauseroutine	; nope, leave
   2540  f0ea
   2541  f0ea		       c9 01		      cmp	#1	; last frame was the start of pausing
   2542  f0ec		       f0 2b		      beq	enterpausestate2	; move from state 1 to 2
   2543  f0ee
   2544  f0ee		       c9 02		      cmp	#2
   2545  f0f0		       f0 34		      beq	carryonpausing
   2546  f0f2
   2547  f0f2							;pausestate must be >2, which means we're ending an unpause 
   2548  f0f2		       a9 00		      lda	#0
   2549  f0f4		       8d ac 01 	      sta	pausebuttonflag
   2550  f0f7		       8d 00 21 	      sta	pausestate
   2551  f0fa		       ad 07 21 	      lda	sCTRL
   2552  f0fd		       85 3c		      sta	CTRL
   2553  f0ff		       4c 20 f1 	      jmp	leavepauseroutine
   2554  f102
   2555  f102				   pausepressed
   2556  f102							;pause is pressed
   2557  f102		       ad ac 01 	      lda	pausebuttonflag
   2558  f105		       c9 ff		      cmp	#$ff
   2559  f107		       f0 1d		      beq	carryonpausing
   2560  f109
   2561  f109							;its a new press, increment the state
   2562  f109		       ee 00 21 	      inc	pausestate
   2563  f10c
   2564  f10c							;silence volume at the start and end of pausing
   2565  f10c		       a9 00		      lda	#0
   2566  f10e		       85 19		      sta	AUDV0
   2567  f110		       85 1a		      sta	AUDV1
   2568  f112
   2569  f112				  -	      ifconst	pokeysupport
   2570  f112				  -	      ldy	#7
   2571  f112				  -pausesilencepokeyaudioloop
   2572  f112				  -	      sta	(pokeybase),y
   2573  f112				  -	      dey
   2574  f112				  -	      bpl	pausesilencepokeyaudioloop
   2575  f112					      endif		; pokeysupport
   2576  f112
   2577  f112		       a9 ff		      lda	#$ff
   2578  f114		       8d ac 01 	      sta	pausebuttonflag
   2579  f117		       d0 0d		      bne	carryonpausing
   2580  f119
   2581  f119				   enterpausestate2
   2582  f119		       a9 02		      lda	#2
   2583  f11b		       8d 00 21 	      sta	pausestate
   2584  f11e		       d0 06		      bne	carryonpausing
   2585  f120				   leavepauseroutine
   2586  f120		       ad 07 21 	      lda	sCTRL
   2587  f123		       85 3c		      sta	CTRL
   2588  f125		       60		      rts
   2589  f126				   carryonpausing
   2590  f126				  -	      ifconst	.pause
   2591  f126				  -	      jsr	.pause
   2592  f126					      endif		; .pause
   2593  f126		       ad 07 21 	      lda	sCTRL
   2594  f129		       09 80		      ora	#%10000000	; turn off colorburst during pause...
   2595  f12b		       85 3c		      sta	CTRL
   2596  f12d		       4c cd f0 	      jmp	pauseroutine
   2597  f130					      endif		; pauseroutineoff
   2598  f130
   2599  f130
   2600  f130				  -	      ifconst	DOUBLEBUFFER
   2601  f130				  -skipterminatedisplaylistreturn
   2602  f130				  -	      rts
   2603  f130					      endif		; DOUBLEBUFFER
   2604  f130				   terminatedisplaylist
   2605  f130				  -	      ifconst	DOUBLEBUFFER
   2606  f130				  -	      lda	doublebufferstate
   2607  f130				  -	      bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2608  f130					      endif		; DOUBLEBUFFER
   2609  f130				   terminatedisplaybuffer
   2610  f130							;add DL end entry on each DL
   2611  f130		       a2 0b		      ldx	#(WZONECOUNT-1)
   2612  f132				   dlendloop
   2613  f132		       bd 45 f6 	      lda	DLPOINTL,x
   2614  f135				  -	      ifconst	DOUBLEBUFFER
   2615  f135				  -	      clc
   2616  f135				  -	      adc	doublebufferdloffset
   2617  f135					      endif		; DOUBLEBUFFER
   2618  f135		       85 63		      sta	dlpnt
   2619  f137		       bd 39 f6 	      lda	DLPOINTH,x
   2620  f13a				  -	      ifconst	DOUBLEBUFFER
   2621  f13a				  -	      adc	#0
   2622  f13a					      endif		; DOUBLEBUFFER
   2623  f13a		       85 64		      sta	dlpnt+1
   2624  f13c		       b4 65		      ldy	dlend,x
   2625  f13e		       a9 00		      lda	#$00
   2626  f140				   dlendmoreloops
   2627  f140		       c8		      iny
   2628  f141		       91 63		      sta	(dlpnt),y
   2629  f143				  -	      ifconst	FRAMESKIPGLITCHFIXWEAK
   2630  f143				  -	      cpy	#DLLASTOBJ+1
   2631  f143				  -	      beq	dlendthiszonedone
   2632  f143				  -	      iny
   2633  f143				  -	      iny
   2634  f143				  -	      iny
   2635  f143				  -	      iny
   2636  f143				  -	      iny
   2637  f143				  -	      sta	(dlpnt),y
   2638  f143				  -dlendthiszonedone
   2639  f143					      endif	FRAMESKIPGLITCHFIXWEAK
   2640  f143				  -	      ifconst	FRAMESKIPGLITCHFIX
   2641  f143				  -	      iny
   2642  f143				  -	      iny
   2643  f143				  -	      iny
   2644  f143				  -	      iny
   2645  f143				  -	      cpy	#DLLASTOBJ-1
   2646  f143				  -	      bcc	dlendmoreloops
   2647  f143					      endif		; FRAMESKIPGLITCHFIX
   2648  f143		       ca		      dex
   2649  f144		       10 ec		      bpl	dlendloop
   2650  f146
   2651  f146					      ifnconst	pauseroutineoff
   2652  f146		       20 cd f0 	      jsr	pauseroutine
   2653  f149					      endif		; pauseroutineoff
   2654  f149		       60		      rts
   2655  f14a
   2656  f14a				   uninterruptableroutines
   2657  f14a							; this is for routines that must happen off the visible screen, each frame.
   2658  f14a
   2659  f14a				  -	      ifconst	AVOXVOICE
   2660  f14a				  -	      jsr	serviceatarivoxqueue
   2661  f14a					      endif
   2662  f14a
   2663  f14a		       a9 00		      lda	#0
   2664  f14c		       8d e1 01 	      sta	palfastframe
   2665  f14f		       ad 09 21 	      lda	paldetected
   2666  f152		       f0 10		      beq	skippalframeadjusting
   2667  f154							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   2668  f154		       ae e0 01 	      ldx	palframes
   2669  f157		       e8		      inx
   2670  f158		       e0 05		      cpx	#5
   2671  f15a		       d0 05		      bne	palframeskipdone
   2672  f15c		       ee e1 01 	      inc	palfastframe
   2673  f15f		       a2 00		      ldx	#0
   2674  f161				   palframeskipdone
   2675  f161		       8e e0 01 	      stx	palframes
   2676  f164				   skippalframeadjusting
   2677  f164
   2678  f164				  -	      ifconst	MUSICTRACKER
   2679  f164				  -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2680  f164				  -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2681  f164				  -			; If that happens, we try again here. Chances are very small we'll run into the same
   2682  f164				  -			; problem twice, and if we do, we just drop a musical note or two.
   2683  f164				  -	      lda	sfxschedulemissed
   2684  f164				  -	      beq	servicesongwasnotmissed
   2685  f164				  -	      jsr	servicesong
   2686  f164				  -servicesongwasnotmissed
   2687  f164					      endif		; MUSICTRACKER
   2688  f164
   2689  f164		       60		      rts
   2690  f165
   2691  f165				   serviceatarivoxqueue
   2692  f165				  -	      ifconst	AVOXVOICE
   2693  f165				  -	      lda	voxlock
   2694  f165				  -	      bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2695  f165				  -skipvoxqueuesizedec
   2696  f165				  -	      jmp	processavoxvoice
   2697  f165				  -skipvoxprocessing
   2698  f165				  -	      rts
   2699  f165				  -
   2700  f165				  -processavoxvoice
   2701  f165				  -	      lda	avoxenable
   2702  f165				  -	      bne	avoxfixport
   2703  f165				  -	      SPKOUT	tempavox
   2704  f165				  -	      rts
   2705  f165				  -avoxfixport
   2706  f165				  -	      lda	#0	; restore the port to all bits as inputs...
   2707  f165				  -	      sta	CTLSWA
   2708  f165				  -	      rts
   2709  f165				  -silenceavoxvoice
   2710  f165				  -	      SPEAK	avoxsilentdata
   2711  f165				  -	      rts
   2712  f165				  -avoxsilentdata
   2713  f165				  -	      .byte	31,255
   2714  f165					      else
   2715  f165		       60		      rts
   2716  f166					      endif		; AVOXVOICE
   2717  f166
   2718  f166				   joybuttonhandler
   2719  f166		       8a		      txa
   2720  f167		       0a		      asl
   2721  f168		       a8		      tay
   2722  f169		       b9 08 00 	      lda	INPT0,y
   2723  f16c		       4a		      lsr
   2724  f16d		       9d 02 21 	      sta	sINPT1,x
   2725  f170		       b9 09 00 	      lda	INPT1,y
   2726  f173		       29 80		      and	#%10000000
   2727  f175		       1d 02 21 	      ora	sINPT1,x
   2728  f178							;eor genesisdetected0,x ; invert INPT1 if genesis is detected
   2729  f178		       9d 02 21 	      sta	sINPT1,x
   2730  f17b
   2731  f17b		       b5 0c		      lda	INPT4,x
   2732  f17d		       30 19		      bmi	.skip1bjoyfirecheck
   2733  f17f							;one button joystick is down
   2734  f17f		       49 80		      eor	#%10000000
   2735  f181		       9d 02 21 	      sta	sINPT1,x
   2736  f184
   2737  f184		       ad b1 01 	      lda	joybuttonmode
   2738  f187		       3d 9b f1 	      and	twobuttonmask,x
   2739  f18a		       f0 0c		      beq	.skip1bjoyfirecheck
   2740  f18c		       ad b1 01 	      lda	joybuttonmode
   2741  f18f		       1d 9b f1 	      ora	twobuttonmask,x
   2742  f192		       8d b1 01 	      sta	joybuttonmode
   2743  f195		       8d 82 02 	      sta	SWCHB
   2744  f198				   .skip1bjoyfirecheck
   2745  f198		       4c 4b f0 	      jmp	buttonreadloopreturn
   2746  f19b
   2747  f19b				   twobuttonmask
   2748  f19b		       04 10		      .byte.b	%00000100,%00010000
   2749  f19d
   2750  f19d				   gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2751  f19d				  -	      ifconst	LIGHTGUNSUPPORT
   2752  f19d				  -	      cpx	#0
   2753  f19d				  -	      bne	secondportgunhandler
   2754  f19d				  -firstportgunhandler
   2755  f19d				  -	      lda	SWCHA
   2756  f19d				  -	      asl
   2757  f19d				  -	      asl
   2758  f19d				  -	      asl		; shift D4 to D7
   2759  f19d				  -	      and	#%10000000
   2760  f19d				  -	      eor	#%10000000
   2761  f19d				  -	      sta	sINPT1
   2762  f19d				  -	      jmp	buttonreadloopreturn
   2763  f19d				  -secondportgunhandler
   2764  f19d				  -	      lda	SWCHA
   2765  f19d				  -	      lsr		; shift D0 into carry
   2766  f19d				  -	      lsr		; shift carry into D7
   2767  f19d				  -	      and	#%10000000
   2768  f19d				  -	      eor	#%10000000
   2769  f19d				  -	      sta	sINPT3
   2770  f19d				  -	      jmp	buttonreadloopreturn
   2771  f19d					      endif		; LIGHTGUNSUPPORT
   2772  f19d
   2773  f19d				   controlsusing2buttoncode
   2774  f19d		       00		      .byte.b	0	; 00=no controller plugged in
   2775  f19e		       01		      .byte.b	1	; 01=proline joystick
   2776  f19f		       00		      .byte.b	0	; 02=lightgun
   2777  f1a0		       00		      .byte.b	0	; 03=paddle
   2778  f1a1		       01		      .byte.b	1	; 04=trakball
   2779  f1a2		       01		      .byte.b	1	; 05=vcs joystick
   2780  f1a3		       01		      .byte.b	1	; 06=driving control
   2781  f1a4		       00		      .byte.b	0	; 07=keypad control
   2782  f1a5		       00		      .byte.b	0	; 08=st mouse/cx80
   2783  f1a6		       00		      .byte.b	0	; 09=amiga mouse
   2784  f1a7		       01		      .byte.b	1	; 10=atarivox
   2785  f1a8
   2786  f1a8				   buttonhandlerhi
   2787  f1a8		       00		      .byte.b	0	; 00=no controller plugged in
   2788  f1a9		       f1		      .byte.b	>joybuttonhandler	; 01=proline joystick
   2789  f1aa		       f1		      .byte.b	>gunbuttonhandler	; 02=lightgun
   2790  f1ab		       00		      .byte.b	0	; 03=paddle [not implemented yet]
   2791  f1ac		       f1		      .byte.b	>joybuttonhandler	; 04=trakball
   2792  f1ad		       f1		      .byte.b	>joybuttonhandler	; 05=vcs joystick
   2793  f1ae		       f1		      .byte.b	>joybuttonhandler	; 06=driving control
   2794  f1af		       00		      .byte.b	0	; 07=keypad
   2795  f1b0		       f5		      .byte.b	>mousebuttonhandler	; 08=st mouse
   2796  f1b1		       f5		      .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2797  f1b2		       f1		      .byte.b	>joybuttonhandler	; 10=atarivox
   2798  f1b3				   buttonhandlerlo
   2799  f1b3		       00		      .byte.b	0	; 00=no controller plugged in
   2800  f1b4		       66		      .byte.b	<joybuttonhandler	; 01=proline joystick
   2801  f1b5		       9d		      .byte.b	<gunbuttonhandler	; 02=lightgun 
   2802  f1b6		       00		      .byte.b	0	; 03=paddle [not implemented yet]
   2803  f1b7		       66		      .byte.b	<joybuttonhandler	; 04=trakball
   2804  f1b8		       66		      .byte.b	<joybuttonhandler	; 05=vcs joystick
   2805  f1b9		       66		      .byte.b	<joybuttonhandler	; 06=driving control
   2806  f1ba		       00		      .byte.b	0	; 07=keypad
   2807  f1bb		       4a		      .byte.b	<mousebuttonhandler	; 08=st mouse
   2808  f1bc		       4a		      .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2809  f1bd		       66		      .byte.b	<joybuttonhandler	; 10=atarivox
   2810  f1be
   2811  f1be				   drawwait
   2812  f1be		       a5 4d		      lda	visibleover
   2813  f1c0		       d0 fc		      bne	drawwait	; make sure the visible screen isn't being drawn
   2814  f1c2		       60		      rts
   2815  f1c3
   2816  f1c3				   mutetia
   2817  f1c3		       a9 00		      lda	#0
   2818  f1c5		       a2 03		      ldx	#3
   2819  f1c7				   mutetialoop
   2820  f1c7		       95 4e		      sta	sfx1pointlo,x
   2821  f1c9		       95 17		      sta	AUDF0,x
   2822  f1cb		       ca		      dex
   2823  f1cc		       10 f9		      bpl	mutetialoop
   2824  f1ce		       60		      rts
   2825  f1cf
   2826  f1cf				   servicesfxchannelsdone
   2827  f1cf					      ifnconst	pokeysupport
   2828  f1cf		       60		      rts
   2829  f1d0				  -	      else
   2830  f1d0				  -	      jmp	checkpokeyplaying
   2831  f1d0					      endif
   2832  f1d0				   servicesfxchannels
   2833  f1d0		       a2 ff		      ldx	#255
   2834  f1d2				   servicesfxchannelsloop
   2835  f1d2		       e8		      inx
   2836  f1d3					      ifnconst	TIASFXMONO
   2837  f1d3		       e0 02		      cpx	#2
   2838  f1d5				  -	      else
   2839  f1d5				  -	      cpx	#1
   2840  f1d5					      endif
   2841  f1d5		       f0 f8		      beq	servicesfxchannelsdone
   2842  f1d7
   2843  f1d7		       b5 4e		      lda	sfx1pointlo,x
   2844  f1d9		       85 dc		      sta	inttemp5
   2845  f1db		       15 50		      ora	sfx1pointhi,x
   2846  f1dd		       f0 f3		      beq	servicesfxchannelsloop
   2847  f1df		       b5 50		      lda	sfx1pointhi,x
   2848  f1e1		       85 dd		      sta	inttemp6
   2849  f1e3
   2850  f1e3		       b5 58		      lda	sfx1tick,x
   2851  f1e5		       f0 05		      beq	servicesfx_cont1	; this chunk is over, load the next!
   2852  f1e7		       d6 58		      dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2853  f1e9		       4c d2 f1 	      jmp	servicesfxchannelsloop
   2854  f1ec				   servicesfx_cont1
   2855  f1ec
   2856  f1ec		       b5 56		      lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2857  f1ee		       95 58		      sta	sfx1tick,x
   2858  f1f0
   2859  f1f0		       b5 52		      lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2860  f1f2		       f0 02		      beq	servicesfx_cont2
   2861  f1f4		       d6 52		      dec	sfx1priority,x
   2862  f1f6				   servicesfx_cont2
   2863  f1f6
   2864  f1f6		       a0 00		      ldy	#0	; play the sound
   2865  f1f8		       b1 dc		      lda	(inttemp5),y
   2866  f1fa		       85 d8		      sta	inttemp1
   2867  f1fc
   2868  f1fc				  -	      ifconst	MUSICTRACKER
   2869  f1fc				  -	      lda	sfx1notedata,x
   2870  f1fc				  -	      beq	exitmusictracker	; exit if this isn't a pitched instrument
   2871  f1fc				  -	      ldy	#0
   2872  f1fc				  -	      sty	inttemp2
   2873  f1fc				  -	      clc
   2874  f1fc				  -	      adc	(inttemp5),y
   2875  f1fc				  -	      asl		; x2
   2876  f1fc				  -	      tay
   2877  f1fc				  -	      lda	tiatrackeroctavenotes,y
   2878  f1fc				  -	      sta	AUDC0,x
   2879  f1fc				  -	      iny
   2880  f1fc				  -	      lda	tiatrackeroctavenotes,y
   2881  f1fc				  -	      sta	AUDF0,x
   2882  f1fc				  -	      ldy	#1
   2883  f1fc				  -	      jmp	sfxvolumeentrypt
   2884  f1fc				  -exitmusictracker
   2885  f1fc				  -	      lda	inttemp1
   2886  f1fc					      endif		; MUSICTRACKER
   2887  f1fc
   2888  f1fc		       18		      clc
   2889  f1fd		       75 54		      adc	sfx1poffset,x	; take into account any pitch modification
   2890  f1ff		       95 17		      sta	AUDF0,x
   2891  f201		       c8		      iny
   2892  f202		       b1 dc		      lda	(inttemp5),y
   2893  f204		       95 15		      sta	AUDC0,x
   2894  f206		       85 d9		      sta	inttemp2
   2895  f208		       c8		      iny
   2896  f209				   sfxvolumeentrypt
   2897  f209		       b1 dc		      lda	(inttemp5),y
   2898  f20b		       95 19		      sta	AUDV0,x
   2899  f20d		       c9 10		      cmp	#$10
   2900  f20f		       b0 19		      bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2901  f211
   2902  f211		       05 d9		      ora	inttemp2
   2903  f213		       05 d8		      ora	inttemp1	; check if F|C|V=0
   2904  f215		       f0 23		      beq	zerosfx	; if so, we're at the end of the sound.
   2905  f217
   2906  f217				   advancesfxpointer
   2907  f217							; advance the pointer to the next sound chunk
   2908  f217		       c8		      iny
   2909  f218		       84 da		      sty	inttemp3
   2910  f21a		       18		      clc
   2911  f21b		       b5 4e		      lda	sfx1pointlo,x
   2912  f21d		       65 da		      adc	inttemp3
   2913  f21f		       95 4e		      sta	sfx1pointlo,x
   2914  f221		       b5 50		      lda	sfx1pointhi,x
   2915  f223		       69 00		      adc	#0
   2916  f225		       95 50		      sta	sfx1pointhi,x
   2917  f227		       4c d2 f1 	      jmp	servicesfxchannelsloop
   2918  f22a
   2919  f22a				   sfxsoundloop
   2920  f22a		       48		      pha
   2921  f22b		       b5 52		      lda	sfx1priority,x
   2922  f22d		       d0 04		      bne	sfxsoundloop_carryon
   2923  f22f		       68		      pla		; fix the stack before we go
   2924  f230		       4c 17 f2 	      jmp	advancesfxpointer
   2925  f233				   sfxsoundloop_carryon
   2926  f233		       68		      pla
   2927  f234		       29 f0		      and	#$F0
   2928  f236		       4a		      lsr
   2929  f237		       4a		      lsr
   2930  f238		       4a		      lsr
   2931  f239		       4a		      lsr
   2932  f23a
   2933  f23a				   zerosfx
   2934  f23a		       95 4e		      sta	sfx1pointlo,x
   2935  f23c		       95 50		      sta	sfx1pointhi,x
   2936  f23e		       95 52		      sta	sfx1priority,x
   2937  f240		       4c d2 f1 	      jmp	servicesfxchannelsloop
   2938  f243
   2939  f243
   2940  f243				   schedulesfx
   2941  f243							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2942  f243		       a0 00		      ldy	#0
   2943  f245		       b1 e0		      lda	(sfxinstrumentlo),y
   2944  f247				  -	      ifconst	pokeysupport
   2945  f247				  -	      cmp	#$20	; POKEY?
   2946  f247				  -	      bne	scheduletiasfx
   2947  f247				  -	      jmp	schedulepokeysfx
   2948  f247					      endif
   2949  f247				   scheduletiasfx
   2950  f247							;cmp #$10 ; TIA?
   2951  f247							;beq continuescheduletiasfx
   2952  f247							; rts ; unhandled!!! 
   2953  f247				   continuescheduletiasfx
   2954  f247					      ifnconst	TIASFXMONO
   2955  f247		       a5 4e		      lda	sfx1pointlo
   2956  f249		       05 50		      ora	sfx1pointhi
   2957  f24b		       f0 13		      beq	schedulesfx1	;if channel 1 is idle, use it
   2958  f24d		       a5 4f		      lda	sfx2pointlo
   2959  f24f		       05 51		      ora	sfx2pointhi
   2960  f251		       f0 11		      beq	schedulesfx2	;if channel 2 is idle, use it
   2961  f253							; Both channels are scheduled. 
   2962  f253		       a0 01		      ldy	#1
   2963  f255		       b1 e0		      lda	(sfxinstrumentlo),y
   2964  f257		       d0 01		      bne	interruptsfx
   2965  f259		       60		      rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2966  f25a				   interruptsfx
   2967  f25a							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2968  f25a		       a5 52		      lda	sfx1priority
   2969  f25c		       c5 53		      cmp	sfx2priority
   2970  f25e		       b0 04		      bcs	schedulesfx2
   2971  f260					      endif		; !TIASFXMONO
   2972  f260
   2973  f260				   schedulesfx1
   2974  f260		       a2 00		      ldx	#0	; channel 1
   2975  f262					      ifnconst	TIASFXMONO
   2976  f262		       f0 02		      beq	skipschedulesfx2
   2977  f264				   schedulesfx2
   2978  f264		       a2 01		      ldx	#1	; channel 2
   2979  f266				   skipschedulesfx2
   2980  f266					      endif		; !TIASFXMONO
   2981  f266
   2982  f266				  -	      ifconst	MUSICTRACKER
   2983  f266				  -	      lda	sfxnoteindex
   2984  f266				  -	      bpl	skipdrumkitoverride
   2985  f266				  -	      and	#$7F	; subtract 128
   2986  f266				  -	      sec
   2987  f266				  -	      sbc	#4	; drums start at 132, i.e. octave 10
   2988  f266				  -	      asl
   2989  f266				  -	      tay
   2990  f266				  -	      lda	tiadrumkitdefinition,y
   2991  f266				  -	      sta	sfxinstrumentlo
   2992  f266				  -	      iny
   2993  f266				  -	      lda	tiadrumkitdefinition,y
   2994  f266				  -	      sta	sfxinstrumenthi
   2995  f266				  -	      lda	#0
   2996  f266				  -	      sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2997  f266				  -skipdrumkitoverride
   2998  f266					      endif		; MUSICTRACKER
   2999  f266		       a0 01		      ldy	#1	; get priority and sound-resolution (in frames)
   3000  f268		       b1 e0		      lda	(sfxinstrumentlo),y
   3001  f26a		       95 52		      sta	sfx1priority,x
   3002  f26c		       c8		      iny
   3003  f26d		       b1 e0		      lda	(sfxinstrumentlo),y
   3004  f26f		       95 56		      sta	sfx1frames,x
   3005  f271		       a5 e0		      lda	sfxinstrumentlo
   3006  f273		       18		      clc
   3007  f274		       69 03		      adc	#3
   3008  f276		       95 4e		      sta	sfx1pointlo,x
   3009  f278		       a5 e1		      lda	sfxinstrumenthi
   3010  f27a		       69 00		      adc	#0
   3011  f27c		       95 50		      sta	sfx1pointhi,x
   3012  f27e		       a5 e2		      lda	sfxpitchoffset
   3013  f280		       95 54		      sta	sfx1poffset,x
   3014  f282		       a9 00		      lda	#0
   3015  f284		       95 58		      sta	sfx1tick,x
   3016  f286		       a5 e3		      lda	sfxnoteindex
   3017  f288		       95 cd		      sta	sfx1notedata,x
   3018  f28a		       60		      rts
   3019  f28b
   3020  f28b				   plotsprite
   3021  f28b				  -	      ifconst	DOUBLEBUFFER
   3022  f28b				  -	      lda	doublebufferstate
   3023  f28b				  -	      bne	skipplotspritewait
   3024  f28b					      endif		; DOUBLEBUFFER
   3025  f28b				   plotspritewait
   3026  f28b		       a5 4d		      lda	visibleover
   3027  f28d		       d0 fc		      bne	plotspritewait
   3028  f28f				   skipplotspritewait
   3029  f28f
   3030  f28f							;arguments: 
   3031  f28f							; temp1=lo graphicdata 
   3032  f28f							; temp2=hi graphicdata 
   3033  f28f							; temp3=palette | width byte
   3034  f28f							; temp4=x
   3035  f28f							; temp5=y
   3036  f28f							; temp6=mode
   3037  f28f		       a5 46		      lda	temp5	;Y position
   3038  f291		       4a		      lsr		; 2 - Divide by 8 or 16
   3039  f292		       4a		      lsr		; 2
   3040  f293		       4a		      lsr		; 2
   3041  f294					      if	WZONEHEIGHT = 16
   3042  f294		       4a		      lsr		; 2
   3043  f295					      endif
   3044  f295
   3045  f295		       aa		      tax
   3046  f296
   3047  f296							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   3048  f296
   3049  f296		       c9 0c		      cmp	#WZONECOUNT
   3050  f298
   3051  f298		       90 0a		      bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   3052  f29a							; otherwise, check to see if the bottom half is in zone 0...
   3053  f29a
   3054  f29a					      if	WZONEHEIGHT = 16
   3055  f29a		       c9 0f		      cmp	#15
   3056  f29c				  -	      else
   3057  f29c				  -	      cmp	#31
   3058  f29c					      endif
   3059  f29c
   3060  f29c		       d0 05		      bne	exitplotsprite1
   3061  f29e		       a2 00		      ldx	#0
   3062  f2a0		       4c db f2 	      jmp	continueplotsprite2
   3063  f2a3				   exitplotsprite1
   3064  f2a3		       60		      rts
   3065  f2a4
   3066  f2a4				   continueplotsprite1
   3067  f2a4
   3068  f2a4		       bd 45 f6 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3069  f2a7				  -	      ifconst	DOUBLEBUFFER
   3070  f2a7				  -	      clc
   3071  f2a7				  -	      adc	doublebufferdloffset
   3072  f2a7					      endif		; DOUBLEBUFFER
   3073  f2a7		       85 63		      sta	dlpnt
   3074  f2a9		       bd 39 f6 	      lda	DLPOINTH,x
   3075  f2ac				  -	      ifconst	DOUBLEBUFFER
   3076  f2ac				  -	      adc	#0
   3077  f2ac					      endif		; DOUBLEBUFFER
   3078  f2ac		       85 64		      sta	dlpnt+1
   3079  f2ae
   3080  f2ae							;Create DL entry for upper part of sprite
   3081  f2ae
   3082  f2ae		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3083  f2b0
   3084  f2b0				  -	      ifconst	CHECKOVERWRITE
   3085  f2b0				  -	      cpy	#DLLASTOBJ
   3086  f2b0				  -	      beq	checkcontinueplotsprite2
   3087  f2b0				  -continueplotsprite1a
   3088  f2b0					      endif
   3089  f2b0
   3090  f2b0		       a5 42		      lda	temp1	; graphic data, lo byte
   3091  f2b2		       91 63		      sta	(dlpnt),y	;Low byte of data address
   3092  f2b4
   3093  f2b4					      ifnconst	ATOMICSPRITEUPDATE
   3094  f2b4		       c8		      iny
   3095  f2b5		       a5 47		      lda	temp6
   3096  f2b7		       91 63		      sta	(dlpnt),y
   3097  f2b9				  -	      else
   3098  f2b9				  -	      iny
   3099  f2b9				  -	      sty	temp8
   3100  f2b9				  -			;lda #0
   3101  f2b9				  -			;sta (dlpnt),y
   3102  f2b9					      endif
   3103  f2b9
   3104  f2b9		       c8		      iny
   3105  f2ba		       a5 46		      lda	temp5	;Y position
   3106  f2bc
   3107  f2bc					      if	WZONEHEIGHT = 16
   3108  f2bc		       29 0f		      and	#$0F
   3109  f2be				  -	      else		; WZONEHEIGHT = 8
   3110  f2be				  -	      and	#$7
   3111  f2be					      endif
   3112  f2be
   3113  f2be		       05 43		      ora	temp2	; graphic data, hi byte
   3114  f2c0		       91 63		      sta	(dlpnt),y
   3115  f2c2
   3116  f2c2		       c8		      iny
   3117  f2c3		       a5 44		      lda	temp3	;palette|width
   3118  f2c5		       91 63		      sta	(dlpnt),y
   3119  f2c7
   3120  f2c7		       c8		      iny
   3121  f2c8		       a5 45		      lda	temp4	;Horizontal position
   3122  f2ca		       91 63		      sta	(dlpnt),y
   3123  f2cc
   3124  f2cc		       c8		      iny
   3125  f2cd		       94 65		      sty	dlend,x
   3126  f2cf
   3127  f2cf				  -	      ifconst	ATOMICSPRITEUPDATE
   3128  f2cf				  -	      ldy	temp8
   3129  f2cf				  -	      lda	temp6
   3130  f2cf				  -	      sta	(dlpnt),y
   3131  f2cf					      endif
   3132  f2cf				   checkcontinueplotsprite2
   3133  f2cf
   3134  f2cf		       a5 46		      lda	temp5
   3135  f2d1		       29 0f		      and	#(WZONEHEIGHT-1)
   3136  f2d3
   3137  f2d3		       f0 38		      beq	doneSPDL	;branch if it is
   3138  f2d5
   3139  f2d5							;Create DL entry for lower part of sprite
   3140  f2d5
   3141  f2d5		       e8		      inx		;Next region
   3142  f2d6
   3143  f2d6		       e0 0c		      cpx	#WZONECOUNT
   3144  f2d8
   3145  f2d8		       90 01		      bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3146  f2da		       60		      rts
   3147  f2db				   continueplotsprite2
   3148  f2db
   3149  f2db		       bd 45 f6 	      lda	DLPOINTL,x	;Get pointer to next DL
   3150  f2de				  -	      ifconst	DOUBLEBUFFER
   3151  f2de				  -	      clc
   3152  f2de				  -	      adc	doublebufferdloffset
   3153  f2de					      endif		; DOUBLEBUFFER
   3154  f2de		       85 63		      sta	dlpnt
   3155  f2e0		       bd 39 f6 	      lda	DLPOINTH,x
   3156  f2e3				  -	      ifconst	DOUBLEBUFFER
   3157  f2e3				  -	      adc	#0
   3158  f2e3					      endif		; DOUBLEBUFFER
   3159  f2e3		       85 64		      sta	dlpnt+1
   3160  f2e5		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3161  f2e7
   3162  f2e7				  -	      ifconst	CHECKOVERWRITE
   3163  f2e7				  -	      cpy	#DLLASTOBJ
   3164  f2e7				  -	      bne	continueplotsprite2a
   3165  f2e7				  -	      rts
   3166  f2e7				  -continueplotsprite2a
   3167  f2e7					      endif
   3168  f2e7
   3169  f2e7		       a5 42		      lda	temp1	; graphic data, lo byte
   3170  f2e9		       91 63		      sta	(dlpnt),y
   3171  f2eb
   3172  f2eb					      ifnconst	ATOMICSPRITEUPDATE
   3173  f2eb		       c8		      iny
   3174  f2ec		       a5 47		      lda	temp6
   3175  f2ee		       91 63		      sta	(dlpnt),y
   3176  f2f0				  -	      else
   3177  f2f0				  -	      iny
   3178  f2f0				  -	      sty	temp8
   3179  f2f0				  -			;lda #0
   3180  f2f0				  -			;sta (dlpnt),y
   3181  f2f0					      endif
   3182  f2f0
   3183  f2f0		       c8		      iny
   3184  f2f1		       a5 46		      lda	temp5	;Y position
   3185  f2f3
   3186  f2f3					      if	WZONEHEIGHT = 16
   3187  f2f3		       29 0f		      and	#$0F
   3188  f2f5		       49 0f		      eor	#$0F
   3189  f2f7					      endif
   3190  f2f7				  -	      if	WZONEHEIGHT = 8
   3191  f2f7				  -	      and	#$07
   3192  f2f7				  -	      eor	#$07
   3193  f2f7					      endif
   3194  f2f7
   3195  f2f7		       85 4a		      sta	temp9
   3196  f2f9		       a5 43		      lda	temp2	; graphic data, hi byte
   3197  f2fb		       18		      clc
   3198  f2fc		       e5 4a		      sbc	temp9
   3199  f2fe		       91 63		      sta	(dlpnt),y
   3200  f300
   3201  f300		       c8		      iny
   3202  f301		       a5 44		      lda	temp3	;palette|width
   3203  f303		       91 63		      sta	(dlpnt),y
   3204  f305
   3205  f305		       c8		      iny
   3206  f306		       a5 45		      lda	temp4	;Horizontal position
   3207  f308		       91 63		      sta	(dlpnt),y
   3208  f30a
   3209  f30a		       c8		      iny
   3210  f30b		       94 65		      sty	dlend,x
   3211  f30d
   3212  f30d				  -	      ifconst	ATOMICSPRITEUPDATE
   3213  f30d				  -	      ldy	temp8
   3214  f30d				  -	      lda	temp6
   3215  f30d				  -	      sta	(dlpnt),y
   3216  f30d					      endif
   3217  f30d
   3218  f30d				   doneSPDL
   3219  f30d		       60		      rts
   3220  f30e
   3221  f30e				   lockzonex
   3222  f30e				  -	      ifconst	ZONELOCKS
   3223  f30e				  -	      ldy	dlend,x
   3224  f30e				  -	      cpy	#DLLASTOBJ
   3225  f30e				  -	      beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3226  f30e				  -	      lda	DLPOINTL,x
   3227  f30e				  -	      ifconst	DOUBLEBUFFER
   3228  f30e				  -	      clc
   3229  f30e				  -	      adc	doublebufferdloffset
   3230  f30e				  -	      endif		; DOUBLEBUFFER
   3231  f30e				  -	      sta	dlpnt
   3232  f30e				  -	      lda	DLPOINTH,x
   3233  f30e				  -	      ifconst	DOUBLEBUFFER
   3234  f30e				  -	      adc	#0
   3235  f30e				  -	      endif		; DOUBLEBUFFER
   3236  f30e				  -	      sta	dlpnt+1
   3237  f30e				  -	      iny
   3238  f30e				  -	      lda	#0
   3239  f30e				  -	      sta	(dlpnt),y
   3240  f30e				  -	      dey
   3241  f30e				  -	      tya
   3242  f30e				  -	      ldy	#(DLLASTOBJ-1)
   3243  f30e				  -	      sta	(dlpnt),y
   3244  f30e				  -	      iny
   3245  f30e				  -	      sty	dlend,x
   3246  f30e				  -lockzonexreturn
   3247  f30e				  -	      rts
   3248  f30e					      endif		; ZONELOCKS
   3249  f30e				   unlockzonex
   3250  f30e				  -	      ifconst	ZONELOCKS
   3251  f30e				  -	      ldy	dlend,x
   3252  f30e				  -	      cpy	#DLLASTOBJ
   3253  f30e				  -	      bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3254  f30e				  -	      lda	DLPOINTL,x
   3255  f30e				  -	      ifconst	DOUBLEBUFFER
   3256  f30e				  -	      clc
   3257  f30e				  -	      adc	doublebufferdloffset
   3258  f30e				  -	      endif		; DOUBLEBUFFER
   3259  f30e				  -	      sta	dlpnt
   3260  f30e				  -	      lda	DLPOINTH,x
   3261  f30e				  -	      ifconst	DOUBLEBUFFER
   3262  f30e				  -	      adc	#0
   3263  f30e				  -	      endif		; DOUBLEBUFFER
   3264  f30e				  -	      sta	dlpnt+1
   3265  f30e				  -	      dey
   3266  f30e				  -			;ldy #(DLLASTOBJ-1)
   3267  f30e				  -	      lda	(dlpnt),y
   3268  f30e				  -	      tay
   3269  f30e				  -	      sty	dlend,x
   3270  f30e				  -unlockzonexreturn
   3271  f30e					      endif		; ZONELOCKS
   3272  f30e		       60		      rts
   3273  f30f
   3274  f30f				   plotcharloop
   3275  f30f							; ** read from a data indirectly pointed to from temp8,temp9
   3276  f30f							; ** format is: lo_data, hi_data, palette|width, x, y
   3277  f30f							; ** format ends with lo_data | hi_data = 0
   3278  f30f
   3279  f30f				  -	      ifconst	DOUBLEBUFFER
   3280  f30f				  -	      lda	doublebufferstate
   3281  f30f				  -	      bne	skipplotcharloopwait
   3282  f30f					      endif		; DOUBLEBUFFER
   3283  f30f				   plotcharloopwait
   3284  f30f		       a5 4d		      lda	visibleover
   3285  f311		       d0 fc		      bne	plotcharloopwait
   3286  f313				   skipplotcharloopwait
   3287  f313				   plotcharlooploop
   3288  f313		       a0 00		      ldy	#0
   3289  f315		       b1 49		      lda	(temp8),y
   3290  f317		       85 42		      sta	temp1
   3291  f319		       c8		      iny
   3292  f31a		       b1 49		      lda	(temp8),y
   3293  f31c		       85 43		      sta	temp2
   3294  f31e		       05 42		      ora	temp1
   3295  f320		       d0 01		      bne	plotcharloopcontinue
   3296  f322							;the pointer=0, so return
   3297  f322		       60		      rts
   3298  f323				   plotcharloopcontinue
   3299  f323		       c8		      iny
   3300  f324		       b1 49		      lda	(temp8),y
   3301  f326		       85 44		      sta	temp3
   3302  f328		       c8		      iny
   3303  f329		       b1 49		      lda	(temp8),y
   3304  f32b		       85 45		      sta	temp4
   3305  f32d		       c8		      iny
   3306  f32e		       b1 49		      lda	(temp8),y
   3307  f330							;sta temp5 ; not needed with our late entry.
   3308  f330		       20 49 f3 	      jsr	plotcharactersskipentry
   3309  f333		       a5 49		      lda	temp8
   3310  f335		       18		      clc
   3311  f336		       69 05		      adc	#5
   3312  f338		       85 49		      sta	temp8
   3313  f33a		       a5 4a		      lda	temp9
   3314  f33c		       69 00		      adc	#0
   3315  f33e		       85 4a		      sta	temp9
   3316  f340		       4c 13 f3 	      jmp	plotcharlooploop
   3317  f343
   3318  f343				   plotcharacters
   3319  f343				  -	      ifconst	DOUBLEBUFFER
   3320  f343				  -	      lda	doublebufferstate
   3321  f343				  -	      bne	skipplotcharacterswait
   3322  f343					      endif		; DOUBLEBUFFER
   3323  f343				   plotcharacterswait
   3324  f343		       a5 4d		      lda	visibleover
   3325  f345		       d0 fc		      bne	plotcharacterswait
   3326  f347				   skipplotcharacterswait
   3327  f347							;arguments: 
   3328  f347							; temp1=lo charactermap
   3329  f347							; temp2=hi charactermap
   3330  f347							; temp3=palette | width byte
   3331  f347							; temp4=x
   3332  f347							; temp5=y
   3333  f347
   3334  f347		       a5 46		      lda	temp5	;Y position
   3335  f349
   3336  f349				   plotcharactersskipentry
   3337  f349
   3338  f349							;ifconst ZONEHEIGHT
   3339  f349							; if ZONEHEIGHT = 16
   3340  f349							; and #$0F
   3341  f349							; endif
   3342  f349							; if ZONEHEIGHT = 8
   3343  f349							; and #$1F
   3344  f349							; endif
   3345  f349							;else
   3346  f349							; and #$0F
   3347  f349							;endif
   3348  f349
   3349  f349		       aa		      tax
   3350  f34a		       bd 45 f6 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3351  f34d				  -	      ifconst	DOUBLEBUFFER
   3352  f34d				  -	      clc
   3353  f34d				  -	      adc	doublebufferdloffset
   3354  f34d					      endif		; DOUBLEBUFFER
   3355  f34d		       85 63		      sta	dlpnt
   3356  f34f		       bd 39 f6 	      lda	DLPOINTH,x
   3357  f352				  -	      ifconst	DOUBLEBUFFER
   3358  f352				  -	      adc	#0
   3359  f352					      endif		; DOUBLEBUFFER
   3360  f352		       85 64		      sta	dlpnt+1
   3361  f354
   3362  f354							;Create DL entry for the characters
   3363  f354
   3364  f354		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3365  f356
   3366  f356				  -	      ifconst	CHECKOVERWRITE
   3367  f356				  -	      cpy	#DLLASTOBJ
   3368  f356				  -	      bne	continueplotcharacters
   3369  f356				  -	      rts
   3370  f356				  -continueplotcharacters
   3371  f356					      endif
   3372  f356
   3373  f356		       a5 42		      lda	temp1	; character map data, lo byte
   3374  f358		       91 63		      sta	(dlpnt),y	;(1) store low address
   3375  f35a
   3376  f35a		       c8		      iny
   3377  f35b		       ad 06 21 	      lda	charactermode
   3378  f35e		       91 63		      sta	(dlpnt),y	;(2) store mode
   3379  f360
   3380  f360		       c8		      iny
   3381  f361		       a5 43		      lda	temp2	; character map, hi byte
   3382  f363		       91 63		      sta	(dlpnt),y	;(3) store high address
   3383  f365
   3384  f365		       c8		      iny
   3385  f366		       a5 44		      lda	temp3	;palette|width
   3386  f368		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   3387  f36a
   3388  f36a		       c8		      iny
   3389  f36b		       a5 45		      lda	temp4	;Horizontal position
   3390  f36d		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   3391  f36f
   3392  f36f		       c8		      iny
   3393  f370		       94 65		      sty	dlend,x	; save display list end byte
   3394  f372		       60		      rts
   3395  f373
   3396  f373
   3397  f373					      ifconst	plotvalueonscreen
   3398  f373				   plotcharacterslive
   3399  f373							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3400  f373
   3401  f373							;arguments: 
   3402  f373							; temp1=lo charactermap
   3403  f373							; temp2=hi charactermap
   3404  f373							; temp3=palette | width byte
   3405  f373							; temp4=x
   3406  f373							; temp5=y
   3407  f373
   3408  f373		       a5 46		      lda	temp5	;Y position
   3409  f375
   3410  f375		       aa		      tax
   3411  f376		       bd 45 f6 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3412  f379				  -	      ifconst	DOUBLEBUFFER
   3413  f379				  -	      clc
   3414  f379				  -	      adc	doublebufferdloffset
   3415  f379					      endif		; DOUBLEBUFFER
   3416  f379		       85 63		      sta	dlpnt
   3417  f37b		       bd 39 f6 	      lda	DLPOINTH,x
   3418  f37e				  -	      ifconst	DOUBLEBUFFER
   3419  f37e				  -	      adc	#0
   3420  f37e					      endif		; DOUBLEBUFFER
   3421  f37e		       85 64		      sta	dlpnt+1
   3422  f380
   3423  f380							;Create DL entry for the characters
   3424  f380
   3425  f380		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   3426  f382
   3427  f382				  -	      ifconst	CHECKOVERWRITE
   3428  f382				  -	      cpy	#DLLASTOBJ
   3429  f382				  -	      bne	continueplotcharacterslive
   3430  f382				  -	      rts
   3431  f382				  -continueplotcharacterslive
   3432  f382					      endif
   3433  f382
   3434  f382		       a5 42		      lda	temp1	; character map data, lo byte
   3435  f384		       91 63		      sta	(dlpnt),y	;(1) store low address
   3436  f386
   3437  f386		       c8		      iny
   3438  f387							; we don't add the second byte yet, since the charmap could briefly
   3439  f387							; render without a proper character map address, width, or position.
   3440  f387		       ad 06 21 	      lda	charactermode
   3441  f38a		       91 63		      sta	(dlpnt),y	;(2) store mode
   3442  f38c
   3443  f38c		       c8		      iny
   3444  f38d		       a5 43		      lda	temp2	; character map, hi byte
   3445  f38f		       91 63		      sta	(dlpnt),y	;(3) store high address
   3446  f391
   3447  f391		       c8		      iny
   3448  f392		       a5 44		      lda	temp3	;palette|width
   3449  f394		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   3450  f396
   3451  f396		       c8		      iny
   3452  f397		       a5 45		      lda	temp4	;Horizontal position
   3453  f399		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   3454  f39b
   3455  f39b		       c8		      iny
   3456  f39c		       94 65		      sty	dlend,x	; save display list end byte
   3457  f39e
   3458  f39e		       60		      rts
   3459  f39f					      endif		;plotcharacterslive
   3460  f39f
   3461  f39f					      ifconst	USED_PLOTVALUE
   3462  f39f				   plotvalue
   3463  f39f							; calling 7800basic command:
   3464  f39f							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3465  f39f							; ...displays the variable as BCD digits
   3466  f39f							;
   3467  f39f							; asm sub arguments: 
   3468  f39f							; temp1=lo charactermap
   3469  f39f							; temp2=hi charactermap
   3470  f39f							; temp3=palette | width byte
   3471  f39f							; temp4=x
   3472  f39f							; temp5=y
   3473  f39f							; temp6=number of digits
   3474  f39f							; temp7=lo variable
   3475  f39f							; temp8=hi variable
   3476  f39f							; temp9=character mode
   3477  f39f
   3478  f39f		       00 47	   plotdigitcount =	temp6
   3479  f39f
   3480  f39f				  -	      ifconst	ZONELOCKS
   3481  f39f				  -	      ldx	temp5
   3482  f39f				  -	      ldy	dlend,x
   3483  f39f				  -	      cpy	#DLLASTOBJ
   3484  f39f				  -	      bne	carryonplotvalue
   3485  f39f				  -	      rts
   3486  f39f				  -carryonplotvalue
   3487  f39f					      endif
   3488  f39f
   3489  f39f		       a9 00		      lda	#0
   3490  f3a1		       a8		      tay
   3491  f3a2		       ae ad 01 	      ldx	valbufend
   3492  f3a5
   3493  f3a5		       a5 47		      lda	plotdigitcount
   3494  f3a7		       29 01		      and	#1
   3495  f3a9		       f0 07		      beq	pvnibble2char
   3496  f3ab		       a9 00		      lda	#0
   3497  f3ad		       9d 00 20 	      sta	VALBUFFER,x	; just in case we skip this digit
   3498  f3b0		       f0 11		      beq	pvnibble2char_skipnibble
   3499  f3b2
   3500  f3b2				   pvnibble2char
   3501  f3b2							; high nibble...
   3502  f3b2		       b1 48		      lda	(temp7),y
   3503  f3b4		       29 f0		      and	#$f0
   3504  f3b6		       4a		      lsr
   3505  f3b7		       4a		      lsr
   3506  f3b8		       4a		      lsr
   3507  f3b9					      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3508  f3b9		       4a		      lsr
   3509  f3ba					      endif
   3510  f3ba
   3511  f3ba		       18		      clc
   3512  f3bb		       65 42		      adc	temp1	; add the offset to character graphics to our value
   3513  f3bd		       9d 00 20 	      sta	VALBUFFER,x
   3514  f3c0		       e8		      inx
   3515  f3c1		       c6 47		      dec	plotdigitcount
   3516  f3c3
   3517  f3c3				   pvnibble2char_skipnibble
   3518  f3c3							; low nibble...
   3519  f3c3		       b1 48		      lda	(temp7),y
   3520  f3c5		       29 0f		      and	#$0f
   3521  f3c7				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3522  f3c7				  -	      asl
   3523  f3c7					      endif
   3524  f3c7		       18		      clc
   3525  f3c8		       65 42		      adc	temp1	; add the offset to character graphics to our value
   3526  f3ca		       9d 00 20 	      sta	VALBUFFER,x
   3527  f3cd		       e8		      inx
   3528  f3ce		       c8		      iny
   3529  f3cf
   3530  f3cf		       c6 47		      dec	plotdigitcount
   3531  f3d1		       d0 df		      bne	pvnibble2char
   3532  f3d3
   3533  f3d3							;point to the start of our valuebuffer
   3534  f3d3		       18		      clc
   3535  f3d4		       a9 00		      lda	#<VALBUFFER
   3536  f3d6		       6d ad 01 	      adc	valbufend
   3537  f3d9		       85 42		      sta	temp1
   3538  f3db		       a9 20		      lda	#>VALBUFFER
   3539  f3dd		       69 00		      adc	#0
   3540  f3df		       85 43		      sta	temp2
   3541  f3e1
   3542  f3e1							;advance valbufend to the end of our value buffer
   3543  f3e1		       8e ad 01 	      stx	valbufend
   3544  f3e4
   3545  f3e4				  -	      ifnconst	plotvalueonscreen
   3546  f3e4				  -	      jmp	plotcharacters
   3547  f3e4					      else
   3548  f3e4		       4c 73 f3 	      jmp	plotcharacterslive
   3549  f3e7					      endif
   3550  f3e7
   3551  f3e7					      endif		; USED_PLOTVALUE
   3552  f3e7
   3553  f3e7
   3554  f3e7				  -	      ifconst	USED_PLOTVALUEEXTRA
   3555  f3e7				  -plotdigitcount =	temp6
   3556  f3e7				  -plotvalueextra
   3557  f3e7				  -			; calling 7800basic command:
   3558  f3e7				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3559  f3e7				  -			; ...displays the variable as BCD digits
   3560  f3e7				  -			;
   3561  f3e7				  -			; asm sub arguments: 
   3562  f3e7				  -			; temp1=lo charactermap
   3563  f3e7				  -			; temp2=hi charactermap
   3564  f3e7				  -			; temp3=palette | width byte
   3565  f3e7				  -			; temp4=x
   3566  f3e7				  -			; temp5=y
   3567  f3e7				  -			; temp6=number of digits
   3568  f3e7				  -			; temp7=lo variable
   3569  f3e7				  -			; temp8=hi variable
   3570  f3e7				  -
   3571  f3e7				  -	      lda	#0
   3572  f3e7				  -	      tay
   3573  f3e7				  -	      ldx	valbufend
   3574  f3e7				  -	      ifnconst	plotvalueonscreen
   3575  f3e7				  -	      sta	VALBUFFER,x
   3576  f3e7				  -	      endif
   3577  f3e7				  -
   3578  f3e7				  -	      lda	plotdigitcount
   3579  f3e7				  -	      and	#1
   3580  f3e7				  -
   3581  f3e7				  -	      bne	pvnibble2char_skipnibbleextra
   3582  f3e7				  -
   3583  f3e7				  -pvnibble2charextra
   3584  f3e7				  -			; high nibble...
   3585  f3e7				  -	      lda	(temp7),y
   3586  f3e7				  -	      and	#$f0
   3587  f3e7				  -	      lsr
   3588  f3e7				  -	      lsr
   3589  f3e7				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3590  f3e7				  -	      lsr
   3591  f3e7				  -	      endif
   3592  f3e7				  -	      clc
   3593  f3e7				  -	      adc	temp1	; add the offset to character graphics to our value
   3594  f3e7				  -	      sta	VALBUFFER,x
   3595  f3e7				  -	      inx
   3596  f3e7				  -
   3597  f3e7				  -			; second half of the digit
   3598  f3e7				  -	      clc
   3599  f3e7				  -	      adc	#1
   3600  f3e7				  -	      sta	VALBUFFER,x
   3601  f3e7				  -	      inx
   3602  f3e7				  -
   3603  f3e7				  -pvnibble2char_skipnibbleextra
   3604  f3e7				  -			; low nibble...
   3605  f3e7				  -	      lda	(temp7),y
   3606  f3e7				  -	      and	#$0f
   3607  f3e7				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3608  f3e7				  -	      asl
   3609  f3e7				  -	      endif
   3610  f3e7				  -	      asl
   3611  f3e7				  -
   3612  f3e7				  -	      clc
   3613  f3e7				  -	      adc	temp1	; add the offset to character graphics to our value
   3614  f3e7				  -	      sta	VALBUFFER,x
   3615  f3e7				  -	      inx
   3616  f3e7				  -
   3617  f3e7				  -	      clc
   3618  f3e7				  -	      adc	#1
   3619  f3e7				  -	      sta	VALBUFFER,x
   3620  f3e7				  -	      inx
   3621  f3e7				  -	      iny
   3622  f3e7				  -
   3623  f3e7				  -	      dec	plotdigitcount
   3624  f3e7				  -	      bne	pvnibble2charextra
   3625  f3e7				  -
   3626  f3e7				  -			;point to the start of our valuebuffer
   3627  f3e7				  -	      clc
   3628  f3e7				  -	      lda	#<VALBUFFER
   3629  f3e7				  -	      adc	valbufend
   3630  f3e7				  -	      sta	temp1
   3631  f3e7				  -	      lda	#>VALBUFFER
   3632  f3e7				  -	      adc	#0
   3633  f3e7				  -	      sta	temp2
   3634  f3e7				  -
   3635  f3e7				  -			;advance valbufend to the end of our value buffer
   3636  f3e7				  -	      stx	valbufend
   3637  f3e7				  -
   3638  f3e7				  -	      ifnconst	plotvalueonscreen
   3639  f3e7				  -	      jmp	plotcharacters
   3640  f3e7				  -	      else
   3641  f3e7				  -	      jmp	plotcharacterslive
   3642  f3e7				  -	      endif
   3643  f3e7					      endif		; USED_PLOTVALUEEXTRA
   3644  f3e7
   3645  f3e7				   boxcollision
   3646  f3e7							; the worst case cycle-time for the code below is 43 cycles.
   3647  f3e7							; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3648  f3e7
   3649  f3e7							;__boxx1 = accumulator
   3650  f3e7							;__boxy1 = y
   3651  f3e7		       00 44	   __boxw1    =	temp3
   3652  f3e7		       00 45	   __boxh1    =	temp4
   3653  f3e7
   3654  f3e7		       00 46	   __boxx2    =	temp5
   3655  f3e7		       00 47	   __boxy2    =	temp6
   3656  f3e7		       00 48	   __boxw2    =	temp7
   3657  f3e7		       00 49	   __boxh2    =	temp8
   3658  f3e7
   3659  f3e7				   DoXCollisionCheck
   3660  f3e7							;lda __boxx1 ; skipped. already in the accumulator
   3661  f3e7		       c5 46		      cmp	__boxx2	;3
   3662  f3e9		       b0 07		      bcs	X1isbiggerthanX2	;2/3
   3663  f3eb				   X2isbiggerthanX1
   3664  f3eb							; carry is clear
   3665  f3eb		       65 44		      adc	__boxw1	;3
   3666  f3ed		       c5 46		      cmp	__boxx2	;3
   3667  f3ef		       b0 08		      bcs	DoYCollisionCheck	;3/2
   3668  f3f1		       60		      rts		;6 - carry clear, no collision
   3669  f3f2				   X1isbiggerthanX2
   3670  f3f2		       18		      clc		;2
   3671  f3f3		       e5 48		      sbc	__boxw2	;3
   3672  f3f5		       c5 46		      cmp	__boxx2	;3
   3673  f3f7		       b0 13		      bcs	noboxcollision	;3/2
   3674  f3f9				   DoYCollisionCheck
   3675  f3f9		       98		      tya		; 2 ; use to be "lda __boxy1"
   3676  f3fa		       c5 47		      cmp	__boxy2	;3
   3677  f3fc		       b0 05		      bcs	Y1isbiggerthanY2	;3/2
   3678  f3fe				   Y2isbiggerthanY1
   3679  f3fe							; carry is clear
   3680  f3fe		       65 45		      adc	__boxh1	;3
   3681  f400		       c5 47		      cmp	__boxy2	;3
   3682  f402		       60		      rts		;6 
   3683  f403				   Y1isbiggerthanY2
   3684  f403		       18		      clc		;2
   3685  f404		       e5 49		      sbc	__boxh2	;3
   3686  f406		       c5 47		      cmp	__boxy2	;3
   3687  f408		       b0 02		      bcs	noboxcollision	;3/2
   3688  f40a				   yesboxcollision
   3689  f40a		       38		      sec		;2
   3690  f40b		       60		      rts		;6
   3691  f40c				   noboxcollision
   3692  f40c		       18		      clc		;2
   3693  f40d		       60		      rts		;6
   3694  f40e
   3695  f40e				   randomize
   3696  f40e		       a5 40		      lda	rand
   3697  f410		       4a		      lsr
   3698  f411		       26 41		      rol	rand16
   3699  f413		       90 02		      bcc	noeor
   3700  f415		       49 b4		      eor	#$B4
   3701  f417				   noeor
   3702  f417		       85 40		      sta	rand
   3703  f419		       45 41		      eor	rand16
   3704  f41b		       60		      rts
   3705  f41c
   3706  f41c							; bcd conversion routine courtesy Omegamatrix
   3707  f41c							; http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3708  f41c				   converttobcd
   3709  f41c							;value to convert is in the accumulator
   3710  f41c		       85 42		      sta	temp1
   3711  f41e		       4a		      lsr
   3712  f41f		       65 42		      adc	temp1
   3713  f421		       6a		      ror
   3714  f422		       4a		      lsr
   3715  f423		       4a		      lsr
   3716  f424		       65 42		      adc	temp1
   3717  f426		       6a		      ror
   3718  f427		       65 42		      adc	temp1
   3719  f429		       6a		      ror
   3720  f42a		       4a		      lsr
   3721  f42b		       29 3c		      and	#$3C
   3722  f42d		       85 43		      sta	temp2
   3723  f42f		       4a		      lsr
   3724  f430		       65 43		      adc	temp2
   3725  f432		       65 42		      adc	temp1
   3726  f434		       60		      rts		; return the result in the accumulator
   3727  f435
   3728  f435							; Y and A contain multiplicands, result in A
   3729  f435				   mul8
   3730  f435		       84 42		      sty	temp1
   3731  f437		       85 43		      sta	temp2
   3732  f439		       a9 00		      lda	#0
   3733  f43b				   reptmul8
   3734  f43b		       46 43		      lsr	temp2
   3735  f43d		       90 03		      bcc	skipmul8
   3736  f43f		       18		      clc
   3737  f440		       65 42		      adc	temp1
   3738  f442							;bcs donemul8 might save cycles?
   3739  f442				   skipmul8
   3740  f442							;beq donemul8 might save cycles?
   3741  f442		       06 42		      asl	temp1
   3742  f444		       d0 f5		      bne	reptmul8
   3743  f446				   donemul8
   3744  f446		       60		      rts
   3745  f447
   3746  f447				   div8
   3747  f447							; A=numerator Y=denominator, result in A
   3748  f447		       c0 02		      cpy	#2
   3749  f449		       90 0a		      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3750  f44b		       84 42		      sty	temp1
   3751  f44d		       a0 ff		      ldy	#$ff
   3752  f44f				   div8loop
   3753  f44f		       e5 42		      sbc	temp1
   3754  f451		       c8		      iny
   3755  f452		       b0 fb		      bcs	div8loop
   3756  f454				   div8end
   3757  f454		       98		      tya
   3758  f455							; result in A
   3759  f455		       60		      rts
   3760  f456
   3761  f456							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3762  f456				   mul16
   3763  f456		       84 42		      sty	temp1
   3764  f458		       85 43		      sta	temp2
   3765  f45a
   3766  f45a		       a9 00		      lda	#0
   3767  f45c		       a2 08		      ldx	#8
   3768  f45e		       46 42		      lsr	temp1
   3769  f460				   mul16_1
   3770  f460		       90 03		      bcc	mul16_2
   3771  f462		       18		      clc
   3772  f463		       65 43		      adc	temp2
   3773  f465				   mul16_2
   3774  f465		       6a		      ror
   3775  f466		       66 42		      ror	temp1
   3776  f468		       ca		      dex
   3777  f469		       d0 f5		      bne	mul16_1
   3778  f46b		       85 43		      sta	temp2
   3779  f46d		       60		      rts
   3780  f46e
   3781  f46e							; div int/int
   3782  f46e							; numerator in A, denom in temp1
   3783  f46e							; returns with quotient in A, remainder in temp1
   3784  f46e				   div16
   3785  f46e		       85 43		      sta	temp2
   3786  f470		       84 42		      sty	temp1
   3787  f472		       a9 00		      lda	#0
   3788  f474		       a2 08		      ldx	#8
   3789  f476		       06 43		      asl	temp2
   3790  f478				   div16_1
   3791  f478		       2a		      rol
   3792  f479		       c5 42		      cmp	temp1
   3793  f47b		       90 02		      bcc	div16_2
   3794  f47d		       e5 42		      sbc	temp1
   3795  f47f				   div16_2
   3796  f47f		       26 43		      rol	temp2
   3797  f481		       ca		      dex
   3798  f482		       d0 f4		      bne	div16_1
   3799  f484		       85 42		      sta	temp1
   3800  f486		       a5 43		      lda	temp2
   3801  f488		       60		      rts
   3802  f489
   3803  f489				  -	      ifconst	bankswitchmode
   3804  f489				  -BS_jsr
   3805  f489				  -	      ifconst	MCPDEVCART
   3806  f489				  -	      ora	#$18
   3807  f489				  -	      sta	$3000
   3808  f489				  -	      else
   3809  f489				  -	      sta	$8000
   3810  f489				  -	      endif
   3811  f489				  -	      pla
   3812  f489				  -	      tax
   3813  f489				  -	      pla
   3814  f489				  -	      rts
   3815  f489				  -
   3816  f489				  -BS_return
   3817  f489				  -	      pla		; bankswitch bank
   3818  f489				  -	      ifconst	BANKRAM
   3819  f489				  -	      sta	currentbank
   3820  f489				  -	      ora	currentrambank
   3821  f489				  -	      endif
   3822  f489				  -	      ifconst	MCPDEVCART
   3823  f489				  -	      ora	#$18
   3824  f489				  -	      sta	$3000
   3825  f489				  -	      else
   3826  f489				  -	      sta	$8000
   3827  f489				  -	      endif
   3828  f489				  -	      pla		; bankswitch $0 flag
   3829  f489				  -	      rts
   3830  f489					      endif
   3831  f489
   3832  f489				   checkselectswitch
   3833  f489		       ad 82 02 	      lda	SWCHB	; first check the real select switch...
   3834  f48c		       29 02		      and	#%00000010
   3835  f48e					      ifnconst	MOUSESUPPORT
   3836  f48e		       f0 05		      beq	checkselectswitchreturn	; switch is pressed
   3837  f490		       ad 80 02 	      lda	SWCHA	; then check the soft "select" joysick code...
   3838  f493		       29 b0		      and	#%10110000	; R_DU
   3839  f495					      endif		; MOUSESUPPORT
   3840  f495				   checkselectswitchreturn
   3841  f495		       60		      rts
   3842  f496
   3843  f496				   checkresetswitch
   3844  f496		       ad 82 02 	      lda	SWCHB	; first check the real reset switch...
   3845  f499		       29 01		      and	#%00000001
   3846  f49b					      ifnconst	MOUSESUPPORT
   3847  f49b		       f0 05		      beq	checkresetswitchreturn	; switch is pressed
   3848  f49d		       ad 80 02 	      lda	SWCHA	; then check the soft "reset" joysick code...
   3849  f4a0		       29 70		      and	#%01110000	; _LDU
   3850  f4a2					      endif		; MOUSESUPPORT
   3851  f4a2				   checkresetswitchreturn
   3852  f4a2		       60		      rts
   3853  f4a3
   3854  f4a3				  -	      ifconst	FINESCROLLENABLED
   3855  f4a3				  -finescrolldlls
   3856  f4a3				  -	      ldx	temp1	; first DLL index x3
   3857  f4a3				  -	      lda	DLLMEM,x
   3858  f4a3				  -	      and	#%11110000
   3859  f4a3				  -	      ora	finescrolly
   3860  f4a3				  -	      sta	DLLMEM,x
   3861  f4a3				  -
   3862  f4a3				  -	      ldx	temp2	; last DLL index x3
   3863  f4a3				  -	      lda	DLLMEM,x
   3864  f4a3				  -	      and	#%11110000
   3865  f4a3				  -	      ora	finescrolly
   3866  f4a3				  -	      eor	#(WZONEHEIGHT-1)
   3867  f4a3				  -	      sta	DLLMEM,x
   3868  f4a3				  -	      rts
   3869  f4a3					      endif		; FINESCROLLENABLED
   3870  f4a3
   3871  f4a3				  -	      ifconst	USED_ADJUSTVISIBLE
   3872  f4a3				  -adjustvisible
   3873  f4a3				  -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3874  f4a3				  -	      jsr	waitforvblankstart	; ensure vblank just started
   3875  f4a3				  -	      ldx	visibleDLLstart
   3876  f4a3				  -findfirstinterrupt
   3877  f4a3				  -	      lda	DLLMEM,x
   3878  f4a3				  -	      bmi	foundfirstinterrupt
   3879  f4a3				  -	      inx
   3880  f4a3				  -	      inx
   3881  f4a3				  -	      inx
   3882  f4a3				  -	      bne	findfirstinterrupt
   3883  f4a3				  -foundfirstinterrupt
   3884  f4a3				  -	      and	#%01111111	; clear the interrupt bit
   3885  f4a3				  -	      sta	DLLMEM,x
   3886  f4a3				  -	      ifconst	DOUBLEBUFFER
   3887  f4a3				  -	      sta	DLLMEM+DBOFFSET,x
   3888  f4a3				  -	      endif		; DOUBLEBUFFER
   3889  f4a3				  -	      ldx	overscanDLLstart
   3890  f4a3				  -findlastinterrupt
   3891  f4a3				  -	      lda	DLLMEM,x
   3892  f4a3				  -	      bmi	foundlastinterrupt
   3893  f4a3				  -	      dex
   3894  f4a3				  -	      dex
   3895  f4a3				  -	      dex
   3896  f4a3				  -	      bne	findlastinterrupt
   3897  f4a3				  -foundlastinterrupt
   3898  f4a3				  -	      and	#%01111111	; clear the interrupt bit
   3899  f4a3				  -	      sta	DLLMEM,x
   3900  f4a3				  -	      ifconst	DOUBLEBUFFER
   3901  f4a3				  -	      sta	DLLMEM+DBOFFSET,x
   3902  f4a3				  -	      endif		; DOUBLEBUFFER
   3903  f4a3				  -			;now we need to set the new interrupts
   3904  f4a3				  -	      clc
   3905  f4a3				  -	      lda	temp1
   3906  f4a3				  -	      adc	visibleDLLstart
   3907  f4a3				  -	      tax
   3908  f4a3				  -	      lda	DLLMEM,x
   3909  f4a3				  -	      ora	#%10000000
   3910  f4a3				  -	      sta	DLLMEM,x
   3911  f4a3				  -	      ifconst	DOUBLEBUFFER
   3912  f4a3				  -	      sta	DLLMEM+DBOFFSET,x
   3913  f4a3				  -	      endif		; DOUBLEBUFFER
   3914  f4a3				  -	      clc
   3915  f4a3				  -	      lda	temp2
   3916  f4a3				  -	      adc	visibleDLLstart
   3917  f4a3				  -	      tax
   3918  f4a3				  -	      lda	DLLMEM,x
   3919  f4a3				  -	      ora	#%10000000
   3920  f4a3				  -	      sta	DLLMEM,x
   3921  f4a3				  -	      ifconst	DOUBLEBUFFER
   3922  f4a3				  -	      sta	DLLMEM+DBOFFSET,x
   3923  f4a3				  -	      endif		; DOUBLEBUFFER
   3924  f4a3				  -	      jsr	vblankresync
   3925  f4a3				  -	      rts
   3926  f4a3					      endif		; USED_ADJUSTVISIBLE
   3927  f4a3
   3928  f4a3				   vblankresync
   3929  f4a3		       20 41 f5 	      jsr	waitforvblankstart	; ensure vblank just started
   3930  f4a6		       a9 00		      lda	#0
   3931  f4a8		       85 4d		      sta	visibleover
   3932  f4aa		       a9 03		      lda	#3
   3933  f4ac		       8d b2 01 	      sta	interruptindex
   3934  f4af		       60		      rts
   3935  f4b0
   3936  f4b0				   createallgamedlls
   3937  f4b0		       a2 00		      ldx	#0
   3938  f4b2		       a9 19		      lda	#NVLINES
   3939  f4b4		       ac 09 21 	      ldy	paldetected
   3940  f4b7		       f0 03		      beq	skipcreatePALpadding
   3941  f4b9		       18		      clc
   3942  f4ba		       69 15		      adc	#21
   3943  f4bc				   skipcreatePALpadding
   3944  f4bc		       20 f1 f4 	      jsr	createnonvisibledlls
   3945  f4bf		       8e 3c 21 	      stx	visibleDLLstart
   3946  f4c2		       20 22 f5 	      jsr	createvisiblezones
   3947  f4c5		       8e 3d 21 	      stx	overscanDLLstart
   3948  f4c8				   createallgamedllscontinue
   3949  f4c8		       a9 50		      lda	#(NVLINES+55)	; extras for PAL
   3950  f4ca		       20 f1 f4 	      jsr	createnonvisibledlls
   3951  f4cd
   3952  f4cd		       ae 3c 21 	      ldx	visibleDLLstart
   3953  f4d0		       bd 00 18 	      lda	DLLMEM,x
   3954  f4d3		       09 80		      ora	#%10000000	; NMI 1 - start of visible screen
   3955  f4d5		       9d 00 18 	      sta	DLLMEM,x
   3956  f4d8				  -	      ifconst	DOUBLEBUFFER
   3957  f4d8				  -	      sta	DLLMEM+DBOFFSET,x
   3958  f4d8					      endif		; DOUBLEBUFFER
   3959  f4d8
   3960  f4d8		       ae 3d 21 	      ldx	overscanDLLstart
   3961  f4db		       bd 00 18 	      lda	DLLMEM,x
   3962  f4de		       09 83		      ora	#%10000011	; NMI 2 - end of visible screen
   3963  f4e0		       29 f3		      and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3964  f4e2		       9d 00 18 	      sta	DLLMEM,x
   3965  f4e5				  -	      ifconst	DOUBLEBUFFER
   3966  f4e5				  -	      sta	DLLMEM+DBOFFSET,x
   3967  f4e5					      endif		; DOUBLEBUFFER
   3968  f4e5
   3969  f4e5		       e8		      inx
   3970  f4e6		       e8		      inx
   3971  f4e7		       e8		      inx
   3972  f4e8
   3973  f4e8		       bd 00 18 	      lda	DLLMEM,x
   3974  f4eb		       09 80		      ora	#%10000000	; NMI 3 - deeper overscan
   3975  f4ed		       9d 00 18 	      sta	DLLMEM,x
   3976  f4f0				  -	      ifconst	DOUBLEBUFFER
   3977  f4f0				  -	      sta	DLLMEM+DBOFFSET,x
   3978  f4f0					      endif		; DOUBLEBUFFER
   3979  f4f0
   3980  f4f0		       60		      rts
   3981  f4f1
   3982  f4f1				   createnonvisibledlls
   3983  f4f1		       85 42		      sta	temp1
   3984  f4f3		       4a		      lsr
   3985  f4f4		       4a		      lsr
   3986  f4f5		       4a		      lsr
   3987  f4f6		       4a		      lsr		; /16
   3988  f4f7		       f0 09		      beq	skipcreatenonvisibledlls1loop
   3989  f4f9		       a8		      tay
   3990  f4fa				   createnonvisibledlls1loop
   3991  f4fa		       a9 4f		      lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3992  f4fc		       20 11 f5 	      jsr	createblankdllentry
   3993  f4ff		       88		      dey
   3994  f500		       d0 f8		      bne	createnonvisibledlls1loop
   3995  f502				   skipcreatenonvisibledlls1loop
   3996  f502		       a5 42		      lda	temp1
   3997  f504		       29 0f		      and	#%00001111
   3998  f506		       f0 08		      beq	createnonvisibledllsreturn
   3999  f508		       38		      sec
   4000  f509		       e9 01		      sbc	#1
   4001  f50b		       09 40		      ora	#%01000000
   4002  f50d		       20 11 f5 	      jsr	createblankdllentry
   4003  f510				   createnonvisibledllsreturn
   4004  f510		       60		      rts
   4005  f511
   4006  f511				   createblankdllentry
   4007  f511		       9d 00 18 	      sta	DLLMEM,x
   4008  f514				  -	      ifconst	DOUBLEBUFFER
   4009  f514				  -	      sta	DLLMEM+DBOFFSET,x
   4010  f514					      endif		; DOUBLEBUFFER
   4011  f514		       e8		      inx
   4012  f515		       a9 21		      lda	#$21	; blank
   4013  f517		       9d 00 18 	      sta	DLLMEM,x
   4014  f51a				  -	      ifconst	DOUBLEBUFFER
   4015  f51a				  -	      sta	DLLMEM+DBOFFSET,x
   4016  f51a					      endif		; DOUBLEBUFFER
   4017  f51a		       e8		      inx
   4018  f51b		       a9 00		      lda	#$00
   4019  f51d		       9d 00 18 	      sta	DLLMEM,x
   4020  f520				  -	      ifconst	DOUBLEBUFFER
   4021  f520				  -	      sta	DLLMEM+DBOFFSET,x
   4022  f520					      endif		; DOUBLEBUFFER
   4023  f520		       e8		      inx
   4024  f521		       60		      rts
   4025  f522
   4026  f522				   createvisiblezones
   4027  f522		       a0 00		      ldy	#0
   4028  f524				   createvisiblezonesloop
   4029  f524		       b9 51 f6 	      lda.w	DLHEIGHT,y
   4030  f527		       09 40		      ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   4031  f529		       9d 00 18 	      sta	DLLMEM,x
   4032  f52c				  -	      ifconst	DOUBLEBUFFER
   4033  f52c				  -	      sta	DLLMEM+DBOFFSET,x
   4034  f52c					      endif		; DOUBLEBUFFER
   4035  f52c		       e8		      inx
   4036  f52d		       b9 39 f6 	      lda	DLPOINTH,y
   4037  f530		       9d 00 18 	      sta	DLLMEM,x
   4038  f533				  -	      ifconst	DOUBLEBUFFER
   4039  f533				  -	      sta	DLLMEM+DBOFFSET,x
   4040  f533					      endif		; DOUBLEBUFFER
   4041  f533		       e8		      inx
   4042  f534		       b9 45 f6 	      lda	DLPOINTL,y
   4043  f537		       9d 00 18 	      sta	DLLMEM,x
   4044  f53a				  -	      ifconst	DOUBLEBUFFER
   4045  f53a				  -	      clc
   4046  f53a				  -	      adc	#DOUBLEBUFFEROFFSET
   4047  f53a				  -	      sta	DLLMEM+DBOFFSET,x
   4048  f53a				  -	      bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   4049  f53a				  -	      inc	DLLMEM+DBOFFSET-1,x
   4050  f53a				  -skiphidoublebufferadjust
   4051  f53a					      endif		; DOUBLEBUFFER
   4052  f53a		       e8		      inx
   4053  f53b		       c8		      iny
   4054  f53c		       c0 0c		      cpy	#WZONECOUNT
   4055  f53e		       d0 e4		      bne	createvisiblezonesloop
   4056  f540		       60		      rts
   4057  f541
   4058  f541				   waitforvblankstart
   4059  f541				   visibleoverwait
   4060  f541		       24 28		      BIT	MSTAT
   4061  f543		       10 fc		      bpl	visibleoverwait
   4062  f545				   vblankstartwait
   4063  f545		       24 28		      BIT	MSTAT
   4064  f547		       30 fc		      bmi	vblankstartwait
   4065  f549		       60		      rts
   4066  f54a
   4067  f54a				  -	      ifconst	DOUBLEBUFFER
   4068  f54a				  -flipdisplaybufferreturn
   4069  f54a				  -	      rts
   4070  f54a				  -flipdisplaybuffer
   4071  f54a				  -	      lda	doublebufferstate
   4072  f54a				  -	      beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4073  f54a				  -
   4074  f54a				  -	      jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4075  f54a				  -
   4076  f54a				  -	      lda	doublebufferstate
   4077  f54a				  -	      lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4078  f54a				  -	      tax
   4079  f54a				  -
   4080  f54a				  -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4081  f54a				  -
   4082  f54a				  -flipdisplaybufferwait1
   4083  f54a				  -	      lda	visibleover
   4084  f54a				  -	      beq	flipdisplaybufferwait1
   4085  f54a				  -
   4086  f54a				  -flipdisplaybufferwait
   4087  f54a				  -	      lda	visibleover
   4088  f54a				  -	      bne	flipdisplaybufferwait
   4089  f54a				  -
   4090  f54a				  -	      lda	doublebufferminimumframetarget
   4091  f54a				  -	      beq	skipminimumframecode
   4092  f54a				  -	      lda	doublebufferminimumframeindex
   4093  f54a				  -	      bne	flipdisplaybufferwait1
   4094  f54a				  -	      lda	doublebufferminimumframetarget
   4095  f54a				  -	      sta	doublebufferminimumframeindex
   4096  f54a				  -skipminimumframecode
   4097  f54a				  -
   4098  f54a				  -	      lda	DLLMEMLutHi,x
   4099  f54a				  -	      sta	DPPH
   4100  f54a				  -	      lda	DLLMEMLutLo,x
   4101  f54a				  -	      sta	DPPL
   4102  f54a				  -
   4103  f54a				  -	      lda	NewPageflipstate,x
   4104  f54a				  -	      sta	doublebufferstate
   4105  f54a				  -	      lda	NewPageflipoffset,x
   4106  f54a				  -	      sta	doublebufferdloffset
   4107  f54a				  -
   4108  f54a				  -	      lda	doublebufferbufferdirty
   4109  f54a				  -	      beq	flipdisplaybufferreturn
   4110  f54a				  -
   4111  f54a				  -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4112  f54a				  -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4113  f54a				  -			; from the displayed buffer to the working buffer...
   4114  f54a				  -
   4115  f54a				  -	      lda	doublebufferdloffset
   4116  f54a				  -	      eor	#DOUBLEBUFFEROFFSET
   4117  f54a				  -	      sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4118  f54a				  -
   4119  f54a				  -	      ldx	#(WZONECOUNT-1)
   4120  f54a				  -copybufferzoneloop
   4121  f54a				  -
   4122  f54a				  -	      lda	DLPOINTL,x
   4123  f54a				  -	      clc
   4124  f54a				  -	      adc	doublebufferdloffset
   4125  f54a				  -	      sta	temp1
   4126  f54a				  -	      lda	DLPOINTH,x
   4127  f54a				  -	      adc	#0
   4128  f54a				  -	      sta	temp2
   4129  f54a				  -
   4130  f54a				  -	      lda	DLPOINTL,x
   4131  f54a				  -	      clc
   4132  f54a				  -	      adc	temp6
   4133  f54a				  -	      sta	temp3
   4134  f54a				  -	      lda	DLPOINTH,x
   4135  f54a				  -	      adc	#0
   4136  f54a				  -	      sta	temp4
   4137  f54a				  -
   4138  f54a				  -	      lda	dlendsave,x
   4139  f54a				  -	      tay
   4140  f54a				  -copybuffercharsloop
   4141  f54a				  -	      lda	(temp3),y
   4142  f54a				  -	      sta	(temp1),y
   4143  f54a				  -	      dey
   4144  f54a				  -	      bpl	copybuffercharsloop
   4145  f54a				  -	      dex
   4146  f54a				  -	      bpl	copybufferzoneloop
   4147  f54a				  -	      lda	#0
   4148  f54a				  -	      sta	doublebufferbufferdirty
   4149  f54a				  -	      rts
   4150  f54a				  -
   4151  f54a				  -doublebufferoff
   4152  f54a				  -	      lda	#1
   4153  f54a				  -	      sta	doublebufferstate
   4154  f54a				  -	      jsr	flipdisplaybuffer
   4155  f54a				  -	      lda	#0
   4156  f54a				  -	      sta	doublebufferstate
   4157  f54a				  -	      sta	doublebufferdloffset
   4158  f54a				  -	      rts
   4159  f54a				  -
   4160  f54a				  -DLLMEMLutLo
   4161  f54a				  -	      .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   4162  f54a				  -DLLMEMLutHi
   4163  f54a				  -	      .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   4164  f54a				  -NewPageflipstate
   4165  f54a				  -	      .byte	3,1
   4166  f54a				  -NewPageflipoffset
   4167  f54a				  -	      .byte	DOUBLEBUFFEROFFSET,0
   4168  f54a				  -
   4169  f54a					      endif		; DOUBLEBUFFER
   4170  f54a
   4171  f54a				  -	      ifconst	MOUSESUPPORT
   4172  f54a				  -	      ifnconst	DRIVINGSUPPORT
   4173  f54a				  -rotationalcompare
   4174  f54a				  -			; new=00, old=xx
   4175  f54a				  -	      .byte	$00, $01, $ff, $00
   4176  f54a				  -			; new=01, old=xx
   4177  f54a				  -	      .byte	$ff, $00, $00, $01
   4178  f54a				  -			; new=10, old=xx
   4179  f54a				  -	      .byte	$01, $00, $00, $ff
   4180  f54a				  -			; new=11, old=xx
   4181  f54a				  -	      .byte	$00, $ff, $01, $00
   4182  f54a				  -	      endif
   4183  f54a				  -
   4184  f54a				  -			;  0000YyXx st mouse
   4185  f54a				  -			;  0000xyXY amiga mouse
   4186  f54a				  -amigatoataribits		; swap bits 1 and 4...
   4187  f54a				  -	      .byte	%00000000, %00001000, %00000010, %00001010
   4188  f54a				  -	      .byte	%00000100, %00001100, %00000110, %00001110
   4189  f54a				  -	      .byte	%00000001, %00001001, %00000011, %00001011
   4190  f54a				  -	      .byte	%00000101, %00001101, %00000111, %00001111
   4191  f54a				  -
   4192  f54a				  -mouseupdate
   4193  f54a				  -			;LONGDEBUG = 1
   4194  f54a				  -	      lda	SWCHA
   4195  f54a				  -	      and	#$0f
   4196  f54a				  -	      sta	inttemp2
   4197  f54a				  -	      lda	SWCHA
   4198  f54a				  -	      lsr
   4199  f54a				  -	      lsr
   4200  f54a				  -	      lsr
   4201  f54a				  -	      lsr
   4202  f54a				  -	      sta	inttemp1
   4203  f54a				  -
   4204  f54a				  -	      lda	port0control,x
   4205  f54a				  -	      cmp	#8	; st mouse
   4206  f54a				  -	      beq	domousecontrol
   4207  f54a				  -	      cmp	#9	; amiga mouse
   4208  f54a				  -	      bne	skipmousecontrol
   4209  f54a				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   4210  f54a				  -			;  0000YyXx st mouse
   4211  f54a				  -			;  0000xyXY amiga mouse
   4212  f54a				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   4213  f54a				  -	      lda	inttemp1,x
   4214  f54a				  -	      tay
   4215  f54a				  -	      lda	amigatoataribits,y
   4216  f54a				  -	      sta	inttemp1,x
   4217  f54a				  -domousecontrol
   4218  f54a				  -			;port X has a mouse enabled
   4219  f54a				  -	      lda	inttemp1,x
   4220  f54a				  -	      and	#%00000011
   4221  f54a				  -	      asl
   4222  f54a				  -	      asl
   4223  f54a				  -	      ora	mousecodex0,x
   4224  f54a				  -	      and	#%00001111
   4225  f54a				  -	      tay
   4226  f54a				  -	      lda	rotationalcompare,y
   4227  f54a				  -	      clc
   4228  f54a				  -	      adc	mousex0,x
   4229  f54a				  -	      sta	mousex0,x
   4230  f54a				  -	      tya
   4231  f54a				  -	      lsr
   4232  f54a				  -	      lsr
   4233  f54a				  -	      sta	mousecodex0,x
   4234  f54a				  -
   4235  f54a				  -	      lda	inttemp1,x
   4236  f54a				  -	      and	#%00001100
   4237  f54a				  -	      ora	mousecodey0,x
   4238  f54a				  -	      and	#%00001111
   4239  f54a				  -	      tay
   4240  f54a				  -	      lda	rotationalcompare,y
   4241  f54a				  -	      asl		; *2 for y axis, since it has ~double the resolution of x
   4242  f54a				  -	      clc
   4243  f54a				  -	      adc	mousey0,x
   4244  f54a				  -	      sta	mousey0,x
   4245  f54a				  -	      tya
   4246  f54a				  -	      lsr
   4247  f54a				  -	      lsr
   4248  f54a				  -	      sta	mousecodey0,x
   4249  f54a				  -skipmousecontrol
   4250  f54a				  -	      jmp	longreadloopreturn
   4251  f54a					      endif		; MOUSESUPPORT
   4252  f54a
   4253  f54a				   mousebuttonhandler		; outside of conditional, so button handler entry in LUT is valid
   4254  f54a				  -	      ifconst	MOUSESUPPORT
   4255  f54a				  -			; stick the mouse buttons in the correct shadow register...
   4256  f54a				  -	      txa
   4257  f54a				  -	      asl
   4258  f54a				  -	      tay		; y=x*2
   4259  f54a				  -	      lda	INPT1,y
   4260  f54a				  -	      eor	#%10000000
   4261  f54a				  -	      lsr
   4262  f54a				  -	      sta	sINPT1,x
   4263  f54a				  -
   4264  f54a				  -	      lda	INPT4,x
   4265  f54a				  -	      and	#%10000000
   4266  f54a				  -	      eor	#%10000000
   4267  f54a				  -	      ora	sINPT1,x
   4268  f54a				  -	      sta	sINPT1,x
   4269  f54a				  -	      jmp	buttonreadloopreturn
   4270  f54a					      endif		; MOUSESUPPORT
   4271  f54a
   4272  f54a				  -	      ifconst	DRIVINGSUPPORT
   4273  f54a				  -rotationalcompare
   4274  f54a				  -			; new=00, old=xx
   4275  f54a				  -	      .byte	$00, $01, $ff, $00
   4276  f54a				  -			; new=01, old=xx
   4277  f54a				  -	      .byte	$ff, $00, $00, $01
   4278  f54a				  -			; new=10, old=xx
   4279  f54a				  -	      .byte	$01, $00, $00, $ff
   4280  f54a				  -			; new=11, old=xx
   4281  f54a				  -	      .byte	$00, $ff, $01, $00
   4282  f54a				  -drivingupdate
   4283  f54a				  -	      ldx	#1
   4284  f54a				  -	      lda	port1control
   4285  f54a				  -	      cmp	#6	; check if port1=driving
   4286  f54a				  -	      bne	skipfirstdrivingcontrol
   4287  f54a				  -	      lda	SWCHA
   4288  f54a				  -	      and	#%00000011
   4289  f54a				  -	      asl
   4290  f54a				  -	      asl
   4291  f54a				  -drivingupdateloop
   4292  f54a				  -	      ora	controller0statesave,x
   4293  f54a				  -	      tay
   4294  f54a				  -	      lda	rotationalcompare,y
   4295  f54a				  -	      clc
   4296  f54a				  -	      adc	drivingposition0,x
   4297  f54a				  -	      sta	drivingposition0,x
   4298  f54a				  -	      tya
   4299  f54a				  -	      lsr
   4300  f54a				  -	      lsr
   4301  f54a				  -	      sta	controller0statesave,x
   4302  f54a				  -skipfirstdrivingcontrol
   4303  f54a				  -	      lda	port0control
   4304  f54a				  -	      cmp	#6	; check if port0=driving
   4305  f54a				  -	      bne	drivingcontrolsloopdone
   4306  f54a				  -	      lda	SWCHA
   4307  f54a				  -	      and	#%00110000
   4308  f54a				  -	      lsr
   4309  f54a				  -	      lsr
   4310  f54a				  -	      dex
   4311  f54a				  -	      bpl	drivingupdateloop
   4312  f54a				  -drivingcontrolsloopdone
   4313  f54a				  -	      rts
   4314  f54a					      endif		; DRIVINGSUPPORT
   4315  f54a
   4316  f54a				  -	      ifconst	KEYPADSUPPORT
   4317  f54a				  -			; ** select keypad rows 0 to 3 over 4 frames...
   4318  f54a				  -keypadrowselect
   4319  f54a				  -	      ldy	#0
   4320  f54a				  -	      lda	port0control
   4321  f54a				  -	      cmp	#7
   4322  f54a				  -	      bne	skipport0val
   4323  f54a				  -	      iny		; y=y+1
   4324  f54a				  -skipport0val
   4325  f54a				  -	      lda	port1control
   4326  f54a				  -	      cmp	#7
   4327  f54a				  -	      bne	skipport1val
   4328  f54a				  -	      iny
   4329  f54a				  -	      iny		; y=y+2
   4330  f54a				  -skipport1val
   4331  f54a				  -	      lda	keyrowdirectionmask,y
   4332  f54a				  -	      sta	CTLSWA
   4333  f54a				  -	      tya
   4334  f54a				  -	      asl
   4335  f54a				  -	      asl
   4336  f54a				  -	      sta	inttemp1
   4337  f54a				  -	      lda	framecounter
   4338  f54a				  -	      and	#3
   4339  f54a				  -	      ora	inttemp1
   4340  f54a				  -	      tax
   4341  f54a				  -	      lda	keyrowselectvalue,x
   4342  f54a				  -	      sta	SWCHA
   4343  f54a				  -	      rts
   4344  f54a				  -
   4345  f54a				  -keyrowdirectionmask
   4346  f54a				  -	      .byte	#%00000000	; 0 : port0=input  port1=input
   4347  f54a				  -	      .byte	#%11110000	; 1 : port0=output port1=input
   4348  f54a				  -	      .byte	#%00001111	; 2 : port0=input  port1=output
   4349  f54a				  -	      .byte	#%11111111	; 3 : port0=output port1=output
   4350  f54a				  -
   4351  f54a				  -keyrowselectvalue
   4352  f54a				  -	      .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   4353  f54a				  -	      .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   4354  f54a				  -	      .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   4355  f54a				  -	      .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   4356  f54a					      endif		;  KEYPADSUPPORT
   4357  f54a
   4358  f54a				  -	      ifconst	KEYPADSUPPORT
   4359  f54a				  -keypadcolumnread
   4360  f54a				  -	      lda	framecounter
   4361  f54a				  -	      and	#3
   4362  f54a				  -	      asl		; x2 because keypad variables are interleaved
   4363  f54a				  -	      tax
   4364  f54a				  -
   4365  f54a				  -	      lda	#0
   4366  f54a				  -	      sta	keypadmatrix0a,x
   4367  f54a				  -	      sta	keypadmatrix1a,x
   4368  f54a				  -
   4369  f54a				  -	      lda	INPT0
   4370  f54a				  -	      cmp	#$80
   4371  f54a				  -	      rol	keypadmatrix0a,x
   4372  f54a				  -	      lda	INPT1
   4373  f54a				  -	      cmp	#$80
   4374  f54a				  -	      rol	keypadmatrix0a,x
   4375  f54a				  -	      lda	INPT4
   4376  f54a				  -	      cmp	#$80
   4377  f54a				  -	      rol	keypadmatrix0a,x
   4378  f54a				  -	      lda	keypadmatrix0a,x
   4379  f54a				  -	      eor	#%00000111
   4380  f54a				  -	      sta	keypadmatrix0a,x
   4381  f54a				  -
   4382  f54a				  -	      rol	keypadmatrix1a,x
   4383  f54a				  -	      lda	INPT2
   4384  f54a				  -	      cmp	#$80
   4385  f54a				  -	      rol	keypadmatrix1a,x
   4386  f54a				  -	      lda	INPT3
   4387  f54a				  -	      cmp	#$80
   4388  f54a				  -	      rol	keypadmatrix1a,x
   4389  f54a				  -	      lda	INPT5
   4390  f54a				  -	      cmp	#$80
   4391  f54a				  -	      rol	keypadmatrix1a,x
   4392  f54a				  -	      lda	keypadmatrix1a,x
   4393  f54a				  -	      eor	#%00000111
   4394  f54a				  -	      sta	keypadmatrix1a,x
   4395  f54a				  -
   4396  f54a				  -	      rts
   4397  f54a					      endif		; KEYPADSUPPORT
   4398  f54a
   4399  f54a				   setportforinput
   4400  f54a		       a5 e4		      lda	CTLSWAs
   4401  f54c		       3d 55 f5 	      and	allpinsinputlut,x
   4402  f54f		       85 e4		      sta	CTLSWAs
   4403  f551		       8d 81 02 	      sta	CTLSWA
   4404  f554		       60		      rts
   4405  f555
   4406  f555				   allpinsinputlut
   4407  f555		       0f f0		      .byte.b	$0F, $F0
   4408  f557
   4409  f557				   setonebuttonmode
   4410  f557		       a9 14		      lda	#$14
   4411  f559		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   4412  f55c		       a5 e5		      lda	CTLSWBs
   4413  f55e		       1d 67 f5 	      ora	thisjoy2buttonbit,x
   4414  f561		       85 e5		      sta	CTLSWBs
   4415  f563		       8d 82 02 	      sta	SWCHB	; turn off the 2-button disable bits
   4416  f566		       60		      rts
   4417  f567
   4418  f567				   thisjoy2buttonbit
   4419  f567		       04 10		      .byte.b	$04, $10
   4420  f569
   4421  f569				   settwobuttonmode
   4422  f569		       a9 14		      lda	#$14
   4423  f56b		       8d 83 02 	      sta	CTLSWB	; set both 2-button disable bits to writable
   4424  f56e		       a5 e5		      lda	CTLSWBs
   4425  f570		       3d 79 f5 	      and	thisjoy2buttonmask,x
   4426  f573		       85 e5		      sta	CTLSWBs
   4427  f575		       8d 82 02 	      sta	SWCHB
   4428  f578		       60		      rts
   4429  f579
   4430  f579				   thisjoy2buttonmask
   4431  f579		       fb ef		      .byte.b	$fb, $ef
   4432  f57b
   4433  f57b							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4434  f57b
   4435  f57b				   START
   4436  f57b				   start
   4437  f57b
   4438  f57b							;******** more or less the Atari recommended startup procedure
   4439  f57b
   4440  f57b		       78		      sei
   4441  f57c		       d8		      cld
   4442  f57d
   4443  f57d					      ifnconst	NOTIALOCK
   4444  f57d		       a9 07		      lda	#$07
   4445  f57f				  -	      else
   4446  f57f				  -	      lda	#$06
   4447  f57f					      endif
   4448  f57f		       85 01		      sta	INPTCTRL	;lock 7800 into 7800 mode
   4449  f581		       a9 7f		      lda	#$7F
   4450  f583		       85 3c		      sta	CTRL	;disable DMA
   4451  f585		       a9 00		      lda	#$00
   4452  f587		       85 38		      sta	OFFSET
   4453  f589					      ifnconst	NOTIALOCK
   4454  f589		       85 01		      sta	INPTCTRL
   4455  f58b					      endif
   4456  f58b		       a2 ff		      ldx	#$FF
   4457  f58d		       9a		      txs
   4458  f58e
   4459  f58e							;************** Clear Memory
   4460  f58e
   4461  f58e		       a2 40		      ldx	#$40
   4462  f590		       a9 00		      lda	#$00
   4463  f592				   crloop1
   4464  f592		       95 00		      sta	$00,x	;Clear zero page
   4465  f594		       9d 00 01 	      sta	$100,x	;Clear page 1
   4466  f597		       e8		      inx
   4467  f598		       d0 f8		      bne	crloop1
   4468  f59a
   4469  f59a
   4470  f59a		       a0 00		      ldy	#$00	;Clear Ram
   4471  f59c		       a9 18		      lda	#$18	;Start at $1800
   4472  f59e		       85 81		      sta	$81
   4473  f5a0		       a9 00		      lda	#$00
   4474  f5a2		       85 80		      sta	$80
   4475  f5a4				   crloop3
   4476  f5a4		       a9 00		      lda	#$00
   4477  f5a6		       91 80		      sta	($80),y	;Store data
   4478  f5a8		       c8		      iny		;Next byte
   4479  f5a9		       d0 f9		      bne	crloop3	;Branch if not done page
   4480  f5ab		       e6 81		      inc	$81	;Next page
   4481  f5ad		       a5 81		      lda	$81
   4482  f5af		       c9 20		      cmp	#$20	;End at $1FFF
   4483  f5b1		       d0 f1		      bne	crloop3	;Branch if not
   4484  f5b3
   4485  f5b3		       a0 00		      ldy	#$00	;Clear Ram
   4486  f5b5		       a9 22		      lda	#$22	;Start at $2200
   4487  f5b7		       85 81		      sta	$81
   4488  f5b9		       a9 00		      lda	#$00
   4489  f5bb		       85 80		      sta	$80
   4490  f5bd				   crloop4
   4491  f5bd		       a9 00		      lda	#$00
   4492  f5bf		       91 80		      sta	($80),y	;Store data
   4493  f5c1		       c8		      iny		;Next byte
   4494  f5c2		       d0 f9		      bne	crloop4	;Branch if not done page
   4495  f5c4		       e6 81		      inc	$81	;Next page
   4496  f5c6		       a5 81		      lda	$81
   4497  f5c8		       c9 27		      cmp	#$27	;End at $27FF
   4498  f5ca		       d0 f1		      bne	crloop4	;Branch if not
   4499  f5cc
   4500  f5cc		       a2 00		      ldx	#$00
   4501  f5ce		       a9 00		      lda	#$00
   4502  f5d0				   crloop5		;Clear 2100-213F, 2000-203F
   4503  f5d0		       9d 00 20 	      sta	$2000,x
   4504  f5d3		       9d 00 21 	      sta	$2100,x
   4505  f5d6		       e8		      inx
   4506  f5d7		       e0 40		      cpx	#$40
   4507  f5d9		       d0 f5		      bne	crloop5
   4508  f5db
   4509  f5db		       85 80		      sta	$80
   4510  f5dd		       85 81		      sta	$81
   4511  f5df		       85 82		      sta	$82
   4512  f5e1		       85 83		      sta	$83
   4513  f5e3
   4514  f5e3							;seed random number with hopefully-random timer value
   4515  f5e3		       a9 01		      lda	#1
   4516  f5e5		       0d 84 02 	      ora	INTIM
   4517  f5e8		       85 40		      sta	rand
   4518  f5ea
   4519  f5ea							; detect the console type...
   4520  f5ea				   pndetectvblankstart
   4521  f5ea		       a5 28		      lda	MSTAT
   4522  f5ec		       10 fc		      bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   4523  f5ee				   pndetectvblankover
   4524  f5ee		       a5 28		      lda	MSTAT
   4525  f5f0		       30 fc		      bmi	pndetectvblankover	;  then wait for it to be over
   4526  f5f2		       a0 00		      ldy	#$00
   4527  f5f4		       a2 00		      ldx	#$00
   4528  f5f6				   pndetectvblankhappening
   4529  f5f6		       a5 28		      lda	MSTAT
   4530  f5f8		       30 07		      bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   4531  f5fa		       85 24		      sta	WSYNC
   4532  f5fc		       85 24		      sta	WSYNC
   4533  f5fe		       e8		      inx
   4534  f5ff		       d0 f5		      bne	pndetectvblankhappening
   4535  f601				   pndetectinvblank
   4536  f601		       e0 7d		      cpx	#125
   4537  f603		       90 02		      bcc	pndetecispal
   4538  f605		       a0 01		      ldy	#$01
   4539  f607				   pndetecispal
   4540  f607		       8c 09 21 	      sty	paldetected
   4541  f60a
   4542  f60a		       20 b0 f4 	      jsr	createallgamedlls
   4543  f60d
   4544  f60d		       a9 18		      lda	#>DLLMEM
   4545  f60f		       85 2c		      sta	DPPH
   4546  f611		       a9 00		      lda	#<DLLMEM
   4547  f613		       85 30		      sta	DPPL
   4548  f615
   4549  f615							; CTRL 76543210
   4550  f615							; 7 colorburst kill
   4551  f615							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   4552  f615							; 4 character width 1=2 byte chars, 0=1 byte chars
   4553  f615							; 3 border control 0=background color border, 1=black border
   4554  f615							; 2 kangaroo mode 0=transparancy, 1=kangaroo
   4555  f615							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   4556  f615
   4557  f615				  -	      ifconst	DOUBLEWIDE
   4558  f615				  -	      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   4559  f615					      else
   4560  f615		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   4561  f617					      endif
   4562  f617		       85 3c		      sta	CTRL
   4563  f619		       8d 07 21 	      sta	sCTRL
   4564  f61c
   4565  f61c		       20 a3 f4 	      jsr	vblankresync
   4566  f61f
   4567  f61f		       a9 04		      lda	#%00000100	; leave cartridge plugged in for any testing
   4568  f621		       8d b7 01 	      sta	XCTRL1s
   4569  f624
   4570  f624				  -	      ifconst	pokeysupport
   4571  f624				  -			; pokey support is compiled in, so try to detect it...
   4572  f624				  -	      jsr	detectpokeylocation
   4573  f624					      endif
   4574  f624
   4575  f624		       a9 01		      lda	#1	; default for port 0 and 1 is a regular joystick
   4576  f626		       8d e2 01 	      sta	port0control
   4577  f629		       8d e3 01 	      sta	port1control
   4578  f62c
   4579  f62c							;Setup port A to read mode
   4580  f62c							;lda #$00
   4581  f62c							;sta SWCHA
   4582  f62c							;sta CTLSWA
   4583  f62c
   4584  f62c				  -	      ifconst	HSSUPPORT
   4585  f62c				  -			; try to detect HSC
   4586  f62c				  -	      jsr	detecthsc
   4587  f62c				  -	      and	#1
   4588  f62c				  -	      sta	hsdevice
   4589  f62c				  -skipHSCdetect
   4590  f62c				  -			; try to detect AtariVox eeprom
   4591  f62c				  -	      jsr	detectatarivoxeeprom
   4592  f62c				  -	      and	#2
   4593  f62c				  -	      ora	hsdevice
   4594  f62c				  -	      cmp	#3
   4595  f62c				  -	      bne	storeAinhsdevice
   4596  f62c				  -			; For now, we tie break by giving HSC priority over AtariVox.
   4597  f62c				  -			; Later we should check each device's priority byte if set, instead, 
   4598  f62c				  -	      lda	#2
   4599  f62c				  -storeAinhsdevice
   4600  f62c				  -	      sta	hsdevice
   4601  f62c				  -	      lda	#$ff
   4602  f62c				  -	      sta	hsdifficulty
   4603  f62c				  -	      sta	hsgameslot
   4604  f62c				  -	      sta	hsnewscoreline
   4605  f62c					      endif
   4606  f62c
   4607  f62c				  -	      ifconst	AVOXVOICE
   4608  f62c				  -	      jsr	silenceavoxvoice
   4609  f62c					      endif
   4610  f62c
   4611  f62c				  -	      ifconst	SGRAM
   4612  f62c				  -			; check if we actually have SGRAM. If not, probe XM for it...
   4613  f62c				  -	      ldy	#$EA
   4614  f62c				  -	      sty	$4000
   4615  f62c				  -	      ldy	$4000
   4616  f62c				  -	      cpy	#$EA
   4617  f62c				  -	      beq	skipSGRAMcheck
   4618  f62c				  -	      lda	XCTRL1s
   4619  f62c				  -	      ora	#%01100100
   4620  f62c				  -	      sta	XCTRL1
   4621  f62c				  -	      sty	$4000
   4622  f62c				  -	      ldy	$4000
   4623  f62c				  -	      cpy	#$EA
   4624  f62c				  -	      bne	skipSGRAMcheck
   4625  f62c				  -			;if we're here, XM memory satisfied our RAM requirement
   4626  f62c				  -	      sta	XCTRL1s	; save it
   4627  f62c				  -	      lda	#$10
   4628  f62c				  -	      sta	XCTRL2
   4629  f62c				  -	      sta	XCTRL3
   4630  f62c				  -skipSGRAMcheck
   4631  f62c					      endif
   4632  f62c
   4633  f62c				  -	      ifconst	TURNEDOFF
   4634  f62c				  -	      ldx	#1
   4635  f62c				  -	      ldy	#3
   4636  f62c				  -joystickdetectloop
   4637  f62c				  -	      jsr	setonebuttonmode
   4638  f62c				  -			; ensure we're in one-button mode and check for a genesis controller
   4639  f62c				  -	      lda	INPT0,y
   4640  f62c				  -	      and	#$80
   4641  f62c				  -	      sta	genesisdetected0,x
   4642  f62c				  -	      bne	skipsetgenesistwobutton
   4643  f62c				  -skipsetgenesis
   4644  f62c				  -	      jsr	settwobuttonmode
   4645  f62c				  -skipsetgenesistwobutton
   4646  f62c				  -	      dey
   4647  f62c				  -	      dey
   4648  f62c				  -	      dex
   4649  f62c				  -	      bpl	joystickdetectloop
   4650  f62c					      endif
   4651  f62c
   4652  f62c		       a2 01		      ldx	#1
   4653  f62e		       20 69 f5 	      jsr	settwobuttonmode
   4654  f631		       a2 00		      ldx	#0
   4655  f633		       20 69 f5 	      jsr	settwobuttonmode
   4656  f636
   4657  f636				  -	      ifconst	bankswitchmode
   4658  f636				  -			; we need to switch to the first bank before we jump there!
   4659  f636				  -	      ifconst	MCPDEVCART
   4660  f636				  -	      lda	#$18	; xxx11nnn - switch to bank 0
   4661  f636				  -	      sta	$3000
   4662  f636				  -	      else
   4663  f636				  -	      lda	#0
   4664  f636				  -	      sta	$8000
   4665  f636				  -	      endif
   4666  f636					      endif
   4667  f636
   4668  f636		       4c 13 40 	      jmp	game
   4669  f639
   4670  f639
   4671  f639							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4672  f639
   4673  f639							;************** Setup DLL entries
   4674  f639
   4675  f639							; setup some working definitions, to avoid ifnconst mess elsewhere...
   4676  f639					      ifnconst	SCREENHEIGHT
   4677  f639		       00 c0	   WSCREENHEIGHT =	192
   4678  f639				  -	      else
   4679  f639				  -WSCREENHEIGHT =	SCREENHEIGHT
   4680  f639					      endif
   4681  f639
   4682  f639				  -	      ifnconst	ZONEHEIGHT
   4683  f639				  -WZONEHEIGHT =	16
   4684  f639					      else
   4685  f639		       00 10	   WZONEHEIGHT =	ZONEHEIGHT
   4686  f639					      endif
   4687  f639
   4688  f639					      ifnconst	ZONECOUNT
   4689  f639		       00 0c	   WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   4690  f639				  -	      else
   4691  f639				  -WZONECOUNT =	ZONECOUNT
   4692  f639					      endif
   4693  f639
   4694  f639							; top of the frame, non-visible lines. this is based on NTSC,
   4695  f639							; but we add in extra NV lines at the end of the display to ensure
   4696  f639							; our PAL friends can play the game without it crashing.
   4697  f639		       00 19	   NVLINES    =	((243-WSCREENHEIGHT)/2)
   4698  f639
   4699  f639					      ifnconst	DLMEMSTART
   4700  f639					      ifnconst	DOUBLEBUFFER
   4701  f639		       18 80	   WDLMEMSTART =	$1880
   4702  f639				  -	      else
   4703  f639				  -WDLMEMSTART =	$18E0
   4704  f639					      endif		; DOUBLEBUFFER
   4705  f639				  -	      else
   4706  f639				  -WDLMEMSTART =	DLMEMSTART
   4707  f639					      endif
   4708  f639
   4709  f639					      ifnconst	DLMEMEND
   4710  f639				  -	      ifconst	EXTRADLMEMORY
   4711  f639				  -WDLMEMEND  =	$23FF
   4712  f639					      else
   4713  f639		       1f ff	   WDLMEMEND  =	$1FFF
   4714  f639					      endif
   4715  f639				  -	      else
   4716  f639				  -WDLMEMEND  =	DLMEMEND
   4717  f639					      endif
   4718  f639
   4719  f639
   4720  f639		       07 80	   WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   4721  f639
   4722  f639					      ifnconst	DOUBLEBUFFER
   4723  f639		       00 9b	   DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   4724  f639				  -	      else
   4725  f639				  -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   4726  f639					      endif
   4727  f639
   4728  f639		       00 9d	   TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   4729  f639				  -	      if	TDOUBLEBUFFEROFFSET > 255
   4730  f639				  -DOUBLEBUFFEROFFSET =	255
   4731  f639					      else
   4732  f639		       00 9d	   DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   4733  f639					      endif
   4734  f639
   4735  f639				  -	      ifconst	EXTRADLMEMORY
   4736  f639				  -SECONDDLHALFSTART SET	$2300
   4737  f639					      endif
   4738  f639
   4739  f639				   DLPOINTH
   4740  f639				   DLINDEX    SET	0
   4741  f639					      REPEAT	WZONECOUNT
   4742  f639				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f639				  -	      ifconst	EXTRADLMEMORY
   4744  f639				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f639				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f639				  -	      else
   4747  f639				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f639				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f639				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f639				  -	      endif
   4751  f639				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f639					      endif		; EXTRADLMEMORY
   4753  f639							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f639		       18		      .byte.b	>TMPMEMADDRESS
   4755  f639				   DLINDEX    SET	DLINDEX + 1
   4741  f639					      REPEND
   4742  f639				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63a				  -	      ifconst	EXTRADLMEMORY
   4744  f63a				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63a				  -	      else
   4747  f63a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63a				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63a				  -	      endif
   4751  f63a				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63a					      endif		; EXTRADLMEMORY
   4753  f63a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63a		       19		      .byte.b	>TMPMEMADDRESS
   4755  f63a				   DLINDEX    SET	DLINDEX + 1
   4741  f63a					      REPEND
   4742  f63a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63b				  -	      ifconst	EXTRADLMEMORY
   4744  f63b				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63b				  -	      else
   4747  f63b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63b				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63b				  -	      endif
   4751  f63b				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63b					      endif		; EXTRADLMEMORY
   4753  f63b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63b		       19		      .byte.b	>TMPMEMADDRESS
   4755  f63b				   DLINDEX    SET	DLINDEX + 1
   4741  f63b					      REPEND
   4742  f63b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63c				  -	      ifconst	EXTRADLMEMORY
   4744  f63c				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63c				  -	      else
   4747  f63c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63c				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63c				  -	      endif
   4751  f63c				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63c					      endif		; EXTRADLMEMORY
   4753  f63c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63c		       1a		      .byte.b	>TMPMEMADDRESS
   4755  f63c				   DLINDEX    SET	DLINDEX + 1
   4741  f63c					      REPEND
   4742  f63c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63d				  -	      ifconst	EXTRADLMEMORY
   4744  f63d				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63d				  -	      else
   4747  f63d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63d				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63d				  -	      endif
   4751  f63d				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63d					      endif		; EXTRADLMEMORY
   4753  f63d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63d		       1b		      .byte.b	>TMPMEMADDRESS
   4755  f63d				   DLINDEX    SET	DLINDEX + 1
   4741  f63d					      REPEND
   4742  f63d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63e				  -	      ifconst	EXTRADLMEMORY
   4744  f63e				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63e				  -	      else
   4747  f63e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63e				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63e				  -	      endif
   4751  f63e				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63e					      endif		; EXTRADLMEMORY
   4753  f63e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63e		       1b		      .byte.b	>TMPMEMADDRESS
   4755  f63e				   DLINDEX    SET	DLINDEX + 1
   4741  f63e					      REPEND
   4742  f63e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f63f				  -	      ifconst	EXTRADLMEMORY
   4744  f63f				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f63f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f63f				  -	      else
   4747  f63f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f63f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f63f				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f63f				  -	      endif
   4751  f63f				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f63f					      endif		; EXTRADLMEMORY
   4753  f63f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f63f		       1c		      .byte.b	>TMPMEMADDRESS
   4755  f63f				   DLINDEX    SET	DLINDEX + 1
   4741  f63f					      REPEND
   4742  f63f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f640				  -	      ifconst	EXTRADLMEMORY
   4744  f640				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f640				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f640				  -	      else
   4747  f640				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f640				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f640				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f640				  -	      endif
   4751  f640				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f640					      endif		; EXTRADLMEMORY
   4753  f640							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f640		       1c		      .byte.b	>TMPMEMADDRESS
   4755  f640				   DLINDEX    SET	DLINDEX + 1
   4741  f640					      REPEND
   4742  f640				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f641				  -	      ifconst	EXTRADLMEMORY
   4744  f641				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f641				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f641				  -	      else
   4747  f641				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f641				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f641				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f641				  -	      endif
   4751  f641				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f641					      endif		; EXTRADLMEMORY
   4753  f641							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f641		       1d		      .byte.b	>TMPMEMADDRESS
   4755  f641				   DLINDEX    SET	DLINDEX + 1
   4741  f641					      REPEND
   4742  f641				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f642				  -	      ifconst	EXTRADLMEMORY
   4744  f642				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f642				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f642				  -	      else
   4747  f642				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f642				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f642				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f642				  -	      endif
   4751  f642				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f642					      endif		; EXTRADLMEMORY
   4753  f642							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f642		       1e		      .byte.b	>TMPMEMADDRESS
   4755  f642				   DLINDEX    SET	DLINDEX + 1
   4741  f642					      REPEND
   4742  f642				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f643				  -	      ifconst	EXTRADLMEMORY
   4744  f643				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f643				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f643				  -	      else
   4747  f643				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f643				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f643				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f643				  -	      endif
   4751  f643				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f643					      endif		; EXTRADLMEMORY
   4753  f643							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f643		       1e		      .byte.b	>TMPMEMADDRESS
   4755  f643				   DLINDEX    SET	DLINDEX + 1
   4741  f643					      REPEND
   4742  f643				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4743  f644				  -	      ifconst	EXTRADLMEMORY
   4744  f644				  -	      if	TMPMEMADDRESS > $1FFF
   4745  f644				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4746  f644				  -	      else
   4747  f644				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4748  f644				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4749  f644				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   4750  f644				  -	      endif
   4751  f644				  -	      endif		; TMPMEMADDRESS > $1FFF
   4752  f644					      endif		; EXTRADLMEMORY
   4753  f644							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   4754  f644		       1f		      .byte.b	>TMPMEMADDRESS
   4755  f644				   DLINDEX    SET	DLINDEX + 1
   4756  f645					      REPEND
   4757  f645
   4758  f645				  -	      ifconst	EXTRADLMEMORY
   4759  f645				  -	      echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   4760  f645					      endif
   4761  f645
   4762  f645
   4763  f645				   DLPOINTL
   4764  f645				   DLINDEX    SET	0
   4765  f645					      REPEAT	WZONECOUNT
   4766  f645				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f645				  -	      ifconst	EXTRADLMEMORY
   4768  f645				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f645				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f645				  -	      else
   4771  f645				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f645				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f645				  -	      endif
   4774  f645				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f645					      endif		; EXTRADLMEMORY
   4776  f645		       80		      .byte.b	<TMPMEMADDRESS
   4777  f645				   DLINDEX    SET	DLINDEX + 1
   4765  f645					      REPEND
   4766  f645				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f646				  -	      ifconst	EXTRADLMEMORY
   4768  f646				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f646				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f646				  -	      else
   4771  f646				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f646				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f646				  -	      endif
   4774  f646				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f646					      endif		; EXTRADLMEMORY
   4776  f646		       20		      .byte.b	<TMPMEMADDRESS
   4777  f646				   DLINDEX    SET	DLINDEX + 1
   4765  f646					      REPEND
   4766  f646				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f647				  -	      ifconst	EXTRADLMEMORY
   4768  f647				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f647				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f647				  -	      else
   4771  f647				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f647				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f647				  -	      endif
   4774  f647				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f647					      endif		; EXTRADLMEMORY
   4776  f647		       c0		      .byte.b	<TMPMEMADDRESS
   4777  f647				   DLINDEX    SET	DLINDEX + 1
   4765  f647					      REPEND
   4766  f647				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f648				  -	      ifconst	EXTRADLMEMORY
   4768  f648				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f648				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f648				  -	      else
   4771  f648				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f648				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f648				  -	      endif
   4774  f648				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f648					      endif		; EXTRADLMEMORY
   4776  f648		       60		      .byte.b	<TMPMEMADDRESS
   4777  f648				   DLINDEX    SET	DLINDEX + 1
   4765  f648					      REPEND
   4766  f648				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f649				  -	      ifconst	EXTRADLMEMORY
   4768  f649				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f649				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f649				  -	      else
   4771  f649				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f649				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f649				  -	      endif
   4774  f649				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f649					      endif		; EXTRADLMEMORY
   4776  f649		       00		      .byte.b	<TMPMEMADDRESS
   4777  f649				   DLINDEX    SET	DLINDEX + 1
   4765  f649					      REPEND
   4766  f649				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64a				  -	      ifconst	EXTRADLMEMORY
   4768  f64a				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64a				  -	      else
   4771  f64a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64a				  -	      endif
   4774  f64a				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64a					      endif		; EXTRADLMEMORY
   4776  f64a		       a0		      .byte.b	<TMPMEMADDRESS
   4777  f64a				   DLINDEX    SET	DLINDEX + 1
   4765  f64a					      REPEND
   4766  f64a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64b				  -	      ifconst	EXTRADLMEMORY
   4768  f64b				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64b				  -	      else
   4771  f64b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64b				  -	      endif
   4774  f64b				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64b					      endif		; EXTRADLMEMORY
   4776  f64b		       40		      .byte.b	<TMPMEMADDRESS
   4777  f64b				   DLINDEX    SET	DLINDEX + 1
   4765  f64b					      REPEND
   4766  f64b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64c				  -	      ifconst	EXTRADLMEMORY
   4768  f64c				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64c				  -	      else
   4771  f64c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64c				  -	      endif
   4774  f64c				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64c					      endif		; EXTRADLMEMORY
   4776  f64c		       e0		      .byte.b	<TMPMEMADDRESS
   4777  f64c				   DLINDEX    SET	DLINDEX + 1
   4765  f64c					      REPEND
   4766  f64c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64d				  -	      ifconst	EXTRADLMEMORY
   4768  f64d				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64d				  -	      else
   4771  f64d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64d				  -	      endif
   4774  f64d				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64d					      endif		; EXTRADLMEMORY
   4776  f64d		       80		      .byte.b	<TMPMEMADDRESS
   4777  f64d				   DLINDEX    SET	DLINDEX + 1
   4765  f64d					      REPEND
   4766  f64d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64e				  -	      ifconst	EXTRADLMEMORY
   4768  f64e				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64e				  -	      else
   4771  f64e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64e				  -	      endif
   4774  f64e				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64e					      endif		; EXTRADLMEMORY
   4776  f64e		       20		      .byte.b	<TMPMEMADDRESS
   4777  f64e				   DLINDEX    SET	DLINDEX + 1
   4765  f64e					      REPEND
   4766  f64e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f64f				  -	      ifconst	EXTRADLMEMORY
   4768  f64f				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f64f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f64f				  -	      else
   4771  f64f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f64f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f64f				  -	      endif
   4774  f64f				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f64f					      endif		; EXTRADLMEMORY
   4776  f64f		       c0		      .byte.b	<TMPMEMADDRESS
   4777  f64f				   DLINDEX    SET	DLINDEX + 1
   4765  f64f					      REPEND
   4766  f64f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4767  f650				  -	      ifconst	EXTRADLMEMORY
   4768  f650				  -	      if	TMPMEMADDRESS > $1FFF
   4769  f650				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4770  f650				  -	      else
   4771  f650				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4772  f650				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4773  f650				  -	      endif
   4774  f650				  -	      endif		; TMPMEMADDRESS > $1FFF
   4775  f650					      endif		; EXTRADLMEMORY
   4776  f650		       60		      .byte.b	<TMPMEMADDRESS
   4777  f650				   DLINDEX    SET	DLINDEX + 1
   4778  f651					      REPEND
   4779  f651
   4780  f651
   4781  f651				   DLINDEX    SET	0
   4782  f651					      REPEAT	WZONECOUNT
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651					      if	DLINDEX = 0
   4794  f651		       18 80	   ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651					      if	DLINDEX = 1
   4797  f651		       19 20	   ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651					      if	DLINDEX = 2
   4800  f651		       19 c0	   ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651					      if	DLINDEX = 3
   4803  f651		       1a 60	   ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651					      if	DLINDEX = 4
   4806  f651		       1b 00	   ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651					      if	DLINDEX = 5
   4809  f651		       1b a0	   ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651					      if	DLINDEX = 6
   4812  f651		       1c 40	   ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651					      if	DLINDEX = 7
   4815  f651		       1c e0	   ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651					      if	DLINDEX = 8
   4818  f651		       1d 80	   ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651					      if	DLINDEX = 9
   4821  f651		       1e 20	   ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651					      if	DLINDEX = 10
   4824  f651		       1e c0	   ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651				  -	      if	DLINDEX = 11
   4827  f651				  -ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4782  f651					      REPEND
   4783  f651				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   4784  f651				  -	      ifconst	EXTRADLMEMORY
   4785  f651				  -	      if	TMPMEMADDRESS > $1FFF
   4786  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4787  f651				  -	      else
   4788  f651				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   4789  f651				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   4790  f651				  -	      endif
   4791  f651				  -	      endif		; TMPMEMADDRESS > $1FFF
   4792  f651					      endif		; EXTRADLMEMORY
   4793  f651				  -	      if	DLINDEX = 0
   4794  f651				  -ZONE0ADDRESS =	TMPMEMADDRESS
   4795  f651					      endif
   4796  f651				  -	      if	DLINDEX = 1
   4797  f651				  -ZONE1ADDRESS =	TMPMEMADDRESS
   4798  f651					      endif
   4799  f651				  -	      if	DLINDEX = 2
   4800  f651				  -ZONE2ADDRESS =	TMPMEMADDRESS
   4801  f651					      endif
   4802  f651				  -	      if	DLINDEX = 3
   4803  f651				  -ZONE3ADDRESS =	TMPMEMADDRESS
   4804  f651					      endif
   4805  f651				  -	      if	DLINDEX = 4
   4806  f651				  -ZONE4ADDRESS =	TMPMEMADDRESS
   4807  f651					      endif
   4808  f651				  -	      if	DLINDEX = 5
   4809  f651				  -ZONE5ADDRESS =	TMPMEMADDRESS
   4810  f651					      endif
   4811  f651				  -	      if	DLINDEX = 6
   4812  f651				  -ZONE6ADDRESS =	TMPMEMADDRESS
   4813  f651					      endif
   4814  f651				  -	      if	DLINDEX = 7
   4815  f651				  -ZONE7ADDRESS =	TMPMEMADDRESS
   4816  f651					      endif
   4817  f651				  -	      if	DLINDEX = 8
   4818  f651				  -ZONE8ADDRESS =	TMPMEMADDRESS
   4819  f651					      endif
   4820  f651				  -	      if	DLINDEX = 9
   4821  f651				  -ZONE9ADDRESS =	TMPMEMADDRESS
   4822  f651					      endif
   4823  f651				  -	      if	DLINDEX = 10
   4824  f651				  -ZONE10ADDRESS =	TMPMEMADDRESS
   4825  f651					      endif
   4826  f651					      if	DLINDEX = 11
   4827  f651		       1f 60	   ZONE11ADDRESS =	TMPMEMADDRESS
   4828  f651					      endif
   4829  f651				  -	      if	DLINDEX = 12
   4830  f651				  -ZONE12ADDRESS =	TMPMEMADDRESS
   4831  f651					      endif
   4832  f651				  -	      if	DLINDEX = 13
   4833  f651				  -ZONE13ADDRESS =	TMPMEMADDRESS
   4834  f651					      endif
   4835  f651				  -	      if	DLINDEX = 14
   4836  f651				  -ZONE14ADDRESS =	TMPMEMADDRESS
   4837  f651					      endif
   4838  f651				  -	      if	DLINDEX = 15
   4839  f651				  -ZONE15ADDRESS =	TMPMEMADDRESS
   4840  f651					      endif
   4841  f651				  -	      if	DLINDEX = 16
   4842  f651				  -ZONE16ADDRESS =	TMPMEMADDRESS
   4843  f651					      endif
   4844  f651				  -	      if	DLINDEX = 17
   4845  f651				  -ZONE17ADDRESS =	TMPMEMADDRESS
   4846  f651					      endif
   4847  f651				  -	      if	DLINDEX = 18
   4848  f651				  -ZONE18ADDRESS =	TMPMEMADDRESS
   4849  f651					      endif
   4850  f651				  -	      if	DLINDEX = 19
   4851  f651				  -ZONE19ADDRESS =	TMPMEMADDRESS
   4852  f651					      endif
   4853  f651				  -	      if	DLINDEX = 20
   4854  f651				  -ZONE20ADDRESS =	TMPMEMADDRESS
   4855  f651					      endif
   4856  f651				  -	      if	DLINDEX = 21
   4857  f651				  -ZONE21ADDRESS =	TMPMEMADDRESS
   4858  f651					      endif
   4859  f651				  -	      if	DLINDEX = 22
   4860  f651				  -ZONE22ADDRESS =	TMPMEMADDRESS
   4861  f651					      endif
   4862  f651				  -	      if	DLINDEX = 23
   4863  f651				  -ZONE23ADDRESS =	TMPMEMADDRESS
   4864  f651					      endif
   4865  f651				  -	      if	DLINDEX = 24
   4866  f651				  -ZONE24ADDRESS =	TMPMEMADDRESS
   4867  f651					      endif
   4868  f651				  -	      if	DLINDEX = 25
   4869  f651				  -ZONE25ADDRESS =	TMPMEMADDRESS
   4870  f651					      endif
   4871  f651				  -	      if	DLINDEX = 26
   4872  f651				  -ZONE26ADDRESS =	TMPMEMADDRESS
   4873  f651					      endif
   4874  f651				  -	      if	DLINDEX = 27
   4875  f651				  -ZONE27ADDRESS =	TMPMEMADDRESS
   4876  f651					      endif
   4877  f651				   DLINDEX    SET	DLINDEX + 1
   4878  f651					      REPEND
   4879  f651
   4880  f651
     $1880 to $1fff used as zone memory, allowing 31 display objects per zone.
   4881  f651					      echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   4882  f651
   4883  f651				   DLHEIGHT
   4884  f651					      REPEAT	WZONECOUNT
   4885  f651		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f651					      REPEND
   4885  f652		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f652					      REPEND
   4885  f653		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f653					      REPEND
   4885  f654		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f654					      REPEND
   4885  f655		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f655					      REPEND
   4885  f656		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f656					      REPEND
   4885  f657		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f657					      REPEND
   4885  f658		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f658					      REPEND
   4885  f659		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f659					      REPEND
   4885  f65a		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f65a					      REPEND
   4885  f65b		       0f		      .byte.b	(WZONEHEIGHT-1)
   4884  f65b					      REPEND
   4885  f65c		       0f		      .byte.b	(WZONEHEIGHT-1)
   4886  f65d					      REPEND
   4887  f65d
   4888  f65d							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4889  f65d
   4890  f65d							; a simple guard, than ensures the 7800basic code hasn't
   4891  f65d							; spilled into the encryption area...
     2337 bytes left in the 7800basic reserved area.
   4892  f65d					      echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   4893  f65d				  -	      if	(*>$FF7D)
   4894  f65d				  -	      ERR		; abort the assembly
   4895  f65d					      endif
   4896  f65d							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4897  f65d
   4898  f65d				  -	      ifconst	DEV
   4899  f65d				  -	      ifnconst	ZONEHEIGHT
   4900  f65d				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4901  f65d				  -	      else
   4902  f65d				  -	      if	ZONEHEIGHT = 8
   4903  f65d				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4904  f65d				  -	      else
   4905  f65d				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   4906  f65d				  -	      endif
   4907  f65d				  -	      endif
   4908  f65d					      endif
   4909  f65d
   4910  f65d							; FF7E/FF7F contains the 7800basic crc checksum word
   4911  f65d
   4912  f65d							; FF80 - FFF7 contains the 7800 encryption key 
   4913  f65d
   4914  f65d					      ifnconst	bankswitchmode
   4915  fff8					      ORG	$FFF8
   4916  fff8				  -	      else
   4917  fff8				  -	      ifconst	ROM128K
   4918  fff8				  -	      ORG	$27FF8
   4919  fff8				  -	      RORG	$FFF8
   4920  fff8				  -	      endif
   4921  fff8				  -	      ifconst	ROM144K
   4922  fff8				  -	      ORG	$27FF8
   4923  fff8				  -	      RORG	$FFF8
   4924  fff8				  -	      endif
   4925  fff8				  -	      ifconst	ROM256K
   4926  fff8				  -	      ORG	$47FF8
   4927  fff8				  -	      RORG	$FFF8
   4928  fff8				  -	      endif
   4929  fff8				  -	      ifconst	ROM272K
   4930  fff8				  -	      ORG	$47FF8
   4931  fff8				  -	      RORG	$FFF8
   4932  fff8				  -	      endif
   4933  fff8				  -	      ifconst	ROM512K
   4934  fff8				  -	      ORG	$87FF8
   4935  fff8				  -	      RORG	$FFF8
   4936  fff8				  -	      endif
   4937  fff8				  -	      ifconst	ROM528K
   4938  fff8				  -	      ORG	$87FF8
   4939  fff8				  -	      RORG	$FFF8
   4940  fff8				  -	      endif
   4941  fff8					      endif
   4942  fff8
   4943  fff8
   4944  fff8		       ff		      .byte.b	$FF	; region verification. $FF=all regions
   4945  fff9		       f7		      .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   4946  fffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   4947  fffa
   4948  fffa							;Vectors
   4949  fffa		       00 f0		      .word.w	NMI
   4950  fffc		       7b f5		      .word.w	START
   4951  fffe		       5d f0		      .word.w	IRQ
   4952  10000
