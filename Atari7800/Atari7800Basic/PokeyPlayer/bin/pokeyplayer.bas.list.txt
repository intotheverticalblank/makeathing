------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????						;-------------------------------------------------------
     45  28000 ????						; SET_POINTER
     46  28000 ????						; Original author: Manuel Rotschkar
     47  28000 ????						;
     48  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     49  28000 ????						;
     50  28000 ????						; Usage: SET_POINTER pointer, address
     51  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     52  28000 ????						;
     53  28000 ????						; Note: Alters the accumulator, NZ flags
     54  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     55  28000 ????						; IN 2: absolute address
     56  28000 ????
     57  28000 ????				       MAC	set_pointer
     58  28000 ????			    .POINTER   SET	{1}
     59  28000 ????			    .ADDRESS   SET	{2}
     60  28000 ????
     61  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
     62  28000 ????				       STA	.POINTER	; Store in pointer
     63  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
     64  28000 ????				       STA	.POINTER+1	; Store in pointer+1
     65  28000 ????
     66  28000 ????				       ENDM
     67  28000 ????
     68  28000 ????						; EOF
     69  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
     70  28000 ????
     71  28000 ????						; 7800MACRO.H
     72  28000 ????
     73  28000 ????						;-------------------------------------------------------
     74  28000 ????						; BOXCOLLISIONCHECK
     75  28000 ????						; author: Mike Saarna
     76  28000 ????						;
     77  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
     78  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
     79  28000 ????						; 
     80  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
     81  28000 ????						;
     82  28000 ????
     83  28000 ????				       MAC	boxcollisioncheck
     84  28000 ????			    .boxx1     SET	{1}
     85  28000 ????			    .boxy1     SET	{2}
     86  28000 ????			    .boxw1     SET	{3}
     87  28000 ????			    .boxh1     SET	{4}
     88  28000 ????			    .boxx2     SET	{5}
     89  28000 ????			    .boxy2     SET	{6}
     90  28000 ????			    .boxw2     SET	{7}
     91  28000 ????			    .boxh2     SET	{8}
     92  28000 ????
     93  28000 ????			    .DoXCollisionCheck
     94  28000 ????				       lda	.boxx1	;3
     95  28000 ????				       cmp	.boxx2	;2
     96  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
     97  28000 ????			    .X2isbiggerthanX1
     98  28000 ????				       adc	#.boxw1	;2
     99  28000 ????				       cmp	.boxx2	;3
    100  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    101  28000 ????				       bcc	.noboxcollision	;3
    102  28000 ????			    .X1isbiggerthanX2
    103  28000 ????				       clc		;2
    104  28000 ????				       sbc	#.boxw2	;2
    105  28000 ????				       cmp	.boxx2	;3
    106  28000 ????				       bcs	.noboxcollision	;3/2
    107  28000 ????			    .DoYCollisionCheck
    108  28000 ????				       lda	.boxy1	;3
    109  28000 ????				       cmp	.boxy2	;3
    110  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    111  28000 ????			    .Y2isbiggerthanY1
    112  28000 ????				       adc	#.boxh1	;2
    113  28000 ????				       cmp	.boxy2	;3
    114  28000 ????				       jmp	.checkdone	;6 
    115  28000 ????			    .Y1isbiggerthanY2
    116  28000 ????				       clc		;2
    117  28000 ????				       sbc	#.boxh2	;2
    118  28000 ????				       cmp	.boxy2	;3
    119  28000 ????				       bcs	.noboxcollision	;3/2
    120  28000 ????			    .boxcollision
    121  28000 ????				       sec		;2
    122  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    123  28000 ????			    .noboxcollision
    124  28000 ????				       clc		;2
    125  28000 ????			    .checkdone
    126  28000 ????
    127  28000 ????				       ENDM
    128  28000 ????
    129  28000 ????				       MAC	median3
    130  28000 ????
    131  28000 ????						; A median filter (for smoothing paddle jitter)
    132  28000 ????						;   this macro takes the current paddle value, compares it to historic
    133  28000 ????						;   values, and replaces the current paddle value with the median.
    134  28000 ????						; 
    135  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    136  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    137  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    138  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    139  28000 ????						;	  the previous values, and update with the median value.
    140  28000 ????						;
    141  28000 ????						; returns: CURRENT (modified to contain median value)
    142  28000 ????						;
    143  28000 ????						; author: Mike Saarna (aka RevEng)
    144  28000 ????
    145  28000 ????			    .MedianBytes SET	{1}
    146  28000 ????			    .NewValue  SET	{2}
    147  28000 ????
    148  28000 ????				       lda	#0
    149  28000 ????				       ldy	.NewValue
    150  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    151  28000 ????
    152  28000 ????						; build an index from relative size comparisons between our 3 values.
    153  28000 ????				       cpy	.MedianBytes
    154  28000 ????				       rol
    155  28000 ????				       cpy	.MedianBytes+1
    156  28000 ????				       rol
    157  28000 ????				       ldy	.MedianBytes
    158  28000 ????				       cpy	.MedianBytes+1
    159  28000 ????				       rol
    160  28000 ????				       tay
    161  28000 ????
    162  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    163  28000 ????				       lda	.MedianBytes,x
    164  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    165  28000 ????
    166  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    167  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    168  28000 ????				       lda	.MedianBytes+1
    169  28000 ????				       sta	.MedianBytes
    170  28000 ????				       lda	.MedianBytes+2
    171  28000 ????				       sta	.MedianBytes+1
    172  28000 ????				       ifnconst	MedianOrderLUT
    173  28000 ????				       jmp	MedianOrderLUTend
    174  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    175  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    176  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    177  28000 ????				       .byte	2	; 2   impossible 
    178  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    179  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    180  28000 ????				       .byte	2	; 5   impossible 
    181  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    182  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    183  28000 ????			    MedianOrderLUTend
    184  28000 ????				       endif
    185  28000 ????				       ENDM
    186  28000 ????
    187  28000 ????				       MAC	plotsprite
    188  28000 ????
    189  28000 ????						; A macro version of the plotsprite command. 
    190  28000 ????						; This trades off rom space for speed.
    191  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    192  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    193  28000 ????
    194  28000 ????			    .GFXLabel  SET	{1}
    195  28000 ????			    .Palette   SET	{2}	; constant
    196  28000 ????			    .SpriteX   SET	{3}	; variable
    197  28000 ????			    .SpriteY   SET	{4}	; variable
    198  28000 ????			    .ByteOffset SET	{5}	; variable 
    199  28000 ????
    200  28000 ????				       lda	.SpriteY
    201  28000 ????				       lsr
    202  28000 ????				       lsr
    203  28000 ????				       asr	#%11111110	; ensure carry is clear
    204  28000 ????				       if	WZONEHEIGHT = 16
    205  28000 ????				       asr	#%11111110	; ensure carry is clear
    206  28000 ????				       endif
    207  28000 ????
    208  28000 ????				       tax
    209  28000 ????
    210  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    211  28000 ????				       sta	dlpnt
    212  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    213  28000 ????				       sta	dlpnt+1
    214  28000 ????
    215  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    216  28000 ????
    217  28000 ????				       lda	.ByteOffset
    218  28000 ????				       if	{1}_width = 2
    219  28000 ????				       asl
    220  28000 ????				       endif
    221  28000 ????				       if	{1}_width = 3
    222  28000 ????				       asl
    223  28000 ????				       adc	.ByteOffset
    224  28000 ????				       endif
    225  28000 ????				       if	{1}_width = 4
    226  28000 ????				       asl
    227  28000 ????				       asl
    228  28000 ????				       endif
    229  28000 ????				       if	{1}_width = 5
    230  28000 ????				       asl
    231  28000 ????				       asl
    232  28000 ????				       adc	.ByteOffset
    233  28000 ????				       endif
    234  28000 ????				       if	{1}_width = 6
    235  28000 ????				       asl
    236  28000 ????				       adc	.ByteOffset
    237  28000 ????				       asl
    238  28000 ????				       endif
    239  28000 ????				       if	{1}_width = 7
    240  28000 ????				       asl
    241  28000 ????				       adc	.ByteOffset
    242  28000 ????				       asl
    243  28000 ????				       adc	.ByteOffset
    244  28000 ????				       endif
    245  28000 ????				       if	{1}_width = 8
    246  28000 ????				       asl
    247  28000 ????				       asl
    248  28000 ????				       asl
    249  28000 ????				       endif
    250  28000 ????				       if	{1}_width = 9
    251  28000 ????				       asl
    252  28000 ????				       asl
    253  28000 ????				       asl
    254  28000 ????				       adc	.ByteOffset
    255  28000 ????				       endif
    256  28000 ????				       if	{1}_width = 10
    257  28000 ????				       asl
    258  28000 ????				       asl
    259  28000 ????				       adc	.ByteOffset
    260  28000 ????				       asl
    261  28000 ????				       endif
    262  28000 ????				       if	{1}_width = 11
    263  28000 ????				       asl
    264  28000 ????				       asl
    265  28000 ????				       adc	.ByteOffset
    266  28000 ????				       asl
    267  28000 ????				       adc	.ByteOffset
    268  28000 ????				       endif
    269  28000 ????				       if	{1}_width = 12
    270  28000 ????				       asl
    271  28000 ????				       adc	.ByteOffset
    272  28000 ????				       asl
    273  28000 ????				       asl
    274  28000 ????				       endif
    275  28000 ????				       if	{1}_width = 13
    276  28000 ????				       asl
    277  28000 ????				       adc	.ByteOffset
    278  28000 ????				       asl
    279  28000 ????				       asl
    280  28000 ????				       adc	.ByteOffset
    281  28000 ????				       endif
    282  28000 ????				       if	{1}_width = 14
    283  28000 ????				       asl
    284  28000 ????				       adc	.ByteOffset
    285  28000 ????				       asl
    286  28000 ????				       adc	.ByteOffset
    287  28000 ????				       asl
    288  28000 ????				       endif
    289  28000 ????
    290  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    291  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    292  28000 ????
    293  28000 ????				       iny
    294  28000 ????
    295  28000 ????				       lda	#({1}_mode | %01000000)
    296  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    297  28000 ????
    298  28000 ????				       iny
    299  28000 ????
    300  28000 ????				       lda	.SpriteY
    301  28000 ????				       and	#(WZONEHEIGHT - 1)
    302  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    303  28000 ????				       ora	#>.GFXLabel
    304  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    305  28000 ????
    306  28000 ????				       iny
    307  28000 ????
    308  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    309  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    310  28000 ????
    311  28000 ????				       iny
    312  28000 ????
    313  28000 ????				       lda	.SpriteX
    314  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    315  28000 ????
    316  28000 ????				       iny
    317  28000 ????				       sty	dlend,x
    318  28000 ????
    319  28000 ????				       ifconst	ALWAYSTERMINATE
    320  28000 ????				       iny
    321  28000 ????				       lda	#0
    322  28000 ????				       sta	(dlpnt),y
    323  28000 ????				       endif
    324  28000 ????
    325  28000 ????				       bcc	.PLOTSPRITEend
    326  28000 ????
    327  28000 ????				       inx		; next zone
    328  28000 ????
    329  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    330  28000 ????				       sta	dlpnt
    331  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    332  28000 ????				       sta	dlpnt+1
    333  28000 ????
    334  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    335  28000 ????
    336  28000 ????				       lda	.ByteOffset
    337  28000 ????				       if	{1}_width = 1
    338  28000 ????				       clc
    339  28000 ????				       endif
    340  28000 ????				       if	{1}_width = 2
    341  28000 ????				       asl		; carry clear
    342  28000 ????				       endif
    343  28000 ????				       if	{1}_width = 3
    344  28000 ????				       asl		; carry clear
    345  28000 ????				       adc	.ByteOffset
    346  28000 ????				       endif
    347  28000 ????				       if	{1}_width = 4
    348  28000 ????				       asl		; carry clear
    349  28000 ????				       asl
    350  28000 ????				       endif
    351  28000 ????				       if	{1}_width = 5
    352  28000 ????				       asl		; carry clear
    353  28000 ????				       asl
    354  28000 ????				       adc	.ByteOffset
    355  28000 ????				       endif
    356  28000 ????				       if	{1}_width = 6
    357  28000 ????				       asl		; carry clear
    358  28000 ????				       adc	.ByteOffset
    359  28000 ????				       asl
    360  28000 ????				       endif
    361  28000 ????				       if	{1}_width = 7
    362  28000 ????				       asl		; carry clear
    363  28000 ????				       adc	.ByteOffset
    364  28000 ????				       asl
    365  28000 ????				       endif
    366  28000 ????				       if	{1}_width = 8
    367  28000 ????				       asl		; carry clear
    368  28000 ????				       asl
    369  28000 ????				       asl
    370  28000 ????				       endif
    371  28000 ????				       if	{1}_width = 9
    372  28000 ????				       asl		; carry clear
    373  28000 ????				       asl
    374  28000 ????				       asl
    375  28000 ????				       adc	.ByteOffset
    376  28000 ????				       endif
    377  28000 ????				       if	{1}_width = 10
    378  28000 ????				       asl		; carry clear
    379  28000 ????				       asl
    380  28000 ????				       adc	.ByteOffset
    381  28000 ????				       asl
    382  28000 ????				       endif
    383  28000 ????				       if	{1}_width = 11
    384  28000 ????				       asl		; carry clear
    385  28000 ????				       asl
    386  28000 ????				       adc	.ByteOffset
    387  28000 ????				       asl
    388  28000 ????				       adc	.ByteOffset
    389  28000 ????				       endif
    390  28000 ????				       if	{1}_width = 12
    391  28000 ????				       asl		; carry clear
    392  28000 ????				       adc	.ByteOffset
    393  28000 ????				       asl
    394  28000 ????				       asl
    395  28000 ????				       endif
    396  28000 ????				       if	{1}_width = 13
    397  28000 ????				       asl		; carry clear
    398  28000 ????				       adc	.ByteOffset
    399  28000 ????				       asl
    400  28000 ????				       asl
    401  28000 ????				       adc	.ByteOffset
    402  28000 ????				       endif
    403  28000 ????				       if	{1}_width = 14
    404  28000 ????				       asl		; carry clear
    405  28000 ????				       adc	.ByteOffset
    406  28000 ????				       asl
    407  28000 ????				       adc	.ByteOffset
    408  28000 ????				       asl
    409  28000 ????				       endif
    410  28000 ????
    411  28000 ????				       adc	#<.GFXLabel
    412  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    413  28000 ????
    414  28000 ????				       iny
    415  28000 ????
    416  28000 ????				       lda	#({1}_mode | %01000000)
    417  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    418  28000 ????
    419  28000 ????				       iny
    420  28000 ????
    421  28000 ????				       lda	.SpriteY
    422  28000 ????				       and	#(WZONEHEIGHT - 1)
    423  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    424  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    425  28000 ????
    426  28000 ????				       iny
    427  28000 ????
    428  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    429  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    430  28000 ????
    431  28000 ????				       iny
    432  28000 ????
    433  28000 ????				       lda	.SpriteX
    434  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    435  28000 ????
    436  28000 ????				       iny
    437  28000 ????				       sty	dlend,x
    438  28000 ????
    439  28000 ????				       ifconst	ALWAYSTERMINATE
    440  28000 ????				       iny
    441  28000 ????				       lda	#0
    442  28000 ????				       sta	(dlpnt),y
    443  28000 ????				       endif
    444  28000 ????
    445  28000 ????			    .PLOTSPRITEend
    446  28000 ????				       ENDM
    447  28000 ????
    448  28000 ????						;
    449  28000 ????						; speakjet.inc
    450  28000 ????						;
    451  28000 ????						;
    452  28000 ????						; AtariVox Speech Synth Driver
    453  28000 ????						;
    454  28000 ????						; By Alex Herbert, 2004
    455  28000 ????						;
    456  28000 ????
    457  28000 ????
    458  28000 ????
    459  28000 ????
    460  28000 ????						; Constants
    461  28000 ????
    462  28000 ????
    463  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    464  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    465  28000 ????
    466  28000 ????
    467  28000 ????
    468  28000 ????						; Macros
    469  28000 ????
    470  28000 ????				       mac	spkout
    471  28000 ????
    472  28000 ????						; check buffer-full status
    473  28000 ????				       lda	SWCHA
    474  28000 ????				       and	#SERIAL_RDYMASK
    475  28000 ????				       beq	.speech_done
    476  28000 ????
    477  28000 ????						; get next speech byte
    478  28000 ????				       ldy	#$00
    479  28000 ????				       lda	(speech_addr),y
    480  28000 ????
    481  28000 ????						; invert data and check for end of string
    482  28000 ????				       eor	#$ff
    483  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    484  28000 ????				       beq	.speech_done
    485  28000 ????				       sta	{1}
    486  28000 ????
    487  28000 ????						; increment speech pointer
    488  28000 ????				       inc	speech_addr
    489  28000 ????				       bne	.incaddr_skip
    490  28000 ????				       inc	speech_addr+1
    491  28000 ????			    .incaddr_skip
    492  28000 ????
    493  28000 ????						; output byte as serial data
    494  28000 ????
    495  28000 ????				       sec		; start bit
    496  28000 ????			    .byteout_loop
    497  28000 ????						; put carry flag into bit 0 of SWACNT, perserving other bits
    498  28000 ????				       lda	SWACNT	; 4
    499  28000 ????				       and	#$fe	; 2 6
    500  28000 ????				       adc	#$00	; 2 8
    501  28000 ????				       sta	SWACNT	; 4 12
    502  28000 ????
    503  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    504  28000 ????				       cpy	#$09	; 2 14
    505  28000 ????				       beq	.speech_done	; 2 16
    506  28000 ????				       iny		; 2 18
    507  28000 ????
    508  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    509  28000 ????						; to match the original baud rate...
    510  28000 ????						;ldx	  #$07 ; 2600
    511  28000 ????				       ldx	#$0D
    512  28000 ????
    513  28000 ????			    .delay_loop
    514  28000 ????				       dex		; 
    515  28000 ????				       bne	.delay_loop	; 36 54
    516  28000 ????
    517  28000 ????						; shift next data bit into carry
    518  28000 ????				       lsr	{1}	; 5 59
    519  28000 ????
    520  28000 ????						; and loop (branch always taken)
    521  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    522  28000 ????
    523  28000 ????			    .speech_done
    524  28000 ????
    525  28000 ????				       endm
    526  28000 ????
    527  28000 ????
    528  28000 ????				       mac	speak
    529  28000 ????
    530  28000 ????				       lda	#<{1}
    531  28000 ????				       sta	speech_addr
    532  28000 ????				       lda	#>{1}
    533  28000 ????				       sta	speech_addr+1
    534  28000 ????
    535  28000 ????				       endm
    536  28000 ????
    537  28000 ????
    538  28000 ????
    539  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    540  28000 ????
    541  28000 ????				       processor	6502
    542  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Adresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	mirror of 1800-27ff
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     51  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     52  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     53  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     54  28000 ????
     55  28000 ????						; ** some common alternate names for INPT0/1/2/3
     56  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     57  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     58  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     59  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     60  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     61  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     62  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     63  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     64  28000 ????
     65  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     66  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     67  28000 ????
     68  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     69  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     70  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     71  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     72  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     73  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     74  28000 ????
     75  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     76  28000 ????
     77  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     78  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     79  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     80  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     81  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     82  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     83  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     84  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     85  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     86  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     87  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     88  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     89  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     90  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     91  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     92  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     93  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     94  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     95  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     96  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     97  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
     98  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
     99  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    100  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    101  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    102  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    103  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    104  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    105  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    106  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    107  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    108  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    109  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    110  28000 ????
    111  28000 ????
    112  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    113  28000 ????
    114  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    115  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    116  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    117  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    118  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    119  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    120  28000 ????
    121  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    122  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    123  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    124  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    125  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    126  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    127  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    128  28000 ????
    129  28000 ????						;XM
    130  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    131  28000 ????		04 70	    XCTRL1     =	$470
    132  28000 ????		04 78	    XCTRL2     =	$478
    133  28000 ????		04 7c	    XCTRL3     =	$47c
    134  28000 ????		04 71	    XCTRL4     =	$471
    135  28000 ????		04 72	    XCTRL5     =	$472
    136  28000 ????
    137  28000 ????						; Pokey register relative locations, since its base may be different
    138  28000 ????						; depending on the hardware.
    139  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    140  28000 ????		00 01	    PAUDC0     =	$1
    141  28000 ????		00 02	    PAUDF1     =	$2
    142  28000 ????		00 03	    PAUDC1     =	$3
    143  28000 ????		00 04	    PAUDF2     =	$4
    144  28000 ????		00 05	    PAUDC2     =	$5
    145  28000 ????		00 06	    PAUDF3     =	$6
    146  28000 ????		00 07	    PAUDC3     =	$7
    147  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    148  28000 ????		00 09	    PSTIMER    =	$9
    149  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    150  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    font_mode  =	$00
      4  28000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  28000 ????		00 35	    font_width =	$35
      6  28000 ????		01 5b	    fireWaitMax =	var27
      7  28000 ????
      8  28000 ????		01 5a	    fireWait   =	var26
      9  28000 ????
     10  28000 ????		01 59	    tColor     =	var25
     11  28000 ????
     12  28000 ????		01 58	    v4s        =	var24
     13  28000 ????
     14  28000 ????		01 57	    v3s        =	var23
     15  28000 ????
     16  28000 ????		01 56	    v2s        =	var22
     17  28000 ????
     18  28000 ????		01 55	    v1s        =	var21
     19  28000 ????
     20  28000 ????		01 54	    w4s        =	var20
     21  28000 ????
     22  28000 ????		01 53	    w3s        =	var19
     23  28000 ????
     24  28000 ????		01 52	    w2s        =	var18
     25  28000 ????
     26  28000 ????		01 51	    w1s        =	var17
     27  28000 ????
     28  28000 ????		01 50	    f4s        =	var16
     29  28000 ????
     30  28000 ????		01 4f	    f3s        =	var15
     31  28000 ????
     32  28000 ????		01 4e	    f2s        =	var14
     33  28000 ????
     34  28000 ????		01 4d	    f1s        =	var13
     35  28000 ????
     36  28000 ????		01 4c	    v4	       =	var12
     37  28000 ????
     38  28000 ????		01 4b	    v3	       =	var11
     39  28000 ????
     40  28000 ????		01 4a	    v2	       =	var10
     41  28000 ????
     42  28000 ????		01 49	    v1	       =	var9
     43  28000 ????
     44  28000 ????		01 48	    w4	       =	var8
     45  28000 ????
     46  28000 ????		01 47	    w3	       =	var7
     47  28000 ????
     48  28000 ????		01 46	    w2	       =	var6
     49  28000 ????
     50  28000 ????		01 45	    w1	       =	var5
     51  28000 ????
     52  28000 ????		01 44	    f4	       =	var4
     53  28000 ????
     54  28000 ????		01 43	    f3	       =	var3
     55  28000 ????
     56  28000 ????		01 42	    f2	       =	var2
     57  28000 ????
     58  28000 ????		01 41	    f1	       =	var1
     59  28000 ????
     60  28000 ????		00 01	    plotvalueonscreen =	1
     61  28000 ????		00 0f	    font_color1 =	$0f
     62  28000 ????		00 00	    font_color0 =	$00
     63  28000 ????		00 01	    pokeysupport =	1
     64  28000 ????		00 01	    SGRAM      =	1
     65  28000 ????		00 08	    bankswitchmode =	8
     66  28000 ????		00 01	    ROM128K    =	1
     67  28000 ????		00 01	    plotvalueonscreen =	1
     68  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    ssCTRL     =	$2131
     63  28000 ????		21 32	    ssCHARBASE =	$2132
     64  28000 ????		21 33	    hsdisplaymode =	$2133
     65  28000 ????		21 34	    gamedifficulty =	$2134
     66  28000 ????		21 35	    hsinitialpos =	$2135
     67  28000 ????		21 36	    hsinitialhold =	$2136
     68  28000 ????		21 37	    hscursorx  =	$2137
     69  28000 ????		21 38	    hsjoydebounce =	$2138
     70  28000 ????		21 39	    hsswcha    =	$2139
     71  28000 ????		21 3a	    hsinpt1    =	$213A
     72  28000 ????		21 3b	    hscolorchaseindex =	$213B
     73  28000 ????		21 3c	    visibleDLLstart =	$213C
     74  28000 ????		21 3d	    overscanDLLstart =	$213D
     75  28000 ????		21 3e	    frameslost =	$213E
     76  28000 ????
     77  28000 ????
     78  28000 ????		00 40	    rand       =	$40
     79  28000 ????		00 41	    rand16     =	$41
     80  28000 ????		00 42	    temp1      =	$42
     81  28000 ????		00 43	    temp2      =	$43
     82  28000 ????		00 44	    temp3      =	$44
     83  28000 ????		00 45	    temp4      =	$45
     84  28000 ????		00 46	    temp5      =	$46
     85  28000 ????		00 47	    temp6      =	$47
     86  28000 ????		00 48	    temp7      =	$48
     87  28000 ????		00 49	    temp8      =	$49
     88  28000 ????		00 4a	    temp9      =	$4a
     89  28000 ????
     90  28000 ????		00 4b	    pokeybase  =	$4b
     91  28000 ????		00 4b	    pokeybaselo =	$4b
     92  28000 ????		00 4c	    pokeybasehi =	$4c
     93  28000 ????
     94  28000 ????		00 4d	    visibleover =	$4d
     95  28000 ????
     96  28000 ????		00 4e	    sfx1pointlo =	$4e
     97  28000 ????		00 4f	    sfx2pointlo =	$4f
     98  28000 ????		00 50	    sfx1pointhi =	$50
     99  28000 ????		00 51	    sfx2pointhi =	$51
    100  28000 ????
    101  28000 ????		00 52	    sfx1priority =	$52
    102  28000 ????		00 53	    sfx2priority =	$53
    103  28000 ????		00 54	    sfx1poffset =	$54
    104  28000 ????		00 55	    sfx2poffset =	$55
    105  28000 ????
    106  28000 ????		00 56	    sfx1frames =	$56
    107  28000 ????		00 57	    sfx2frames =	$57
    108  28000 ????		00 58	    sfx1tick   =	$58
    109  28000 ????		00 59	    sfx2tick   =	$59
    110  28000 ????
    111  28000 ????		00 5a	    tempmath   =	$5a
    112  28000 ????
    113  28000 ????		00 5b	    pokey1pointlo =	$5b
    114  28000 ????		00 5c	    pokey1pointhi =	$5c
    115  28000 ????		00 5d	    pokey2pointlo =	$5d
    116  28000 ????		00 5e	    pokey2pointhi =	$5e
    117  28000 ????		00 5f	    pokey3pointlo =	$5f
    118  28000 ????		00 60	    pokey3pointhi =	$60
    119  28000 ????		00 61	    pokey4pointlo =	$61
    120  28000 ????		00 62	    pokey4pointhi =	$62
    121  28000 ????
    122  28000 ????		00 63	    dlpnt      =	$63	; to $64
    123  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    124  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    125  28000 ????
    126  28000 ????		00 9f	    speech_addr =	$9f
    127  28000 ????		00 a0	    speech_addr_hi =	$a0
    128  28000 ????
    129  28000 ????		00 a1	    HSGameTableLo =	$a1
    130  28000 ????		00 a2	    HSGameTableHi =	$a2
    131  28000 ????		00 a3	    HSVoxHi    =	$a3
    132  28000 ????		00 a4	    HSVoxLo    =	$a4
    133  28000 ????
    134  28000 ????						;channel pointers
    135  28000 ????
    136  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    137  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    138  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    139  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    140  28000 ????
    141  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    142  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    143  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    144  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    145  28000 ????
    146  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    147  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    148  28000 ????		00 af	    songchannel3layer3lo =	$aF
    149  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    150  28000 ????
    151  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    152  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    153  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    154  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    155  28000 ????
    156  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    157  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    158  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    159  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    160  28000 ????
    161  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    162  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    163  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    164  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    165  28000 ????
    166  28000 ????		00 bd	    songdatalo =	$bd
    167  28000 ????		00 be	    songdatahi =	$be
    168  28000 ????
    169  28000 ????		00 bf	    inactivechannelcount =	$bf
    170  28000 ????
    171  28000 ????
    172  28000 ????		00 c0	    songchannel1transpose =	$c0
    173  28000 ????		00 c1	    songchannel2transpose =	$c1
    174  28000 ????		00 c2	    songchannel3transpose =	$c2
    175  28000 ????		00 c3	    songchannel4transpose =	$c3
    176  28000 ????
    177  28000 ????		00 c4	    songstackindex =	$c4
    178  28000 ????
    179  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  28000 ????
    184  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  28000 ????
    189  28000 ????		00 cd	    sfx1notedata =	$cd
    190  28000 ????		00 ce	    sfx2notedata =	$ce
    191  28000 ????
    192  28000 ????		00 cf	    songloops  =	$cf
    193  28000 ????
    194  28000 ????		00 d0	    songpointerlo =	$D0
    195  28000 ????		00 d1	    songpointerhi =	$D1
    196  28000 ????
    197  28000 ????		00 d2	    voxlock    =	$D2
    198  28000 ????		00 d3	    voxqueuesize =	$D3
    199  28000 ????
    200  28000 ????		00 d4	    vblankroutines =	$D4
    201  28000 ????
    202  28000 ????		00 d5	    doublebufferstate =	$D5
    203  28000 ????		00 d6	    doublebufferdloffset =	$D6
    204  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  28000 ????
    206  28000 ????		00 d8	    inttemp1   =	$D8
    207  28000 ????		00 d9	    inttemp2   =	$D9
    208  28000 ????		00 da	    inttemp3   =	$DA
    209  28000 ????		00 db	    inttemp4   =	$DB
    210  28000 ????		00 dc	    inttemp5   =	$DC
    211  28000 ????		00 dd	    inttemp6   =	$DD
    212  28000 ????
    213  28000 ????		00 de	    sfxschedulelock =	$DE
    214  28000 ????		00 df	    sfxschedulemissed =	$DF
    215  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  28000 ????		00 e2	    sfxpitchoffset =	$E2
    218  28000 ????		00 e3	    sfxnoteindex =	$E3
    219  28000 ????
    220  28000 ????		00 e4	    CTLSWAs    =	$E4
    221  28000 ????		00 e5	    CTLSWBs    =	$E5
    222  28000 ????
    223  28000 ????		00 e6	    A	       =	$e6
    224  28000 ????		00 e6	    a	       =	$e6
    225  28000 ????		00 e7	    B	       =	$e7
    226  28000 ????		00 e7	    b	       =	$e7
    227  28000 ????		00 e8	    C	       =	$e8
    228  28000 ????		00 e8	    c	       =	$e8
    229  28000 ????		00 e9	    D	       =	$e9
    230  28000 ????		00 e9	    d	       =	$e9
    231  28000 ????		00 ea	    E	       =	$ea
    232  28000 ????		00 ea	    e	       =	$ea
    233  28000 ????		00 eb	    F	       =	$eb
    234  28000 ????		00 eb	    f	       =	$eb
    235  28000 ????		00 ec	    G	       =	$ec
    236  28000 ????		00 ec	    g	       =	$ec
    237  28000 ????		00 ed	    H	       =	$ed
    238  28000 ????		00 ed	    h	       =	$ed
    239  28000 ????		00 ee	    I	       =	$ee
    240  28000 ????		00 ee	    i	       =	$ee
    241  28000 ????		00 ef	    J	       =	$ef
    242  28000 ????		00 ef	    j	       =	$ef
    243  28000 ????		00 f0	    K	       =	$f0
    244  28000 ????		00 f0	    k	       =	$f0
    245  28000 ????		00 f1	    L	       =	$f1
    246  28000 ????		00 f1	    l	       =	$f1
    247  28000 ????		00 f2	    M	       =	$f2
    248  28000 ????		00 f2	    m	       =	$f2
    249  28000 ????		00 f3	    N	       =	$f3
    250  28000 ????		00 f3	    n	       =	$f3
    251  28000 ????		00 f4	    O	       =	$f4
    252  28000 ????		00 f4	    o	       =	$f4
    253  28000 ????		00 f5	    P	       =	$f5
    254  28000 ????		00 f5	    p	       =	$f5
    255  28000 ????		00 f6	    Q	       =	$f6
    256  28000 ????		00 f6	    q	       =	$f6
    257  28000 ????		00 f7	    R	       =	$f7
    258  28000 ????		00 f7	    r	       =	$f7
    259  28000 ????		00 f8	    S	       =	$f8
    260  28000 ????		00 f8	    s	       =	$f8
    261  28000 ????		00 f9	    T	       =	$f9
    262  28000 ????		00 f9	    t	       =	$f9
    263  28000 ????		00 fa	    U	       =	$fa
    264  28000 ????		00 fa	    u	       =	$fa
    265  28000 ????		00 fb	    V	       =	$fb
    266  28000 ????		00 fb	    v	       =	$fb
    267  28000 ????		00 fc	    W	       =	$fc
    268  28000 ????		00 fc	    w	       =	$fc
    269  28000 ????		00 fd	    X	       =	$fd
    270  28000 ????		00 fd	    x	       =	$fd
    271  28000 ????		00 fe	    Y	       =	$fe
    272  28000 ????		00 fe	    y	       =	$fe
    273  28000 ????		00 ff	    Z	       =	$ff
    274  28000 ????		00 ff	    z	       =	$ff
    275  28000 ????
    276  28000 ????						; var0-var99 variables use the top of the stack
    277  28000 ????		01 40	    var0       =	$140
    278  28000 ????		01 41	    var1       =	$141
    279  28000 ????		01 42	    var2       =	$142
    280  28000 ????		01 43	    var3       =	$143
    281  28000 ????		01 44	    var4       =	$144
    282  28000 ????		01 45	    var5       =	$145
    283  28000 ????		01 46	    var6       =	$146
    284  28000 ????		01 47	    var7       =	$147
    285  28000 ????		01 48	    var8       =	$148
    286  28000 ????		01 49	    var9       =	$149
    287  28000 ????		01 4a	    var10      =	$14a
    288  28000 ????		01 4b	    var11      =	$14b
    289  28000 ????		01 4c	    var12      =	$14c
    290  28000 ????		01 4d	    var13      =	$14d
    291  28000 ????		01 4e	    var14      =	$14e
    292  28000 ????		01 4f	    var15      =	$14f
    293  28000 ????		01 50	    var16      =	$150
    294  28000 ????		01 51	    var17      =	$151
    295  28000 ????		01 52	    var18      =	$152
    296  28000 ????		01 53	    var19      =	$153
    297  28000 ????		01 54	    var20      =	$154
    298  28000 ????		01 55	    var21      =	$155
    299  28000 ????		01 56	    var22      =	$156
    300  28000 ????		01 57	    var23      =	$157
    301  28000 ????		01 58	    var24      =	$158
    302  28000 ????		01 59	    var25      =	$159
    303  28000 ????		01 5a	    var26      =	$15a
    304  28000 ????		01 5b	    var27      =	$15b
    305  28000 ????		01 5c	    var28      =	$15c
    306  28000 ????		01 5d	    var29      =	$15d
    307  28000 ????		01 5e	    var30      =	$15e
    308  28000 ????		01 5f	    var31      =	$15f
    309  28000 ????		01 60	    var32      =	$160
    310  28000 ????		01 61	    var33      =	$161
    311  28000 ????		01 62	    var34      =	$162
    312  28000 ????		01 63	    var35      =	$163
    313  28000 ????		01 64	    var36      =	$164
    314  28000 ????		01 65	    var37      =	$165
    315  28000 ????		01 66	    var38      =	$166
    316  28000 ????		01 67	    var39      =	$167
    317  28000 ????		01 68	    var40      =	$168
    318  28000 ????		01 69	    var41      =	$169
    319  28000 ????		01 6a	    var42      =	$16a
    320  28000 ????		01 6b	    var43      =	$16b
    321  28000 ????		01 6c	    var44      =	$16c
    322  28000 ????		01 6d	    var45      =	$16d
    323  28000 ????		01 6e	    var46      =	$16e
    324  28000 ????		01 6f	    var47      =	$16f
    325  28000 ????		01 70	    var48      =	$170
    326  28000 ????		01 71	    var49      =	$171
    327  28000 ????		01 72	    var50      =	$172
    328  28000 ????		01 73	    var51      =	$173
    329  28000 ????		01 74	    var52      =	$174
    330  28000 ????		01 75	    var53      =	$175
    331  28000 ????		01 76	    var54      =	$176
    332  28000 ????		01 77	    var55      =	$177
    333  28000 ????		01 78	    var56      =	$178
    334  28000 ????		01 79	    var57      =	$179
    335  28000 ????		01 7a	    var58      =	$17a
    336  28000 ????		01 7b	    var59      =	$17b
    337  28000 ????		01 7c	    var60      =	$17c
    338  28000 ????		01 7d	    var61      =	$17d
    339  28000 ????		01 7e	    var62      =	$17e
    340  28000 ????		01 7f	    var63      =	$17f
    341  28000 ????		01 80	    var64      =	$180
    342  28000 ????		01 81	    var65      =	$181
    343  28000 ????		01 82	    var66      =	$182
    344  28000 ????		01 83	    var67      =	$183
    345  28000 ????		01 84	    var68      =	$184
    346  28000 ????		01 85	    var69      =	$185
    347  28000 ????		01 86	    var70      =	$186
    348  28000 ????		01 87	    var71      =	$187
    349  28000 ????		01 88	    var72      =	$188
    350  28000 ????		01 89	    var73      =	$189
    351  28000 ????		01 8a	    var74      =	$18a
    352  28000 ????		01 8b	    var75      =	$18b
    353  28000 ????		01 8c	    var76      =	$18c
    354  28000 ????		01 8d	    var77      =	$18d
    355  28000 ????		01 8e	    var78      =	$18e
    356  28000 ????		01 8f	    var79      =	$18f
    357  28000 ????		01 90	    var80      =	$190
    358  28000 ????		01 91	    var81      =	$191
    359  28000 ????		01 92	    var82      =	$192
    360  28000 ????		01 93	    var83      =	$193
    361  28000 ????		01 94	    var84      =	$194
    362  28000 ????		01 95	    var85      =	$195
    363  28000 ????		01 96	    var86      =	$196
    364  28000 ????		01 97	    var87      =	$197
    365  28000 ????		01 98	    var88      =	$198
    366  28000 ????		01 99	    var89      =	$199
    367  28000 ????		01 9a	    var90      =	$19a
    368  28000 ????		01 9b	    var91      =	$19b
    369  28000 ????		01 9c	    var92      =	$19c
    370  28000 ????		01 9d	    var93      =	$19d
    371  28000 ????		01 9e	    var94      =	$19e
    372  28000 ????		01 9f	    var95      =	$19f
    373  28000 ????		01 a0	    var96      =	$1a0
    374  28000 ????		01 a1	    var97      =	$1a1
    375  28000 ????		01 a2	    var98      =	$1a2
    376  28000 ????		01 a3	    var99      =	$1a3
    377  28000 ????
    378 U01d2 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3				  -	      ifconst	DOUBLEBUFFER
    395 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    396 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    397 U01b3					      endif
    398 U01b3
    399 U01b3		       00	   pausedisable DS	1	; $1B5
    400 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b5
    402 U01b5				  -	      ifconst	AVOXVOICE
    403 U01b5				  -avoxenable DS	1	; $1B7
    404 U01b5				  -tempavox   DS	1	; $1B8
    405 U01b5					      endif
    406 U01b5
    407 U01b5				  -	      ifconst	MUSICTRACKER
    408 U01b5				  -songtempo  DS	1	; $1B9
    409 U01b5				  -songtick   DS	1	; $1BA
    410 U01b5				  -
    411 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b5				  -
    416 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b5				  -
    421 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b5				  -
    426 U01b5				  -songchannel1busywait DS	1	; $1C7
    427 U01b5				  -songchannel2busywait DS	1	; $1C8
    428 U01b5				  -songchannel3busywait DS	1	; $1C9
    429 U01b5				  -songchannel4busywait DS	1	; $1CA
    430 U01b5				  -
    431 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b5					      endif
    436 U01b5
    437 U01b5		       00	   palframes  DS	1	; $1CF
    438 U01b6		       00	   palfastframe DS	1	; $1D0
    439 U01b7
    440 U01b7				  -	      ifconst	MOUSESUPPORT
    441 U01b7				  -port0resolution DS	1	; $1D1
    442 U01b7				  -port1resolution DS	1	; $1D2
    443 U01b7					      else
    444 U01b7				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b7				  -port0resolution DS	1	; $1D1
    446 U01b7				  -port1resolution DS	1	; $1D2
    447 U01b7					      endif
    448 U01b7					      endif
    449 U01b7
    450 U01b7		       00	   port0control DS	1	; $1D3
    451 U01b8		       00	   port1control DS	1	; $1D4
    452 U01b9
    453 U01b9							; port#control values...
    454 U01b9							;	1 = proline
    455 U01b9							;	2 = lightgun
    456 U01b9							;	3 = paddle
    457 U01b9							;	4 = trakball
    458 U01b9							;	5 = vcs joystick
    459 U01b9							;	6 = driving
    460 U01b9							;	7 = keypad
    461 U01b9							;	8 = st mouse/cx80
    462 U01b9							;	9 = amiga mouse
    463 U01b9							;     10 = atarivox
    464 U01b9
    465 U01b9							; controller 0 data...
    466 U01b9		       00	   paddleposition0 DS	1	; $1D5
    467 U01b9		       01 b9	   keypadmatrix0a =	paddleposition0
    468 U01b9		       01 b9	   drivingposition0 =	paddleposition0
    469 U01b9		       01 b9	   trakballx0 =	paddleposition0
    470 U01b9		       01 b9	   mousex0    =	paddleposition0
    471 U01b9		       01 b9	   lighttgunx0 =	paddleposition0
    472 U01ba
    473 U01ba							; controller 1 data...
    474 U01ba		       00	   paddleposition2 DS	1	; $1D6
    475 U01ba		       01 ba	   keypadmatrix1a =	paddleposition2
    476 U01ba		       01 ba	   drivingposition1 =	paddleposition2
    477 U01ba		       01 ba	   trakballx1 =	paddleposition2
    478 U01ba		       01 ba	   mousex1    =	paddleposition2
    479 U01ba		       01 ba	   lightgunx1 =	paddleposition2
    480 U01bb
    481 U01bb							; controller 0 altdata...
    482 U01bb		       00	   paddleposition1 DS	1	; $1D7
    483 U01bb		       01 bb	   keypadmatrix0b =	paddleposition1
    484 U01bb		       01 bb	   trakbally0 =	paddleposition1
    485 U01bb		       01 bb	   mousey0    =	paddleposition1
    486 U01bb		       01 bb	   lightguny0 =	paddleposition1
    487 U01bc
    488 U01bc							; controller 1 altdata...
    489 U01bc		       00	   paddleposition3 DS	1	; $1D8
    490 U01bc		       01 bc	   keypadmatrix1b =	paddleposition3
    491 U01bc		       01 bc	   trakbally1 =	paddleposition3
    492 U01bc		       01 bc	   mousey1    =	paddleposition3
    493 U01bc		       01 bc	   lightguny1 =	paddleposition3
    494 U01bd
    495 U01bd							; controller state save. for trakball state+dir codes, rotary position codes
    496 U01bd		       00	   controller0statesave DS	1	; $1D9
    497 U01bd		       01 bd	   paddleprevious0 =	controller0statesave
    498 U01bd		       01 bd	   mousecodex0 =	controller0statesave
    499 U01bd		       01 bd	   trakballcodex0 =	controller0statesave
    500 U01bd		       01 bd	   keypadmatrix0c =	controller0statesave
    501 U01be
    502 U01be		       00	   controller1statesave DS	1	; $1DA
    503 U01be		       01 be	   paddleprevious2 =	controller1statesave
    504 U01be		       01 be	   mousecodex1 =	controller1statesave
    505 U01be		       01 be	   trakballcodex1 =	controller1statesave
    506 U01be		       01 be	   keypadmatrix1c =	controller1statesave
    507 U01bf
    508 U01bf		       00	   paddleprevious1 DS	1	; $1DB
    509 U01bf		       01 bf	   keypadmatrix0d =	paddleprevious1
    510 U01bf		       01 bf	   mousecodey0 =	paddleprevious1
    511 U01bf		       01 bf	   trakballcodey0 =	paddleprevious1
    512 U01c0
    513 U01c0		       00	   paddleprevious3 DS	1	; $1DC
    514 U01c0		       01 c0	   keypadmatrix1d =	paddleprevious3
    515 U01c0		       01 c0	   mousecodey1 =	paddleprevious3
    516 U01c0		       01 c0	   trakballcodey1 =	paddleprevious3
    517 U01c1
    518 U01c1					      ifconst	pokeysupport
    519 U01c1		       00	   pokey1frames DS	1	; $1DD
    520 U01c2		       00	   pokey1tick DS	1	; $1DE
    521 U01c3		       00	   pokey2frames DS	1	; $1DF
    522 U01c4		       00	   pokey2tick DS	1	; $1E0
    523 U01c5		       00	   pokey3frames DS	1	; $1E1
    524 U01c6		       00	   pokey3tick DS	1	; $1E2
    525 U01c7		       00	   pokey4frames DS	1	; $1E3
    526 U01c8		       00	   pokey4tick DS	1	; $1E4
    527 U01c9		       00	   pokey1priority DS	1	; $1E5
    528 U01ca		       00	   pokey1offset DS	1	; $1E6
    529 U01cb		       00	   pokey2priority DS	1	; $1E7
    530 U01cc		       00	   pokey2offset DS	1	; $1E8
    531 U01cd		       00	   pokey3priority DS	1	; $1E9
    532 U01ce		       00	   pokey3offset DS	1	; $1EA
    533 U01cf		       00	   pokey4priority DS	1	; $1EB
    534 U01d0		       00	   pokey4offset DS	1	; $1EC
    535 U01d1					      endif
    536 U01d1
    537 U01d1					      ifnconst	CANARRYOFF
    538 U01d1		       00	   canary     DS	1	; $1ED
    539 U01d2					      endif
    540 U01d2
    541 U01d2				  -	      ifnconst	bankswitchmode
    542 U01d2				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    543 U01d2					      else
   stack allowance: 15 nested subroutines.
    544 U01d2					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    545 U01d2					      endif
    546 U01d2					      ifnconst	CANARRYOFF
   the canary is situated at: $1d1
    547 U01d2					      echo	"  the canary is situated at:",[canary]
    548 U01d2				  -	      else
    549 U01d2				  -	      echo	"  the canary is disabled."
    550 U01d2					      endif
    551 U01d2
    552 U01d2							; $1EE - $1FF reserved for stack
    553 U01d2
    554  28000 ????				       SEG	"GAME"
    555  28000 ????
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    font_mode  =	$00
      4  28000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  28000 ????		00 35	    font_width =	$35
      6  28000 ????		01 5b	    fireWaitMax =	var27
      7  28000 ????
      8  28000 ????		01 5a	    fireWait   =	var26
      9  28000 ????
     10  28000 ????		01 59	    tColor     =	var25
     11  28000 ????
     12  28000 ????		01 58	    v4s        =	var24
     13  28000 ????
     14  28000 ????		01 57	    v3s        =	var23
     15  28000 ????
     16  28000 ????		01 56	    v2s        =	var22
     17  28000 ????
     18  28000 ????		01 55	    v1s        =	var21
     19  28000 ????
     20  28000 ????		01 54	    w4s        =	var20
     21  28000 ????
     22  28000 ????		01 53	    w3s        =	var19
     23  28000 ????
     24  28000 ????		01 52	    w2s        =	var18
     25  28000 ????
     26  28000 ????		01 51	    w1s        =	var17
     27  28000 ????
     28  28000 ????		01 50	    f4s        =	var16
     29  28000 ????
     30  28000 ????		01 4f	    f3s        =	var15
     31  28000 ????
     32  28000 ????		01 4e	    f2s        =	var14
     33  28000 ????
     34  28000 ????		01 4d	    f1s        =	var13
     35  28000 ????
     36  28000 ????		01 4c	    v4	       =	var12
     37  28000 ????
     38  28000 ????		01 4b	    v3	       =	var11
     39  28000 ????
     40  28000 ????		01 4a	    v2	       =	var10
     41  28000 ????
     42  28000 ????		01 49	    v1	       =	var9
     43  28000 ????
     44  28000 ????		01 48	    w4	       =	var8
     45  28000 ????
     46  28000 ????		01 47	    w3	       =	var7
     47  28000 ????
     48  28000 ????		01 46	    w2	       =	var6
     49  28000 ????
     50  28000 ????		01 45	    w1	       =	var5
     51  28000 ????
     52  28000 ????		01 44	    f4	       =	var4
     53  28000 ????
     54  28000 ????		01 43	    f3	       =	var3
     55  28000 ????
     56  28000 ????		01 42	    f2	       =	var2
     57  28000 ????
     58  28000 ????		01 41	    f1	       =	var1
     59  28000 ????
     60  28000 ????		00 01	    plotvalueonscreen =	1
     61  28000 ????		00 0f	    font_color1 =	$0f
     62  28000 ????		00 00	    font_color0 =	$00
     63  28000 ????		00 01	    pokeysupport =	1
     64  28000 ????		00 01	    SGRAM      =	1
     65  28000 ????		00 08	    bankswitchmode =	8
     66  28000 ????		00 01	    ROM128K    =	1
     67  28000 ????		00 01	    plotvalueonscreen =	1
     68  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
    545  28000 ????
    546  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    547  28000 ????						; For more BEAD executable info, check out the spec...
    548  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    549  28000 ????
    550  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    551  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    552  28000 ????
    553  28000 ????		00 40	    BDHSC      =	%01000000
    554  28000 ????		00 20	    BDYM       =	%00100000
    555  28000 ????		00 10	    BDPOKEY    =	%00010000
    556  28000 ????		00 08	    BDROF      =	%00001000
    557  28000 ????		00 00	    BD16K      =	%00000000
    558  28000 ????		00 01	    BD32K      =	%00000001
    559  28000 ????		00 02	    BD48K      =	%00000010
    560  28000 ????		00 05	    BD1800     =	%00000101
    561  28000 ????		00 06	    BD4000     =	%00000110
    562  28000 ????
    563  28000 ????			   -	       ifconst	ROM16K
    564  28000 ????			   -BEADHEADER =	1
    565  28000 ????				       endif
    566  28000 ????			   -	       ifconst	ROM32K
    567  28000 ????			   -BEADHEADER =	1
    568  28000 ????				       endif
    569  28000 ????			   -	       ifconst	ROM48K
    570  28000 ????			   -BEADHEADER =	1
    571  28000 ????				       endif
    572  28000 ????
    573  28000 ????			   -	       ifconst	BEADHEADER
    574  28000 ????			   -BEADHARDWARE SET	0
    575  28000 ????			   -	       ifconst	ROM16K
    576  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    577  28000 ????			   -	       endif
    578  28000 ????			   -	       ifconst	ROM32K
    579  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    580  28000 ????			   -	       endif
    581  28000 ????			   -	       ifconst	ROM48K
    582  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    583  28000 ????			   -	       endif
    584  28000 ????			   -	       ifconst	pokeysupport
    585  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    586  28000 ????			   -	       endif
    587  28000 ????			   -	       ifconst	HSSUPPORT
    588  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    589  28000 ????			   -	       endif
    590  28000 ????				       endif
    591  28000 ????
    592  28000 ????						;start address of cart...
    593  28000 ????			   -	       ifconst	ROM48K
    594  28000 ????			   -	       ORG	$4000,0
    595  28000 ????			   -	       ifconst	BEADHEADER
    596  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    597  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    598  28000 ????			   -	       CLC
    599  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    600  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    601  28000 ????			   -_SKIPDESCRIPTION
    602  28000 ????			   -	       endif
    603  28000 ????			   -	       jmp	($FFFC)
    604  28000 ????			   -	       endif
    605  28000 ????				       else
    606  28000 ????				       ifconst	bankswitchmode
    607  28000 ????			   -	       ifconst	ROMAT4K
    608  28000 ????			   -	       ORG	$4000,0
    609  28000 ????			   -	       RORG	$4000
    610  28000 ????				       else
    611  8000					      ORG	$8000,0
    612  8000					      RORG	$8000
    613  8000					      endif
    614  8000				  -	      else		; not bankswitchmode
    615  8000				  -	      ifconst	ROM16K
    616  8000				  -	      ORG	$C000,0
    617  8000				  -	      ifconst	BEADHEADER
    618  8000				  -	      .byte	$BE,$AD,BEADHARDWARE
    619  8000				  -	      ifconst	GAMEDESCRIPTION
    620  8000				  -	      CLC
    621  8000				  -	      BCC	_SKIPDESCRIPTION
    622  8000				  -	      .byte	GAMEDESCRIPTION,0
    623  8000				  -_SKIPDESCRIPTION
    624  8000				  -	      endif
    625  8000				  -	      jmp	($FFFC)
    626  8000				  -	      endif
    627  8000				  -	      else
    628  8000				  -	      ifconst	ROM8K
    629  8000				  -	      ORG	$E000,0
    630  8000				  -	      else
    631  8000				  -	      ORG	$8000,0
    632  8000				  -	      ifconst	BEADHEADER
    633  8000				  -	      .byte	$BE,$AD,BEADHARDWARE
    634  8000				  -	      ifconst	GAMEDESCRIPTION
    635  8000				  -	      CLC
    636  8000				  -	      BCC	_SKIPDESCRIPTION
    637  8000				  -	      .byte	GAMEDESCRIPTION,0
    638  8000				  -_SKIPDESCRIPTION
    639  8000				  -	      endif
    640  8000				  -	      jmp	($FFFC)
    641  8000				  -	      endif
    642  8000				  -	      endif
    643  8000				  -	      endif
    644  8000					      endif
    645  8000					      endif
    646  8000
    647  8000							;7800basic v0.15 Sep 16 2020 14:11:44
    648  8000				   SPACEOVERFLOW SET	0
    649  8000				   game
    650  8000				   .L00 		;;  set zoneheight 16
    651  8000
    652  8000				   .L01 		;;  displaymode 160A
    653  8000
    654  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    655  8002		       85 3c		      sta	CTRL
    656  8004
    657  8004		       8d 07 21 	      sta	sCTRL
    658  8007
    659  8007				   .L02 		;;  set plotvalueonscreen on
    660  8007
    661  8007				   .L03 		;;  set romsize 128kRAM
    662  8007
    663  8007				   .L04 		;;  set dlmemory $4000 $7FFF
    664  8007
    665  8007		       40 00	   DLMEMSTART =	$4000
    666  8007		       7f ff	   DLMEMEND   =	$7FFF
    667  8007
    668  8007				   .L05 		;;  set pokeysupport on
    669  8007
    670  8007				   .L06 		;;  BACKGRND = $00
    671  8007
    672  8007		       a9 00		      LDA	#$00
    673  8009		       85 20		      STA	BACKGRND
    674  800b				   .L07 		;;  incgraphic font.png 160A 0 2 3 1
    675  800b
    676  800b				   .
    677  800b							;; 
    678  800b
    679  800b				   .L08 		;;  characterset font
    680  800b
    681  800b		       a9 a0		      lda	#>font
    682  800d		       85 34		      sta	CHARBASE
    683  800f		       8d 0b 21 	      sta	sCHARBASE
    684  8012
    685  8012		       a9 60		      lda	#(font_mode | %01100000)
    686  8014		       8d 06 21 	      sta	charactermode
    687  8017
    688  8017				   .L09 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    689  8017
    690  8017				   .L010		;;  set plotvalueonscreen on 
    691  8017
    692  8017				   .
    693  8017							;; 
    694  8017
    695  8017				   .L011		;;  rem red pallette
    696  8017
    697  8017				   .L012		;;  P0C1 = $44
    698  8017
    699  8017		       a9 44		      LDA	#$44
    700  8019		       85 21		      STA	P0C1
    701  801b				   .L013		;;  P0C2 = $32
    702  801b
    703  801b		       a9 32		      LDA	#$32
    704  801d		       85 22		      STA	P0C2
    705  801f				   .L014		;;  P0C3 = $F1
    706  801f
    707  801f		       a9 f1		      LDA	#$F1
    708  8021		       85 23		      STA	P0C3
    709  8023				   .L015		;;  rem grey pallette
    710  8023
    711  8023				   .L016		;;  P1C1 = $0A
    712  8023
    713  8023		       a9 0a		      LDA	#$0A
    714  8025		       85 25		      STA	P1C1
    715  8027				   .L017		;;  P1C2 = $05
    716  8027
    717  8027		       a9 05		      LDA	#$05
    718  8029		       85 26		      STA	P1C2
    719  802b				   .L018		;;  P1C3 = $0F
    720  802b
    721  802b		       a9 0f		      LDA	#$0F
    722  802d		       85 27		      STA	P1C3
    723  802f				   .L019		;;  rem brown pallette
    724  802f
    725  802f				   .L020		;;  P2C1 = $F5
    726  802f
    727  802f		       a9 f5		      LDA	#$F5
    728  8031		       85 29		      STA	P2C1
    729  8033				   .L021		;;  P2C2 = $3F
    730  8033
    731  8033		       a9 3f		      LDA	#$3F
    732  8035		       85 2a		      STA	P2C2
    733  8037				   .L022		;;  P2C3 = $3C
    734  8037
    735  8037		       a9 3c		      LDA	#$3C
    736  8039		       85 2b		      STA	P2C3
    737  803b				   .L023		;;  rem green pallette
    738  803b
    739  803b				   .L024		;;  P3C1  = $B2
    740  803b
    741  803b		       a9 b2		      LDA	#$B2
    742  803d		       85 2d		      STA	P3C1
    743  803f				   .L025		;;  P3C2  = $C8
    744  803f
    745  803f		       a9 c8		      LDA	#$C8
    746  8041		       85 2e		      STA	P3C2
    747  8043				   .L026		;;  P3C3  = $CB
    748  8043
    749  8043		       a9 cb		      LDA	#$CB
    750  8045		       85 2f		      STA	P3C3
    751  8047				   .L027		;;  rem blue - palleete
    752  8047
    753  8047				   .L028		;;  P4C1  = $70
    754  8047
    755  8047		       a9 70		      LDA	#$70
    756  8049		       85 31		      STA	P4C1
    757  804b				   .L029		;;  P4C2  = $74
    758  804b
    759  804b		       a9 74		      LDA	#$74
    760  804d		       85 32		      STA	P4C2
    761  804f				   .L030		;;  P4C3  = $99
    762  804f
    763  804f		       a9 99		      LDA	#$99
    764  8051		       85 33		      STA	P4C3
    765  8053				   .L031		;;  rem orange pallette
    766  8053
    767  8053				   .L032		;;  P5C1  =  $35
    768  8053
    769  8053		       a9 35		      LDA	#$35
    770  8055		       85 35		      STA	P5C1
    771  8057				   .L033		;;  P5C2  =  $39
    772  8057
    773  8057		       a9 39		      LDA	#$39
    774  8059		       85 36		      STA	P5C2
    775  805b				   .L034		;;  P5C3  =  $3C
    776  805b
    777  805b		       a9 3c		      LDA	#$3C
    778  805d		       85 37		      STA	P5C3
    779  805f				   .L035		;;  rem purple palette
    780  805f
    781  805f				   .L036		;;  P6C1  =  $50
    782  805f
    783  805f		       a9 50		      LDA	#$50
    784  8061		       85 39		      STA	P6C1
    785  8063				   .L037		;;  P6C2  =  $54
    786  8063
    787  8063		       a9 54		      LDA	#$54
    788  8065		       85 3a		      STA	P6C2
    789  8067				   .L038		;;  P6C3  =  $58
    790  8067
    791  8067		       a9 58		      LDA	#$58
    792  8069		       85 3b		      STA	P6C3
    793  806b				   .L039		;;  rem yellow pallette
    794  806b
    795  806b				   .L040		;;  P7C1  =  $18
    796  806b
    797  806b		       a9 18		      LDA	#$18
    798  806d		       85 3d		      STA	P7C1
    799  806f				   .L041		;;  P7C2  =  $1B
    800  806f
    801  806f		       a9 1b		      LDA	#$1B
    802  8071		       85 3e		      STA	P7C2
    803  8073				   .L042		;;  P7C3  =  $1F
    804  8073
    805  8073		       a9 1f		      LDA	#$1F
    806  8075		       85 3f		      STA	P7C3
    807  8077				   .
    808  8077							;; 
    809  8077
    810  8077				   .L043		;;  dim f1  =	var1
    811  8077
    812  8077				   .L044		;;  dim f2  =	var2
    813  8077
    814  8077				   .L045		;;  dim f3  =	var3
    815  8077
    816  8077				   .L046		;;  dim f4  =	var4
    817  8077
    818  8077				   .L047		;;  dim w1  =	var5
    819  8077
    820  8077				   .L048		;;  dim w2  =	var6
    821  8077
    822  8077				   .L049		;;  dim w3  =	var7
    823  8077
    824  8077				   .L050		;;  dim w4  =	var8
    825  8077
    826  8077				   .L051		;;  dim v1  =	var9
    827  8077
    828  8077				   .L052		;;  dim v2  =	var10
    829  8077
    830  8077				   .L053		;;  dim v3  =	var11
    831  8077
    832  8077				   .L054		;;  dim v4  =	var12
    833  8077
    834  8077				   .
    835  8077							;; 
    836  8077
    837  8077				   .L055		;;  dim f1s  =  var13
    838  8077
    839  8077				   .L056		;;  dim f2s  =  var14
    840  8077
    841  8077				   .L057		;;  dim f3s  =  var15
    842  8077
    843  8077				   .L058		;;  dim f4s  =  var16
    844  8077
    845  8077				   .L059		;;  dim w1s  =  var17
    846  8077
    847  8077				   .L060		;;  dim w2s  =  var18
    848  8077
    849  8077				   .L061		;;  dim w3s  =  var19
    850  8077
    851  8077				   .L062		;;  dim w4s  =  var20
    852  8077
    853  8077				   .L063		;;  dim v1s  =  var21
    854  8077
    855  8077				   .L064		;;  dim v2s  =  var22
    856  8077
    857  8077				   .L065		;;  dim v3s  =  var23
    858  8077
    859  8077				   .L066		;;  dim v4s  =  var24
    860  8077
    861  8077				   .
    862  8077							;; 
    863  8077
    864  8077				   .L067		;;  dim tColor  =  var25
    865  8077
    866  8077				   .L068		;;  dim fireWait  =  var26
    867  8077
    868  8077				   .L069		;;  dim fireWaitMax  =  var27
    869  8077
    870  8077				   .
    871  8077							;; 
    872  8077
    873  8077				   .L070		;;  f1  =  0
    874  8077
    875  8077		       a9 00		      LDA	#0
    876  8079		       8d 41 01 	      STA	f1
    877  807c				   .L071		;;  f2  =  0
    878  807c
    879  807c		       a9 00		      LDA	#0
    880  807e		       8d 42 01 	      STA	f2
    881  8081				   .L072		;;  f3  =  0
    882  8081
    883  8081		       a9 00		      LDA	#0
    884  8083		       8d 43 01 	      STA	f3
    885  8086				   .L073		;;  f4  =  0
    886  8086
    887  8086		       a9 00		      LDA	#0
    888  8088		       8d 44 01 	      STA	f4
    889  808b				   .L074		;;  w1  =  10
    890  808b
    891  808b		       a9 0a		      LDA	#10
    892  808d		       8d 45 01 	      STA	w1
    893  8090				   .L075		;;  w2  =  0
    894  8090
    895  8090		       a9 00		      LDA	#0
    896  8092		       8d 46 01 	      STA	w2
    897  8095				   .L076		;;  w3  =  0
    898  8095
    899  8095		       a9 00		      LDA	#0
    900  8097		       8d 47 01 	      STA	w3
    901  809a				   .L077		;;  w4  =  0
    902  809a
    903  809a		       a9 00		      LDA	#0
    904  809c		       8d 48 01 	      STA	w4
    905  809f				   .L078		;;  v1  =  10
    906  809f
    907  809f		       a9 0a		      LDA	#10
    908  80a1		       8d 49 01 	      STA	v1
    909  80a4				   .L079		;;  v2  =  0
    910  80a4
    911  80a4		       a9 00		      LDA	#0
    912  80a6		       8d 4a 01 	      STA	v2
    913  80a9				   .L080		;;  v3  =  0
    914  80a9
    915  80a9		       a9 00		      LDA	#0
    916  80ab		       8d 4b 01 	      STA	v3
    917  80ae				   .L081		;;  v4  =  0
    918  80ae
    919  80ae		       a9 00		      LDA	#0
    920  80b0		       8d 4c 01 	      STA	v4
    921  80b3				   .
    922  80b3							;; 
    923  80b3
    924  80b3				   .L082		;;  f1s  =  1
    925  80b3
    926  80b3		       a9 01		      LDA	#1
    927  80b5		       8d 4d 01 	      STA	f1s
    928  80b8				   .L083		;;  f2s  =  0
    929  80b8
    930  80b8		       a9 00		      LDA	#0
    931  80ba		       8d 4e 01 	      STA	f2s
    932  80bd				   .L084		;;  f3s  =  0
    933  80bd
    934  80bd		       a9 00		      LDA	#0
    935  80bf		       8d 4f 01 	      STA	f3s
    936  80c2				   .L085		;;  f4s  =  0
    937  80c2
    938  80c2		       a9 00		      LDA	#0
    939  80c4		       8d 50 01 	      STA	f4s
    940  80c7				   .L086		;;  w1s  =  0
    941  80c7
    942  80c7		       a9 00		      LDA	#0
    943  80c9		       8d 51 01 	      STA	w1s
    944  80cc				   .L087		;;  w2s  =  0
    945  80cc
    946  80cc		       a9 00		      LDA	#0
    947  80ce		       8d 52 01 	      STA	w2s
    948  80d1				   .L088		;;  w3s  =  0
    949  80d1
    950  80d1		       a9 00		      LDA	#0
    951  80d3		       8d 53 01 	      STA	w3s
    952  80d6				   .L089		;;  w4s  =  0
    953  80d6
    954  80d6		       a9 00		      LDA	#0
    955  80d8		       8d 54 01 	      STA	w4s
    956  80db				   .L090		;;  v1s  =  0
    957  80db
    958  80db		       a9 00		      LDA	#0
    959  80dd		       8d 55 01 	      STA	v1s
    960  80e0				   .L091		;;  v2s  =  0
    961  80e0
    962  80e0		       a9 00		      LDA	#0
    963  80e2		       8d 56 01 	      STA	v2s
    964  80e5				   .L092		;;  v3s  =  0
    965  80e5
    966  80e5		       a9 00		      LDA	#0
    967  80e7		       8d 57 01 	      STA	v3s
    968  80ea				   .L093		;;  v4s  =  0
    969  80ea
    970  80ea		       a9 00		      LDA	#0
    971  80ec		       8d 58 01 	      STA	v4s
    972  80ef				   .L094		;;  tColor  =	0
    973  80ef
    974  80ef		       a9 00		      LDA	#0
    975  80f1		       8d 59 01 	      STA	tColor
    976  80f4				   .L095		;;  fireWait = 0
    977  80f4
    978  80f4		       a9 00		      LDA	#0
    979  80f6		       8d 5a 01 	      STA	fireWait
    980  80f9				   .L096		;;  fireWaitMax = 8
    981  80f9
    982  80f9		       a9 08		      LDA	#8
    983  80fb		       8d 5b 01 	      STA	fireWaitMax
    984  80fe				   .
    985  80fe							;; 
    986  80fe
    987  80fe				   .mainScreen
    988  80fe							;; mainScreen
    989  80fe
    990  80fe				   .L097		;;  clearscreen
    991  80fe
    992  80fe		       20 c6 f1 	      jsr	clearscreen
    993  8101				   .
    994  8101							;; 
    995  8101
    996  8101				   .L098		;;  psound 0 , f1 , w1 , v1
    997  8101
    998  8101		       a0 00		      ldy	#0
    999  8103		       ad 41 01 	      lda	f1
   1000  8106		       91 4b		      sta	(pokeybase),y
   1001  8108		       c8		      iny
   1002  8109		       ad 45 01 	      lda	w1
   1003  810c		       0a		      asl
   1004  810d		       0a		      asl
   1005  810e		       0a		      asl
   1006  810f		       0a		      asl
   1007  8110		       18		      clc
   1008  8111		       6d 49 01 	      adc	v1
   1009  8114		       91 4b		      sta	(pokeybase),y
   1010  8116				   .L099		;;  psound 1 , f2 , w2 , v2
   1011  8116
   1012  8116		       a0 02		      ldy	#2
   1013  8118		       ad 42 01 	      lda	f2
   1014  811b		       91 4b		      sta	(pokeybase),y
   1015  811d		       c8		      iny
   1016  811e		       ad 46 01 	      lda	w2
   1017  8121		       0a		      asl
   1018  8122		       0a		      asl
   1019  8123		       0a		      asl
   1020  8124		       0a		      asl
   1021  8125		       18		      clc
   1022  8126		       6d 4a 01 	      adc	v2
   1023  8129		       91 4b		      sta	(pokeybase),y
   1024  812b				   .L0100		;;  psound 2 , f3 , w3 , v3
   1025  812b
   1026  812b		       a0 04		      ldy	#4
   1027  812d		       ad 43 01 	      lda	f3
   1028  8130		       91 4b		      sta	(pokeybase),y
   1029  8132		       c8		      iny
   1030  8133		       ad 47 01 	      lda	w3
   1031  8136		       0a		      asl
   1032  8137		       0a		      asl
   1033  8138		       0a		      asl
   1034  8139		       0a		      asl
   1035  813a		       18		      clc
   1036  813b		       6d 4b 01 	      adc	v3
   1037  813e		       91 4b		      sta	(pokeybase),y
   1038  8140				   .L0101		;;  psound 3 , f4 , w4 , v4
   1039  8140
   1040  8140		       a0 06		      ldy	#6
   1041  8142		       ad 44 01 	      lda	f4
   1042  8145		       91 4b		      sta	(pokeybase),y
   1043  8147		       c8		      iny
   1044  8148		       ad 48 01 	      lda	w4
   1045  814b		       0a		      asl
   1046  814c		       0a		      asl
   1047  814d		       0a		      asl
   1048  814e		       0a		      asl
   1049  814f		       18		      clc
   1050  8150		       6d 4c 01 	      adc	v4
   1051  8153		       91 4b		      sta	(pokeybase),y
   1052  8155				   .
   1053  8155							;; 
   1054  8155
   1055  8155				   .L0102		;;  plotchars 'freq^^^wave^^vol' 5 55 2
   1056  8155
   1057  8155		       4c 68 81 	      JMP	skipalphadata0
   1058  8158				   alphadata0
   1059  8158		       0f		      .byte.b	(<font + $0f)
   1060  8159		       1b		      .byte.b	(<font + $1b)
   1061  815a		       0e		      .byte.b	(<font + $0e)
   1062  815b		       1a		      .byte.b	(<font + $1a)
   1063  815c		       34		      .byte.b	(<font + $34)
   1064  815d		       34		      .byte.b	(<font + $34)
   1065  815e		       34		      .byte.b	(<font + $34)
   1066  815f		       20		      .byte.b	(<font + $20)
   1067  8160		       0a		      .byte.b	(<font + $0a)
   1068  8161		       1f		      .byte.b	(<font + $1f)
   1069  8162		       0e		      .byte.b	(<font + $0e)
   1070  8163		       34		      .byte.b	(<font + $34)
   1071  8164		       34		      .byte.b	(<font + $34)
   1072  8165		       1f		      .byte.b	(<font + $1f)
   1073  8166		       18		      .byte.b	(<font + $18)
   1074  8167		       15		      .byte.b	(<font + $15)
   1075  8168				   skipalphadata0
   1076  8168		       a9 58		      lda	#<alphadata0
   1077  816a		       85 42		      sta	temp1
   1078  816c
   1079  816c		       a9 81		      lda	#>alphadata0
   1080  816e		       85 43		      sta	temp2
   1081  8170
   1082  8170		       a9 10		      lda	#16	; width in two's complement
   1083  8172		       09 a0		      ora	#160	; palette left shifted 5 bits
   1084  8174		       85 44		      sta	temp3
   1085  8176		       a9 37		      lda	#55
   1086  8178		       85 45		      sta	temp4
   1087  817a
   1088  817a		       a9 02		      lda	#2
   1089  817c
   1090  817c		       85 46		      sta	temp5
   1091  817e
   1092  817e		       20 9b f4 	      jsr	plotcharacters
   1093  8181				   .L0103		;;  plotchars 'channel^0' 1 10 3
   1094  8181
   1095  8181		       4c 8d 81 	      JMP	skipalphadata1
   1096  8184				   alphadata1
   1097  8184		       0c		      .byte.b	(<font + $0c)
   1098  8185		       11		      .byte.b	(<font + $11)
   1099  8186		       0a		      .byte.b	(<font + $0a)
   1100  8187		       17		      .byte.b	(<font + $17)
   1101  8188		       17		      .byte.b	(<font + $17)
   1102  8189		       0e		      .byte.b	(<font + $0e)
   1103  818a		       15		      .byte.b	(<font + $15)
   1104  818b		       34		      .byte.b	(<font + $34)
   1105  818c		       00		      .byte.b	(<font + $00)
   1106  818d				   skipalphadata1
   1107  818d		       a9 84		      lda	#<alphadata1
   1108  818f		       85 42		      sta	temp1
   1109  8191
   1110  8191		       a9 81		      lda	#>alphadata1
   1111  8193		       85 43		      sta	temp2
   1112  8195
   1113  8195		       a9 17		      lda	#23	; width in two's complement
   1114  8197		       09 20		      ora	#32	; palette left shifted 5 bits
   1115  8199		       85 44		      sta	temp3
   1116  819b		       a9 0a		      lda	#10
   1117  819d		       85 45		      sta	temp4
   1118  819f
   1119  819f		       a9 03		      lda	#3
   1120  81a1
   1121  81a1		       85 46		      sta	temp5
   1122  81a3
   1123  81a3		       20 9b f4 	      jsr	plotcharacters
   1124  81a6				   .L0104		;;  plotchars 'channel^1' 1 10 4
   1125  81a6
   1126  81a6		       4c b2 81 	      JMP	skipalphadata2
   1127  81a9				   alphadata2
   1128  81a9		       0c		      .byte.b	(<font + $0c)
   1129  81aa		       11		      .byte.b	(<font + $11)
   1130  81ab		       0a		      .byte.b	(<font + $0a)
   1131  81ac		       17		      .byte.b	(<font + $17)
   1132  81ad		       17		      .byte.b	(<font + $17)
   1133  81ae		       0e		      .byte.b	(<font + $0e)
   1134  81af		       15		      .byte.b	(<font + $15)
   1135  81b0		       34		      .byte.b	(<font + $34)
   1136  81b1		       01		      .byte.b	(<font + $01)
   1137  81b2				   skipalphadata2
   1138  81b2		       a9 a9		      lda	#<alphadata2
   1139  81b4		       85 42		      sta	temp1
   1140  81b6
   1141  81b6		       a9 81		      lda	#>alphadata2
   1142  81b8		       85 43		      sta	temp2
   1143  81ba
   1144  81ba		       a9 17		      lda	#23	; width in two's complement
   1145  81bc		       09 20		      ora	#32	; palette left shifted 5 bits
   1146  81be		       85 44		      sta	temp3
   1147  81c0		       a9 0a		      lda	#10
   1148  81c2		       85 45		      sta	temp4
   1149  81c4
   1150  81c4		       a9 04		      lda	#4
   1151  81c6
   1152  81c6		       85 46		      sta	temp5
   1153  81c8
   1154  81c8		       20 9b f4 	      jsr	plotcharacters
   1155  81cb				   .L0105		;;  plotchars 'channel^2' 1 10 5
   1156  81cb
   1157  81cb		       4c d7 81 	      JMP	skipalphadata3
   1158  81ce				   alphadata3
   1159  81ce		       0c		      .byte.b	(<font + $0c)
   1160  81cf		       11		      .byte.b	(<font + $11)
   1161  81d0		       0a		      .byte.b	(<font + $0a)
   1162  81d1		       17		      .byte.b	(<font + $17)
   1163  81d2		       17		      .byte.b	(<font + $17)
   1164  81d3		       0e		      .byte.b	(<font + $0e)
   1165  81d4		       15		      .byte.b	(<font + $15)
   1166  81d5		       34		      .byte.b	(<font + $34)
   1167  81d6		       02		      .byte.b	(<font + $02)
   1168  81d7				   skipalphadata3
   1169  81d7		       a9 ce		      lda	#<alphadata3
   1170  81d9		       85 42		      sta	temp1
   1171  81db
   1172  81db		       a9 81		      lda	#>alphadata3
   1173  81dd		       85 43		      sta	temp2
   1174  81df
   1175  81df		       a9 17		      lda	#23	; width in two's complement
   1176  81e1		       09 20		      ora	#32	; palette left shifted 5 bits
   1177  81e3		       85 44		      sta	temp3
   1178  81e5		       a9 0a		      lda	#10
   1179  81e7		       85 45		      sta	temp4
   1180  81e9
   1181  81e9		       a9 05		      lda	#5
   1182  81eb
   1183  81eb		       85 46		      sta	temp5
   1184  81ed
   1185  81ed		       20 9b f4 	      jsr	plotcharacters
   1186  81f0				   .L0106		;;  plotchars 'channel^3' 1 10 6
   1187  81f0
   1188  81f0		       4c fc 81 	      JMP	skipalphadata4
   1189  81f3				   alphadata4
   1190  81f3		       0c		      .byte.b	(<font + $0c)
   1191  81f4		       11		      .byte.b	(<font + $11)
   1192  81f5		       0a		      .byte.b	(<font + $0a)
   1193  81f6		       17		      .byte.b	(<font + $17)
   1194  81f7		       17		      .byte.b	(<font + $17)
   1195  81f8		       0e		      .byte.b	(<font + $0e)
   1196  81f9		       15		      .byte.b	(<font + $15)
   1197  81fa		       34		      .byte.b	(<font + $34)
   1198  81fb		       03		      .byte.b	(<font + $03)
   1199  81fc				   skipalphadata4
   1200  81fc		       a9 f3		      lda	#<alphadata4
   1201  81fe		       85 42		      sta	temp1
   1202  8200
   1203  8200		       a9 81		      lda	#>alphadata4
   1204  8202		       85 43		      sta	temp2
   1205  8204
   1206  8204		       a9 17		      lda	#23	; width in two's complement
   1207  8206		       09 20		      ora	#32	; palette left shifted 5 bits
   1208  8208		       85 44		      sta	temp3
   1209  820a		       a9 0a		      lda	#10
   1210  820c		       85 45		      sta	temp4
   1211  820e
   1212  820e		       a9 06		      lda	#6
   1213  8210
   1214  8210		       85 46		      sta	temp5
   1215  8212
   1216  8212		       20 9b f4 	      jsr	plotcharacters
   1217  8215				   .
   1218  8215							;; 
   1219  8215
   1220  8215				   .L0107		;;  if f1s then tColor  =  3
   1221  8215
   1222  8215		       ad 4d 01 	      LDA	f1s
   1223  8218		       f0 05		      BEQ	.skipL0107
   1224  821a				   .condpart0
   1225  821a		       a9 03		      LDA	#3
   1226  821c		       8d 59 01 	      STA	tColor
   1227  821f				   .skipL0107
   1228  821f				   .L0108		;;  if !f1s then tColor  =  4
   1229  821f
   1230  821f		       ad 4d 01 	      LDA	f1s
   1231  8222		       d0 05		      BNE	.skipL0108
   1232  8224				   .condpart1
   1233  8224		       a9 04		      LDA	#4
   1234  8226		       8d 59 01 	      STA	tColor
   1235  8229				   .skipL0108
   1236  8229				   .L0109		;;  plotvalue font tColor f1 2 60 3
   1237  8229
   1238  8229		       a9 00		      lda	#<font
   1239  822b		       85 42		      sta	temp1
   1240  822d
   1241  822d		       a9 a0		      lda	#>font
   1242  822f		       85 43		      sta	temp2
   1243  8231
   1244  8231		       ad 06 21 	      lda	charactermode
   1245  8234		       85 4a		      sta	temp9
   1246  8236		       a9 60		      lda	#(font_mode | %01100000)
   1247  8238		       8d 06 21 	      sta	charactermode
   1248  823b		       a9 1e		      lda	#30	; width in two's complement
   1249  823d		       85 44		      sta	temp3
   1250  823f		       ad 59 01 	      lda	tColor
   1251  8242		       0a		      asl
   1252  8243		       0a		      asl
   1253  8244		       0a		      asl
   1254  8245		       0a		      asl
   1255  8246		       0a		      asl
   1256  8247		       05 44		      ora	temp3
   1257  8249		       85 44		      sta	temp3
   1258  824b		       a9 3c		      lda	#60
   1259  824d		       85 45		      sta	temp4
   1260  824f
   1261  824f		       a9 03		      lda	#3
   1262  8251		       85 46		      sta	temp5
   1263  8253
   1264  8253		       a9 02		      lda	#2
   1265  8255		       85 47		      sta	temp6
   1266  8257
   1267  8257		       a9 41		      lda	#<f1
   1268  8259		       85 48		      sta	temp7
   1269  825b
   1270  825b		       a9 01		      lda	#>f1
   1271  825d		       85 49		      sta	temp8
   1272  825f
   1273  825f		       20 f7 f4 	      jsr	plotvalue
   1274  825f		       00 01	   USED_PLOTVALUE =	1
   1275  8262		       a5 4a		      lda	temp9
   1276  8264		       8d 06 21 	      sta	charactermode
   1277  8267				   .L0110		;;  plotvalue font 4 f2 2 60 4
   1278  8267
   1279  8267		       a9 00		      lda	#<font
   1280  8269		       85 42		      sta	temp1
   1281  826b
   1282  826b		       a9 a0		      lda	#>font
   1283  826d		       85 43		      sta	temp2
   1284  826f
   1285  826f		       ad 06 21 	      lda	charactermode
   1286  8272		       85 4a		      sta	temp9
   1287  8274		       a9 60		      lda	#(font_mode | %01100000)
   1288  8276		       8d 06 21 	      sta	charactermode
   1289  8279		       a9 1e		      lda	#30	; width in two's complement
   1290  827b		       09 80		      ora	#128	; palette left shifted 5 bits
   1291  827d		       85 44		      sta	temp3
   1292  827f		       a9 3c		      lda	#60
   1293  8281		       85 45		      sta	temp4
   1294  8283
   1295  8283		       a9 04		      lda	#4
   1296  8285		       85 46		      sta	temp5
   1297  8287
   1298  8287		       a9 02		      lda	#2
   1299  8289		       85 47		      sta	temp6
   1300  828b
   1301  828b		       a9 42		      lda	#<f2
   1302  828d		       85 48		      sta	temp7
   1303  828f
   1304  828f		       a9 01		      lda	#>f2
   1305  8291		       85 49		      sta	temp8
   1306  8293
   1307  8293		       20 f7 f4 	      jsr	plotvalue
   1308  8293		       00 01	   USED_PLOTVALUE =	1
   1309  8296		       a5 4a		      lda	temp9
   1310  8298		       8d 06 21 	      sta	charactermode
   1311  829b				   .L0111		;;  plotvalue font 4 f3 2 60 5
   1312  829b
   1313  829b		       a9 00		      lda	#<font
   1314  829d		       85 42		      sta	temp1
   1315  829f
   1316  829f		       a9 a0		      lda	#>font
   1317  82a1		       85 43		      sta	temp2
   1318  82a3
   1319  82a3		       ad 06 21 	      lda	charactermode
   1320  82a6		       85 4a		      sta	temp9
   1321  82a8		       a9 60		      lda	#(font_mode | %01100000)
   1322  82aa		       8d 06 21 	      sta	charactermode
   1323  82ad		       a9 1e		      lda	#30	; width in two's complement
   1324  82af		       09 80		      ora	#128	; palette left shifted 5 bits
   1325  82b1		       85 44		      sta	temp3
   1326  82b3		       a9 3c		      lda	#60
   1327  82b5		       85 45		      sta	temp4
   1328  82b7
   1329  82b7		       a9 05		      lda	#5
   1330  82b9		       85 46		      sta	temp5
   1331  82bb
   1332  82bb		       a9 02		      lda	#2
   1333  82bd		       85 47		      sta	temp6
   1334  82bf
   1335  82bf		       a9 43		      lda	#<f3
   1336  82c1		       85 48		      sta	temp7
   1337  82c3
   1338  82c3		       a9 01		      lda	#>f3
   1339  82c5		       85 49		      sta	temp8
   1340  82c7
   1341  82c7		       20 f7 f4 	      jsr	plotvalue
   1342  82c7		       00 01	   USED_PLOTVALUE =	1
   1343  82ca		       a5 4a		      lda	temp9
   1344  82cc		       8d 06 21 	      sta	charactermode
   1345  82cf				   .L0112		;;  plotvalue font 4 f4 2 60 6
   1346  82cf
   1347  82cf		       a9 00		      lda	#<font
   1348  82d1		       85 42		      sta	temp1
   1349  82d3
   1350  82d3		       a9 a0		      lda	#>font
   1351  82d5		       85 43		      sta	temp2
   1352  82d7
   1353  82d7		       ad 06 21 	      lda	charactermode
   1354  82da		       85 4a		      sta	temp9
   1355  82dc		       a9 60		      lda	#(font_mode | %01100000)
   1356  82de		       8d 06 21 	      sta	charactermode
   1357  82e1		       a9 1e		      lda	#30	; width in two's complement
   1358  82e3		       09 80		      ora	#128	; palette left shifted 5 bits
   1359  82e5		       85 44		      sta	temp3
   1360  82e7		       a9 3c		      lda	#60
   1361  82e9		       85 45		      sta	temp4
   1362  82eb
   1363  82eb		       a9 06		      lda	#6
   1364  82ed		       85 46		      sta	temp5
   1365  82ef
   1366  82ef		       a9 02		      lda	#2
   1367  82f1		       85 47		      sta	temp6
   1368  82f3
   1369  82f3		       a9 44		      lda	#<f4
   1370  82f5		       85 48		      sta	temp7
   1371  82f7
   1372  82f7		       a9 01		      lda	#>f4
   1373  82f9		       85 49		      sta	temp8
   1374  82fb
   1375  82fb		       20 f7 f4 	      jsr	plotvalue
   1376  82fb		       00 01	   USED_PLOTVALUE =	1
   1377  82fe		       a5 4a		      lda	temp9
   1378  8300		       8d 06 21 	      sta	charactermode
   1379  8303				   .
   1380  8303							;; 
   1381  8303
   1382  8303				   .L0113		;;  if w1s then tColor  =  3
   1383  8303
   1384  8303		       ad 51 01 	      LDA	w1s
   1385  8306		       f0 05		      BEQ	.skipL0113
   1386  8308				   .condpart2
   1387  8308		       a9 03		      LDA	#3
   1388  830a		       8d 59 01 	      STA	tColor
   1389  830d				   .skipL0113
   1390  830d				   .L0114		;;  if !w1s then tColor  =  4
   1391  830d
   1392  830d		       ad 51 01 	      LDA	w1s
   1393  8310		       d0 05		      BNE	.skipL0114
   1394  8312				   .condpart3
   1395  8312		       a9 04		      LDA	#4
   1396  8314		       8d 59 01 	      STA	tColor
   1397  8317				   .skipL0114
   1398  8317				   .L0115		;;  plotvalue font tColor w1 2 85 3
   1399  8317
   1400  8317		       a9 00		      lda	#<font
   1401  8319		       85 42		      sta	temp1
   1402  831b
   1403  831b		       a9 a0		      lda	#>font
   1404  831d		       85 43		      sta	temp2
   1405  831f
   1406  831f		       ad 06 21 	      lda	charactermode
   1407  8322		       85 4a		      sta	temp9
   1408  8324		       a9 60		      lda	#(font_mode | %01100000)
   1409  8326		       8d 06 21 	      sta	charactermode
   1410  8329		       a9 1e		      lda	#30	; width in two's complement
   1411  832b		       85 44		      sta	temp3
   1412  832d		       ad 59 01 	      lda	tColor
   1413  8330		       0a		      asl
   1414  8331		       0a		      asl
   1415  8332		       0a		      asl
   1416  8333		       0a		      asl
   1417  8334		       0a		      asl
   1418  8335		       05 44		      ora	temp3
   1419  8337		       85 44		      sta	temp3
   1420  8339		       a9 55		      lda	#85
   1421  833b		       85 45		      sta	temp4
   1422  833d
   1423  833d		       a9 03		      lda	#3
   1424  833f		       85 46		      sta	temp5
   1425  8341
   1426  8341		       a9 02		      lda	#2
   1427  8343		       85 47		      sta	temp6
   1428  8345
   1429  8345		       a9 45		      lda	#<w1
   1430  8347		       85 48		      sta	temp7
   1431  8349
   1432  8349		       a9 01		      lda	#>w1
   1433  834b		       85 49		      sta	temp8
   1434  834d
   1435  834d		       20 f7 f4 	      jsr	plotvalue
   1436  834d		       00 01	   USED_PLOTVALUE =	1
   1437  8350		       a5 4a		      lda	temp9
   1438  8352		       8d 06 21 	      sta	charactermode
   1439  8355				   .L0116		;;  plotvalue font 4 w2 2 85 4
   1440  8355
   1441  8355		       a9 00		      lda	#<font
   1442  8357		       85 42		      sta	temp1
   1443  8359
   1444  8359		       a9 a0		      lda	#>font
   1445  835b		       85 43		      sta	temp2
   1446  835d
   1447  835d		       ad 06 21 	      lda	charactermode
   1448  8360		       85 4a		      sta	temp9
   1449  8362		       a9 60		      lda	#(font_mode | %01100000)
   1450  8364		       8d 06 21 	      sta	charactermode
   1451  8367		       a9 1e		      lda	#30	; width in two's complement
   1452  8369		       09 80		      ora	#128	; palette left shifted 5 bits
   1453  836b		       85 44		      sta	temp3
   1454  836d		       a9 55		      lda	#85
   1455  836f		       85 45		      sta	temp4
   1456  8371
   1457  8371		       a9 04		      lda	#4
   1458  8373		       85 46		      sta	temp5
   1459  8375
   1460  8375		       a9 02		      lda	#2
   1461  8377		       85 47		      sta	temp6
   1462  8379
   1463  8379		       a9 46		      lda	#<w2
   1464  837b		       85 48		      sta	temp7
   1465  837d
   1466  837d		       a9 01		      lda	#>w2
   1467  837f		       85 49		      sta	temp8
   1468  8381
   1469  8381		       20 f7 f4 	      jsr	plotvalue
   1470  8381		       00 01	   USED_PLOTVALUE =	1
   1471  8384		       a5 4a		      lda	temp9
   1472  8386		       8d 06 21 	      sta	charactermode
   1473  8389				   .L0117		;;  plotvalue font 4 w3 2 85 5
   1474  8389
   1475  8389		       a9 00		      lda	#<font
   1476  838b		       85 42		      sta	temp1
   1477  838d
   1478  838d		       a9 a0		      lda	#>font
   1479  838f		       85 43		      sta	temp2
   1480  8391
   1481  8391		       ad 06 21 	      lda	charactermode
   1482  8394		       85 4a		      sta	temp9
   1483  8396		       a9 60		      lda	#(font_mode | %01100000)
   1484  8398		       8d 06 21 	      sta	charactermode
   1485  839b		       a9 1e		      lda	#30	; width in two's complement
   1486  839d		       09 80		      ora	#128	; palette left shifted 5 bits
   1487  839f		       85 44		      sta	temp3
   1488  83a1		       a9 55		      lda	#85
   1489  83a3		       85 45		      sta	temp4
   1490  83a5
   1491  83a5		       a9 05		      lda	#5
   1492  83a7		       85 46		      sta	temp5
   1493  83a9
   1494  83a9		       a9 02		      lda	#2
   1495  83ab		       85 47		      sta	temp6
   1496  83ad
   1497  83ad		       a9 47		      lda	#<w3
   1498  83af		       85 48		      sta	temp7
   1499  83b1
   1500  83b1		       a9 01		      lda	#>w3
   1501  83b3		       85 49		      sta	temp8
   1502  83b5
   1503  83b5		       20 f7 f4 	      jsr	plotvalue
   1504  83b5		       00 01	   USED_PLOTVALUE =	1
   1505  83b8		       a5 4a		      lda	temp9
   1506  83ba		       8d 06 21 	      sta	charactermode
   1507  83bd				   .L0118		;;  plotvalue font 4 w4 2 85 6
   1508  83bd
   1509  83bd		       a9 00		      lda	#<font
   1510  83bf		       85 42		      sta	temp1
   1511  83c1
   1512  83c1		       a9 a0		      lda	#>font
   1513  83c3		       85 43		      sta	temp2
   1514  83c5
   1515  83c5		       ad 06 21 	      lda	charactermode
   1516  83c8		       85 4a		      sta	temp9
   1517  83ca		       a9 60		      lda	#(font_mode | %01100000)
   1518  83cc		       8d 06 21 	      sta	charactermode
   1519  83cf		       a9 1e		      lda	#30	; width in two's complement
   1520  83d1		       09 80		      ora	#128	; palette left shifted 5 bits
   1521  83d3		       85 44		      sta	temp3
   1522  83d5		       a9 55		      lda	#85
   1523  83d7		       85 45		      sta	temp4
   1524  83d9
   1525  83d9		       a9 06		      lda	#6
   1526  83db		       85 46		      sta	temp5
   1527  83dd
   1528  83dd		       a9 02		      lda	#2
   1529  83df		       85 47		      sta	temp6
   1530  83e1
   1531  83e1		       a9 48		      lda	#<w4
   1532  83e3		       85 48		      sta	temp7
   1533  83e5
   1534  83e5		       a9 01		      lda	#>w4
   1535  83e7		       85 49		      sta	temp8
   1536  83e9
   1537  83e9		       20 f7 f4 	      jsr	plotvalue
   1538  83e9		       00 01	   USED_PLOTVALUE =	1
   1539  83ec		       a5 4a		      lda	temp9
   1540  83ee		       8d 06 21 	      sta	charactermode
   1541  83f1				   .
   1542  83f1							;; 
   1543  83f1
   1544  83f1				   .L0119		;;  if v1s then tColor  =  3
   1545  83f1
   1546  83f1		       ad 55 01 	      LDA	v1s
   1547  83f4		       f0 05		      BEQ	.skipL0119
   1548  83f6				   .condpart4
   1549  83f6		       a9 03		      LDA	#3
   1550  83f8		       8d 59 01 	      STA	tColor
   1551  83fb				   .skipL0119
   1552  83fb				   .L0120		;;  if !v1s then tColor  =  4
   1553  83fb
   1554  83fb		       ad 55 01 	      LDA	v1s
   1555  83fe		       d0 05		      BNE	.skipL0120
   1556  8400				   .condpart5
   1557  8400		       a9 04		      LDA	#4
   1558  8402		       8d 59 01 	      STA	tColor
   1559  8405				   .skipL0120
   1560  8405				   .L0121		;;  plotvalue font tColor v1 2 110 3
   1561  8405
   1562  8405		       a9 00		      lda	#<font
   1563  8407		       85 42		      sta	temp1
   1564  8409
   1565  8409		       a9 a0		      lda	#>font
   1566  840b		       85 43		      sta	temp2
   1567  840d
   1568  840d		       ad 06 21 	      lda	charactermode
   1569  8410		       85 4a		      sta	temp9
   1570  8412		       a9 60		      lda	#(font_mode | %01100000)
   1571  8414		       8d 06 21 	      sta	charactermode
   1572  8417		       a9 1e		      lda	#30	; width in two's complement
   1573  8419		       85 44		      sta	temp3
   1574  841b		       ad 59 01 	      lda	tColor
   1575  841e		       0a		      asl
   1576  841f		       0a		      asl
   1577  8420		       0a		      asl
   1578  8421		       0a		      asl
   1579  8422		       0a		      asl
   1580  8423		       05 44		      ora	temp3
   1581  8425		       85 44		      sta	temp3
   1582  8427		       a9 6e		      lda	#110
   1583  8429		       85 45		      sta	temp4
   1584  842b
   1585  842b		       a9 03		      lda	#3
   1586  842d		       85 46		      sta	temp5
   1587  842f
   1588  842f		       a9 02		      lda	#2
   1589  8431		       85 47		      sta	temp6
   1590  8433
   1591  8433		       a9 49		      lda	#<v1
   1592  8435		       85 48		      sta	temp7
   1593  8437
   1594  8437		       a9 01		      lda	#>v1
   1595  8439		       85 49		      sta	temp8
   1596  843b
   1597  843b		       20 f7 f4 	      jsr	plotvalue
   1598  843b		       00 01	   USED_PLOTVALUE =	1
   1599  843e		       a5 4a		      lda	temp9
   1600  8440		       8d 06 21 	      sta	charactermode
   1601  8443				   .L0122		;;  plotvalue font 4 v2 2 110 4
   1602  8443
   1603  8443		       a9 00		      lda	#<font
   1604  8445		       85 42		      sta	temp1
   1605  8447
   1606  8447		       a9 a0		      lda	#>font
   1607  8449		       85 43		      sta	temp2
   1608  844b
   1609  844b		       ad 06 21 	      lda	charactermode
   1610  844e		       85 4a		      sta	temp9
   1611  8450		       a9 60		      lda	#(font_mode | %01100000)
   1612  8452		       8d 06 21 	      sta	charactermode
   1613  8455		       a9 1e		      lda	#30	; width in two's complement
   1614  8457		       09 80		      ora	#128	; palette left shifted 5 bits
   1615  8459		       85 44		      sta	temp3
   1616  845b		       a9 6e		      lda	#110
   1617  845d		       85 45		      sta	temp4
   1618  845f
   1619  845f		       a9 04		      lda	#4
   1620  8461		       85 46		      sta	temp5
   1621  8463
   1622  8463		       a9 02		      lda	#2
   1623  8465		       85 47		      sta	temp6
   1624  8467
   1625  8467		       a9 4a		      lda	#<v2
   1626  8469		       85 48		      sta	temp7
   1627  846b
   1628  846b		       a9 01		      lda	#>v2
   1629  846d		       85 49		      sta	temp8
   1630  846f
   1631  846f		       20 f7 f4 	      jsr	plotvalue
   1632  846f		       00 01	   USED_PLOTVALUE =	1
   1633  8472		       a5 4a		      lda	temp9
   1634  8474		       8d 06 21 	      sta	charactermode
   1635  8477				   .L0123		;;  plotvalue font 4 v3 2 110 5
   1636  8477
   1637  8477		       a9 00		      lda	#<font
   1638  8479		       85 42		      sta	temp1
   1639  847b
   1640  847b		       a9 a0		      lda	#>font
   1641  847d		       85 43		      sta	temp2
   1642  847f
   1643  847f		       ad 06 21 	      lda	charactermode
   1644  8482		       85 4a		      sta	temp9
   1645  8484		       a9 60		      lda	#(font_mode | %01100000)
   1646  8486		       8d 06 21 	      sta	charactermode
   1647  8489		       a9 1e		      lda	#30	; width in two's complement
   1648  848b		       09 80		      ora	#128	; palette left shifted 5 bits
   1649  848d		       85 44		      sta	temp3
   1650  848f		       a9 6e		      lda	#110
   1651  8491		       85 45		      sta	temp4
   1652  8493
   1653  8493		       a9 05		      lda	#5
   1654  8495		       85 46		      sta	temp5
   1655  8497
   1656  8497		       a9 02		      lda	#2
   1657  8499		       85 47		      sta	temp6
   1658  849b
   1659  849b		       a9 4b		      lda	#<v3
   1660  849d		       85 48		      sta	temp7
   1661  849f
   1662  849f		       a9 01		      lda	#>v3
   1663  84a1		       85 49		      sta	temp8
   1664  84a3
   1665  84a3		       20 f7 f4 	      jsr	plotvalue
   1666  84a3		       00 01	   USED_PLOTVALUE =	1
   1667  84a6		       a5 4a		      lda	temp9
   1668  84a8		       8d 06 21 	      sta	charactermode
   1669  84ab				   .L0124		;;  plotvalue font 4 v4 2 110 6
   1670  84ab
   1671  84ab		       a9 00		      lda	#<font
   1672  84ad		       85 42		      sta	temp1
   1673  84af
   1674  84af		       a9 a0		      lda	#>font
   1675  84b1		       85 43		      sta	temp2
   1676  84b3
   1677  84b3		       ad 06 21 	      lda	charactermode
   1678  84b6		       85 4a		      sta	temp9
   1679  84b8		       a9 60		      lda	#(font_mode | %01100000)
   1680  84ba		       8d 06 21 	      sta	charactermode
   1681  84bd		       a9 1e		      lda	#30	; width in two's complement
   1682  84bf		       09 80		      ora	#128	; palette left shifted 5 bits
   1683  84c1		       85 44		      sta	temp3
   1684  84c3		       a9 6e		      lda	#110
   1685  84c5		       85 45		      sta	temp4
   1686  84c7
   1687  84c7		       a9 06		      lda	#6
   1688  84c9		       85 46		      sta	temp5
   1689  84cb
   1690  84cb		       a9 02		      lda	#2
   1691  84cd		       85 47		      sta	temp6
   1692  84cf
   1693  84cf		       a9 4c		      lda	#<v4
   1694  84d1		       85 48		      sta	temp7
   1695  84d3
   1696  84d3		       a9 01		      lda	#>v4
   1697  84d5		       85 49		      sta	temp8
   1698  84d7
   1699  84d7		       20 f7 f4 	      jsr	plotvalue
   1700  84d7		       00 01	   USED_PLOTVALUE =	1
   1701  84da		       a5 4a		      lda	temp9
   1702  84dc		       8d 06 21 	      sta	charactermode
   1703  84df				   .
   1704  84df							;; 
   1705  84df
   1706  84df				   .L0125		;;  if fireWait  <  fireWaitMax then goto _skipInput
   1707  84df
   1708  84df		       ad 5a 01 	      LDA	fireWait
   1709  84e2		       cd 5b 01 	      CMP	fireWaitMax
   1710  84e5		       b0 03		      BCS	.skipL0125
   1711  84e7				   .condpart6
   1712  84e7		       4c 03 86 	      jmp	._skipInput
   1713  84ea
   1714  84ea				   .skipL0125
   1715  84ea				   .L0126		;;  fireWait  =  0
   1716  84ea
   1717  84ea		       a9 00		      LDA	#0
   1718  84ec		       8d 5a 01 	      STA	fireWait
   1719  84ef				   .L0127		;;  if joy0fire1  &&  f1s then f1  =  f1  +  1
   1720  84ef
   1721  84ef		       2c 02 21 	      bit	sINPT1
   1722  84f2		       10 0e		      BPL	.skipL0127
   1723  84f4				   .condpart7
   1724  84f4		       ad 4d 01 	      LDA	f1s
   1725  84f7		       f0 09		      BEQ	.skip7then
   1726  84f9				   .condpart8
   1727  84f9		       ad 41 01 	      LDA	f1
   1728  84fc		       18		      CLC
   1729  84fd		       69 01		      ADC	#1
   1730  84ff		       8d 41 01 	      STA	f1
   1731  8502				   .skip7then
   1732  8502				   .skipL0127
   1733  8502				   .L0128		;;  if joy0fire0  &&  f1s then f1  =  f1  -  1
   1734  8502
   1735  8502		       2c 02 21 	      bit	sINPT1
   1736  8505		       50 0e		      BVC	.skipL0128
   1737  8507				   .condpart9
   1738  8507		       ad 4d 01 	      LDA	f1s
   1739  850a		       f0 09		      BEQ	.skip9then
   1740  850c				   .condpart10
   1741  850c		       ad 41 01 	      LDA	f1
   1742  850f		       38		      SEC
   1743  8510		       e9 01		      SBC	#1
   1744  8512		       8d 41 01 	      STA	f1
   1745  8515				   .skip9then
   1746  8515				   .skipL0128
   1747  8515				   .L0129		;;  if joy0fire1  &&  w1s then w1  =  w1  +  1
   1748  8515
   1749  8515		       2c 02 21 	      bit	sINPT1
   1750  8518		       10 0e		      BPL	.skipL0129
   1751  851a				   .condpart11
   1752  851a		       ad 51 01 	      LDA	w1s
   1753  851d		       f0 09		      BEQ	.skip11then
   1754  851f				   .condpart12
   1755  851f		       ad 45 01 	      LDA	w1
   1756  8522		       18		      CLC
   1757  8523		       69 01		      ADC	#1
   1758  8525		       8d 45 01 	      STA	w1
   1759  8528				   .skip11then
   1760  8528				   .skipL0129
   1761  8528				   .L0130		;;  if joy0fire0  &&  w1s then w1  =  w1  -  1
   1762  8528
   1763  8528		       2c 02 21 	      bit	sINPT1
   1764  852b		       50 0e		      BVC	.skipL0130
   1765  852d				   .condpart13
   1766  852d		       ad 51 01 	      LDA	w1s
   1767  8530		       f0 09		      BEQ	.skip13then
   1768  8532				   .condpart14
   1769  8532		       ad 45 01 	      LDA	w1
   1770  8535		       38		      SEC
   1771  8536		       e9 01		      SBC	#1
   1772  8538		       8d 45 01 	      STA	w1
   1773  853b				   .skip13then
   1774  853b				   .skipL0130
   1775  853b				   .L0131		;;  if joy0fire1  &&  v1s then v1  =  v1  +  1
   1776  853b
   1777  853b		       2c 02 21 	      bit	sINPT1
   1778  853e		       10 0e		      BPL	.skipL0131
   1779  8540				   .condpart15
   1780  8540		       ad 55 01 	      LDA	v1s
   1781  8543		       f0 09		      BEQ	.skip15then
   1782  8545				   .condpart16
   1783  8545		       ad 49 01 	      LDA	v1
   1784  8548		       18		      CLC
   1785  8549		       69 01		      ADC	#1
   1786  854b		       8d 49 01 	      STA	v1
   1787  854e				   .skip15then
   1788  854e				   .skipL0131
   1789  854e				   .L0132		;;  if joy0fire0  &&  v1s then v1  =  v1  -  1
   1790  854e
   1791  854e		       2c 02 21 	      bit	sINPT1
   1792  8551		       50 0e		      BVC	.skipL0132
   1793  8553				   .condpart17
   1794  8553		       ad 55 01 	      LDA	v1s
   1795  8556		       f0 09		      BEQ	.skip17then
   1796  8558				   .condpart18
   1797  8558		       ad 49 01 	      LDA	v1
   1798  855b		       38		      SEC
   1799  855c		       e9 01		      SBC	#1
   1800  855e		       8d 49 01 	      STA	v1
   1801  8561				   .skip17then
   1802  8561				   .skipL0132
   1803  8561				   .L0133		;;  if v1  >  15 then v1  =  0
   1804  8561
   1805  8561		       a9 0f		      LDA	#15
   1806  8563		       cd 49 01 	      CMP	v1
   1807  8566		       b0 05		      BCS	.skipL0133
   1808  8568				   .condpart19
   1809  8568		       a9 00		      LDA	#0
   1810  856a		       8d 49 01 	      STA	v1
   1811  856d				   .skipL0133
   1812  856d				   .L0134		;;  if w1  >  15 then w1  =  0
   1813  856d
   1814  856d		       a9 0f		      LDA	#15
   1815  856f		       cd 45 01 	      CMP	w1
   1816  8572		       b0 05		      BCS	.skipL0134
   1817  8574				   .condpart20
   1818  8574		       a9 00		      LDA	#0
   1819  8576		       8d 45 01 	      STA	w1
   1820  8579				   .skipL0134
   1821  8579				   .L0135		;;  if joy0left  &&  f1s then f1s  =  0  :  v1s  =  1	:  goto _skipInput
   1822  8579
   1823  8579		       2c 80 02 	      bit	SWCHA
   1824  857c		       70 12		      BVS	.skipL0135
   1825  857e				   .condpart21
   1826  857e		       ad 4d 01 	      LDA	f1s
   1827  8581		       f0 0d		      BEQ	.skip21then
   1828  8583				   .condpart22
   1829  8583		       a9 00		      LDA	#0
   1830  8585		       8d 4d 01 	      STA	f1s
   1831  8588		       a9 01		      LDA	#1
   1832  858a		       8d 55 01 	      STA	v1s
   1833  858d		       4c 03 86 	      jmp	._skipInput
   1834  8590
   1835  8590				   .skip21then
   1836  8590				   .skipL0135
   1837  8590				   .L0136		;;  if joy0right  &&  f1s then f1s  = 0  :  w1s  =  1	:  goto _skipInput
   1838  8590
   1839  8590		       2c 80 02 	      bit	SWCHA
   1840  8593		       30 12		      BMI	.skipL0136
   1841  8595				   .condpart23
   1842  8595		       ad 4d 01 	      LDA	f1s
   1843  8598		       f0 0d		      BEQ	.skip23then
   1844  859a				   .condpart24
   1845  859a		       a9 00		      LDA	#0
   1846  859c		       8d 4d 01 	      STA	f1s
   1847  859f		       a9 01		      LDA	#1
   1848  85a1		       8d 51 01 	      STA	w1s
   1849  85a4		       4c 03 86 	      jmp	._skipInput
   1850  85a7
   1851  85a7				   .skip23then
   1852  85a7				   .skipL0136
   1853  85a7				   .L0137		;;  if joy0left  &&  w1s then w1s  =  0  : f1s  =  1  :  goto _skipInput
   1854  85a7
   1855  85a7		       2c 80 02 	      bit	SWCHA
   1856  85aa		       70 12		      BVS	.skipL0137
   1857  85ac				   .condpart25
   1858  85ac		       ad 51 01 	      LDA	w1s
   1859  85af		       f0 0d		      BEQ	.skip25then
   1860  85b1				   .condpart26
   1861  85b1		       a9 00		      LDA	#0
   1862  85b3		       8d 51 01 	      STA	w1s
   1863  85b6		       a9 01		      LDA	#1
   1864  85b8		       8d 4d 01 	      STA	f1s
   1865  85bb		       4c 03 86 	      jmp	._skipInput
   1866  85be
   1867  85be				   .skip25then
   1868  85be				   .skipL0137
   1869  85be				   .L0138		;;  if joy0right  &&  w1s then w1s  = 0  : v1s  =  1  :  goto _skipInput
   1870  85be
   1871  85be		       2c 80 02 	      bit	SWCHA
   1872  85c1		       30 12		      BMI	.skipL0138
   1873  85c3				   .condpart27
   1874  85c3		       ad 51 01 	      LDA	w1s
   1875  85c6		       f0 0d		      BEQ	.skip27then
   1876  85c8				   .condpart28
   1877  85c8		       a9 00		      LDA	#0
   1878  85ca		       8d 51 01 	      STA	w1s
   1879  85cd		       a9 01		      LDA	#1
   1880  85cf		       8d 55 01 	      STA	v1s
   1881  85d2		       4c 03 86 	      jmp	._skipInput
   1882  85d5
   1883  85d5				   .skip27then
   1884  85d5				   .skipL0138
   1885  85d5				   .L0139		;;  if joy0left  &&  v1s then v1s  =  0  : w1s  =  1  :  goto _skipInput
   1886  85d5
   1887  85d5		       2c 80 02 	      bit	SWCHA
   1888  85d8		       70 12		      BVS	.skipL0139
   1889  85da				   .condpart29
   1890  85da		       ad 55 01 	      LDA	v1s
   1891  85dd		       f0 0d		      BEQ	.skip29then
   1892  85df				   .condpart30
   1893  85df		       a9 00		      LDA	#0
   1894  85e1		       8d 55 01 	      STA	v1s
   1895  85e4		       a9 01		      LDA	#1
   1896  85e6		       8d 51 01 	      STA	w1s
   1897  85e9		       4c 03 86 	      jmp	._skipInput
   1898  85ec
   1899  85ec				   .skip29then
   1900  85ec				   .skipL0139
   1901  85ec				   .L0140		;;  if joy0right  &&  v1s then v1s  = 0  : f1s  =  1  :  goto _skipInput
   1902  85ec
   1903  85ec		       2c 80 02 	      bit	SWCHA
   1904  85ef		       30 12		      BMI	.skipL0140
   1905  85f1				   .condpart31
   1906  85f1		       ad 55 01 	      LDA	v1s
   1907  85f4		       f0 0d		      BEQ	.skip31then
   1908  85f6				   .condpart32
   1909  85f6		       a9 00		      LDA	#0
   1910  85f8		       8d 55 01 	      STA	v1s
   1911  85fb		       a9 01		      LDA	#1
   1912  85fd		       8d 4d 01 	      STA	f1s
   1913  8600		       4c 03 86 	      jmp	._skipInput
   1914  8603
   1915  8603				   .skip31then
   1916  8603				   .skipL0140
   1917  8603				   ._skipInput
   1918  8603							;; _skipInput
   1919  8603
   1920  8603				   .L0141		;;  fireWait  =  fireWait  +  1
   1921  8603
   1922  8603		       ad 5a 01 	      LDA	fireWait
   1923  8606		       18		      CLC
   1924  8607		       69 01		      ADC	#1
   1925  8609		       8d 5a 01 	      STA	fireWait
   1926  860c				   .L0142		;;  if fireWait  >=  fireWaitMax then fireWait  =  fireWaitMax  +  1
   1927  860c
   1928  860c		       ad 5a 01 	      LDA	fireWait
   1929  860f		       cd 5b 01 	      CMP	fireWaitMax
   1930  8612		       90 09		      BCC	.skipL0142
   1931  8614				   .condpart33
   1932  8614		       ad 5b 01 	      LDA	fireWaitMax
   1933  8617		       18		      CLC
   1934  8618		       69 01		      ADC	#1
   1935  861a		       8d 5a 01 	      STA	fireWait
   1936  861d				   .skipL0142
   1937  861d				   .
   1938  861d							;; 
   1939  861d
   1940  861d				   .L0143		;;  drawscreen
   1941  861d
   1942  861d		       20 fa f1 	      jsr	drawscreen
   1943  8620				   .
   1944  8620							;; 
   1945  8620
   1946  8620				   .
   1947  8620							;; 
   1948  8620
   1949  8620				   .L0144		;;  goto mainScreen
   1950  8620		       4c fe 80 	      jmp	.mainScreen
   1951  8620				   DMAHOLEEND0 SET	.
   1952  8623				   gameend
   1953  8623				   DMAHOLEEND0 SET	.
   6621 bytes of ROM space left in the main area of bank 1.
   1954  8623					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   1955  8623				  -	      if	($A000 - .) < 0
   1956  8623				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   1957  8623					      endif
   1958  8623
   1959  a000					      ORG	$A000,0	; *************
   1960  a000
   1961  a000					      RORG	$A000	; *************
   1962  a000
   1963  a000				   font
   1964  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1965  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1966  a035
   1967  a100					      ORG	$A100,0	; *************
   1968  a100
   1969  a100					      RORG	$A100	; *************
   1970  a100
   1971  a100							;font
   1972  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1973  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1974  a135
   1975  a200					      ORG	$A200,0	; *************
   1976  a200
   1977  a200					      RORG	$A200	; *************
   1978  a200
   1979  a200							;font
   1980  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1981  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1982  a235
   1983  a300					      ORG	$A300,0	; *************
   1984  a300
   1985  a300					      RORG	$A300	; *************
   1986  a300
   1987  a300							;font
   1988  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1989  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1990  a335
   1991  a400					      ORG	$A400,0	; *************
   1992  a400
   1993  a400					      RORG	$A400	; *************
   1994  a400
   1995  a400							;font
   1996  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   1997  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   1998  a435
   1999  a500					      ORG	$A500,0	; *************
   2000  a500
   2001  a500					      RORG	$A500	; *************
   2002  a500
   2003  a500							;font
   2004  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2005  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2006  a535
   2007  a600					      ORG	$A600,0	; *************
   2008  a600
   2009  a600					      RORG	$A600	; *************
   2010  a600
   2011  a600							;font
   2012  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2013  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2014  a635
   2015  a700					      ORG	$A700,0	; *************
   2016  a700
   2017  a700					      RORG	$A700	; *************
   2018  a700
   2019  a700							;font
   2020  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2021  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2022  a735
   2023  a800					      ORG	$A800,0	; *************
   2024  a800
   2025  a800					      RORG	$A800	; *************
   2026  a800
   2027  a800							;font
   2028  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2029  a820		       00 00 00 00*	      HEX	000000000000000000008000a80000000000000000
   2030  a835
   2031  a900					      ORG	$A900,0	; *************
   2032  a900
   2033  a900					      RORG	$A900	; *************
   2034  a900
   2035  a900							;font
   2036  a900		       a8 a8 a8 a8*	      HEX	a8a8a8a808a8a820a8a888a0a8a0a880a888a8a888a88888a8800888a820a820
   2037  a920		       88 88 20 a8*	      HEX	888820a88000202080202000000880a8a8282a8000
   2038  a935
   2039  aa00					      ORG	$AA00,0	; *************
   2040  aa00
   2041  aa00					      RORG	$AA00	; *************
   2042  aa00
   2043  aa00							;font
   2044  aa00		       88 20 80 08*	      HEX	8820800808888820880888888088808088882088888088888880a088082088a8
   2045  aa20		       a8 88 20 80*	      HEX	a8882080a000000080000000002020800882802000
   2046  aa35
   2047  ab00					      ORG	$AB00,0	; *************
   2048  ab00
   2049  ab00					      RORG	$AB00	; *************
   2050  ab00
   2051  ab00							;font
   2052  ab00		       88 20 80 08*	      HEX	88208008080888208808a8888088808088882008a080888888a888a008208888
   2053  ab20		       a8 a8 20 80*	      HEX	a8a82080a8002020200000000080088008828a2000
   2054  ab35
   2055  ac00					      ORG	$AC00,0	; *************
   2056  ac00
   2057  ac00					      RORG	$AC00	; *************
   2058  ac00
   2059  ac00							;font
   2060  ac00		       88 20 a8 28*	      HEX	8820a828a808a820a8a888a08088a0a088a82008a080a88888888888a8208888
   2061  ac20		       88 20 20 a0*	      HEX	882020a0aa002020200000a8008008800828882000
   2062  ac35
   2063  ad00					      ORG	$AD00,0	; *************
   2064  ad00
   2065  ad00					      RORG	$AD00	; *************
   2066  ad00
   2067  ad00							;font
   2068  ad00		       88 20 08 08*	      HEX	8820080888a880088888888880888080808820088880a8888888888880208888
   2069  ad20		       88 a8 88 28*	      HEX	88a88828a8000820200000000080088008888a2000
   2070  ad35
   2071  ae00					      ORG	$AE00,0	; *************
   2072  ae00
   2073  ae00					      RORG	$AE00	; *************
   2074  ae00
   2075  ae00							;font
   2076  ae00		       88 a0 08 08*	      HEX	88a00808888080888888888880888080808820088880a8888888888880208888
   2077  ae20		       88 88 88 08*	      HEX	88888808a088882008000000002020800888802000
   2078  ae35
   2079  af00					      ORG	$AF00,0	; *************
   2080  af00
   2081  af00					      RORG	$AF00	; *************
   2082  af00
   2083  af00							;font
   2084  af00		       a8 20 a8 a8*	      HEX	a820a8a888a8a8a8a8a8a8a0a8a0a8a8a888a808888088a8a8a8a8a8a8a88888
   2085  af20		       88 88 88 a8*	      HEX	888888a88088a82008000000000880a8a8202a8000
   2086  af35
   2087  b000					      ORG	$B000,0	; *************
   2088  b000
   2089  b000					      RORG	$B000	; *************
   2090  b000				  -	      if	SPACEOVERFLOW > 0
   2091  b000				  -	      echo	""
   2092  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   2093  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   2094  b000				  -	      echo	"######## Aborting assembly."
   2095  b000				  -	      ERR
   2096  b000					      endif
   2097  b000
   2098  b000
   2099  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2100  b000
   2101  b000				  -	      ifnconst	bankswitchmode
   2102  b000				  -	      if	( * < $f000 )
   2103  b000				  -	      ORG	$F000
   2104  b000				  -	      endif
   2105  b000					      else
   2106  b000					      ifconst	ROM128K
   2107  b000					      if	( * < $f000 )
   2108  27000					       ORG	$27000
   2109  27000					       RORG	$F000
   2110  27000					       endif
   2111  27000					       endif
   2112  27000				   -	       ifconst	ROM144K
   2113  27000				   -	       if	( * < $f000 )
   2114  27000				   -	       ORG	$27000
   2115  27000				   -	       RORG	$F000
   2116  27000				   -	       endif
   2117  27000					       endif
   2118  27000				   -	       ifconst	ROM256K
   2119  27000				   -	       if	( * < $f000 )
   2120  27000				   -	       ORG	$47000
   2121  27000				   -	       RORG	$F000
   2122  27000				   -	       endif
   2123  27000					       endif
   2124  27000				   -	       ifconst	ROM272K
   2125  27000				   -	       if	( * < $f000 )
   2126  27000				   -	       ORG	$47000
   2127  27000				   -	       RORG	$F000
   2128  27000				   -	       endif
   2129  27000					       endif
   2130  27000				   -	       ifconst	ROM512K
   2131  27000				   -	       if	( * < $f000 )
   2132  27000				   -	       ORG	$87000
   2133  27000				   -	       RORG	$F000
   2134  27000				   -	       endif
   2135  27000					       endif
   2136  27000				   -	       ifconst	ROM528K
   2137  27000				   -	       if	( * < $f000 )
   2138  27000				   -	       ORG	$87000
   2139  27000				   -	       RORG	$F000
   2140  27000				   -	       endif
   2141  27000					       endif
   2142  27000					       endif
   2143  27000
   2144  27000							; all of these "modules" have conditional clauses in them, so even though
   2145  27000							; they're always included here, they don't take up rom unless the user
   2146  27000							; explicitly enables support for the feature.
   2147  27000
   2148  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -AVoxReadBytes
     12  27000				   -	       sta	temp8
     13  27000				   -	       jsr	i2c_startwrite
     14  27000				   -	       bcs	eeprom_error
     15  27000				   -
     16  27000				   -	       lda	HSVoxHi
     17  27000				   -	       jsr	i2c_txbyte
     18  27000				   -	       lda	HSVoxLo
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       jsr	i2c_stopwrite
     21  27000				   -
     22  27000				   -	       jsr	i2c_startread
     23  27000				   -
     24  27000				   -	       ldx	#0
     25  27000				   -AVoxReadBytesLoop
     26  27000				   -	       jsr	i2c_rxbyte
     27  27000				   -	       sta	eeprombuffer,x
     28  27000				   -	       inx
     29  27000				   -	       cpx	temp8
     30  27000				   -	       bne	AVoxReadBytesLoop
     31  27000				   -	       jsr	i2c_stopread
     32  27000				   -	       lda	#0
     33  27000				   -	       rts
     34  27000				   -
     35  27000				   -			; to be called with
     36  27000				   -			; A=# of bytes
     37  27000				   -			;
     38  27000				   -
     39  27000				   -AVoxWriteBytes
     40  27000				   -	       sta	temp8
     41  27000				   -	       jsr	i2c_startwrite
     42  27000				   -	       bcs	eeprom_error
     43  27000				   -
     44  27000				   -	       lda	HSVoxHi
     45  27000				   -	       jsr	i2c_txbyte
     46  27000				   -	       lda	HSVoxLo
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -
     49  27000				   -	       ldx	#$00
     50  27000				   -AVoxWriteBytesLoop
     51  27000				   -	       lda	eeprombuffer,x
     52  27000				   -	       jsr	i2c_txbyte
     53  27000				   -	       inx
     54  27000				   -	       cpx	temp8
     55  27000				   -	       bne	AVoxWriteBytesLoop
     56  27000				   -	       jsr	i2c_stopwrite
     57  27000				   -
     58  27000				   -	       lda	#0
     59  27000				   -	       rts
     60  27000				   -
     61  27000				   -eeprom_error
     62  27000				   -	       lda	#$ff
     63  27000				   -	       rts
     64  27000				   -
     65  27000				   -AVoxDetect
     66  27000				   -
     67  27000				   -	       jsr	i2c_startwrite
     68  27000				   -	       bcs	eeprom_error
     69  27000				   -	       lda	#$30
     70  27000				   -	       jsr	i2c_txbyte
     71  27000				   -	       lda	#$00
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       jsr	i2c_stopwrite
     74  27000				   -	       rts
     75  27000				   -
     76  27000				   -	       include	"i2c7800.inc"
     77  27000				   -	       I2C_SUBS	temp9
     78  27000				   -
     79  27000					       endif
     80  27000
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
   2150  27000					       endif
   2151  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000					       ifconst	pokeysupport
      5  27000
      6  27000				    pokeysoundmodulestart
      7  27000
      8  27000				    mutepokey
      9  27000			a9 00		       lda	#0
     10  27002			a0 07		       ldy	#7
     11  27004				    mutepokeyloop
     12  27004			99 5b 00	       sta	pokey1pointlo,y
     13  27007			91 4b		       sta	(pokeybaselo),y
     14  27009			88		       dey
     15  2700a			10 f8		       bpl	mutepokeyloop
     16  2700c			60		       rts
     17  2700d
     18  2700d				    checkpokeyplaying
     19  2700d			a2 06		       ldx	#6
     20  2700f				    checkpokeyplayingloop
     21  2700f			b5 5b		       lda	pokey1pointlo,x
     22  27011			15 5c		       ora	pokey1pointhi,x
     23  27013			f0 03		       beq	pokeychannelinactive
     24  27015			20 1d f0	       jsr	playpokeysfxA	; x=channel*2
     25  27018				    pokeychannelinactive
     26  27018			ca		       dex
     27  27019			ca		       dex
     28  2701a			10 f3		       bpl	checkpokeyplayingloop
     29  2701c			60		       rts
     30  2701d
     31  2701d				    playpokeysfxA
     32  2701d			8a		       txa
     33  2701e			a8		       tay
     34  2701f			bd c2 01	       lda	pokey1tick,x
     35  27022			f0 07		       beq	playpokeysfxAcont
     36  27024			38		       sec
     37  27025			e9 01		       sbc	#1
     38  27027			9d c2 01	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  2702a			60		       rts
     40  2702b
     41  2702b				    playpokeysfxAcont
     42  2702b			bd c1 01	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  2702e			9d c2 01	       sta	pokey1tick,x
     44  27031
     45  27031			bd c9 01	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  27034			f0 06		       beq	playpokeysfxAcont2
     47  27036			38		       sec
     48  27037			e9 01		       sbc	#1
     49  27039			9d c9 01	       sta	pokey1priority,x
     50  2703c				    playpokeysfxAcont2
     51  2703c
     52  2703c							; *** FREQUENCY
     53  2703c			a1 5b		       lda	(pokey1pointlo,x)
     54  2703e			85 42		       sta	temp1
     55  27040			18		       clc
     56  27041			7d ca 01	       adc	pokey1offset,x	; take into account any pitch modification
     57  27044			91 4b		       sta	(pokeybaselo),y	; PAUDF0,0
     58  27046
     59  27046							;advance the data pointer +1
     60  27046			f6 5b		       inc	pokey1pointlo,x
     61  27048			d0 02		       bne	skippokeyhiinc1
     62  2704a			f6 5c		       inc	pokey1pointhi,x
     63  2704c				    skippokeyhiinc1
     64  2704c
     65  2704c							; *** WAVE
     66  2704c			a1 5b		       lda	(pokey1pointlo,x)
     67  2704e			0a		       asl
     68  2704f			0a		       asl
     69  27050			0a		       asl
     70  27051			0a		       asl		; x16
     71  27052
     72  27052							;advance the data pointer +1
     73  27052			f6 5b		       inc	pokey1pointlo,x
     74  27054			d0 02		       bne	skippokeyhiinc2
     75  27056			f6 5c		       inc	pokey1pointhi,x
     76  27058				    skippokeyhiinc2
     77  27058
     78  27058			01 5b		       ora	(pokey1pointlo,x)
     79  2705a			c8		       iny
     80  2705b			91 4b		       sta	(pokeybaselo),y
     81  2705d
     82  2705d			05 42		       ora	temp1	; check if F|C|V=0
     83  2705f			f0 07		       beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  27061
     85  27061							; advance the pointer +1, on to the next sound chunk
     86  27061			f6 5b		       inc	pokey1pointlo,x
     87  27063			d0 02		       bne	skippokeyhiinc3
     88  27065			f6 5c		       inc	pokey1pointhi,x
     89  27067				    skippokeyhiinc3
     90  27067			60		       rts
     91  27068
     92  27068				    zeropokeypoint
     93  27068			95 5b		       sta	pokey1pointlo,x
     94  2706a			95 5c		       sta	pokey1pointhi,x
     95  2706c			9d c9 01	       sta	pokey1priority,x
     96  2706f			60		       rts
     97  27070
     98  27070				    schedulepokeysfx
     99  27070			a2 06		       ldx	#6
    100  27072				    schedulepokeysfxloop
    101  27072			b5 5b		       lda	pokey1pointlo,x
    102  27074			15 5c		       ora	pokey1pointhi,x
    103  27076			d0 03		       bne	schedulespokeysearch
    104  27078			4c a2 f0	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  2707b				    schedulespokeysearch
    106  2707b			ca		       dex
    107  2707c			ca		       dex
    108  2707d			10 f3		       bpl	schedulepokeysfxloop
    109  2707f
    110  2707f							; if we're here, all 4 channels are presently playing a sound...
    111  2707f			a0 01		       ldy	#1
    112  27081			b1 42		       lda	(temp1),y	; peek at the priority of this sfx...
    113  27083			d0 01		       bne	schedulepokeysfxcont1
    114  27085			60		       rts		; ...and skip it if it's 0 priority
    115  27086				    schedulepokeysfxcont1
    116  27086
    117  27086							; figure out which current sound has the lowest priority...
    118  27086			a9 00		       lda	#0
    119  27088			85 49		       sta	temp8
    120  2708a			ad c9 01	       lda	pokey1priority
    121  2708d			85 4a		       sta	temp9
    122  2708f			a2 06		       ldx	#6
    123  27091				    findlowprioritypokeyloop
    124  27091			bd c9 01	       lda	pokey1priority,x
    125  27094			c5 4a		       cmp	temp9
    126  27096			b0 04		       bcs	findlowprioritypokeyloopcontinue
    127  27098			85 4a		       sta	temp9
    128  2709a			86 49		       stx	temp8
    129  2709c				    findlowprioritypokeyloopcontinue
    130  2709c			ca		       dex
    131  2709d			ca		       dex
    132  2709e			d0 f1		       bne	findlowprioritypokeyloop
    133  270a0			a6 49		       ldx	temp8	; the low priority channel we'll interrupt
    134  270a2
    135  270a2				    schedulepokeyX
    136  270a2							;called with X=2*pokey channel to play on...
    137  270a2			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
    138  270a4			b1 42		       lda	(temp1),y
    139  270a6			9d c9 01	       sta	pokey1priority,x
    140  270a9			c8		       iny
    141  270aa			b1 42		       lda	(temp1),y
    142  270ac			9d c1 01	       sta	pokey1frames,x
    143  270af
    144  270af			a5 42		       lda	temp1
    145  270b1			18		       clc
    146  270b2			69 03		       adc	#3
    147  270b4			95 5b		       sta	pokey1pointlo,x
    148  270b6			a5 43		       lda	temp2
    149  270b8			69 00		       adc	#0
    150  270ba			95 5c		       sta	pokey1pointhi,x
    151  270bc			a5 44		       lda	temp3
    152  270be			9d ca 01	       sta	pokey1offset,x
    153  270c1			a9 00		       lda	#0
    154  270c3			9d c2 01	       sta	pokey1tick,x
    155  270c6			60		       rts
    156  270c7
    157  270c7							; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  270c7							; and the standard $4000 location.
    159  270c7							; if pokey the pokey is present, this routine will reset it.
    160  270c7
    161  270c7				    detectpokeylocation
    162  270c7							;XBoard/XM...
    163  270c7			a2 02		       ldx	#2
    164  270c9				    detectpokeyloop
    165  270c9			ad b4 01	       lda	XCTRL1s
    166  270cc			09 14		       ora	#%00010100
    167  270ce			3d f2 f0	       and	POKEYXMMASK,x
    168  270d1			8d b4 01	       sta	XCTRL1s
    169  270d4			8d 70 04	       sta	XCTRL1
    170  270d7
    171  270d7			bd f5 f0	       lda	POKEYCHECKLO,x
    172  270da			85 4b		       sta	pokeybaselo
    173  270dc			bd f8 f0	       lda	POKEYCHECKHI,x
    174  270df			85 4c		       sta	pokeybasehi
    175  270e1			20 fb f0	       jsr	checkforpokey
    176  270e4			ad 08 21	       lda	pokeydetected
    177  270e7			f0 03		       beq	foundpokeychip
    178  270e9			ca		       dex
    179  270ea			10 dd		       bpl	detectpokeyloop
    180  270ec				    foundpokeychip
    181  270ec			49 ff		       eor	#$ff	; invert state for 7800basic if...then test
    182  270ee			8d 08 21	       sta	pokeydetected
    183  270f1			60		       rts
    184  270f2
    185  270f2				    POKEYXMMASK
    186  270f2							;     XM POKEY on    XM POKEY off   XM POKEY off
    187  270f2			ff ef ef	       .byte.b	%11111111, %11101111, %11101111
    188  270f5
    189  270f5				    POKEYCHECKLO
    190  270f5			50 50 00	       .byte.b	<$0450, <$0450, <$4000
    191  270f8				    POKEYCHECKHI
    192  270f8			04 04 40	       .byte.b	>$0450, >$0450, >$4000
    193  270fb
    194  270fb				    checkforpokey
    195  270fb			a0 0f		       ldy	#$0f
    196  270fd			a9 00		       lda	#$00
    197  270ff			8d 08 21	       sta	pokeydetected	; start off by assuming pokey will be detected
    198  27102				    resetpokeyregistersloop
    199  27102			91 4b		       sta	(pokeybase),y
    200  27104			88		       dey
    201  27105			10 fb		       bpl	resetpokeyregistersloop
    202  27107
    203  27107			a0 08		       ldy	#PAUDCTL
    204  27109			91 4b		       sta	(pokeybase),y
    205  2710b			a0 0f		       ldy	#PSKCTL
    206  2710d			91 4b		       sta	(pokeybase),y
    207  2710f
    208  2710f							; let the dust settle...
    209  2710f			ea		       nop
    210  27110			ea		       nop
    211  27111			ea		       nop
    212  27112
    213  27112			a9 04		       lda	#4
    214  27114			85 4a		       sta	temp9
    215  27116				    pokeycheckloop1
    216  27116							; we're in reset, so the RANDOM register should read $ff...
    217  27116			a0 0a		       ldy	#PRANDOM
    218  27118			b1 4b		       lda	(pokeybase),y
    219  2711a			c9 ff		       cmp	#$ff
    220  2711c			d0 24		       bne	nopokeydetected
    221  2711e			c6 4a		       dec	temp9
    222  27120			d0 f4		       bne	pokeycheckloop1
    223  27122
    224  27122							; take pokey out of reset...
    225  27122			a0 0f		       ldy	#PSKCTL
    226  27124			a9 03		       lda	#3
    227  27126			91 4b		       sta	(pokeybase),y
    228  27128			a0 08		       ldy	#PAUDCTL
    229  2712a			a9 00		       lda	#0
    230  2712c			91 4b		       sta	(pokeybase),y
    231  2712e
    232  2712e							; let the dust settle again...
    233  2712e			ea		       nop
    234  2712f			ea		       nop
    235  27130			ea		       nop
    236  27131
    237  27131			a9 04		       lda	#4
    238  27133			85 4a		       sta	temp9
    239  27135				    pokeycheckloop2
    240  27135							; we're out of reset, so RANDOM should read non-$ff...
    241  27135			a0 0a		       ldy	#PRANDOM
    242  27137			b1 4b		       lda	(pokeybase),y
    243  27139			c9 ff		       cmp	#$ff
    244  2713b			f0 01		       beq	skippokeycheckreturn
    245  2713d			60		       rts
    246  2713e				    skippokeycheckreturn
    247  2713e			c6 4a		       dec	temp9
    248  27140			d0 f3		       bne	pokeycheckloop2
    249  27142				    nopokeydetected
    250  27142			ce 08 21	       dec	pokeydetected	; pokeydetected=#$ff
    251  27145			60		       rts
    252  27146
    253  27146				    pokeysoundmoduleend
    254  27146
   pokeysound assembly:  326  bytes
    255  27146					       echo	"  pokeysound assembly: ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes"
    256  27146
    257  27146					       endif
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
   2153  27146					       endif
   2154  27146					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27146					       include	tracker.asm
      1  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27146
      3  27146
      4  27146				   -	       ifconst	MUSICTRACKER
      5  27146				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      6  27146				   -			; ** the player operates on a 16th note grid.
      7  27146				   -
      8  27146				   -servicesongover
      9  27146				   -	       rts
     10  27146				   -servicesong
     11  27146				   -	       lda	songtempo
     12  27146				   -	       beq	servicesongover	; ** if song is off/paused then return
     13  27146				   -servicesongcontinue
     14  27146				   -	       lda	sfxschedulelock
     15  27146				   -	       sta	sfxschedulemissed
     16  27146				   -	       bne	servicesongover
     17  27146				   -	       lda	songtempo
     18  27146				   -	       clc
     19  27146				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     20  27146				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     21  27146				   -	       bcc	servicesongover
     22  27146				   -			; ** if we're here a new 16th note has passed
     23  27146				   -			; ** check if a new note is due on any of the 4 channels
     24  27146				   -servicesongredo
     25  27146				   -	       ldx	#3
     26  27146				   -checkchannelloop
     27  27146				   -	       dec	songchannel1busywait,x
     28  27146				   -	       bpl	carryoncheckingchannel
     29  27146				   -	       txa
     30  27146				   -	       pha		; save X for the loop
     31  27146				   -	       jsr	processsongdata
     32  27146				   -	       pla		; restore X for the loop
     33  27146				   -	       tax
     34  27146				   -carryoncheckingchannel
     35  27146				   -	       dex
     36  27146				   -	       bpl	checkchannelloop
     37  27146				   -	       lda	inactivechannelcount
     38  27146				   -	       cmp	#15
     39  27146				   -	       bne	skipstopsong
     40  27146				   -	       lda	songloops
     41  27146				   -	       bne	doasongloop
     42  27146				   -			;lda #0
     43  27146				   -	       sta	songtempo	; all channels are done. stop the song
     44  27146				   -	       rts
     45  27146				   -doasongloop
     46  27146				   -	       bmi	skipsongloopadjust
     47  27146				   -	       dec	songloops
     48  27146				   -skipsongloopadjust
     49  27146				   -	       jsr	setsongchannels
     50  27146				   -	       jmp	servicesongredo
     51  27146				   -skipstopsong
     52  27146				   -	       rts
     53  27146				   -
     54  27146				   -processsongdata
     55  27146				   -			; channel needs processing
     56  27146				   -			; X=channel #
     57  27146				   -
     58  27146				   -	       txa
     59  27146				   -	       clc
     60  27146				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     61  27146				   -	       tay
     62  27146				   -
     63  27146				   -
     64  27146				   -			; ** indirect x is cumbersome with mult-byte commands.
     65  27146				   -			; ** setup a pointer to the song data for indirect y addressing.
     66  27146				   -	       lda	songchannel1layer1lo,y
     67  27146				   -	       sta	songdatalo
     68  27146				   -	       lda	songchannel1layer1hi,y
     69  27146				   -	       sta	songdatahi
     70  27146				   -	       ora	songdatalo
     71  27146				   -	       bne	channelhasdata
     72  27146				   -			;channel data is pointing at $0000
     73  27146				   -	       lda	#$7F
     74  27146				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     75  27146				   -setchannelcountbits
     76  27146				   -	       lda	channel2bits,x
     77  27146				   -	       ora	inactivechannelcount
     78  27146				   -	       sta	inactivechannelcount
     79  27146				   -	       rts
     80  27146				   -channelhasdata
     81  27146				   -
     82  27146				   -	       sty	songstackindex
     83  27146				   -	       ldy	#0
     84  27146				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     85  27146				   -	       cmp	#$ff
     86  27146				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     87  27146				   -	       jmp	handlechannelEOD
     88  27146				   -
     89  27146				   -carryoncheckingdatatype
     90  27146				   -	       and	#$F0
     91  27146				   -	       cmp	#$C0
     92  27146				   -	       beq	handlechannelrest	; 0000XXXX=rest
     93  27146				   -	       cmp	#$F0
     94  27146				   -	       beq	handlemultibytecommand
     95  27146				   -	       cmp	#$D0
     96  27146				   -	       beq	handlesemiup
     97  27146				   -	       cmp	#$E0
     98  27146				   -	       beq	handlesemidown
     99  27146				   -handlenotedata
    100  27146				   -			; ** TODO: note playing is a terrible choice for fall-through
    101  27146				   -
    102  27146				   -			; ** its simple note data, prepare arguments for schedulesfx
    103  27146				   -
    104  27146				   -			; ** set the note length
    105  27146				   -	       lda	(songdatalo),y
    106  27146				   -	       and	#$0F
    107  27146				   -	       sta	songchannel1busywait,x
    108  27146				   -
    109  27146				   -			; ** load the instrument
    110  27146				   -	       lda	songchannel1instrumentlo,x
    111  27146				   -	       sta	sfxinstrumentlo
    112  27146				   -	       lda	songchannel1instrumenthi,x
    113  27146				   -	       sta	sfxinstrumenthi
    114  27146				   -
    115  27146				   -			; ** get the note, and transpose
    116  27146				   -	       lda	(songdatalo),y
    117  27146				   -	       lsr
    118  27146				   -	       lsr
    119  27146				   -	       lsr
    120  27146				   -	       lsr
    121  27146				   -	       clc
    122  27146				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    123  27146				   -			; ** its up the respective SFX scheduler to handle and save the note data
    124  27146				   -	       sta	sfxnoteindex
    125  27146				   -
    126  27146				   -	       lda	#0
    127  27146				   -	       sta	sfxpitchoffset
    128  27146				   -
    129  27146				   -	       jsr	schedulesfx
    130  27146				   -
    131  27146				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    132  27146				   -
    133  27146				   -handlechannelrest
    134  27146				   -			; ** set the note length
    135  27146				   -	       lda	(songdatalo),y
    136  27146				   -	       and	#$0F
    137  27146				   -	       sta	songchannel1busywait,x
    138  27146				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  27146				   -
    140  27146				   -handlesemiup
    141  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    142  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    143  27146				   -	       clc
    144  27146				   -handlesemidownentry
    145  27146				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    146  27146				   -	       sta	songchannel1transpose,x
    147  27146				   -	       jsr	advancethesongpointer1byte
    148  27146				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    149  27146				   -
    150  27146				   -handlesemidown
    151  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    152  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    153  27146				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    154  27146				   -	       sec
    155  27146				   -	       jmp	handlesemidownentry
    156  27146				   -
    157  27146				   -handlemultibytecommand
    158  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  27146				   -	       cmp	#$08	; ** load new instrument?
    161  27146				   -	       bne	nothandleinstrumentchange
    162  27146				   -handleinstrumentchange
    163  27146				   -	       iny
    164  27146				   -	       lda	(songdatalo),y
    165  27146				   -	       sta	songchannel1instrumentlo,x
    166  27146				   -	       iny
    167  27146				   -	       lda	(songdatalo),y
    168  27146				   -	       sta	songchannel1instrumenthi,x
    169  27146				   -	       lda	#3
    170  27146				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    171  27146				   -	       jmp	processsongdata
    172  27146				   -
    173  27146				   -nothandleinstrumentchange
    174  27146				   -	       cmp	#$09	; ** absolute tempo change?
    175  27146				   -	       bne	nothandletempochange
    176  27146				   -	       lda	#0
    177  27146				   -	       sta	songtempo
    178  27146				   -handlerelativetempochange
    179  27146				   -	       iny
    180  27146				   -	       lda	(songdatalo),y
    181  27146				   -	       clc
    182  27146				   -	       adc	songtempo
    183  27146				   -	       sta	songtempo
    184  27146				   -	       lda	#2
    185  27146				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    186  27146				   -	       jmp	processsongdata
    187  27146				   -
    188  27146				   -nothandletempochange
    189  27146				   -	       cmp	#$0A	; ** relative tempo change?:
    190  27146				   -	       beq	handlerelativetempochange
    191  27146				   -	       cmp	#$0B	; ** octave/semi change?
    192  27146				   -	       beq	handleoctavesemichange
    193  27146				   -handlepatterndata
    194  27146				   -			; ** if we're here its a pattern/loop "subroutine"
    195  27146				   -			; ** move the channel's "stack" pointer and populate the new stack level
    196  27146				   -
    197  27146				   -	       lda	#4
    198  27146				   -	       clc
    199  27146				   -	       adc	songchannel1stackdepth,x
    200  27146				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    201  27146				   -
    202  27146				   -	       stx	inttemp6	; about to invalidate x. save it.
    203  27146				   -	       lda	songstackindex
    204  27146				   -	       adc	#4
    205  27146				   -	       tax
    206  27146				   -
    207  27146				   -	       lda	(songdatalo),y
    208  27146				   -	       and	#$7
    209  27146				   -	       sta	songchannel1layer1loops,x
    210  27146				   -	       iny
    211  27146				   -	       lda	(songdatalo),y
    212  27146				   -	       sta	songchannel1layer1lo,x
    213  27146				   -	       iny
    214  27146				   -	       lda	(songdatalo),y
    215  27146				   -	       sta	songchannel1layer1hi,x
    216  27146				   -
    217  27146				   -	       ldx	inttemp6	; restore x with the channel #
    218  27146				   -
    219  27146				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    220  27146				   -	       lda	#3
    221  27146				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    222  27146				   -
    223  27146				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    224  27146				   -	       jmp	processsongdata
    225  27146				   -
    226  27146				   -handlechannelEOD
    227  27146				   -			; ** check if there are loops remaining on the pattern
    228  27146				   -	       stx	inttemp6
    229  27146				   -	       ldx	songstackindex
    230  27146				   -	       dec	songchannel1layer1loops,x
    231  27146				   -	       bmi	handlechannelEODnoloop
    232  27146				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    233  27146				   -	       iny
    234  27146				   -	       lda	(songdatalo),y
    235  27146				   -	       sta	songchannel1layer1lo,x
    236  27146				   -	       iny
    237  27146				   -	       lda	(songdatalo),y
    238  27146				   -	       sta	songchannel1layer1hi,x
    239  27146				   -	       ldx	inttemp6
    240  27146				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    241  27146				   -
    242  27146				   -handlechannelEODnoloop
    243  27146				   -			; this pattern/loop is done playing. "pop" the stack
    244  27146				   -	       ldx	inttemp6
    245  27146				   -	       lda	songchannel1stackdepth,x
    246  27146				   -	       beq	handlerootchannelEOD
    247  27146				   -	       sec
    248  27146				   -	       sbc	#4
    249  27146				   -	       sta	songchannel1stackdepth,x
    250  27146				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    251  27146				   -
    252  27146				   -handlerootchannelEOD
    253  27146				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    254  27146				   -	       lda	#0
    255  27146				   -	       sta	songchannel1layer1lo,x
    256  27146				   -	       sta	songchannel1layer1hi,x
    257  27146				   -	       sta	songchannel1busywait,x
    258  27146				   -	       jmp	setchannelcountbits
    259  27146				   -	       rts
    260  27146				   -
    261  27146				   -nothandlepatternchange
    262  27146				   -handleoctavesemichange
    263  27146				   -	       iny
    264  27146				   -	       lda	(songdatalo),y
    265  27146				   -	       sta	songchannel1transpose,x
    266  27146				   -	       lda	#2
    267  27146				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    268  27146				   -	       jmp	processsongdata
    269  27146				   -
    270  27146				   -advancethesongpointer1byte
    271  27146				   -	       txa
    272  27146				   -	       ldx	songstackindex
    273  27146				   -	       inc	songchannel1layer1lo,x
    274  27146				   -	       bne	skiphiadvancethesongpointer1byte
    275  27146				   -	       inc	songchannel1layer1hi,x
    276  27146				   -skiphiadvancethesongpointer1byte
    277  27146				   -	       tax
    278  27146				   -	       rts
    279  27146				   -
    280  27146				   -advancethesongpointerNbytes
    281  27146				   -			; entered with A=# of byte to advance
    282  27146				   -	       stx	inttemp6
    283  27146				   -	       ldx	songstackindex
    284  27146				   -	       clc
    285  27146				   -	       adc	songchannel1layer1lo,x
    286  27146				   -	       sta	songchannel1layer1lo,x
    287  27146				   -	       lda	#0
    288  27146				   -	       adc	songchannel1layer1hi,x
    289  27146				   -	       sta	songchannel1layer1hi,x
    290  27146				   -	       ldx	inttemp6
    291  27146				   -	       rts
    292  27146				   -
    293  27146				   -clearsongmemory
    294  27146				   -	       lda	#0
    295  27146				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    296  27146				   -clearsongmemoryloop1
    297  27146				   -	       sta	songchannel1layer1lo,x
    298  27146				   -	       dex
    299  27146				   -	       bpl	clearsongmemoryloop1
    300  27146				   -
    301  27146				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    302  27146				   -clearsongmemoryloop2
    303  27146				   -	       sta	songchannel1layer1loops,x
    304  27146				   -	       dex
    305  27146				   -	       bpl	clearsongmemoryloop2
    306  27146				   -
    307  27146				   -	       lda	#$ff
    308  27146				   -	       ldx	#3
    309  27146				   -clearsongmemoryloop3
    310  27146				   -	       sta	songchannel1busywait,x
    311  27146				   -	       dex
    312  27146				   -	       bpl	clearsongmemoryloop3
    313  27146				   -	       rts
    314  27146				   -
    315  27146				   -setsongchannels
    316  27146				   -	       jsr	clearsongmemory
    317  27146				   -	       ldy	#7
    318  27146				   -	       ldx	#3
    319  27146				   -setsongchannelsloop
    320  27146				   -	       lda	(songpointerlo),y
    321  27146				   -	       sta	songchannel1layer1hi,x
    322  27146				   -	       dey
    323  27146				   -	       lda	(songpointerlo),y
    324  27146				   -	       sta	songchannel1layer1lo,x
    325  27146				   -	       dex
    326  27146				   -	       dey
    327  27146				   -	       bpl	setsongchannelsloop
    328  27146				   -	       rts
    329  27146				   -
    330  27146				   -channel2bits
    331  27146				   -	       .byte	1,2,4,8
    332  27146				   -
    333  27146				   -tiatrackeroctavenotes
    334  27146				   -	       ifconst	BUZZBASS
    335  27146				   -LOWC       =	15
    336  27146				   -	       else
    337  27146				   -LOWC       =	14
    338  27146				   -	       endif
    339  27146				   -			; ****** ELECTRONIC (0 to 11)
    340  27146				   -	       .byte	LOWC,20	; c0	 16.1Hz
    341  27146				   -	       .byte	LOWC,18	; c#0
    342  27146				   -	       .byte	LOWC,17	; d0
    343  27146				   -	       .byte	LOWC,16	; d#0
    344  27146				   -	       .byte	LOWC,15	; e0
    345  27146				   -	       .byte	LOWC,14	; f0  (very off)
    346  27146				   -	       .byte	LOWC,14	; f#0
    347  27146				   -	       .byte	LOWC,13	; g0
    348  27146				   -	       .byte	LOWC,12	; g#0
    349  27146				   -	       .byte	LOWC,11	; a0
    350  27146				   -	       .byte	LOWC,11	; a#0 (very off)
    351  27146				   -	       .byte	LOWC,10	; b0	 30.7Hz
    352  27146				   -
    353  27146				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    354  27146				   -	       .byte	6,30	; c1	 32.7Hz
    355  27146				   -	       .byte	6,28	; c#1
    356  27146				   -	       .byte	6,27	; d1
    357  27146				   -	       .byte	6,25	; d#1
    358  27146				   -	       .byte	6,24	; e1
    359  27146				   -	       .byte	6,22	; f1
    360  27146				   -	       .byte	6,21	; f#1
    361  27146				   -	       .byte	6,20	; g1
    362  27146				   -	       .byte	6,18	; g#1
    363  27146				   -	       .byte	6,17	; a1
    364  27146				   -	       .byte	6,16	; a#1
    365  27146				   -	       .byte	6,15	; b1	 63.4Hz
    366  27146				   -
    367  27146				   -			; ****** BUZZY (24 to 39)
    368  27146				   -	       .byte	1,31	; c2	 65.5
    369  27146				   -	       .byte	1,30	; c#2	 67.6
    370  27146				   -	       .byte	1,27	; d2	 72.3
    371  27146				   -	       .byte	1,26	; d#2	 77.6
    372  27146				   -	       .byte	1,24	; e2
    373  27146				   -	       .byte	1,23	; f2
    374  27146				   -	       .byte	1,22	; f#2
    375  27146				   -	       .byte	1,20	; g2
    376  27146				   -	       .byte	1,19	; g#2
    377  27146				   -	       .byte	1,18	; a2
    378  27146				   -	       .byte	1,17	; a#2
    379  27146				   -	       .byte	1,16	; b2
    380  27146				   -	       .byte	1,15	; c3	126.8Hz
    381  27146				   -	       .byte	1,14	; c#3
    382  27146				   -	       .byte	1,13	; d3	149.7Hz
    383  27146				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    384  27146				   -			; ****** PURE (40 to 71) - best key is A3 Major
    385  27146				   -	       .byte	12,31	; e3	163.8Hz
    386  27146				   -	       .byte	12,29	; f3
    387  27146				   -	       .byte	12,28	; f#3
    388  27146				   -	       .byte	12,26	; g3
    389  27146				   -	       .byte	12,24	; g#3
    390  27146				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    391  27146				   -	       .byte	12,22	; a#3
    392  27146				   -	       .byte	12,20	; b3
    393  27146				   -	       .byte	12,19	; c4  (middle C)
    394  27146				   -	       .byte	12,18	; c#4
    395  27146				   -	       .byte	12,17	; d4
    396  27146				   -	       .byte	12,16	; d#4
    397  27146				   -	       .byte	12,15	; e4
    398  27146				   -	       .byte	12,14	; f4
    399  27146				   -	       .byte	12,13	; f#4
    400  27146				   -	       .byte	12,12	; g4  (very off)
    401  27146				   -	       .byte	12,12	; g#4
    402  27146				   -	       .byte	12,11	; a4
    403  27146				   -	       .byte	12,10	; a#4
    404  27146				   -	       .byte	4,31	; b4
    405  27146				   -	       .byte	4,29	; c5
    406  27146				   -	       .byte	4,28	; c#5
    407  27146				   -	       .byte	4,26	; d5
    408  27146				   -	       .byte	4,24	; d#5
    409  27146				   -	       .byte	4,23	; e5
    410  27146				   -	       .byte	4,22	; f5
    411  27146				   -	       .byte	4,20	; f#5
    412  27146				   -	       .byte	4,19	; g5
    413  27146				   -	       .byte	4,18	; g#5
    414  27146				   -	       .byte	4,17	; a5
    415  27146				   -	       .byte	4,16	; a#5
    416  27146				   -	       .byte	4,15	; b5
    417  27146				   -
    418  27146				   -			; ****** TUNED WIND (72 to 83)
    419  27146				   -	       .byte	8,30	; c
    420  27146				   -	       .byte	8,28	; c#
    421  27146				   -	       .byte	8,27	; d
    422  27146				   -	       .byte	8,25	; d#
    423  27146				   -	       .byte	8,24	; e
    424  27146				   -	       .byte	8,22	; f
    425  27146				   -	       .byte	8,21	; f#
    426  27146				   -	       .byte	8,20	; g
    427  27146				   -	       .byte	8,18	; g#
    428  27146				   -	       .byte	8,17	; a
    429  27146				   -	       .byte	8,16	; a#
    430  27146				   -	       .byte	8,15	; b
    431  27146				   -
    432  27146				   -	       include	"tiadrumkit.asm"
    433  27146				   -
    434  27146					       endif		;MUSICTRACKER
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
   2156  27146					       endif
   2157  27146					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27146					       include	hiscore.asm
      1  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27146
      3  27146				   -	       ifconst	HSSUPPORT
      4  27146				   -detectatarivoxeeprom
      5  27146				   -hiscoremodulestart
      6  27146				   -			; do a test to see if atarivox eeprom can be accessed, and save results
      7  27146				   -	       jsr	AVoxDetect
      8  27146				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
      9  27146				   -	       sta	avoxdetected
     10  27146				   -	       lda	#$0
     11  27146				   -	       sta	SWACNT
     12  27146				   -	       lda	avoxdetected
     13  27146				   -	       rts
     14  27146				   -
     15  27146				   -detecthsc
     16  27146				   -			; check for the HSC ROM signature...
     17  27146				   -	       lda	XCTRL1s
     18  27146				   -	       ora	#%00001100
     19  27146				   -	       sta	XCTRL1s
     20  27146				   -	       sta	XCTRL1
     21  27146				   -	       lda	$3900
     22  27146				   -	       cmp	#$C6
     23  27146				   -	       bne	detecthscfail
     24  27146				   -	       lda	$3904
     25  27146				   -	       cmp	#$FE
     26  27146				   -	       bne	detecthscfail
     27  27146				   -			; check if it's initialized...
     28  27146				   -	       ldy	#0
     29  27146				   -	       lda	#$ff
     30  27146				   -checkhscinit
     31  27146				   -	       and	$1000,y
     32  27146				   -	       dey
     33  27146				   -	       bpl	checkhscinit
     34  27146				   -	       cmp	#$ff
     35  27146				   -	       bne	hscisalreadyinit
     36  27146				   -			; if we're here, we need to do a minimal HSC init...
     37  27146				   -	       ldy	#$28
     38  27146				   -hscinitloop1
     39  27146				   -	       lda	hscheader,y
     40  27146				   -	       sta	$1000,y
     41  27146				   -	       dey
     42  27146				   -	       bpl	hscinitloop1
     43  27146				   -	       ldy	#$89
     44  27146				   -	       lda	#$7F
     45  27146				   -hscinitloop2
     46  27146				   -	       sta	$10B3,y
     47  27146				   -	       dey
     48  27146				   -	       cpy	#$ff
     49  27146				   -	       bne	hscinitloop2
     50  27146				   -hscisalreadyinit
     51  27146				   -	       lda	#$ff
     52  27146				   -	       rts
     53  27146				   -hscheader
     54  27146				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     55  27146				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     56  27146				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     57  27146				   -detecthscfail
     58  27146				   -	       lda	XCTRL1s
     59  27146				   -	       and	#%11110111
     60  27146				   -	       sta	XCTRL1s
     61  27146				   -	       lda	#0
     62  27146				   -	       rts
     63  27146					       endif		; HSSUPPORT
     64  27146
     65  27146				   -	       ifconst	HSSUPPORT
     66  27146				   -	       ifnconst	hiscorefont
     67  27146				   -	       echo	""
     68  27146				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     69  27146				   -	       echo	" NOT imported with incgraphic. The high score display code"
     70  27146				   -	       echo	" has been omitted from this build."
     71  27146				   -	       echo	""
     72  27146				   -	       else
     73  27146				   -hscdrawscreen
     74  27146				   -
     75  27146				   -			; we use 20 lines on a 24 line display
     76  27146				   -			; HSSCOREY to dynamically centers based on
     77  27146				   -			;HSSCOREY = 0
     78  27146				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     79  27146				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     80  27146				   -
     81  27146				   -	       ifconst	HSSCORESIZE
     82  27146				   -SCORESIZE  =	HSSCORESIZE
     83  27146				   -	       else
     84  27146				   -SCORESIZE  =	6
     85  27146				   -	       endif
     86  27146				   -
     87  27146				   -			;save shadow registers for later return...
     88  27146				   -	       lda	sCTRL
     89  27146				   -	       sta	ssCTRL
     90  27146				   -	       lda	sCHARBASE
     91  27146				   -	       sta	ssCHARBASE
     92  27146				   -	       lda	#$60
     93  27146				   -	       sta	charactermode
     94  27146				   -	       jsr	drawwait
     95  27146				   -	       jsr	blacken320colors
     96  27146				   -	       jsr	clearscreen
     97  27146				   -
     98  27146				   -			;set the character base to the HSC font
     99  27146				   -	       lda	#>hiscorefont
    100  27146				   -	       sta	CHARBASE
    101  27146				   -	       sta	sCHARBASE
    102  27146				   -	       lda	#%01000011	;Enable DMA, mode=320A
    103  27146				   -	       sta	CTRL
    104  27146				   -	       sta	sCTRL
    105  27146				   -
    106  27146				   -	       lda	#60
    107  27146				   -	       sta	hsjoydebounce
    108  27146				   -
    109  27146				   -	       lda	#0
    110  27146				   -	       sta	hscursorx
    111  27146				   -	       sta	framecounter
    112  27146				   -	       ifnconst	HSCOLORCHASESTART
    113  27146				   -	       lda	#$8D	; default is blue. why not?
    114  27146				   -	       else
    115  27146				   -	       lda	#HSCOLORCHASESTART
    116  27146				   -	       endif
    117  27146				   -	       sta	hscolorchaseindex
    118  27146				   -
    119  27146				   -	       lda	#$0F
    120  27146				   -	       sta	P0C2	; base text is white
    121  27146				   -
    122  27146				   -	       jsr	hschasecolors
    123  27146				   -			; ** plot all of the initials
    124  27146				   -	       lda	#<HSRAMInitials
    125  27146				   -	       sta	temp1	; charmaplo
    126  27146				   -	       lda	#>HSRAMInitials
    127  27146				   -	       sta	temp2	; charmaphi
    128  27146				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    129  27146				   -	       sta	temp3	; palette/width
    130  27146				   -	       lda	#104
    131  27146				   -	       sta	temp4	; X
    132  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    133  27146				   -	       sta	temp5	; Y
    134  27146				   -plothsinitialsloop
    135  27146				   -	       jsr	plotcharacters
    136  27146				   -	       clc
    137  27146				   -	       lda	temp3
    138  27146				   -	       adc	#32
    139  27146				   -	       sta	temp3
    140  27146				   -	       inc	temp5
    141  27146				   -	       if	WZONEHEIGHT = 8
    142  27146				   -	       inc	temp5
    143  27146				   -	       endif
    144  27146				   -	       clc
    145  27146				   -	       lda	#3
    146  27146				   -	       adc	temp1
    147  27146				   -	       sta	temp1
    148  27146				   -	       cmp	#(<(HSRAMInitials+15))
    149  27146				   -	       bcc	plothsinitialsloop
    150  27146				   -
    151  27146				   -	       ifconst	HSGAMENAMELEN
    152  27146				   -			;plot the game name...
    153  27146				   -	       lda	#<HSGAMENAMEtable
    154  27146				   -	       sta	temp1	; charmaplo
    155  27146				   -	       lda	#>HSGAMENAMEtable
    156  27146				   -	       sta	temp2	; charmaphi
    157  27146				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    158  27146				   -	       sta	temp3	; palette/width
    159  27146				   -	       lda	#(80-(HSGAMENAMELEN*2))
    160  27146				   -	       sta	temp4	; X
    161  27146				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    162  27146				   -	       sta	temp5	; Y
    163  27146				   -	       jsr	plotcharacters
    164  27146				   -	       endif		; HSGAMENAMELEN
    165  27146				   -
    166  27146				   -			;plot "difficulty"...
    167  27146				   -	       ldy	gamedifficulty
    168  27146				   -	       ifnconst	HSNOLEVELNAMES
    169  27146				   -	       lda	highscoredifficultytextlo,y
    170  27146				   -	       sta	temp1
    171  27146				   -	       lda	highscoredifficultytexthi,y
    172  27146				   -	       sta	temp2
    173  27146				   -	       sec
    174  27146				   -	       lda	#32
    175  27146				   -	       sbc	highscoredifficultytextlen,y
    176  27146				   -	       sta	temp3	; palette/width
    177  27146				   -	       sec
    178  27146				   -	       lda	#40
    179  27146				   -	       sbc	highscoredifficultytextlen,y
    180  27146				   -	       asl
    181  27146				   -	       sta	temp4	; X
    182  27146				   -	       else
    183  27146				   -	       lda	#<HSHIGHSCOREStext
    184  27146				   -	       sta	temp1	; charmaplo
    185  27146				   -	       lda	#>HSHIGHSCOREStext
    186  27146				   -	       sta	temp2	; charmaphi
    187  27146				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    188  27146				   -	       sta	temp3	; palette/width
    189  27146				   -	       lda	#(80-(11*2))
    190  27146				   -	       sta	temp4	; X
    191  27146				   -	       endif		; HSNOLEVELNAMES
    192  27146				   -
    193  27146				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    194  27146				   -	       sta	temp5	; Y
    195  27146				   -	       jsr	plotcharacters
    196  27146				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    197  27146				   -	       bne	carronwithscoreevaluation
    198  27146				   -	       jmp	donoscoreevaluation
    199  27146				   -carronwithscoreevaluation
    200  27146				   -	       dey
    201  27146				   -	       lda	highscorelabeltextlo,y
    202  27146				   -	       sta	temp1
    203  27146				   -	       lda	highscorelabeltexthi,y
    204  27146				   -	       sta	temp2
    205  27146				   -	       sec
    206  27146				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    207  27146				   -	       sta	temp3	; palette/width
    208  27146				   -	       lda	highscorelabeladjust1,y
    209  27146				   -	       sta	temp4	; X
    210  27146				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    211  27146				   -	       sta	temp5	; Y
    212  27146				   -	       jsr	plotcharacters
    213  27146				   -
    214  27146				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval
    215  27146				   -	       dey
    216  27146				   -			;plot the current player score...
    217  27146				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    218  27146				   -	       sta	temp3	; palette/width
    219  27146				   -	       lda	highscorelabeladjust2,y
    220  27146				   -	       sta	temp4	; X
    221  27146				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    222  27146				   -	       sta	temp5	; Y
    223  27146				   -
    224  27146				   -	       lda	scorevarlo,y
    225  27146				   -	       sta	temp7	; score variable lo
    226  27146				   -	       lda	scorevarhi,y
    227  27146				   -	       sta	temp8	; score variable hi
    228  27146				   -
    229  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    230  27146				   -	       sta	temp9
    231  27146				   -
    232  27146				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    233  27146				   -	       sta	temp1	; charmaplo
    234  27146				   -	       lda	#>(hiscorefont+33)
    235  27146				   -	       sta	temp2	; charmaphi
    236  27146				   -	       lda	#SCORESIZE
    237  27146				   -	       sta	temp6
    238  27146				   -	       ifnconst	DOUBLEWIDE
    239  27146				   -	       jsr	plotvalue
    240  27146				   -	       else
    241  27146				   -	       jsr	plotvaluedw
    242  27146				   -	       endif
    243  27146				   -
    244  27146				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    245  27146				   -
    246  27146				   -	       ifconst	HSGAMERANKS
    247  27146				   -
    248  27146				   -	       ldx	#$ff	; start at 0 after the inx...
    249  27146				   -comparescore2rankloop
    250  27146				   -	       inx
    251  27146				   -	       ldy	#0
    252  27146				   -	       lda	rankvalue_0,x
    253  27146				   -	       cmp	(temp7),y
    254  27146				   -	       bcc	score2rankloopdone
    255  27146				   -	       bne	comparescore2rankloop
    256  27146				   -	       iny
    257  27146				   -	       lda	rankvalue_1,x
    258  27146				   -	       cmp	(temp7),y
    259  27146				   -	       bcc	score2rankloopdone
    260  27146				   -	       bne	comparescore2rankloop
    261  27146				   -	       iny
    262  27146				   -	       lda	(temp7),y
    263  27146				   -	       cmp	rankvalue_2,x
    264  27146				   -	       bcs	score2rankloopdone
    265  27146				   -	       jmp	comparescore2rankloop
    266  27146				   -score2rankloopdone
    267  27146				   -	       stx	hsnewscorerank
    268  27146				   -
    269  27146				   -	       lda	ranklabello,x
    270  27146				   -	       sta	temp1
    271  27146				   -	       lda	ranklabelhi,x
    272  27146				   -	       sta	temp2
    273  27146				   -	       sec
    274  27146				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    275  27146				   -	       sbc	ranklabellengths,x
    276  27146				   -	       sta	temp3	; palette/width
    277  27146				   -	       sec
    278  27146				   -	       lda	#(40+6)
    279  27146				   -	       sbc	ranklabellengths,x
    280  27146				   -	       asl
    281  27146				   -	       sta	temp4	; X
    282  27146				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    283  27146				   -	       sta	temp5	; Y
    284  27146				   -	       jsr	plotcharacters
    285  27146				   -
    286  27146				   -	       ldx	hsnewscorerank
    287  27146				   -
    288  27146				   -	       lda	#<highscoreranklabel
    289  27146				   -	       sta	temp1
    290  27146				   -	       lda	#>highscoreranklabel
    291  27146				   -	       sta	temp2
    292  27146				   -
    293  27146				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    294  27146				   -	       sta	temp3	; palette/width
    295  27146				   -	       lda	#(40-6)
    296  27146				   -	       sec
    297  27146				   -	       sbc	ranklabellengths,x
    298  27146				   -	       asl
    299  27146				   -	       sta	temp4	; X
    300  27146				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    301  27146				   -	       sta	temp5	; Y
    302  27146				   -	       jsr	plotcharacters
    303  27146				   -	       endif
    304  27146				   -
    305  27146				   -
    306  27146				   -			; ** which line did this player beat?
    307  27146				   -	       lda	#$ff
    308  27146				   -	       sta	hsnewscoreline
    309  27146				   -	       ldx	#$fd
    310  27146				   -comparescoreadd2x
    311  27146				   -	       inx
    312  27146				   -comparescoreadd1x
    313  27146				   -	       inx
    314  27146				   -comparescore2lineloop
    315  27146				   -	       inc	hsnewscoreline
    316  27146				   -	       inx		; initialrun, x=0
    317  27146				   -	       cpx	#15
    318  27146				   -	       beq	nohighscoreforyou
    319  27146				   -	       ldy	#0
    320  27146				   -	       lda	HSRAMScores,x
    321  27146				   -	       cmp	(temp7),y	; first score digit
    322  27146				   -	       bcc	score2lineloopdonedel1x
    323  27146				   -	       bne	comparescoreadd2x
    324  27146				   -	       iny
    325  27146				   -	       inx
    326  27146				   -	       lda	HSRAMScores,x
    327  27146				   -	       cmp	(temp7),y
    328  27146				   -	       bcc	score2lineloopdonedel2x
    329  27146				   -	       bne	comparescoreadd1x
    330  27146				   -	       iny
    331  27146				   -	       inx
    332  27146				   -	       lda	(temp7),y
    333  27146				   -	       cmp	HSRAMScores,x
    334  27146				   -	       bcs	score2lineloopdonedel3x
    335  27146				   -	       jmp	comparescore2lineloop
    336  27146				   -nohighscoreforyou
    337  27146				   -	       lda	#$ff
    338  27146				   -	       sta	hsnewscoreline
    339  27146				   -	       sta	countdownseconds
    340  27146				   -	       jmp	donoscoreevaluation
    341  27146				   -score2lineloopdonedel3x
    342  27146				   -	       dex
    343  27146				   -score2lineloopdonedel2x
    344  27146				   -	       dex
    345  27146				   -score2lineloopdonedel1x
    346  27146				   -	       dex
    347  27146				   -
    348  27146				   -			; 0 1 2
    349  27146				   -			; 3 4 5
    350  27146				   -			; 6 7 8
    351  27146				   -			; 9 0 1
    352  27146				   -			; 2 3 4
    353  27146				   -
    354  27146				   -	       stx	temp9
    355  27146				   -	       cpx	#11
    356  27146				   -	       beq	postsortscoresuploop
    357  27146				   -	       ldx	#11
    358  27146				   -sortscoresuploop
    359  27146				   -	       lda	HSRAMScores,x
    360  27146				   -	       sta	HSRAMScores+3,x
    361  27146				   -	       lda	HSRAMInitials,x
    362  27146				   -	       sta	HSRAMInitials+3,x
    363  27146				   -	       dex
    364  27146				   -	       cpx	temp9
    365  27146				   -	       bne	sortscoresuploop
    366  27146				   -postsortscoresuploop
    367  27146				   -
    368  27146				   -			;stick the score and cleared initials in the slot...
    369  27146				   -	       inx
    370  27146				   -	       ldy	#0
    371  27146				   -	       sty	hsinitialhold
    372  27146				   -	       lda	(temp7),y
    373  27146				   -	       sta	HSRAMScores,x
    374  27146				   -	       iny
    375  27146				   -	       lda	(temp7),y
    376  27146				   -	       sta	HSRAMScores+1,x
    377  27146				   -	       iny
    378  27146				   -	       lda	(temp7),y
    379  27146				   -	       sta	HSRAMScores+2,x
    380  27146				   -	       lda	#0
    381  27146				   -	       sta	HSRAMInitials,x
    382  27146				   -	       lda	#29
    383  27146				   -	       sta	HSRAMInitials+1,x
    384  27146				   -	       sta	HSRAMInitials+2,x
    385  27146				   -
    386  27146				   -	       stx	hsinitialpos
    387  27146				   -
    388  27146				   -	       ifconst	vox_highscore
    389  27146				   -	       lda	<#vox_highscore
    390  27146				   -	       sta	speech_addr
    391  27146				   -	       lda	>#vox_highscore
    392  27146				   -	       sta	speech_addr+1
    393  27146				   -	       endif
    394  27146				   -	       ifconst	sfx_highscore
    395  27146				   -	       lda	<#sfx_highscore
    396  27146				   -	       sta	temp1
    397  27146				   -	       lda	>#sfx_highscore
    398  27146				   -	       sta	temp2
    399  27146				   -	       lda	#0
    400  27146				   -	       sta	temp3
    401  27146				   -	       jsr	schedulesfx
    402  27146				   -	       endif
    403  27146				   -	       ifconst	songdatastart_song_highscore
    404  27146				   -	       lda	#<songchanneltable_song_highscore
    405  27146				   -	       sta	songpointerlo
    406  27146				   -	       lda	#>songchanneltable_song_highscore
    407  27146				   -	       sta	songpointerhi
    408  27146				   -	       lda	#73
    409  27146				   -	       sta	songtempo
    410  27146				   -	       jsr	setsongchannels
    411  27146				   -	       endif
    412  27146				   -
    413  27146				   -
    414  27146				   -donoscoreevaluation
    415  27146				   -
    416  27146				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    417  27146				   -	       sta	temp3	; palette/width
    418  27146				   -	       lda	#(72+(4*(6-SCORESIZE)))
    419  27146				   -	       sta	temp4	; X
    420  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    421  27146				   -	       sta	temp5	; Y
    422  27146				   -	       lda	#<HSRAMScores
    423  27146				   -	       sta	temp7	; score variable lo
    424  27146				   -	       lda	#>HSRAMScores
    425  27146				   -	       sta	temp8	; score variable hi
    426  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    427  27146				   -	       sta	temp9
    428  27146				   -plothsscoresloop
    429  27146				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    430  27146				   -	       sta	temp1	; charmaplo
    431  27146				   -	       lda	#>(hiscorefont+33)
    432  27146				   -	       sta	temp2	; charmaphi
    433  27146				   -	       lda	#6
    434  27146				   -	       sta	temp6
    435  27146				   -	       ifnconst	DOUBLEWIDE
    436  27146				   -	       jsr	plotvalue
    437  27146				   -	       else
    438  27146				   -	       jsr	plotvaluedw
    439  27146				   -	       endif
    440  27146				   -	       clc
    441  27146				   -	       lda	temp3
    442  27146				   -	       adc	#32
    443  27146				   -	       sta	temp3
    444  27146				   -	       inc	temp5
    445  27146				   -	       if	WZONEHEIGHT = 8
    446  27146				   -	       inc	temp5
    447  27146				   -	       endif
    448  27146				   -	       clc
    449  27146				   -	       lda	#3
    450  27146				   -	       adc	temp7
    451  27146				   -	       sta	temp7
    452  27146				   -	       cmp	#(<(HSRAMScores+15))
    453  27146				   -	       bcc	plothsscoresloop
    454  27146				   -plothsindex
    455  27146				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    456  27146				   -	       sta	temp3	; palette/width
    457  27146				   -	       lda	#44
    458  27146				   -	       sta	temp4	; X
    459  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    460  27146				   -	       sta	temp5	; Y
    461  27146				   -	       lda	#<hsgameslotnumbers
    462  27146				   -	       sta	temp7	; score variable lo
    463  27146				   -	       lda	#>hsgameslotnumbers
    464  27146				   -	       sta	temp8	; score variable hi
    465  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    466  27146				   -	       sta	temp9
    467  27146				   -plothsindexloop
    468  27146				   -	       lda	#<(hiscorefont+33)
    469  27146				   -	       sta	temp1	; charmaplo
    470  27146				   -	       lda	#>(hiscorefont+33)
    471  27146				   -	       sta	temp2	; charmaphi
    472  27146				   -	       lda	#1
    473  27146				   -	       sta	temp6	; number of characters
    474  27146				   -	       ifnconst	DOUBLEWIDE
    475  27146				   -	       jsr	plotvalue
    476  27146				   -	       else
    477  27146				   -	       jsr	plotvaluedw
    478  27146				   -	       endif
    479  27146				   -	       clc
    480  27146				   -	       lda	temp3
    481  27146				   -	       adc	#32
    482  27146				   -	       sta	temp3
    483  27146				   -	       inc	temp5
    484  27146				   -	       if	WZONEHEIGHT = 8
    485  27146				   -	       inc	temp5
    486  27146				   -	       endif
    487  27146				   -	       inc	temp7
    488  27146				   -	       lda	temp7
    489  27146				   -	       cmp	#(<(hsgameslotnumbers+5))
    490  27146				   -	       bcc	plothsindexloop
    491  27146				   -
    492  27146				   -	       jsr	savescreen
    493  27146				   -	       ifnconst	HSSECONDS
    494  27146				   -	       lda	#6
    495  27146				   -	       else
    496  27146				   -	       lda	#HSSECONDS
    497  27146				   -	       endif
    498  27146				   -
    499  27146				   -	       sta	countdownseconds
    500  27146				   -
    501  27146				   -keepdisplayinghs
    502  27146				   -	       jsr	restorescreen
    503  27146				   -
    504  27146				   -	       jsr	setuphsinpt1
    505  27146				   -
    506  27146				   -	       lda	hsnewscoreline
    507  27146				   -	       bpl	carryonkeepdisplayinghs
    508  27146				   -	       jmp	skipenterscorecontrol
    509  27146				   -carryonkeepdisplayinghs
    510  27146				   -
    511  27146				   -
    512  27146				   -	       ifnconst	HSSECONDS
    513  27146				   -	       lda	#6
    514  27146				   -	       else
    515  27146				   -	       lda	#HSSECONDS
    516  27146				   -	       endif
    517  27146				   -
    518  27146				   -	       sta	countdownseconds
    519  27146				   -
    520  27146				   -			;plot the "cursor" initial sprite...
    521  27146				   -	       lda	hsinitialhold
    522  27146				   -
    523  27146				   -	       sta	temp1
    524  27146				   -	       lda	#>(hiscorefont+32)
    525  27146				   -	       sta	temp2
    526  27146				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    527  27146				   -	       sta	temp3	; palette/width
    528  27146				   -	       lda	hscursorx
    529  27146				   -	       asl
    530  27146				   -	       asl
    531  27146				   -	       clc
    532  27146				   -	       adc	#104
    533  27146				   -	       sta	temp4	; X
    534  27146				   -	       lda	hsnewscoreline
    535  27146				   -	       asl
    536  27146				   -	       asl
    537  27146				   -	       asl
    538  27146				   -	       asl
    539  27146				   -	       adc	#((3*16)+HSCURSORY)
    540  27146				   -	       sta	temp5	; Y
    541  27146				   -	       lda	#%01000000
    542  27146				   -	       sta	temp6
    543  27146				   -	       jsr	plotsprite
    544  27146				   -
    545  27146				   -	       ldx	hscursorx
    546  27146				   -	       ldy	hsdisplaymode
    547  27146				   -	       lda	SWCHA
    548  27146				   -	       cpy	#3
    549  27146				   -	       bne	hsskipadjustjoystick1
    550  27146				   -	       asl
    551  27146				   -	       asl
    552  27146				   -	       asl
    553  27146				   -	       asl
    554  27146				   -hsskipadjustjoystick1
    555  27146				   -	       sta	hsswcha
    556  27146				   -	       lda	SWCHB
    557  27146				   -	       and	#%00000010
    558  27146				   -	       bne	hsskipselectswitch
    559  27146				   -	       lda	#%00010000
    560  27146				   -	       sta	hsswcha
    561  27146				   -	       bne	hsdodebouncecheck
    562  27146				   -hsskipselectswitch
    563  27146				   -	       lda	hsswcha
    564  27146				   -	       and	#%00110000
    565  27146				   -	       cmp	#%00110000
    566  27146				   -	       beq	hsjoystickskipped
    567  27146				   -hsdodebouncecheck
    568  27146				   -	       lda	hsjoydebounce
    569  27146				   -	       beq	hsdontdebounce
    570  27146				   -	       jmp	hspostjoystick
    571  27146				   -hsdontdebounce
    572  27146				   -	       ldx	#1	; small tick sound
    573  27146				   -	       jsr	playhssfx
    574  27146				   -	       lda	hsswcha
    575  27146				   -	       and	#%00110000
    576  27146				   -	       ldx	hscursorx
    577  27146				   -	       cmp	#%00100000	; check down
    578  27146				   -	       bne	hsjoycheckup
    579  27146				   -	       ldy	hsinitialhold
    580  27146				   -	       cpx	#0
    581  27146				   -	       bne	skipavoid31_1
    582  27146				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    583  27146				   -	       bne	skipavoid31_1
    584  27146				   -	       dey
    585  27146				   -skipavoid31_1
    586  27146				   -	       dey
    587  27146				   -	       jmp	hssetdebounce
    588  27146				   -hsjoycheckup
    589  27146				   -	       cmp	#%00010000	; check up
    590  27146				   -	       bne	hsjoystickskipped
    591  27146				   -	       ldy	hsinitialhold
    592  27146				   -	       cpx	#0
    593  27146				   -	       bne	skipavoid31_2
    594  27146				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    595  27146				   -	       bne	skipavoid31_2
    596  27146				   -	       iny
    597  27146				   -skipavoid31_2
    598  27146				   -	       iny
    599  27146				   -hssetdebounce
    600  27146				   -	       tya
    601  27146				   -	       and	#31
    602  27146				   -	       sta	hsinitialhold
    603  27146				   -	       lda	#15
    604  27146				   -	       sta	hsjoydebounce
    605  27146				   -	       bne	hspostjoystick
    606  27146				   -hsjoystickskipped
    607  27146				   -			; check the fire button only when the stick isn't engaged
    608  27146				   -	       lda	hsinpt1
    609  27146				   -	       bpl	hsbuttonskipped
    610  27146				   -	       lda	hsjoydebounce
    611  27146				   -	       beq	hsfiredontdebounce
    612  27146				   -	       bne	hspostjoystick
    613  27146				   -hsfiredontdebounce
    614  27146				   -	       lda	hsinitialhold
    615  27146				   -	       cmp	#31
    616  27146				   -	       beq	hsmovecursorback
    617  27146				   -	       inc	hscursorx
    618  27146				   -	       inc	hsinitialpos
    619  27146				   -	       lda	hscursorx
    620  27146				   -	       cmp	#3
    621  27146				   -	       bne	skiphsentryisdone
    622  27146				   -	       lda	#0
    623  27146				   -	       sta	framecounter
    624  27146				   -	       lda	#$ff
    625  27146				   -	       sta	hsnewscoreline
    626  27146				   -	       dec	hsinitialpos
    627  27146				   -	       bne	skiphsentryisdone
    628  27146				   -hsmovecursorback
    629  27146				   -	       lda	hscursorx
    630  27146				   -	       beq	skiphsmovecursorback
    631  27146				   -	       lda	#29
    632  27146				   -	       ldx	hsinitialpos
    633  27146				   -	       sta	HSRAMInitials,x
    634  27146				   -	       dec	hsinitialpos
    635  27146				   -	       dec	hscursorx
    636  27146				   -	       dex
    637  27146				   -	       lda	HSRAMInitials,x
    638  27146				   -	       sta	hsinitialhold
    639  27146				   -skiphsmovecursorback
    640  27146				   -skiphsentryisdone
    641  27146				   -	       ldx	#0
    642  27146				   -	       jsr	playhssfx
    643  27146				   -	       lda	#20
    644  27146				   -	       sta	hsjoydebounce
    645  27146				   -	       bne	hspostjoystick
    646  27146				   -
    647  27146				   -hsbuttonskipped
    648  27146				   -	       lda	#0
    649  27146				   -	       sta	hsjoydebounce
    650  27146				   -hspostjoystick
    651  27146				   -
    652  27146				   -	       ldx	hsinitialpos
    653  27146				   -	       lda	hsinitialhold
    654  27146				   -	       sta	HSRAMInitials,x
    655  27146				   -
    656  27146				   -	       jmp	skiphschasecolors
    657  27146				   -
    658  27146				   -skipenterscorecontrol
    659  27146				   -	       jsr	hschasecolors
    660  27146				   -	       jsr	setuphsinpt1
    661  27146				   -	       lda	hsjoydebounce
    662  27146				   -	       bne	skiphschasecolors
    663  27146				   -	       lda	hsinpt1
    664  27146				   -	       bmi	returnfromhs
    665  27146				   -skiphschasecolors
    666  27146				   -
    667  27146				   -	       jsr	drawscreen
    668  27146				   -
    669  27146				   -	       lda	countdownseconds
    670  27146				   -	       beq	returnfromhs
    671  27146				   -	       jmp	keepdisplayinghs
    672  27146				   -returnfromhs
    673  27146				   -
    674  27146				   -	       ifconst	songdatastart_song_highscore
    675  27146				   -	       lda	hsdisplaymode
    676  27146				   -	       beq	skipclearHSCsong
    677  27146				   -	       lda	#0
    678  27146				   -	       sta	songtempo
    679  27146				   -skipclearHSCsong
    680  27146				   -	       endif
    681  27146				   -	       jsr	drawwait
    682  27146				   -	       jsr	clearscreen
    683  27146				   -	       lda	#0
    684  27146				   -	       ldy	#7
    685  27146				   -	       jsr	blacken320colors
    686  27146				   -	       lda	ssCTRL
    687  27146				   -	       sta	sCTRL
    688  27146				   -	       lda	ssCHARBASE
    689  27146				   -	       sta	sCHARBASE
    690  27146				   -	       rts
    691  27146				   -
    692  27146				   -setuphsinpt1
    693  27146				   -	       lda	#$ff
    694  27146				   -	       sta	hsinpt1
    695  27146				   -	       lda	hsjoydebounce
    696  27146				   -	       beq	skipdebounceadjust
    697  27146				   -	       dec	hsjoydebounce
    698  27146				   -	       bne	skipstorefirebuttonstatus
    699  27146				   -skipdebounceadjust
    700  27146				   -	       lda	SWCHB
    701  27146				   -	       and	#%00000001
    702  27146				   -	       bne	hscheckresetover
    703  27146				   -	       lda	#$ff
    704  27146				   -	       sta	hsinpt1
    705  27146				   -	       rts
    706  27146				   -hscheckresetover
    707  27146				   -	       ldx	hsdisplaymode
    708  27146				   -	       cpx	#3
    709  27146				   -	       bne	hsskipadjustjoyfire1
    710  27146				   -	       lda	sINPT3
    711  27146				   -	       jmp	hsskipadjustjoyfire1done
    712  27146				   -hsskipadjustjoyfire1
    713  27146				   -	       lda	sINPT1
    714  27146				   -hsskipadjustjoyfire1done
    715  27146				   -	       sta	hsinpt1
    716  27146				   -skipstorefirebuttonstatus
    717  27146				   -	       rts
    718  27146				   -
    719  27146				   -blacken320colors
    720  27146				   -	       ldy	#7
    721  27146				   -blacken320colorsloop
    722  27146				   -	       sta	P0C2,y
    723  27146				   -	       dey
    724  27146				   -	       bpl	blacken320colorsloop
    725  27146				   -	       rts
    726  27146				   -
    727  27146				   -hschasecolors
    728  27146				   -	       lda	framecounter
    729  27146				   -	       and	#3
    730  27146				   -	       bne	hschasecolorsreturn
    731  27146				   -	       inc	hscolorchaseindex
    732  27146				   -	       lda	hscolorchaseindex
    733  27146				   -
    734  27146				   -	       sta	P5C2
    735  27146				   -	       sbc	#$02
    736  27146				   -	       sta	P4C2
    737  27146				   -	       sbc	#$02
    738  27146				   -	       sta	P3C2
    739  27146				   -	       sbc	#$02
    740  27146				   -	       sta	P2C2
    741  27146				   -	       sbc	#$02
    742  27146				   -	       sta	P1C2
    743  27146				   -hschasecolorsreturn
    744  27146				   -	       rts
    745  27146				   -
    746  27146				   -playhssfx
    747  27146				   -	       lda	hssfx_lo,x
    748  27146				   -	       sta	temp1
    749  27146				   -	       lda	hssfx_hi,x
    750  27146				   -	       sta	temp2
    751  27146				   -	       lda	#0
    752  27146				   -	       sta	temp3
    753  27146				   -	       jmp	schedulesfx
    754  27146				   -
    755  27146				   -hssfx_lo
    756  27146				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    757  27146				   -hssfx_hi
    758  27146				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    759  27146				   -
    760  27146				   -sfx_hsletterpositionchange
    761  27146				   -	       .byte	$10,$18,$00
    762  27146				   -	       .byte	$02,$06,$08
    763  27146				   -	       .byte	$02,$06,$04
    764  27146				   -	       .byte	$00,$00,$00
    765  27146				   -sfx_hslettertick
    766  27146				   -	       .byte	$10,$18,$00
    767  27146				   -	       .byte	$00,$00,$0a
    768  27146				   -	       .byte	$00,$00,$00
    769  27146				   -
    770  27146				   -highscorelabeladjust1
    771  27146				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    772  27146				   -highscorelabeladjust2
    773  27146				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    774  27146				   -
    775  27146				   -scorevarlo
    776  27146				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    777  27146				   -scorevarhi
    778  27146				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    779  27146				   -
    780  27146				   -	       ifnconst	HSNOLEVELNAMES
    781  27146				   -highscoredifficultytextlo
    782  27146				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    783  27146				   -highscoredifficultytexthi
    784  27146				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    785  27146				   -	       ifnconst	HSCUSTOMLEVELNAMES
    786  27146				   -highscoredifficultytextlen
    787  27146				   -	       .byte	22, 30, 26, 24
    788  27146				   -
    789  27146				   -easylevelname
    790  27146				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    791  27146				   -mediumlevelname
    792  27146				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    793  27146				   -hardlevelname
    794  27146				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    795  27146				   -expertlevelname
    796  27146				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    797  27146				   -	       else
    798  27146				   -	       include	"7800hsgamediffnames.asm"
    799  27146				   -	       endif		; HSCUSTOMLEVELNAMES
    800  27146				   -	       else
    801  27146				   -HSHIGHSCOREStext
    802  27146				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    803  27146				   -	       endif		; HSNOLEVELNAMES
    804  27146				   -
    805  27146				   -highscorelabeltextlo
    806  27146				   -	       .byte	<player0label, <player1label, <player2label
    807  27146				   -highscorelabeltexthi
    808  27146				   -	       .byte	>player0label, >player1label, >player2label
    809  27146				   -
    810  27146				   -player0label
    811  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    812  27146				   -
    813  27146				   -player1label
    814  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    815  27146				   -
    816  27146				   -player2label
    817  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    818  27146				   -
    819  27146				   -
    820  27146				   -	       ifconst	HSGAMENAMELEN
    821  27146				   -HSGAMENAMEtable
    822  27146				   -	       include	"7800hsgamename.asm"
    823  27146				   -	       endif
    824  27146				   -	       ifconst	HSGAMERANKS
    825  27146				   -	       include	"7800hsgameranks.asm"
    826  27146				   -highscoreranklabel
    827  27146				   -	       .byte	$11,$00,$0d,$0a,$1a
    828  27146				   -	       endif
    829  27146				   -
    830  27146				   -			;ensure our table doesn't wrap a page...
    831  27146				   -	       if	((<*)>251)
    832  27146				   -	       align	256
    833  27146				   -	       endif
    834  27146				   -hsgameslotnumbers
    835  27146				   -	       .byte	33,34,35,36,37
    836  27146				   -	       endif
    837  27146				   -
    838  27146				   -loaddifficultytable
    839  27146				   -	       lda	gamedifficulty
    840  27146				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    841  27146				   -	       sta	gamedifficulty
    842  27146				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    843  27146				   -	       bne	loaddifficultytablecontinue1
    844  27146				   -	       rts		; this high score difficulty table is already loaded
    845  27146				   -loaddifficultytablecontinue1
    846  27146				   -	       lda	gamedifficulty
    847  27146				   -	       sta	hsdifficulty
    848  27146				   -			;we need to check the device for the table
    849  27146				   -	       lda	hsdevice
    850  27146				   -	       bne	loaddifficultytablecontinue2
    851  27146				   -			; there's no save device. clear out this table.
    852  27146				   -	       jmp	cleardifficultytablemem
    853  27146				   -loaddifficultytablecontinue2
    854  27146				   -	       lda	hsdevice
    855  27146				   -	       and	#1
    856  27146				   -	       beq	memdeviceisntHSC
    857  27146				   -	       jmp	loaddifficultytableHSC
    858  27146				   -memdeviceisntHSC
    859  27146				   -	       jmp	loaddifficultytableAVOX
    860  27146				   -
    861  27146				   -savedifficultytable
    862  27146				   -			;*** we need to check wich device we should use...
    863  27146				   -	       lda	hsdevice
    864  27146				   -	       bne	savedifficultytablerealdevice
    865  27146				   -	       rts		; its a ram device
    866  27146				   -savedifficultytablerealdevice
    867  27146				   -	       and	#1
    868  27146				   -	       beq	savememdeviceisntHSC
    869  27146				   -	       jmp	savedifficultytableHSC
    870  27146				   -savememdeviceisntHSC
    871  27146				   -	       jmp	savedifficultytableAVOX
    872  27146				   -
    873  27146				   -savedifficultytableAVOX
    874  27146				   -			; the load call already setup the memory structure and atarivox memory location
    875  27146				   -	       jsr	savealoadedHSCtablecontinue
    876  27146				   -savedifficultytableAVOXskipconvert
    877  27146				   -	       lda	#HSIDHI
    878  27146				   -	       sta	eeprombuffer
    879  27146				   -	       lda	#HSIDLO
    880  27146				   -	       sta	eeprombuffer+1
    881  27146				   -	       lda	hsdifficulty
    882  27146				   -	       sta	eeprombuffer+2
    883  27146				   -	       lda	#32
    884  27146				   -	       jsr	AVoxWriteBytes
    885  27146				   -	       rts
    886  27146				   -
    887  27146				   -savedifficultytableHSC
    888  27146				   -			;we always load a table before reaching here, so the
    889  27146				   -			;memory structures from the load should be intact...
    890  27146				   -	       ldy	hsgameslot
    891  27146				   -	       bpl	savealoadedHSCtable
    892  27146				   -	       rts
    893  27146				   -savealoadedHSCtable
    894  27146				   -	       lda	HSCGameDifficulty,y
    895  27146				   -	       cmp	#$7F
    896  27146				   -	       bne	savealoadedHSCtablecontinue
    897  27146				   -	       jsr	initializeHSCtableentry
    898  27146				   -savealoadedHSCtablecontinue
    899  27146				   -			;convert our RAM table to HSC format and write it out...
    900  27146				   -	       ldy	#0
    901  27146				   -	       ldx	#0
    902  27146				   -savedifficultytableScores
    903  27146				   -
    904  27146				   -	       lda	HSRAMInitials,x
    905  27146				   -	       sta	temp3
    906  27146				   -	       lda	HSRAMInitials+1,x
    907  27146				   -	       sta	temp4
    908  27146				   -	       lda	HSRAMInitials+2,x
    909  27146				   -	       sta	temp5
    910  27146				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    911  27146				   -
    912  27146				   -	       lda	temp1
    913  27146				   -	       sta	(HSGameTableLo),y
    914  27146				   -	       iny
    915  27146				   -	       lda	temp2
    916  27146				   -	       sta	(HSGameTableLo),y
    917  27146				   -	       iny
    918  27146				   -
    919  27146				   -	       lda	HSRAMScores,x
    920  27146				   -	       sta	(HSGameTableLo),y
    921  27146				   -	       iny
    922  27146				   -	       lda	HSRAMScores+1,x
    923  27146				   -	       sta	(HSGameTableLo),y
    924  27146				   -	       iny
    925  27146				   -	       lda	HSRAMScores+2,x
    926  27146				   -	       sta	(HSGameTableLo),y
    927  27146				   -	       iny
    928  27146				   -	       inx
    929  27146				   -	       inx
    930  27146				   -	       inx		; +3
    931  27146				   -	       cpx	#15
    932  27146				   -	       bne	savedifficultytableScores
    933  27146				   -	       rts
    934  27146				   -
    935  27146				   -loaddifficultytableHSC
    936  27146				   -			; routine responsible for loading the difficulty table from HSC
    937  27146				   -	       jsr	findindexHSC
    938  27146				   -	       ldy	hsgameslot
    939  27146				   -	       lda	HSCGameDifficulty,y
    940  27146				   -	       cmp	#$7F
    941  27146				   -	       bne	loaddifficultytableHSCcontinue
    942  27146				   -			;there was an error. use a new RAM table instead...
    943  27146				   -	       jmp	cleardifficultytablemem
    944  27146				   -loaddifficultytableHSCcontinue
    945  27146				   -			; parse the data into the HS memory...
    946  27146				   -	       ldy	#0
    947  27146				   -	       ldx	#0
    948  27146				   -loaddifficultytableScores
    949  27146				   -	       lda	(HSGameTableLo),y
    950  27146				   -	       sta	temp1
    951  27146				   -	       iny
    952  27146				   -	       lda	(HSGameTableLo),y
    953  27146				   -	       sta	temp2
    954  27146				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    955  27146				   -	       iny
    956  27146				   -	       lda	(HSGameTableLo),y
    957  27146				   -	       sta	HSRAMScores,x
    958  27146				   -	       lda	temp3
    959  27146				   -	       sta	HSRAMInitials,x
    960  27146				   -	       inx
    961  27146				   -	       iny
    962  27146				   -	       lda	(HSGameTableLo),y
    963  27146				   -	       sta	HSRAMScores,x
    964  27146				   -	       lda	temp4
    965  27146				   -	       sta	HSRAMInitials,x
    966  27146				   -	       inx
    967  27146				   -	       iny
    968  27146				   -	       lda	(HSGameTableLo),y
    969  27146				   -	       sta	HSRAMScores,x
    970  27146				   -	       lda	temp5
    971  27146				   -	       sta	HSRAMInitials,x
    972  27146				   -	       inx
    973  27146				   -	       iny
    974  27146				   -	       cpx	#15
    975  27146				   -	       bne	loaddifficultytableScores
    976  27146				   -	       rts
    977  27146				   -
    978  27146				   -decodeHSCInitials
    979  27146				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    980  27146				   -			; 2 bytes are packed in the form: 22211111 22_33333
    981  27146				   -	       lda	#0
    982  27146				   -	       sta	temp4
    983  27146				   -	       lda	temp1
    984  27146				   -	       and	#%00011111
    985  27146				   -	       sta	temp3
    986  27146				   -
    987  27146				   -	       lda	temp2
    988  27146				   -	       and	#%00011111
    989  27146				   -	       sta	temp5
    990  27146				   -
    991  27146				   -	       lda	temp1
    992  27146				   -	       asl
    993  27146				   -	       rol	temp4
    994  27146				   -	       asl
    995  27146				   -	       rol	temp4
    996  27146				   -	       asl
    997  27146				   -	       rol	temp4
    998  27146				   -	       lda	temp2
    999  27146				   -	       asl
   1000  27146				   -	       rol	temp4
   1001  27146				   -	       asl
   1002  27146				   -	       rol	temp4
   1003  27146				   -	       rts
   1004  27146				   -encodeHSCInitials
   1005  27146				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1006  27146				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1007  27146				   -			; start with packing temp1...
   1008  27146				   -	       lda	temp4
   1009  27146				   -	       and	#%00011100
   1010  27146				   -	       sta	temp1
   1011  27146				   -	       asl	temp1
   1012  27146				   -	       asl	temp1
   1013  27146				   -	       asl	temp1
   1014  27146				   -	       lda	temp3
   1015  27146				   -	       and	#%00011111
   1016  27146				   -	       ora	temp1
   1017  27146				   -	       sta	temp1
   1018  27146				   -			; ...temp1 is now packed, on to temp2...
   1019  27146				   -	       lda	temp5
   1020  27146				   -	       asl
   1021  27146				   -	       asl
   1022  27146				   -	       ror	temp4
   1023  27146				   -	       ror
   1024  27146				   -	       ror	temp4
   1025  27146				   -	       ror
   1026  27146				   -	       sta	temp2
   1027  27146				   -	       rts
   1028  27146				   -
   1029  27146				   -findindexHSCerror
   1030  27146				   -			;the HSC is stuffed. return the bad slot flag
   1031  27146				   -	       ldy	#$ff
   1032  27146				   -	       sty	hsgameslot
   1033  27146				   -	       rts
   1034  27146				   -
   1035  27146				   -findindexHSC
   1036  27146				   -HSCGameID1 =	$1029
   1037  27146				   -HSCGameID2 =	$106E
   1038  27146				   -HSCGameDifficulty =	$10B3
   1039  27146				   -HSCGameIndex =	$10F8
   1040  27146				   -			; routine responsible for finding the game index from HSC
   1041  27146				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1042  27146				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1043  27146				   -	       ldy	#69	; start +1 to account for the dey
   1044  27146				   -findindexHSCloop
   1045  27146				   -	       dey
   1046  27146				   -	       bmi	findindexHSCerror
   1047  27146				   -	       lda	HSCGameDifficulty,y
   1048  27146				   -	       cmp	#$7F
   1049  27146				   -	       beq	findourindexHSC
   1050  27146				   -	       cmp	gamedifficulty
   1051  27146				   -	       bne	findindexHSCloop
   1052  27146				   -	       lda	HSCGameID1,y
   1053  27146				   -	       cmp	#HSIDHI
   1054  27146				   -	       bne	findindexHSCloop
   1055  27146				   -	       lda	HSCGameID2,y
   1056  27146				   -	       cmp	#HSIDLO
   1057  27146				   -	       bne	findindexHSCloop
   1058  27146				   -findourindexHSC
   1059  27146				   -			; if we're here we found our index in the table
   1060  27146				   -			; or we found the first empty one
   1061  27146				   -	       sty	hsgameslot
   1062  27146				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1063  27146				   -	       rts
   1064  27146				   -
   1065  27146				   -
   1066  27146				   -initializeHSCtableentry
   1067  27146				   -	       ldy	hsgameslot
   1068  27146				   -			; we need to make a new entry...
   1069  27146				   -	       lda	#HSIDHI
   1070  27146				   -	       sta	HSCGameID1,y
   1071  27146				   -	       lda	#HSIDLO
   1072  27146				   -	       sta	HSCGameID2,y
   1073  27146				   -	       lda	gamedifficulty
   1074  27146				   -	       sta	HSCGameDifficulty,y
   1075  27146				   -	       ldx	#0
   1076  27146				   -fixHSDGameDifficultylistLoop
   1077  27146				   -	       inx
   1078  27146				   -	       txa
   1079  27146				   -	       sta	HSCGameIndex,y
   1080  27146				   -	       iny
   1081  27146				   -	       cpy	#69
   1082  27146				   -	       bne	fixHSDGameDifficultylistLoop
   1083  27146				   -	       rts
   1084  27146				   -
   1085  27146				   -setupHSCGamepointer
   1086  27146				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1087  27146				   -	       lda	#$17
   1088  27146				   -	       sta	HSGameTableHi
   1089  27146				   -	       lda	#$FA
   1090  27146				   -	       sta	HSGameTableLo
   1091  27146				   -setupHSCGamepointerLoop
   1092  27146				   -	       lda	HSGameTableLo
   1093  27146				   -	       sec
   1094  27146				   -	       sbc	#25
   1095  27146				   -	       sta	HSGameTableLo
   1096  27146				   -	       lda	HSGameTableHi
   1097  27146				   -	       sbc	#0
   1098  27146				   -	       sta	HSGameTableHi
   1099  27146				   -	       iny
   1100  27146				   -	       cpy	#69
   1101  27146				   -	       bne	setupHSCGamepointerLoop
   1102  27146				   -	       rts
   1103  27146				   -
   1104  27146				   -loaddifficultytableAVOX
   1105  27146				   -			; routine responsible for loading the difficulty table from Avox
   1106  27146				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1107  27146				   -	       lda	#>(eeprombuffer+3)
   1108  27146				   -	       sta	HSGameTableHi
   1109  27146				   -	       lda	#<(eeprombuffer+3)
   1110  27146				   -	       sta	HSGameTableLo
   1111  27146				   -
   1112  27146				   -			; the start location in EEPROM, subtract 32...
   1113  27146				   -	       lda	#$5F
   1114  27146				   -	       sta	HSVoxHi
   1115  27146				   -	       lda	#$E0
   1116  27146				   -	       sta	HSVoxLo
   1117  27146				   -	       lda	#0
   1118  27146				   -	       sta	temp1
   1119  27146				   -loaddifficultytableAVOXloop
   1120  27146				   -	       inc	temp1
   1121  27146				   -	       beq	loaddifficultytableAVOXfull
   1122  27146				   -	       clc
   1123  27146				   -	       lda	HSVoxLo
   1124  27146				   -	       adc	#32
   1125  27146				   -	       sta	HSVoxLo
   1126  27146				   -	       lda	HSVoxHi
   1127  27146				   -	       adc	#0
   1128  27146				   -	       sta	HSVoxHi
   1129  27146				   -	       lda	#3
   1130  27146				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1131  27146				   -	       lda	eeprombuffer
   1132  27146				   -	       cmp	#$FF
   1133  27146				   -	       beq	loaddifficultytableAVOXempty
   1134  27146				   -	       cmp	#HSIDHI
   1135  27146				   -	       bne	loaddifficultytableAVOXloop
   1136  27146				   -	       lda	eeprombuffer+1
   1137  27146				   -	       cmp	#HSIDLO
   1138  27146				   -	       bne	loaddifficultytableAVOXloop
   1139  27146				   -	       lda	eeprombuffer+2
   1140  27146				   -	       cmp	gamedifficulty
   1141  27146				   -	       bne	loaddifficultytableAVOXloop
   1142  27146				   -loaddifficultytableAVOXdone
   1143  27146				   -	       lda	#32
   1144  27146				   -	       jsr	AVoxReadBytes
   1145  27146				   -	       jsr	loaddifficultytableHSCcontinue
   1146  27146				   -	       rts
   1147  27146				   -loaddifficultytableAVOXfull
   1148  27146				   -	       lda	#0
   1149  27146				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1150  27146				   -loaddifficultytableAVOXempty
   1151  27146				   -	       jmp	cleardifficultytablemem
   1152  27146				   -	       rts
   1153  27146				   -
   1154  27146				   -cleardifficultytablemem
   1155  27146				   -	       ldy	#29
   1156  27146				   -	       lda	#0
   1157  27146				   -cleardifficultytablememloop
   1158  27146				   -	       sta	HSRAMTable,y
   1159  27146				   -	       dey
   1160  27146				   -	       bpl	cleardifficultytablememloop
   1161  27146				   -	       rts
   1162  27146				   -hiscoremoduleend
   1163  27146				   -
   1164  27146				   -	       echo	"  hiscore assembly: ",[(hiscoremoduleend-hiscoremodulestart)]d," bytes"
   1165  27146				   -
   1166  27146				   -	       ifconst	DOUBLEWIDE
   1167  27146				   -plotvaluedw
   1168  27146				   -plotdigitcount =	temp6
   1169  27146				   -	       lda	#0
   1170  27146				   -	       tay
   1171  27146				   -	       ldx	valbufend
   1172  27146				   -
   1173  27146				   -	       lda	plotdigitcount
   1174  27146				   -	       and	#1
   1175  27146				   -	       beq	pvnibble2chardw
   1176  27146				   -	       lda	#0
   1177  27146				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1178  27146				   -	       beq	pvnibble2char_skipnibbledw
   1179  27146				   -
   1180  27146				   -pvnibble2chardw
   1181  27146				   -			; high nibble...
   1182  27146				   -	       lda	(temp7),y
   1183  27146				   -	       and	#$f0
   1184  27146				   -	       lsr
   1185  27146				   -	       lsr
   1186  27146				   -	       lsr
   1187  27146				   -	       lsr
   1188  27146				   -
   1189  27146				   -	       clc
   1190  27146				   -	       adc	temp1	; add the offset to character graphics to our value
   1191  27146				   -	       sta	VALBUFFER,x
   1192  27146				   -	       inx
   1193  27146				   -	       dec	plotdigitcount
   1194  27146				   -pvnibble2char_skipnibbledw
   1195  27146				   -			; low nibble...
   1196  27146				   -	       lda	(temp7),y
   1197  27146				   -	       and	#$0f
   1198  27146				   -	       clc
   1199  27146				   -	       adc	temp1	; add the offset to character graphics to our value
   1200  27146				   -	       sta	VALBUFFER,x
   1201  27146				   -	       inx
   1202  27146				   -	       iny
   1203  27146				   -
   1204  27146				   -	       dec	plotdigitcount
   1205  27146				   -	       bne	pvnibble2chardw
   1206  27146				   -			;point to the start of our valuebuffer
   1207  27146				   -	       clc
   1208  27146				   -	       lda	#<VALBUFFER
   1209  27146				   -	       adc	valbufend
   1210  27146				   -	       sta	temp1
   1211  27146				   -	       lda	#>VALBUFFER
   1212  27146				   -	       adc	#0
   1213  27146				   -	       sta	temp2
   1214  27146				   -
   1215  27146				   -			;advance valbufend to the end of our value buffer
   1216  27146				   -	       stx	valbufend
   1217  27146				   -
   1218  27146				   -	       ifnconst	plotvalueonscreen
   1219  27146				   -	       jmp	plotcharacters
   1220  27146				   -	       else
   1221  27146				   -	       jmp	plotcharacterslive
   1222  27146				   -	       endif
   1223  27146				   -	       endif		; DOUBLEWIDE
   1224  27146				   -
   1225  27146					       endif		; HSSUPPORT
   1226  27146
------- FILE c:\Users\Steve\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer.bas.asm
   2159  27146					       endif
   2160  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2161  27146
   2162  27146							;standard routimes needed for pretty much all games
   2163  27146
   2164  27146							; some definitions used with "set debug color"
   2165  27146			00 91	    DEBUGCALC  =	$91
   2166  27146			00 41	    DEBUGWASTE =	$41
   2167  27146			00 c1	    DEBUGDRAW  =	$C1
   2168  27146
   2169  27146							;NMI and IRQ handlers
   2170  27146				    NMI
   2171  27146							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   2172  27146			48		       pha		; save A
   2173  27147			a5 4d		       lda	visibleover
   2174  27149			49 ff		       eor	#255
   2175  2714b			85 4d		       sta	visibleover
   2176  2714d				   -	       ifconst	DEBUGINTERRUPT
   2177  2714d				   -	       and	#$93
   2178  2714d				   -	       sta	BACKGRND
   2179  2714d					       endif
   2180  2714d			ce b2 01	       dec	interruptindex
   2181  27150			d0 03		       bne	skipreallyoffvisible
   2182  27152			4c ad f1	       jmp	reallyoffvisible
   2183  27155				    skipreallyoffvisible
   2184  27155			a5 4d		       lda	visibleover
   2185  27157			d0 03		       bne	carryontopscreenroutine
   2186  27159			4c ab f1	       jmp	skiptopscreenroutine
   2187  2715c				    carryontopscreenroutine
   2188  2715c			8a		       txa		; save X+Y
   2189  2715d			48		       pha
   2190  2715e			98		       tya
   2191  2715f			48		       pha
   2192  27160			d8		       cld
   2193  27161				   -	       ifconst	.topscreenroutine
   2194  27161				   -	       jsr	.topscreenroutine
   2195  27161					       endif
   2196  27161					       ifnconst	CANARYOFF
   2197  27161			ad d1 01	       lda	canary
   2198  27164			f0 0c		       beq	skipcanarytriggered
   2199  27166			a9 45		       lda	#$45
   2200  27168			85 20		       sta	BACKGRND
   2201  2716a			a9 60		       lda	#$60
   2202  2716c			85 3c		       sta	CTRL
   2203  2716e			8d 07 21	       sta	sCTRL
   2204  27171			02		       .byte.b	$02	; KIL/JAM
   2205  27172					       endif
   2206  27172				    skipcanarytriggered
   2207  27172			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   2208  27175
   2209  27175							; ** Other important routines that need to regularly run, and can run onscreen.
   2210  27175							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   2211  27175
   2212  27175				   -	       ifconst	LONGCONTROLLERREAD
   2213  27175				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   2214  27175				   -	       ldy	port1control
   2215  27175				   -	       lda	longreadtype,y
   2216  27175				   -	       beq	LLRET1
   2217  27175				   -	       tay
   2218  27175				   -	       lda	longreadroutinehiP1,y
   2219  27175				   -	       sta	inttemp4
   2220  27175				   -	       lda	longreadroutineloP1,y
   2221  27175				   -	       sta	inttemp3
   2222  27175				   -	       jmp	(inttemp3)
   2223  27175				   -LLRET1
   2224  27175				   -	       ldy	port0control
   2225  27175				   -	       lda	longreadtype,y
   2226  27175				   -	       beq	LLRET0
   2227  27175				   -	       tay
   2228  27175				   -	       lda	longreadroutinehiP0,y
   2229  27175				   -	       sta	inttemp4
   2230  27175				   -	       lda	longreadroutineloP0,y
   2231  27175				   -	       sta	inttemp3
   2232  27175				   -	       jmp	(inttemp3)
   2233  27175				   -LLRET0
   2234  27175				   -
   2235  27175				   -
   2236  27175				   -	       ifconst	PADDLERANGE
   2237  27175				   -TIMEVAL    =	PADDLERANGE
   2238  27175				   -	       else
   2239  27175				   -TIMEVAL    =	160
   2240  27175				   -	       endif
   2241  27175				   -TIMEOFFSET =	10
   2242  27175				   -
   2243  27175					       endif		; LONGCONTROLLERREAD
   2244  27175
   2245  27175
   2246  27175			20 28 f3	       jsr	servicesfxchannels
   2247  27178				   -	       ifconst	MUSICTRACKER
   2248  27178				   -	       jsr	servicesong
   2249  27178					       endif		; MUSICTRACKER
   2250  27178
   2251  27178			ee a4 01	       inc	framecounter
   2252  2717b			ad a4 01	       lda	framecounter
   2253  2717e			29 3f		       and	#63
   2254  27180			d0 08		       bne	skipcountdownseconds
   2255  27182			ad a5 01	       lda	countdownseconds
   2256  27185			f0 03		       beq	skipcountdownseconds
   2257  27187			ce a5 01	       dec	countdownseconds
   2258  2718a				    skipcountdownseconds
   2259  2718a
   2260  2718a			a2 01		       ldx	#1
   2261  2718c				    buttonreadloop
   2262  2718c			8a		       txa
   2263  2718d			48		       pha
   2264  2718e			bc b7 01	       ldy	port0control,x
   2265  27191			b9 09 f3	       lda	buttonhandlerlo,y
   2266  27194			85 da		       sta	inttemp3
   2267  27196			b9 fe f2	       lda	buttonhandlerhi,y
   2268  27199			85 db		       sta	inttemp4
   2269  2719b			05 da		       ora	inttemp3
   2270  2719d			f0 03		       beq	buttonreadloopreturn
   2271  2719f			6c da 00	       jmp	(inttemp3)
   2272  271a2				    buttonreadloopreturn
   2273  271a2			68		       pla
   2274  271a3			aa		       tax
   2275  271a4			ca		       dex
   2276  271a5			10 e5		       bpl	buttonreadloop
   2277  271a7
   2278  271a7				   -	       ifconst	KEYPADSUPPORT
   2279  271a7				   -	       jsr	keypadrowselect
   2280  271a7					       endif		; KEYPADSUPPORT
   2281  271a7
   2282  271a7
   2283  271a7				   -	       ifconst	DOUBLEBUFFER
   2284  271a7				   -	       lda	doublebufferminimumframeindex
   2285  271a7				   -	       beq	skipdoublebufferminimumframeindexadjust
   2286  271a7				   -	       dec	doublebufferminimumframeindex
   2287  271a7				   -skipdoublebufferminimumframeindexadjust
   2288  271a7					       endif
   2289  271a7
   2290  271a7			68		       pla
   2291  271a8			a8		       tay
   2292  271a9			68		       pla
   2293  271aa			aa		       tax
   2294  271ab				    skiptopscreenroutine
   2295  271ab			68		       pla
   2296  271ac				    IRQ
   2297  271ac			40		       RTI
   2298  271ad
   2299  271ad				   -	       ifconst	LONGCONTROLLERREAD
   2300  271ad				   -
   2301  271ad				   -longreadtype
   2302  271ad				   -	       .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   2303  271ad				   -	       .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   2304  271ad				   -	       .byte	3, 3, 0	; STMOUSE  AMOUSE    ATARIVOX
   2305  271ad				   -
   2306  271ad				   -longreadroutineloP0
   2307  271ad				   -	       .byte	<LLRET0	;  0 = no routine
   2308  271ad				   -	       .byte	<paddleport0update	;  1 = paddle
   2309  271ad				   -	       .byte	<trakball0update	;  2 = trakball
   2310  271ad				   -	       .byte	<mouse0update	;  3 = mouse
   2311  271ad				   -
   2312  271ad				   -longreadroutinehiP0
   2313  271ad				   -	       .byte	>LLRET0	;  0 = no routine
   2314  271ad				   -	       .byte	>paddleport0update	;  1 = paddle
   2315  271ad				   -	       .byte	>trakball0update	;  2 = trackball
   2316  271ad				   -	       .byte	>mouse0update	;  3 = mouse
   2317  271ad				   -
   2318  271ad				   -longreadroutineloP1
   2319  271ad				   -	       .byte	<LLRET1	;  0 = no routine
   2320  271ad				   -	       .byte	<paddleport1update	;  1 = paddle
   2321  271ad				   -	       .byte	<trakball1update	;  2 = trakball
   2322  271ad				   -	       .byte	<mouse1update	;  3 = mouse
   2323  271ad				   -
   2324  271ad				   -longreadroutinehiP1
   2325  271ad				   -	       .byte	>LLRET1	;  0 = no routine
   2326  271ad				   -	       .byte	>paddleport1update	;  1 = paddle
   2327  271ad				   -	       .byte	>trakball1update	;  2 = trackball
   2328  271ad				   -	       .byte	>mouse1update	;  3 = mouse
   2329  271ad				   -
   2330  271ad				   -
   2331  271ad				   -SETTIM64T
   2332  271ad				   -	       bne	skipdefaulttime
   2333  271ad				   -	       ifnconst	PADDLESMOOTHINGOFF
   2334  271ad				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   2335  271ad				   -	       else
   2336  271ad				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   2337  271ad				   -	       endif
   2338  271ad				   -skipdefaulttime
   2339  271ad				   -	       tay
   2340  271ad				   -	       dey
   2341  271ad				   -.setTIM64Tloop
   2342  271ad				   -	       sta	TIM64T
   2343  271ad				   -	       cpy	INTIM
   2344  271ad				   -	       bne	.setTIM64Tloop
   2345  271ad				   -	       rts
   2346  271ad					       endif		; LONGCONTROLLERREAD
   2347  271ad
   2348  271ad				    reallyoffvisible
   2349  271ad			85 24		       sta	WSYNC
   2350  271af
   2351  271af			a9 00		       lda	#0
   2352  271b1			85 4d		       sta	visibleover
   2353  271b3				   -	       ifconst	DEBUGINTERRUPT
   2354  271b3				   -	       sta	BACKGRND
   2355  271b3					       endif
   2356  271b3
   2357  271b3			a9 03		       lda	#3
   2358  271b5			8d b2 01	       sta	interruptindex
   2359  271b8
   2360  271b8			8a		       txa
   2361  271b9			48		       pha
   2362  271ba			98		       tya
   2363  271bb			48		       pha
   2364  271bc			d8		       cld
   2365  271bd
   2366  271bd			20 a0 f2	       jsr	uninterruptableroutines
   2367  271c0
   2368  271c0				   -	       ifconst	.userinterrupt
   2369  271c0				   -	       jsr	.userinterrupt
   2370  271c0					       endif
   2371  271c0
   2372  271c0				   -	       ifconst	KEYPADSUPPORT
   2373  271c0				   -	       jsr	keypadcolumnread
   2374  271c0					       endif
   2375  271c0
   2376  271c0			68		       pla
   2377  271c1			a8		       tay
   2378  271c2			68		       pla
   2379  271c3			aa		       tax
   2380  271c4			68		       pla
   2381  271c5			40		       RTI
   2382  271c6
   2383  271c6				    clearscreen
   2384  271c6			a2 0b		       ldx	#(WZONECOUNT-1)
   2385  271c8			a9 00		       lda	#0
   2386  271ca				    clearscreenloop
   2387  271ca			95 65		       sta	dlend,x
   2388  271cc			ca		       dex
   2389  271cd			10 fb		       bpl	clearscreenloop
   2390  271cf			a9 00		       lda	#0
   2391  271d1			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   2392  271d4			8d ae 01	       sta	valbufendsave
   2393  271d7			60		       rts
   2394  271d8
   2395  271d8				    restorescreen
   2396  271d8			a2 0b		       ldx	#(WZONECOUNT-1)
   2397  271da			a9 00		       lda	#0
   2398  271dc				    restorescreenloop
   2399  271dc			b5 82		       lda	dlendsave,x
   2400  271de			95 65		       sta	dlend,x
   2401  271e0			ca		       dex
   2402  271e1			10 f9		       bpl	restorescreenloop
   2403  271e3			ad ae 01	       lda	valbufendsave
   2404  271e6			8d ad 01	       sta	valbufend
   2405  271e9			60		       rts
   2406  271ea
   2407  271ea				    savescreen
   2408  271ea			a2 0b		       ldx	#(WZONECOUNT-1)
   2409  271ec				    savescreenloop
   2410  271ec			b5 65		       lda	dlend,x
   2411  271ee			95 82		       sta	dlendsave,x
   2412  271f0			ca		       dex
   2413  271f1			10 f9		       bpl	savescreenloop
   2414  271f3			ad ad 01	       lda	valbufend
   2415  271f6			8d ae 01	       sta	valbufendsave
   2416  271f9				   -	       ifconst	DOUBLEBUFFER
   2417  271f9				   -	       lda	doublebufferstate
   2418  271f9				   -	       beq	savescreenrts
   2419  271f9				   -	       lda	#1
   2420  271f9				   -	       sta	doublebufferbufferdirty
   2421  271f9				   -savescreenrts
   2422  271f9					       endif		; DOUBLEBUFFER
   2423  271f9			60		       rts
   2424  271fa
   2425  271fa				    drawscreen
   2426  271fa
   2427  271fa			a9 00		       lda	#0
   2428  271fc			85 42		       sta	temp1	; not B&W if we're here...
   2429  271fe
   2430  271fe				    drawscreenwait
   2431  271fe			a5 4d		       lda	visibleover
   2432  27200			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2433  27202
   2434  27202							;restore some registers in case the game changed them mid-screen...
   2435  27202			ad 07 21	       lda	sCTRL
   2436  27205			05 42		       ora	temp1
   2437  27207			85 3c		       sta	CTRL
   2438  27209			ad 0b 21	       lda	sCHARBASE
   2439  2720c			85 34		       sta	CHARBASE
   2440  2720e
   2441  2720e							;ensure all of the display list is terminated...
   2442  2720e			20 86 f2	       jsr	terminatedisplaylist
   2443  27211
   2444  27211					       ifnconst	pauseroutineoff
   2445  27211			20 1c f2	       jsr	pauseroutine
   2446  27214					       endif		; pauseroutineoff
   2447  27214
   2448  27214							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2449  27214							; delaying a full frame, but still allowing time for basic calculations.
   2450  27214				    visiblescreenstartedwait
   2451  27214			a5 4d		       lda	visibleover
   2452  27216			f0 fc		       beq	visiblescreenstartedwait
   2453  27218				    visiblescreenstartedwaitdone
   2454  27218			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2455  2721b			60		       rts
   2456  2721c
   2457  2721c					       ifnconst	pauseroutineoff
   2458  2721c							; check to see if pause was pressed and released
   2459  2721c				    pauseroutine
   2460  2721c			ad b3 01	       lda	pausedisable
   2461  2721f			d0 55		       bne	leavepauseroutine
   2462  27221			a9 08		       lda	#8
   2463  27223			2c 82 02	       bit	SWCHB
   2464  27226			f0 29		       beq	pausepressed
   2465  27228
   2466  27228					       ifnconst	SOFTRESETASPAUSEOFF
   2467  27228					       ifnconst	MOUSESUPPORT
   2468  27228					       ifnconst	TRAKBALLSUPPORT
   2469  27228			ad 80 02	       lda	SWCHA	; then check the soft "RESET" joysick code...
   2470  2722b			29 70		       and	#%01110000	; _LDU
   2471  2722d			f0 22		       beq	pausepressed
   2472  2722f					       endif
   2473  2722f					       endif
   2474  2722f					       endif
   2475  2722f
   2476  2722f							;pause isn't pressed
   2477  2722f			a9 00		       lda	#0
   2478  27231			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2479  27234
   2480  27234							;check if we're in an already paused state
   2481  27234			ad 00 21	       lda	pausestate
   2482  27237			f0 3d		       beq	leavepauseroutine	; nope, leave
   2483  27239
   2484  27239			c9 01		       cmp	#1	; last frame was the start of pausing
   2485  2723b			f0 32		       beq	enterpausestate2	; move from state 1 to 2
   2486  2723d
   2487  2723d			c9 02		       cmp	#2
   2488  2723f			f0 3b		       beq	carryonpausing
   2489  27241
   2490  27241							;pausestate must be >2, which means we're ending an unpause 
   2491  27241			a9 00		       lda	#0
   2492  27243			8d ac 01	       sta	pausebuttonflag
   2493  27246			8d 00 21	       sta	pausestate
   2494  27249			ad 07 21	       lda	sCTRL
   2495  2724c			85 3c		       sta	CTRL
   2496  2724e			4c 76 f2	       jmp	leavepauseroutine
   2497  27251
   2498  27251				    pausepressed
   2499  27251							;pause is pressed
   2500  27251			ad ac 01	       lda	pausebuttonflag
   2501  27254			c9 ff		       cmp	#$ff
   2502  27256			f0 24		       beq	carryonpausing
   2503  27258
   2504  27258							;its a new press, increment the state
   2505  27258			ee 00 21	       inc	pausestate
   2506  2725b
   2507  2725b							;silence volume at the start and end of pausing
   2508  2725b			a9 00		       lda	#0
   2509  2725d			85 19		       sta	AUDV0
   2510  2725f			85 1a		       sta	AUDV1
   2511  27261
   2512  27261					       ifconst	pokeysupport
   2513  27261			a0 07		       ldy	#7
   2514  27263				    pausesilencepokeyaudioloop
   2515  27263			91 4b		       sta	(pokeybase),y
   2516  27265			88		       dey
   2517  27266			10 fb		       bpl	pausesilencepokeyaudioloop
   2518  27268					       endif		; pokeysupport
   2519  27268
   2520  27268			a9 ff		       lda	#$ff
   2521  2726a			8d ac 01	       sta	pausebuttonflag
   2522  2726d			d0 0d		       bne	carryonpausing
   2523  2726f
   2524  2726f				    enterpausestate2
   2525  2726f			a9 02		       lda	#2
   2526  27271			8d 00 21	       sta	pausestate
   2527  27274			d0 06		       bne	carryonpausing
   2528  27276				    leavepauseroutine
   2529  27276			ad 07 21	       lda	sCTRL
   2530  27279			85 3c		       sta	CTRL
   2531  2727b			60		       rts
   2532  2727c				    carryonpausing
   2533  2727c				   -	       ifconst	.pause
   2534  2727c				   -	       jsr	.pause
   2535  2727c					       endif		; .pause
   2536  2727c			ad 07 21	       lda	sCTRL
   2537  2727f			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2538  27281			85 3c		       sta	CTRL
   2539  27283			4c 1c f2	       jmp	pauseroutine
   2540  27286					       endif		; pauseroutineoff
   2541  27286
   2542  27286
   2543  27286				   -	       ifconst	DOUBLEBUFFER
   2544  27286				   -skipterminatedisplaylistreturn
   2545  27286				   -	       rts
   2546  27286					       endif		; DOUBLEBUFFER
   2547  27286				    terminatedisplaylist
   2548  27286				   -	       ifconst	DOUBLEBUFFER
   2549  27286				   -	       lda	doublebufferstate
   2550  27286				   -	       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2551  27286					       endif		; DOUBLEBUFFER
   2552  27286				    terminatedisplaybuffer
   2553  27286							;add DL end entry on each DL
   2554  27286			a2 0b		       ldx	#(WZONECOUNT-1)
   2555  27288				    dlendloop
   2556  27288			bd e3 f7	       lda	DLPOINTL,x
   2557  2728b				   -	       ifconst	DOUBLEBUFFER
   2558  2728b				   -	       clc
   2559  2728b				   -	       adc	doublebufferdloffset
   2560  2728b					       endif		; DOUBLEBUFFER
   2561  2728b			85 63		       sta	dlpnt
   2562  2728d			bd d7 f7	       lda	DLPOINTH,x
   2563  27290				   -	       ifconst	DOUBLEBUFFER
   2564  27290				   -	       adc	#0
   2565  27290					       endif		; DOUBLEBUFFER
   2566  27290			85 64		       sta	dlpnt+1
   2567  27292			b4 65		       ldy	dlend,x
   2568  27294			a9 00		       lda	#$00
   2569  27296				    dlendmoreloops
   2570  27296			c8		       iny
   2571  27297			91 63		       sta	(dlpnt),y
   2572  27299				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2573  27299				   -	       cpy	#DLLASTOBJ+1
   2574  27299				   -	       beq	dlendthiszonedone
   2575  27299				   -	       iny
   2576  27299				   -	       iny
   2577  27299				   -	       iny
   2578  27299				   -	       iny
   2579  27299				   -	       iny
   2580  27299				   -	       sta	(dlpnt),y
   2581  27299				   -dlendthiszonedone
   2582  27299					       endif	FRAMESKIPGLITCHFIXWEAK
   2583  27299				   -	       ifconst	FRAMESKIPGLITCHFIX
   2584  27299				   -	       iny
   2585  27299				   -	       iny
   2586  27299				   -	       iny
   2587  27299				   -	       iny
   2588  27299				   -	       cpy	#DLLASTOBJ-1
   2589  27299				   -	       bcc	dlendmoreloops
   2590  27299					       endif		; FRAMESKIPGLITCHFIX
   2591  27299			ca		       dex
   2592  2729a			10 ec		       bpl	dlendloop
   2593  2729c
   2594  2729c					       ifnconst	pauseroutineoff
   2595  2729c			20 1c f2	       jsr	pauseroutine
   2596  2729f					       endif		; pauseroutineoff
   2597  2729f			60		       rts
   2598  272a0
   2599  272a0				    uninterruptableroutines
   2600  272a0							; this is for routines that must happen off the visible screen, each frame.
   2601  272a0
   2602  272a0				   -	       ifconst	AVOXVOICE
   2603  272a0				   -	       jsr	serviceatarivoxqueue
   2604  272a0					       endif
   2605  272a0
   2606  272a0			a9 00		       lda	#0
   2607  272a2			8d b6 01	       sta	palfastframe
   2608  272a5			ad 09 21	       lda	paldetected
   2609  272a8			f0 10		       beq	skippalframeadjusting
   2610  272aa							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   2611  272aa			ae b5 01	       ldx	palframes
   2612  272ad			e8		       inx
   2613  272ae			e0 05		       cpx	#5
   2614  272b0			d0 05		       bne	palframeskipdone
   2615  272b2			ee b6 01	       inc	palfastframe
   2616  272b5			a2 00		       ldx	#0
   2617  272b7				    palframeskipdone
   2618  272b7			8e b5 01	       stx	palframes
   2619  272ba				    skippalframeadjusting
   2620  272ba
   2621  272ba				   -	       ifconst	MUSICTRACKER
   2622  272ba				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   2623  272ba				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   2624  272ba				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   2625  272ba				   -			; problem twice, and if we do, we just drop a musical note or two.
   2626  272ba				   -	       lda	sfxschedulemissed
   2627  272ba				   -	       beq	servicesongwasnotmissed
   2628  272ba				   -	       jsr	servicesong
   2629  272ba				   -servicesongwasnotmissed
   2630  272ba					       endif		; MUSICTRACKER
   2631  272ba
   2632  272ba			60		       rts
   2633  272bb
   2634  272bb				    serviceatarivoxqueue
   2635  272bb				   -	       ifconst	AVOXVOICE
   2636  272bb				   -	       lda	voxlock
   2637  272bb				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   2638  272bb				   -skipvoxqueuesizedec
   2639  272bb				   -	       jmp	processavoxvoice
   2640  272bb				   -skipvoxprocessing
   2641  272bb				   -	       rts
   2642  272bb				   -
   2643  272bb				   -processavoxvoice
   2644  272bb				   -	       lda	avoxenable
   2645  272bb				   -	       bne	avoxfixport
   2646  272bb				   -	       SPKOUT	tempavox
   2647  272bb				   -	       rts
   2648  272bb				   -avoxfixport
   2649  272bb				   -	       lda	#0	; restore the port to all bits as inputs...
   2650  272bb				   -	       sta	CTLSWA
   2651  272bb				   -	       rts
   2652  272bb				   -silenceavoxvoice
   2653  272bb				   -	       SPEAK	avoxsilentdata
   2654  272bb				   -	       rts
   2655  272bb				   -avoxsilentdata
   2656  272bb				   -	       .byte	31,255
   2657  272bb					       else
   2658  272bb			60		       rts
   2659  272bc					       endif		; AVOXVOICE
   2660  272bc
   2661  272bc				    joybuttonhandler
   2662  272bc			8a		       txa
   2663  272bd			0a		       asl
   2664  272be			a8		       tay
   2665  272bf			b9 08 00	       lda	INPT0,y
   2666  272c2			4a		       lsr
   2667  272c3			9d 02 21	       sta	sINPT1,x
   2668  272c6			b9 09 00	       lda	INPT1,y
   2669  272c9			29 80		       and	#%10000000
   2670  272cb			1d 02 21	       ora	sINPT1,x
   2671  272ce			9d 02 21	       sta	sINPT1,x
   2672  272d1
   2673  272d1			b5 0c		       lda	INPT4,x
   2674  272d3			30 19		       bmi	.skip1bjoyfirecheck
   2675  272d5							;one button joystick is down
   2676  272d5			49 80		       eor	#%10000000
   2677  272d7			9d 02 21	       sta	sINPT1,x
   2678  272da
   2679  272da			ad b1 01	       lda	joybuttonmode
   2680  272dd			3d f1 f2	       and	twobuttonmask,x
   2681  272e0			f0 0c		       beq	.skip1bjoyfirecheck
   2682  272e2			ad b1 01	       lda	joybuttonmode
   2683  272e5			1d f1 f2	       ora	twobuttonmask,x
   2684  272e8			8d b1 01	       sta	joybuttonmode
   2685  272eb			8d 82 02	       sta	SWCHB
   2686  272ee				    .skip1bjoyfirecheck
   2687  272ee			4c a2 f1	       jmp	buttonreadloopreturn
   2688  272f1
   2689  272f1				    twobuttonmask
   2690  272f1			04 10		       .byte.b	%00000100,%00010000
   2691  272f3
   2692  272f3				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   2693  272f3				   -	       ifconst	LIGHTGUNSUPPORT
   2694  272f3				   -	       cpx	#0
   2695  272f3				   -	       bne	secondportgunhandler
   2696  272f3				   -firstportgunhandler
   2697  272f3				   -	       lda	SWCHA
   2698  272f3				   -	       asl
   2699  272f3				   -	       asl
   2700  272f3				   -	       asl		; shift D4 to D7
   2701  272f3				   -	       and	#%10000000
   2702  272f3				   -	       eor	#%10000000
   2703  272f3				   -	       sta	sINPT1
   2704  272f3				   -	       jmp	buttonreadloopreturn
   2705  272f3				   -secondportgunhandler
   2706  272f3				   -	       lda	SWCHA
   2707  272f3				   -	       lsr		; shift D0 into carry
   2708  272f3				   -	       lsr		; shift carry into D7
   2709  272f3				   -	       and	#%10000000
   2710  272f3				   -	       eor	#%10000000
   2711  272f3				   -	       sta	sINPT3
   2712  272f3				   -	       jmp	buttonreadloopreturn
   2713  272f3					       endif		; LIGHTGUNSUPPORT
   2714  272f3
   2715  272f3				    controlsusing2buttoncode
   2716  272f3			00		       .byte.b	0	; 00=no controller plugged in
   2717  272f4			01		       .byte.b	1	; 01=proline joystick
   2718  272f5			00		       .byte.b	0	; 02=lightgun
   2719  272f6			00		       .byte.b	0	; 03=paddle
   2720  272f7			01		       .byte.b	1	; 04=trakball
   2721  272f8			01		       .byte.b	1	; 05=vcs joystick
   2722  272f9			01		       .byte.b	1	; 06=driving control
   2723  272fa			00		       .byte.b	0	; 07=keypad control
   2724  272fb			00		       .byte.b	0	; 08=st mouse/cx80
   2725  272fc			00		       .byte.b	0	; 09=amiga mouse
   2726  272fd			01		       .byte.b	1	; 10=atarivox
   2727  272fe
   2728  272fe				    buttonhandlerhi
   2729  272fe			00		       .byte.b	0	; 00=no controller plugged in
   2730  272ff			f2		       .byte.b	>joybuttonhandler	; 01=proline joystick
   2731  27300			f2		       .byte.b	>gunbuttonhandler	; 02=lightgun
   2732  27301			f6		       .byte.b	>paddlebuttonhandler	; 03=paddle
   2733  27302			f2		       .byte.b	>joybuttonhandler	; 04=trakball
   2734  27303			f2		       .byte.b	>joybuttonhandler	; 05=vcs joystick
   2735  27304			f2		       .byte.b	>joybuttonhandler	; 06=driving control
   2736  27305			00		       .byte.b	0	; 07=keypad
   2737  27306			f6		       .byte.b	>mousebuttonhandler	; 08=st mouse
   2738  27307			f6		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   2739  27308			f2		       .byte.b	>joybuttonhandler	; 10=atarivox
   2740  27309				    buttonhandlerlo
   2741  27309			00		       .byte.b	0	; 00=no controller plugged in
   2742  2730a			bc		       .byte.b	<joybuttonhandler	; 01=proline joystick
   2743  2730b			f3		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   2744  2730c			af		       .byte.b	<paddlebuttonhandler	; 03=paddle
   2745  2730d			bc		       .byte.b	<joybuttonhandler	; 04=trakball
   2746  2730e			bc		       .byte.b	<joybuttonhandler	; 05=vcs joystick
   2747  2730f			bc		       .byte.b	<joybuttonhandler	; 06=driving control
   2748  27310			00		       .byte.b	0	; 07=keypad
   2749  27311			af		       .byte.b	<mousebuttonhandler	; 08=st mouse
   2750  27312			af		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   2751  27313			bc		       .byte.b	<joybuttonhandler	; 10=atarivox
   2752  27314
   2753  27314				    drawwait
   2754  27314			a5 4d		       lda	visibleover
   2755  27316			d0 fc		       bne	drawwait	; make sure the visible screen isn't being drawn
   2756  27318			60		       rts
   2757  27319
   2758  27319				    mutetia
   2759  27319			a9 00		       lda	#0
   2760  2731b			a2 03		       ldx	#3
   2761  2731d				    mutetialoop
   2762  2731d			95 4e		       sta	sfx1pointlo,x
   2763  2731f			95 17		       sta	AUDF0,x
   2764  27321			ca		       dex
   2765  27322			10 f9		       bpl	mutetialoop
   2766  27324			60		       rts
   2767  27325
   2768  27325				    servicesfxchannelsdone
   2769  27325				   -	       ifnconst	pokeysupport
   2770  27325				   -	       rts
   2771  27325					       else
   2772  27325			4c 0d f0	       jmp	checkpokeyplaying
   2773  27328					       endif
   2774  27328				    servicesfxchannels
   2775  27328			a2 ff		       ldx	#255
   2776  2732a				    servicesfxchannelsloop
   2777  2732a			e8		       inx
   2778  2732b					       ifnconst	TIASFXMONO
   2779  2732b			e0 02		       cpx	#2
   2780  2732d				   -	       else
   2781  2732d				   -	       cpx	#1
   2782  2732d					       endif
   2783  2732d			f0 f6		       beq	servicesfxchannelsdone
   2784  2732f
   2785  2732f			b5 4e		       lda	sfx1pointlo,x
   2786  27331			85 dc		       sta	inttemp5
   2787  27333			15 50		       ora	sfx1pointhi,x
   2788  27335			f0 f3		       beq	servicesfxchannelsloop
   2789  27337			b5 50		       lda	sfx1pointhi,x
   2790  27339			85 dd		       sta	inttemp6
   2791  2733b
   2792  2733b			b5 58		       lda	sfx1tick,x
   2793  2733d			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   2794  2733f			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   2795  27341			4c 2a f3	       jmp	servicesfxchannelsloop
   2796  27344				    servicesfx_cont1
   2797  27344
   2798  27344			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   2799  27346			95 58		       sta	sfx1tick,x
   2800  27348
   2801  27348			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   2802  2734a			f0 02		       beq	servicesfx_cont2
   2803  2734c			d6 52		       dec	sfx1priority,x
   2804  2734e				    servicesfx_cont2
   2805  2734e
   2806  2734e			a0 00		       ldy	#0	; play the sound
   2807  27350			b1 dc		       lda	(inttemp5),y
   2808  27352			85 d8		       sta	inttemp1
   2809  27354
   2810  27354				   -	       ifconst	MUSICTRACKER
   2811  27354				   -	       lda	sfx1notedata,x
   2812  27354				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   2813  27354				   -	       ldy	#0
   2814  27354				   -	       sty	inttemp2
   2815  27354				   -	       clc
   2816  27354				   -	       adc	(inttemp5),y
   2817  27354				   -	       asl		; x2
   2818  27354				   -	       tay
   2819  27354				   -	       lda	tiatrackeroctavenotes,y
   2820  27354				   -	       sta	AUDC0,x
   2821  27354				   -	       iny
   2822  27354				   -	       lda	tiatrackeroctavenotes,y
   2823  27354				   -	       sta	AUDF0,x
   2824  27354				   -	       ldy	#1
   2825  27354				   -	       jmp	sfxvolumeentrypt
   2826  27354				   -exitmusictracker
   2827  27354				   -	       lda	inttemp1
   2828  27354					       endif		; MUSICTRACKER
   2829  27354
   2830  27354			18		       clc
   2831  27355			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   2832  27357			95 17		       sta	AUDF0,x
   2833  27359			c8		       iny
   2834  2735a			b1 dc		       lda	(inttemp5),y
   2835  2735c			95 15		       sta	AUDC0,x
   2836  2735e			85 d9		       sta	inttemp2
   2837  27360			c8		       iny
   2838  27361				    sfxvolumeentrypt
   2839  27361			b1 dc		       lda	(inttemp5),y
   2840  27363			95 19		       sta	AUDV0,x
   2841  27365			c9 10		       cmp	#$10
   2842  27367			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   2843  27369
   2844  27369			05 d9		       ora	inttemp2
   2845  2736b			05 d8		       ora	inttemp1	; check if F|C|V=0
   2846  2736d			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   2847  2736f
   2848  2736f				    advancesfxpointer
   2849  2736f							; advance the pointer to the next sound chunk
   2850  2736f			c8		       iny
   2851  27370			84 da		       sty	inttemp3
   2852  27372			18		       clc
   2853  27373			b5 4e		       lda	sfx1pointlo,x
   2854  27375			65 da		       adc	inttemp3
   2855  27377			95 4e		       sta	sfx1pointlo,x
   2856  27379			b5 50		       lda	sfx1pointhi,x
   2857  2737b			69 00		       adc	#0
   2858  2737d			95 50		       sta	sfx1pointhi,x
   2859  2737f			4c 2a f3	       jmp	servicesfxchannelsloop
   2860  27382
   2861  27382				    sfxsoundloop
   2862  27382			48		       pha
   2863  27383			b5 52		       lda	sfx1priority,x
   2864  27385			d0 04		       bne	sfxsoundloop_carryon
   2865  27387			68		       pla		; fix the stack before we go
   2866  27388			4c 6f f3	       jmp	advancesfxpointer
   2867  2738b				    sfxsoundloop_carryon
   2868  2738b			68		       pla
   2869  2738c			29 f0		       and	#$F0
   2870  2738e			4a		       lsr
   2871  2738f			4a		       lsr
   2872  27390			4a		       lsr
   2873  27391			4a		       lsr
   2874  27392
   2875  27392				    zerosfx
   2876  27392			95 4e		       sta	sfx1pointlo,x
   2877  27394			95 50		       sta	sfx1pointhi,x
   2878  27396			95 52		       sta	sfx1priority,x
   2879  27398			4c 2a f3	       jmp	servicesfxchannelsloop
   2880  2739b
   2881  2739b
   2882  2739b				    schedulesfx
   2883  2739b							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   2884  2739b			a0 00		       ldy	#0
   2885  2739d			b1 e0		       lda	(sfxinstrumentlo),y
   2886  2739f					       ifconst	pokeysupport
   2887  2739f			c9 20		       cmp	#$20	; POKEY?
   2888  273a1			d0 03		       bne	scheduletiasfx
   2889  273a3			4c 70 f0	       jmp	schedulepokeysfx
   2890  273a6					       endif
   2891  273a6				    scheduletiasfx
   2892  273a6							;cmp #$10 ; TIA?
   2893  273a6							;beq continuescheduletiasfx
   2894  273a6							; rts ; unhandled!!! 
   2895  273a6				    continuescheduletiasfx
   2896  273a6					       ifnconst	TIASFXMONO
   2897  273a6			a5 4e		       lda	sfx1pointlo
   2898  273a8			05 50		       ora	sfx1pointhi
   2899  273aa			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   2900  273ac			a5 4f		       lda	sfx2pointlo
   2901  273ae			05 51		       ora	sfx2pointhi
   2902  273b0			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   2903  273b2							; Both channels are scheduled. 
   2904  273b2			a0 01		       ldy	#1
   2905  273b4			b1 e0		       lda	(sfxinstrumentlo),y
   2906  273b6			d0 01		       bne	interruptsfx
   2907  273b8			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   2908  273b9				    interruptsfx
   2909  273b9							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   2910  273b9			a5 52		       lda	sfx1priority
   2911  273bb			c5 53		       cmp	sfx2priority
   2912  273bd			b0 04		       bcs	schedulesfx2
   2913  273bf					       endif		; !TIASFXMONO
   2914  273bf
   2915  273bf				    schedulesfx1
   2916  273bf			a2 00		       ldx	#0	; channel 1
   2917  273c1					       ifnconst	TIASFXMONO
   2918  273c1			f0 02		       beq	skipschedulesfx2
   2919  273c3				    schedulesfx2
   2920  273c3			a2 01		       ldx	#1	; channel 2
   2921  273c5				    skipschedulesfx2
   2922  273c5					       endif		; !TIASFXMONO
   2923  273c5
   2924  273c5				   -	       ifconst	MUSICTRACKER
   2925  273c5				   -	       lda	sfxnoteindex
   2926  273c5				   -	       bpl	skipdrumkitoverride
   2927  273c5				   -	       and	#$7F	; subtract 128
   2928  273c5				   -	       sec
   2929  273c5				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   2930  273c5				   -	       asl
   2931  273c5				   -	       tay
   2932  273c5				   -	       lda	tiadrumkitdefinition,y
   2933  273c5				   -	       sta	sfxinstrumentlo
   2934  273c5				   -	       iny
   2935  273c5				   -	       lda	tiadrumkitdefinition,y
   2936  273c5				   -	       sta	sfxinstrumenthi
   2937  273c5				   -	       lda	#0
   2938  273c5				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   2939  273c5				   -skipdrumkitoverride
   2940  273c5					       endif		; MUSICTRACKER
   2941  273c5			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   2942  273c7			b1 e0		       lda	(sfxinstrumentlo),y
   2943  273c9			95 52		       sta	sfx1priority,x
   2944  273cb			c8		       iny
   2945  273cc			b1 e0		       lda	(sfxinstrumentlo),y
   2946  273ce			95 56		       sta	sfx1frames,x
   2947  273d0			a5 e0		       lda	sfxinstrumentlo
   2948  273d2			18		       clc
   2949  273d3			69 03		       adc	#3
   2950  273d5			95 4e		       sta	sfx1pointlo,x
   2951  273d7			a5 e1		       lda	sfxinstrumenthi
   2952  273d9			69 00		       adc	#0
   2953  273db			95 50		       sta	sfx1pointhi,x
   2954  273dd			a5 e2		       lda	sfxpitchoffset
   2955  273df			95 54		       sta	sfx1poffset,x
   2956  273e1			a9 00		       lda	#0
   2957  273e3			95 58		       sta	sfx1tick,x
   2958  273e5			a5 e3		       lda	sfxnoteindex
   2959  273e7			95 cd		       sta	sfx1notedata,x
   2960  273e9			60		       rts
   2961  273ea
   2962  273ea				    plotsprite
   2963  273ea					       ifnconst	NODRAWWAIT
   2964  273ea				   -	       ifconst	DOUBLEBUFFER
   2965  273ea				   -	       lda	doublebufferstate
   2966  273ea				   -	       bne	skipplotspritewait
   2967  273ea					       endif		; DOUBLEBUFFER
   2968  273ea				   -	       ifconst	DEBUGWAITCOLOR
   2969  273ea				   -	       lda	#$41
   2970  273ea				   -	       sta	BACKGRND
   2971  273ea					       endif
   2972  273ea				    plotspritewait
   2973  273ea			a5 4d		       lda	visibleover
   2974  273ec			d0 fc		       bne	plotspritewait
   2975  273ee				    skipplotspritewait
   2976  273ee				   -	       ifconst	DEBUGWAITCOLOR
   2977  273ee				   -	       lda	#$0
   2978  273ee				   -	       sta	BACKGRND
   2979  273ee					       endif
   2980  273ee					       endif
   2981  273ee
   2982  273ee							;arguments: 
   2983  273ee							; temp1=lo graphicdata 
   2984  273ee							; temp2=hi graphicdata 
   2985  273ee							; temp3=palette | width byte
   2986  273ee							; temp4=x
   2987  273ee							; temp5=y
   2988  273ee							; temp6=mode
   2989  273ee			a5 46		       lda	temp5	;Y position
   2990  273f0			4a		       lsr		; 2 - Divide by 8 or 16
   2991  273f1			4a		       lsr		; 2
   2992  273f2			4a		       lsr		; 2
   2993  273f3					       if	WZONEHEIGHT = 16
   2994  273f3			4a		       lsr		; 2
   2995  273f4					       endif
   2996  273f4
   2997  273f4			aa		       tax
   2998  273f5
   2999  273f5					       ifnconst	NOLIMITCHECKING
   3000  273f5
   3001  273f5							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   3002  273f5
   3003  273f5			c9 0c		       cmp	#WZONECOUNT
   3004  273f7
   3005  273f7			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   3006  273f9							; otherwise, check to see if the bottom half is in zone 0...
   3007  273f9
   3008  273f9					       if	WZONEHEIGHT = 16
   3009  273f9			c9 0f		       cmp	#15
   3010  273fb				   -	       else
   3011  273fb				   -	       cmp	#31
   3012  273fb					       endif
   3013  273fb
   3014  273fb			d0 05		       bne	exitplotsprite1
   3015  273fd			a2 00		       ldx	#0
   3016  273ff			4c 38 f4	       jmp	continueplotsprite2
   3017  27402				    exitplotsprite1
   3018  27402			60		       rts
   3019  27403
   3020  27403				    continueplotsprite1
   3021  27403					       endif
   3022  27403
   3023  27403			bd e3 f7	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3024  27406				   -	       ifconst	DOUBLEBUFFER
   3025  27406				   -	       clc
   3026  27406				   -	       adc	doublebufferdloffset
   3027  27406					       endif		; DOUBLEBUFFER
   3028  27406			85 63		       sta	dlpnt
   3029  27408			bd d7 f7	       lda	DLPOINTH,x
   3030  2740b				   -	       ifconst	DOUBLEBUFFER
   3031  2740b				   -	       adc	#0
   3032  2740b					       endif		; DOUBLEBUFFER
   3033  2740b			85 64		       sta	dlpnt+1
   3034  2740d
   3035  2740d							;Create DL entry for upper part of sprite
   3036  2740d
   3037  2740d			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3038  2740f
   3039  2740f				   -	       ifconst	CHECKOVERWRITE
   3040  2740f				   -	       cpy	#DLLASTOBJ
   3041  2740f				   -	       beq	checkcontinueplotsprite2
   3042  2740f				   -continueplotsprite1a
   3043  2740f					       endif
   3044  2740f
   3045  2740f			a5 42		       lda	temp1	; graphic data, lo byte
   3046  27411			91 63		       sta	(dlpnt),y	;Low byte of data address
   3047  27413
   3048  27413					       ifnconst	ATOMICSPRITEUPDATE
   3049  27413			c8		       iny
   3050  27414			a5 47		       lda	temp6
   3051  27416			91 63		       sta	(dlpnt),y
   3052  27418				   -	       else
   3053  27418				   -	       iny
   3054  27418				   -	       sty	temp8
   3055  27418					       endif
   3056  27418
   3057  27418			c8		       iny
   3058  27419
   3059  27419			a5 46		       lda	temp5	;Y position
   3060  2741b			29 0f		       and	#(WZONEHEIGHT - 1)
   3061  2741d			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   3062  2741f			05 43		       ora	temp2	; graphic data, hi byte
   3063  27421			91 63		       sta	(dlpnt),y
   3064  27423
   3065  27423
   3066  27423			c8		       iny
   3067  27424			a5 44		       lda	temp3	;palette|width
   3068  27426			91 63		       sta	(dlpnt),y
   3069  27428
   3070  27428			c8		       iny
   3071  27429			a5 45		       lda	temp4	;Horizontal position
   3072  2742b			91 63		       sta	(dlpnt),y
   3073  2742d
   3074  2742d			c8		       iny
   3075  2742e			94 65		       sty	dlend,x
   3076  27430
   3077  27430				   -	       ifconst	ALWAYSTERMINATE
   3078  27430				   -	       iny
   3079  27430				   -	       lda	#0
   3080  27430				   -	       sta	(dlpnt),y
   3081  27430					       endif
   3082  27430
   3083  27430				   -	       ifconst	ATOMICSPRITEUPDATE
   3084  27430				   -	       ldy	temp8
   3085  27430				   -	       lda	temp6
   3086  27430				   -	       sta	(dlpnt),y
   3087  27430					       endif
   3088  27430
   3089  27430				    checkcontinueplotsprite2
   3090  27430
   3091  27430			90 33		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   3092  27432
   3093  27432							;Create DL entry for lower part of sprite
   3094  27432
   3095  27432			e8		       inx		;Next region
   3096  27433
   3097  27433					       ifnconst	NOLIMITCHECKING
   3098  27433			e0 0c		       cpx	#WZONECOUNT
   3099  27435
   3100  27435			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3101  27437			60		       rts
   3102  27438				    continueplotsprite2
   3103  27438					       endif
   3104  27438
   3105  27438			bd e3 f7	       lda	DLPOINTL,x	;Get pointer to next DL
   3106  2743b				   -	       ifconst	DOUBLEBUFFER
   3107  2743b				   -	       clc
   3108  2743b				   -	       adc	doublebufferdloffset
   3109  2743b					       endif		; DOUBLEBUFFER
   3110  2743b			85 63		       sta	dlpnt
   3111  2743d			bd d7 f7	       lda	DLPOINTH,x
   3112  27440				   -	       ifconst	DOUBLEBUFFER
   3113  27440				   -	       adc	#0
   3114  27440					       endif		; DOUBLEBUFFER
   3115  27440			85 64		       sta	dlpnt+1
   3116  27442			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3117  27444
   3118  27444				   -	       ifconst	CHECKOVERWRITE
   3119  27444				   -	       cpy	#DLLASTOBJ
   3120  27444				   -	       bne	continueplotsprite2a
   3121  27444				   -	       rts
   3122  27444				   -continueplotsprite2a
   3123  27444					       endif
   3124  27444
   3125  27444			a5 42		       lda	temp1	; graphic data, lo byte
   3126  27446			91 63		       sta	(dlpnt),y
   3127  27448
   3128  27448					       ifnconst	ATOMICSPRITEUPDATE
   3129  27448			c8		       iny
   3130  27449			a5 47		       lda	temp6
   3131  2744b			91 63		       sta	(dlpnt),y
   3132  2744d				   -	       else
   3133  2744d				   -	       iny
   3134  2744d				   -	       sty	temp8
   3135  2744d					       endif
   3136  2744d
   3137  2744d			c8		       iny
   3138  2744e
   3139  2744e			a5 46		       lda	temp5	;Y position
   3140  27450			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   3141  27452			05 43		       ora	temp2	; graphic data, hi byte
   3142  27454			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   3143  27456			91 63		       sta	(dlpnt),y
   3144  27458
   3145  27458			c8		       iny
   3146  27459
   3147  27459			a5 44		       lda	temp3	;palette|width
   3148  2745b			91 63		       sta	(dlpnt),y
   3149  2745d
   3150  2745d			c8		       iny
   3151  2745e
   3152  2745e			a5 45		       lda	temp4	;Horizontal position
   3153  27460			91 63		       sta	(dlpnt),y
   3154  27462
   3155  27462			c8		       iny
   3156  27463			94 65		       sty	dlend,x
   3157  27465
   3158  27465				   -	       ifconst	ALWAYSTERMINATE
   3159  27465				   -	       iny
   3160  27465				   -	       lda	#0
   3161  27465				   -	       sta	(dlpnt),y
   3162  27465					       endif
   3163  27465
   3164  27465				   -	       ifconst	ATOMICSPRITEUPDATE
   3165  27465				   -	       ldy	temp8
   3166  27465				   -	       lda	temp6
   3167  27465				   -	       sta	(dlpnt),y
   3168  27465					       endif
   3169  27465
   3170  27465				    doneSPDL
   3171  27465			60		       rts
   3172  27466
   3173  27466
   3174  27466				    lockzonex
   3175  27466				   -	       ifconst	ZONELOCKS
   3176  27466				   -	       ldy	dlend,x
   3177  27466				   -	       cpy	#DLLASTOBJ
   3178  27466				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3179  27466				   -	       lda	DLPOINTL,x
   3180  27466				   -	       ifconst	DOUBLEBUFFER
   3181  27466				   -	       clc
   3182  27466				   -	       adc	doublebufferdloffset
   3183  27466				   -	       endif		; DOUBLEBUFFER
   3184  27466				   -	       sta	dlpnt
   3185  27466				   -	       lda	DLPOINTH,x
   3186  27466				   -	       ifconst	DOUBLEBUFFER
   3187  27466				   -	       adc	#0
   3188  27466				   -	       endif		; DOUBLEBUFFER
   3189  27466				   -	       sta	dlpnt+1
   3190  27466				   -	       iny
   3191  27466				   -	       lda	#0
   3192  27466				   -	       sta	(dlpnt),y
   3193  27466				   -	       dey
   3194  27466				   -	       tya
   3195  27466				   -	       ldy	#(DLLASTOBJ-1)
   3196  27466				   -	       sta	(dlpnt),y
   3197  27466				   -	       iny
   3198  27466				   -	       sty	dlend,x
   3199  27466				   -lockzonexreturn
   3200  27466				   -	       rts
   3201  27466					       endif		; ZONELOCKS
   3202  27466				    unlockzonex
   3203  27466				   -	       ifconst	ZONELOCKS
   3204  27466				   -	       ldy	dlend,x
   3205  27466				   -	       cpy	#DLLASTOBJ
   3206  27466				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3207  27466				   -	       lda	DLPOINTL,x
   3208  27466				   -	       ifconst	DOUBLEBUFFER
   3209  27466				   -	       clc
   3210  27466				   -	       adc	doublebufferdloffset
   3211  27466				   -	       endif		; DOUBLEBUFFER
   3212  27466				   -	       sta	dlpnt
   3213  27466				   -	       lda	DLPOINTH,x
   3214  27466				   -	       ifconst	DOUBLEBUFFER
   3215  27466				   -	       adc	#0
   3216  27466				   -	       endif		; DOUBLEBUFFER
   3217  27466				   -	       sta	dlpnt+1
   3218  27466				   -	       dey
   3219  27466				   -			;ldy #(DLLASTOBJ-1)
   3220  27466				   -	       lda	(dlpnt),y
   3221  27466				   -	       tay
   3222  27466				   -	       sty	dlend,x
   3223  27466				   -unlockzonexreturn
   3224  27466					       endif		; ZONELOCKS
   3225  27466			60		       rts
   3226  27467
   3227  27467				    plotcharloop
   3228  27467							; ** read from a data indirectly pointed to from temp8,temp9
   3229  27467							; ** format is: lo_data, hi_data, palette|width, x, y
   3230  27467							; ** format ends with lo_data | hi_data = 0
   3231  27467
   3232  27467				   -	       ifconst	DOUBLEBUFFER
   3233  27467				   -	       lda	doublebufferstate
   3234  27467				   -	       bne	skipplotcharloopwait
   3235  27467					       endif		; DOUBLEBUFFER
   3236  27467				   -	       ifconst	DEBUGWAITCOLOR
   3237  27467				   -	       lda	#$61
   3238  27467				   -	       sta	BACKGRND
   3239  27467					       endif
   3240  27467				    plotcharloopwait
   3241  27467			a5 4d		       lda	visibleover
   3242  27469			d0 fc		       bne	plotcharloopwait
   3243  2746b				   -	       ifconst	DEBUGWAITCOLOR
   3244  2746b				   -	       lda	#0
   3245  2746b				   -	       sta	BACKGRND
   3246  2746b					       endif
   3247  2746b				    skipplotcharloopwait
   3248  2746b				    plotcharlooploop
   3249  2746b			a0 00		       ldy	#0
   3250  2746d			b1 49		       lda	(temp8),y
   3251  2746f			85 42		       sta	temp1
   3252  27471			c8		       iny
   3253  27472			b1 49		       lda	(temp8),y
   3254  27474			85 43		       sta	temp2
   3255  27476			05 42		       ora	temp1
   3256  27478			d0 01		       bne	plotcharloopcontinue
   3257  2747a							;the pointer=0, so return
   3258  2747a			60		       rts
   3259  2747b				    plotcharloopcontinue
   3260  2747b			c8		       iny
   3261  2747c			b1 49		       lda	(temp8),y
   3262  2747e			85 44		       sta	temp3
   3263  27480			c8		       iny
   3264  27481			b1 49		       lda	(temp8),y
   3265  27483			85 45		       sta	temp4
   3266  27485			c8		       iny
   3267  27486			b1 49		       lda	(temp8),y
   3268  27488							;sta temp5 ; not needed with our late entry.
   3269  27488			20 a1 f4	       jsr	plotcharactersskipentry
   3270  2748b			a5 49		       lda	temp8
   3271  2748d			18		       clc
   3272  2748e			69 05		       adc	#5
   3273  27490			85 49		       sta	temp8
   3274  27492			a5 4a		       lda	temp9
   3275  27494			69 00		       adc	#0
   3276  27496			85 4a		       sta	temp9
   3277  27498			4c 6b f4	       jmp	plotcharlooploop
   3278  2749b
   3279  2749b				    plotcharacters
   3280  2749b				   -	       ifconst	DOUBLEBUFFER
   3281  2749b				   -	       lda	doublebufferstate
   3282  2749b				   -	       bne	skipplotcharacterswait
   3283  2749b					       endif		; DOUBLEBUFFER
   3284  2749b				   -	       ifconst	DEBUGWAITCOLOR
   3285  2749b				   -	       lda	#$41
   3286  2749b				   -	       sta	BACKGRND
   3287  2749b					       endif
   3288  2749b				    plotcharacterswait
   3289  2749b			a5 4d		       lda	visibleover
   3290  2749d			d0 fc		       bne	plotcharacterswait
   3291  2749f				   -	       ifconst	DEBUGWAITCOLOR
   3292  2749f				   -	       sta	BACKGRND
   3293  2749f					       endif
   3294  2749f				    skipplotcharacterswait
   3295  2749f							;arguments: 
   3296  2749f							; temp1=lo charactermap
   3297  2749f							; temp2=hi charactermap
   3298  2749f							; temp3=palette | width byte
   3299  2749f							; temp4=x
   3300  2749f							; temp5=y
   3301  2749f
   3302  2749f			a5 46		       lda	temp5	;Y position
   3303  274a1
   3304  274a1				    plotcharactersskipentry
   3305  274a1
   3306  274a1							;ifconst ZONEHEIGHT
   3307  274a1							; if ZONEHEIGHT = 16
   3308  274a1							; and #$0F
   3309  274a1							; endif
   3310  274a1							; if ZONEHEIGHT = 8
   3311  274a1							; and #$1F
   3312  274a1							; endif
   3313  274a1							;else
   3314  274a1							; and #$0F
   3315  274a1							;endif
   3316  274a1
   3317  274a1			aa		       tax
   3318  274a2			bd e3 f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3319  274a5				   -	       ifconst	DOUBLEBUFFER
   3320  274a5				   -	       clc
   3321  274a5				   -	       adc	doublebufferdloffset
   3322  274a5					       endif		; DOUBLEBUFFER
   3323  274a5			85 63		       sta	dlpnt
   3324  274a7			bd d7 f7	       lda	DLPOINTH,x
   3325  274aa				   -	       ifconst	DOUBLEBUFFER
   3326  274aa				   -	       adc	#0
   3327  274aa					       endif		; DOUBLEBUFFER
   3328  274aa			85 64		       sta	dlpnt+1
   3329  274ac
   3330  274ac							;Create DL entry for the characters
   3331  274ac
   3332  274ac			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3333  274ae
   3334  274ae				   -	       ifconst	CHECKOVERWRITE
   3335  274ae				   -	       cpy	#DLLASTOBJ
   3336  274ae				   -	       bne	continueplotcharacters
   3337  274ae				   -	       rts
   3338  274ae				   -continueplotcharacters
   3339  274ae					       endif
   3340  274ae
   3341  274ae			a5 42		       lda	temp1	; character map data, lo byte
   3342  274b0			91 63		       sta	(dlpnt),y	;(1) store low address
   3343  274b2
   3344  274b2			c8		       iny
   3345  274b3			ad 06 21	       lda	charactermode
   3346  274b6			91 63		       sta	(dlpnt),y	;(2) store mode
   3347  274b8
   3348  274b8			c8		       iny
   3349  274b9			a5 43		       lda	temp2	; character map, hi byte
   3350  274bb			91 63		       sta	(dlpnt),y	;(3) store high address
   3351  274bd
   3352  274bd			c8		       iny
   3353  274be			a5 44		       lda	temp3	;palette|width
   3354  274c0			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3355  274c2
   3356  274c2			c8		       iny
   3357  274c3			a5 45		       lda	temp4	;Horizontal position
   3358  274c5			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3359  274c7
   3360  274c7			c8		       iny
   3361  274c8			94 65		       sty	dlend,x	; save display list end byte
   3362  274ca			60		       rts
   3363  274cb
   3364  274cb
   3365  274cb					       ifconst	plotvalueonscreen
   3366  274cb				    plotcharacterslive
   3367  274cb							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3368  274cb
   3369  274cb							;arguments: 
   3370  274cb							; temp1=lo charactermap
   3371  274cb							; temp2=hi charactermap
   3372  274cb							; temp3=palette | width byte
   3373  274cb							; temp4=x
   3374  274cb							; temp5=y
   3375  274cb
   3376  274cb			a5 46		       lda	temp5	;Y position
   3377  274cd
   3378  274cd			aa		       tax
   3379  274ce			bd e3 f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3380  274d1				   -	       ifconst	DOUBLEBUFFER
   3381  274d1				   -	       clc
   3382  274d1				   -	       adc	doublebufferdloffset
   3383  274d1					       endif		; DOUBLEBUFFER
   3384  274d1			85 63		       sta	dlpnt
   3385  274d3			bd d7 f7	       lda	DLPOINTH,x
   3386  274d6				   -	       ifconst	DOUBLEBUFFER
   3387  274d6				   -	       adc	#0
   3388  274d6					       endif		; DOUBLEBUFFER
   3389  274d6			85 64		       sta	dlpnt+1
   3390  274d8
   3391  274d8							;Create DL entry for the characters
   3392  274d8
   3393  274d8			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3394  274da
   3395  274da				   -	       ifconst	CHECKOVERWRITE
   3396  274da				   -	       cpy	#DLLASTOBJ
   3397  274da				   -	       bne	continueplotcharacterslive
   3398  274da				   -	       rts
   3399  274da				   -continueplotcharacterslive
   3400  274da					       endif
   3401  274da
   3402  274da			a5 42		       lda	temp1	; character map data, lo byte
   3403  274dc			91 63		       sta	(dlpnt),y	;(1) store low address
   3404  274de
   3405  274de			c8		       iny
   3406  274df							; we don't add the second byte yet, since the charmap could briefly
   3407  274df							; render without a proper character map address, width, or position.
   3408  274df			ad 06 21	       lda	charactermode
   3409  274e2			91 63		       sta	(dlpnt),y	;(2) store mode
   3410  274e4
   3411  274e4			c8		       iny
   3412  274e5			a5 43		       lda	temp2	; character map, hi byte
   3413  274e7			91 63		       sta	(dlpnt),y	;(3) store high address
   3414  274e9
   3415  274e9			c8		       iny
   3416  274ea			a5 44		       lda	temp3	;palette|width
   3417  274ec			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3418  274ee
   3419  274ee			c8		       iny
   3420  274ef			a5 45		       lda	temp4	;Horizontal position
   3421  274f1			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3422  274f3
   3423  274f3			c8		       iny
   3424  274f4			94 65		       sty	dlend,x	; save display list end byte
   3425  274f6
   3426  274f6			60		       rts
   3427  274f7					       endif		;plotcharacterslive
   3428  274f7
   3429  274f7					       ifconst	USED_PLOTVALUE
   3430  274f7				    plotvalue
   3431  274f7							; calling 7800basic command:
   3432  274f7							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3433  274f7							; ...displays the variable as BCD digits
   3434  274f7							;
   3435  274f7							; asm sub arguments: 
   3436  274f7							; temp1=lo charactermap
   3437  274f7							; temp2=hi charactermap
   3438  274f7							; temp3=palette | width byte
   3439  274f7							; temp4=x
   3440  274f7							; temp5=y
   3441  274f7							; temp6=number of digits
   3442  274f7							; temp7=lo variable
   3443  274f7							; temp8=hi variable
   3444  274f7							; temp9=character mode
   3445  274f7
   3446  274f7			00 47	    plotdigitcount =	temp6
   3447  274f7
   3448  274f7				   -	       ifconst	ZONELOCKS
   3449  274f7				   -	       ldx	temp5
   3450  274f7				   -	       ldy	dlend,x
   3451  274f7				   -	       cpy	#DLLASTOBJ
   3452  274f7				   -	       bne	carryonplotvalue
   3453  274f7				   -	       rts
   3454  274f7				   -carryonplotvalue
   3455  274f7					       endif
   3456  274f7
   3457  274f7			a9 00		       lda	#0
   3458  274f9			a8		       tay
   3459  274fa			ae ad 01	       ldx	valbufend
   3460  274fd
   3461  274fd			a5 47		       lda	plotdigitcount
   3462  274ff			29 01		       and	#1
   3463  27501			f0 07		       beq	pvnibble2char
   3464  27503			a9 00		       lda	#0
   3465  27505			9d 00 20	       sta	VALBUFFER,x	; just in case we skip this digit
   3466  27508			f0 11		       beq	pvnibble2char_skipnibble
   3467  2750a
   3468  2750a				    pvnibble2char
   3469  2750a							; high nibble...
   3470  2750a			b1 48		       lda	(temp7),y
   3471  2750c			29 f0		       and	#$f0
   3472  2750e			4a		       lsr
   3473  2750f			4a		       lsr
   3474  27510			4a		       lsr
   3475  27511					       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3476  27511			4a		       lsr
   3477  27512					       endif
   3478  27512
   3479  27512			18		       clc
   3480  27513			65 42		       adc	temp1	; add the offset to character graphics to our value
   3481  27515			9d 00 20	       sta	VALBUFFER,x
   3482  27518			e8		       inx
   3483  27519			c6 47		       dec	plotdigitcount
   3484  2751b
   3485  2751b				    pvnibble2char_skipnibble
   3486  2751b							; low nibble...
   3487  2751b			b1 48		       lda	(temp7),y
   3488  2751d			29 0f		       and	#$0f
   3489  2751f				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3490  2751f				   -	       asl
   3491  2751f					       endif
   3492  2751f			18		       clc
   3493  27520			65 42		       adc	temp1	; add the offset to character graphics to our value
   3494  27522			9d 00 20	       sta	VALBUFFER,x
   3495  27525			e8		       inx
   3496  27526			c8		       iny
   3497  27527
   3498  27527			c6 47		       dec	plotdigitcount
   3499  27529			d0 df		       bne	pvnibble2char
   3500  2752b
   3501  2752b							;point to the start of our valuebuffer
   3502  2752b			18		       clc
   3503  2752c			a9 00		       lda	#<VALBUFFER
   3504  2752e			6d ad 01	       adc	valbufend
   3505  27531			85 42		       sta	temp1
   3506  27533			a9 20		       lda	#>VALBUFFER
   3507  27535			69 00		       adc	#0
   3508  27537			85 43		       sta	temp2
   3509  27539
   3510  27539							;advance valbufend to the end of our value buffer
   3511  27539			8e ad 01	       stx	valbufend
   3512  2753c
   3513  2753c				   -	       ifnconst	plotvalueonscreen
   3514  2753c				   -	       jmp	plotcharacters
   3515  2753c					       else
   3516  2753c			4c cb f4	       jmp	plotcharacterslive
   3517  2753f					       endif
   3518  2753f
   3519  2753f					       endif		; USED_PLOTVALUE
   3520  2753f
   3521  2753f
   3522  2753f				   -	       ifconst	USED_PLOTVALUEEXTRA
   3523  2753f				   -plotdigitcount =	temp6
   3524  2753f				   -plotvalueextra
   3525  2753f				   -			; calling 7800basic command:
   3526  2753f				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   3527  2753f				   -			; ...displays the variable as BCD digits
   3528  2753f				   -			;
   3529  2753f				   -			; asm sub arguments: 
   3530  2753f				   -			; temp1=lo charactermap
   3531  2753f				   -			; temp2=hi charactermap
   3532  2753f				   -			; temp3=palette | width byte
   3533  2753f				   -			; temp4=x
   3534  2753f				   -			; temp5=y
   3535  2753f				   -			; temp6=number of digits
   3536  2753f				   -			; temp7=lo variable
   3537  2753f				   -			; temp8=hi variable
   3538  2753f				   -
   3539  2753f				   -	       lda	#0
   3540  2753f				   -	       tay
   3541  2753f				   -	       ldx	valbufend
   3542  2753f				   -	       ifnconst	plotvalueonscreen
   3543  2753f				   -	       sta	VALBUFFER,x
   3544  2753f				   -	       endif
   3545  2753f				   -
   3546  2753f				   -	       lda	plotdigitcount
   3547  2753f				   -	       and	#1
   3548  2753f				   -
   3549  2753f				   -	       bne	pvnibble2char_skipnibbleextra
   3550  2753f				   -
   3551  2753f				   -pvnibble2charextra
   3552  2753f				   -			; high nibble...
   3553  2753f				   -	       lda	(temp7),y
   3554  2753f				   -	       and	#$f0
   3555  2753f				   -	       lsr
   3556  2753f				   -	       lsr
   3557  2753f				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3558  2753f				   -	       lsr
   3559  2753f				   -	       endif
   3560  2753f				   -	       clc
   3561  2753f				   -	       adc	temp1	; add the offset to character graphics to our value
   3562  2753f				   -	       sta	VALBUFFER,x
   3563  2753f				   -	       inx
   3564  2753f				   -
   3565  2753f				   -			; second half of the digit
   3566  2753f				   -	       clc
   3567  2753f				   -	       adc	#1
   3568  2753f				   -	       sta	VALBUFFER,x
   3569  2753f				   -	       inx
   3570  2753f				   -
   3571  2753f				   -pvnibble2char_skipnibbleextra
   3572  2753f				   -			; low nibble...
   3573  2753f				   -	       lda	(temp7),y
   3574  2753f				   -	       and	#$0f
   3575  2753f				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   3576  2753f				   -	       asl
   3577  2753f				   -	       endif
   3578  2753f				   -	       asl
   3579  2753f				   -
   3580  2753f				   -	       clc
   3581  2753f				   -	       adc	temp1	; add the offset to character graphics to our value
   3582  2753f				   -	       sta	VALBUFFER,x
   3583  2753f				   -	       inx
   3584  2753f				   -
   3585  2753f				   -	       clc
   3586  2753f				   -	       adc	#1
   3587  2753f				   -	       sta	VALBUFFER,x
   3588  2753f				   -	       inx
   3589  2753f				   -	       iny
   3590  2753f				   -
   3591  2753f				   -	       dec	plotdigitcount
   3592  2753f				   -	       bne	pvnibble2charextra
   3593  2753f				   -
   3594  2753f				   -			;point to the start of our valuebuffer
   3595  2753f				   -	       clc
   3596  2753f				   -	       lda	#<VALBUFFER
   3597  2753f				   -	       adc	valbufend
   3598  2753f				   -	       sta	temp1
   3599  2753f				   -	       lda	#>VALBUFFER
   3600  2753f				   -	       adc	#0
   3601  2753f				   -	       sta	temp2
   3602  2753f				   -
   3603  2753f				   -			;advance valbufend to the end of our value buffer
   3604  2753f				   -	       stx	valbufend
   3605  2753f				   -
   3606  2753f				   -	       ifnconst	plotvalueonscreen
   3607  2753f				   -	       jmp	plotcharacters
   3608  2753f				   -	       else
   3609  2753f				   -	       jmp	plotcharacterslive
   3610  2753f				   -	       endif
   3611  2753f					       endif		; USED_PLOTVALUEEXTRA
   3612  2753f
   3613  2753f				    boxcollision
   3614  2753f							; the worst case cycle-time for the code below is 43 cycles.
   3615  2753f							; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   3616  2753f
   3617  2753f							;__boxx1 = accumulator
   3618  2753f							;__boxy1 = y
   3619  2753f			00 44	    __boxw1    =	temp3
   3620  2753f			00 45	    __boxh1    =	temp4
   3621  2753f
   3622  2753f			00 46	    __boxx2    =	temp5
   3623  2753f			00 47	    __boxy2    =	temp6
   3624  2753f			00 48	    __boxw2    =	temp7
   3625  2753f			00 49	    __boxh2    =	temp8
   3626  2753f
   3627  2753f				    DoXCollisionCheck
   3628  2753f							;lda __boxx1 ; skipped. already in the accumulator
   3629  2753f			c5 46		       cmp	__boxx2	;3
   3630  27541			b0 07		       bcs	X1isbiggerthanX2	;2/3
   3631  27543				    X2isbiggerthanX1
   3632  27543							; carry is clear
   3633  27543			65 44		       adc	__boxw1	;3
   3634  27545			c5 46		       cmp	__boxx2	;3
   3635  27547			b0 08		       bcs	DoYCollisionCheck	;3/2
   3636  27549			60		       rts		;6 - carry clear, no collision
   3637  2754a				    X1isbiggerthanX2
   3638  2754a			18		       clc		;2
   3639  2754b			e5 48		       sbc	__boxw2	;3
   3640  2754d			c5 46		       cmp	__boxx2	;3
   3641  2754f			b0 13		       bcs	noboxcollision	;3/2
   3642  27551				    DoYCollisionCheck
   3643  27551			98		       tya		; 2 ; use to be "lda __boxy1"
   3644  27552			c5 47		       cmp	__boxy2	;3
   3645  27554			b0 05		       bcs	Y1isbiggerthanY2	;3/2
   3646  27556				    Y2isbiggerthanY1
   3647  27556							; carry is clear
   3648  27556			65 45		       adc	__boxh1	;3
   3649  27558			c5 47		       cmp	__boxy2	;3
   3650  2755a			60		       rts		;6 
   3651  2755b				    Y1isbiggerthanY2
   3652  2755b			18		       clc		;2
   3653  2755c			e5 49		       sbc	__boxh2	;3
   3654  2755e			c5 47		       cmp	__boxy2	;3
   3655  27560			b0 02		       bcs	noboxcollision	;3/2
   3656  27562				    yesboxcollision
   3657  27562			38		       sec		;2
   3658  27563			60		       rts		;6
   3659  27564				    noboxcollision
   3660  27564			18		       clc		;2
   3661  27565			60		       rts		;6
   3662  27566
   3663  27566				    randomize
   3664  27566			a5 40		       lda	rand
   3665  27568			4a		       lsr
   3666  27569			26 41		       rol	rand16
   3667  2756b			90 02		       bcc	noeor
   3668  2756d			49 b4		       eor	#$B4
   3669  2756f				    noeor
   3670  2756f			85 40		       sta	rand
   3671  27571			45 41		       eor	rand16
   3672  27573			60		       rts
   3673  27574
   3674  27574							; *** bcd conversion routine courtesy Omegamatrix
   3675  27574							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   3676  27574				    converttobcd
   3677  27574							;value to convert is in the accumulator
   3678  27574			85 42		       sta	temp1
   3679  27576			4a		       lsr
   3680  27577			65 42		       adc	temp1
   3681  27579			6a		       ror
   3682  2757a			4a		       lsr
   3683  2757b			4a		       lsr
   3684  2757c			65 42		       adc	temp1
   3685  2757e			6a		       ror
   3686  2757f			65 42		       adc	temp1
   3687  27581			6a		       ror
   3688  27582			4a		       lsr
   3689  27583			29 3c		       and	#$3C
   3690  27585			85 43		       sta	temp2
   3691  27587			4a		       lsr
   3692  27588			65 43		       adc	temp2
   3693  2758a			65 42		       adc	temp1
   3694  2758c			60		       rts		; return the result in the accumulator
   3695  2758d
   3696  2758d							; Y and A contain multiplicands, result in A
   3697  2758d				    mul8
   3698  2758d			84 42		       sty	temp1
   3699  2758f			85 43		       sta	temp2
   3700  27591			a9 00		       lda	#0
   3701  27593				    reptmul8
   3702  27593			46 43		       lsr	temp2
   3703  27595			90 03		       bcc	skipmul8
   3704  27597			18		       clc
   3705  27598			65 42		       adc	temp1
   3706  2759a							;bcs donemul8 might save cycles?
   3707  2759a				    skipmul8
   3708  2759a							;beq donemul8 might save cycles?
   3709  2759a			06 42		       asl	temp1
   3710  2759c			d0 f5		       bne	reptmul8
   3711  2759e				    donemul8
   3712  2759e			60		       rts
   3713  2759f
   3714  2759f				    div8
   3715  2759f							; A=numerator Y=denominator, result in A
   3716  2759f			c0 02		       cpy	#2
   3717  275a1			90 0a		       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   3718  275a3			84 42		       sty	temp1
   3719  275a5			a0 ff		       ldy	#$ff
   3720  275a7				    div8loop
   3721  275a7			e5 42		       sbc	temp1
   3722  275a9			c8		       iny
   3723  275aa			b0 fb		       bcs	div8loop
   3724  275ac				    div8end
   3725  275ac			98		       tya
   3726  275ad							; result in A
   3727  275ad			60		       rts
   3728  275ae
   3729  275ae							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   3730  275ae				    mul16
   3731  275ae			84 42		       sty	temp1
   3732  275b0			85 43		       sta	temp2
   3733  275b2
   3734  275b2			a9 00		       lda	#0
   3735  275b4			a2 08		       ldx	#8
   3736  275b6			46 42		       lsr	temp1
   3737  275b8				    mul16_1
   3738  275b8			90 03		       bcc	mul16_2
   3739  275ba			18		       clc
   3740  275bb			65 43		       adc	temp2
   3741  275bd				    mul16_2
   3742  275bd			6a		       ror
   3743  275be			66 42		       ror	temp1
   3744  275c0			ca		       dex
   3745  275c1			d0 f5		       bne	mul16_1
   3746  275c3			85 43		       sta	temp2
   3747  275c5			60		       rts
   3748  275c6
   3749  275c6							; div int/int
   3750  275c6							; numerator in A, denom in temp1
   3751  275c6							; returns with quotient in A, remainder in temp1
   3752  275c6				    div16
   3753  275c6			85 43		       sta	temp2
   3754  275c8			84 42		       sty	temp1
   3755  275ca			a9 00		       lda	#0
   3756  275cc			a2 08		       ldx	#8
   3757  275ce			06 43		       asl	temp2
   3758  275d0				    div16_1
   3759  275d0			2a		       rol
   3760  275d1			c5 42		       cmp	temp1
   3761  275d3			90 02		       bcc	div16_2
   3762  275d5			e5 42		       sbc	temp1
   3763  275d7				    div16_2
   3764  275d7			26 43		       rol	temp2
   3765  275d9			ca		       dex
   3766  275da			d0 f4		       bne	div16_1
   3767  275dc			85 42		       sta	temp1
   3768  275de			a5 43		       lda	temp2
   3769  275e0			60		       rts
   3770  275e1
   3771  275e1					       ifconst	bankswitchmode
   3772  275e1				    BS_jsr
   3773  275e1				   -	       ifconst	MCPDEVCART
   3774  275e1				   -	       ora	#$18
   3775  275e1				   -	       sta	$3000
   3776  275e1					       else
   3777  275e1			8d 00 80	       sta	$8000
   3778  275e4					       endif
   3779  275e4			68		       pla
   3780  275e5			aa		       tax
   3781  275e6			68		       pla
   3782  275e7			60		       rts
   3783  275e8
   3784  275e8				    BS_return
   3785  275e8			68		       pla		; bankswitch bank
   3786  275e9				   -	       ifconst	BANKRAM
   3787  275e9				   -	       sta	currentbank
   3788  275e9				   -	       ora	currentrambank
   3789  275e9					       endif
   3790  275e9				   -	       ifconst	MCPDEVCART
   3791  275e9				   -	       ora	#$18
   3792  275e9				   -	       sta	$3000
   3793  275e9					       else
   3794  275e9			8d 00 80	       sta	$8000
   3795  275ec					       endif
   3796  275ec			68		       pla		; bankswitch $0 flag
   3797  275ed			60		       rts
   3798  275ee					       endif
   3799  275ee
   3800  275ee				    checkselectswitch
   3801  275ee			ad 82 02	       lda	SWCHB	; first check the real select switch...
   3802  275f1			29 02		       and	#%00000010
   3803  275f3					       ifnconst	MOUSESUPPORT
   3804  275f3			f0 05		       beq	checkselectswitchreturn	; switch is pressed
   3805  275f5			ad 80 02	       lda	SWCHA	; then check the soft "select" joysick code...
   3806  275f8			29 b0		       and	#%10110000	; R_DU
   3807  275fa					       endif		; MOUSESUPPORT
   3808  275fa				    checkselectswitchreturn
   3809  275fa			60		       rts
   3810  275fb
   3811  275fb				    checkresetswitch
   3812  275fb			ad 82 02	       lda	SWCHB	; first check the real reset switch...
   3813  275fe			29 01		       and	#%00000001
   3814  27600					       ifnconst	MOUSESUPPORT
   3815  27600			f0 05		       beq	checkresetswitchreturn	; switch is pressed
   3816  27602			ad 80 02	       lda	SWCHA	; then check the soft "reset" joysick code...
   3817  27605			29 70		       and	#%01110000	; _LDU
   3818  27607					       endif		; MOUSESUPPORT
   3819  27607				    checkresetswitchreturn
   3820  27607			60		       rts
   3821  27608
   3822  27608				   -	       ifconst	FINESCROLLENABLED
   3823  27608				   -finescrolldlls
   3824  27608				   -	       ldx	temp1	; first DLL index x3
   3825  27608				   -	       lda	DLLMEM,x
   3826  27608				   -	       and	#%11110000
   3827  27608				   -	       ora	finescrolly
   3828  27608				   -	       sta	DLLMEM,x
   3829  27608				   -
   3830  27608				   -	       ldx	temp2	; last DLL index x3
   3831  27608				   -	       lda	DLLMEM,x
   3832  27608				   -	       and	#%11110000
   3833  27608				   -	       ora	finescrolly
   3834  27608				   -	       eor	#(WZONEHEIGHT-1)
   3835  27608				   -	       sta	DLLMEM,x
   3836  27608				   -	       rts
   3837  27608					       endif		; FINESCROLLENABLED
   3838  27608
   3839  27608				   -	       ifconst	USED_ADJUSTVISIBLE
   3840  27608				   -adjustvisible
   3841  27608				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   3842  27608				   -	       jsr	waitforvblankstart	; ensure vblank just started
   3843  27608				   -	       ldx	visibleDLLstart
   3844  27608				   -findfirstinterrupt
   3845  27608				   -	       lda	DLLMEM,x
   3846  27608				   -	       bmi	foundfirstinterrupt
   3847  27608				   -	       inx
   3848  27608				   -	       inx
   3849  27608				   -	       inx
   3850  27608				   -	       bne	findfirstinterrupt
   3851  27608				   -foundfirstinterrupt
   3852  27608				   -	       and	#%01111111	; clear the interrupt bit
   3853  27608				   -	       sta	DLLMEM,x
   3854  27608				   -	       ifconst	DOUBLEBUFFER
   3855  27608				   -	       sta	DLLMEM+DBOFFSET,x
   3856  27608				   -	       endif		; DOUBLEBUFFER
   3857  27608				   -	       ldx	overscanDLLstart
   3858  27608				   -findlastinterrupt
   3859  27608				   -	       lda	DLLMEM,x
   3860  27608				   -	       bmi	foundlastinterrupt
   3861  27608				   -	       dex
   3862  27608				   -	       dex
   3863  27608				   -	       dex
   3864  27608				   -	       bne	findlastinterrupt
   3865  27608				   -foundlastinterrupt
   3866  27608				   -	       and	#%01111111	; clear the interrupt bit
   3867  27608				   -	       sta	DLLMEM,x
   3868  27608				   -	       ifconst	DOUBLEBUFFER
   3869  27608				   -	       sta	DLLMEM+DBOFFSET,x
   3870  27608				   -	       endif		; DOUBLEBUFFER
   3871  27608				   -			;now we need to set the new interrupts
   3872  27608				   -	       clc
   3873  27608				   -	       lda	temp1
   3874  27608				   -	       adc	visibleDLLstart
   3875  27608				   -	       tax
   3876  27608				   -	       lda	DLLMEM,x
   3877  27608				   -	       ora	#%10000000
   3878  27608				   -	       sta	DLLMEM,x
   3879  27608				   -	       ifconst	DOUBLEBUFFER
   3880  27608				   -	       sta	DLLMEM+DBOFFSET,x
   3881  27608				   -	       endif		; DOUBLEBUFFER
   3882  27608				   -	       clc
   3883  27608				   -	       lda	temp2
   3884  27608				   -	       adc	visibleDLLstart
   3885  27608				   -	       tax
   3886  27608				   -	       lda	DLLMEM,x
   3887  27608				   -	       ora	#%10000000
   3888  27608				   -	       sta	DLLMEM,x
   3889  27608				   -	       ifconst	DOUBLEBUFFER
   3890  27608				   -	       sta	DLLMEM+DBOFFSET,x
   3891  27608				   -	       endif		; DOUBLEBUFFER
   3892  27608				   -	       jsr	vblankresync
   3893  27608				   -	       rts
   3894  27608					       endif		; USED_ADJUSTVISIBLE
   3895  27608
   3896  27608				    vblankresync
   3897  27608			20 a6 f6	       jsr	waitforvblankstart	; ensure vblank just started
   3898  2760b			a9 00		       lda	#0
   3899  2760d			85 4d		       sta	visibleover
   3900  2760f			a9 03		       lda	#3
   3901  27611			8d b2 01	       sta	interruptindex
   3902  27614			60		       rts
   3903  27615
   3904  27615				    createallgamedlls
   3905  27615			a2 00		       ldx	#0
   3906  27617			a9 19		       lda	#NVLINES
   3907  27619			ac 09 21	       ldy	paldetected
   3908  2761c			f0 03		       beq	skipcreatePALpadding
   3909  2761e			18		       clc
   3910  2761f			69 15		       adc	#21
   3911  27621				    skipcreatePALpadding
   3912  27621			20 56 f6	       jsr	createnonvisibledlls
   3913  27624			8e 3c 21	       stx	visibleDLLstart
   3914  27627			20 87 f6	       jsr	createvisiblezones
   3915  2762a			8e 3d 21	       stx	overscanDLLstart
   3916  2762d				    createallgamedllscontinue
   3917  2762d			a9 50		       lda	#(NVLINES+55)	; extras for PAL
   3918  2762f			20 56 f6	       jsr	createnonvisibledlls
   3919  27632
   3920  27632			ae 3c 21	       ldx	visibleDLLstart
   3921  27635			bd 00 18	       lda	DLLMEM,x
   3922  27638			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   3923  2763a			9d 00 18	       sta	DLLMEM,x
   3924  2763d				   -	       ifconst	DOUBLEBUFFER
   3925  2763d				   -	       sta	DLLMEM+DBOFFSET,x
   3926  2763d					       endif		; DOUBLEBUFFER
   3927  2763d
   3928  2763d			ae 3d 21	       ldx	overscanDLLstart
   3929  27640			bd 00 18	       lda	DLLMEM,x
   3930  27643			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   3931  27645			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   3932  27647			9d 00 18	       sta	DLLMEM,x
   3933  2764a				   -	       ifconst	DOUBLEBUFFER
   3934  2764a				   -	       sta	DLLMEM+DBOFFSET,x
   3935  2764a					       endif		; DOUBLEBUFFER
   3936  2764a
   3937  2764a			e8		       inx
   3938  2764b			e8		       inx
   3939  2764c			e8		       inx
   3940  2764d
   3941  2764d			bd 00 18	       lda	DLLMEM,x
   3942  27650			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   3943  27652			9d 00 18	       sta	DLLMEM,x
   3944  27655				   -	       ifconst	DOUBLEBUFFER
   3945  27655				   -	       sta	DLLMEM+DBOFFSET,x
   3946  27655					       endif		; DOUBLEBUFFER
   3947  27655
   3948  27655			60		       rts
   3949  27656
   3950  27656				    createnonvisibledlls
   3951  27656			85 42		       sta	temp1
   3952  27658			4a		       lsr
   3953  27659			4a		       lsr
   3954  2765a			4a		       lsr
   3955  2765b			4a		       lsr		; /16
   3956  2765c			f0 09		       beq	skipcreatenonvisibledlls1loop
   3957  2765e			a8		       tay
   3958  2765f				    createnonvisibledlls1loop
   3959  2765f			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   3960  27661			20 76 f6	       jsr	createblankdllentry
   3961  27664			88		       dey
   3962  27665			d0 f8		       bne	createnonvisibledlls1loop
   3963  27667				    skipcreatenonvisibledlls1loop
   3964  27667			a5 42		       lda	temp1
   3965  27669			29 0f		       and	#%00001111
   3966  2766b			f0 08		       beq	createnonvisibledllsreturn
   3967  2766d			38		       sec
   3968  2766e			e9 01		       sbc	#1
   3969  27670			09 40		       ora	#%01000000
   3970  27672			20 76 f6	       jsr	createblankdllentry
   3971  27675				    createnonvisibledllsreturn
   3972  27675			60		       rts
   3973  27676
   3974  27676				    createblankdllentry
   3975  27676			9d 00 18	       sta	DLLMEM,x
   3976  27679				   -	       ifconst	DOUBLEBUFFER
   3977  27679				   -	       sta	DLLMEM+DBOFFSET,x
   3978  27679					       endif		; DOUBLEBUFFER
   3979  27679			e8		       inx
   3980  2767a			a9 21		       lda	#$21	; blank
   3981  2767c			9d 00 18	       sta	DLLMEM,x
   3982  2767f				   -	       ifconst	DOUBLEBUFFER
   3983  2767f				   -	       sta	DLLMEM+DBOFFSET,x
   3984  2767f					       endif		; DOUBLEBUFFER
   3985  2767f			e8		       inx
   3986  27680			a9 00		       lda	#$00
   3987  27682			9d 00 18	       sta	DLLMEM,x
   3988  27685				   -	       ifconst	DOUBLEBUFFER
   3989  27685				   -	       sta	DLLMEM+DBOFFSET,x
   3990  27685					       endif		; DOUBLEBUFFER
   3991  27685			e8		       inx
   3992  27686			60		       rts
   3993  27687
   3994  27687				    createvisiblezones
   3995  27687			a0 00		       ldy	#0
   3996  27689				    createvisiblezonesloop
   3997  27689			b9 ef f7	       lda.w	DLHEIGHT,y
   3998  2768c			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   3999  2768e			9d 00 18	       sta	DLLMEM,x
   4000  27691				   -	       ifconst	DOUBLEBUFFER
   4001  27691				   -	       sta	DLLMEM+DBOFFSET,x
   4002  27691					       endif		; DOUBLEBUFFER
   4003  27691			e8		       inx
   4004  27692			b9 d7 f7	       lda	DLPOINTH,y
   4005  27695			9d 00 18	       sta	DLLMEM,x
   4006  27698				   -	       ifconst	DOUBLEBUFFER
   4007  27698				   -	       sta	DLLMEM+DBOFFSET,x
   4008  27698					       endif		; DOUBLEBUFFER
   4009  27698			e8		       inx
   4010  27699			b9 e3 f7	       lda	DLPOINTL,y
   4011  2769c			9d 00 18	       sta	DLLMEM,x
   4012  2769f				   -	       ifconst	DOUBLEBUFFER
   4013  2769f				   -	       clc
   4014  2769f				   -	       adc	#DOUBLEBUFFEROFFSET
   4015  2769f				   -	       sta	DLLMEM+DBOFFSET,x
   4016  2769f				   -	       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   4017  2769f				   -	       inc	DLLMEM+DBOFFSET-1,x
   4018  2769f				   -skiphidoublebufferadjust
   4019  2769f					       endif		; DOUBLEBUFFER
   4020  2769f			e8		       inx
   4021  276a0			c8		       iny
   4022  276a1			c0 0c		       cpy	#WZONECOUNT
   4023  276a3			d0 e4		       bne	createvisiblezonesloop
   4024  276a5			60		       rts
   4025  276a6
   4026  276a6				    waitforvblankstart
   4027  276a6				    visibleoverwait
   4028  276a6			24 28		       BIT	MSTAT
   4029  276a8			10 fc		       bpl	visibleoverwait
   4030  276aa				    vblankstartwait
   4031  276aa			24 28		       BIT	MSTAT
   4032  276ac			30 fc		       bmi	vblankstartwait
   4033  276ae			60		       rts
   4034  276af
   4035  276af				   -	       ifconst	DOUBLEBUFFER
   4036  276af				   -flipdisplaybufferreturn
   4037  276af				   -	       rts
   4038  276af				   -flipdisplaybuffer
   4039  276af				   -	       lda	doublebufferstate
   4040  276af				   -	       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4041  276af				   -
   4042  276af				   -	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4043  276af				   -
   4044  276af				   -	       lda	doublebufferstate
   4045  276af				   -	       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4046  276af				   -	       tax
   4047  276af				   -
   4048  276af				   -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4049  276af				   -
   4050  276af				   -flipdisplaybufferwait1
   4051  276af				   -	       lda	visibleover
   4052  276af				   -	       beq	flipdisplaybufferwait1
   4053  276af				   -
   4054  276af				   -flipdisplaybufferwait
   4055  276af				   -	       lda	visibleover
   4056  276af				   -	       bne	flipdisplaybufferwait
   4057  276af				   -
   4058  276af				   -	       lda	doublebufferminimumframetarget
   4059  276af				   -	       beq	skipminimumframecode
   4060  276af				   -	       lda	doublebufferminimumframeindex
   4061  276af				   -	       bne	flipdisplaybufferwait1
   4062  276af				   -	       lda	doublebufferminimumframetarget
   4063  276af				   -	       sta	doublebufferminimumframeindex
   4064  276af				   -skipminimumframecode
   4065  276af				   -
   4066  276af				   -	       lda	DLLMEMLutHi,x
   4067  276af				   -	       sta	DPPH
   4068  276af				   -	       lda	DLLMEMLutLo,x
   4069  276af				   -	       sta	DPPL
   4070  276af				   -
   4071  276af				   -	       lda	NewPageflipstate,x
   4072  276af				   -	       sta	doublebufferstate
   4073  276af				   -	       lda	NewPageflipoffset,x
   4074  276af				   -	       sta	doublebufferdloffset
   4075  276af				   -
   4076  276af				   -	       lda	doublebufferbufferdirty
   4077  276af				   -	       beq	flipdisplaybufferreturn
   4078  276af				   -
   4079  276af				   -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4080  276af				   -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4081  276af				   -			; from the displayed buffer to the working buffer...
   4082  276af				   -
   4083  276af				   -	       lda	doublebufferdloffset
   4084  276af				   -	       eor	#DOUBLEBUFFEROFFSET
   4085  276af				   -	       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4086  276af				   -
   4087  276af				   -	       ldx	#(WZONECOUNT-1)
   4088  276af				   -copybufferzoneloop
   4089  276af				   -
   4090  276af				   -	       lda	DLPOINTL,x
   4091  276af				   -	       clc
   4092  276af				   -	       adc	doublebufferdloffset
   4093  276af				   -	       sta	temp1
   4094  276af				   -	       lda	DLPOINTH,x
   4095  276af				   -	       adc	#0
   4096  276af				   -	       sta	temp2
   4097  276af				   -
   4098  276af				   -	       lda	DLPOINTL,x
   4099  276af				   -	       clc
   4100  276af				   -	       adc	temp6
   4101  276af				   -	       sta	temp3
   4102  276af				   -	       lda	DLPOINTH,x
   4103  276af				   -	       adc	#0
   4104  276af				   -	       sta	temp4
   4105  276af				   -
   4106  276af				   -	       lda	dlendsave,x
   4107  276af				   -	       tay
   4108  276af				   -copybuffercharsloop
   4109  276af				   -	       lda	(temp3),y
   4110  276af				   -	       sta	(temp1),y
   4111  276af				   -	       dey
   4112  276af				   -	       bpl	copybuffercharsloop
   4113  276af				   -	       dex
   4114  276af				   -	       bpl	copybufferzoneloop
   4115  276af				   -	       lda	#0
   4116  276af				   -	       sta	doublebufferbufferdirty
   4117  276af				   -	       rts
   4118  276af				   -
   4119  276af				   -doublebufferoff
   4120  276af				   -	       lda	#1
   4121  276af				   -	       sta	doublebufferstate
   4122  276af				   -	       jsr	flipdisplaybuffer
   4123  276af				   -	       lda	#0
   4124  276af				   -	       sta	doublebufferstate
   4125  276af				   -	       sta	doublebufferdloffset
   4126  276af				   -	       rts
   4127  276af				   -
   4128  276af				   -DLLMEMLutLo
   4129  276af				   -	       .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   4130  276af				   -DLLMEMLutHi
   4131  276af				   -	       .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   4132  276af				   -NewPageflipstate
   4133  276af				   -	       .byte	3,1
   4134  276af				   -NewPageflipoffset
   4135  276af				   -	       .byte	DOUBLEBUFFEROFFSET,0
   4136  276af				   -
   4137  276af					       endif		; DOUBLEBUFFER
   4138  276af
   4139  276af				   -	       ifconst	MOUSESUPPORT
   4140  276af				   -
   4141  276af				   -rotationalcompare
   4142  276af				   -			; old =   00	  01	  10	 11
   4143  276af				   -	       .byte	$00, $01, $ff, $00	; new=00
   4144  276af				   -	       .byte	$ff, $00, $00, $01	; new=01
   4145  276af				   -	       .byte	$01, $00, $00, $ff	; new=10
   4146  276af				   -	       .byte	$00, $ff, $01, $00	; new=11
   4147  276af				   -
   4148  276af				   -			;  0000YyXx st mouse
   4149  276af				   -
   4150  276af				   -			;  0000xyXY amiga mouse
   4151  276af				   -
   4152  276af				   -	       ifconst	MOUSEXONLY
   4153  276af				   -amigatoataribits		; swap bits 1 and 4...
   4154  276af				   -	       .byte	%0000, %0000, %0010, %0010
   4155  276af				   -	       .byte	%0000, %0000, %0010, %0010
   4156  276af				   -	       .byte	%0001, %0001, %0011, %0011
   4157  276af				   -	       .byte	%0001, %0001, %0011, %0011
   4158  276af				   -
   4159  276af				   -			; null change bits
   4160  276af				   -	       .byte	%0000, %0001, %0010, %0011
   4161  276af				   -	       .byte	%0000, %0001, %0010, %0011
   4162  276af				   -	       .byte	%0000, %0001, %0010, %0011
   4163  276af				   -	       .byte	%0000, %0001, %0010, %0011
   4164  276af				   -
   4165  276af				   -	       else		; !MOUSEXONLY
   4166  276af				   -
   4167  276af				   -amigatoataribits		; swap bits 1 and 4...
   4168  276af				   -	       .byte	%0000, %1000, %0010, %1010
   4169  276af				   -	       .byte	%0100, %1100, %0110, %1110
   4170  276af				   -	       .byte	%0001, %1001, %0011, %1011
   4171  276af				   -	       .byte	%0101, %1101, %0111, %1111
   4172  276af				   -			; null change bits
   4173  276af				   -	       .byte	%0000, %0001, %0010, %0011
   4174  276af				   -	       .byte	%0100, %0101, %0110, %0111
   4175  276af				   -	       .byte	%1000, %1001, %1010, %1011
   4176  276af				   -	       .byte	%1100, %1101, %1110, %1111
   4177  276af				   -	       endif		; !MOUSEXONLY
   4178  276af				   -
   4179  276af					       endif		; MOUSESUPPORT
   4180  276af
   4181  276af				    mouse0update
   4182  276af				   -	       ifconst	MOUSE0SUPPORT
   4183  276af				   -
   4184  276af				   -mousetableselect =	inttemp2
   4185  276af				   -mousexdelta =	inttemp3
   4186  276af				   -mouseydelta =	inttemp4
   4187  276af				   -lastSWCHA  =	inttemp6
   4188  276af				   -
   4189  276af				   -			;  0000YyXx st mouse
   4190  276af				   -			;  0000xyXY amiga mouse
   4191  276af				   -
   4192  276af				   -	       lda	#$ff
   4193  276af				   -	       sta	lastSWCHA
   4194  276af				   -
   4195  276af				   -	       ldy	port0control
   4196  276af				   -
   4197  276af				   -	       lda	#%00010000
   4198  276af				   -	       cpy	#9	; AMIGA?
   4199  276af				   -	       bne	skipamigabitsfix0
   4200  276af				   -	       lda	#0
   4201  276af				   -skipamigabitsfix0
   4202  276af				   -	       sta	mousetableselect
   4203  276af				   -	       ifconst	DRIVINGBOOST
   4204  276af				   -	       cpy	#6	; DRIVING?
   4205  276af				   -	       bne	skipdriving0setup
   4206  276af				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   4207  276af				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   4208  276af				   -			; the actual position. This actual position is stored in mousey0 
   4209  276af				   -			; after the driver has run.
   4210  276af				   -	       ldx	mousex0
   4211  276af				   -	       lda	mousey0
   4212  276af				   -	       stx	mousey0
   4213  276af				   -	       sta	mousex0
   4214  276af				   -skipdriving0setup
   4215  276af				   -	       endif		; DRIVINGBOOST
   4216  276af				   -
   4217  276af				   -	       lda	#0
   4218  276af				   -	       sta	mousexdelta
   4219  276af				   -	       sta	mouseydelta
   4220  276af				   -
   4221  276af				   -	       ifnconst	MOUSETIME
   4222  276af				   -	       ifnconst	MOUSEXONLY
   4223  276af				   -	       lda	#180	; minimum for x+y
   4224  276af				   -	       else
   4225  276af				   -	       lda	#100	; minimum for just x
   4226  276af				   -	       endif
   4227  276af				   -	       else
   4228  276af				   -	       lda	#MOUSETIME
   4229  276af				   -	       endif
   4230  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4231  276af				   -
   4232  276af				   -mouse0updateloop
   4233  276af				   -	       lda	SWCHA
   4234  276af				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4235  276af				   -	       cmp	lastSWCHA
   4236  276af				   -	       beq	mouse0loopcondition
   4237  276af				   -	       sta	lastSWCHA
   4238  276af				   -	       lsr
   4239  276af				   -	       lsr
   4240  276af				   -	       lsr
   4241  276af				   -
   4242  276af				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4243  276af				   -
   4244  276af				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4245  276af				   -			;  0000YyXx st mouse
   4246  276af				   -			;  0000xyXY amiga mouse
   4247  276af				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4248  276af				   -	       tay
   4249  276af				   -	       lax	amigatoataribits,y
   4250  276af				   -
   4251  276af				   -	       ifnconst	MOUSEXONLY
   4252  276af				   -			; first the Y...
   4253  276af				   -	       and	#%00001100
   4254  276af				   -	       ora	mousecodey0
   4255  276af				   -	       tay
   4256  276af				   -	       lda	rotationalcompare,y
   4257  276af				   -	       clc
   4258  276af				   -	       adc	mouseydelta
   4259  276af				   -	       sta	mouseydelta
   4260  276af				   -	       tya
   4261  276af				   -	       lsr
   4262  276af				   -	       lsr
   4263  276af				   -	       sta	mousecodey0
   4264  276af				   -	       txa
   4265  276af				   -			; ...then the X...
   4266  276af				   -	       and	#%00000011
   4267  276af				   -	       tax
   4268  276af				   -	       endif		; !MOUSEXONLY
   4269  276af				   -
   4270  276af				   -	       asl
   4271  276af				   -	       asl
   4272  276af				   -	       ora	mousecodex0
   4273  276af				   -	       tay
   4274  276af				   -	       lda	rotationalcompare,y
   4275  276af				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4276  276af				   -	       sta	mousexdelta
   4277  276af				   -	       stx	mousecodex0
   4278  276af				   -mouse0loopcondition
   4279  276af				   -	       lda	TIMINT
   4280  276af				   -	       bpl	mouse0updateloop
   4281  276af				   -
   4282  276af				   -			; *** adapt to selected device resolution. 
   4283  276af				   -	       ldx	port0control
   4284  276af				   -
   4285  276af				   -	       ifconst	PRECISIONMOUSING
   4286  276af				   -	       ldy	port0resolution
   4287  276af				   -	       bne	mouse0halveddone
   4288  276af				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4289  276af				   -	       beq	mouse0halveddone
   4290  276af				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4291  276af				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4292  276af				   -
   4293  276af				   -	       lda	mousexdelta
   4294  276af				   -	       cmp	#$80
   4295  276af				   -	       ror		; do a signed divide by 2.
   4296  276af				   -	       clc
   4297  276af				   -	       adc	mousex0
   4298  276af				   -	       sta	mousex0
   4299  276af				   -	       ifnconst	MOUSEXONLY
   4300  276af				   -	       lda	mouseydelta
   4301  276af				   -	       clc
   4302  276af				   -	       adc	mousey0
   4303  276af				   -	       sta	mousey0
   4304  276af				   -	       endif
   4305  276af				   -			; at half resolution we just exit after updating x and y
   4306  276af				   -	       jmp	LLRET0
   4307  276af				   -mouse0halveddone
   4308  276af				   -	       endif		; PRECISIONMOUSING
   4309  276af				   -
   4310  276af				   -	       ifnconst	MOUSEXONLY
   4311  276af				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4312  276af				   -	       ldy	port0resolution
   4313  276af				   -	       dey
   4314  276af				   -	       lda	#0
   4315  276af				   -mousey0resolutionfix
   4316  276af				   -	       clc
   4317  276af				   -	       adc	mouseydelta
   4318  276af				   -	       dey
   4319  276af				   -	       bpl	mousey0resolutionfix
   4320  276af				   -	       clc
   4321  276af				   -	       adc	mousey0
   4322  276af				   -	       sta	mousey0
   4323  276af				   -	       endif		; MOUSEXONLY
   4324  276af				   -
   4325  276af				   -	       ldy	port0resolution
   4326  276af				   -	       dey
   4327  276af				   -	       lda	#0
   4328  276af				   -mousex0resolutionfix
   4329  276af				   -	       clc
   4330  276af				   -	       adc	mousexdelta
   4331  276af				   -	       dey
   4332  276af				   -	       bpl	mousex0resolutionfix
   4333  276af				   -	       ifnconst	DRIVINGBOOST
   4334  276af				   -	       clc
   4335  276af				   -	       adc	mousex0
   4336  276af				   -	       sta	mousex0
   4337  276af				   -	       else
   4338  276af				   -	       cpx	#6
   4339  276af				   -	       beq	carryonmouse0boost
   4340  276af				   -	       clc
   4341  276af				   -	       adc	mousex0
   4342  276af				   -	       sta	mousex0
   4343  276af				   -	       jmp	LLRET0
   4344  276af				   -carryonmouse0boost
   4345  276af				   -	       sta	mousexdelta
   4346  276af				   -	       clc
   4347  276af				   -	       adc	mousecodey0
   4348  276af				   -	       sta	mousecodey0
   4349  276af				   -	       clc
   4350  276af				   -	       adc	mousex0
   4351  276af				   -	       tay		; save the target X
   4352  276af				   -	       adc	mousey0	; average in the smoothly-trailing X
   4353  276af				   -	       ror
   4354  276af				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   4355  276af				   -	       sty	mousey0	; and mousey0 has the the target X
   4356  276af				   -
   4357  276af				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4358  276af				   -			; A has mousex0, the smoothly trailing X
   4359  276af				   -	       sbc	mousey0	; less the target X
   4360  276af				   -	       bpl	skipabsolutedrive0
   4361  276af				   -	       eor	#$ff
   4362  276af				   -skipabsolutedrive0
   4363  276af				   -	       cmp	#64	; just an unreasonably large change
   4364  276af				   -	       bcc	skipdrivewrapfix0
   4365  276af				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   4366  276af				   -skipdrivewrapfix0
   4367  276af				   -
   4368  276af				   -			; get rid of the tweening if the distance travelled was very small
   4369  276af				   -	       lda	mousexdelta
   4370  276af				   -	       cmp	port0resolution
   4371  276af				   -	       bcs	skipbetweenfix0
   4372  276af				   -	       lda	mousex0
   4373  276af				   -	       sta	mousey0
   4374  276af				   -skipbetweenfix0
   4375  276af				   -
   4376  276af				   -drivingboostreductioncheck0
   4377  276af				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4378  276af				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4379  276af				   -			; negated again because truncation during BCD math results in 
   4380  276af				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4381  276af				   -driving0fix
   4382  276af				   -	       lax	mousecodey0
   4383  276af				   -	       cmp	#$80
   4384  276af				   -	       bcs	driving0skipnegate1
   4385  276af				   -	       eor	#$FF
   4386  276af				   -	       adc	#1
   4387  276af				   -	       sta	mousecodey0
   4388  276af				   -driving0skipnegate1
   4389  276af				   -	       cmp	#$80
   4390  276af				   -	       ror
   4391  276af				   -	       cmp	#$80
   4392  276af				   -	       ror
   4393  276af				   -	       cmp	#$80
   4394  276af				   -	       ror
   4395  276af				   -	       sta	inttemp1
   4396  276af				   -	       lda	mousecodey0
   4397  276af				   -	       sec
   4398  276af				   -	       sbc	inttemp1
   4399  276af				   -	       cpx	#$80
   4400  276af				   -	       bcs	driving0skipnegate2
   4401  276af				   -	       eor	#$FF
   4402  276af				   -	       adc	#1
   4403  276af				   -driving0skipnegate2
   4404  276af				   -	       sta	mousecodey0
   4405  276af				   -drivingboostdone0
   4406  276af				   -	       endif		; DRIVINGBOOST
   4407  276af				   -
   4408  276af				   -	       jmp	LLRET0
   4409  276af				   -
   4410  276af					       endif		; MOUSE0SUPPORT
   4411  276af
   4412  276af				    mouse1update
   4413  276af				   -	       ifconst	MOUSE1SUPPORT
   4414  276af				   -
   4415  276af				   -mousetableselect =	inttemp2
   4416  276af				   -mousexdelta =	inttemp3
   4417  276af				   -mouseydelta =	inttemp4
   4418  276af				   -lastSWCHA  =	inttemp6
   4419  276af				   -
   4420  276af				   -			;  0000YyXx st mouse
   4421  276af				   -			;  0000xyXY amiga mouse
   4422  276af				   -
   4423  276af				   -	       lda	#$ff
   4424  276af				   -	       sta	lastSWCHA
   4425  276af				   -
   4426  276af				   -	       ldy	port1control
   4427  276af				   -
   4428  276af				   -	       lda	#%00010000
   4429  276af				   -	       cpy	#9	; AMIGA?
   4430  276af				   -	       bne	skipamigabitsfix1
   4431  276af				   -	       lda	#0
   4432  276af				   -skipamigabitsfix1
   4433  276af				   -	       sta	mousetableselect
   4434  276af				   -	       ifconst	DRIVINGBOOST
   4435  276af				   -	       cpy	#6	; DRIVING?
   4436  276af				   -	       bne	skipdriving1setup
   4437  276af				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   4438  276af				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   4439  276af				   -			; the actual position. This actual position is stored in mousey1 
   4440  276af				   -			; after the driver has run.
   4441  276af				   -	       ldx	mousex1
   4442  276af				   -	       lda	mousey1
   4443  276af				   -	       stx	mousey1
   4444  276af				   -	       sta	mousex1
   4445  276af				   -skipdriving1setup
   4446  276af				   -	       endif		; DRIVINGBOOST
   4447  276af				   -
   4448  276af				   -	       lda	#0
   4449  276af				   -	       sta	mousexdelta
   4450  276af				   -	       sta	mouseydelta
   4451  276af				   -
   4452  276af				   -	       ifnconst	MOUSETIME
   4453  276af				   -	       ifnconst	MOUSEXONLY
   4454  276af				   -	       lda	#180	; minimum for x+y
   4455  276af				   -	       else
   4456  276af				   -	       lda	#100	; minimum for just x
   4457  276af				   -	       endif
   4458  276af				   -	       else
   4459  276af				   -	       lda	#MOUSETIME
   4460  276af				   -	       endif
   4461  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4462  276af				   -
   4463  276af				   -mouse1updateloop
   4464  276af				   -	       lda	SWCHA
   4465  276af				   -	       and	#%00001111
   4466  276af				   -	       cmp	lastSWCHA
   4467  276af				   -	       beq	mouse1loopcondition
   4468  276af				   -	       sta	lastSWCHA
   4469  276af				   -
   4470  276af				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4471  276af				   -
   4472  276af				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4473  276af				   -			;  0000YyXx st mouse
   4474  276af				   -			;  0000xyXY amiga mouse
   4475  276af				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4476  276af				   -	       tay
   4477  276af				   -	       lax	amigatoataribits,y
   4478  276af				   -
   4479  276af				   -	       ifnconst	MOUSEXONLY
   4480  276af				   -			; first the Y...
   4481  276af				   -	       and	#%00001100
   4482  276af				   -	       ora	mousecodey1
   4483  276af				   -	       tay
   4484  276af				   -	       lda	rotationalcompare,y
   4485  276af				   -	       clc
   4486  276af				   -	       adc	mouseydelta
   4487  276af				   -	       sta	mouseydelta
   4488  276af				   -	       tya
   4489  276af				   -	       lsr
   4490  276af				   -	       lsr
   4491  276af				   -	       sta	mousecodey1
   4492  276af				   -	       txa
   4493  276af				   -			; ...then the X...
   4494  276af				   -	       and	#%00000011
   4495  276af				   -	       tax
   4496  276af				   -	       endif		; !MOUSEXONLY
   4497  276af				   -
   4498  276af				   -	       asl
   4499  276af				   -	       asl
   4500  276af				   -	       ora	mousecodex1
   4501  276af				   -	       tay
   4502  276af				   -	       lda	rotationalcompare,y
   4503  276af				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4504  276af				   -	       sta	mousexdelta
   4505  276af				   -	       stx	mousecodex1
   4506  276af				   -mouse1loopcondition
   4507  276af				   -	       lda	TIMINT
   4508  276af				   -	       bpl	mouse1updateloop
   4509  276af				   -
   4510  276af				   -			; *** adapt to selected device resolution. 
   4511  276af				   -	       ldx	port1control
   4512  276af				   -
   4513  276af				   -	       ifconst	PRECISIONMOUSING
   4514  276af				   -	       ldy	port1resolution
   4515  276af				   -	       bne	mouse1halveddone
   4516  276af				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4517  276af				   -	       beq	mouse1halveddone
   4518  276af				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4519  276af				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4520  276af				   -
   4521  276af				   -	       lda	mousexdelta
   4522  276af				   -	       cmp	#$80
   4523  276af				   -	       ror		; do a signed divide by 2.
   4524  276af				   -	       clc
   4525  276af				   -	       adc	mousex1
   4526  276af				   -	       sta	mousex1
   4527  276af				   -	       ifnconst	MOUSEXONLY
   4528  276af				   -	       lda	mouseydelta
   4529  276af				   -	       clc
   4530  276af				   -	       adc	mousey1
   4531  276af				   -	       sta	mousey1
   4532  276af				   -	       endif
   4533  276af				   -			; at half resolution we just exit after updating x and y
   4534  276af				   -	       jmp	LLRET1
   4535  276af				   -mouse1halveddone
   4536  276af				   -	       endif		; PRECISIONMOUSING
   4537  276af				   -
   4538  276af				   -	       ifnconst	MOUSEXONLY
   4539  276af				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4540  276af				   -	       ldy	port1resolution
   4541  276af				   -	       dey
   4542  276af				   -	       lda	#0
   4543  276af				   -mousey1resolutionfix
   4544  276af				   -	       clc
   4545  276af				   -	       adc	mouseydelta
   4546  276af				   -	       dey
   4547  276af				   -	       bpl	mousey1resolutionfix
   4548  276af				   -	       clc
   4549  276af				   -	       adc	mousey1
   4550  276af				   -	       sta	mousey1
   4551  276af				   -	       endif		; MOUSEXONLY
   4552  276af				   -
   4553  276af				   -	       ldy	port1resolution
   4554  276af				   -	       dey
   4555  276af				   -	       lda	#0
   4556  276af				   -mousex1resolutionfix
   4557  276af				   -	       clc
   4558  276af				   -	       adc	mousexdelta
   4559  276af				   -	       dey
   4560  276af				   -	       bpl	mousex1resolutionfix
   4561  276af				   -	       ifnconst	DRIVINGBOOST
   4562  276af				   -	       clc
   4563  276af				   -	       adc	mousex1
   4564  276af				   -	       sta	mousex1
   4565  276af				   -	       else
   4566  276af				   -	       cpx	#6
   4567  276af				   -	       beq	carryonmouse1boost
   4568  276af				   -	       clc
   4569  276af				   -	       adc	mousex1
   4570  276af				   -	       sta	mousex1
   4571  276af				   -	       jmp	LLRET1
   4572  276af				   -carryonmouse1boost
   4573  276af				   -	       sta	mousexdelta
   4574  276af				   -	       clc
   4575  276af				   -	       adc	mousecodey1
   4576  276af				   -	       sta	mousecodey1
   4577  276af				   -	       clc
   4578  276af				   -	       adc	mousex1
   4579  276af				   -	       tay		; save the target X
   4580  276af				   -	       adc	mousey1	; average in the smoothly-trailing X
   4581  276af				   -	       ror
   4582  276af				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   4583  276af				   -	       sty	mousey1	; and mousey0 has the the target X
   4584  276af				   -
   4585  276af				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   4586  276af				   -			; A has mousex1, the smoothly trailing X
   4587  276af				   -	       sbc	mousey1	; less the target X
   4588  276af				   -	       bpl	skipabsolutedrive1
   4589  276af				   -	       eor	#$ff
   4590  276af				   -skipabsolutedrive1
   4591  276af				   -	       cmp	#64	; just an unreasonably large change
   4592  276af				   -	       bcc	skipdrivewrapfix1
   4593  276af				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   4594  276af				   -skipdrivewrapfix1
   4595  276af				   -
   4596  276af				   -			; get rid of the tweening if the distance travelled was very small
   4597  276af				   -	       lda	mousexdelta
   4598  276af				   -	       cmp	port1resolution
   4599  276af				   -	       bcs	skipbetweenfix1
   4600  276af				   -	       lda	mousex1
   4601  276af				   -	       sta	mousey1
   4602  276af				   -skipbetweenfix1
   4603  276af				   -
   4604  276af				   -drivingboostreductioncheck1
   4605  276af				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   4606  276af				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   4607  276af				   -			; negated again because truncation during BCD math results in 
   4608  276af				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   4609  276af				   -driving1fix
   4610  276af				   -	       lax	mousecodey1
   4611  276af				   -	       cmp	#$80
   4612  276af				   -	       bcs	driving0skipnegate1
   4613  276af				   -	       eor	#$FF
   4614  276af				   -	       adc	#1
   4615  276af				   -	       sta	mousecodey1
   4616  276af				   -driving0skipnegate1
   4617  276af				   -	       cmp	#$80
   4618  276af				   -	       ror
   4619  276af				   -	       cmp	#$80
   4620  276af				   -	       ror
   4621  276af				   -	       cmp	#$80
   4622  276af				   -	       ror
   4623  276af				   -	       sta	inttemp1
   4624  276af				   -	       lda	mousecodey1
   4625  276af				   -	       sec
   4626  276af				   -	       sbc	inttemp1
   4627  276af				   -	       cpx	#$80
   4628  276af				   -	       bcs	driving1skipnegate2
   4629  276af				   -	       eor	#$FF
   4630  276af				   -	       adc	#1
   4631  276af				   -driving1skipnegate2
   4632  276af				   -	       sta	mousecodey1
   4633  276af				   -drivingboostdone1
   4634  276af				   -	       endif		; DRIVINGBOOST
   4635  276af				   -
   4636  276af				   -	       jmp	LLRET1
   4637  276af				   -
   4638  276af					       endif		; MOUSE1SUPPORT
   4639  276af
   4640  276af
   4641  276af				    trakball0update
   4642  276af				   -	       ifconst	TRAKBALL0SUPPORT
   4643  276af				   -	       ifnconst	TRAKTIME
   4644  276af				   -	       ifnconst	TRAKXONLY
   4645  276af				   -	       lda	#180	; minimum for x+y
   4646  276af				   -	       else		;  !TRAKXONLY
   4647  276af				   -	       lda	#100	; minimum for just x
   4648  276af				   -	       endif		; !TRAKXONLY
   4649  276af				   -	       else		; !TRAKTIME
   4650  276af				   -	       lda	#TRAKTIME
   4651  276af				   -	       endif		; !TRAKTIME
   4652  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4653  276af				   -	       ldx	#0
   4654  276af				   -	       ifnconst	TRAKXONLY
   4655  276af				   -	       ldy	#0
   4656  276af				   -	       endif		;  TRAKXONLY
   4657  276af				   -trakball0updateloop
   4658  276af				   -	       lda	SWCHA
   4659  276af				   -	       and	#%00110000
   4660  276af				   -	       cmp	trakballcodex0
   4661  276af				   -	       sta	trakballcodex0
   4662  276af				   -	       beq	trakball0movementXdone
   4663  276af				   -	       and	#%00010000
   4664  276af				   -	       beq	trakball0negativeX
   4665  276af				   -trakball0positiveX
   4666  276af				   -			;(2 from beq)
   4667  276af				   -	       inx		; 2
   4668  276af				   -	       jmp	trakball0movementXdone	; 3
   4669  276af				   -trakball0negativeX
   4670  276af				   -			;(3 from beq)
   4671  276af				   -	       dex		; 2
   4672  276af				   -	       nop		; 2
   4673  276af				   -trakball0movementXdone
   4674  276af				   -
   4675  276af				   -	       ifnconst	TRAKXONLY
   4676  276af				   -	       lda	SWCHA
   4677  276af				   -	       and	#%11000000
   4678  276af				   -	       cmp	trakballcodey0
   4679  276af				   -	       sta	trakballcodey0
   4680  276af				   -	       beq	trakball0movementYdone
   4681  276af				   -	       and	#%01000000
   4682  276af				   -	       beq	trakball0negativeY
   4683  276af				   -trakball0positiveY
   4684  276af				   -			;(2 from beq)
   4685  276af				   -	       iny		; 2
   4686  276af				   -	       jmp	trakball0movementYdone	; 3
   4687  276af				   -trakball0negativeY
   4688  276af				   -			;(3 from beq)
   4689  276af				   -	       dey		; 2
   4690  276af				   -	       nop		; 2
   4691  276af				   -trakball0movementYdone
   4692  276af				   -	       endif		; !TRAKXONLY
   4693  276af				   -
   4694  276af				   -	       lda	TIMINT
   4695  276af				   -	       bpl	trakball0updateloop
   4696  276af				   -	       lda	#0
   4697  276af				   -	       cpx	#0
   4698  276af				   -	       beq	trakball0skipXadjust
   4699  276af				   -	       clc
   4700  276af				   -trakball0Xloop
   4701  276af				   -	       adc	port0resolution
   4702  276af				   -	       dex
   4703  276af				   -	       bne	trakball0Xloop
   4704  276af				   -	       clc
   4705  276af				   -	       adc	trakballx0
   4706  276af				   -	       sta	trakballx0
   4707  276af				   -trakball0skipXadjust
   4708  276af				   -	       ifnconst	TRAKXONLY
   4709  276af				   -	       lda	#0
   4710  276af				   -	       cpy	#0
   4711  276af				   -	       beq	trakball0skipYadjust
   4712  276af				   -	       clc
   4713  276af				   -trakball0yloop
   4714  276af				   -	       adc	port0resolution
   4715  276af				   -	       dey
   4716  276af				   -	       bne	trakball0yloop
   4717  276af				   -	       clc
   4718  276af				   -	       adc	trakbally0
   4719  276af				   -	       sta	trakbally0
   4720  276af				   -trakball0skipYadjust
   4721  276af				   -	       endif		; !TRAKXONLY
   4722  276af				   -
   4723  276af				   -	       jmp	LLRET0
   4724  276af					       endif
   4725  276af
   4726  276af
   4727  276af
   4728  276af				    trakball1update
   4729  276af				   -	       ifconst	TRAKBALL1SUPPORT
   4730  276af				   -	       ifnconst	TRAKTIME
   4731  276af				   -	       ifnconst	TRAKXONLY
   4732  276af				   -	       lda	#180	; minimum for x+y
   4733  276af				   -	       else		;  !TRAKXONLY
   4734  276af				   -	       lda	#100	; minimum for just x
   4735  276af				   -	       endif		; !TRAKXONLY
   4736  276af				   -	       else		; !TRAKTIME
   4737  276af				   -	       lda	#TRAKTIME
   4738  276af				   -	       endif		; !TRAKTIME
   4739  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4740  276af				   -	       ldx	#0
   4741  276af				   -	       ifnconst	TRAKXONLY
   4742  276af				   -	       ldy	#0
   4743  276af				   -	       endif		;  TRAKXONLY
   4744  276af				   -trakball1updateloop
   4745  276af				   -	       lda	SWCHA
   4746  276af				   -	       and	#%00000011
   4747  276af				   -	       cmp	trakballcodex1
   4748  276af				   -	       sta	trakballcodex1
   4749  276af				   -	       beq	trakball1movementXdone
   4750  276af				   -	       and	#%00000001
   4751  276af				   -	       beq	trakball1negativeX
   4752  276af				   -trakball1positiveX
   4753  276af				   -			;(2 from beq)
   4754  276af				   -	       inx		; 2
   4755  276af				   -	       jmp	trakball1movementXdone	; 3
   4756  276af				   -trakball1negativeX
   4757  276af				   -			;(3 from beq)
   4758  276af				   -	       dex		; 2
   4759  276af				   -	       nop		; 2
   4760  276af				   -trakball1movementXdone
   4761  276af				   -
   4762  276af				   -	       ifnconst	TRAKXONLY
   4763  276af				   -	       lda	SWCHA
   4764  276af				   -	       and	#%00001100
   4765  276af				   -	       cmp	trakballcodey1
   4766  276af				   -	       sta	trakballcodey1
   4767  276af				   -	       beq	trakball1movementYdone
   4768  276af				   -	       and	#%00000100
   4769  276af				   -	       beq	trakball1negativeY
   4770  276af				   -trakball1positiveY
   4771  276af				   -			;(2 from beq)
   4772  276af				   -	       iny		; 2
   4773  276af				   -	       jmp	trakball1movementYdone	; 3
   4774  276af				   -trakball1negativeY
   4775  276af				   -			;(3 from beq)
   4776  276af				   -	       dey		; 2
   4777  276af				   -	       nop		; 2
   4778  276af				   -trakball1movementYdone
   4779  276af				   -	       endif		; !TRAKXONLY
   4780  276af				   -
   4781  276af				   -	       lda	TIMINT
   4782  276af				   -	       bpl	trakball1updateloop
   4783  276af				   -	       lda	#0
   4784  276af				   -	       cpx	#0
   4785  276af				   -	       beq	trakball1skipXadjust
   4786  276af				   -	       clc
   4787  276af				   -trakball1Xloop
   4788  276af				   -	       adc	port1resolution
   4789  276af				   -	       dex
   4790  276af				   -	       bne	trakball1Xloop
   4791  276af				   -	       clc
   4792  276af				   -	       adc	trakballx1
   4793  276af				   -	       sta	trakballx1
   4794  276af				   -trakball1skipXadjust
   4795  276af				   -	       ifnconst	TRAKXONLY
   4796  276af				   -	       lda	#0
   4797  276af				   -	       cpy	#0
   4798  276af				   -	       beq	trakball1skipYadjust
   4799  276af				   -	       clc
   4800  276af				   -trakball1yloop
   4801  276af				   -	       adc	port1resolution
   4802  276af				   -	       dey
   4803  276af				   -	       bne	trakball1yloop
   4804  276af				   -	       clc
   4805  276af				   -	       adc	trakbally1
   4806  276af				   -	       sta	trakbally1
   4807  276af				   -trakball1skipYadjust
   4808  276af				   -	       endif		; !TRAKXONLY
   4809  276af				   -
   4810  276af				   -	       jmp	LLRET1
   4811  276af					       endif
   4812  276af
   4813  276af
   4814  276af				    paddleport0update
   4815  276af				   -	       ifconst	PADDLE0SUPPORT
   4816  276af				   -	       lda	#6
   4817  276af				   -	       sta	VBLANK	; start charging the paddle caps
   4818  276af				   -	       lda	#0	; use PADDLE timing
   4819  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4820  276af				   -
   4821  276af				   -paddleport0updateloop
   4822  276af				   -	       lda	INPT0
   4823  276af				   -	       bmi	skippaddle0setposition
   4824  276af				   -	       sty	paddleposition0
   4825  276af				   -skippaddle0setposition
   4826  276af				   -	       ifconst	TWOPADDLESUPPORT
   4827  276af				   -	       lda	INPT1
   4828  276af				   -	       bmi	skippaddle1setposition
   4829  276af				   -	       sty	paddleposition1
   4830  276af				   -skippaddle1setposition
   4831  276af				   -	       endif
   4832  276af				   -	       ldy	INTIM
   4833  276af				   -	       cpy	#TIMEOFFSET
   4834  276af				   -	       bcs	paddleport0updateloop
   4835  276af				   -
   4836  276af				   -	       lda	#%10000110
   4837  276af				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4838  276af				   -	       sec
   4839  276af				   -	       lda	paddleposition0
   4840  276af				   -	       sbc	#TIMEOFFSET
   4841  276af				   -	       ifconst	PADDLESCALEX2
   4842  276af				   -	       asl
   4843  276af				   -	       endif
   4844  276af				   -
   4845  276af				   -	       ifnconst	PADDLESMOOTHINGOFF
   4846  276af				   -	       clc
   4847  276af				   -	       adc	paddleprevious0
   4848  276af				   -	       ror
   4849  276af				   -	       sta	paddleprevious0
   4850  276af				   -	       endif
   4851  276af				   -
   4852  276af				   -	       sta	paddleposition0
   4853  276af				   -
   4854  276af				   -	       ifconst	TWOPADDLESUPPORT
   4855  276af				   -	       sec
   4856  276af				   -	       lda	paddleposition1
   4857  276af				   -	       sbc	#TIMEOFFSET
   4858  276af				   -	       ifconst	PADDLESCALEX2
   4859  276af				   -	       asl
   4860  276af				   -	       endif
   4861  276af				   -
   4862  276af				   -	       ifnconst	PADDLESMOOTHINGOFF
   4863  276af				   -	       clc
   4864  276af				   -	       adc	paddleprevious1
   4865  276af				   -	       ror
   4866  276af				   -	       sta	paddleprevious1
   4867  276af				   -	       endif
   4868  276af				   -	       sta	paddleposition1
   4869  276af				   -	       endif		; TWOPADDLESUPPORT
   4870  276af				   -
   4871  276af				   -	       jmp	LLRET0
   4872  276af					       endif
   4873  276af
   4874  276af				    paddleport1update
   4875  276af				   -	       ifconst	PADDLE1SUPPORT
   4876  276af				   -	       lda	#6
   4877  276af				   -	       sta	VBLANK	; start charging the paddle caps
   4878  276af				   -
   4879  276af				   -	       lda	#0	; use PADDLE timing
   4880  276af				   -	       jsr	SETTIM64T	; INTIM is in Y
   4881  276af				   -
   4882  276af				   -paddleport1updateloop
   4883  276af				   -	       lda	INPT2
   4884  276af				   -	       bmi	skippaddle2setposition
   4885  276af				   -	       sty	paddleposition2
   4886  276af				   -skippaddle2setposition
   4887  276af				   -	       ifconst	TWOPADDLESUPPORT
   4888  276af				   -	       lda	INPT3
   4889  276af				   -	       bmi	skippaddle3setposition
   4890  276af				   -	       sty	paddleposition3
   4891  276af				   -skippaddle3setposition
   4892  276af				   -	       endif
   4893  276af				   -	       ldy	INTIM
   4894  276af				   -	       cpy	#TIMEOFFSET
   4895  276af				   -	       bcs	paddleport1updateloop
   4896  276af				   -
   4897  276af				   -	       lda	#%10000110
   4898  276af				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   4899  276af				   -	       sec
   4900  276af				   -	       lda	paddleposition2
   4901  276af				   -	       sbc	#TIMEOFFSET
   4902  276af				   -	       ifconst	PADDLESCALEX2
   4903  276af				   -	       asl
   4904  276af				   -	       endif
   4905  276af				   -
   4906  276af				   -	       ifnconst	PADDLESMOOTHINGOFF
   4907  276af				   -	       clc
   4908  276af				   -	       adc	paddleprevious2
   4909  276af				   -	       ror
   4910  276af				   -	       sta	paddleprevious2
   4911  276af				   -	       endif
   4912  276af				   -
   4913  276af				   -	       sta	paddleposition2
   4914  276af				   -
   4915  276af				   -	       ifconst	TWOPADDLESUPPORT
   4916  276af				   -	       sec
   4917  276af				   -	       lda	paddleposition3
   4918  276af				   -	       sbc	#TIMEOFFSET
   4919  276af				   -	       ifconst	PADDLESCALEX2
   4920  276af				   -	       asl
   4921  276af				   -	       endif
   4922  276af				   -
   4923  276af				   -	       ifnconst	PADDLESMOOTHINGOFF
   4924  276af				   -	       clc
   4925  276af				   -	       adc	paddleprevious3
   4926  276af				   -	       ror
   4927  276af				   -	       sta	paddleprevious3
   4928  276af				   -	       endif
   4929  276af				   -	       sta	paddleposition3
   4930  276af				   -	       endif		; TWOPADDLESUPPORT
   4931  276af				   -
   4932  276af				   -	       jmp	LLRET1
   4933  276af					       endif
   4934  276af
   4935  276af
   4936  276af				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   4937  276af				   -	       ifconst	PADDLESUPPORT
   4938  276af				   -			; x=0|1 for port, rather than paddle #. 
   4939  276af				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   4940  276af				   -			; game wants to support 2 paddles, up to the game to instead test the 
   4941  276af				   -			; joystick right+left directions instead.
   4942  276af				   -	       lda	SWCHA	; top of nibble is first paddle button
   4943  276af				   -	       cpx	#0	; port 0?
   4944  276af				   -	       beq	skippaddleport2shift
   4945  276af				   -	       asl		; shift second port to upper nibble
   4946  276af				   -	       asl
   4947  276af				   -	       asl
   4948  276af				   -	       asl
   4949  276af				   -skippaddleport2shift
   4950  276af				   -	       and	#%10000000
   4951  276af				   -	       eor	#%10000000	; invert
   4952  276af				   -	       sta	sINPT1,x
   4953  276af				   -	       jmp	buttonreadloopreturn
   4954  276af					       endif		; PADDLESUPPORT
   4955  276af
   4956  276af				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   4957  276af				   -	       ifconst	MOUSESUPPORT
   4958  276af				   -			; stick the mouse buttons in the correct shadow register...
   4959  276af				   -	       txa
   4960  276af				   -	       asl
   4961  276af				   -	       tay		; y=x*2
   4962  276af				   -	       lda	INPT4,x
   4963  276af				   -	       eor	#%10000000
   4964  276af				   -	       lsr
   4965  276af				   -	       sta	sINPT1,x
   4966  276af				   -
   4967  276af				   -	       lda	INPT1,y
   4968  276af				   -	       and	#%10000000
   4969  276af				   -	       eor	#%10000000
   4970  276af				   -	       ora	sINPT1,x
   4971  276af				   -	       sta	sINPT1,x
   4972  276af				   -	       jmp	buttonreadloopreturn
   4973  276af					       endif		; MOUSESUPPORT
   4974  276af
   4975  276af				   -	       ifconst	KEYPADSUPPORT
   4976  276af				   -			; ** select keypad rows 0 to 3 over 4 frames...
   4977  276af				   -keypadrowselect
   4978  276af				   -	       ldy	#0
   4979  276af				   -	       lda	port0control
   4980  276af				   -	       cmp	#7
   4981  276af				   -	       bne	skipport0val
   4982  276af				   -	       iny		; y=y+1
   4983  276af				   -skipport0val
   4984  276af				   -	       lda	port1control
   4985  276af				   -	       cmp	#7
   4986  276af				   -	       bne	skipport1val
   4987  276af				   -	       iny
   4988  276af				   -	       iny		; y=y+2
   4989  276af				   -skipport1val
   4990  276af				   -	       lda	keyrowdirectionmask,y
   4991  276af				   -	       sta	CTLSWA
   4992  276af				   -	       tya
   4993  276af				   -	       asl
   4994  276af				   -	       asl
   4995  276af				   -	       sta	inttemp1
   4996  276af				   -	       lda	framecounter
   4997  276af				   -	       and	#3
   4998  276af				   -	       ora	inttemp1
   4999  276af				   -	       tax
   5000  276af				   -	       lda	keyrowselectvalue,x
   5001  276af				   -	       sta	SWCHA
   5002  276af				   -	       rts
   5003  276af				   -
   5004  276af				   -keyrowdirectionmask
   5005  276af				   -	       .byte	#%00000000	; 0 : port0=input  port1=input
   5006  276af				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   5007  276af				   -	       .byte	#%00001111	; 2 : port0=input  port1=output
   5008  276af				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   5009  276af				   -
   5010  276af				   -keyrowselectvalue
   5011  276af				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   5012  276af				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   5013  276af				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   5014  276af				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   5015  276af					       endif		;  KEYPADSUPPORT
   5016  276af
   5017  276af				   -	       ifconst	KEYPADSUPPORT
   5018  276af				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   5019  276af				   -keypadcolumnread
   5020  276af				   -	       lda	port0control
   5021  276af				   -	       cmp	#7
   5022  276af				   -	       bne	skipkeypadcolumnread0
   5023  276af				   -	       lda	framecounter
   5024  276af				   -	       and	#3
   5025  276af				   -	       asl		; x2 because keypad variables are interleaved
   5026  276af				   -	       tax
   5027  276af				   -	       lda	#0
   5028  276af				   -	       sta	keypadmatrix0a,x
   5029  276af				   -	       lda	INPT0
   5030  276af				   -	       cmp	#$80
   5031  276af				   -	       rol	keypadmatrix0a,x
   5032  276af				   -	       lda	INPT1
   5033  276af				   -	       cmp	#$80
   5034  276af				   -	       rol	keypadmatrix0a,x
   5035  276af				   -	       lda	INPT4
   5036  276af				   -	       cmp	#$80
   5037  276af				   -	       rol	keypadmatrix0a,x
   5038  276af				   -	       lda	keypadmatrix0a,x
   5039  276af				   -	       eor	#%00000111
   5040  276af				   -	       sta	keypadmatrix0a,x
   5041  276af				   -skipkeypadcolumnread0
   5042  276af				   -
   5043  276af				   -	       lda	port1control
   5044  276af				   -	       cmp	#7
   5045  276af				   -	       bne	skipkeypadcolumnread1
   5046  276af				   -	       lda	framecounter
   5047  276af				   -	       and	#3
   5048  276af				   -	       asl		; x2 because keypad variables are interleaved
   5049  276af				   -	       tax
   5050  276af				   -	       lda	#0
   5051  276af				   -	       sta	keypadmatrix1a,x
   5052  276af				   -	       rol	keypadmatrix1a,x
   5053  276af				   -	       lda	INPT2
   5054  276af				   -	       cmp	#$80
   5055  276af				   -	       rol	keypadmatrix1a,x
   5056  276af				   -	       lda	INPT3
   5057  276af				   -	       cmp	#$80
   5058  276af				   -	       rol	keypadmatrix1a,x
   5059  276af				   -	       lda	INPT5
   5060  276af				   -	       cmp	#$80
   5061  276af				   -	       rol	keypadmatrix1a,x
   5062  276af				   -	       lda	keypadmatrix1a,x
   5063  276af				   -	       eor	#%00000111
   5064  276af				   -	       sta	keypadmatrix1a,x
   5065  276af				   -skipkeypadcolumnread1
   5066  276af				   -	       rts
   5067  276af					       endif		; KEYPADSUPPORT
   5068  276af
   5069  276af				    setportforinput
   5070  276af			a5 e4		       lda	CTLSWAs
   5071  276b1			3d ba f6	       and	allpinsinputlut,x
   5072  276b4			85 e4		       sta	CTLSWAs
   5073  276b6			8d 81 02	       sta	CTLSWA
   5074  276b9			60		       rts
   5075  276ba
   5076  276ba				    allpinsinputlut
   5077  276ba			0f f0		       .byte.b	$0F, $F0
   5078  276bc
   5079  276bc				    setonebuttonmode
   5080  276bc			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5081  276be			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5082  276c0			a9 14		       lda	#$14
   5083  276c2			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   5084  276c5			a5 e5		       lda	CTLSWBs
   5085  276c7			1d d0 f6	       ora	thisjoy2buttonbit,x
   5086  276ca			85 e5		       sta	CTLSWBs
   5087  276cc			8d 82 02	       sta	SWCHB	; turn off the 2-button disable bits
   5088  276cf			60		       rts
   5089  276d0
   5090  276d0				    thisjoy2buttonbit
   5091  276d0			04 10		       .byte.b	$04, $10
   5092  276d2
   5093  276d2				    settwobuttonmode
   5094  276d2			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5095  276d4			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5096  276d6			a9 14		       lda	#$14
   5097  276d8			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   5098  276db			a5 e5		       lda	CTLSWBs
   5099  276dd			3d e6 f6	       and	thisjoy2buttonmask,x
   5100  276e0			85 e5		       sta	CTLSWBs
   5101  276e2			8d 82 02	       sta	SWCHB
   5102  276e5			60		       rts
   5103  276e6
   5104  276e6				    thisjoy2buttonmask
   5105  276e6			fb ef		       .byte.b	$fb, $ef
   5106  276e8
   5107  276e8							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5108  276e8
   5109  276e8				    START
   5110  276e8				    start
   5111  276e8
   5112  276e8							;******** more or less the Atari recommended startup procedure
   5113  276e8
   5114  276e8			78		       sei
   5115  276e9			d8		       cld
   5116  276ea
   5117  276ea					       ifnconst	NOTIALOCK
   5118  276ea			a9 07		       lda	#$07
   5119  276ec				   -	       else
   5120  276ec				   -	       lda	#$06
   5121  276ec					       endif
   5122  276ec			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   5123  276ee			a9 7f		       lda	#$7F
   5124  276f0			85 3c		       sta	CTRL	;disable DMA
   5125  276f2			a9 00		       lda	#$00
   5126  276f4			85 38		       sta	OFFSET
   5127  276f6					       ifnconst	NOTIALOCK
   5128  276f6			85 01		       sta	INPTCTRL
   5129  276f8					       endif
   5130  276f8			a2 ff		       ldx	#$FF
   5131  276fa			9a		       txs
   5132  276fb
   5133  276fb							;************** Clear Memory
   5134  276fb
   5135  276fb			a2 40		       ldx	#$40
   5136  276fd			a9 00		       lda	#$00
   5137  276ff				    crloop1
   5138  276ff			95 00		       sta	$00,x	;Clear zero page
   5139  27701			9d 00 01	       sta	$100,x	;Clear page 1
   5140  27704			e8		       inx
   5141  27705			d0 f8		       bne	crloop1
   5142  27707
   5143  27707
   5144  27707			a0 00		       ldy	#$00	;Clear Ram
   5145  27709			a9 18		       lda	#$18	;Start at $1800
   5146  2770b			85 81		       sta	$81
   5147  2770d			a9 00		       lda	#$00
   5148  2770f			85 80		       sta	$80
   5149  27711				    crloop3
   5150  27711			a9 00		       lda	#$00
   5151  27713			91 80		       sta	($80),y	;Store data
   5152  27715			c8		       iny		;Next byte
   5153  27716			d0 f9		       bne	crloop3	;Branch if not done page
   5154  27718			e6 81		       inc	$81	;Next page
   5155  2771a			a5 81		       lda	$81
   5156  2771c			c9 20		       cmp	#$20	;End at $1FFF
   5157  2771e			d0 f1		       bne	crloop3	;Branch if not
   5158  27720
   5159  27720			a0 00		       ldy	#$00	;Clear Ram
   5160  27722			a9 22		       lda	#$22	;Start at $2200
   5161  27724			85 81		       sta	$81
   5162  27726			a9 00		       lda	#$00
   5163  27728			85 80		       sta	$80
   5164  2772a				    crloop4
   5165  2772a			a9 00		       lda	#$00
   5166  2772c			91 80		       sta	($80),y	;Store data
   5167  2772e			c8		       iny		;Next byte
   5168  2772f			d0 f9		       bne	crloop4	;Branch if not done page
   5169  27731			e6 81		       inc	$81	;Next page
   5170  27733			a5 81		       lda	$81
   5171  27735			c9 27		       cmp	#$27	;End at $27FF
   5172  27737			d0 f1		       bne	crloop4	;Branch if not
   5173  27739
   5174  27739			a2 00		       ldx	#$00
   5175  2773b			a9 00		       lda	#$00
   5176  2773d				    crloop5		;Clear 2100-213F, 2000-203F
   5177  2773d			9d 00 20	       sta	$2000,x
   5178  27740			9d 00 21	       sta	$2100,x
   5179  27743			e8		       inx
   5180  27744			e0 40		       cpx	#$40
   5181  27746			d0 f5		       bne	crloop5
   5182  27748
   5183  27748			85 80		       sta	$80
   5184  2774a			85 81		       sta	$81
   5185  2774c			85 82		       sta	$82
   5186  2774e			85 83		       sta	$83
   5187  27750
   5188  27750							;seed random number with hopefully-random timer value
   5189  27750			a9 01		       lda	#1
   5190  27752			0d 84 02	       ora	INTIM
   5191  27755			85 40		       sta	rand
   5192  27757
   5193  27757							; detect the console type...
   5194  27757				    pndetectvblankstart
   5195  27757			a5 28		       lda	MSTAT
   5196  27759			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5197  2775b				    pndetectvblankover
   5198  2775b			a5 28		       lda	MSTAT
   5199  2775d			30 fc		       bmi	pndetectvblankover	;  then wait for it to be over
   5200  2775f			a0 00		       ldy	#$00
   5201  27761			a2 00		       ldx	#$00
   5202  27763				    pndetectvblankhappening
   5203  27763			a5 28		       lda	MSTAT
   5204  27765			30 07		       bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   5205  27767			85 24		       sta	WSYNC
   5206  27769			85 24		       sta	WSYNC
   5207  2776b			e8		       inx
   5208  2776c			d0 f5		       bne	pndetectvblankhappening
   5209  2776e				    pndetectinvblank
   5210  2776e			e0 7d		       cpx	#125
   5211  27770			90 02		       bcc	pndetecispal
   5212  27772			a0 01		       ldy	#$01
   5213  27774				    pndetecispal
   5214  27774			8c 09 21	       sty	paldetected
   5215  27777
   5216  27777			20 15 f6	       jsr	createallgamedlls
   5217  2777a
   5218  2777a			a9 18		       lda	#>DLLMEM
   5219  2777c			85 2c		       sta	DPPH
   5220  2777e			a9 00		       lda	#<DLLMEM
   5221  27780			85 30		       sta	DPPL
   5222  27782
   5223  27782							; CTRL 76543210
   5224  27782							; 7 colorburst kill
   5225  27782							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5226  27782							; 4 character width 1=2 byte chars, 0=1 byte chars
   5227  27782							; 3 border control 0=background color border, 1=black border
   5228  27782							; 2 kangaroo mode 0=transparancy, 1=kangaroo
   5229  27782							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   5230  27782
   5231  27782				   -	       ifconst	DOUBLEWIDE
   5232  27782				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   5233  27782					       else
   5234  27782			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   5235  27784					       endif
   5236  27784			85 3c		       sta	CTRL
   5237  27786			8d 07 21	       sta	sCTRL
   5238  27789
   5239  27789			20 08 f6	       jsr	vblankresync
   5240  2778c
   5241  2778c			a9 04		       lda	#%00000100	; leave cartridge plugged in for any testing
   5242  2778e			8d b4 01	       sta	XCTRL1s
   5243  27791
   5244  27791					       ifconst	pokeysupport
   5245  27791							; pokey support is compiled in, so try to detect it...
   5246  27791			20 c7 f0	       jsr	detectpokeylocation
   5247  27794					       endif
   5248  27794
   5249  27794			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   5250  27796			8d b7 01	       sta	port0control
   5251  27799			8d b8 01	       sta	port1control
   5252  2779c
   5253  2779c							;Setup port A to read mode
   5254  2779c							;lda #$00
   5255  2779c							;sta SWCHA
   5256  2779c							;sta CTLSWA
   5257  2779c
   5258  2779c				   -	       ifconst	HSSUPPORT
   5259  2779c				   -			; try to detect HSC
   5260  2779c				   -	       jsr	detecthsc
   5261  2779c				   -	       and	#1
   5262  2779c				   -	       sta	hsdevice
   5263  2779c				   -skipHSCdetect
   5264  2779c				   -			; try to detect AtariVox eeprom
   5265  2779c				   -	       jsr	detectatarivoxeeprom
   5266  2779c				   -	       and	#2
   5267  2779c				   -	       ora	hsdevice
   5268  2779c				   -	       cmp	#3
   5269  2779c				   -	       bne	storeAinhsdevice
   5270  2779c				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5271  2779c				   -			; Later we should check each device's priority byte if set, instead, 
   5272  2779c				   -	       lda	#2
   5273  2779c				   -storeAinhsdevice
   5274  2779c				   -	       sta	hsdevice
   5275  2779c				   -	       lda	#$ff
   5276  2779c				   -	       sta	hsdifficulty
   5277  2779c				   -	       sta	hsgameslot
   5278  2779c				   -	       sta	hsnewscoreline
   5279  2779c					       endif
   5280  2779c
   5281  2779c				   -	       ifconst	AVOXVOICE
   5282  2779c				   -	       jsr	silenceavoxvoice
   5283  2779c					       endif
   5284  2779c
   5285  2779c					       ifconst	SGRAM
   5286  2779c							; check if we actually have SGRAM. If not, probe XM for it...
   5287  2779c			a0 ea		       ldy	#$EA
   5288  2779e			8c 00 40	       sty	$4000
   5289  277a1			ac 00 40	       ldy	$4000
   5290  277a4			c0 ea		       cpy	#$EA
   5291  277a6			f0 1d		       beq	skipSGRAMcheck
   5292  277a8			ad b4 01	       lda	XCTRL1s
   5293  277ab			09 64		       ora	#%01100100
   5294  277ad			8d 70 04	       sta	XCTRL1
   5295  277b0			8c 00 40	       sty	$4000
   5296  277b3			ac 00 40	       ldy	$4000
   5297  277b6			c0 ea		       cpy	#$EA
   5298  277b8			d0 0b		       bne	skipSGRAMcheck
   5299  277ba							;if we're here, XM memory satisfied our RAM requirement
   5300  277ba			8d b4 01	       sta	XCTRL1s	; save it
   5301  277bd			a9 10		       lda	#$10
   5302  277bf			8d 78 04	       sta	XCTRL2
   5303  277c2			8d 7c 04	       sta	XCTRL3
   5304  277c5				    skipSGRAMcheck
   5305  277c5					       endif
   5306  277c5
   5307  277c5			a2 01		       ldx	#1
   5308  277c7			20 d2 f6	       jsr	settwobuttonmode
   5309  277ca			a2 00		       ldx	#0
   5310  277cc			20 d2 f6	       jsr	settwobuttonmode
   5311  277cf
   5312  277cf					       ifconst	bankswitchmode
   5313  277cf							; we need to switch to the first bank before we jump there!
   5314  277cf				   -	       ifconst	MCPDEVCART
   5315  277cf				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5316  277cf				   -	       sta	$3000
   5317  277cf					       else
   5318  277cf			a9 00		       lda	#0
   5319  277d1			8d 00 80	       sta	$8000
   5320  277d4					       endif
   5321  277d4					       endif
   5322  277d4
   5323  277d4			4c 00 80	       jmp	game
   5324  277d7
   5325  277d7
   5326  277d7							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5327  277d7
   5328  277d7							;************** Setup DLL entries
   5329  277d7
   5330  277d7							; setup some working definitions, to avoid ifnconst mess elsewhere...
   5331  277d7					       ifnconst	SCREENHEIGHT
   5332  277d7			00 c0	    WSCREENHEIGHT =	192
   5333  277d7				   -	       else
   5334  277d7				   -WSCREENHEIGHT =	SCREENHEIGHT
   5335  277d7					       endif
   5336  277d7
   5337  277d7				   -	       ifnconst	ZONEHEIGHT
   5338  277d7				   -WZONEHEIGHT =	16
   5339  277d7					       else
   5340  277d7			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   5341  277d7					       endif
   5342  277d7
   5343  277d7					       ifnconst	ZONECOUNT
   5344  277d7			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   5345  277d7				   -	       else
   5346  277d7				   -WZONECOUNT =	ZONECOUNT
   5347  277d7					       endif
   5348  277d7
   5349  277d7							; top of the frame, non-visible lines. this is based on NTSC,
   5350  277d7							; but we add in extra NV lines at the end of the display to ensure
   5351  277d7							; our PAL friends can play the game without it crashing.
   5352  277d7			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   5353  277d7
   5354  277d7				   -	       ifnconst	DLMEMSTART
   5355  277d7				   -	       ifnconst	DOUBLEBUFFER
   5356  277d7				   -WDLMEMSTART =	$1880
   5357  277d7				   -	       else
   5358  277d7				   -WDLMEMSTART =	$18E0
   5359  277d7				   -	       endif		; DOUBLEBUFFER
   5360  277d7					       else
   5361  277d7			40 00	    WDLMEMSTART =	DLMEMSTART
   5362  277d7					       endif
   5363  277d7
   5364  277d7				   -	       ifnconst	DLMEMEND
   5365  277d7				   -	       ifconst	EXTRADLMEMORY
   5366  277d7				   -WDLMEMEND  =	$23FF
   5367  277d7				   -	       else
   5368  277d7				   -WDLMEMEND  =	$1FFF
   5369  277d7				   -	       endif
   5370  277d7					       else
   5371  277d7			7f ff	    WDLMEMEND  =	DLMEMEND
   5372  277d7					       endif
   5373  277d7
   5374  277d7
   5375  277d7			40 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   5376  277d7
   5377  277d7					       ifnconst	DOUBLEBUFFER
   5378  277d7			05 50	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   5379  277d7				   -	       else
   5380  277d7				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   5381  277d7					       endif
   5382  277d7
   5383  277d7			05 52	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   5384  277d7					       if	TDOUBLEBUFFEROFFSET > 255
   5385  277d7			00 ff	    DOUBLEBUFFEROFFSET =	255
   5386  277d7				   -	       else
   5387  277d7				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   5388  277d7					       endif
   5389  277d7
   5390  277d7				   -	       ifconst	EXTRADLMEMORY
   5391  277d7				   -SECONDDLHALFSTART SET	$2300
   5392  277d7					       endif
   5393  277d7
   5394  277d7				    DLPOINTH
   5395  277d7				    DLINDEX    SET	0
   5396  277d7					       REPEAT	WZONECOUNT
   5397  277d7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277d7				   -	       ifconst	EXTRADLMEMORY
   5399  277d7				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277d7				   -	       else
   5402  277d7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277d7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277d7				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277d7				   -	       endif
   5406  277d7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277d7					       endif		; EXTRADLMEMORY
   5408  277d7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277d7			40		       .byte.b	>TMPMEMADDRESS
   5410  277d7				    DLINDEX    SET	DLINDEX + 1
   5396  277d7					       REPEND
   5397  277d7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277d8				   -	       ifconst	EXTRADLMEMORY
   5399  277d8				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277d8				   -	       else
   5402  277d8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277d8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277d8				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277d8				   -	       endif
   5406  277d8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277d8					       endif		; EXTRADLMEMORY
   5408  277d8							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277d8			45		       .byte.b	>TMPMEMADDRESS
   5410  277d8				    DLINDEX    SET	DLINDEX + 1
   5396  277d8					       REPEND
   5397  277d8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277d9				   -	       ifconst	EXTRADLMEMORY
   5399  277d9				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277d9				   -	       else
   5402  277d9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277d9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277d9				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277d9				   -	       endif
   5406  277d9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277d9					       endif		; EXTRADLMEMORY
   5408  277d9							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277d9			4a		       .byte.b	>TMPMEMADDRESS
   5410  277d9				    DLINDEX    SET	DLINDEX + 1
   5396  277d9					       REPEND
   5397  277d9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277da				   -	       ifconst	EXTRADLMEMORY
   5399  277da				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277da				   -	       else
   5402  277da				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277da				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277da				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277da				   -	       endif
   5406  277da				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277da					       endif		; EXTRADLMEMORY
   5408  277da							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277da			50		       .byte.b	>TMPMEMADDRESS
   5410  277da				    DLINDEX    SET	DLINDEX + 1
   5396  277da					       REPEND
   5397  277da				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277db				   -	       ifconst	EXTRADLMEMORY
   5399  277db				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277db				   -	       else
   5402  277db				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277db				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277db				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277db				   -	       endif
   5406  277db				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277db					       endif		; EXTRADLMEMORY
   5408  277db							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277db			55		       .byte.b	>TMPMEMADDRESS
   5410  277db				    DLINDEX    SET	DLINDEX + 1
   5396  277db					       REPEND
   5397  277db				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277dc				   -	       ifconst	EXTRADLMEMORY
   5399  277dc				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277dc				   -	       else
   5402  277dc				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277dc				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277dc				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277dc				   -	       endif
   5406  277dc				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277dc					       endif		; EXTRADLMEMORY
   5408  277dc							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277dc			5a		       .byte.b	>TMPMEMADDRESS
   5410  277dc				    DLINDEX    SET	DLINDEX + 1
   5396  277dc					       REPEND
   5397  277dc				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277dd				   -	       ifconst	EXTRADLMEMORY
   5399  277dd				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277dd				   -	       else
   5402  277dd				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277dd				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277dd				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277dd				   -	       endif
   5406  277dd				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277dd					       endif		; EXTRADLMEMORY
   5408  277dd							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277dd			60		       .byte.b	>TMPMEMADDRESS
   5410  277dd				    DLINDEX    SET	DLINDEX + 1
   5396  277dd					       REPEND
   5397  277dd				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277de				   -	       ifconst	EXTRADLMEMORY
   5399  277de				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277de				   -	       else
   5402  277de				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277de				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277de				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277de				   -	       endif
   5406  277de				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277de					       endif		; EXTRADLMEMORY
   5408  277de							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277de			65		       .byte.b	>TMPMEMADDRESS
   5410  277de				    DLINDEX    SET	DLINDEX + 1
   5396  277de					       REPEND
   5397  277de				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277df				   -	       ifconst	EXTRADLMEMORY
   5399  277df				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277df				   -	       else
   5402  277df				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277df				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277df				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277df				   -	       endif
   5406  277df				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277df					       endif		; EXTRADLMEMORY
   5408  277df							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277df			6a		       .byte.b	>TMPMEMADDRESS
   5410  277df				    DLINDEX    SET	DLINDEX + 1
   5396  277df					       REPEND
   5397  277df				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277e0				   -	       ifconst	EXTRADLMEMORY
   5399  277e0				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277e0				   -	       else
   5402  277e0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277e0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277e0				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277e0				   -	       endif
   5406  277e0				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277e0					       endif		; EXTRADLMEMORY
   5408  277e0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277e0			70		       .byte.b	>TMPMEMADDRESS
   5410  277e0				    DLINDEX    SET	DLINDEX + 1
   5396  277e0					       REPEND
   5397  277e0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277e1				   -	       ifconst	EXTRADLMEMORY
   5399  277e1				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277e1				   -	       else
   5402  277e1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277e1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277e1				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277e1				   -	       endif
   5406  277e1				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277e1					       endif		; EXTRADLMEMORY
   5408  277e1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277e1			75		       .byte.b	>TMPMEMADDRESS
   5410  277e1				    DLINDEX    SET	DLINDEX + 1
   5396  277e1					       REPEND
   5397  277e1				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5398  277e2				   -	       ifconst	EXTRADLMEMORY
   5399  277e2				   -	       if	TMPMEMADDRESS > $1FFF
   5400  277e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5401  277e2				   -	       else
   5402  277e2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5403  277e2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5404  277e2				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   5405  277e2				   -	       endif
   5406  277e2				   -	       endif		; TMPMEMADDRESS > $1FFF
   5407  277e2					       endif		; EXTRADLMEMORY
   5408  277e2							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   5409  277e2			7a		       .byte.b	>TMPMEMADDRESS
   5410  277e2				    DLINDEX    SET	DLINDEX + 1
   5411  277e3					       REPEND
   5412  277e3
   5413  277e3				   -	       ifconst	EXTRADLMEMORY
   5414  277e3				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   5415  277e3					       endif
   5416  277e3
   5417  277e3
   5418  277e3				    DLPOINTL
   5419  277e3				    DLINDEX    SET	0
   5420  277e3					       REPEAT	WZONECOUNT
   5421  277e3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e3				   -	       ifconst	EXTRADLMEMORY
   5423  277e3				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e3				   -	       else
   5426  277e3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e3				   -	       endif
   5429  277e3				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e3					       endif		; EXTRADLMEMORY
   5431  277e3			00		       .byte.b	<TMPMEMADDRESS
   5432  277e3				    DLINDEX    SET	DLINDEX + 1
   5420  277e3					       REPEND
   5421  277e3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e4				   -	       ifconst	EXTRADLMEMORY
   5423  277e4				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e4				   -	       else
   5426  277e4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e4				   -	       endif
   5429  277e4				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e4					       endif		; EXTRADLMEMORY
   5431  277e4			55		       .byte.b	<TMPMEMADDRESS
   5432  277e4				    DLINDEX    SET	DLINDEX + 1
   5420  277e4					       REPEND
   5421  277e4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e5				   -	       ifconst	EXTRADLMEMORY
   5423  277e5				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e5				   -	       else
   5426  277e5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e5				   -	       endif
   5429  277e5				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e5					       endif		; EXTRADLMEMORY
   5431  277e5			aa		       .byte.b	<TMPMEMADDRESS
   5432  277e5				    DLINDEX    SET	DLINDEX + 1
   5420  277e5					       REPEND
   5421  277e5				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e6				   -	       ifconst	EXTRADLMEMORY
   5423  277e6				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e6				   -	       else
   5426  277e6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e6				   -	       endif
   5429  277e6				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e6					       endif		; EXTRADLMEMORY
   5431  277e6			00		       .byte.b	<TMPMEMADDRESS
   5432  277e6				    DLINDEX    SET	DLINDEX + 1
   5420  277e6					       REPEND
   5421  277e6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e7				   -	       ifconst	EXTRADLMEMORY
   5423  277e7				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e7				   -	       else
   5426  277e7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e7				   -	       endif
   5429  277e7				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e7					       endif		; EXTRADLMEMORY
   5431  277e7			55		       .byte.b	<TMPMEMADDRESS
   5432  277e7				    DLINDEX    SET	DLINDEX + 1
   5420  277e7					       REPEND
   5421  277e7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e8				   -	       ifconst	EXTRADLMEMORY
   5423  277e8				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e8				   -	       else
   5426  277e8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e8				   -	       endif
   5429  277e8				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e8					       endif		; EXTRADLMEMORY
   5431  277e8			aa		       .byte.b	<TMPMEMADDRESS
   5432  277e8				    DLINDEX    SET	DLINDEX + 1
   5420  277e8					       REPEND
   5421  277e8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277e9				   -	       ifconst	EXTRADLMEMORY
   5423  277e9				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277e9				   -	       else
   5426  277e9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277e9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277e9				   -	       endif
   5429  277e9				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277e9					       endif		; EXTRADLMEMORY
   5431  277e9			00		       .byte.b	<TMPMEMADDRESS
   5432  277e9				    DLINDEX    SET	DLINDEX + 1
   5420  277e9					       REPEND
   5421  277e9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277ea				   -	       ifconst	EXTRADLMEMORY
   5423  277ea				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277ea				   -	       else
   5426  277ea				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277ea				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277ea				   -	       endif
   5429  277ea				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277ea					       endif		; EXTRADLMEMORY
   5431  277ea			55		       .byte.b	<TMPMEMADDRESS
   5432  277ea				    DLINDEX    SET	DLINDEX + 1
   5420  277ea					       REPEND
   5421  277ea				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277eb				   -	       ifconst	EXTRADLMEMORY
   5423  277eb				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277eb				   -	       else
   5426  277eb				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277eb				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277eb				   -	       endif
   5429  277eb				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277eb					       endif		; EXTRADLMEMORY
   5431  277eb			aa		       .byte.b	<TMPMEMADDRESS
   5432  277eb				    DLINDEX    SET	DLINDEX + 1
   5420  277eb					       REPEND
   5421  277eb				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277ec				   -	       ifconst	EXTRADLMEMORY
   5423  277ec				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277ec				   -	       else
   5426  277ec				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277ec				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277ec				   -	       endif
   5429  277ec				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277ec					       endif		; EXTRADLMEMORY
   5431  277ec			00		       .byte.b	<TMPMEMADDRESS
   5432  277ec				    DLINDEX    SET	DLINDEX + 1
   5420  277ec					       REPEND
   5421  277ec				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277ed				   -	       ifconst	EXTRADLMEMORY
   5423  277ed				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277ed				   -	       else
   5426  277ed				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277ed				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277ed				   -	       endif
   5429  277ed				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277ed					       endif		; EXTRADLMEMORY
   5431  277ed			55		       .byte.b	<TMPMEMADDRESS
   5432  277ed				    DLINDEX    SET	DLINDEX + 1
   5420  277ed					       REPEND
   5421  277ed				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5422  277ee				   -	       ifconst	EXTRADLMEMORY
   5423  277ee				   -	       if	TMPMEMADDRESS > $1FFF
   5424  277ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5425  277ee				   -	       else
   5426  277ee				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5427  277ee				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5428  277ee				   -	       endif
   5429  277ee				   -	       endif		; TMPMEMADDRESS > $1FFF
   5430  277ee					       endif		; EXTRADLMEMORY
   5431  277ee			aa		       .byte.b	<TMPMEMADDRESS
   5432  277ee				    DLINDEX    SET	DLINDEX + 1
   5433  277ef					       REPEND
   5434  277ef
   5435  277ef
   5436  277ef				    DLINDEX    SET	0
   5437  277ef					       REPEAT	WZONECOUNT
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef					       if	DLINDEX = 0
   5449  277ef			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef					       if	DLINDEX = 1
   5452  277ef			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef					       if	DLINDEX = 2
   5455  277ef			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef					       if	DLINDEX = 3
   5458  277ef			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef					       if	DLINDEX = 4
   5461  277ef			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef					       if	DLINDEX = 5
   5464  277ef			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef					       if	DLINDEX = 6
   5467  277ef			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef					       if	DLINDEX = 7
   5470  277ef			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef					       if	DLINDEX = 8
   5473  277ef			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef					       if	DLINDEX = 9
   5476  277ef			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef					       if	DLINDEX = 10
   5479  277ef			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef				   -	       if	DLINDEX = 11
   5482  277ef				   -ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5437  277ef					       REPEND
   5438  277ef				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   5439  277ef				   -	       ifconst	EXTRADLMEMORY
   5440  277ef				   -	       if	TMPMEMADDRESS > $1FFF
   5441  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5442  277ef				   -	       else
   5443  277ef				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   5444  277ef				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   5445  277ef				   -	       endif
   5446  277ef				   -	       endif		; TMPMEMADDRESS > $1FFF
   5447  277ef					       endif		; EXTRADLMEMORY
   5448  277ef				   -	       if	DLINDEX = 0
   5449  277ef				   -ZONE0ADDRESS =	TMPMEMADDRESS
   5450  277ef					       endif
   5451  277ef				   -	       if	DLINDEX = 1
   5452  277ef				   -ZONE1ADDRESS =	TMPMEMADDRESS
   5453  277ef					       endif
   5454  277ef				   -	       if	DLINDEX = 2
   5455  277ef				   -ZONE2ADDRESS =	TMPMEMADDRESS
   5456  277ef					       endif
   5457  277ef				   -	       if	DLINDEX = 3
   5458  277ef				   -ZONE3ADDRESS =	TMPMEMADDRESS
   5459  277ef					       endif
   5460  277ef				   -	       if	DLINDEX = 4
   5461  277ef				   -ZONE4ADDRESS =	TMPMEMADDRESS
   5462  277ef					       endif
   5463  277ef				   -	       if	DLINDEX = 5
   5464  277ef				   -ZONE5ADDRESS =	TMPMEMADDRESS
   5465  277ef					       endif
   5466  277ef				   -	       if	DLINDEX = 6
   5467  277ef				   -ZONE6ADDRESS =	TMPMEMADDRESS
   5468  277ef					       endif
   5469  277ef				   -	       if	DLINDEX = 7
   5470  277ef				   -ZONE7ADDRESS =	TMPMEMADDRESS
   5471  277ef					       endif
   5472  277ef				   -	       if	DLINDEX = 8
   5473  277ef				   -ZONE8ADDRESS =	TMPMEMADDRESS
   5474  277ef					       endif
   5475  277ef				   -	       if	DLINDEX = 9
   5476  277ef				   -ZONE9ADDRESS =	TMPMEMADDRESS
   5477  277ef					       endif
   5478  277ef				   -	       if	DLINDEX = 10
   5479  277ef				   -ZONE10ADDRESS =	TMPMEMADDRESS
   5480  277ef					       endif
   5481  277ef					       if	DLINDEX = 11
   5482  277ef			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   5483  277ef					       endif
   5484  277ef				   -	       if	DLINDEX = 12
   5485  277ef				   -ZONE12ADDRESS =	TMPMEMADDRESS
   5486  277ef					       endif
   5487  277ef				   -	       if	DLINDEX = 13
   5488  277ef				   -ZONE13ADDRESS =	TMPMEMADDRESS
   5489  277ef					       endif
   5490  277ef				   -	       if	DLINDEX = 14
   5491  277ef				   -ZONE14ADDRESS =	TMPMEMADDRESS
   5492  277ef					       endif
   5493  277ef				   -	       if	DLINDEX = 15
   5494  277ef				   -ZONE15ADDRESS =	TMPMEMADDRESS
   5495  277ef					       endif
   5496  277ef				   -	       if	DLINDEX = 16
   5497  277ef				   -ZONE16ADDRESS =	TMPMEMADDRESS
   5498  277ef					       endif
   5499  277ef				   -	       if	DLINDEX = 17
   5500  277ef				   -ZONE17ADDRESS =	TMPMEMADDRESS
   5501  277ef					       endif
   5502  277ef				   -	       if	DLINDEX = 18
   5503  277ef				   -ZONE18ADDRESS =	TMPMEMADDRESS
   5504  277ef					       endif
   5505  277ef				   -	       if	DLINDEX = 19
   5506  277ef				   -ZONE19ADDRESS =	TMPMEMADDRESS
   5507  277ef					       endif
   5508  277ef				   -	       if	DLINDEX = 20
   5509  277ef				   -ZONE20ADDRESS =	TMPMEMADDRESS
   5510  277ef					       endif
   5511  277ef				   -	       if	DLINDEX = 21
   5512  277ef				   -ZONE21ADDRESS =	TMPMEMADDRESS
   5513  277ef					       endif
   5514  277ef				   -	       if	DLINDEX = 22
   5515  277ef				   -ZONE22ADDRESS =	TMPMEMADDRESS
   5516  277ef					       endif
   5517  277ef				   -	       if	DLINDEX = 23
   5518  277ef				   -ZONE23ADDRESS =	TMPMEMADDRESS
   5519  277ef					       endif
   5520  277ef				   -	       if	DLINDEX = 24
   5521  277ef				   -ZONE24ADDRESS =	TMPMEMADDRESS
   5522  277ef					       endif
   5523  277ef				   -	       if	DLINDEX = 25
   5524  277ef				   -ZONE25ADDRESS =	TMPMEMADDRESS
   5525  277ef					       endif
   5526  277ef				   -	       if	DLINDEX = 26
   5527  277ef				   -ZONE26ADDRESS =	TMPMEMADDRESS
   5528  277ef					       endif
   5529  277ef				   -	       if	DLINDEX = 27
   5530  277ef				   -ZONE27ADDRESS =	TMPMEMADDRESS
   5531  277ef					       endif
   5532  277ef				    DLINDEX    SET	DLINDEX + 1
   5533  277ef					       REPEND
   5534  277ef
   5535  277ef
     $4000 to $7fff used as zone memory, allowing 272 display objects per zone.
   5536  277ef					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   5537  277ef
   5538  277ef				    DLHEIGHT
   5539  277ef					       REPEAT	WZONECOUNT
   5540  277ef			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277ef					       REPEND
   5540  277f0			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f0					       REPEND
   5540  277f1			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f1					       REPEND
   5540  277f2			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f2					       REPEND
   5540  277f3			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f3					       REPEND
   5540  277f4			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f4					       REPEND
   5540  277f5			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f5					       REPEND
   5540  277f6			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f6					       REPEND
   5540  277f7			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f7					       REPEND
   5540  277f8			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f8					       REPEND
   5540  277f9			0f		       .byte.b	(WZONEHEIGHT-1)
   5539  277f9					       REPEND
   5540  277fa			0f		       .byte.b	(WZONEHEIGHT-1)
   5541  277fb					       REPEND
   5542  277fb
   5543  277fb							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5544  277fb
   5545  277fb							; a simple guard, than ensures the 7800basic code hasn't
   5546  277fb							; spilled into the encryption area...
     1923 bytes left in the 7800basic reserved area.
   5547  277fb					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   5548  277fb				   -	       if	(*>$FF7D)
   5549  277fb				   -	       ERR		; abort the assembly
   5550  277fb					       endif
   5551  277fb							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5552  277fb
   5553  277fb				   -	       ifconst	DEV
   5554  277fb				   -	       ifnconst	ZONEHEIGHT
   5555  277fb				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5556  277fb				   -	       else
   5557  277fb				   -	       if	ZONEHEIGHT = 8
   5558  277fb				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5559  277fb				   -	       else
   5560  277fb				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   5561  277fb				   -	       endif
   5562  277fb				   -	       endif
   5563  277fb					       endif
   5564  277fb
   5565  277fb							; FF7E/FF7F contains the 7800basic crc checksum word
   5566  277fb
   5567  277fb							; FF80 - FFF7 contains the 7800 encryption key 
   5568  277fb
   5569  277fb				   -	       ifnconst	bankswitchmode
   5570  277fb				   -	       ORG	$FFF8
   5571  277fb					       else
   5572  277fb					       ifconst	ROM128K
   5573  27ff8					       ORG	$27FF8
   5574  27ff8					       RORG	$FFF8
   5575  27ff8					       endif
   5576  27ff8				   -	       ifconst	ROM144K
   5577  27ff8				   -	       ORG	$27FF8
   5578  27ff8				   -	       RORG	$FFF8
   5579  27ff8					       endif
   5580  27ff8				   -	       ifconst	ROM256K
   5581  27ff8				   -	       ORG	$47FF8
   5582  27ff8				   -	       RORG	$FFF8
   5583  27ff8					       endif
   5584  27ff8				   -	       ifconst	ROM272K
   5585  27ff8				   -	       ORG	$47FF8
   5586  27ff8				   -	       RORG	$FFF8
   5587  27ff8					       endif
   5588  27ff8				   -	       ifconst	ROM512K
   5589  27ff8				   -	       ORG	$87FF8
   5590  27ff8				   -	       RORG	$FFF8
   5591  27ff8					       endif
   5592  27ff8				   -	       ifconst	ROM528K
   5593  27ff8				   -	       ORG	$87FF8
   5594  27ff8				   -	       RORG	$FFF8
   5595  27ff8					       endif
   5596  27ff8					       endif
   5597  27ff8
   5598  27ff8
   5599  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   5600  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   5601  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   5602  27ffa
   5603  27ffa							;Vectors
   5604  27ffa			46 f1		       .word.w	NMI
   5605  27ffc			e8 f6		       .word.w	START
   5606  27ffe			ac f1		       .word.w	IRQ
   5607  28000
