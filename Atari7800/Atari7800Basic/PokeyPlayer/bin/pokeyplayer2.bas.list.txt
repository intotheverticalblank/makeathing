------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????				       MAC	median3
    172  28000 ????
    173  28000 ????						; A median filter (for smoothing paddle jitter)
    174  28000 ????						;   this macro takes the current paddle value, compares it to historic
    175  28000 ????						;   values, and replaces the current paddle value with the median.
    176  28000 ????						; 
    177  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    178  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    179  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    180  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    181  28000 ????						;	  the previous values, and update with the median value.
    182  28000 ????						;
    183  28000 ????						; returns: CURRENT (modified to contain median value)
    184  28000 ????						;
    185  28000 ????						; author: Mike Saarna (aka RevEng)
    186  28000 ????
    187  28000 ????			    .MedianBytes SET	{1}
    188  28000 ????			    .NewValue  SET	{2}
    189  28000 ????
    190  28000 ????				       lda	#0
    191  28000 ????				       ldy	.NewValue
    192  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    193  28000 ????
    194  28000 ????						; build an index from relative size comparisons between our 3 values.
    195  28000 ????				       cpy	.MedianBytes
    196  28000 ????				       rol
    197  28000 ????				       cpy	.MedianBytes+1
    198  28000 ????				       rol
    199  28000 ????				       ldy	.MedianBytes
    200  28000 ????				       cpy	.MedianBytes+1
    201  28000 ????				       rol
    202  28000 ????				       tay
    203  28000 ????
    204  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    205  28000 ????				       lda	.MedianBytes,x
    206  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    207  28000 ????
    208  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    209  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    210  28000 ????				       lda	.MedianBytes+1
    211  28000 ????				       sta	.MedianBytes
    212  28000 ????				       lda	.MedianBytes+2
    213  28000 ????				       sta	.MedianBytes+1
    214  28000 ????				       ifnconst	MedianOrderLUT
    215  28000 ????				       jmp	MedianOrderLUTend
    216  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    217  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    218  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    219  28000 ????				       .byte	2	; 2   impossible 
    220  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    221  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    222  28000 ????				       .byte	2	; 5   impossible 
    223  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    224  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    225  28000 ????			    MedianOrderLUTend
    226  28000 ????				       endif
    227  28000 ????				       ENDM
    228  28000 ????
    229  28000 ????				       MAC	plotsprite
    230  28000 ????
    231  28000 ????						; A macro version of the plotsprite command. 
    232  28000 ????						; This trades off rom space for speed.
    233  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    234  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    235  28000 ????
    236  28000 ????			    .GFXLabel  SET	{1}
    237  28000 ????			    .Palette   SET	{2}	; constant
    238  28000 ????			    .SpriteX   SET	{3}	; variable
    239  28000 ????			    .SpriteY   SET	{4}	; variable
    240  28000 ????			    .ByteOffset SET	{5}	; variable 
    241  28000 ????
    242  28000 ????				       lda	.SpriteY
    243  28000 ????				       lsr
    244  28000 ????				       lsr
    245  28000 ????				       asr	#%11111110	; ensure carry is clear
    246  28000 ????				       if	WZONEHEIGHT = 16
    247  28000 ????				       asr	#%11111110	; ensure carry is clear
    248  28000 ????				       endif
    249  28000 ????
    250  28000 ????				       tax
    251  28000 ????
    252  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    253  28000 ????				       sta	dlpnt
    254  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    255  28000 ????				       sta	dlpnt+1
    256  28000 ????
    257  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    258  28000 ????
    259  28000 ????				       lda	.ByteOffset
    260  28000 ????				       if	{1}_width = 2
    261  28000 ????				       asl
    262  28000 ????				       endif
    263  28000 ????				       if	{1}_width = 3
    264  28000 ????				       asl
    265  28000 ????				       adc	.ByteOffset
    266  28000 ????				       endif
    267  28000 ????				       if	{1}_width = 4
    268  28000 ????				       asl
    269  28000 ????				       asl
    270  28000 ????				       endif
    271  28000 ????				       if	{1}_width = 5
    272  28000 ????				       asl
    273  28000 ????				       asl
    274  28000 ????				       adc	.ByteOffset
    275  28000 ????				       endif
    276  28000 ????				       if	{1}_width = 6
    277  28000 ????				       asl
    278  28000 ????				       adc	.ByteOffset
    279  28000 ????				       asl
    280  28000 ????				       endif
    281  28000 ????				       if	{1}_width = 7
    282  28000 ????				       asl
    283  28000 ????				       adc	.ByteOffset
    284  28000 ????				       asl
    285  28000 ????				       adc	.ByteOffset
    286  28000 ????				       endif
    287  28000 ????				       if	{1}_width = 8
    288  28000 ????				       asl
    289  28000 ????				       asl
    290  28000 ????				       asl
    291  28000 ????				       endif
    292  28000 ????				       if	{1}_width = 9
    293  28000 ????				       asl
    294  28000 ????				       asl
    295  28000 ????				       asl
    296  28000 ????				       adc	.ByteOffset
    297  28000 ????				       endif
    298  28000 ????				       if	{1}_width = 10
    299  28000 ????				       asl
    300  28000 ????				       asl
    301  28000 ????				       adc	.ByteOffset
    302  28000 ????				       asl
    303  28000 ????				       endif
    304  28000 ????				       if	{1}_width = 11
    305  28000 ????				       asl
    306  28000 ????				       asl
    307  28000 ????				       adc	.ByteOffset
    308  28000 ????				       asl
    309  28000 ????				       adc	.ByteOffset
    310  28000 ????				       endif
    311  28000 ????				       if	{1}_width = 12
    312  28000 ????				       asl
    313  28000 ????				       adc	.ByteOffset
    314  28000 ????				       asl
    315  28000 ????				       asl
    316  28000 ????				       endif
    317  28000 ????				       if	{1}_width = 13
    318  28000 ????				       asl
    319  28000 ????				       adc	.ByteOffset
    320  28000 ????				       asl
    321  28000 ????				       asl
    322  28000 ????				       adc	.ByteOffset
    323  28000 ????				       endif
    324  28000 ????				       if	{1}_width = 14
    325  28000 ????				       asl
    326  28000 ????				       adc	.ByteOffset
    327  28000 ????				       asl
    328  28000 ????				       adc	.ByteOffset
    329  28000 ????				       asl
    330  28000 ????				       endif
    331  28000 ????
    332  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    333  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    334  28000 ????
    335  28000 ????				       iny
    336  28000 ????
    337  28000 ????				       lda	#({1}_mode | %01000000)
    338  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    339  28000 ????
    340  28000 ????				       iny
    341  28000 ????
    342  28000 ????				       lda	.SpriteY
    343  28000 ????				       and	#(WZONEHEIGHT - 1)
    344  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    345  28000 ????				       ora	#>.GFXLabel
    346  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    347  28000 ????
    348  28000 ????				       iny
    349  28000 ????
    350  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    351  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    352  28000 ????
    353  28000 ????				       iny
    354  28000 ????
    355  28000 ????				       lda	.SpriteX
    356  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    357  28000 ????
    358  28000 ????				       iny
    359  28000 ????				       sty	dlend,x
    360  28000 ????
    361  28000 ????				       ifconst	ALWAYSTERMINATE
    362  28000 ????				       iny
    363  28000 ????				       lda	#0
    364  28000 ????				       sta	(dlpnt),y
    365  28000 ????				       endif
    366  28000 ????
    367  28000 ????				       bcc	.PLOTSPRITEend
    368  28000 ????
    369  28000 ????				       inx		; next zone
    370  28000 ????
    371  28000 ????				       lda	DLPOINTL,x	; setup DL pointer for this zone
    372  28000 ????				       sta	dlpnt
    373  28000 ????				       lda	DLPOINTH,x	; setup DL pointer for this zone
    374  28000 ????				       sta	dlpnt+1
    375  28000 ????
    376  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    377  28000 ????
    378  28000 ????				       lda	.ByteOffset
    379  28000 ????				       if	{1}_width = 1
    380  28000 ????				       clc
    381  28000 ????				       endif
    382  28000 ????				       if	{1}_width = 2
    383  28000 ????				       asl		; carry clear
    384  28000 ????				       endif
    385  28000 ????				       if	{1}_width = 3
    386  28000 ????				       asl		; carry clear
    387  28000 ????				       adc	.ByteOffset
    388  28000 ????				       endif
    389  28000 ????				       if	{1}_width = 4
    390  28000 ????				       asl		; carry clear
    391  28000 ????				       asl
    392  28000 ????				       endif
    393  28000 ????				       if	{1}_width = 5
    394  28000 ????				       asl		; carry clear
    395  28000 ????				       asl
    396  28000 ????				       adc	.ByteOffset
    397  28000 ????				       endif
    398  28000 ????				       if	{1}_width = 6
    399  28000 ????				       asl		; carry clear
    400  28000 ????				       adc	.ByteOffset
    401  28000 ????				       asl
    402  28000 ????				       endif
    403  28000 ????				       if	{1}_width = 7
    404  28000 ????				       asl		; carry clear
    405  28000 ????				       adc	.ByteOffset
    406  28000 ????				       asl
    407  28000 ????				       endif
    408  28000 ????				       if	{1}_width = 8
    409  28000 ????				       asl		; carry clear
    410  28000 ????				       asl
    411  28000 ????				       asl
    412  28000 ????				       endif
    413  28000 ????				       if	{1}_width = 9
    414  28000 ????				       asl		; carry clear
    415  28000 ????				       asl
    416  28000 ????				       asl
    417  28000 ????				       adc	.ByteOffset
    418  28000 ????				       endif
    419  28000 ????				       if	{1}_width = 10
    420  28000 ????				       asl		; carry clear
    421  28000 ????				       asl
    422  28000 ????				       adc	.ByteOffset
    423  28000 ????				       asl
    424  28000 ????				       endif
    425  28000 ????				       if	{1}_width = 11
    426  28000 ????				       asl		; carry clear
    427  28000 ????				       asl
    428  28000 ????				       adc	.ByteOffset
    429  28000 ????				       asl
    430  28000 ????				       adc	.ByteOffset
    431  28000 ????				       endif
    432  28000 ????				       if	{1}_width = 12
    433  28000 ????				       asl		; carry clear
    434  28000 ????				       adc	.ByteOffset
    435  28000 ????				       asl
    436  28000 ????				       asl
    437  28000 ????				       endif
    438  28000 ????				       if	{1}_width = 13
    439  28000 ????				       asl		; carry clear
    440  28000 ????				       adc	.ByteOffset
    441  28000 ????				       asl
    442  28000 ????				       asl
    443  28000 ????				       adc	.ByteOffset
    444  28000 ????				       endif
    445  28000 ????				       if	{1}_width = 14
    446  28000 ????				       asl		; carry clear
    447  28000 ????				       adc	.ByteOffset
    448  28000 ????				       asl
    449  28000 ????				       adc	.ByteOffset
    450  28000 ????				       asl
    451  28000 ????				       endif
    452  28000 ????
    453  28000 ????				       adc	#<.GFXLabel
    454  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    455  28000 ????
    456  28000 ????				       iny
    457  28000 ????
    458  28000 ????				       lda	#({1}_mode | %01000000)
    459  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    460  28000 ????
    461  28000 ????				       iny
    462  28000 ????
    463  28000 ????				       lda	.SpriteY
    464  28000 ????				       and	#(WZONEHEIGHT - 1)
    465  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    466  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    467  28000 ????
    468  28000 ????				       iny
    469  28000 ????
    470  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    471  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    472  28000 ????
    473  28000 ????				       iny
    474  28000 ????
    475  28000 ????				       lda	.SpriteX
    476  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    477  28000 ????
    478  28000 ????				       iny
    479  28000 ????				       sty	dlend,x
    480  28000 ????
    481  28000 ????				       ifconst	ALWAYSTERMINATE
    482  28000 ????				       iny
    483  28000 ????				       lda	#0
    484  28000 ????				       sta	(dlpnt),y
    485  28000 ????				       endif
    486  28000 ????
    487  28000 ????			    .PLOTSPRITEend
    488  28000 ????				       ENDM
    489  28000 ????
    490  28000 ????				       MAC	sizeof
    491  28000 ????
    492  28000 ????						; echo's the size difference between the current address and the
    493  28000 ????						; a label that was passed as an argument. This is a quick way to
    494  28000 ????						; determine the size of a structure.
    495  28000 ????
    496  28000 ????			    .NAME      SETSTR	{1}
    497  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
    498  28000 ????				       ENDM
    499  28000 ????
    500  28000 ????						;
    501  28000 ????						; speakjet.inc
    502  28000 ????						;
    503  28000 ????						;
    504  28000 ????						; AtariVox Speech Synth Driver
    505  28000 ????						;
    506  28000 ????						; By Alex Herbert, 2004
    507  28000 ????						;
    508  28000 ????
    509  28000 ????
    510  28000 ????
    511  28000 ????
    512  28000 ????						; Constants
    513  28000 ????
    514  28000 ????
    515  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
    516  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
    517  28000 ????
    518  28000 ????
    519  28000 ????
    520  28000 ????						; Macros
    521  28000 ????
    522  28000 ????				       mac	spkout
    523  28000 ????
    524  28000 ????						; check buffer-full status
    525  28000 ????				       lda	SWCHA
    526  28000 ????				       and	#SERIAL_RDYMASK
    527  28000 ????				       beq	.speech_done
    528  28000 ????
    529  28000 ????						; get next speech byte
    530  28000 ????				       ldy	#$00
    531  28000 ????				       lda	(speech_addr),y
    532  28000 ????
    533  28000 ????						; invert data and check for end of string
    534  28000 ????				       eor	#$ff
    535  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
    536  28000 ????				       beq	.speech_done
    537  28000 ????				       sta	{1}
    538  28000 ????
    539  28000 ????						; increment speech pointer
    540  28000 ????				       inc	speech_addr
    541  28000 ????				       bne	.incaddr_skip
    542  28000 ????				       inc	speech_addr+1
    543  28000 ????			    .incaddr_skip
    544  28000 ????
    545  28000 ????						; output byte as serial data
    546  28000 ????
    547  28000 ????				       sec		; start bit
    548  28000 ????			    .byteout_loop
    549  28000 ????						; put carry flag into bit 0 of SWACNT, perserving other bits
    550  28000 ????				       lda	SWACNT	; 4
    551  28000 ????				       and	#$fe	; 2 6
    552  28000 ????				       adc	#$00	; 2 8
    553  28000 ????				       sta	SWACNT	; 4 12
    554  28000 ????
    555  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
    556  28000 ????				       cpy	#$09	; 2 14
    557  28000 ????				       beq	.speech_done	; 2 16
    558  28000 ????				       iny		; 2 18
    559  28000 ????
    560  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
    561  28000 ????						; to match the original baud rate...
    562  28000 ????						;ldx	  #$07 ; 2600
    563  28000 ????				       ldx	#$0D
    564  28000 ????
    565  28000 ????			    .delay_loop
    566  28000 ????				       dex		; 
    567  28000 ????				       bne	.delay_loop	; 36 54
    568  28000 ????
    569  28000 ????						; shift next data bit into carry
    570  28000 ????				       lsr	{1}	; 5 59
    571  28000 ????
    572  28000 ????						; and loop (branch always taken)
    573  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
    574  28000 ????
    575  28000 ????			    .speech_done
    576  28000 ????
    577  28000 ????				       endm
    578  28000 ????
    579  28000 ????
    580  28000 ????				       mac	speak
    581  28000 ????
    582  28000 ????				       lda	#<{1}
    583  28000 ????				       sta	speech_addr
    584  28000 ????				       lda	#>{1}
    585  28000 ????				       sta	speech_addr+1
    586  28000 ????
    587  28000 ????				       endm
    588  28000 ????
    589  28000 ????
    590  28000 ????
    591  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    592  28000 ????
    593  28000 ????				       processor	6502
    594  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Adresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	mirror of 1800-27ff
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????
    123  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    124  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    125  28000 ????		02 95	    TIMINT     =	$295	;Interval Timer Interrupt		       read-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    font_mode  =	$00
      4  28000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  28000 ????		00 35	    font_width =	$35
      6  28000 ????		22 20	    cTicks     =	$2220
      7  28000 ????
      8  28000 ????		22 1c	    cMode      =	$221C
      9  28000 ????
     10  28000 ????		22 18	    cType      =	$2218
     11  28000 ????
     12  28000 ????		22 14	    cSilence   =	$2214
     13  28000 ????
     14  28000 ????		22 10	    cDuration  =	$2210
     15  28000 ????
     16  28000 ????		22 0c	    cVolume    =	$220C
     17  28000 ????
     18  28000 ????		22 08	    cWaveForm  =	$2208
     19  28000 ????
     20  28000 ????		22 04	    cFrequency =	$2204
     21  28000 ????
     22  28000 ????		22 00	    cChannel   =	$2200
     23  28000 ????
     24  28000 ????		01 5b	    fireWaitMax =	var27
     25  28000 ????
     26  28000 ????		01 5a	    fireWait   =	var26
     27  28000 ????
     28  28000 ????		00 03	    TYPE_DECAY =	3
     29  28000 ????
     30  28000 ????		00 02	    TYPE_ATTACK =	2
     31  28000 ????
     32  28000 ????		00 01	    TYPE_CONSTANT =	1
     33  28000 ????
     34  28000 ????		00 02	    MODE_SILENCE =	2
     35  28000 ????
     36  28000 ????		00 01	    MODE_PLAY  =	1
     37  28000 ????
     38  28000 ????		01 54	    tMode      =	var20
     39  28000 ????
     40  28000 ????		01 53	    tTicks     =	var19
     41  28000 ????
     42  28000 ????		01 52	    tSilence   =	var18
     43  28000 ????
     44  28000 ????		01 51	    xMode      =	var17
     45  28000 ????
     46  28000 ????		01 50	    timeCount  =	var16
     47  28000 ????
     48  28000 ????		01 4f	    xSilence   =	var15
     49  28000 ????
     50  28000 ????		01 4e	    xDuration  =	var14
     51  28000 ????
     52  28000 ????		01 4d	    xColumn    =	var13
     53  28000 ????
     54  28000 ????		01 4c	    xChannel   =	var12
     55  28000 ????
     56  28000 ????		01 4b	    tColumn    =	var11
     57  28000 ????
     58  28000 ????		01 4a	    tempY      =	var10
     59  28000 ????
     60  28000 ????		01 49	    tempX      =	var9
     61  28000 ????
     62  28000 ????		01 48	    tSelected  =	var8
     63  28000 ????
     64  28000 ????		01 47	    tColor     =	var7
     65  28000 ????
     66  28000 ????		01 46	    tDuration  =	var6
     67  28000 ????
     68  28000 ????		01 45	    tType      =	var5
     69  28000 ????
     70  28000 ????		01 44	    tVolume    =	var4
     71  28000 ????
     72  28000 ????		01 43	    tWaveForm  =	var3
     73  28000 ????
     74  28000 ????		01 42	    tFrequency =	var2
     75  28000 ????
     76  28000 ????		01 41	    tChannel   =	var1
     77  28000 ????
     78  28000 ????		00 01	    plotvalueonscreen =	1
     79  28000 ????		00 0f	    font_color1 =	$0f
     80  28000 ????		00 00	    font_color0 =	$00
     81  28000 ????		00 01	    pokeysupport =	1
     82  28000 ????		00 01	    SGRAM      =	1
     83  28000 ????		00 08	    bankswitchmode =	8
     84  28000 ????		00 01	    ROM128K    =	1
     85  28000 ????		00 01	    plotvalueonscreen =	1
     86  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    ssCTRL     =	$2131
     63  28000 ????		21 32	    ssCHARBASE =	$2132
     64  28000 ????		21 33	    hsdisplaymode =	$2133
     65  28000 ????		21 34	    gamedifficulty =	$2134
     66  28000 ????		21 35	    hsinitialpos =	$2135
     67  28000 ????		21 36	    hsinitialhold =	$2136
     68  28000 ????		21 37	    hscursorx  =	$2137
     69  28000 ????		21 38	    hsjoydebounce =	$2138
     70  28000 ????		21 39	    hsswcha    =	$2139
     71  28000 ????		21 3a	    hsinpt1    =	$213A
     72  28000 ????		21 3b	    hscolorchaseindex =	$213B
     73  28000 ????		21 3c	    visibleDLLstart =	$213C
     74  28000 ????		21 3d	    overscanDLLstart =	$213D
     75  28000 ????		21 3e	    frameslost =	$213E
     76  28000 ????
     77  28000 ????
     78  28000 ????		00 40	    rand       =	$40
     79  28000 ????		00 41	    rand16     =	$41
     80  28000 ????		00 42	    temp1      =	$42
     81  28000 ????		00 43	    temp2      =	$43
     82  28000 ????		00 44	    temp3      =	$44
     83  28000 ????		00 45	    temp4      =	$45
     84  28000 ????		00 46	    temp5      =	$46
     85  28000 ????		00 47	    temp6      =	$47
     86  28000 ????		00 48	    temp7      =	$48
     87  28000 ????		00 49	    temp8      =	$49
     88  28000 ????		00 4a	    temp9      =	$4a
     89  28000 ????
     90  28000 ????		00 4b	    pokeybase  =	$4b
     91  28000 ????		00 4b	    pokeybaselo =	$4b
     92  28000 ????		00 4c	    pokeybasehi =	$4c
     93  28000 ????
     94  28000 ????		00 4d	    visibleover =	$4d
     95  28000 ????
     96  28000 ????		00 4e	    sfx1pointlo =	$4e
     97  28000 ????		00 4f	    sfx2pointlo =	$4f
     98  28000 ????		00 50	    sfx1pointhi =	$50
     99  28000 ????		00 51	    sfx2pointhi =	$51
    100  28000 ????
    101  28000 ????		00 52	    sfx1priority =	$52
    102  28000 ????		00 53	    sfx2priority =	$53
    103  28000 ????		00 54	    sfx1poffset =	$54
    104  28000 ????		00 55	    sfx2poffset =	$55
    105  28000 ????
    106  28000 ????		00 56	    sfx1frames =	$56
    107  28000 ????		00 57	    sfx2frames =	$57
    108  28000 ????		00 58	    sfx1tick   =	$58
    109  28000 ????		00 59	    sfx2tick   =	$59
    110  28000 ????
    111  28000 ????		00 5a	    tempmath   =	$5a
    112  28000 ????
    113  28000 ????		00 5b	    pokey1pointlo =	$5b
    114  28000 ????		00 5c	    pokey1pointhi =	$5c
    115  28000 ????		00 5d	    pokey2pointlo =	$5d
    116  28000 ????		00 5e	    pokey2pointhi =	$5e
    117  28000 ????		00 5f	    pokey3pointlo =	$5f
    118  28000 ????		00 60	    pokey3pointhi =	$60
    119  28000 ????		00 61	    pokey4pointlo =	$61
    120  28000 ????		00 62	    pokey4pointhi =	$62
    121  28000 ????
    122  28000 ????		00 63	    dlpnt      =	$63	; to $64
    123  28000 ????		00 65	    dlend      =	$65	; to $81 - for 28 possible visible dll entries
    124  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 28 possible visible dll entries
    125  28000 ????
    126  28000 ????		00 9f	    speech_addr =	$9f
    127  28000 ????		00 a0	    speech_addr_hi =	$a0
    128  28000 ????
    129  28000 ????		00 a1	    HSGameTableLo =	$a1
    130  28000 ????		00 a2	    HSGameTableHi =	$a2
    131  28000 ????		00 a3	    HSVoxHi    =	$a3
    132  28000 ????		00 a4	    HSVoxLo    =	$a4
    133  28000 ????
    134  28000 ????						;channel pointers
    135  28000 ????
    136  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    137  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    138  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    139  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    140  28000 ????
    141  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    142  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    143  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    144  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    145  28000 ????
    146  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    147  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    148  28000 ????		00 af	    songchannel3layer3lo =	$aF
    149  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    150  28000 ????
    151  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    152  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    153  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    154  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    155  28000 ????
    156  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    157  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    158  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    159  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    160  28000 ????
    161  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    162  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    163  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    164  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    165  28000 ????
    166  28000 ????		00 bd	    songdatalo =	$bd
    167  28000 ????		00 be	    songdatahi =	$be
    168  28000 ????
    169  28000 ????		00 bf	    inactivechannelcount =	$bf
    170  28000 ????
    171  28000 ????
    172  28000 ????		00 c0	    songchannel1transpose =	$c0
    173  28000 ????		00 c1	    songchannel2transpose =	$c1
    174  28000 ????		00 c2	    songchannel3transpose =	$c2
    175  28000 ????		00 c3	    songchannel4transpose =	$c3
    176  28000 ????
    177  28000 ????		00 c4	    songstackindex =	$c4
    178  28000 ????
    179  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    180  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    181  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    182  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    183  28000 ????
    184  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    185  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    186  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    187  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    188  28000 ????
    189  28000 ????		00 cd	    sfx1notedata =	$cd
    190  28000 ????		00 ce	    sfx2notedata =	$ce
    191  28000 ????
    192  28000 ????		00 cf	    songloops  =	$cf
    193  28000 ????
    194  28000 ????		00 d0	    songpointerlo =	$D0
    195  28000 ????		00 d1	    songpointerhi =	$D1
    196  28000 ????
    197  28000 ????		00 d2	    voxlock    =	$D2
    198  28000 ????		00 d3	    voxqueuesize =	$D3
    199  28000 ????
    200  28000 ????		00 d4	    vblankroutines =	$D4
    201  28000 ????
    202  28000 ????		00 d5	    doublebufferstate =	$D5
    203  28000 ????		00 d6	    doublebufferdloffset =	$D6
    204  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    205  28000 ????
    206  28000 ????		00 d8	    inttemp1   =	$D8
    207  28000 ????		00 d9	    inttemp2   =	$D9
    208  28000 ????		00 da	    inttemp3   =	$DA
    209  28000 ????		00 db	    inttemp4   =	$DB
    210  28000 ????		00 dc	    inttemp5   =	$DC
    211  28000 ????		00 dd	    inttemp6   =	$DD
    212  28000 ????
    213  28000 ????		00 de	    sfxschedulelock =	$DE
    214  28000 ????		00 df	    sfxschedulemissed =	$DF
    215  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    216  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    217  28000 ????		00 e2	    sfxpitchoffset =	$E2
    218  28000 ????		00 e3	    sfxnoteindex =	$E3
    219  28000 ????
    220  28000 ????		00 e4	    CTLSWAs    =	$E4
    221  28000 ????		00 e5	    CTLSWBs    =	$E5
    222  28000 ????
    223  28000 ????		00 e6	    A	       =	$e6
    224  28000 ????		00 e6	    a	       =	$e6
    225  28000 ????		00 e7	    B	       =	$e7
    226  28000 ????		00 e7	    b	       =	$e7
    227  28000 ????		00 e8	    C	       =	$e8
    228  28000 ????		00 e8	    c	       =	$e8
    229  28000 ????		00 e9	    D	       =	$e9
    230  28000 ????		00 e9	    d	       =	$e9
    231  28000 ????		00 ea	    E	       =	$ea
    232  28000 ????		00 ea	    e	       =	$ea
    233  28000 ????		00 eb	    F	       =	$eb
    234  28000 ????		00 eb	    f	       =	$eb
    235  28000 ????		00 ec	    G	       =	$ec
    236  28000 ????		00 ec	    g	       =	$ec
    237  28000 ????		00 ed	    H	       =	$ed
    238  28000 ????		00 ed	    h	       =	$ed
    239  28000 ????		00 ee	    I	       =	$ee
    240  28000 ????		00 ee	    i	       =	$ee
    241  28000 ????		00 ef	    J	       =	$ef
    242  28000 ????		00 ef	    j	       =	$ef
    243  28000 ????		00 f0	    K	       =	$f0
    244  28000 ????		00 f0	    k	       =	$f0
    245  28000 ????		00 f1	    L	       =	$f1
    246  28000 ????		00 f1	    l	       =	$f1
    247  28000 ????		00 f2	    M	       =	$f2
    248  28000 ????		00 f2	    m	       =	$f2
    249  28000 ????		00 f3	    N	       =	$f3
    250  28000 ????		00 f3	    n	       =	$f3
    251  28000 ????		00 f4	    O	       =	$f4
    252  28000 ????		00 f4	    o	       =	$f4
    253  28000 ????		00 f5	    P	       =	$f5
    254  28000 ????		00 f5	    p	       =	$f5
    255  28000 ????		00 f6	    Q	       =	$f6
    256  28000 ????		00 f6	    q	       =	$f6
    257  28000 ????		00 f7	    R	       =	$f7
    258  28000 ????		00 f7	    r	       =	$f7
    259  28000 ????		00 f8	    S	       =	$f8
    260  28000 ????		00 f8	    s	       =	$f8
    261  28000 ????		00 f9	    T	       =	$f9
    262  28000 ????		00 f9	    t	       =	$f9
    263  28000 ????		00 fa	    U	       =	$fa
    264  28000 ????		00 fa	    u	       =	$fa
    265  28000 ????		00 fb	    V	       =	$fb
    266  28000 ????		00 fb	    v	       =	$fb
    267  28000 ????		00 fc	    W	       =	$fc
    268  28000 ????		00 fc	    w	       =	$fc
    269  28000 ????		00 fd	    X	       =	$fd
    270  28000 ????		00 fd	    x	       =	$fd
    271  28000 ????		00 fe	    Y	       =	$fe
    272  28000 ????		00 fe	    y	       =	$fe
    273  28000 ????		00 ff	    Z	       =	$ff
    274  28000 ????		00 ff	    z	       =	$ff
    275  28000 ????
    276  28000 ????						; var0-var99 variables use the top of the stack
    277  28000 ????		01 40	    var0       =	$140
    278  28000 ????		01 41	    var1       =	$141
    279  28000 ????		01 42	    var2       =	$142
    280  28000 ????		01 43	    var3       =	$143
    281  28000 ????		01 44	    var4       =	$144
    282  28000 ????		01 45	    var5       =	$145
    283  28000 ????		01 46	    var6       =	$146
    284  28000 ????		01 47	    var7       =	$147
    285  28000 ????		01 48	    var8       =	$148
    286  28000 ????		01 49	    var9       =	$149
    287  28000 ????		01 4a	    var10      =	$14a
    288  28000 ????		01 4b	    var11      =	$14b
    289  28000 ????		01 4c	    var12      =	$14c
    290  28000 ????		01 4d	    var13      =	$14d
    291  28000 ????		01 4e	    var14      =	$14e
    292  28000 ????		01 4f	    var15      =	$14f
    293  28000 ????		01 50	    var16      =	$150
    294  28000 ????		01 51	    var17      =	$151
    295  28000 ????		01 52	    var18      =	$152
    296  28000 ????		01 53	    var19      =	$153
    297  28000 ????		01 54	    var20      =	$154
    298  28000 ????		01 55	    var21      =	$155
    299  28000 ????		01 56	    var22      =	$156
    300  28000 ????		01 57	    var23      =	$157
    301  28000 ????		01 58	    var24      =	$158
    302  28000 ????		01 59	    var25      =	$159
    303  28000 ????		01 5a	    var26      =	$15a
    304  28000 ????		01 5b	    var27      =	$15b
    305  28000 ????		01 5c	    var28      =	$15c
    306  28000 ????		01 5d	    var29      =	$15d
    307  28000 ????		01 5e	    var30      =	$15e
    308  28000 ????		01 5f	    var31      =	$15f
    309  28000 ????		01 60	    var32      =	$160
    310  28000 ????		01 61	    var33      =	$161
    311  28000 ????		01 62	    var34      =	$162
    312  28000 ????		01 63	    var35      =	$163
    313  28000 ????		01 64	    var36      =	$164
    314  28000 ????		01 65	    var37      =	$165
    315  28000 ????		01 66	    var38      =	$166
    316  28000 ????		01 67	    var39      =	$167
    317  28000 ????		01 68	    var40      =	$168
    318  28000 ????		01 69	    var41      =	$169
    319  28000 ????		01 6a	    var42      =	$16a
    320  28000 ????		01 6b	    var43      =	$16b
    321  28000 ????		01 6c	    var44      =	$16c
    322  28000 ????		01 6d	    var45      =	$16d
    323  28000 ????		01 6e	    var46      =	$16e
    324  28000 ????		01 6f	    var47      =	$16f
    325  28000 ????		01 70	    var48      =	$170
    326  28000 ????		01 71	    var49      =	$171
    327  28000 ????		01 72	    var50      =	$172
    328  28000 ????		01 73	    var51      =	$173
    329  28000 ????		01 74	    var52      =	$174
    330  28000 ????		01 75	    var53      =	$175
    331  28000 ????		01 76	    var54      =	$176
    332  28000 ????		01 77	    var55      =	$177
    333  28000 ????		01 78	    var56      =	$178
    334  28000 ????		01 79	    var57      =	$179
    335  28000 ????		01 7a	    var58      =	$17a
    336  28000 ????		01 7b	    var59      =	$17b
    337  28000 ????		01 7c	    var60      =	$17c
    338  28000 ????		01 7d	    var61      =	$17d
    339  28000 ????		01 7e	    var62      =	$17e
    340  28000 ????		01 7f	    var63      =	$17f
    341  28000 ????		01 80	    var64      =	$180
    342  28000 ????		01 81	    var65      =	$181
    343  28000 ????		01 82	    var66      =	$182
    344  28000 ????		01 83	    var67      =	$183
    345  28000 ????		01 84	    var68      =	$184
    346  28000 ????		01 85	    var69      =	$185
    347  28000 ????		01 86	    var70      =	$186
    348  28000 ????		01 87	    var71      =	$187
    349  28000 ????		01 88	    var72      =	$188
    350  28000 ????		01 89	    var73      =	$189
    351  28000 ????		01 8a	    var74      =	$18a
    352  28000 ????		01 8b	    var75      =	$18b
    353  28000 ????		01 8c	    var76      =	$18c
    354  28000 ????		01 8d	    var77      =	$18d
    355  28000 ????		01 8e	    var78      =	$18e
    356  28000 ????		01 8f	    var79      =	$18f
    357  28000 ????		01 90	    var80      =	$190
    358  28000 ????		01 91	    var81      =	$191
    359  28000 ????		01 92	    var82      =	$192
    360  28000 ????		01 93	    var83      =	$193
    361  28000 ????		01 94	    var84      =	$194
    362  28000 ????		01 95	    var85      =	$195
    363  28000 ????		01 96	    var86      =	$196
    364  28000 ????		01 97	    var87      =	$197
    365  28000 ????		01 98	    var88      =	$198
    366  28000 ????		01 99	    var89      =	$199
    367  28000 ????		01 9a	    var90      =	$19a
    368  28000 ????		01 9b	    var91      =	$19b
    369  28000 ????		01 9c	    var92      =	$19c
    370  28000 ????		01 9d	    var93      =	$19d
    371  28000 ????		01 9e	    var94      =	$19e
    372  28000 ????		01 9f	    var95      =	$19f
    373  28000 ????		01 a0	    var96      =	$1a0
    374  28000 ????		01 a1	    var97      =	$1a1
    375  28000 ????		01 a2	    var98      =	$1a2
    376  28000 ????		01 a3	    var99      =	$1a3
    377  28000 ????
    378 U01d2 ????				      SEG.U	"7800basicRAM"
    379 U01a4					      ORG	$1A4
    380 U01a4
    381 U01a4							; MAX allocation locations are in comments...
    382 U01a4		       00	   framecounter DS	1	; $1A4
    383 U01a5		       00	   countdownseconds DS	1	; $1A5
    384 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    385 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    386 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    387 U01ad		       00	   valbufend  DS	1	; $1AD
    388 U01ae		       00	   valbufendsave DS	1	; $1AE
    389 U01af		       00	   finescrollx DS	1	; $1AF
    390 U01b0		       00	   finescrolly DS	1	; $1B0
    391 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    392 U01b2		       00	   interruptindex DS	1	; $1B2
    393 U01b3
    394 U01b3				  -	      ifconst	DOUBLEBUFFER
    395 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    396 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    397 U01b3					      endif
    398 U01b3
    399 U01b3		       00	   pausedisable DS	1	; $1B5
    400 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    401 U01b5
    402 U01b5				  -	      ifconst	AVOXVOICE
    403 U01b5				  -avoxenable DS	1	; $1B7
    404 U01b5				  -tempavox   DS	1	; $1B8
    405 U01b5					      endif
    406 U01b5
    407 U01b5				  -	      ifconst	MUSICTRACKER
    408 U01b5				  -songtempo  DS	1	; $1B9
    409 U01b5				  -songtick   DS	1	; $1BA
    410 U01b5				  -
    411 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    412 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    413 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    414 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    415 U01b5				  -
    416 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    417 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    418 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    419 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    420 U01b5				  -
    421 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    422 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    423 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    424 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    425 U01b5				  -
    426 U01b5				  -songchannel1busywait DS	1	; $1C7
    427 U01b5				  -songchannel2busywait DS	1	; $1C8
    428 U01b5				  -songchannel3busywait DS	1	; $1C9
    429 U01b5				  -songchannel4busywait DS	1	; $1CA
    430 U01b5				  -
    431 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    432 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    433 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    434 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    435 U01b5					      endif
    436 U01b5
    437 U01b5		       00	   palframes  DS	1	; $1CF
    438 U01b6		       00	   palfastframe DS	1	; $1D0
    439 U01b7
    440 U01b7				  -	      ifconst	MOUSESUPPORT
    441 U01b7				  -port0resolution DS	1	; $1D1
    442 U01b7				  -port1resolution DS	1	; $1D2
    443 U01b7					      else
    444 U01b7				  -	      ifconst	TRAKBALLSUPPORT
    445 U01b7				  -port0resolution DS	1	; $1D1
    446 U01b7				  -port1resolution DS	1	; $1D2
    447 U01b7					      endif
    448 U01b7					      endif
    449 U01b7
    450 U01b7		       00	   port0control DS	1	; $1D3
    451 U01b8		       00	   port1control DS	1	; $1D4
    452 U01b9
    453 U01b9							; port#control values...
    454 U01b9							;	1 = proline
    455 U01b9							;	2 = lightgun
    456 U01b9							;	3 = paddle
    457 U01b9							;	4 = trakball
    458 U01b9							;	5 = vcs joystick
    459 U01b9							;	6 = driving
    460 U01b9							;	7 = keypad
    461 U01b9							;	8 = st mouse/cx80
    462 U01b9							;	9 = amiga mouse
    463 U01b9							;     10 = atarivox
    464 U01b9
    465 U01b9							; controller 0 data...
    466 U01b9		       00	   paddleposition0 DS	1	; $1D5
    467 U01b9		       01 b9	   keypadmatrix0a =	paddleposition0
    468 U01b9		       01 b9	   drivingposition0 =	paddleposition0
    469 U01b9		       01 b9	   trakballx0 =	paddleposition0
    470 U01b9		       01 b9	   mousex0    =	paddleposition0
    471 U01b9		       01 b9	   lighttgunx0 =	paddleposition0
    472 U01ba
    473 U01ba							; controller 1 data...
    474 U01ba		       00	   paddleposition2 DS	1	; $1D6
    475 U01ba		       01 ba	   keypadmatrix1a =	paddleposition2
    476 U01ba		       01 ba	   drivingposition1 =	paddleposition2
    477 U01ba		       01 ba	   trakballx1 =	paddleposition2
    478 U01ba		       01 ba	   mousex1    =	paddleposition2
    479 U01ba		       01 ba	   lightgunx1 =	paddleposition2
    480 U01bb
    481 U01bb							; controller 0 altdata...
    482 U01bb		       00	   paddleposition1 DS	1	; $1D7
    483 U01bb		       01 bb	   keypadmatrix0b =	paddleposition1
    484 U01bb		       01 bb	   trakbally0 =	paddleposition1
    485 U01bb		       01 bb	   mousey0    =	paddleposition1
    486 U01bb		       01 bb	   lightguny0 =	paddleposition1
    487 U01bc
    488 U01bc							; controller 1 altdata...
    489 U01bc		       00	   paddleposition3 DS	1	; $1D8
    490 U01bc		       01 bc	   keypadmatrix1b =	paddleposition3
    491 U01bc		       01 bc	   trakbally1 =	paddleposition3
    492 U01bc		       01 bc	   mousey1    =	paddleposition3
    493 U01bc		       01 bc	   lightguny1 =	paddleposition3
    494 U01bd
    495 U01bd							; controller state save. for trakball state+dir codes, rotary position codes
    496 U01bd		       00	   controller0statesave DS	1	; $1D9
    497 U01bd		       01 bd	   paddleprevious0 =	controller0statesave
    498 U01bd		       01 bd	   mousecodex0 =	controller0statesave
    499 U01bd		       01 bd	   trakballcodex0 =	controller0statesave
    500 U01bd		       01 bd	   keypadmatrix0c =	controller0statesave
    501 U01be
    502 U01be		       00	   controller1statesave DS	1	; $1DA
    503 U01be		       01 be	   paddleprevious2 =	controller1statesave
    504 U01be		       01 be	   mousecodex1 =	controller1statesave
    505 U01be		       01 be	   trakballcodex1 =	controller1statesave
    506 U01be		       01 be	   keypadmatrix1c =	controller1statesave
    507 U01bf
    508 U01bf		       00	   paddleprevious1 DS	1	; $1DB
    509 U01bf		       01 bf	   keypadmatrix0d =	paddleprevious1
    510 U01bf		       01 bf	   mousecodey0 =	paddleprevious1
    511 U01bf		       01 bf	   trakballcodey0 =	paddleprevious1
    512 U01c0
    513 U01c0		       00	   paddleprevious3 DS	1	; $1DC
    514 U01c0		       01 c0	   keypadmatrix1d =	paddleprevious3
    515 U01c0		       01 c0	   mousecodey1 =	paddleprevious3
    516 U01c0		       01 c0	   trakballcodey1 =	paddleprevious3
    517 U01c1
    518 U01c1					      ifconst	pokeysupport
    519 U01c1		       00	   pokey1frames DS	1	; $1DD
    520 U01c2		       00	   pokey1tick DS	1	; $1DE
    521 U01c3		       00	   pokey2frames DS	1	; $1DF
    522 U01c4		       00	   pokey2tick DS	1	; $1E0
    523 U01c5		       00	   pokey3frames DS	1	; $1E1
    524 U01c6		       00	   pokey3tick DS	1	; $1E2
    525 U01c7		       00	   pokey4frames DS	1	; $1E3
    526 U01c8		       00	   pokey4tick DS	1	; $1E4
    527 U01c9		       00	   pokey1priority DS	1	; $1E5
    528 U01ca		       00	   pokey1offset DS	1	; $1E6
    529 U01cb		       00	   pokey2priority DS	1	; $1E7
    530 U01cc		       00	   pokey2offset DS	1	; $1E8
    531 U01cd		       00	   pokey3priority DS	1	; $1E9
    532 U01ce		       00	   pokey3offset DS	1	; $1EA
    533 U01cf		       00	   pokey4priority DS	1	; $1EB
    534 U01d0		       00	   pokey4offset DS	1	; $1EC
    535 U01d1					      endif
    536 U01d1
    537 U01d1				  -	      ifconst	pokeykeysupport
    538 U01d1				  -pokeylastkeycode DS	1
    539 U01d1				  -pokeykeycode DS	1
    540 U01d1				  -pokeykeydebounce DS	1
    541 U01d1					      endif
    542 U01d1
    543 U01d1							; see if we need an interrupthold byte...
    544 U01d1				   INTERRUPTNEEDED SET	0
    545 U01d1				  -	      ifconst	.topscreenroutine
    546 U01d1				  -INTERRUPTNEEDED SET	1
    547 U01d1					      endif
    548 U01d1				  -	      ifconst	.bottomscreenroutine
    549 U01d1				  -INTERRUPTNEEDED SET	1
    550 U01d1					      endif
    551 U01d1				  -	      ifconst	.userinterrupt
    552 U01d1				  -INTERRUPTNEEDED SET	1
    553 U01d1					      endif
    554 U01d1				  -	      if	INTERRUPTNEEDED = 1
    555 U01d1				  -interrupthold DS	1	; $1ED
    556 U01d1					      endif
    557 U01d1
    558 U01d1					      ifnconst	CANARYOFF
    559 U01d1		       00	   canary     DS	1	; $1EF
    560 U01d2					      endif
    561 U01d2
    562 U01d2
    563 U01d2				  -	      ifnconst	bankswitchmode
    564 U01d2				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    565 U01d2					      else
   stack allowance: 15 nested subroutines.
    566 U01d2					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    567 U01d2					      endif
    568 U01d2					      ifnconst	CANARYOFF
   the canary is situated at: $1d1
    569 U01d2					      echo	"  the canary is situated at:",[canary]
    570 U01d2				  -	      else
    571 U01d2				  -	      echo	"  the canary is disabled."
    572 U01d2					      endif
    573 U01d2
    574 U01d2							; $1EE - $1FF reserved for stack
    575 U01d2
    576  28000 ????				       SEG	"GAME"
    577  28000 ????
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
------- FILE 7800basic_variable_redefs.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    font_mode  =	$00
      4  28000 ????		00 0b	    font_width_twoscompliment =	$0b
      5  28000 ????		00 35	    font_width =	$35
      6  28000 ????		22 20	    cTicks     =	$2220
      7  28000 ????
      8  28000 ????		22 1c	    cMode      =	$221C
      9  28000 ????
     10  28000 ????		22 18	    cType      =	$2218
     11  28000 ????
     12  28000 ????		22 14	    cSilence   =	$2214
     13  28000 ????
     14  28000 ????		22 10	    cDuration  =	$2210
     15  28000 ????
     16  28000 ????		22 0c	    cVolume    =	$220C
     17  28000 ????
     18  28000 ????		22 08	    cWaveForm  =	$2208
     19  28000 ????
     20  28000 ????		22 04	    cFrequency =	$2204
     21  28000 ????
     22  28000 ????		22 00	    cChannel   =	$2200
     23  28000 ????
     24  28000 ????		01 5b	    fireWaitMax =	var27
     25  28000 ????
     26  28000 ????		01 5a	    fireWait   =	var26
     27  28000 ????
     28  28000 ????		00 03	    TYPE_DECAY =	3
     29  28000 ????
     30  28000 ????		00 02	    TYPE_ATTACK =	2
     31  28000 ????
     32  28000 ????		00 01	    TYPE_CONSTANT =	1
     33  28000 ????
     34  28000 ????		00 02	    MODE_SILENCE =	2
     35  28000 ????
     36  28000 ????		00 01	    MODE_PLAY  =	1
     37  28000 ????
     38  28000 ????		01 54	    tMode      =	var20
     39  28000 ????
     40  28000 ????		01 53	    tTicks     =	var19
     41  28000 ????
     42  28000 ????		01 52	    tSilence   =	var18
     43  28000 ????
     44  28000 ????		01 51	    xMode      =	var17
     45  28000 ????
     46  28000 ????		01 50	    timeCount  =	var16
     47  28000 ????
     48  28000 ????		01 4f	    xSilence   =	var15
     49  28000 ????
     50  28000 ????		01 4e	    xDuration  =	var14
     51  28000 ????
     52  28000 ????		01 4d	    xColumn    =	var13
     53  28000 ????
     54  28000 ????		01 4c	    xChannel   =	var12
     55  28000 ????
     56  28000 ????		01 4b	    tColumn    =	var11
     57  28000 ????
     58  28000 ????		01 4a	    tempY      =	var10
     59  28000 ????
     60  28000 ????		01 49	    tempX      =	var9
     61  28000 ????
     62  28000 ????		01 48	    tSelected  =	var8
     63  28000 ????
     64  28000 ????		01 47	    tColor     =	var7
     65  28000 ????
     66  28000 ????		01 46	    tDuration  =	var6
     67  28000 ????
     68  28000 ????		01 45	    tType      =	var5
     69  28000 ????
     70  28000 ????		01 44	    tVolume    =	var4
     71  28000 ????
     72  28000 ????		01 43	    tWaveForm  =	var3
     73  28000 ????
     74  28000 ????		01 42	    tFrequency =	var2
     75  28000 ????
     76  28000 ????		01 41	    tChannel   =	var1
     77  28000 ????
     78  28000 ????		00 01	    plotvalueonscreen =	1
     79  28000 ????		00 0f	    font_color1 =	$0f
     80  28000 ????		00 00	    font_color0 =	$00
     81  28000 ????		00 01	    pokeysupport =	1
     82  28000 ????		00 01	    SGRAM      =	1
     83  28000 ????		00 08	    bankswitchmode =	8
     84  28000 ????		00 01	    ROM128K    =	1
     85  28000 ????		00 01	    plotvalueonscreen =	1
     86  28000 ????		00 10	    ZONEHEIGHT =	16
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
    597  28000 ????
    598  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
    599  28000 ????						; For more BEAD executable info, check out the spec...
    600  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
    601  28000 ????
    602  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
    603  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
    604  28000 ????
    605  28000 ????		00 40	    BDHSC      =	%01000000
    606  28000 ????		00 20	    BDYM       =	%00100000
    607  28000 ????		00 10	    BDPOKEY    =	%00010000
    608  28000 ????		00 08	    BDROF      =	%00001000
    609  28000 ????		00 00	    BD16K      =	%00000000
    610  28000 ????		00 01	    BD32K      =	%00000001
    611  28000 ????		00 02	    BD48K      =	%00000010
    612  28000 ????		00 05	    BD1800     =	%00000101
    613  28000 ????		00 06	    BD4000     =	%00000110
    614  28000 ????
    615  28000 ????			   -	       ifconst	ROM32K
    616  28000 ????			   -BEADHEADER =	1
    617  28000 ????				       endif
    618  28000 ????			   -	       ifconst	ROM48K
    619  28000 ????			   -BEADHEADER =	1
    620  28000 ????				       endif
    621  28000 ????
    622  28000 ????			   -	       ifconst	BEADHEADER
    623  28000 ????			   -BEADHARDWARE SET	0
    624  28000 ????			   -	       ifconst	ROM16K
    625  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
    626  28000 ????			   -	       endif
    627  28000 ????			   -	       ifconst	ROM32K
    628  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
    629  28000 ????			   -	       endif
    630  28000 ????			   -	       ifconst	ROM48K
    631  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
    632  28000 ????			   -	       endif
    633  28000 ????			   -	       ifconst	pokeysupport
    634  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
    635  28000 ????			   -	       endif
    636  28000 ????			   -	       ifconst	HSSUPPORT
    637  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
    638  28000 ????			   -	       endif
    639  28000 ????				       endif
    640  28000 ????
    641  28000 ????						;start address of cart...
    642  28000 ????			   -	       ifconst	ROM48K
    643  28000 ????			   -	       ORG	$4000,0
    644  28000 ????			   -	       ifconst	BEADHEADER
    645  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
    646  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
    647  28000 ????			   -	       CLC
    648  28000 ????			   -	       BCC	_SKIPDESCRIPTION
    649  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
    650  28000 ????			   -_SKIPDESCRIPTION
    651  28000 ????			   -	       endif
    652  28000 ????			   -	       jmp	($FFFC)
    653  28000 ????			   -	       endif
    654  28000 ????				       else
    655  28000 ????				       ifconst	bankswitchmode
    656  28000 ????			   -	       ifconst	ROMAT4K
    657  28000 ????			   -	       ORG	$4000,0
    658  28000 ????			   -	       RORG	$4000
    659  28000 ????				       else
    660  8000					      ORG	$8000,0
    661  8000					      RORG	$8000
    662  8000					      endif
    663  8000				  -	      else		; not bankswitchmode
    664  8000				  -	      ifconst	ROM16K
    665  8000				  -	      ORG	$C000,0
    666  8000				  -	      ifconst	BEADHEADER
    667  8000				  -	      .byte	$BE,$AD,BEADHARDWARE
    668  8000				  -	      ifconst	GAMEDESCRIPTION
    669  8000				  -	      CLC
    670  8000				  -	      BCC	_SKIPDESCRIPTION
    671  8000				  -	      .byte	GAMEDESCRIPTION,0
    672  8000				  -_SKIPDESCRIPTION
    673  8000				  -	      endif
    674  8000				  -	      jmp	($FFFC)
    675  8000				  -	      endif
    676  8000				  -	      else
    677  8000				  -	      ifconst	ROM8K
    678  8000				  -	      ORG	$E000,0
    679  8000				  -	      else
    680  8000				  -	      ORG	$8000,0
    681  8000				  -	      ifconst	BEADHEADER
    682  8000				  -	      .byte	$BE,$AD,BEADHARDWARE
    683  8000				  -	      ifconst	GAMEDESCRIPTION
    684  8000				  -	      CLC
    685  8000				  -	      BCC	_SKIPDESCRIPTION
    686  8000				  -	      .byte	GAMEDESCRIPTION,0
    687  8000				  -_SKIPDESCRIPTION
    688  8000				  -	      endif
    689  8000				  -	      jmp	($FFFC)
    690  8000				  -	      endif
    691  8000				  -	      endif
    692  8000				  -	      endif
    693  8000					      endif
    694  8000					      endif
    695  8000
    696  8000							;7800basic v0.19 Dec 31 2021 00:14:23
    697  8000				   SPACEOVERFLOW SET	0
    698  8000				   game
    699  8000				   .L00 		;;  set zoneheight 16
    700  8000
    701  8000				   .L01 		;;  displaymode 160A
    702  8000
    703  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
    704  8002		       85 3c		      sta	CTRL
    705  8004
    706  8004		       8d 07 21 	      sta	sCTRL
    707  8007
    708  8007				   .L02 		;;  set plotvalueonscreen on
    709  8007
    710  8007				   .L03 		;;  set romsize 128kRAM
    711  8007
    712  8007				   .L04 		;;  set dlmemory $4000 $7FFF
    713  8007
    714  8007		       40 00	   DLMEMSTART =	$4000
    715  8007		       7f ff	   DLMEMEND   =	$7FFF
    716  8007
    717  8007				   .L05 		;;  set pokeysupport on
    718  8007
    719  8007				   .L06 		;;  BACKGRND = $00
    720  8007
    721  8007		       a9 00		      LDA	#$00
    722  8009		       85 20		      STA	BACKGRND
    723  800b				   .L07 		;;  incgraphic font.png 160A 0 2 3 1
    724  800b
    725  800b				   .
    726  800b							;; 
    727  800b
    728  800b				   .L08 		;;  characterset font
    729  800b
    730  800b		       a9 a0		      lda	#>font
    731  800d		       8d 0b 21 	      sta	sCHARBASE
    732  8010
    733  8010		       85 34		      sta	CHARBASE
    734  8012		       a9 60		      lda	#(font_mode | %01100000)
    735  8014		       8d 06 21 	      sta	charactermode
    736  8017
    737  8017				   .L09 		;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
    738  8017
    739  8017				   .L010		;;  set plotvalueonscreen on 
    740  8017
    741  8017				   .
    742  8017							;; 
    743  8017
    744  8017				   .L011		;;  rem red pallette
    745  8017
    746  8017				   .L012		;;  P0C1 = $44
    747  8017
    748  8017		       a9 44		      LDA	#$44
    749  8019		       85 21		      STA	P0C1
    750  801b				   .L013		;;  P0C2 = $32
    751  801b
    752  801b		       a9 32		      LDA	#$32
    753  801d		       85 22		      STA	P0C2
    754  801f				   .L014		;;  P0C3 = $F1
    755  801f
    756  801f		       a9 f1		      LDA	#$F1
    757  8021		       85 23		      STA	P0C3
    758  8023				   .L015		;;  rem grey pallette
    759  8023
    760  8023				   .L016		;;  P1C1 = $0A
    761  8023
    762  8023		       a9 0a		      LDA	#$0A
    763  8025		       85 25		      STA	P1C1
    764  8027				   .L017		;;  P1C2 = $05
    765  8027
    766  8027		       a9 05		      LDA	#$05
    767  8029		       85 26		      STA	P1C2
    768  802b				   .L018		;;  P1C3 = $0F
    769  802b
    770  802b		       a9 0f		      LDA	#$0F
    771  802d		       85 27		      STA	P1C3
    772  802f				   .L019		;;  rem brown pallette
    773  802f
    774  802f				   .L020		;;  P2C1 = $F5
    775  802f
    776  802f		       a9 f5		      LDA	#$F5
    777  8031		       85 29		      STA	P2C1
    778  8033				   .L021		;;  P2C2 = $3F
    779  8033
    780  8033		       a9 3f		      LDA	#$3F
    781  8035		       85 2a		      STA	P2C2
    782  8037				   .L022		;;  P2C3 = $3C
    783  8037
    784  8037		       a9 3c		      LDA	#$3C
    785  8039		       85 2b		      STA	P2C3
    786  803b				   .L023		;;  rem green pallette
    787  803b
    788  803b				   .L024		;;  P3C1  = $B2
    789  803b
    790  803b		       a9 b2		      LDA	#$B2
    791  803d		       85 2d		      STA	P3C1
    792  803f				   .L025		;;  P3C2  = $C8
    793  803f
    794  803f		       a9 c8		      LDA	#$C8
    795  8041		       85 2e		      STA	P3C2
    796  8043				   .L026		;;  P3C3  = $CB
    797  8043
    798  8043		       a9 cb		      LDA	#$CB
    799  8045		       85 2f		      STA	P3C3
    800  8047				   .L027		;;  rem blue - palleete
    801  8047
    802  8047				   .L028		;;  P4C1  = $70
    803  8047
    804  8047		       a9 70		      LDA	#$70
    805  8049		       85 31		      STA	P4C1
    806  804b				   .L029		;;  P4C2  = $74
    807  804b
    808  804b		       a9 74		      LDA	#$74
    809  804d		       85 32		      STA	P4C2
    810  804f				   .L030		;;  P4C3  = $99
    811  804f
    812  804f		       a9 99		      LDA	#$99
    813  8051		       85 33		      STA	P4C3
    814  8053				   .L031		;;  rem orange pallette
    815  8053
    816  8053				   .L032		;;  P5C1  =  $35
    817  8053
    818  8053		       a9 35		      LDA	#$35
    819  8055		       85 35		      STA	P5C1
    820  8057				   .L033		;;  P5C2  =  $39
    821  8057
    822  8057		       a9 39		      LDA	#$39
    823  8059		       85 36		      STA	P5C2
    824  805b				   .L034		;;  P5C3  =  $3C
    825  805b
    826  805b		       a9 3c		      LDA	#$3C
    827  805d		       85 37		      STA	P5C3
    828  805f				   .L035		;;  rem purple palette
    829  805f
    830  805f				   .L036		;;  P6C1  =  $50
    831  805f
    832  805f		       a9 50		      LDA	#$50
    833  8061		       85 39		      STA	P6C1
    834  8063				   .L037		;;  P6C2  =  $54
    835  8063
    836  8063		       a9 54		      LDA	#$54
    837  8065		       85 3a		      STA	P6C2
    838  8067				   .L038		;;  P6C3  =  $58
    839  8067
    840  8067		       a9 58		      LDA	#$58
    841  8069		       85 3b		      STA	P6C3
    842  806b				   .L039		;;  rem yellow pallette
    843  806b
    844  806b				   .L040		;;  P7C1  =  $18
    845  806b
    846  806b		       a9 18		      LDA	#$18
    847  806d		       85 3d		      STA	P7C1
    848  806f				   .L041		;;  P7C2  =  $1B
    849  806f
    850  806f		       a9 1b		      LDA	#$1B
    851  8071		       85 3e		      STA	P7C2
    852  8073				   .L042		;;  P7C3  =  $1F
    853  8073
    854  8073		       a9 1f		      LDA	#$1F
    855  8075		       85 3f		      STA	P7C3
    856  8077				   .
    857  8077							;; 
    858  8077
    859  8077				   .
    860  8077							;; 
    861  8077
    862  8077				   .
    863  8077							;; 
    864  8077
    865  8077				   .
    866  8077							;; 
    867  8077
    868  8077				   .
    869  8077							;; 
    870  8077
    871  8077				   .
    872  8077							;; 
    873  8077
    874  8077				   .
    875  8077							;; 
    876  8077
    877  8077				   .
    878  8077							;; 
    879  8077
    880  8077				   .
    881  8077							;; 
    882  8077
    883  8077				   .
    884  8077							;; 
    885  8077
    886  8077				   .
    887  8077							;; 
    888  8077
    889  8077				   .
    890  8077							;; 
    891  8077
    892  8077				   .
    893  8077							;; 
    894  8077
    895  8077				   .
    896  8077							;; 
    897  8077
    898  8077				   .
    899  8077							;; 
    900  8077
    901  8077				   .
    902  8077							;; 
    903  8077
    904  8077				   .
    905  8077							;; 
    906  8077
    907  8077				   .
    908  8077							;; 
    909  8077
    910  8077				   .
    911  8077							;; 
    912  8077
    913  8077				   .
    914  8077							;; 
    915  8077
    916  8077				   .
    917  8077							;; 
    918  8077
    919  8077				   .
    920  8077							;; 
    921  8077
    922  8077				   .
    923  8077							;; 
    924  8077
    925  8077				   .
    926  8077							;; 
    927  8077
    928  8077				   .
    929  8077							;; 
    930  8077
    931  8077				   .
    932  8077							;; 
    933  8077
    934  8077				   .
    935  8077							;; 
    936  8077
    937  8077				   .
    938  8077							;; 
    939  8077
    940  8077				   .L043		;;  dim tChannel  =  var1
    941  8077
    942  8077				   .L044		;;  dim tFrequency  =	var2
    943  8077
    944  8077				   .L045		;;  dim tWaveForm  =  var3
    945  8077
    946  8077				   .L046		;;  dim tVolume  =  var4
    947  8077
    948  8077				   .L047		;;  dim tType	=  var5
    949  8077
    950  8077				   .L048		;;  dim tDuration  =  var6
    951  8077
    952  8077				   .L049		;;  dim tColor  =  var7
    953  8077
    954  8077				   .L050		;;  dim tSelected  =  var8
    955  8077
    956  8077				   .L051		;;  dim tempX	=  var9
    957  8077
    958  8077				   .L052		;;  dim tempY	=  var10
    959  8077
    960  8077				   .L053		;;  dim tColumn  =  var11
    961  8077
    962  8077				   .L054		;;  dim xChannel  =  var12
    963  8077
    964  8077				   .L055		;;  dim xColumn  =  var13
    965  8077
    966  8077				   .L056		;;  dim xDuration  =  var14
    967  8077
    968  8077				   .L057		;;  dim xSilence  =  var15
    969  8077
    970  8077				   .L058		;;  dim timeCount  =  var16
    971  8077
    972  8077				   .L059		;;  dim xMode	=  var17
    973  8077
    974  8077				   .L060		;;  dim tSilence  =  var18
    975  8077
    976  8077				   .L061		;;  dim tTicks  =  var19
    977  8077
    978  8077				   .L062		;;  dim tMode	=  var20
    979  8077
    980  8077				   .
    981  8077							;; 
    982  8077
    983  8077				   .
    984  8077							;; 
    985  8077
    986  8077				   .
    987  8077							;; 
    988  8077
    989  8077				   .L063		;;  const MODE_PLAY  =  1
    990  8077
    991  8077				   .L064		;;  const MODE_SILENCE  =  2
    992  8077
    993  8077				   .L065		;;  const TYPE_CONSTANT  =  1
    994  8077
    995  8077				   .L066		;;  const TYPE_ATTACK	=  2
    996  8077
    997  8077				   .L067		;;  const TYPE_DECAY  =  3
    998  8077
    999  8077				   .
   1000  8077							;; 
   1001  8077
   1002  8077				   .
   1003  8077							;; 
   1004  8077
   1005  8077				   .L068		;;  dim fireWait  =  var26
   1006  8077
   1007  8077				   .L069		;;  dim fireWaitMax  =  var27
   1008  8077
   1009  8077				   .
   1010  8077							;; 
   1011  8077
   1012  8077				   .L070		;;  dim cChannel  =  $2200
   1013  8077
   1014  8077				   .L071		;;  dim cFrequency  =	$2204
   1015  8077
   1016  8077				   .L072		;;  dim cWaveForm  =  $2208
   1017  8077
   1018  8077				   .L073		;;  dim cVolume  =  $220C
   1019  8077
   1020  8077				   .L074		;;  dim cDuration  =  $2210
   1021  8077
   1022  8077				   .L075		;;  dim cSilence  =  $2214
   1023  8077
   1024  8077				   .L076		;;  dim cType	=  $2218
   1025  8077
   1026  8077				   .L077		;;  dim cMode	=  $221C
   1027  8077
   1028  8077				   .L078		;;  dim cTicks  =  $2220
   1029  8077
   1030  8077				   .
   1031  8077							;; 
   1032  8077
   1033  8077				   .
   1034  8077							;; 
   1035  8077
   1036  8077				   .
   1037  8077							;; 
   1038  8077
   1039  8077				   .
   1040  8077							;; 
   1041  8077
   1042  8077				   .
   1043  8077							;; 
   1044  8077
   1045  8077				   .
   1046  8077							;; 
   1047  8077
   1048  8077				   .
   1049  8077							;; 
   1050  8077
   1051  8077				   .
   1052  8077							;; 
   1053  8077
   1054  8077				   .
   1055  8077							;; 
   1056  8077
   1057  8077				   .
   1058  8077							;; 
   1059  8077
   1060  8077				   .
   1061  8077							;; 
   1062  8077
   1063  8077				   .
   1064  8077							;; 
   1065  8077
   1066  8077				   .
   1067  8077							;; 
   1068  8077
   1069  8077				   .
   1070  8077							;; 
   1071  8077
   1072  8077				   .
   1073  8077							;; 
   1074  8077
   1075  8077				   .
   1076  8077							;; 
   1077  8077
   1078  8077				   .
   1079  8077							;; 
   1080  8077
   1081  8077				   .
   1082  8077							;; 
   1083  8077
   1084  8077				   .
   1085  8077							;; 
   1086  8077
   1087  8077				   .
   1088  8077							;; 
   1089  8077
   1090  8077				   .
   1091  8077							;; 
   1092  8077
   1093  8077				   .
   1094  8077							;; 
   1095  8077
   1096  8077				   .
   1097  8077							;; 
   1098  8077
   1099  8077				   .
   1100  8077							;; 
   1101  8077
   1102  8077				   .
   1103  8077							;; 
   1104  8077
   1105  8077				   .
   1106  8077							;; 
   1107  8077
   1108  8077				   .
   1109  8077							;; 
   1110  8077
   1111  8077				   .
   1112  8077							;; 
   1113  8077
   1114  8077				   .
   1115  8077							;; 
   1116  8077
   1117  8077				   .
   1118  8077							;; 
   1119  8077
   1120  8077				   .
   1121  8077							;; 
   1122  8077
   1123  8077				   .
   1124  8077							;; 
   1125  8077
   1126  8077				   .
   1127  8077							;; 
   1128  8077
   1129  8077				   .L079		;;  tColor  =	0
   1130  8077
   1131  8077		       a9 00		      LDA	#0
   1132  8079		       8d 47 01 	      STA	tColor
   1133  807c				   .L080		;;  fireWait = 0
   1134  807c
   1135  807c		       a9 00		      LDA	#0
   1136  807e		       8d 5a 01 	      STA	fireWait
   1137  8081				   .L081		;;  fireWaitMax = 3
   1138  8081
   1139  8081		       a9 03		      LDA	#3
   1140  8083		       8d 5b 01 	      STA	fireWaitMax
   1141  8086				   .L082		;;  tChannel =  0
   1142  8086
   1143  8086		       a9 00		      LDA	#0
   1144  8088		       8d 41 01 	      STA	tChannel
   1145  808b				   .L083		;;  tColumn  =  0
   1146  808b
   1147  808b		       a9 00		      LDA	#0
   1148  808d		       8d 4b 01 	      STA	tColumn
   1149  8090				   .
   1150  8090							;; 
   1151  8090
   1152  8090				   .
   1153  8090							;; 
   1154  8090
   1155  8090				   .
   1156  8090							;; 
   1157  8090
   1158  8090				   .L084		;;  xMode  =  MODE_PLAY
   1159  8090
   1160  8090		       a9 01		      LDA	#MODE_PLAY
   1161  8092		       8d 51 01 	      STA	xMode
   1162  8095				   .
   1163  8095							;; 
   1164  8095
   1165  8095				   .L085		;;  for i  =  0 to 3
   1166  8095
   1167  8095		       a9 00		      LDA	#0
   1168  8097		       85 ee		      STA	i
   1169  8099				   .L085fori
   1170  8099				   .L086		;;  cChannel[i]  =  i
   1171  8099
   1172  8099		       a5 ee		      LDA	i
   1173  809b		       a6 ee		      LDX	i
   1174  809d		       9d 00 22 	      STA	cChannel,x
   1175  80a0				   .L087		;;  cFrequency[i]  =  0
   1176  80a0
   1177  80a0		       a9 00		      LDA	#0
   1178  80a2		       a6 ee		      LDX	i
   1179  80a4		       9d 04 22 	      STA	cFrequency,x
   1180  80a7				   .L088		;;  cWaveForm[i]  =  0
   1181  80a7
   1182  80a7		       a9 00		      LDA	#0
   1183  80a9		       a6 ee		      LDX	i
   1184  80ab		       9d 08 22 	      STA	cWaveForm,x
   1185  80ae				   .L089		;;  cVolume[i]  =  0
   1186  80ae
   1187  80ae		       a9 00		      LDA	#0
   1188  80b0		       a6 ee		      LDX	i
   1189  80b2		       9d 0c 22 	      STA	cVolume,x
   1190  80b5				   .L090		;;  cDuration[i]  =  8
   1191  80b5
   1192  80b5		       a9 08		      LDA	#8
   1193  80b7		       a6 ee		      LDX	i
   1194  80b9		       9d 10 22 	      STA	cDuration,x
   1195  80bc				   .L091		;;  cSilence[i]  =  4
   1196  80bc
   1197  80bc		       a9 04		      LDA	#4
   1198  80be		       a6 ee		      LDX	i
   1199  80c0		       9d 14 22 	      STA	cSilence,x
   1200  80c3				   .L092		;;  cType[i]  =  TYPE_CONSTANT
   1201  80c3
   1202  80c3		       a9 01		      LDA	#TYPE_CONSTANT
   1203  80c5		       a6 ee		      LDX	i
   1204  80c7		       9d 18 22 	      STA	cType,x
   1205  80ca				   .L093		;;  cTicks[i]	=  0
   1206  80ca
   1207  80ca		       a9 00		      LDA	#0
   1208  80cc		       a6 ee		      LDX	i
   1209  80ce		       9d 20 22 	      STA	cTicks,x
   1210  80d1				   .L094		;;  cMode[i]  =  MODE_PLAY
   1211  80d1
   1212  80d1		       a9 01		      LDA	#MODE_PLAY
   1213  80d3		       a6 ee		      LDX	i
   1214  80d5		       9d 1c 22 	      STA	cMode,x
   1215  80d8				   .
   1216  80d8							;; 
   1217  80d8
   1218  80d8				   .
   1219  80d8							;; 
   1220  80d8
   1221  80d8				   .
   1222  80d8							;; 
   1223  80d8
   1224  80d8				   .L095		;;  next
   1225  80d8
   1226  80d8		       a5 ee		      LDA	i
   1227  80da		       c9 03		      CMP	#3
   1228  80dc		       e6 ee		      INC	i
   1229  80de					      if	((* - .L085fori) < 127) && ((* - .L085fori) > -128)
   1230  80de		       90 b9		      bcc	.L085fori
   1231  80e0				  -	      else
   1232  80e0				  -	      bcs	.0skipL085fori
   1233  80e0				  -	      jmp	.L085fori
   1234  80e0				  -.0skipL085fori
   1235  80e0					      endif
   1236  80e0				   .L096		;;  tSelected	=  0
   1237  80e0
   1238  80e0		       a9 00		      LDA	#0
   1239  80e2		       8d 48 01 	      STA	tSelected
   1240  80e5				   .mainScreen
   1241  80e5							;; mainScreen
   1242  80e5
   1243  80e5				   .L097		;;  clearscreen
   1244  80e5
   1245  80e5		       20 c5 f1 	      jsr	clearscreen
   1246  80e8				   .L098		;;  for i  =  0 to 3
   1247  80e8
   1248  80e8		       a9 00		      LDA	#0
   1249  80ea		       85 ee		      STA	i
   1250  80ec				   .L098fori
   1251  80ec				   .L099		;;  tChannel  =  cChannel[i]
   1252  80ec
   1253  80ec		       a6 ee		      LDX	i
   1254  80ee		       bd 00 22 	      LDA	cChannel,x
   1255  80f1		       8d 41 01 	      STA	tChannel
   1256  80f4				   .L0100		;;  tFrequency  =  cFrequency[i]
   1257  80f4
   1258  80f4		       a6 ee		      LDX	i
   1259  80f6		       bd 04 22 	      LDA	cFrequency,x
   1260  80f9		       8d 42 01 	      STA	tFrequency
   1261  80fc				   .L0101		;;  tMode  =  cMode[i]
   1262  80fc
   1263  80fc		       a6 ee		      LDX	i
   1264  80fe		       bd 1c 22 	      LDA	cMode,x
   1265  8101		       8d 54 01 	      STA	tMode
   1266  8104				   .L0102		;;  tType  =  cType[i]
   1267  8104
   1268  8104		       a6 ee		      LDX	i
   1269  8106		       bd 18 22 	      LDA	cType,x
   1270  8109		       8d 45 01 	      STA	tType
   1271  810c				   .L0103		;;  tDuration	=  cDuration[i]
   1272  810c
   1273  810c		       a6 ee		      LDX	i
   1274  810e		       bd 10 22 	      LDA	cDuration,x
   1275  8111		       8d 46 01 	      STA	tDuration
   1276  8114				   .L0104		;;  tSilence  =  cSilence[i]
   1277  8114
   1278  8114		       a6 ee		      LDX	i
   1279  8116		       bd 14 22 	      LDA	cSilence,x
   1280  8119		       8d 52 01 	      STA	tSilence
   1281  811c				   .L0105		;;  tTicks  =	cTicks[i]
   1282  811c
   1283  811c		       a6 ee		      LDX	i
   1284  811e		       bd 20 22 	      LDA	cTicks,x
   1285  8121		       8d 53 01 	      STA	tTicks
   1286  8124				   .L0106		;;  if tMode  =  MODE_SILENCE then tFrequency	=  0
   1287  8124
   1288  8124		       ad 54 01 	      LDA	tMode
   1289  8127		       c9 02		      CMP	#MODE_SILENCE
   1290  8129		       d0 05		      BNE	.skipL0106
   1291  812b				   .condpart0
   1292  812b		       a9 00		      LDA	#0
   1293  812d		       8d 42 01 	      STA	tFrequency
   1294  8130				   .skipL0106
   1295  8130				   .L0107		;;  tWaveForm	=  cWaveForm[i]
   1296  8130
   1297  8130		       a6 ee		      LDX	i
   1298  8132		       bd 08 22 	      LDA	cWaveForm,x
   1299  8135		       8d 43 01 	      STA	tWaveForm
   1300  8138				   .L0108		;;  if tMode  =  MODE_SILENCE then tWaveForm  =  0
   1301  8138
   1302  8138		       ad 54 01 	      LDA	tMode
   1303  813b		       c9 02		      CMP	#MODE_SILENCE
   1304  813d		       d0 05		      BNE	.skipL0108
   1305  813f				   .condpart1
   1306  813f		       a9 00		      LDA	#0
   1307  8141		       8d 43 01 	      STA	tWaveForm
   1308  8144				   .skipL0108
   1309  8144				   .L0109		;;  tVolume  =  cVolume[i]
   1310  8144
   1311  8144		       a6 ee		      LDX	i
   1312  8146		       bd 0c 22 	      LDA	cVolume,x
   1313  8149		       8d 44 01 	      STA	tVolume
   1314  814c				   .L0110		;;  if tMode  =  MODE_SILENCE then tVolume  =	0
   1315  814c
   1316  814c		       ad 54 01 	      LDA	tMode
   1317  814f		       c9 02		      CMP	#MODE_SILENCE
   1318  8151		       d0 05		      BNE	.skipL0110
   1319  8153				   .condpart2
   1320  8153		       a9 00		      LDA	#0
   1321  8155		       8d 44 01 	      STA	tVolume
   1322  8158				   .skipL0110
   1323  8158				   .L0111		;;  if tType  =  TYPE_ATTACK then tVolume  =  tVolume	+  1
   1324  8158
   1325  8158		       ad 45 01 	      LDA	tType
   1326  815b		       c9 02		      CMP	#TYPE_ATTACK
   1327  815d		       d0 09		      BNE	.skipL0111
   1328  815f				   .condpart3
   1329  815f		       ad 44 01 	      LDA	tVolume
   1330  8162		       18		      CLC
   1331  8163		       69 01		      ADC	#1
   1332  8165		       8d 44 01 	      STA	tVolume
   1333  8168				   .skipL0111
   1334  8168				   .L0112		;;  if tType  =  TYPE_DECAY then tVolume  =  tVolume  -  1
   1335  8168
   1336  8168		       ad 45 01 	      LDA	tType
   1337  816b		       c9 03		      CMP	#TYPE_DECAY
   1338  816d		       d0 09		      BNE	.skipL0112
   1339  816f				   .condpart4
   1340  816f		       ad 44 01 	      LDA	tVolume
   1341  8172		       38		      SEC
   1342  8173		       e9 01		      SBC	#1
   1343  8175		       8d 44 01 	      STA	tVolume
   1344  8178				   .skipL0112
   1345  8178				   .L0113		;;  if tVolume  =  16 then tVolume =  15
   1346  8178
   1347  8178		       ad 44 01 	      LDA	tVolume
   1348  817b		       c9 10		      CMP	#16
   1349  817d		       d0 05		      BNE	.skipL0113
   1350  817f				   .condpart5
   1351  817f		       a9 0f		      LDA	#15
   1352  8181		       8d 44 01 	      STA	tVolume
   1353  8184				   .skipL0113
   1354  8184				   .L0114		;;  if tVolume  =  255 then tVolume  =  0
   1355  8184
   1356  8184		       ad 44 01 	      LDA	tVolume
   1357  8187		       c9 ff		      CMP	#255
   1358  8189		       d0 05		      BNE	.skipL0114
   1359  818b				   .condpart6
   1360  818b		       a9 00		      LDA	#0
   1361  818d		       8d 44 01 	      STA	tVolume
   1362  8190				   .skipL0114
   1363  8190				   .
   1364  8190							;; 
   1365  8190
   1366  8190				   .
   1367  8190							;; 
   1368  8190
   1369  8190				   .L0115		;;  psound tChannel , tFrequency , tWaveForm , tVolume
   1370  8190
   1371  8190		       ad 41 01 	      lda	tChannel
   1372  8193		       0a		      asl
   1373  8194		       a8		      tay
   1374  8195		       ad 42 01 	      lda	tFrequency
   1375  8198		       91 4b		      sta	(pokeybase),y
   1376  819a		       c8		      iny
   1377  819b		       ad 43 01 	      lda	tWaveForm
   1378  819e		       0a		      asl
   1379  819f		       0a		      asl
   1380  81a0		       0a		      asl
   1381  81a1		       0a		      asl
   1382  81a2		       18		      clc
   1383  81a3		       6d 44 01 	      adc	tVolume
   1384  81a6		       91 4b		      sta	(pokeybase),y
   1385  81a8				   .
   1386  81a8							;; 
   1387  81a8
   1388  81a8				   .L0116		;;  tTicks  =	tTicks	+  1
   1389  81a8
   1390  81a8		       ad 53 01 	      LDA	tTicks
   1391  81ab		       18		      CLC
   1392  81ac		       69 01		      ADC	#1
   1393  81ae		       8d 53 01 	      STA	tTicks
   1394  81b1				   .L0117		;;  if tType  =  TYPE_ATTACK  ||  tType  =  TYPE_DECAY then cVolume[i]  =  tVolume
   1395  81b1
   1396  81b1		       ad 45 01 	      LDA	tType
   1397  81b4		       c9 02		      CMP	#TYPE_ATTACK
   1398  81b6		       d0 03		      BNE	.skipL0117
   1399  81b8				   .condpart7
   1400  81b8		       4c c2 81 	      jmp	.condpart8
   1401  81bb				   .skipL0117
   1402  81bb		       ad 45 01 	      LDA	tType
   1403  81be		       c9 03		      CMP	#TYPE_DECAY
   1404  81c0		       d0 08		      BNE	.skip0OR
   1405  81c2				   .condpart8
   1406  81c2		       ad 44 01 	      LDA	tVolume
   1407  81c5		       a6 ee		      LDX	i
   1408  81c7		       9d 0c 22 	      STA	cVolume,x
   1409  81ca				   .skip0OR
   1410  81ca				   .L0118		;;  if tMode  =  MODE_PLAY  &&  tTicks  >=  tDuration then goto _doEndPlay
   1411  81ca
   1412  81ca		       ad 54 01 	      LDA	tMode
   1413  81cd		       c9 01		      CMP	#MODE_PLAY
   1414  81cf		       d0 0b		      BNE	.skipL0118
   1415  81d1				   .condpart9
   1416  81d1		       ad 53 01 	      LDA	tTicks
   1417  81d4		       cd 46 01 	      CMP	tDuration
   1418  81d7		       90 03		      BCC	.skip9then
   1419  81d9				   .condpart10
   1420  81d9		       4c df 81 	      jmp	._doEndPlay
   1421  81dc
   1422  81dc				   .skip9then
   1423  81dc				   .skipL0118
   1424  81dc				   .L0119		;;  goto _doSilentTest
   1425  81dc
   1426  81dc		       4c 1b 82 	      jmp	._doSilentTest
   1427  81df
   1428  81df				   ._doEndPlay
   1429  81df							;; _doEndPlay
   1430  81df
   1431  81df				   .L0120		;;  if tSilence  >  0 then tMode  =  MODE_SILENCE
   1432  81df
   1433  81df		       a9 00		      LDA	#0
   1434  81e1		       cd 52 01 	      CMP	tSilence
   1435  81e4		       b0 05		      BCS	.skipL0120
   1436  81e6				   .condpart11
   1437  81e6		       a9 02		      LDA	#MODE_SILENCE
   1438  81e8		       8d 54 01 	      STA	tMode
   1439  81eb				   .skipL0120
   1440  81eb				   .L0121		;;  tTicks  =	0
   1441  81eb
   1442  81eb		       a9 00		      LDA	#0
   1443  81ed		       8d 53 01 	      STA	tTicks
   1444  81f0				   .L0122		;;  if tType  =  TYPE_ATTACK then tVolume  =  0  :  cVolume[i]  =  tVolume
   1445  81f0
   1446  81f0		       ad 45 01 	      LDA	tType
   1447  81f3		       c9 02		      CMP	#TYPE_ATTACK
   1448  81f5		       d0 0d		      BNE	.skipL0122
   1449  81f7				   .condpart12
   1450  81f7		       a9 00		      LDA	#0
   1451  81f9		       8d 44 01 	      STA	tVolume
   1452  81fc		       ad 44 01 	      LDA	tVolume
   1453  81ff		       a6 ee		      LDX	i
   1454  8201		       9d 0c 22 	      STA	cVolume,x
   1455  8204				   .skipL0122
   1456  8204				   .L0123		;;  if tType  =  TYPE_DECAY then tVolume  =  15  :  cVolume[i]  =  tVolume
   1457  8204
   1458  8204		       ad 45 01 	      LDA	tType
   1459  8207		       c9 03		      CMP	#TYPE_DECAY
   1460  8209		       d0 0d		      BNE	.skipL0123
   1461  820b				   .condpart13
   1462  820b		       a9 0f		      LDA	#15
   1463  820d		       8d 44 01 	      STA	tVolume
   1464  8210		       ad 44 01 	      LDA	tVolume
   1465  8213		       a6 ee		      LDX	i
   1466  8215		       9d 0c 22 	      STA	cVolume,x
   1467  8218				   .skipL0123
   1468  8218				   .L0124		;;  goto _skipSilentTest
   1469  8218
   1470  8218		       4c 6c 82 	      jmp	._skipSilentTest
   1471  821b
   1472  821b				   ._doSilentTest
   1473  821b							;; _doSilentTest
   1474  821b
   1475  821b				   .L0125		;;  if tSilence  =  0 then goto _skipSilentTest
   1476  821b
   1477  821b		       ad 52 01 	      LDA	tSilence
   1478  821e		       c9 00		      CMP	#0
   1479  8220		       d0 03		      BNE	.skipL0125
   1480  8222				   .condpart14
   1481  8222		       4c 6c 82 	      jmp	._skipSilentTest
   1482  8225
   1483  8225				   .skipL0125
   1484  8225				   .L0126		;;  if tMode  =  MODE_SILENCE	&&  tTicks  >=	tSilence then goto _doEndSilence
   1485  8225
   1486  8225		       ad 54 01 	      LDA	tMode
   1487  8228		       c9 02		      CMP	#MODE_SILENCE
   1488  822a		       d0 0b		      BNE	.skipL0126
   1489  822c				   .condpart15
   1490  822c		       ad 53 01 	      LDA	tTicks
   1491  822f		       cd 52 01 	      CMP	tSilence
   1492  8232		       90 03		      BCC	.skip15then
   1493  8234				   .condpart16
   1494  8234		       4c 3a 82 	      jmp	._doEndSilence
   1495  8237
   1496  8237				   .skip15then
   1497  8237				   .skipL0126
   1498  8237				   .L0127		;;  goto _skipSilentTest
   1499  8237
   1500  8237		       4c 6c 82 	      jmp	._skipSilentTest
   1501  823a
   1502  823a				   ._doEndSilence
   1503  823a							;; _doEndSilence
   1504  823a
   1505  823a				   .L0128		;;  tMode  =  MODE_PLAY
   1506  823a
   1507  823a		       a9 01		      LDA	#MODE_PLAY
   1508  823c		       8d 54 01 	      STA	tMode
   1509  823f				   .L0129		;;  tTicks  =	0
   1510  823f
   1511  823f		       a9 00		      LDA	#0
   1512  8241		       8d 53 01 	      STA	tTicks
   1513  8244				   .L0130		;;  if tType  =  TYPE_ATTACK then tVolume  =  0  :  cVolume[i]  =  tVolume
   1514  8244
   1515  8244		       ad 45 01 	      LDA	tType
   1516  8247		       c9 02		      CMP	#TYPE_ATTACK
   1517  8249		       d0 0d		      BNE	.skipL0130
   1518  824b				   .condpart17
   1519  824b		       a9 00		      LDA	#0
   1520  824d		       8d 44 01 	      STA	tVolume
   1521  8250		       ad 44 01 	      LDA	tVolume
   1522  8253		       a6 ee		      LDX	i
   1523  8255		       9d 0c 22 	      STA	cVolume,x
   1524  8258				   .skipL0130
   1525  8258				   .L0131		;;  if tType  =  TYPE_DECAY then tVolume  =  15  :  cVolume[i]  =  tVolume
   1526  8258
   1527  8258		       ad 45 01 	      LDA	tType
   1528  825b		       c9 03		      CMP	#TYPE_DECAY
   1529  825d		       d0 0d		      BNE	.skipL0131
   1530  825f				   .condpart18
   1531  825f		       a9 0f		      LDA	#15
   1532  8261		       8d 44 01 	      STA	tVolume
   1533  8264		       ad 44 01 	      LDA	tVolume
   1534  8267		       a6 ee		      LDX	i
   1535  8269		       9d 0c 22 	      STA	cVolume,x
   1536  826c				   .skipL0131
   1537  826c				   ._skipSilentTest
   1538  826c							;; _skipSilentTest
   1539  826c
   1540  826c				   .L0132		;;  cMode[i]  =  tMode
   1541  826c
   1542  826c		       ad 54 01 	      LDA	tMode
   1543  826f		       a6 ee		      LDX	i
   1544  8271		       9d 1c 22 	      STA	cMode,x
   1545  8274				   .L0133		;;  cTicks[i]	=  tTicks
   1546  8274
   1547  8274		       ad 53 01 	      LDA	tTicks
   1548  8277		       a6 ee		      LDX	i
   1549  8279		       9d 20 22 	      STA	cTicks,x
   1550  827c				   .L0134		;;  next
   1551  827c
   1552  827c		       a5 ee		      LDA	i
   1553  827e		       c9 03		      CMP	#3
   1554  8280		       e6 ee		      INC	i
   1555  8282				  -	      if	((* - .L098fori) < 127) && ((* - .L098fori) > -128)
   1556  8282				  -	      bcc	.L098fori
   1557  8282					      else
   1558  8282		       b0 03		      bcs	.1skipL098fori
   1559  8284		       4c ec 80 	      jmp	.L098fori
   1560  8287				   .1skipL098fori
   1561  8287					      endif
   1562  8287				   .
   1563  8287							;; 
   1564  8287
   1565  8287				   .
   1566  8287							;; 
   1567  8287
   1568  8287				   .
   1569  8287							;; 
   1570  8287
   1571  8287				   .
   1572  8287							;; 
   1573  8287
   1574  8287				   .L0135		;;  plotchars 'f' 5 20 2
   1575  8287
   1576  8287		       4c 8b 82 	      JMP	skipalphadata0
   1577  828a				   alphadata0
   1578  828a		       0f		      .byte.b	(<font + $0f)
   1579  828b				   skipalphadata0
   1580  828b		       a9 8a		      lda	#<alphadata0
   1581  828d		       85 42		      sta	temp1
   1582  828f
   1583  828f		       a9 82		      lda	#>alphadata0
   1584  8291		       85 43		      sta	temp2
   1585  8293
   1586  8293		       a9 1f		      lda	#31	; width in two's complement
   1587  8295		       09 a0		      ora	#160	; palette left shifted 5 bits
   1588  8297		       85 44		      sta	temp3
   1589  8299		       a9 14		      lda	#20
   1590  829b		       85 45		      sta	temp4
   1591  829d
   1592  829d		       a9 02		      lda	#2
   1593  829f
   1594  829f		       85 46		      sta	temp5
   1595  82a1
   1596  82a1		       20 c6 f4 	      jsr	plotcharacters
   1597  82a4				   .L0136		;;  plotchars 'w' 5 40 2
   1598  82a4
   1599  82a4		       4c a8 82 	      JMP	skipalphadata1
   1600  82a7				   alphadata1
   1601  82a7		       20		      .byte.b	(<font + $20)
   1602  82a8				   skipalphadata1
   1603  82a8		       a9 a7		      lda	#<alphadata1
   1604  82aa		       85 42		      sta	temp1
   1605  82ac
   1606  82ac		       a9 82		      lda	#>alphadata1
   1607  82ae		       85 43		      sta	temp2
   1608  82b0
   1609  82b0		       a9 1f		      lda	#31	; width in two's complement
   1610  82b2		       09 a0		      ora	#160	; palette left shifted 5 bits
   1611  82b4		       85 44		      sta	temp3
   1612  82b6		       a9 28		      lda	#40
   1613  82b8		       85 45		      sta	temp4
   1614  82ba
   1615  82ba		       a9 02		      lda	#2
   1616  82bc
   1617  82bc		       85 46		      sta	temp5
   1618  82be
   1619  82be		       20 c6 f4 	      jsr	plotcharacters
   1620  82c1				   .L0137		;;  plotchars 'v' 5 60 2
   1621  82c1
   1622  82c1		       4c c5 82 	      JMP	skipalphadata2
   1623  82c4				   alphadata2
   1624  82c4		       1f		      .byte.b	(<font + $1f)
   1625  82c5				   skipalphadata2
   1626  82c5		       a9 c4		      lda	#<alphadata2
   1627  82c7		       85 42		      sta	temp1
   1628  82c9
   1629  82c9		       a9 82		      lda	#>alphadata2
   1630  82cb		       85 43		      sta	temp2
   1631  82cd
   1632  82cd		       a9 1f		      lda	#31	; width in two's complement
   1633  82cf		       09 a0		      ora	#160	; palette left shifted 5 bits
   1634  82d1		       85 44		      sta	temp3
   1635  82d3		       a9 3c		      lda	#60
   1636  82d5		       85 45		      sta	temp4
   1637  82d7
   1638  82d7		       a9 02		      lda	#2
   1639  82d9
   1640  82d9		       85 46		      sta	temp5
   1641  82db
   1642  82db		       20 c6 f4 	      jsr	plotcharacters
   1643  82de				   .L0138		;;  plotchars 'd' 5 80 2
   1644  82de
   1645  82de		       4c e2 82 	      JMP	skipalphadata3
   1646  82e1				   alphadata3
   1647  82e1		       0d		      .byte.b	(<font + $0d)
   1648  82e2				   skipalphadata3
   1649  82e2		       a9 e1		      lda	#<alphadata3
   1650  82e4		       85 42		      sta	temp1
   1651  82e6
   1652  82e6		       a9 82		      lda	#>alphadata3
   1653  82e8		       85 43		      sta	temp2
   1654  82ea
   1655  82ea		       a9 1f		      lda	#31	; width in two's complement
   1656  82ec		       09 a0		      ora	#160	; palette left shifted 5 bits
   1657  82ee		       85 44		      sta	temp3
   1658  82f0		       a9 50		      lda	#80
   1659  82f2		       85 45		      sta	temp4
   1660  82f4
   1661  82f4		       a9 02		      lda	#2
   1662  82f6
   1663  82f6		       85 46		      sta	temp5
   1664  82f8
   1665  82f8		       20 c6 f4 	      jsr	plotcharacters
   1666  82fb				   .L0139		;;  plotchars 's' 5 100 2
   1667  82fb
   1668  82fb		       4c ff 82 	      JMP	skipalphadata4
   1669  82fe				   alphadata4
   1670  82fe		       1c		      .byte.b	(<font + $1c)
   1671  82ff				   skipalphadata4
   1672  82ff		       a9 fe		      lda	#<alphadata4
   1673  8301		       85 42		      sta	temp1
   1674  8303
   1675  8303		       a9 82		      lda	#>alphadata4
   1676  8305		       85 43		      sta	temp2
   1677  8307
   1678  8307		       a9 1f		      lda	#31	; width in two's complement
   1679  8309		       09 a0		      ora	#160	; palette left shifted 5 bits
   1680  830b		       85 44		      sta	temp3
   1681  830d		       a9 64		      lda	#100
   1682  830f		       85 45		      sta	temp4
   1683  8311
   1684  8311		       a9 02		      lda	#2
   1685  8313
   1686  8313		       85 46		      sta	temp5
   1687  8315
   1688  8315		       20 c6 f4 	      jsr	plotcharacters
   1689  8318				   .L0140		;;  plotchars 't' 5 120 2
   1690  8318
   1691  8318		       4c 1c 83 	      JMP	skipalphadata5
   1692  831b				   alphadata5
   1693  831b		       1d		      .byte.b	(<font + $1d)
   1694  831c				   skipalphadata5
   1695  831c		       a9 1b		      lda	#<alphadata5
   1696  831e		       85 42		      sta	temp1
   1697  8320
   1698  8320		       a9 83		      lda	#>alphadata5
   1699  8322		       85 43		      sta	temp2
   1700  8324
   1701  8324		       a9 1f		      lda	#31	; width in two's complement
   1702  8326		       09 a0		      ora	#160	; palette left shifted 5 bits
   1703  8328		       85 44		      sta	temp3
   1704  832a		       a9 78		      lda	#120
   1705  832c		       85 45		      sta	temp4
   1706  832e
   1707  832e		       a9 02		      lda	#2
   1708  8330
   1709  8330		       85 46		      sta	temp5
   1710  8332
   1711  8332		       20 c6 f4 	      jsr	plotcharacters
   1712  8335				   .
   1713  8335							;; 
   1714  8335
   1715  8335				   .
   1716  8335							;; 
   1717  8335
   1718  8335				   .L0141		;;  plotchars 'c0' 1 10 3
   1719  8335
   1720  8335		       4c 3a 83 	      JMP	skipalphadata6
   1721  8338				   alphadata6
   1722  8338		       0c		      .byte.b	(<font + $0c)
   1723  8339		       00		      .byte.b	(<font + $00)
   1724  833a				   skipalphadata6
   1725  833a		       a9 38		      lda	#<alphadata6
   1726  833c		       85 42		      sta	temp1
   1727  833e
   1728  833e		       a9 83		      lda	#>alphadata6
   1729  8340		       85 43		      sta	temp2
   1730  8342
   1731  8342		       a9 1e		      lda	#30	; width in two's complement
   1732  8344		       09 20		      ora	#32	; palette left shifted 5 bits
   1733  8346		       85 44		      sta	temp3
   1734  8348		       a9 0a		      lda	#10
   1735  834a		       85 45		      sta	temp4
   1736  834c
   1737  834c		       a9 03		      lda	#3
   1738  834e
   1739  834e		       85 46		      sta	temp5
   1740  8350
   1741  8350		       20 c6 f4 	      jsr	plotcharacters
   1742  8353				   .L0142		;;  plotchars 'c1' 1 10 4
   1743  8353
   1744  8353		       4c 58 83 	      JMP	skipalphadata7
   1745  8356				   alphadata7
   1746  8356		       0c		      .byte.b	(<font + $0c)
   1747  8357		       01		      .byte.b	(<font + $01)
   1748  8358				   skipalphadata7
   1749  8358		       a9 56		      lda	#<alphadata7
   1750  835a		       85 42		      sta	temp1
   1751  835c
   1752  835c		       a9 83		      lda	#>alphadata7
   1753  835e		       85 43		      sta	temp2
   1754  8360
   1755  8360		       a9 1e		      lda	#30	; width in two's complement
   1756  8362		       09 20		      ora	#32	; palette left shifted 5 bits
   1757  8364		       85 44		      sta	temp3
   1758  8366		       a9 0a		      lda	#10
   1759  8368		       85 45		      sta	temp4
   1760  836a
   1761  836a		       a9 04		      lda	#4
   1762  836c
   1763  836c		       85 46		      sta	temp5
   1764  836e
   1765  836e		       20 c6 f4 	      jsr	plotcharacters
   1766  8371				   .L0143		;;  plotchars 'c2' 1 10 5
   1767  8371
   1768  8371		       4c 76 83 	      JMP	skipalphadata8
   1769  8374				   alphadata8
   1770  8374		       0c		      .byte.b	(<font + $0c)
   1771  8375		       02		      .byte.b	(<font + $02)
   1772  8376				   skipalphadata8
   1773  8376		       a9 74		      lda	#<alphadata8
   1774  8378		       85 42		      sta	temp1
   1775  837a
   1776  837a		       a9 83		      lda	#>alphadata8
   1777  837c		       85 43		      sta	temp2
   1778  837e
   1779  837e		       a9 1e		      lda	#30	; width in two's complement
   1780  8380		       09 20		      ora	#32	; palette left shifted 5 bits
   1781  8382		       85 44		      sta	temp3
   1782  8384		       a9 0a		      lda	#10
   1783  8386		       85 45		      sta	temp4
   1784  8388
   1785  8388		       a9 05		      lda	#5
   1786  838a
   1787  838a		       85 46		      sta	temp5
   1788  838c
   1789  838c		       20 c6 f4 	      jsr	plotcharacters
   1790  838f				   .L0144		;;  plotchars 'c3' 1 10 6
   1791  838f
   1792  838f		       4c 94 83 	      JMP	skipalphadata9
   1793  8392				   alphadata9
   1794  8392		       0c		      .byte.b	(<font + $0c)
   1795  8393		       03		      .byte.b	(<font + $03)
   1796  8394				   skipalphadata9
   1797  8394		       a9 92		      lda	#<alphadata9
   1798  8396		       85 42		      sta	temp1
   1799  8398
   1800  8398		       a9 83		      lda	#>alphadata9
   1801  839a		       85 43		      sta	temp2
   1802  839c
   1803  839c		       a9 1e		      lda	#30	; width in two's complement
   1804  839e		       09 20		      ora	#32	; palette left shifted 5 bits
   1805  83a0		       85 44		      sta	temp3
   1806  83a2		       a9 0a		      lda	#10
   1807  83a4		       85 45		      sta	temp4
   1808  83a6
   1809  83a6		       a9 06		      lda	#6
   1810  83a8
   1811  83a8		       85 46		      sta	temp5
   1812  83aa
   1813  83aa		       20 c6 f4 	      jsr	plotcharacters
   1814  83ad				   .
   1815  83ad							;; 
   1816  83ad
   1817  83ad				   .
   1818  83ad							;; 
   1819  83ad
   1820  83ad				   .
   1821  83ad							;; 
   1822  83ad
   1823  83ad				   .
   1824  83ad							;; 
   1825  83ad
   1826  83ad				   .
   1827  83ad							;; 
   1828  83ad
   1829  83ad				   .L0145		;;  plotchars 'reset^to^re-sync^all^channels' 1 10 7
   1830  83ad
   1831  83ad		       4c cd 83 	      JMP	skipalphadata10
   1832  83b0				   alphadata10
   1833  83b0		       1b		      .byte.b	(<font + $1b)
   1834  83b1		       0e		      .byte.b	(<font + $0e)
   1835  83b2		       1c		      .byte.b	(<font + $1c)
   1836  83b3		       0e		      .byte.b	(<font + $0e)
   1837  83b4		       1d		      .byte.b	(<font + $1d)
   1838  83b5		       34		      .byte.b	(<font + $34)
   1839  83b6		       1d		      .byte.b	(<font + $1d)
   1840  83b7		       18		      .byte.b	(<font + $18)
   1841  83b8		       34		      .byte.b	(<font + $34)
   1842  83b9		       1b		      .byte.b	(<font + $1b)
   1843  83ba		       0e		      .byte.b	(<font + $0e)
   1844  83bb		       2b		      .byte.b	(<font + $2b)
   1845  83bc		       1c		      .byte.b	(<font + $1c)
   1846  83bd		       22		      .byte.b	(<font + $22)
   1847  83be		       17		      .byte.b	(<font + $17)
   1848  83bf		       0c		      .byte.b	(<font + $0c)
   1849  83c0		       34		      .byte.b	(<font + $34)
   1850  83c1		       0a		      .byte.b	(<font + $0a)
   1851  83c2		       15		      .byte.b	(<font + $15)
   1852  83c3		       15		      .byte.b	(<font + $15)
   1853  83c4		       34		      .byte.b	(<font + $34)
   1854  83c5		       0c		      .byte.b	(<font + $0c)
   1855  83c6		       11		      .byte.b	(<font + $11)
   1856  83c7		       0a		      .byte.b	(<font + $0a)
   1857  83c8		       17		      .byte.b	(<font + $17)
   1858  83c9		       17		      .byte.b	(<font + $17)
   1859  83ca		       0e		      .byte.b	(<font + $0e)
   1860  83cb		       15		      .byte.b	(<font + $15)
   1861  83cc		       1c		      .byte.b	(<font + $1c)
   1862  83cd				   skipalphadata10
   1863  83cd		       a9 b0		      lda	#<alphadata10
   1864  83cf		       85 42		      sta	temp1
   1865  83d1
   1866  83d1		       a9 83		      lda	#>alphadata10
   1867  83d3		       85 43		      sta	temp2
   1868  83d5
   1869  83d5		       a9 03		      lda	#3	; width in two's complement
   1870  83d7		       09 20		      ora	#32	; palette left shifted 5 bits
   1871  83d9		       85 44		      sta	temp3
   1872  83db		       a9 0a		      lda	#10
   1873  83dd		       85 45		      sta	temp4
   1874  83df
   1875  83df		       a9 07		      lda	#7
   1876  83e1
   1877  83e1		       85 46		      sta	temp5
   1878  83e3
   1879  83e3		       20 c6 f4 	      jsr	plotcharacters
   1880  83e6				   .L0146		;;  plotchars 'joystick^to^select' 1 10 8
   1881  83e6
   1882  83e6		       4c fb 83 	      JMP	skipalphadata11
   1883  83e9				   alphadata11
   1884  83e9		       13		      .byte.b	(<font + $13)
   1885  83ea		       18		      .byte.b	(<font + $18)
   1886  83eb		       22		      .byte.b	(<font + $22)
   1887  83ec		       1c		      .byte.b	(<font + $1c)
   1888  83ed		       1d		      .byte.b	(<font + $1d)
   1889  83ee		       12		      .byte.b	(<font + $12)
   1890  83ef		       0c		      .byte.b	(<font + $0c)
   1891  83f0		       14		      .byte.b	(<font + $14)
   1892  83f1		       34		      .byte.b	(<font + $34)
   1893  83f2		       1d		      .byte.b	(<font + $1d)
   1894  83f3		       18		      .byte.b	(<font + $18)
   1895  83f4		       34		      .byte.b	(<font + $34)
   1896  83f5		       1c		      .byte.b	(<font + $1c)
   1897  83f6		       0e		      .byte.b	(<font + $0e)
   1898  83f7		       15		      .byte.b	(<font + $15)
   1899  83f8		       0e		      .byte.b	(<font + $0e)
   1900  83f9		       0c		      .byte.b	(<font + $0c)
   1901  83fa		       1d		      .byte.b	(<font + $1d)
   1902  83fb				   skipalphadata11
   1903  83fb		       a9 e9		      lda	#<alphadata11
   1904  83fd		       85 42		      sta	temp1
   1905  83ff
   1906  83ff		       a9 83		      lda	#>alphadata11
   1907  8401		       85 43		      sta	temp2
   1908  8403
   1909  8403		       a9 0e		      lda	#14	; width in two's complement
   1910  8405		       09 20		      ora	#32	; palette left shifted 5 bits
   1911  8407		       85 44		      sta	temp3
   1912  8409		       a9 0a		      lda	#10
   1913  840b		       85 45		      sta	temp4
   1914  840d
   1915  840d		       a9 08		      lda	#8
   1916  840f
   1917  840f		       85 46		      sta	temp5
   1918  8411
   1919  8411		       20 c6 f4 	      jsr	plotcharacters
   1920  8414				   .L0147		;;  plotchars 'fire^1^to^increase' 1 10 9
   1921  8414
   1922  8414		       4c 29 84 	      JMP	skipalphadata12
   1923  8417				   alphadata12
   1924  8417		       0f		      .byte.b	(<font + $0f)
   1925  8418		       12		      .byte.b	(<font + $12)
   1926  8419		       1b		      .byte.b	(<font + $1b)
   1927  841a		       0e		      .byte.b	(<font + $0e)
   1928  841b		       34		      .byte.b	(<font + $34)
   1929  841c		       01		      .byte.b	(<font + $01)
   1930  841d		       34		      .byte.b	(<font + $34)
   1931  841e		       1d		      .byte.b	(<font + $1d)
   1932  841f		       18		      .byte.b	(<font + $18)
   1933  8420		       34		      .byte.b	(<font + $34)
   1934  8421		       12		      .byte.b	(<font + $12)
   1935  8422		       17		      .byte.b	(<font + $17)
   1936  8423		       0c		      .byte.b	(<font + $0c)
   1937  8424		       1b		      .byte.b	(<font + $1b)
   1938  8425		       0e		      .byte.b	(<font + $0e)
   1939  8426		       0a		      .byte.b	(<font + $0a)
   1940  8427		       1c		      .byte.b	(<font + $1c)
   1941  8428		       0e		      .byte.b	(<font + $0e)
   1942  8429				   skipalphadata12
   1943  8429		       a9 17		      lda	#<alphadata12
   1944  842b		       85 42		      sta	temp1
   1945  842d
   1946  842d		       a9 84		      lda	#>alphadata12
   1947  842f		       85 43		      sta	temp2
   1948  8431
   1949  8431		       a9 0e		      lda	#14	; width in two's complement
   1950  8433		       09 20		      ora	#32	; palette left shifted 5 bits
   1951  8435		       85 44		      sta	temp3
   1952  8437		       a9 0a		      lda	#10
   1953  8439		       85 45		      sta	temp4
   1954  843b
   1955  843b		       a9 09		      lda	#9
   1956  843d
   1957  843d		       85 46		      sta	temp5
   1958  843f
   1959  843f		       20 c6 f4 	      jsr	plotcharacters
   1960  8442				   .L0148		;;  plotchars 'fire^2^to^decrease' 1 10 10
   1961  8442
   1962  8442		       4c 57 84 	      JMP	skipalphadata13
   1963  8445				   alphadata13
   1964  8445		       0f		      .byte.b	(<font + $0f)
   1965  8446		       12		      .byte.b	(<font + $12)
   1966  8447		       1b		      .byte.b	(<font + $1b)
   1967  8448		       0e		      .byte.b	(<font + $0e)
   1968  8449		       34		      .byte.b	(<font + $34)
   1969  844a		       02		      .byte.b	(<font + $02)
   1970  844b		       34		      .byte.b	(<font + $34)
   1971  844c		       1d		      .byte.b	(<font + $1d)
   1972  844d		       18		      .byte.b	(<font + $18)
   1973  844e		       34		      .byte.b	(<font + $34)
   1974  844f		       0d		      .byte.b	(<font + $0d)
   1975  8450		       0e		      .byte.b	(<font + $0e)
   1976  8451		       0c		      .byte.b	(<font + $0c)
   1977  8452		       1b		      .byte.b	(<font + $1b)
   1978  8453		       0e		      .byte.b	(<font + $0e)
   1979  8454		       0a		      .byte.b	(<font + $0a)
   1980  8455		       1c		      .byte.b	(<font + $1c)
   1981  8456		       0e		      .byte.b	(<font + $0e)
   1982  8457				   skipalphadata13
   1983  8457		       a9 45		      lda	#<alphadata13
   1984  8459		       85 42		      sta	temp1
   1985  845b
   1986  845b		       a9 84		      lda	#>alphadata13
   1987  845d		       85 43		      sta	temp2
   1988  845f
   1989  845f		       a9 0e		      lda	#14	; width in two's complement
   1990  8461		       09 20		      ora	#32	; palette left shifted 5 bits
   1991  8463		       85 44		      sta	temp3
   1992  8465		       a9 0a		      lda	#10
   1993  8467		       85 45		      sta	temp4
   1994  8469
   1995  8469		       a9 0a		      lda	#10
   1996  846b
   1997  846b		       85 46		      sta	temp5
   1998  846d
   1999  846d		       20 c6 f4 	      jsr	plotcharacters
   2000  8470				   .
   2001  8470							;; 
   2002  8470
   2003  8470				   .L0149		;;  tempX  =  20
   2004  8470
   2005  8470		       a9 14		      LDA	#20
   2006  8472		       8d 49 01 	      STA	tempX
   2007  8475				   .L0150		;;  tempY  =  3
   2008  8475
   2009  8475		       a9 03		      LDA	#3
   2010  8477		       8d 4a 01 	      STA	tempY
   2011  847a				   .L0151		;;  for i  =  0 to 3
   2012  847a
   2013  847a		       a9 00		      LDA	#0
   2014  847c		       85 ee		      STA	i
   2015  847e				   .L0151fori
   2016  847e				   .L0152		;;  tFrequency  =  cFrequency[i]
   2017  847e
   2018  847e		       a6 ee		      LDX	i
   2019  8480		       bd 04 22 	      LDA	cFrequency,x
   2020  8483		       8d 42 01 	      STA	tFrequency
   2021  8486				   .L0153		;;  tWaveForm	=  cWaveForm[i]
   2022  8486
   2023  8486		       a6 ee		      LDX	i
   2024  8488		       bd 08 22 	      LDA	cWaveForm,x
   2025  848b		       8d 43 01 	      STA	tWaveForm
   2026  848e				   .L0154		;;  tVolume  =  cVolume[i]
   2027  848e
   2028  848e		       a6 ee		      LDX	i
   2029  8490		       bd 0c 22 	      LDA	cVolume,x
   2030  8493		       8d 44 01 	      STA	tVolume
   2031  8496				   .L0155		;;  tDuration	=  cDuration[i]
   2032  8496
   2033  8496		       a6 ee		      LDX	i
   2034  8498		       bd 10 22 	      LDA	cDuration,x
   2035  849b		       8d 46 01 	      STA	tDuration
   2036  849e				   .L0156		;;  tSilence  =  cSilence[i]
   2037  849e
   2038  849e		       a6 ee		      LDX	i
   2039  84a0		       bd 14 22 	      LDA	cSilence,x
   2040  84a3		       8d 52 01 	      STA	tSilence
   2041  84a6				   .L0157		;;  tType  =  cType[i]
   2042  84a6
   2043  84a6		       a6 ee		      LDX	i
   2044  84a8		       bd 18 22 	      LDA	cType,x
   2045  84ab		       8d 45 01 	      STA	tType
   2046  84ae				   .L0158		;;  tColor  =	4
   2047  84ae
   2048  84ae		       a9 04		      LDA	#4
   2049  84b0		       8d 47 01 	      STA	tColor
   2050  84b3				   .L0159		;;  if tSelected  =   ( i + 0 + i * 6 )  - i then tColor  =  5
   2051  84b3
   2052  84b3							; complex condition detected
   2053  84b3							; complex statement detected
   2054  84b3		       a5 ee		      LDA	i
   2055  84b5		       18		      CLC
   2056  84b6		       69 00		      ADC	#0
   2057  84b8		       48		      PHA
   2058  84b9		       a5 ee		      LDA	i
   2059  84bb		       0a		      asl
   2060  84bc		       18		      clc
   2061  84bd		       65 ee		      adc	i
   2062  84bf		       0a		      asl
   2063  84c0		       ba		      TSX
   2064  84c1		       e8		      INX
   2065  84c2		       18		      CLC
   2066  84c3		       7d 00 01 	      ADC	$100,x
   2067  84c6		       9a		      TXS
   2068  84c7		       38		      SEC
   2069  84c8		       e5 ee		      SBC	i
   2070  84ca		       48		      PHA
   2071  84cb		       ba		      TSX
   2072  84cc		       68		      PLA
   2073  84cd		       ad 48 01 	      LDA	tSelected
   2074  84d0		       dd 01 01 	      CMP	$101,x
   2075  84d3		       d0 05		      BNE	.skipL0159
   2076  84d5				   .condpart19
   2077  84d5		       a9 05		      LDA	#5
   2078  84d7		       8d 47 01 	      STA	tColor
   2079  84da				   .skipL0159
   2080  84da				   .L0160		;;  plotvalue font tColor tFrequency 2 tempX tempY
   2081  84da
   2082  84da		       a9 00		      lda	#<font
   2083  84dc		       85 42		      sta	temp1
   2084  84de
   2085  84de		       a9 a0		      lda	#>font
   2086  84e0		       85 43		      sta	temp2
   2087  84e2
   2088  84e2		       ad 06 21 	      lda	charactermode
   2089  84e5		       85 4a		      sta	temp9
   2090  84e7		       a9 60		      lda	#(font_mode | %01100000)
   2091  84e9		       8d 06 21 	      sta	charactermode
   2092  84ec		       a9 1e		      lda	#30	; width in two's complement
   2093  84ee		       85 44		      sta	temp3
   2094  84f0		       ad 47 01 	      lda	tColor
   2095  84f3		       0a		      asl
   2096  84f4		       0a		      asl
   2097  84f5		       0a		      asl
   2098  84f6		       0a		      asl
   2099  84f7		       0a		      asl
   2100  84f8		       05 44		      ora	temp3
   2101  84fa		       85 44		      sta	temp3
   2102  84fc		       ad 49 01 	      lda	tempX
   2103  84ff		       85 45		      sta	temp4
   2104  8501
   2105  8501		       ad 4a 01 	      lda	tempY
   2106  8504		       85 46		      sta	temp5
   2107  8506
   2108  8506		       a9 02		      lda	#2
   2109  8508		       85 47		      sta	temp6
   2110  850a
   2111  850a		       a9 42		      lda	#<tFrequency
   2112  850c		       85 48		      sta	temp7
   2113  850e
   2114  850e		       a9 01		      lda	#>tFrequency
   2115  8510		       85 49		      sta	temp8
   2116  8512
   2117  8512		       20 22 f5 	      jsr	plotvalue
   2118  8512		       00 01	   USED_PLOTVALUE =	1
   2119  8515		       a5 4a		      lda	temp9
   2120  8517		       8d 06 21 	      sta	charactermode
   2121  851a				   .L0161		;;  tempX  =  tempX  +  20
   2122  851a
   2123  851a		       ad 49 01 	      LDA	tempX
   2124  851d		       18		      CLC
   2125  851e		       69 14		      ADC	#20
   2126  8520		       8d 49 01 	      STA	tempX
   2127  8523				   .L0162		;;  tColor  =	4
   2128  8523
   2129  8523		       a9 04		      LDA	#4
   2130  8525		       8d 47 01 	      STA	tColor
   2131  8528				   .L0163		;;  if tSelected  =   ( i + 1 + i * 6 )  - i then tColor  =  5
   2132  8528
   2133  8528							; complex condition detected
   2134  8528							; complex statement detected
   2135  8528		       a5 ee		      LDA	i
   2136  852a		       18		      CLC
   2137  852b		       69 01		      ADC	#1
   2138  852d		       48		      PHA
   2139  852e		       a5 ee		      LDA	i
   2140  8530		       0a		      asl
   2141  8531		       18		      clc
   2142  8532		       65 ee		      adc	i
   2143  8534		       0a		      asl
   2144  8535		       ba		      TSX
   2145  8536		       e8		      INX
   2146  8537		       18		      CLC
   2147  8538		       7d 00 01 	      ADC	$100,x
   2148  853b		       9a		      TXS
   2149  853c		       38		      SEC
   2150  853d		       e5 ee		      SBC	i
   2151  853f		       48		      PHA
   2152  8540		       ba		      TSX
   2153  8541		       68		      PLA
   2154  8542		       ad 48 01 	      LDA	tSelected
   2155  8545		       dd 01 01 	      CMP	$101,x
   2156  8548		       d0 05		      BNE	.skipL0163
   2157  854a				   .condpart20
   2158  854a		       a9 05		      LDA	#5
   2159  854c		       8d 47 01 	      STA	tColor
   2160  854f				   .skipL0163
   2161  854f				   .L0164		;;  plotvalue font tColor tWaveForm 2 tempX tempY
   2162  854f
   2163  854f		       a9 00		      lda	#<font
   2164  8551		       85 42		      sta	temp1
   2165  8553
   2166  8553		       a9 a0		      lda	#>font
   2167  8555		       85 43		      sta	temp2
   2168  8557
   2169  8557		       ad 06 21 	      lda	charactermode
   2170  855a		       85 4a		      sta	temp9
   2171  855c		       a9 60		      lda	#(font_mode | %01100000)
   2172  855e		       8d 06 21 	      sta	charactermode
   2173  8561		       a9 1e		      lda	#30	; width in two's complement
   2174  8563		       85 44		      sta	temp3
   2175  8565		       ad 47 01 	      lda	tColor
   2176  8568		       0a		      asl
   2177  8569		       0a		      asl
   2178  856a		       0a		      asl
   2179  856b		       0a		      asl
   2180  856c		       0a		      asl
   2181  856d		       05 44		      ora	temp3
   2182  856f		       85 44		      sta	temp3
   2183  8571		       ad 49 01 	      lda	tempX
   2184  8574		       85 45		      sta	temp4
   2185  8576
   2186  8576		       ad 4a 01 	      lda	tempY
   2187  8579		       85 46		      sta	temp5
   2188  857b
   2189  857b		       a9 02		      lda	#2
   2190  857d		       85 47		      sta	temp6
   2191  857f
   2192  857f		       a9 43		      lda	#<tWaveForm
   2193  8581		       85 48		      sta	temp7
   2194  8583
   2195  8583		       a9 01		      lda	#>tWaveForm
   2196  8585		       85 49		      sta	temp8
   2197  8587
   2198  8587		       20 22 f5 	      jsr	plotvalue
   2199  8587		       00 01	   USED_PLOTVALUE =	1
   2200  858a		       a5 4a		      lda	temp9
   2201  858c		       8d 06 21 	      sta	charactermode
   2202  858f				   .L0165		;;  tempX  =  tempX  +  20
   2203  858f
   2204  858f		       ad 49 01 	      LDA	tempX
   2205  8592		       18		      CLC
   2206  8593		       69 14		      ADC	#20
   2207  8595		       8d 49 01 	      STA	tempX
   2208  8598				   .L0166		;;  tColor  =	4
   2209  8598
   2210  8598		       a9 04		      LDA	#4
   2211  859a		       8d 47 01 	      STA	tColor
   2212  859d				   .L0167		;;  if tSelected  =   ( i + 2 + i * 6 )  - i then tColor  =  5
   2213  859d
   2214  859d							; complex condition detected
   2215  859d							; complex statement detected
   2216  859d		       a5 ee		      LDA	i
   2217  859f		       18		      CLC
   2218  85a0		       69 02		      ADC	#2
   2219  85a2		       48		      PHA
   2220  85a3		       a5 ee		      LDA	i
   2221  85a5		       0a		      asl
   2222  85a6		       18		      clc
   2223  85a7		       65 ee		      adc	i
   2224  85a9		       0a		      asl
   2225  85aa		       ba		      TSX
   2226  85ab		       e8		      INX
   2227  85ac		       18		      CLC
   2228  85ad		       7d 00 01 	      ADC	$100,x
   2229  85b0		       9a		      TXS
   2230  85b1		       38		      SEC
   2231  85b2		       e5 ee		      SBC	i
   2232  85b4		       48		      PHA
   2233  85b5		       ba		      TSX
   2234  85b6		       68		      PLA
   2235  85b7		       ad 48 01 	      LDA	tSelected
   2236  85ba		       dd 01 01 	      CMP	$101,x
   2237  85bd		       d0 05		      BNE	.skipL0167
   2238  85bf				   .condpart21
   2239  85bf		       a9 05		      LDA	#5
   2240  85c1		       8d 47 01 	      STA	tColor
   2241  85c4				   .skipL0167
   2242  85c4				   .L0168		;;  plotvalue font tColor tVolume 2 tempX tempY
   2243  85c4
   2244  85c4		       a9 00		      lda	#<font
   2245  85c6		       85 42		      sta	temp1
   2246  85c8
   2247  85c8		       a9 a0		      lda	#>font
   2248  85ca		       85 43		      sta	temp2
   2249  85cc
   2250  85cc		       ad 06 21 	      lda	charactermode
   2251  85cf		       85 4a		      sta	temp9
   2252  85d1		       a9 60		      lda	#(font_mode | %01100000)
   2253  85d3		       8d 06 21 	      sta	charactermode
   2254  85d6		       a9 1e		      lda	#30	; width in two's complement
   2255  85d8		       85 44		      sta	temp3
   2256  85da		       ad 47 01 	      lda	tColor
   2257  85dd		       0a		      asl
   2258  85de		       0a		      asl
   2259  85df		       0a		      asl
   2260  85e0		       0a		      asl
   2261  85e1		       0a		      asl
   2262  85e2		       05 44		      ora	temp3
   2263  85e4		       85 44		      sta	temp3
   2264  85e6		       ad 49 01 	      lda	tempX
   2265  85e9		       85 45		      sta	temp4
   2266  85eb
   2267  85eb		       ad 4a 01 	      lda	tempY
   2268  85ee		       85 46		      sta	temp5
   2269  85f0
   2270  85f0		       a9 02		      lda	#2
   2271  85f2		       85 47		      sta	temp6
   2272  85f4
   2273  85f4		       a9 44		      lda	#<tVolume
   2274  85f6		       85 48		      sta	temp7
   2275  85f8
   2276  85f8		       a9 01		      lda	#>tVolume
   2277  85fa		       85 49		      sta	temp8
   2278  85fc
   2279  85fc		       20 22 f5 	      jsr	plotvalue
   2280  85fc		       00 01	   USED_PLOTVALUE =	1
   2281  85ff		       a5 4a		      lda	temp9
   2282  8601		       8d 06 21 	      sta	charactermode
   2283  8604				   .L0169		;;  tempX  =  tempX  +  20
   2284  8604
   2285  8604		       ad 49 01 	      LDA	tempX
   2286  8607		       18		      CLC
   2287  8608		       69 14		      ADC	#20
   2288  860a		       8d 49 01 	      STA	tempX
   2289  860d				   .L0170		;;  tColor  =	4
   2290  860d
   2291  860d		       a9 04		      LDA	#4
   2292  860f		       8d 47 01 	      STA	tColor
   2293  8612				   .L0171		;;  if tSelected  =   ( i + 3 + i * 6 )  - i then tColor  =  5
   2294  8612
   2295  8612							; complex condition detected
   2296  8612							; complex statement detected
   2297  8612		       a5 ee		      LDA	i
   2298  8614		       18		      CLC
   2299  8615		       69 03		      ADC	#3
   2300  8617		       48		      PHA
   2301  8618		       a5 ee		      LDA	i
   2302  861a		       0a		      asl
   2303  861b		       18		      clc
   2304  861c		       65 ee		      adc	i
   2305  861e		       0a		      asl
   2306  861f		       ba		      TSX
   2307  8620		       e8		      INX
   2308  8621		       18		      CLC
   2309  8622		       7d 00 01 	      ADC	$100,x
   2310  8625		       9a		      TXS
   2311  8626		       38		      SEC
   2312  8627		       e5 ee		      SBC	i
   2313  8629		       48		      PHA
   2314  862a		       ba		      TSX
   2315  862b		       68		      PLA
   2316  862c		       ad 48 01 	      LDA	tSelected
   2317  862f		       dd 01 01 	      CMP	$101,x
   2318  8632		       d0 05		      BNE	.skipL0171
   2319  8634				   .condpart22
   2320  8634		       a9 05		      LDA	#5
   2321  8636		       8d 47 01 	      STA	tColor
   2322  8639				   .skipL0171
   2323  8639				   .L0172		;;  plotvalue font tColor tDuration 2 tempX tempY
   2324  8639
   2325  8639		       a9 00		      lda	#<font
   2326  863b		       85 42		      sta	temp1
   2327  863d
   2328  863d		       a9 a0		      lda	#>font
   2329  863f		       85 43		      sta	temp2
   2330  8641
   2331  8641		       ad 06 21 	      lda	charactermode
   2332  8644		       85 4a		      sta	temp9
   2333  8646		       a9 60		      lda	#(font_mode | %01100000)
   2334  8648		       8d 06 21 	      sta	charactermode
   2335  864b		       a9 1e		      lda	#30	; width in two's complement
   2336  864d		       85 44		      sta	temp3
   2337  864f		       ad 47 01 	      lda	tColor
   2338  8652		       0a		      asl
   2339  8653		       0a		      asl
   2340  8654		       0a		      asl
   2341  8655		       0a		      asl
   2342  8656		       0a		      asl
   2343  8657		       05 44		      ora	temp3
   2344  8659		       85 44		      sta	temp3
   2345  865b		       ad 49 01 	      lda	tempX
   2346  865e		       85 45		      sta	temp4
   2347  8660
   2348  8660		       ad 4a 01 	      lda	tempY
   2349  8663		       85 46		      sta	temp5
   2350  8665
   2351  8665		       a9 02		      lda	#2
   2352  8667		       85 47		      sta	temp6
   2353  8669
   2354  8669		       a9 46		      lda	#<tDuration
   2355  866b		       85 48		      sta	temp7
   2356  866d
   2357  866d		       a9 01		      lda	#>tDuration
   2358  866f		       85 49		      sta	temp8
   2359  8671
   2360  8671		       20 22 f5 	      jsr	plotvalue
   2361  8671		       00 01	   USED_PLOTVALUE =	1
   2362  8674		       a5 4a		      lda	temp9
   2363  8676		       8d 06 21 	      sta	charactermode
   2364  8679				   .L0173		;;  tempX  =  tempX  +  20
   2365  8679
   2366  8679		       ad 49 01 	      LDA	tempX
   2367  867c		       18		      CLC
   2368  867d		       69 14		      ADC	#20
   2369  867f		       8d 49 01 	      STA	tempX
   2370  8682				   .L0174		;;  tColor  =	4
   2371  8682
   2372  8682		       a9 04		      LDA	#4
   2373  8684		       8d 47 01 	      STA	tColor
   2374  8687				   .L0175		;;  if tSelected  =   ( i + 4 + i * 6 )  - i then tColor  =  5
   2375  8687
   2376  8687							; complex condition detected
   2377  8687							; complex statement detected
   2378  8687		       a5 ee		      LDA	i
   2379  8689		       18		      CLC
   2380  868a		       69 04		      ADC	#4
   2381  868c		       48		      PHA
   2382  868d		       a5 ee		      LDA	i
   2383  868f		       0a		      asl
   2384  8690		       18		      clc
   2385  8691		       65 ee		      adc	i
   2386  8693		       0a		      asl
   2387  8694		       ba		      TSX
   2388  8695		       e8		      INX
   2389  8696		       18		      CLC
   2390  8697		       7d 00 01 	      ADC	$100,x
   2391  869a		       9a		      TXS
   2392  869b		       38		      SEC
   2393  869c		       e5 ee		      SBC	i
   2394  869e		       48		      PHA
   2395  869f		       ba		      TSX
   2396  86a0		       68		      PLA
   2397  86a1		       ad 48 01 	      LDA	tSelected
   2398  86a4		       dd 01 01 	      CMP	$101,x
   2399  86a7		       d0 05		      BNE	.skipL0175
   2400  86a9				   .condpart23
   2401  86a9		       a9 05		      LDA	#5
   2402  86ab		       8d 47 01 	      STA	tColor
   2403  86ae				   .skipL0175
   2404  86ae				   .L0176		;;  plotvalue font tColor tSilence 2 tempX tempY
   2405  86ae
   2406  86ae		       a9 00		      lda	#<font
   2407  86b0		       85 42		      sta	temp1
   2408  86b2
   2409  86b2		       a9 a0		      lda	#>font
   2410  86b4		       85 43		      sta	temp2
   2411  86b6
   2412  86b6		       ad 06 21 	      lda	charactermode
   2413  86b9		       85 4a		      sta	temp9
   2414  86bb		       a9 60		      lda	#(font_mode | %01100000)
   2415  86bd		       8d 06 21 	      sta	charactermode
   2416  86c0		       a9 1e		      lda	#30	; width in two's complement
   2417  86c2		       85 44		      sta	temp3
   2418  86c4		       ad 47 01 	      lda	tColor
   2419  86c7		       0a		      asl
   2420  86c8		       0a		      asl
   2421  86c9		       0a		      asl
   2422  86ca		       0a		      asl
   2423  86cb		       0a		      asl
   2424  86cc		       05 44		      ora	temp3
   2425  86ce		       85 44		      sta	temp3
   2426  86d0		       ad 49 01 	      lda	tempX
   2427  86d3		       85 45		      sta	temp4
   2428  86d5
   2429  86d5		       ad 4a 01 	      lda	tempY
   2430  86d8		       85 46		      sta	temp5
   2431  86da
   2432  86da		       a9 02		      lda	#2
   2433  86dc		       85 47		      sta	temp6
   2434  86de
   2435  86de		       a9 52		      lda	#<tSilence
   2436  86e0		       85 48		      sta	temp7
   2437  86e2
   2438  86e2		       a9 01		      lda	#>tSilence
   2439  86e4		       85 49		      sta	temp8
   2440  86e6
   2441  86e6		       20 22 f5 	      jsr	plotvalue
   2442  86e6		       00 01	   USED_PLOTVALUE =	1
   2443  86e9		       a5 4a		      lda	temp9
   2444  86eb		       8d 06 21 	      sta	charactermode
   2445  86ee				   .L0177		;;  tempX  =  tempX  +  20
   2446  86ee
   2447  86ee		       ad 49 01 	      LDA	tempX
   2448  86f1		       18		      CLC
   2449  86f2		       69 14		      ADC	#20
   2450  86f4		       8d 49 01 	      STA	tempX
   2451  86f7				   .L0178		;;  tColor  =	4
   2452  86f7
   2453  86f7		       a9 04		      LDA	#4
   2454  86f9		       8d 47 01 	      STA	tColor
   2455  86fc				   .L0179		;;  if tSelected  =   ( i + 5 + i * 6 )  - i then tColor  =  5
   2456  86fc
   2457  86fc							; complex condition detected
   2458  86fc							; complex statement detected
   2459  86fc		       a5 ee		      LDA	i
   2460  86fe		       18		      CLC
   2461  86ff		       69 05		      ADC	#5
   2462  8701		       48		      PHA
   2463  8702		       a5 ee		      LDA	i
   2464  8704		       0a		      asl
   2465  8705		       18		      clc
   2466  8706		       65 ee		      adc	i
   2467  8708		       0a		      asl
   2468  8709		       ba		      TSX
   2469  870a		       e8		      INX
   2470  870b		       18		      CLC
   2471  870c		       7d 00 01 	      ADC	$100,x
   2472  870f		       9a		      TXS
   2473  8710		       38		      SEC
   2474  8711		       e5 ee		      SBC	i
   2475  8713		       48		      PHA
   2476  8714		       ba		      TSX
   2477  8715		       68		      PLA
   2478  8716		       ad 48 01 	      LDA	tSelected
   2479  8719		       dd 01 01 	      CMP	$101,x
   2480  871c		       d0 05		      BNE	.skipL0179
   2481  871e				   .condpart24
   2482  871e		       a9 05		      LDA	#5
   2483  8720		       8d 47 01 	      STA	tColor
   2484  8723				   .skipL0179
   2485  8723				   .L0180		;;  if tType  =  1 then plotchars 'c' tColor tempX tempY
   2486  8723
   2487  8723		       ad 45 01 	      LDA	tType
   2488  8726		       c9 01		      CMP	#1
   2489  8728		       d0 29		      BNE	.skipL0180
   2490  872a				   .condpart25
   2491  872a		       4c 2e 87 	      JMP	skipalphadata14
   2492  872d				   alphadata14
   2493  872d		       0c		      .byte.b	(<font + $0c)
   2494  872e				   skipalphadata14
   2495  872e		       a9 2d		      lda	#<alphadata14
   2496  8730		       85 42		      sta	temp1
   2497  8732
   2498  8732		       a9 87		      lda	#>alphadata14
   2499  8734		       85 43		      sta	temp2
   2500  8736
   2501  8736		       a9 1f		      lda	#31	; width in two's complement
   2502  8738		       85 44		      sta	temp3
   2503  873a		       ad 47 01 	      lda	tColor
   2504  873d		       0a		      asl
   2505  873e		       0a		      asl
   2506  873f		       0a		      asl
   2507  8740		       0a		      asl
   2508  8741		       0a		      asl
   2509  8742		       05 44		      ora	temp3
   2510  8744		       85 44		      sta	temp3
   2511  8746		       ad 49 01 	      lda	tempX
   2512  8749		       85 45		      sta	temp4
   2513  874b
   2514  874b		       ad 4a 01 	      lda	tempY
   2515  874e
   2516  874e		       85 46		      sta	temp5
   2517  8750
   2518  8750		       20 c6 f4 	      jsr	plotcharacters
   2519  8753				   .skipL0180
   2520  8753				   .L0181		;;  if tType  =  2 then plotchars 'a' tColor tempX tempY
   2521  8753
   2522  8753		       ad 45 01 	      LDA	tType
   2523  8756		       c9 02		      CMP	#2
   2524  8758		       d0 29		      BNE	.skipL0181
   2525  875a				   .condpart26
   2526  875a		       4c 5e 87 	      JMP	skipalphadata15
   2527  875d				   alphadata15
   2528  875d		       0a		      .byte.b	(<font + $0a)
   2529  875e				   skipalphadata15
   2530  875e		       a9 5d		      lda	#<alphadata15
   2531  8760		       85 42		      sta	temp1
   2532  8762
   2533  8762		       a9 87		      lda	#>alphadata15
   2534  8764		       85 43		      sta	temp2
   2535  8766
   2536  8766		       a9 1f		      lda	#31	; width in two's complement
   2537  8768		       85 44		      sta	temp3
   2538  876a		       ad 47 01 	      lda	tColor
   2539  876d		       0a		      asl
   2540  876e		       0a		      asl
   2541  876f		       0a		      asl
   2542  8770		       0a		      asl
   2543  8771		       0a		      asl
   2544  8772		       05 44		      ora	temp3
   2545  8774		       85 44		      sta	temp3
   2546  8776		       ad 49 01 	      lda	tempX
   2547  8779		       85 45		      sta	temp4
   2548  877b
   2549  877b		       ad 4a 01 	      lda	tempY
   2550  877e
   2551  877e		       85 46		      sta	temp5
   2552  8780
   2553  8780		       20 c6 f4 	      jsr	plotcharacters
   2554  8783				   .skipL0181
   2555  8783				   .L0182		;;  if tType  =  3 then plotchars 'd' tColor tempX tempY
   2556  8783
   2557  8783		       ad 45 01 	      LDA	tType
   2558  8786		       c9 03		      CMP	#3
   2559  8788		       d0 29		      BNE	.skipL0182
   2560  878a				   .condpart27
   2561  878a		       4c 8e 87 	      JMP	skipalphadata16
   2562  878d				   alphadata16
   2563  878d		       0d		      .byte.b	(<font + $0d)
   2564  878e				   skipalphadata16
   2565  878e		       a9 8d		      lda	#<alphadata16
   2566  8790		       85 42		      sta	temp1
   2567  8792
   2568  8792		       a9 87		      lda	#>alphadata16
   2569  8794		       85 43		      sta	temp2
   2570  8796
   2571  8796		       a9 1f		      lda	#31	; width in two's complement
   2572  8798		       85 44		      sta	temp3
   2573  879a		       ad 47 01 	      lda	tColor
   2574  879d		       0a		      asl
   2575  879e		       0a		      asl
   2576  879f		       0a		      asl
   2577  87a0		       0a		      asl
   2578  87a1		       0a		      asl
   2579  87a2		       05 44		      ora	temp3
   2580  87a4		       85 44		      sta	temp3
   2581  87a6		       ad 49 01 	      lda	tempX
   2582  87a9		       85 45		      sta	temp4
   2583  87ab
   2584  87ab		       ad 4a 01 	      lda	tempY
   2585  87ae
   2586  87ae		       85 46		      sta	temp5
   2587  87b0
   2588  87b0		       20 c6 f4 	      jsr	plotcharacters
   2589  87b3				   .skipL0182
   2590  87b3				   .L0183		;;  tempY  =  tempY  +  1
   2591  87b3
   2592  87b3		       ad 4a 01 	      LDA	tempY
   2593  87b6		       18		      CLC
   2594  87b7		       69 01		      ADC	#1
   2595  87b9		       8d 4a 01 	      STA	tempY
   2596  87bc				   .L0184		;;  tempX  =  20
   2597  87bc
   2598  87bc		       a9 14		      LDA	#20
   2599  87be		       8d 49 01 	      STA	tempX
   2600  87c1				   .L0185		;;  next
   2601  87c1
   2602  87c1		       a5 ee		      LDA	i
   2603  87c3		       c9 03		      CMP	#3
   2604  87c5		       e6 ee		      INC	i
   2605  87c7				  -	      if	((* - .L0151fori) < 127) && ((* - .L0151fori) > -128)
   2606  87c7				  -	      bcc	.L0151fori
   2607  87c7					      else
   2608  87c7		       b0 03		      bcs	.2skipL0151fori
   2609  87c9		       4c 7e 84 	      jmp	.L0151fori
   2610  87cc				   .2skipL0151fori
   2611  87cc					      endif
   2612  87cc				   .
   2613  87cc							;; 
   2614  87cc
   2615  87cc				   .L0186		;;  if fireWait  <  fireWaitMax then goto _skipInput
   2616  87cc
   2617  87cc		       ad 5a 01 	      LDA	fireWait
   2618  87cf		       cd 5b 01 	      CMP	fireWaitMax
   2619  87d2		       b0 03		      BCS	.skipL0186
   2620  87d4				   .condpart28
   2621  87d4		       4c 12 8b 	      jmp	._skipInput
   2622  87d7
   2623  87d7				   .skipL0186
   2624  87d7				   .L0187		;;  fireWait  =  0
   2625  87d7
   2626  87d7		       a9 00		      LDA	#0
   2627  87d9		       8d 5a 01 	      STA	fireWait
   2628  87dc				   .L0188		;;  xChannel  =   (  ( tSelected )  / 6 ) 
   2629  87dc
   2630  87dc							; complex statement detected
   2631  87dc		       ad 48 01 	      LDA	tSelected
   2632  87df		       a0 06		      LDY	#6
   2633  87e1		       20 a3 f5 	      jsr	div8
   2634  87e4		       8d 4c 01 	      STA	xChannel
   2635  87e7				   .L0189		;;  if xChannel  >  3 then xChannel  =  0
   2636  87e7
   2637  87e7		       a9 03		      LDA	#3
   2638  87e9		       cd 4c 01 	      CMP	xChannel
   2639  87ec		       b0 05		      BCS	.skipL0189
   2640  87ee				   .condpart29
   2641  87ee		       a9 00		      LDA	#0
   2642  87f0		       8d 4c 01 	      STA	xChannel
   2643  87f3				   .skipL0189
   2644  87f3				   .L0190		;;  if tSelected  =   ( xChannel * 6 )   +  0 then xColumn  =	0
   2645  87f3
   2646  87f3							; complex condition detected
   2647  87f3							; complex statement detected
   2648  87f3		       ad 4c 01 	      LDA	xChannel
   2649  87f6		       0a		      asl
   2650  87f7		       18		      clc
   2651  87f8		       6d 4c 01 	      adc	xChannel
   2652  87fb		       0a		      asl
   2653  87fc		       18		      CLC
   2654  87fd		       69 00		      ADC	#0
   2655  87ff		       48		      PHA
   2656  8800		       ba		      TSX
   2657  8801		       68		      PLA
   2658  8802		       ad 48 01 	      LDA	tSelected
   2659  8805		       dd 01 01 	      CMP	$101,x
   2660  8808		       d0 05		      BNE	.skipL0190
   2661  880a				   .condpart30
   2662  880a		       a9 00		      LDA	#0
   2663  880c		       8d 4d 01 	      STA	xColumn
   2664  880f				   .skipL0190
   2665  880f				   .L0191		;;  if tSelected  =   ( xChannel * 6 )   +  1 then xColumn  =	1
   2666  880f
   2667  880f							; complex condition detected
   2668  880f							; complex statement detected
   2669  880f		       ad 4c 01 	      LDA	xChannel
   2670  8812		       0a		      asl
   2671  8813		       18		      clc
   2672  8814		       6d 4c 01 	      adc	xChannel
   2673  8817		       0a		      asl
   2674  8818		       18		      CLC
   2675  8819		       69 01		      ADC	#1
   2676  881b		       48		      PHA
   2677  881c		       ba		      TSX
   2678  881d		       68		      PLA
   2679  881e		       ad 48 01 	      LDA	tSelected
   2680  8821		       dd 01 01 	      CMP	$101,x
   2681  8824		       d0 05		      BNE	.skipL0191
   2682  8826				   .condpart31
   2683  8826		       a9 01		      LDA	#1
   2684  8828		       8d 4d 01 	      STA	xColumn
   2685  882b				   .skipL0191
   2686  882b				   .L0192		;;  if tSelected  =   ( xChannel * 6 )   +  2 then xColumn  =	2
   2687  882b
   2688  882b							; complex condition detected
   2689  882b							; complex statement detected
   2690  882b		       ad 4c 01 	      LDA	xChannel
   2691  882e		       0a		      asl
   2692  882f		       18		      clc
   2693  8830		       6d 4c 01 	      adc	xChannel
   2694  8833		       0a		      asl
   2695  8834		       18		      CLC
   2696  8835		       69 02		      ADC	#2
   2697  8837		       48		      PHA
   2698  8838		       ba		      TSX
   2699  8839		       68		      PLA
   2700  883a		       ad 48 01 	      LDA	tSelected
   2701  883d		       dd 01 01 	      CMP	$101,x
   2702  8840		       d0 05		      BNE	.skipL0192
   2703  8842				   .condpart32
   2704  8842		       a9 02		      LDA	#2
   2705  8844		       8d 4d 01 	      STA	xColumn
   2706  8847				   .skipL0192
   2707  8847				   .L0193		;;  if tSelected  =   ( xChannel * 6 )   +  3 then xColumn  =	3
   2708  8847
   2709  8847							; complex condition detected
   2710  8847							; complex statement detected
   2711  8847		       ad 4c 01 	      LDA	xChannel
   2712  884a		       0a		      asl
   2713  884b		       18		      clc
   2714  884c		       6d 4c 01 	      adc	xChannel
   2715  884f		       0a		      asl
   2716  8850		       18		      CLC
   2717  8851		       69 03		      ADC	#3
   2718  8853		       48		      PHA
   2719  8854		       ba		      TSX
   2720  8855		       68		      PLA
   2721  8856		       ad 48 01 	      LDA	tSelected
   2722  8859		       dd 01 01 	      CMP	$101,x
   2723  885c		       d0 05		      BNE	.skipL0193
   2724  885e				   .condpart33
   2725  885e		       a9 03		      LDA	#3
   2726  8860		       8d 4d 01 	      STA	xColumn
   2727  8863				   .skipL0193
   2728  8863				   .L0194		;;  if tSelected  =   ( xChannel * 6 )   +  4 then xColumn  =	4
   2729  8863
   2730  8863							; complex condition detected
   2731  8863							; complex statement detected
   2732  8863		       ad 4c 01 	      LDA	xChannel
   2733  8866		       0a		      asl
   2734  8867		       18		      clc
   2735  8868		       6d 4c 01 	      adc	xChannel
   2736  886b		       0a		      asl
   2737  886c		       18		      CLC
   2738  886d		       69 04		      ADC	#4
   2739  886f		       48		      PHA
   2740  8870		       ba		      TSX
   2741  8871		       68		      PLA
   2742  8872		       ad 48 01 	      LDA	tSelected
   2743  8875		       dd 01 01 	      CMP	$101,x
   2744  8878		       d0 05		      BNE	.skipL0194
   2745  887a				   .condpart34
   2746  887a		       a9 04		      LDA	#4
   2747  887c		       8d 4d 01 	      STA	xColumn
   2748  887f				   .skipL0194
   2749  887f				   .L0195		;;  if tSelected  =   ( xChannel * 6 )   +  5 then xColumn  =	5
   2750  887f
   2751  887f							; complex condition detected
   2752  887f							; complex statement detected
   2753  887f		       ad 4c 01 	      LDA	xChannel
   2754  8882		       0a		      asl
   2755  8883		       18		      clc
   2756  8884		       6d 4c 01 	      adc	xChannel
   2757  8887		       0a		      asl
   2758  8888		       18		      CLC
   2759  8889		       69 05		      ADC	#5
   2760  888b		       48		      PHA
   2761  888c		       ba		      TSX
   2762  888d		       68		      PLA
   2763  888e		       ad 48 01 	      LDA	tSelected
   2764  8891		       dd 01 01 	      CMP	$101,x
   2765  8894		       d0 05		      BNE	.skipL0195
   2766  8896				   .condpart35
   2767  8896		       a9 05		      LDA	#5
   2768  8898		       8d 4d 01 	      STA	xColumn
   2769  889b				   .skipL0195
   2770  889b				   .
   2771  889b							;; 
   2772  889b
   2773  889b				   .
   2774  889b							;; 
   2775  889b
   2776  889b				   .
   2777  889b							;; 
   2778  889b
   2779  889b				   .
   2780  889b							;; 
   2781  889b
   2782  889b				   .
   2783  889b							;; 
   2784  889b
   2785  889b				   .
   2786  889b							;; 
   2787  889b
   2788  889b				   .
   2789  889b							;; 
   2790  889b
   2791  889b				   .
   2792  889b							;; 
   2793  889b
   2794  889b				   .
   2795  889b							;; 
   2796  889b
   2797  889b				   ._testJoyFire0
   2798  889b							;; _testJoyFire0
   2799  889b
   2800  889b				   .L0196		;;  if !joy0fire1 then goto _testJoyFire1
   2801  889b
   2802  889b		       2c 02 21 	      bit	sINPT1
   2803  889e		       30 03		      BMI	.skipL0196
   2804  88a0				   .condpart36
   2805  88a0		       4c 73 89 	      jmp	._testJoyFire1
   2806  88a3
   2807  88a3				   .skipL0196
   2808  88a3				   .L0197		;;  if xColumn  =  0 then tFrequency  =  cFrequency[xChannel]	+  1  :  cFrequency[xChannel]  =  tFrequency
   2809  88a3
   2810  88a3		       ad 4d 01 	      LDA	xColumn
   2811  88a6		       c9 00		      CMP	#0
   2812  88a8		       d0 15		      BNE	.skipL0197
   2813  88aa				   .condpart37
   2814  88aa		       ae 4c 01 	      LDX	xChannel
   2815  88ad		       bd 04 22 	      LDA	cFrequency,x
   2816  88b0		       18		      CLC
   2817  88b1		       69 01		      ADC	#1
   2818  88b3		       8d 42 01 	      STA	tFrequency
   2819  88b6		       ad 42 01 	      LDA	tFrequency
   2820  88b9		       ae 4c 01 	      LDX	xChannel
   2821  88bc		       9d 04 22 	      STA	cFrequency,x
   2822  88bf				   .skipL0197
   2823  88bf				   .L0198		;;  if xColumn  =  1 then cWaveForm[xChannel]	=  cWaveForm[xChannel]	+  1
   2824  88bf
   2825  88bf		       ad 4d 01 	      LDA	xColumn
   2826  88c2		       c9 01		      CMP	#1
   2827  88c4		       d0 0f		      BNE	.skipL0198
   2828  88c6				   .condpart38
   2829  88c6		       ae 4c 01 	      LDX	xChannel
   2830  88c9		       bd 08 22 	      LDA	cWaveForm,x
   2831  88cc		       18		      CLC
   2832  88cd		       69 01		      ADC	#1
   2833  88cf		       ae 4c 01 	      LDX	xChannel
   2834  88d2		       9d 08 22 	      STA	cWaveForm,x
   2835  88d5				   .skipL0198
   2836  88d5				   .L0199		;;  if xColumn  =  2 then cVolume[xChannel]  =  cVolume[xChannel]  +  1
   2837  88d5
   2838  88d5		       ad 4d 01 	      LDA	xColumn
   2839  88d8		       c9 02		      CMP	#2
   2840  88da		       d0 0f		      BNE	.skipL0199
   2841  88dc				   .condpart39
   2842  88dc		       ae 4c 01 	      LDX	xChannel
   2843  88df		       bd 0c 22 	      LDA	cVolume,x
   2844  88e2		       18		      CLC
   2845  88e3		       69 01		      ADC	#1
   2846  88e5		       ae 4c 01 	      LDX	xChannel
   2847  88e8		       9d 0c 22 	      STA	cVolume,x
   2848  88eb				   .skipL0199
   2849  88eb				   .L0200		;;  if xColumn  =  3 then cDuration[xChannel]	=  cDuration[xChannel]	+  1
   2850  88eb
   2851  88eb		       ad 4d 01 	      LDA	xColumn
   2852  88ee		       c9 03		      CMP	#3
   2853  88f0		       d0 0f		      BNE	.skipL0200
   2854  88f2				   .condpart40
   2855  88f2		       ae 4c 01 	      LDX	xChannel
   2856  88f5		       bd 10 22 	      LDA	cDuration,x
   2857  88f8		       18		      CLC
   2858  88f9		       69 01		      ADC	#1
   2859  88fb		       ae 4c 01 	      LDX	xChannel
   2860  88fe		       9d 10 22 	      STA	cDuration,x
   2861  8901				   .skipL0200
   2862  8901				   .L0201		;;  if xColumn  =  4 then cSilence[xChannel]  =  cSilence[xChannel]  +  1
   2863  8901
   2864  8901		       ad 4d 01 	      LDA	xColumn
   2865  8904		       c9 04		      CMP	#4
   2866  8906		       d0 0f		      BNE	.skipL0201
   2867  8908				   .condpart41
   2868  8908		       ae 4c 01 	      LDX	xChannel
   2869  890b		       bd 14 22 	      LDA	cSilence,x
   2870  890e		       18		      CLC
   2871  890f		       69 01		      ADC	#1
   2872  8911		       ae 4c 01 	      LDX	xChannel
   2873  8914		       9d 14 22 	      STA	cSilence,x
   2874  8917				   .skipL0201
   2875  8917				   .L0202		;;  if xColumn  =  5 then cType[xChannel]  =  cType[xChannel]	+  1
   2876  8917
   2877  8917		       ad 4d 01 	      LDA	xColumn
   2878  891a		       c9 05		      CMP	#5
   2879  891c		       d0 0f		      BNE	.skipL0202
   2880  891e				   .condpart42
   2881  891e		       ae 4c 01 	      LDX	xChannel
   2882  8921		       bd 18 22 	      LDA	cType,x
   2883  8924		       18		      CLC
   2884  8925		       69 01		      ADC	#1
   2885  8927		       ae 4c 01 	      LDX	xChannel
   2886  892a		       9d 18 22 	      STA	cType,x
   2887  892d				   .skipL0202
   2888  892d				   .L0203		;;  if cWaveForm[xChannel]  >	15 then cWaveForm[xChannel]  =	0
   2889  892d
   2890  892d		       a9 0f		      LDA	#15
   2891  892f		       ae 4c 01 	      LDX	xChannel
   2892  8932		       dd 08 22 	      CMP	cWaveForm,x
   2893  8935		       b0 08		      BCS	.skipL0203
   2894  8937				   .condpart43
   2895  8937		       a9 00		      LDA	#0
   2896  8939		       ae 4c 01 	      LDX	xChannel
   2897  893c		       9d 08 22 	      STA	cWaveForm,x
   2898  893f				   .skipL0203
   2899  893f				   .L0204		;;  if cVolume[xChannel]  >  15 then cVolume[xChannel]  =  0
   2900  893f
   2901  893f		       a9 0f		      LDA	#15
   2902  8941		       ae 4c 01 	      LDX	xChannel
   2903  8944		       dd 0c 22 	      CMP	cVolume,x
   2904  8947		       b0 08		      BCS	.skipL0204
   2905  8949				   .condpart44
   2906  8949		       a9 00		      LDA	#0
   2907  894b		       ae 4c 01 	      LDX	xChannel
   2908  894e		       9d 0c 22 	      STA	cVolume,x
   2909  8951				   .skipL0204
   2910  8951				   .L0205		;;  if cType[xChannel]  >  3  ||  cType[xChannel]  =  0 then cType[xChannel]  =  1
   2911  8951
   2912  8951		       a9 03		      LDA	#3
   2913  8953		       ae 4c 01 	      LDX	xChannel
   2914  8956		       dd 18 22 	      CMP	cType,x
   2915  8959		       b0 03		      BCS	.skipL0205
   2916  895b				   .condpart45
   2917  895b		       4c 68 89 	      jmp	.condpart46
   2918  895e				   .skipL0205
   2919  895e		       ae 4c 01 	      LDX	xChannel
   2920  8961		       bd 18 22 	      LDA	cType,x
   2921  8964		       c9 00		      CMP	#0
   2922  8966		       d0 08		      BNE	.skip3OR
   2923  8968				   .condpart46
   2924  8968		       a9 01		      LDA	#1
   2925  896a		       ae 4c 01 	      LDX	xChannel
   2926  896d		       9d 18 22 	      STA	cType,x
   2927  8970				   .skip3OR
   2928  8970				   .L0206		;;  goto _skipInput
   2929  8970
   2930  8970		       4c 12 8b 	      jmp	._skipInput
   2931  8973
   2932  8973				   ._testJoyFire1
   2933  8973							;; _testJoyFire1
   2934  8973
   2935  8973				   .L0207		;;  if !joy0fire0 then goto _testJoyLeft
   2936  8973
   2937  8973		       2c 02 21 	      bit	sINPT1
   2938  8976		       70 03		      BVS	.skipL0207
   2939  8978				   .condpart47
   2940  8978		       4c 45 8a 	      jmp	._testJoyLeft
   2941  897b
   2942  897b				   .skipL0207
   2943  897b				   .L0208		;;  if xColumn  =  0 then cFrequency[xChannel]  =  cFrequency[xChannel]  -  1
   2944  897b
   2945  897b		       ad 4d 01 	      LDA	xColumn
   2946  897e		       c9 00		      CMP	#0
   2947  8980		       d0 0f		      BNE	.skipL0208
   2948  8982				   .condpart48
   2949  8982		       ae 4c 01 	      LDX	xChannel
   2950  8985		       bd 04 22 	      LDA	cFrequency,x
   2951  8988		       38		      SEC
   2952  8989		       e9 01		      SBC	#1
   2953  898b		       ae 4c 01 	      LDX	xChannel
   2954  898e		       9d 04 22 	      STA	cFrequency,x
   2955  8991				   .skipL0208
   2956  8991				   .L0209		;;  if xColumn  =  1 then cWaveForm[xChannel]	=  cWaveForm[xChannel]	-  1
   2957  8991
   2958  8991		       ad 4d 01 	      LDA	xColumn
   2959  8994		       c9 01		      CMP	#1
   2960  8996		       d0 0f		      BNE	.skipL0209
   2961  8998				   .condpart49
   2962  8998		       ae 4c 01 	      LDX	xChannel
   2963  899b		       bd 08 22 	      LDA	cWaveForm,x
   2964  899e		       38		      SEC
   2965  899f		       e9 01		      SBC	#1
   2966  89a1		       ae 4c 01 	      LDX	xChannel
   2967  89a4		       9d 08 22 	      STA	cWaveForm,x
   2968  89a7				   .skipL0209
   2969  89a7				   .L0210		;;  if xColumn  =  2 then cVolume[xChannel]  =  cVolume[xChannel]  -  1
   2970  89a7
   2971  89a7		       ad 4d 01 	      LDA	xColumn
   2972  89aa		       c9 02		      CMP	#2
   2973  89ac		       d0 0f		      BNE	.skipL0210
   2974  89ae				   .condpart50
   2975  89ae		       ae 4c 01 	      LDX	xChannel
   2976  89b1		       bd 0c 22 	      LDA	cVolume,x
   2977  89b4		       38		      SEC
   2978  89b5		       e9 01		      SBC	#1
   2979  89b7		       ae 4c 01 	      LDX	xChannel
   2980  89ba		       9d 0c 22 	      STA	cVolume,x
   2981  89bd				   .skipL0210
   2982  89bd				   .L0211		;;  if xColumn  =  3 then cDuration[xChannel]	=  cDuration[xChannel]	-  1
   2983  89bd
   2984  89bd		       ad 4d 01 	      LDA	xColumn
   2985  89c0		       c9 03		      CMP	#3
   2986  89c2		       d0 0f		      BNE	.skipL0211
   2987  89c4				   .condpart51
   2988  89c4		       ae 4c 01 	      LDX	xChannel
   2989  89c7		       bd 10 22 	      LDA	cDuration,x
   2990  89ca		       38		      SEC
   2991  89cb		       e9 01		      SBC	#1
   2992  89cd		       ae 4c 01 	      LDX	xChannel
   2993  89d0		       9d 10 22 	      STA	cDuration,x
   2994  89d3				   .skipL0211
   2995  89d3				   .L0212		;;  if xColumn  =  4 then cSilence[xChannel]  =  cSilence[xChannel]  -  1
   2996  89d3
   2997  89d3		       ad 4d 01 	      LDA	xColumn
   2998  89d6		       c9 04		      CMP	#4
   2999  89d8		       d0 0f		      BNE	.skipL0212
   3000  89da				   .condpart52
   3001  89da		       ae 4c 01 	      LDX	xChannel
   3002  89dd		       bd 14 22 	      LDA	cSilence,x
   3003  89e0		       38		      SEC
   3004  89e1		       e9 01		      SBC	#1
   3005  89e3		       ae 4c 01 	      LDX	xChannel
   3006  89e6		       9d 14 22 	      STA	cSilence,x
   3007  89e9				   .skipL0212
   3008  89e9				   .L0213		;;  if xColumn  =  5 then cType[xChannel]  =  cType[xChannel]	-  1
   3009  89e9
   3010  89e9		       ad 4d 01 	      LDA	xColumn
   3011  89ec		       c9 05		      CMP	#5
   3012  89ee		       d0 0f		      BNE	.skipL0213
   3013  89f0				   .condpart53
   3014  89f0		       ae 4c 01 	      LDX	xChannel
   3015  89f3		       bd 18 22 	      LDA	cType,x
   3016  89f6		       38		      SEC
   3017  89f7		       e9 01		      SBC	#1
   3018  89f9		       ae 4c 01 	      LDX	xChannel
   3019  89fc		       9d 18 22 	      STA	cType,x
   3020  89ff				   .skipL0213
   3021  89ff				   .L0214		;;  if cWaveForm[xChannel]  >	15 then cWaveForm[xChannel]  =	0
   3022  89ff
   3023  89ff		       a9 0f		      LDA	#15
   3024  8a01		       ae 4c 01 	      LDX	xChannel
   3025  8a04		       dd 08 22 	      CMP	cWaveForm,x
   3026  8a07		       b0 08		      BCS	.skipL0214
   3027  8a09				   .condpart54
   3028  8a09		       a9 00		      LDA	#0
   3029  8a0b		       ae 4c 01 	      LDX	xChannel
   3030  8a0e		       9d 08 22 	      STA	cWaveForm,x
   3031  8a11				   .skipL0214
   3032  8a11				   .L0215		;;  if cVolume[xChannel]  >  15 then cVolume[xChannel]  =  0
   3033  8a11
   3034  8a11		       a9 0f		      LDA	#15
   3035  8a13		       ae 4c 01 	      LDX	xChannel
   3036  8a16		       dd 0c 22 	      CMP	cVolume,x
   3037  8a19		       b0 08		      BCS	.skipL0215
   3038  8a1b				   .condpart55
   3039  8a1b		       a9 00		      LDA	#0
   3040  8a1d		       ae 4c 01 	      LDX	xChannel
   3041  8a20		       9d 0c 22 	      STA	cVolume,x
   3042  8a23				   .skipL0215
   3043  8a23				   .L0216		;;  if cType[xChannel]  >  3  ||  cType[xChannel]  =  0 then cType[xChannel]  =  1
   3044  8a23
   3045  8a23		       a9 03		      LDA	#3
   3046  8a25		       ae 4c 01 	      LDX	xChannel
   3047  8a28		       dd 18 22 	      CMP	cType,x
   3048  8a2b		       b0 03		      BCS	.skipL0216
   3049  8a2d				   .condpart56
   3050  8a2d		       4c 3a 8a 	      jmp	.condpart57
   3051  8a30				   .skipL0216
   3052  8a30		       ae 4c 01 	      LDX	xChannel
   3053  8a33		       bd 18 22 	      LDA	cType,x
   3054  8a36		       c9 00		      CMP	#0
   3055  8a38		       d0 08		      BNE	.skip4OR
   3056  8a3a				   .condpart57
   3057  8a3a		       a9 01		      LDA	#1
   3058  8a3c		       ae 4c 01 	      LDX	xChannel
   3059  8a3f		       9d 18 22 	      STA	cType,x
   3060  8a42				   .skip4OR
   3061  8a42				   .L0217		;;  goto _skipInput
   3062  8a42
   3063  8a42		       4c 12 8b 	      jmp	._skipInput
   3064  8a45
   3065  8a45				   ._testJoyLeft
   3066  8a45							;; _testJoyLeft
   3067  8a45
   3068  8a45				   .L0218		;;  if !joy0left then goto _testJoyRight
   3069  8a45
   3070  8a45		       2c 80 02 	      bit	SWCHA
   3071  8a48		       50 03		      BVC	.skipL0218
   3072  8a4a				   .condpart58
   3073  8a4a		       4c 65 8a 	      jmp	._testJoyRight
   3074  8a4d
   3075  8a4d				   .skipL0218
   3076  8a4d				   .L0219		;;  tSelected	=  tSelected  -  1
   3077  8a4d
   3078  8a4d		       ad 48 01 	      LDA	tSelected
   3079  8a50		       38		      SEC
   3080  8a51		       e9 01		      SBC	#1
   3081  8a53		       8d 48 01 	      STA	tSelected
   3082  8a56				   .L0220		;;  if tSelected  >  23 then tSelected  =  0
   3083  8a56
   3084  8a56		       a9 17		      LDA	#23
   3085  8a58		       cd 48 01 	      CMP	tSelected
   3086  8a5b		       b0 05		      BCS	.skipL0220
   3087  8a5d				   .condpart59
   3088  8a5d		       a9 00		      LDA	#0
   3089  8a5f		       8d 48 01 	      STA	tSelected
   3090  8a62				   .skipL0220
   3091  8a62				   .L0221		;;  goto _skipInput
   3092  8a62
   3093  8a62		       4c 12 8b 	      jmp	._skipInput
   3094  8a65
   3095  8a65				   ._testJoyRight
   3096  8a65							;; _testJoyRight
   3097  8a65
   3098  8a65				   .L0222		;;  if !joy0right then goto _testJoyUp
   3099  8a65
   3100  8a65		       2c 80 02 	      bit	SWCHA
   3101  8a68		       10 03		      BPL	.skipL0222
   3102  8a6a				   .condpart60
   3103  8a6a		       4c 82 8a 	      jmp	._testJoyUp
   3104  8a6d
   3105  8a6d				   .skipL0222
   3106  8a6d				   .L0223		;;  tSelected	=  tSelected  +  1
   3107  8a6d
   3108  8a6d		       ad 48 01 	      LDA	tSelected
   3109  8a70		       18		      CLC
   3110  8a71		       69 01		      ADC	#1
   3111  8a73		       8d 48 01 	      STA	tSelected
   3112  8a76				   .L0224		;;  if tSelected  >  23 then tSelected  =  0
   3113  8a76
   3114  8a76		       a9 17		      LDA	#23
   3115  8a78		       cd 48 01 	      CMP	tSelected
   3116  8a7b		       b0 05		      BCS	.skipL0224
   3117  8a7d				   .condpart61
   3118  8a7d		       a9 00		      LDA	#0
   3119  8a7f		       8d 48 01 	      STA	tSelected
   3120  8a82				   .skipL0224
   3121  8a82				   ._testJoyUp
   3122  8a82							;; _testJoyUp
   3123  8a82
   3124  8a82				   .L0225		;;  if !joy0up then goto _testJoyDown
   3125  8a82
   3126  8a82		       a9 10		      lda	#$10
   3127  8a84		       2c 80 02 	      bit	SWCHA
   3128  8a87		       f0 03		      BEQ	.skipL0225
   3129  8a89				   .condpart62
   3130  8a89		       4c a5 8a 	      jmp	._testJoyDown
   3131  8a8c
   3132  8a8c				   .skipL0225
   3133  8a8c				   .L0226		;;  tSelected	=  tSelected  -  6
   3134  8a8c
   3135  8a8c		       ad 48 01 	      LDA	tSelected
   3136  8a8f		       38		      SEC
   3137  8a90		       e9 06		      SBC	#6
   3138  8a92		       8d 48 01 	      STA	tSelected
   3139  8a95				   .L0227		;;  if tSelected  >  23 then tSelected  =  tSelected  +  6
   3140  8a95
   3141  8a95		       a9 17		      LDA	#23
   3142  8a97		       cd 48 01 	      CMP	tSelected
   3143  8a9a		       b0 09		      BCS	.skipL0227
   3144  8a9c				   .condpart63
   3145  8a9c		       ad 48 01 	      LDA	tSelected
   3146  8a9f		       18		      CLC
   3147  8aa0		       69 06		      ADC	#6
   3148  8aa2		       8d 48 01 	      STA	tSelected
   3149  8aa5				   .skipL0227
   3150  8aa5				   ._testJoyDown
   3151  8aa5							;; _testJoyDown
   3152  8aa5
   3153  8aa5				   .L0228		;;  if !joy0down then goto _testReset
   3154  8aa5
   3155  8aa5		       a9 20		      lda	#$20
   3156  8aa7		       2c 80 02 	      bit	SWCHA
   3157  8aaa		       f0 03		      BEQ	.skipL0228
   3158  8aac				   .condpart64
   3159  8aac		       4c c8 8a 	      jmp	._testReset
   3160  8aaf
   3161  8aaf				   .skipL0228
   3162  8aaf				   .L0229		;;  tSelected	=  tSelected  +  6
   3163  8aaf
   3164  8aaf		       ad 48 01 	      LDA	tSelected
   3165  8ab2		       18		      CLC
   3166  8ab3		       69 06		      ADC	#6
   3167  8ab5		       8d 48 01 	      STA	tSelected
   3168  8ab8				   .L0230		;;  if tSelected  >  23 then tSelected  =  tSelected  -  6
   3169  8ab8
   3170  8ab8		       a9 17		      LDA	#23
   3171  8aba		       cd 48 01 	      CMP	tSelected
   3172  8abd		       b0 09		      BCS	.skipL0230
   3173  8abf				   .condpart65
   3174  8abf		       ad 48 01 	      LDA	tSelected
   3175  8ac2		       38		      SEC
   3176  8ac3		       e9 06		      SBC	#6
   3177  8ac5		       8d 48 01 	      STA	tSelected
   3178  8ac8				   .skipL0230
   3179  8ac8				   ._testReset
   3180  8ac8							;; _testReset
   3181  8ac8
   3182  8ac8				   .L0231		;;  if !switchreset then goto _skipInput
   3183  8ac8
   3184  8ac8		       20 ff f5 	      jsr	checkresetswitch
   3185  8acb		       f0 03		      BEQ	.skipL0231
   3186  8acd				   .condpart66
   3187  8acd		       4c 12 8b 	      jmp	._skipInput
   3188  8ad0
   3189  8ad0				   .skipL0231
   3190  8ad0				   .L0232		;;  for i  =  0 to 3
   3191  8ad0
   3192  8ad0		       a9 00		      LDA	#0
   3193  8ad2		       85 ee		      STA	i
   3194  8ad4				   .L0232fori
   3195  8ad4				   .L0233		;;  cTicks[i]	=  0
   3196  8ad4
   3197  8ad4		       a9 00		      LDA	#0
   3198  8ad6		       a6 ee		      LDX	i
   3199  8ad8		       9d 20 22 	      STA	cTicks,x
   3200  8adb				   .L0234		;;  cMode[i]  =  MODE_PLAY
   3201  8adb
   3202  8adb		       a9 01		      LDA	#MODE_PLAY
   3203  8add		       a6 ee		      LDX	i
   3204  8adf		       9d 1c 22 	      STA	cMode,x
   3205  8ae2				   .L0235		;;  tType  =  cType[i]
   3206  8ae2
   3207  8ae2		       a6 ee		      LDX	i
   3208  8ae4		       bd 18 22 	      LDA	cType,x
   3209  8ae7		       8d 45 01 	      STA	tType
   3210  8aea				   .L0236		;;  if tType  =  TYPE_ATTACK then tVolume  =  0
   3211  8aea
   3212  8aea		       ad 45 01 	      LDA	tType
   3213  8aed		       c9 02		      CMP	#TYPE_ATTACK
   3214  8aef		       d0 05		      BNE	.skipL0236
   3215  8af1				   .condpart67
   3216  8af1		       a9 00		      LDA	#0
   3217  8af3		       8d 44 01 	      STA	tVolume
   3218  8af6				   .skipL0236
   3219  8af6				   .L0237		;;  if tType  =  TYPE_DECAY then tVolume  =  15
   3220  8af6
   3221  8af6		       ad 45 01 	      LDA	tType
   3222  8af9		       c9 03		      CMP	#TYPE_DECAY
   3223  8afb		       d0 05		      BNE	.skipL0237
   3224  8afd				   .condpart68
   3225  8afd		       a9 0f		      LDA	#15
   3226  8aff		       8d 44 01 	      STA	tVolume
   3227  8b02				   .skipL0237
   3228  8b02				   .L0238		;;  cVolume[i]  =  tVolume
   3229  8b02
   3230  8b02		       ad 44 01 	      LDA	tVolume
   3231  8b05		       a6 ee		      LDX	i
   3232  8b07		       9d 0c 22 	      STA	cVolume,x
   3233  8b0a				   .
   3234  8b0a							;; 
   3235  8b0a
   3236  8b0a				   .L0239		;;  next
   3237  8b0a
   3238  8b0a		       a5 ee		      LDA	i
   3239  8b0c		       c9 03		      CMP	#3
   3240  8b0e		       e6 ee		      INC	i
   3241  8b10					      if	((* - .L0232fori) < 127) && ((* - .L0232fori) > -128)
   3242  8b10		       90 c2		      bcc	.L0232fori
   3243  8b12				  -	      else
   3244  8b12				  -	      bcs	.3skipL0232fori
   3245  8b12				  -	      jmp	.L0232fori
   3246  8b12				  -.3skipL0232fori
   3247  8b12					      endif
   3248  8b12				   .
   3249  8b12							;; 
   3250  8b12
   3251  8b12				   ._skipInput
   3252  8b12							;; _skipInput
   3253  8b12
   3254  8b12				   .L0240		;;  fireWait  =  fireWait  +  1
   3255  8b12
   3256  8b12		       ad 5a 01 	      LDA	fireWait
   3257  8b15		       18		      CLC
   3258  8b16		       69 01		      ADC	#1
   3259  8b18		       8d 5a 01 	      STA	fireWait
   3260  8b1b				   .L0241		;;  if fireWait  >=  fireWaitMax then fireWait  =  fireWaitMax  +  1
   3261  8b1b
   3262  8b1b		       ad 5a 01 	      LDA	fireWait
   3263  8b1e		       cd 5b 01 	      CMP	fireWaitMax
   3264  8b21		       90 09		      BCC	.skipL0241
   3265  8b23				   .condpart69
   3266  8b23		       ad 5b 01 	      LDA	fireWaitMax
   3267  8b26		       18		      CLC
   3268  8b27		       69 01		      ADC	#1
   3269  8b29		       8d 5a 01 	      STA	fireWait
   3270  8b2c				   .skipL0241
   3271  8b2c				   .
   3272  8b2c							;; 
   3273  8b2c
   3274  8b2c				   .L0242		;;  drawscreen
   3275  8b2c
   3276  8b2c		       20 f9 f1 	      jsr	drawscreen
   3277  8b2f				   .
   3278  8b2f							;; 
   3279  8b2f
   3280  8b2f				   .
   3281  8b2f							;; 
   3282  8b2f
   3283  8b2f				   .L0243		;;  goto mainScreen
   3284  8b2f		       4c e5 80 	      jmp	.mainScreen
   3285  8b2f				   DMAHOLEEND0 SET	.
   3286  8b32				   gameend
   3287  8b32				   DMAHOLEEND0 SET	.
   5326 bytes of ROM space left in the main area of bank 1.
   3288  8b32					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   3289  8b32				  -	      if	($A000 - .) < 0
   3290  8b32				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3291  8b32					      endif
   3292  8b32
   3293  a000					      ORG	$A000,0	; *************
   3294  a000
   3295  a000					      RORG	$A000	; *************
   3296  a000
   3297  a000				   font
   3298  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3299  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3300  a035
   3301  a100					      ORG	$A100,0	; *************
   3302  a100
   3303  a100					      RORG	$A100	; *************
   3304  a100
   3305  a100							;font
   3306  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3307  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3308  a135
   3309  a200					      ORG	$A200,0	; *************
   3310  a200
   3311  a200					      RORG	$A200	; *************
   3312  a200
   3313  a200							;font
   3314  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3315  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3316  a235
   3317  a300					      ORG	$A300,0	; *************
   3318  a300
   3319  a300					      RORG	$A300	; *************
   3320  a300
   3321  a300							;font
   3322  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3323  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3324  a335
   3325  a400					      ORG	$A400,0	; *************
   3326  a400
   3327  a400					      RORG	$A400	; *************
   3328  a400
   3329  a400							;font
   3330  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3331  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3332  a435
   3333  a500					      ORG	$A500,0	; *************
   3334  a500
   3335  a500					      RORG	$A500	; *************
   3336  a500
   3337  a500							;font
   3338  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3339  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3340  a535
   3341  a600					      ORG	$A600,0	; *************
   3342  a600
   3343  a600					      RORG	$A600	; *************
   3344  a600
   3345  a600							;font
   3346  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3347  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3348  a635
   3349  a700					      ORG	$A700,0	; *************
   3350  a700
   3351  a700					      RORG	$A700	; *************
   3352  a700
   3353  a700							;font
   3354  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3355  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   3356  a735
   3357  a800					      ORG	$A800,0	; *************
   3358  a800
   3359  a800					      RORG	$A800	; *************
   3360  a800
   3361  a800							;font
   3362  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   3363  a820		       00 00 00 00*	      HEX	000000000000000000008000a80000000000000000
   3364  a835
   3365  a900					      ORG	$A900,0	; *************
   3366  a900
   3367  a900					      RORG	$A900	; *************
   3368  a900
   3369  a900							;font
   3370  a900		       a8 a8 a8 a8*	      HEX	a8a8a8a808a8a820a8a888a0a8a0a880a888a8a888a88888a8800888a820a820
   3371  a920		       88 88 20 a8*	      HEX	888820a88000202080202000000880a8a8282a8000
   3372  a935
   3373  aa00					      ORG	$AA00,0	; *************
   3374  aa00
   3375  aa00					      RORG	$AA00	; *************
   3376  aa00
   3377  aa00							;font
   3378  aa00		       88 20 80 08*	      HEX	8820800808888820880888888088808088882088888088888880a088082088a8
   3379  aa20		       a8 88 20 80*	      HEX	a8882080a000000080000000002020800882802000
   3380  aa35
   3381  ab00					      ORG	$AB00,0	; *************
   3382  ab00
   3383  ab00					      RORG	$AB00	; *************
   3384  ab00
   3385  ab00							;font
   3386  ab00		       88 20 80 08*	      HEX	88208008080888208808a8888088808088882008a080888888a888a008208888
   3387  ab20		       a8 a8 20 80*	      HEX	a8a82080a8002020200000000080088008828a2000
   3388  ab35
   3389  ac00					      ORG	$AC00,0	; *************
   3390  ac00
   3391  ac00					      RORG	$AC00	; *************
   3392  ac00
   3393  ac00							;font
   3394  ac00		       88 20 a8 28*	      HEX	8820a828a808a820a8a888a08088a0a088a82008a080a88888888888a8208888
   3395  ac20		       88 20 20 a0*	      HEX	882020a0aa002020200000a8008008800828882000
   3396  ac35
   3397  ad00					      ORG	$AD00,0	; *************
   3398  ad00
   3399  ad00					      RORG	$AD00	; *************
   3400  ad00
   3401  ad00							;font
   3402  ad00		       88 20 08 08*	      HEX	8820080888a880088888888880888080808820088880a8888888888880208888
   3403  ad20		       88 a8 88 28*	      HEX	88a88828a8000820200000000080088008888a2000
   3404  ad35
   3405  ae00					      ORG	$AE00,0	; *************
   3406  ae00
   3407  ae00					      RORG	$AE00	; *************
   3408  ae00
   3409  ae00							;font
   3410  ae00		       88 a0 08 08*	      HEX	88a00808888080888888888880888080808820088880a8888888888880208888
   3411  ae20		       88 88 88 08*	      HEX	88888808a088882008000000002020800888802000
   3412  ae35
   3413  af00					      ORG	$AF00,0	; *************
   3414  af00
   3415  af00					      RORG	$AF00	; *************
   3416  af00
   3417  af00							;font
   3418  af00		       a8 20 a8 a8*	      HEX	a820a8a888a8a8a8a8a8a8a0a8a0a8a8a888a808888088a8a8a8a8a8a8a88888
   3419  af20		       88 88 88 a8*	      HEX	888888a88088a82008000000000880a8a8202a8000
   3420  af35
   3421  b000					      ORG	$B000,0	; *************
   3422  b000
   3423  b000					      RORG	$B000	; *************
   3424  b000				  -	      if	SPACEOVERFLOW > 0
   3425  b000				  -	      echo	""
   3426  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   3427  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   3428  b000				  -	      echo	"######## Aborting assembly."
   3429  b000				  -	      ERR
   3430  b000					      endif
   3431  b000
   3432  b000
   3433  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3434  b000
   3435  b000				  -	      ifnconst	bankswitchmode
   3436  b000				  -	      if	( * < $f000 )
   3437  b000				  -	      ORG	$F000
   3438  b000				  -	      endif
   3439  b000					      else
   3440  b000					      ifconst	ROM128K
   3441  b000					      if	( * < $f000 )
   3442  27000					       ORG	$27000
   3443  27000					       RORG	$F000
   3444  27000					       endif
   3445  27000					       endif
   3446  27000				   -	       ifconst	ROM144K
   3447  27000				   -	       if	( * < $f000 )
   3448  27000				   -	       ORG	$27000
   3449  27000				   -	       RORG	$F000
   3450  27000				   -	       endif
   3451  27000					       endif
   3452  27000				   -	       ifconst	ROM256K
   3453  27000				   -	       if	( * < $f000 )
   3454  27000				   -	       ORG	$47000
   3455  27000				   -	       RORG	$F000
   3456  27000				   -	       endif
   3457  27000					       endif
   3458  27000				   -	       ifconst	ROM272K
   3459  27000				   -	       if	( * < $f000 )
   3460  27000				   -	       ORG	$47000
   3461  27000				   -	       RORG	$F000
   3462  27000				   -	       endif
   3463  27000					       endif
   3464  27000				   -	       ifconst	ROM512K
   3465  27000				   -	       if	( * < $f000 )
   3466  27000				   -	       ORG	$87000
   3467  27000				   -	       RORG	$F000
   3468  27000				   -	       endif
   3469  27000					       endif
   3470  27000				   -	       ifconst	ROM528K
   3471  27000				   -	       if	( * < $f000 )
   3472  27000				   -	       ORG	$87000
   3473  27000				   -	       RORG	$F000
   3474  27000				   -	       endif
   3475  27000					       endif
   3476  27000					       endif
   3477  27000
   3478  27000							; all of these "modules" have conditional clauses in them, so even though
   3479  27000							; they're always included here, they don't take up rom unless the user
   3480  27000							; explicitly enables support for the feature.
   3481  27000
   3482  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -AVoxReadBytes
     12  27000				   -	       sta	temp8
     13  27000				   -	       jsr	i2c_startwrite
     14  27000				   -	       bcs	eeprom_error
     15  27000				   -
     16  27000				   -	       lda	HSVoxHi
     17  27000				   -	       jsr	i2c_txbyte
     18  27000				   -	       lda	HSVoxLo
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       jsr	i2c_stopwrite
     21  27000				   -
     22  27000				   -	       jsr	i2c_startread
     23  27000				   -
     24  27000				   -	       ldx	#0
     25  27000				   -AVoxReadBytesLoop
     26  27000				   -	       jsr	i2c_rxbyte
     27  27000				   -	       sta	eeprombuffer,x
     28  27000				   -	       inx
     29  27000				   -	       cpx	temp8
     30  27000				   -	       bne	AVoxReadBytesLoop
     31  27000				   -	       jsr	i2c_stopread
     32  27000				   -	       lda	#0
     33  27000				   -	       rts
     34  27000				   -
     35  27000				   -			; to be called with
     36  27000				   -			; A=# of bytes
     37  27000				   -			;
     38  27000				   -
     39  27000				   -AVoxWriteBytes
     40  27000				   -	       sta	temp8
     41  27000				   -	       jsr	i2c_startwrite
     42  27000				   -	       bcs	eeprom_error
     43  27000				   -
     44  27000				   -	       lda	HSVoxHi
     45  27000				   -	       jsr	i2c_txbyte
     46  27000				   -	       lda	HSVoxLo
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -
     49  27000				   -	       ldx	#$00
     50  27000				   -AVoxWriteBytesLoop
     51  27000				   -	       lda	eeprombuffer,x
     52  27000				   -	       jsr	i2c_txbyte
     53  27000				   -	       inx
     54  27000				   -	       cpx	temp8
     55  27000				   -	       bne	AVoxWriteBytesLoop
     56  27000				   -	       jsr	i2c_stopwrite
     57  27000				   -
     58  27000				   -	       lda	#0
     59  27000				   -	       rts
     60  27000				   -
     61  27000				   -eeprom_error
     62  27000				   -	       lda	#$ff
     63  27000				   -	       rts
     64  27000				   -
     65  27000				   -AVoxDetect
     66  27000				   -
     67  27000				   -	       jsr	i2c_startwrite
     68  27000				   -	       bcs	eeprom_error
     69  27000				   -	       lda	#$30
     70  27000				   -	       jsr	i2c_txbyte
     71  27000				   -	       lda	#$00
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       jsr	i2c_stopwrite
     74  27000				   -	       rts
     75  27000				   -
     76  27000				   -	       include	"i2c7800.inc"
     77  27000				   -	       I2C_SUBS	temp9
     78  27000				   -
     79  27000					       endif
     80  27000
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
   3484  27000					       endif
   3485  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000					       ifconst	pokeysupport
      5  27000
      6  27000				    pokeysoundmodulestart
      7  27000
      8  27000				    mutepokey
      9  27000			a9 00		       lda	#0
     10  27002			a0 07		       ldy	#7
     11  27004				    mutepokeyloop
     12  27004			99 5b 00	       sta	pokey1pointlo,y
     13  27007			91 4b		       sta	(pokeybaselo),y
     14  27009			88		       dey
     15  2700a			10 f8		       bpl	mutepokeyloop
     16  2700c			60		       rts
     17  2700d
     18  2700d				    checkpokeyplaying
     19  2700d			a2 06		       ldx	#6
     20  2700f				    checkpokeyplayingloop
     21  2700f			b5 5b		       lda	pokey1pointlo,x
     22  27011			15 5c		       ora	pokey1pointhi,x
     23  27013			f0 03		       beq	pokeychannelinactive
     24  27015			20 1d f0	       jsr	playpokeysfxA	; x=channel*2
     25  27018				    pokeychannelinactive
     26  27018			ca		       dex
     27  27019			ca		       dex
     28  2701a			10 f3		       bpl	checkpokeyplayingloop
     29  2701c			60		       rts
     30  2701d
     31  2701d				    playpokeysfxA
     32  2701d			8a		       txa
     33  2701e			a8		       tay
     34  2701f			bd c2 01	       lda	pokey1tick,x
     35  27022			f0 07		       beq	playpokeysfxAcont
     36  27024			38		       sec
     37  27025			e9 01		       sbc	#1
     38  27027			9d c2 01	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     39  2702a			60		       rts
     40  2702b
     41  2702b				    playpokeysfxAcont
     42  2702b			bd c1 01	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     43  2702e			9d c2 01	       sta	pokey1tick,x
     44  27031
     45  27031			bd c9 01	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     46  27034			f0 06		       beq	playpokeysfxAcont2
     47  27036			38		       sec
     48  27037			e9 01		       sbc	#1
     49  27039			9d c9 01	       sta	pokey1priority,x
     50  2703c				    playpokeysfxAcont2
     51  2703c
     52  2703c							; *** FREQUENCY
     53  2703c			a1 5b		       lda	(pokey1pointlo,x)
     54  2703e			85 d8		       sta	inttemp1
     55  27040			18		       clc
     56  27041			7d ca 01	       adc	pokey1offset,x	; take into account any pitch modification
     57  27044			91 4b		       sta	(pokeybaselo),y	; PAUDF0,0
     58  27046
     59  27046							;advance the data pointer +1
     60  27046			f6 5b		       inc	pokey1pointlo,x
     61  27048			d0 02		       bne	skippokeyhiinc1
     62  2704a			f6 5c		       inc	pokey1pointhi,x
     63  2704c				    skippokeyhiinc1
     64  2704c
     65  2704c							; *** WAVE
     66  2704c			a1 5b		       lda	(pokey1pointlo,x)
     67  2704e			0a		       asl
     68  2704f			0a		       asl
     69  27050			0a		       asl
     70  27051			0a		       asl		; x16
     71  27052
     72  27052							;advance the data pointer +1
     73  27052			f6 5b		       inc	pokey1pointlo,x
     74  27054			d0 02		       bne	skippokeyhiinc2
     75  27056			f6 5c		       inc	pokey1pointhi,x
     76  27058				    skippokeyhiinc2
     77  27058
     78  27058			01 5b		       ora	(pokey1pointlo,x)
     79  2705a			c8		       iny
     80  2705b			91 4b		       sta	(pokeybaselo),y
     81  2705d
     82  2705d			05 d8		       ora	inttemp1	; check if F|C|V=0
     83  2705f			f0 07		       beq	zeropokeypoint	; if so, we're at the end of the sound.
     84  27061
     85  27061							; advance the pointer +1, on to the next sound chunk
     86  27061			f6 5b		       inc	pokey1pointlo,x
     87  27063			d0 02		       bne	skippokeyhiinc3
     88  27065			f6 5c		       inc	pokey1pointhi,x
     89  27067				    skippokeyhiinc3
     90  27067			60		       rts
     91  27068
     92  27068				    zeropokeypoint
     93  27068			95 5b		       sta	pokey1pointlo,x
     94  2706a			95 5c		       sta	pokey1pointhi,x
     95  2706c			9d c9 01	       sta	pokey1priority,x
     96  2706f			60		       rts
     97  27070
     98  27070				    schedulepokeysfx
     99  27070			a2 06		       ldx	#6
    100  27072				    schedulepokeysfxloop
    101  27072			b5 5b		       lda	pokey1pointlo,x
    102  27074			15 5c		       ora	pokey1pointhi,x
    103  27076			d0 03		       bne	schedulespokeysearch
    104  27078			4c a2 f0	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    105  2707b				    schedulespokeysearch
    106  2707b			ca		       dex
    107  2707c			ca		       dex
    108  2707d			10 f3		       bpl	schedulepokeysfxloop
    109  2707f
    110  2707f							; if we're here, all 4 channels are presently playing a sound...
    111  2707f			a0 01		       ldy	#1
    112  27081			b1 e0		       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    113  27083			d0 01		       bne	schedulepokeysfxcont1
    114  27085			60		       rts		; ...and skip it if it's 0 priority
    115  27086				    schedulepokeysfxcont1
    116  27086
    117  27086							; figure out which current sound has the lowest priority...
    118  27086			a9 00		       lda	#0
    119  27088			85 49		       sta	temp8
    120  2708a			ad c9 01	       lda	pokey1priority
    121  2708d			85 4a		       sta	temp9
    122  2708f			a2 06		       ldx	#6
    123  27091				    findlowprioritypokeyloop
    124  27091			bd c9 01	       lda	pokey1priority,x
    125  27094			c5 4a		       cmp	temp9
    126  27096			b0 04		       bcs	findlowprioritypokeyloopcontinue
    127  27098			85 4a		       sta	temp9
    128  2709a			86 49		       stx	temp8
    129  2709c				    findlowprioritypokeyloopcontinue
    130  2709c			ca		       dex
    131  2709d			ca		       dex
    132  2709e			d0 f1		       bne	findlowprioritypokeyloop
    133  270a0			a6 49		       ldx	temp8	; the low priority channel we'll interrupt
    134  270a2
    135  270a2				    schedulepokeyX
    136  270a2							;called with X=2*pokey channel to play on...
    137  270a2			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
    138  270a4			b1 e0		       lda	(sfxinstrumentlo),y
    139  270a6			9d c9 01	       sta	pokey1priority,x
    140  270a9			c8		       iny
    141  270aa			b1 e0		       lda	(sfxinstrumentlo),y
    142  270ac			9d c1 01	       sta	pokey1frames,x
    143  270af
    144  270af			a5 e0		       lda	sfxinstrumentlo
    145  270b1			18		       clc
    146  270b2			69 03		       adc	#3
    147  270b4			95 5b		       sta	pokey1pointlo,x
    148  270b6			a5 e1		       lda	sfxinstrumenthi
    149  270b8			69 00		       adc	#0
    150  270ba			95 5c		       sta	pokey1pointhi,x
    151  270bc			a5 44		       lda	temp3
    152  270be			9d ca 01	       sta	pokey1offset,x
    153  270c1			a9 00		       lda	#0
    154  270c3			9d c2 01	       sta	pokey1tick,x
    155  270c6			60		       rts
    156  270c7
    157  270c7							; pokey detection routine. we check for pokey in the XBOARD/XM location,
    158  270c7							; and the standard $4000 location.
    159  270c7							; if pokey the pokey is present, this routine will reset it.
    160  270c7
    161  270c7				    detectpokeylocation
    162  270c7							;XBoard/XM...
    163  270c7			a2 02		       ldx	#2
    164  270c9				    detectpokeyloop
    165  270c9			ad b4 01	       lda	XCTRL1s
    166  270cc			09 14		       ora	#%00010100
    167  270ce			3d f2 f0	       and	POKEYXMMASK,x
    168  270d1			8d b4 01	       sta	XCTRL1s
    169  270d4			8d 70 04	       sta	XCTRL1
    170  270d7
    171  270d7			bd f5 f0	       lda	POKEYCHECKLO,x
    172  270da			85 4b		       sta	pokeybaselo
    173  270dc			bd f8 f0	       lda	POKEYCHECKHI,x
    174  270df			85 4c		       sta	pokeybasehi
    175  270e1			20 fb f0	       jsr	checkforpokey
    176  270e4			ad 08 21	       lda	pokeydetected
    177  270e7			f0 03		       beq	foundpokeychip
    178  270e9			ca		       dex
    179  270ea			10 dd		       bpl	detectpokeyloop
    180  270ec				    foundpokeychip
    181  270ec			49 ff		       eor	#$ff	; invert state for 7800basic if...then test
    182  270ee			8d 08 21	       sta	pokeydetected
    183  270f1			60		       rts
    184  270f2
    185  270f2				    POKEYXMMASK
    186  270f2							;     XM POKEY on    XM POKEY off   XM POKEY off
    187  270f2			ff ef ef	       .byte.b	%11111111, %11101111, %11101111
    188  270f5
    189  270f5				    POKEYCHECKLO
    190  270f5			50 50 00	       .byte.b	<$0450, <$0450, <$4000
    191  270f8				    POKEYCHECKHI
    192  270f8			04 04 40	       .byte.b	>$0450, >$0450, >$4000
    193  270fb
    194  270fb				    checkforpokey
    195  270fb			a0 0f		       ldy	#$0f
    196  270fd			a9 00		       lda	#$00
    197  270ff			8d 08 21	       sta	pokeydetected	; start off by assuming pokey will be detected
    198  27102				    resetpokeyregistersloop
    199  27102			91 4b		       sta	(pokeybase),y
    200  27104			88		       dey
    201  27105			10 fb		       bpl	resetpokeyregistersloop
    202  27107
    203  27107			a0 08		       ldy	#PAUDCTL
    204  27109			91 4b		       sta	(pokeybase),y
    205  2710b			a0 0f		       ldy	#PSKCTL
    206  2710d			91 4b		       sta	(pokeybase),y
    207  2710f
    208  2710f							; let the dust settle...
    209  2710f			ea		       nop
    210  27110			ea		       nop
    211  27111			ea		       nop
    212  27112
    213  27112			a9 04		       lda	#4
    214  27114			85 4a		       sta	temp9
    215  27116				    pokeycheckloop1
    216  27116							; we're in reset, so the RANDOM register should read $ff...
    217  27116			a0 0a		       ldy	#PRANDOM
    218  27118			b1 4b		       lda	(pokeybase),y
    219  2711a			c9 ff		       cmp	#$ff
    220  2711c			d0 24		       bne	nopokeydetected
    221  2711e			c6 4a		       dec	temp9
    222  27120			d0 f4		       bne	pokeycheckloop1
    223  27122
    224  27122							; take pokey out of reset...
    225  27122			a0 0f		       ldy	#PSKCTL
    226  27124			a9 03		       lda	#3
    227  27126			91 4b		       sta	(pokeybase),y
    228  27128			a0 08		       ldy	#PAUDCTL
    229  2712a			a9 00		       lda	#0
    230  2712c			91 4b		       sta	(pokeybase),y
    231  2712e
    232  2712e							; let the dust settle again...
    233  2712e			ea		       nop
    234  2712f			ea		       nop
    235  27130			ea		       nop
    236  27131
    237  27131			a9 04		       lda	#4
    238  27133			85 4a		       sta	temp9
    239  27135				    pokeycheckloop2
    240  27135							; we're out of reset, so RANDOM should read non-$ff...
    241  27135			a0 0a		       ldy	#PRANDOM
    242  27137			b1 4b		       lda	(pokeybase),y
    243  27139			c9 ff		       cmp	#$ff
    244  2713b			f0 01		       beq	skippokeycheckreturn
    245  2713d			60		       rts
    246  2713e				    skippokeycheckreturn
    247  2713e			c6 4a		       dec	temp9
    248  27140			d0 f3		       bne	pokeycheckloop2
    249  27142				    nopokeydetected
    250  27142			ce 08 21	       dec	pokeydetected	; pokeydetected=#$ff
    251  27145			60		       rts
    252  27146
    253  27146				    pokeysoundmoduleend
    254  27146
   pokeysound assembly:  326  bytes
    255  27146					       echo	"  pokeysound assembly: ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes"
    256  27146
    257  27146					       endif
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
   3487  27146					       endif
   3488  27146					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27146					       include	tracker.asm
      1  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27146
      3  27146
      4  27146				   -	       ifconst	MUSICTRACKER
      5  27146				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      6  27146				   -			; ** the player operates on a 16th note grid.
      7  27146				   -
      8  27146				   -servicesongover
      9  27146				   -	       rts
     10  27146				   -servicesong
     11  27146				   -	       lda	songtempo
     12  27146				   -	       beq	servicesongover	; ** if song is off/paused then return
     13  27146				   -servicesongcontinue
     14  27146				   -	       lda	sfxschedulelock
     15  27146				   -	       sta	sfxschedulemissed
     16  27146				   -	       bne	servicesongover
     17  27146				   -	       lda	songtempo
     18  27146				   -	       clc
     19  27146				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     20  27146				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     21  27146				   -	       bcc	servicesongover
     22  27146				   -			; ** if we're here a new 16th note has passed
     23  27146				   -			; ** check if a new note is due on any of the 4 channels
     24  27146				   -servicesongredo
     25  27146				   -	       ldx	#3
     26  27146				   -checkchannelloop
     27  27146				   -	       dec	songchannel1busywait,x
     28  27146				   -	       bpl	carryoncheckingchannel
     29  27146				   -	       txa
     30  27146				   -	       pha		; save X for the loop
     31  27146				   -	       jsr	processsongdata
     32  27146				   -	       pla		; restore X for the loop
     33  27146				   -	       tax
     34  27146				   -carryoncheckingchannel
     35  27146				   -	       dex
     36  27146				   -	       bpl	checkchannelloop
     37  27146				   -	       lda	inactivechannelcount
     38  27146				   -	       cmp	#15
     39  27146				   -	       bne	skipstopsong
     40  27146				   -	       lda	songloops
     41  27146				   -	       bne	doasongloop
     42  27146				   -			;lda #0
     43  27146				   -	       sta	songtempo	; all channels are done. stop the song
     44  27146				   -	       rts
     45  27146				   -doasongloop
     46  27146				   -	       bmi	skipsongloopadjust
     47  27146				   -	       dec	songloops
     48  27146				   -skipsongloopadjust
     49  27146				   -	       jsr	setsongchannels
     50  27146				   -	       jmp	servicesongredo
     51  27146				   -skipstopsong
     52  27146				   -	       rts
     53  27146				   -
     54  27146				   -processsongdata
     55  27146				   -			; channel needs processing
     56  27146				   -			; X=channel #
     57  27146				   -
     58  27146				   -	       txa
     59  27146				   -	       clc
     60  27146				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     61  27146				   -	       tay
     62  27146				   -
     63  27146				   -
     64  27146				   -			; ** indirect x is cumbersome with mult-byte commands.
     65  27146				   -			; ** setup a pointer to the song data for indirect y addressing.
     66  27146				   -	       lda	songchannel1layer1lo,y
     67  27146				   -	       sta	songdatalo
     68  27146				   -	       lda	songchannel1layer1hi,y
     69  27146				   -	       sta	songdatahi
     70  27146				   -	       ora	songdatalo
     71  27146				   -	       bne	channelhasdata
     72  27146				   -			;channel data is pointing at $0000
     73  27146				   -	       lda	#$7F
     74  27146				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     75  27146				   -setchannelcountbits
     76  27146				   -	       lda	channel2bits,x
     77  27146				   -	       ora	inactivechannelcount
     78  27146				   -	       sta	inactivechannelcount
     79  27146				   -	       rts
     80  27146				   -channelhasdata
     81  27146				   -
     82  27146				   -	       sty	songstackindex
     83  27146				   -	       ldy	#0
     84  27146				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     85  27146				   -	       cmp	#$ff
     86  27146				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     87  27146				   -	       jmp	handlechannelEOD
     88  27146				   -
     89  27146				   -carryoncheckingdatatype
     90  27146				   -	       and	#$F0
     91  27146				   -	       cmp	#$C0
     92  27146				   -	       beq	handlechannelrest	; 0000XXXX=rest
     93  27146				   -	       cmp	#$F0
     94  27146				   -	       beq	handlemultibytecommand
     95  27146				   -	       cmp	#$D0
     96  27146				   -	       beq	handlesemiup
     97  27146				   -	       cmp	#$E0
     98  27146				   -	       beq	handlesemidown
     99  27146				   -handlenotedata
    100  27146				   -			; ** TODO: note playing is a terrible choice for fall-through
    101  27146				   -
    102  27146				   -			; ** its simple note data, prepare arguments for schedulesfx
    103  27146				   -
    104  27146				   -			; ** set the note length
    105  27146				   -	       lda	(songdatalo),y
    106  27146				   -	       and	#$0F
    107  27146				   -	       sta	songchannel1busywait,x
    108  27146				   -
    109  27146				   -			; ** load the instrument
    110  27146				   -	       lda	songchannel1instrumentlo,x
    111  27146				   -	       sta	sfxinstrumentlo
    112  27146				   -	       lda	songchannel1instrumenthi,x
    113  27146				   -	       sta	sfxinstrumenthi
    114  27146				   -
    115  27146				   -			; ** get the note, and transpose
    116  27146				   -	       lda	(songdatalo),y
    117  27146				   -	       lsr
    118  27146				   -	       lsr
    119  27146				   -	       lsr
    120  27146				   -	       lsr
    121  27146				   -	       clc
    122  27146				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    123  27146				   -			; ** its up the respective SFX scheduler to handle and save the note data
    124  27146				   -	       sta	sfxnoteindex
    125  27146				   -
    126  27146				   -	       lda	#0
    127  27146				   -	       sta	sfxpitchoffset
    128  27146				   -
    129  27146				   -	       jsr	schedulesfx
    130  27146				   -
    131  27146				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    132  27146				   -
    133  27146				   -handlechannelrest
    134  27146				   -			; ** set the note length
    135  27146				   -	       lda	(songdatalo),y
    136  27146				   -	       and	#$0F
    137  27146				   -	       sta	songchannel1busywait,x
    138  27146				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  27146				   -
    140  27146				   -handlesemiup
    141  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    142  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    143  27146				   -	       clc
    144  27146				   -handlesemidownentry
    145  27146				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    146  27146				   -	       sta	songchannel1transpose,x
    147  27146				   -	       jsr	advancethesongpointer1byte
    148  27146				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    149  27146				   -
    150  27146				   -handlesemidown
    151  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    152  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    153  27146				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    154  27146				   -	       sec
    155  27146				   -	       jmp	handlesemidownentry
    156  27146				   -
    157  27146				   -handlemultibytecommand
    158  27146				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  27146				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  27146				   -	       cmp	#$08	; ** load new instrument?
    161  27146				   -	       bne	nothandleinstrumentchange
    162  27146				   -handleinstrumentchange
    163  27146				   -	       iny
    164  27146				   -	       lda	(songdatalo),y
    165  27146				   -	       sta	songchannel1instrumentlo,x
    166  27146				   -	       iny
    167  27146				   -	       lda	(songdatalo),y
    168  27146				   -	       sta	songchannel1instrumenthi,x
    169  27146				   -	       lda	#3
    170  27146				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    171  27146				   -	       jmp	processsongdata
    172  27146				   -
    173  27146				   -nothandleinstrumentchange
    174  27146				   -	       cmp	#$09	; ** absolute tempo change?
    175  27146				   -	       bne	nothandletempochange
    176  27146				   -	       lda	#0
    177  27146				   -	       sta	songtempo
    178  27146				   -handlerelativetempochange
    179  27146				   -	       iny
    180  27146				   -	       lda	(songdatalo),y
    181  27146				   -	       clc
    182  27146				   -	       adc	songtempo
    183  27146				   -	       sta	songtempo
    184  27146				   -	       lda	#2
    185  27146				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    186  27146				   -	       jmp	processsongdata
    187  27146				   -
    188  27146				   -nothandletempochange
    189  27146				   -	       cmp	#$0A	; ** relative tempo change?:
    190  27146				   -	       beq	handlerelativetempochange
    191  27146				   -	       cmp	#$0B	; ** octave/semi change?
    192  27146				   -	       beq	handleoctavesemichange
    193  27146				   -handlepatterndata
    194  27146				   -			; ** if we're here its a pattern/loop "subroutine"
    195  27146				   -			; ** move the channel's "stack" pointer and populate the new stack level
    196  27146				   -
    197  27146				   -	       lda	#4
    198  27146				   -	       clc
    199  27146				   -	       adc	songchannel1stackdepth,x
    200  27146				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    201  27146				   -
    202  27146				   -	       stx	inttemp6	; about to invalidate x. save it.
    203  27146				   -	       lda	songstackindex
    204  27146				   -	       adc	#4
    205  27146				   -	       tax
    206  27146				   -
    207  27146				   -	       lda	(songdatalo),y
    208  27146				   -	       and	#$7
    209  27146				   -	       sta	songchannel1layer1loops,x
    210  27146				   -	       iny
    211  27146				   -	       lda	(songdatalo),y
    212  27146				   -	       sta	songchannel1layer1lo,x
    213  27146				   -	       iny
    214  27146				   -	       lda	(songdatalo),y
    215  27146				   -	       sta	songchannel1layer1hi,x
    216  27146				   -
    217  27146				   -	       ldx	inttemp6	; restore x with the channel #
    218  27146				   -
    219  27146				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    220  27146				   -	       lda	#3
    221  27146				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    222  27146				   -
    223  27146				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    224  27146				   -	       jmp	processsongdata
    225  27146				   -
    226  27146				   -handlechannelEOD
    227  27146				   -			; ** check if there are loops remaining on the pattern
    228  27146				   -	       stx	inttemp6
    229  27146				   -	       ldx	songstackindex
    230  27146				   -	       dec	songchannel1layer1loops,x
    231  27146				   -	       bmi	handlechannelEODnoloop
    232  27146				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    233  27146				   -	       iny
    234  27146				   -	       lda	(songdatalo),y
    235  27146				   -	       sta	songchannel1layer1lo,x
    236  27146				   -	       iny
    237  27146				   -	       lda	(songdatalo),y
    238  27146				   -	       sta	songchannel1layer1hi,x
    239  27146				   -	       ldx	inttemp6
    240  27146				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    241  27146				   -
    242  27146				   -handlechannelEODnoloop
    243  27146				   -			; this pattern/loop is done playing. "pop" the stack
    244  27146				   -	       ldx	inttemp6
    245  27146				   -	       lda	songchannel1stackdepth,x
    246  27146				   -	       beq	handlerootchannelEOD
    247  27146				   -	       sec
    248  27146				   -	       sbc	#4
    249  27146				   -	       sta	songchannel1stackdepth,x
    250  27146				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    251  27146				   -
    252  27146				   -handlerootchannelEOD
    253  27146				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    254  27146				   -	       lda	#0
    255  27146				   -	       sta	songchannel1layer1lo,x
    256  27146				   -	       sta	songchannel1layer1hi,x
    257  27146				   -	       sta	songchannel1busywait,x
    258  27146				   -	       jmp	setchannelcountbits
    259  27146				   -	       rts
    260  27146				   -
    261  27146				   -nothandlepatternchange
    262  27146				   -handleoctavesemichange
    263  27146				   -	       iny
    264  27146				   -	       lda	(songdatalo),y
    265  27146				   -	       sta	songchannel1transpose,x
    266  27146				   -	       lda	#2
    267  27146				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    268  27146				   -	       jmp	processsongdata
    269  27146				   -
    270  27146				   -advancethesongpointer1byte
    271  27146				   -	       txa
    272  27146				   -	       ldx	songstackindex
    273  27146				   -	       inc	songchannel1layer1lo,x
    274  27146				   -	       bne	skiphiadvancethesongpointer1byte
    275  27146				   -	       inc	songchannel1layer1hi,x
    276  27146				   -skiphiadvancethesongpointer1byte
    277  27146				   -	       tax
    278  27146				   -	       rts
    279  27146				   -
    280  27146				   -advancethesongpointerNbytes
    281  27146				   -			; entered with A=# of byte to advance
    282  27146				   -	       stx	inttemp6
    283  27146				   -	       ldx	songstackindex
    284  27146				   -	       clc
    285  27146				   -	       adc	songchannel1layer1lo,x
    286  27146				   -	       sta	songchannel1layer1lo,x
    287  27146				   -	       lda	#0
    288  27146				   -	       adc	songchannel1layer1hi,x
    289  27146				   -	       sta	songchannel1layer1hi,x
    290  27146				   -	       ldx	inttemp6
    291  27146				   -	       rts
    292  27146				   -
    293  27146				   -clearsongmemory
    294  27146				   -	       lda	#0
    295  27146				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    296  27146				   -clearsongmemoryloop1
    297  27146				   -	       sta	songchannel1layer1lo,x
    298  27146				   -	       dex
    299  27146				   -	       bpl	clearsongmemoryloop1
    300  27146				   -
    301  27146				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    302  27146				   -clearsongmemoryloop2
    303  27146				   -	       sta	songchannel1layer1loops,x
    304  27146				   -	       dex
    305  27146				   -	       bpl	clearsongmemoryloop2
    306  27146				   -
    307  27146				   -	       lda	#$ff
    308  27146				   -	       ldx	#3
    309  27146				   -clearsongmemoryloop3
    310  27146				   -	       sta	songchannel1busywait,x
    311  27146				   -	       dex
    312  27146				   -	       bpl	clearsongmemoryloop3
    313  27146				   -	       rts
    314  27146				   -
    315  27146				   -setsongchannels
    316  27146				   -	       jsr	clearsongmemory
    317  27146				   -	       ldy	#7
    318  27146				   -	       ldx	#3
    319  27146				   -setsongchannelsloop
    320  27146				   -	       lda	(songpointerlo),y
    321  27146				   -	       sta	songchannel1layer1hi,x
    322  27146				   -	       dey
    323  27146				   -	       lda	(songpointerlo),y
    324  27146				   -	       sta	songchannel1layer1lo,x
    325  27146				   -	       dex
    326  27146				   -	       dey
    327  27146				   -	       bpl	setsongchannelsloop
    328  27146				   -	       rts
    329  27146				   -
    330  27146				   -channel2bits
    331  27146				   -	       .byte	1,2,4,8
    332  27146				   -
    333  27146				   -tiatrackeroctavenotes
    334  27146				   -	       ifconst	BUZZBASS
    335  27146				   -LOWC       =	15
    336  27146				   -	       else
    337  27146				   -LOWC       =	14
    338  27146				   -	       endif
    339  27146				   -			; ****** ELECTRONIC (0 to 11)
    340  27146				   -	       .byte	LOWC,20	; c0	 16.1Hz
    341  27146				   -	       .byte	LOWC,18	; c#0
    342  27146				   -	       .byte	LOWC,17	; d0
    343  27146				   -	       .byte	LOWC,16	; d#0
    344  27146				   -	       .byte	LOWC,15	; e0
    345  27146				   -	       .byte	LOWC,14	; f0  (very off)
    346  27146				   -	       .byte	LOWC,14	; f#0
    347  27146				   -	       .byte	LOWC,13	; g0
    348  27146				   -	       .byte	LOWC,12	; g#0
    349  27146				   -	       .byte	LOWC,11	; a0
    350  27146				   -	       .byte	LOWC,11	; a#0 (very off)
    351  27146				   -	       .byte	LOWC,10	; b0	 30.7Hz
    352  27146				   -
    353  27146				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    354  27146				   -	       .byte	6,30	; c1	 32.7Hz
    355  27146				   -	       .byte	6,28	; c#1
    356  27146				   -	       .byte	6,27	; d1
    357  27146				   -	       .byte	6,25	; d#1
    358  27146				   -	       .byte	6,24	; e1
    359  27146				   -	       .byte	6,22	; f1
    360  27146				   -	       .byte	6,21	; f#1
    361  27146				   -	       .byte	6,20	; g1
    362  27146				   -	       .byte	6,18	; g#1
    363  27146				   -	       .byte	6,17	; a1
    364  27146				   -	       .byte	6,16	; a#1
    365  27146				   -	       .byte	6,15	; b1	 63.4Hz
    366  27146				   -
    367  27146				   -			; ****** BUZZY (24 to 39)
    368  27146				   -	       .byte	1,31	; c2	 65.5
    369  27146				   -	       .byte	1,30	; c#2	 67.6
    370  27146				   -	       .byte	1,27	; d2	 72.3
    371  27146				   -	       .byte	1,26	; d#2	 77.6
    372  27146				   -	       .byte	1,24	; e2
    373  27146				   -	       .byte	1,23	; f2
    374  27146				   -	       .byte	1,22	; f#2
    375  27146				   -	       .byte	1,20	; g2
    376  27146				   -	       .byte	1,19	; g#2
    377  27146				   -	       .byte	1,18	; a2
    378  27146				   -	       .byte	1,17	; a#2
    379  27146				   -	       .byte	1,16	; b2
    380  27146				   -	       .byte	1,15	; c3	126.8Hz
    381  27146				   -	       .byte	1,14	; c#3
    382  27146				   -	       .byte	1,13	; d3	149.7Hz
    383  27146				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    384  27146				   -			; ****** PURE (40 to 71) - best key is A3 Major
    385  27146				   -	       .byte	12,31	; e3	163.8Hz
    386  27146				   -	       .byte	12,29	; f3
    387  27146				   -	       .byte	12,28	; f#3
    388  27146				   -	       .byte	12,26	; g3
    389  27146				   -	       .byte	12,24	; g#3
    390  27146				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    391  27146				   -	       .byte	12,22	; a#3
    392  27146				   -	       .byte	12,20	; b3
    393  27146				   -	       .byte	12,19	; c4  (middle C)
    394  27146				   -	       .byte	12,18	; c#4
    395  27146				   -	       .byte	12,17	; d4
    396  27146				   -	       .byte	12,16	; d#4
    397  27146				   -	       .byte	12,15	; e4
    398  27146				   -	       .byte	12,14	; f4
    399  27146				   -	       .byte	12,13	; f#4
    400  27146				   -	       .byte	12,12	; g4  (very off)
    401  27146				   -	       .byte	12,12	; g#4
    402  27146				   -	       .byte	12,11	; a4
    403  27146				   -	       .byte	12,10	; a#4
    404  27146				   -	       .byte	4,31	; b4
    405  27146				   -	       .byte	4,29	; c5
    406  27146				   -	       .byte	4,28	; c#5
    407  27146				   -	       .byte	4,26	; d5
    408  27146				   -	       .byte	4,24	; d#5
    409  27146				   -	       .byte	4,23	; e5
    410  27146				   -	       .byte	4,22	; f5
    411  27146				   -	       .byte	4,20	; f#5
    412  27146				   -	       .byte	4,19	; g5
    413  27146				   -	       .byte	4,18	; g#5
    414  27146				   -	       .byte	4,17	; a5
    415  27146				   -	       .byte	4,16	; a#5
    416  27146				   -	       .byte	4,15	; b5
    417  27146				   -
    418  27146				   -			; ****** TUNED WIND (72 to 83)
    419  27146				   -	       .byte	8,30	; c
    420  27146				   -	       .byte	8,28	; c#
    421  27146				   -	       .byte	8,27	; d
    422  27146				   -	       .byte	8,25	; d#
    423  27146				   -	       .byte	8,24	; e
    424  27146				   -	       .byte	8,22	; f
    425  27146				   -	       .byte	8,21	; f#
    426  27146				   -	       .byte	8,20	; g
    427  27146				   -	       .byte	8,18	; g#
    428  27146				   -	       .byte	8,17	; a
    429  27146				   -	       .byte	8,16	; a#
    430  27146				   -	       .byte	8,15	; b
    431  27146				   -
    432  27146				   -	       include	"tiadrumkit.asm"
    433  27146				   -
    434  27146					       endif		;MUSICTRACKER
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
   3490  27146					       endif
   3491  27146					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27146					       include	hiscore.asm
      1  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27146
      3  27146				   -	       ifconst	HSSUPPORT
      4  27146				   -detectatarivoxeeprom
      5  27146				   -hiscoremodulestart
      6  27146				   -			; do a test to see if atarivox eeprom can be accessed, and save results
      7  27146				   -	       jsr	AVoxDetect
      8  27146				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
      9  27146				   -	       sta	avoxdetected
     10  27146				   -	       lda	#$0
     11  27146				   -	       sta	SWACNT
     12  27146				   -	       lda	avoxdetected
     13  27146				   -	       rts
     14  27146				   -
     15  27146				   -detecthsc
     16  27146				   -			; check for the HSC ROM signature...
     17  27146				   -	       lda	XCTRL1s
     18  27146				   -	       ora	#%00001100
     19  27146				   -	       sta	XCTRL1s
     20  27146				   -	       sta	XCTRL1
     21  27146				   -	       lda	$3900
     22  27146				   -	       eor	#$C6
     23  27146				   -	       bne	detecthscfail
     24  27146				   -	       lda	$3904
     25  27146				   -	       eor	#$FE
     26  27146				   -	       bne	detecthscfail
     27  27146				   -			; check if it's initialized...
     28  27146				   -	       ldy	#0
     29  27146				   -	       lda	#$ff
     30  27146				   -checkhscinit
     31  27146				   -	       and	$1000,y
     32  27146				   -	       dey
     33  27146				   -	       bpl	checkhscinit
     34  27146				   -	       cmp	#$ff
     35  27146				   -	       bne	hscisalreadyinit
     36  27146				   -			; if we're here, we need to do a minimal HSC init...
     37  27146				   -	       ldy	#$28
     38  27146				   -hscinitloop1
     39  27146				   -	       lda	hscheader,y
     40  27146				   -	       sta	$1000,y
     41  27146				   -	       dey
     42  27146				   -	       bpl	hscinitloop1
     43  27146				   -	       ldy	#$89
     44  27146				   -	       lda	#$7F
     45  27146				   -hscinitloop2
     46  27146				   -	       sta	$10B3,y
     47  27146				   -	       dey
     48  27146				   -	       cpy	#$ff
     49  27146				   -	       bne	hscinitloop2
     50  27146				   -hscisalreadyinit
     51  27146				   -	       lda	#$ff
     52  27146				   -	       rts
     53  27146				   -hscheader
     54  27146				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     55  27146				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     56  27146				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     57  27146				   -detecthscfail
     58  27146				   -	       lda	XCTRL1s
     59  27146				   -	       and	#%11110111
     60  27146				   -	       sta	XCTRL1s
     61  27146				   -	       lda	#0
     62  27146				   -	       rts
     63  27146					       endif		; HSSUPPORT
     64  27146
     65  27146				   -	       ifconst	HSSUPPORT
     66  27146				   -	       ifnconst	hiscorefont
     67  27146				   -	       echo	""
     68  27146				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     69  27146				   -	       echo	" NOT imported with incgraphic. The high score display code"
     70  27146				   -	       echo	" has been omitted from this build."
     71  27146				   -	       echo	""
     72  27146				   -	       else
     73  27146				   -hscdrawscreen
     74  27146				   -
     75  27146				   -			; we use 20 lines on a 24 line display
     76  27146				   -			; HSSCOREY to dynamically centers based on
     77  27146				   -			;HSSCOREY = 0
     78  27146				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
     79  27146				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
     80  27146				   -
     81  27146				   -	       ifconst	HSSCORESIZE
     82  27146				   -SCORESIZE  =	HSSCORESIZE
     83  27146				   -	       else
     84  27146				   -SCORESIZE  =	6
     85  27146				   -	       endif
     86  27146				   -
     87  27146				   -			;save shadow registers for later return...
     88  27146				   -	       lda	sCTRL
     89  27146				   -	       sta	ssCTRL
     90  27146				   -	       lda	sCHARBASE
     91  27146				   -	       sta	ssCHARBASE
     92  27146				   -	       lda	#$60
     93  27146				   -	       sta	charactermode
     94  27146				   -	       jsr	drawwait
     95  27146				   -	       jsr	blacken320colors
     96  27146				   -	       jsr	clearscreen
     97  27146				   -
     98  27146				   -			;set the character base to the HSC font
     99  27146				   -	       lda	#>hiscorefont
    100  27146				   -	       sta	CHARBASE
    101  27146				   -	       sta	sCHARBASE
    102  27146				   -	       lda	#%01000011	;Enable DMA, mode=320A
    103  27146				   -	       sta	CTRL
    104  27146				   -	       sta	sCTRL
    105  27146				   -
    106  27146				   -	       lda	#60
    107  27146				   -	       sta	hsjoydebounce
    108  27146				   -
    109  27146				   -	       lda	#0
    110  27146				   -	       sta	hscursorx
    111  27146				   -	       sta	framecounter
    112  27146				   -	       ifnconst	HSCOLORCHASESTART
    113  27146				   -	       lda	#$8D	; default is blue. why not?
    114  27146				   -	       else
    115  27146				   -	       lda	#HSCOLORCHASESTART
    116  27146				   -	       endif
    117  27146				   -	       sta	hscolorchaseindex
    118  27146				   -
    119  27146				   -	       lda	#$0F
    120  27146				   -	       sta	P0C2	; base text is white
    121  27146				   -
    122  27146				   -	       jsr	hschasecolors
    123  27146				   -			; ** plot all of the initials
    124  27146				   -	       lda	#<HSRAMInitials
    125  27146				   -	       sta	temp1	; charmaplo
    126  27146				   -	       lda	#>HSRAMInitials
    127  27146				   -	       sta	temp2	; charmaphi
    128  27146				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    129  27146				   -	       sta	temp3	; palette/width
    130  27146				   -	       lda	#104
    131  27146				   -	       sta	temp4	; X
    132  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    133  27146				   -	       sta	temp5	; Y
    134  27146				   -plothsinitialsloop
    135  27146				   -	       jsr	plotcharacters
    136  27146				   -	       clc
    137  27146				   -	       lda	temp3
    138  27146				   -	       adc	#32
    139  27146				   -	       sta	temp3
    140  27146				   -	       inc	temp5
    141  27146				   -	       if	WZONEHEIGHT = 8
    142  27146				   -	       inc	temp5
    143  27146				   -	       endif
    144  27146				   -	       clc
    145  27146				   -	       lda	#3
    146  27146				   -	       adc	temp1
    147  27146				   -	       sta	temp1
    148  27146				   -	       cmp	#(<(HSRAMInitials+15))
    149  27146				   -	       bcc	plothsinitialsloop
    150  27146				   -
    151  27146				   -	       ifconst	HSGAMENAMELEN
    152  27146				   -			;plot the game name...
    153  27146				   -	       lda	#<HSGAMENAMEtable
    154  27146				   -	       sta	temp1	; charmaplo
    155  27146				   -	       lda	#>HSGAMENAMEtable
    156  27146				   -	       sta	temp2	; charmaphi
    157  27146				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    158  27146				   -	       sta	temp3	; palette/width
    159  27146				   -	       lda	#(80-(HSGAMENAMELEN*2))
    160  27146				   -	       sta	temp4	; X
    161  27146				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    162  27146				   -	       sta	temp5	; Y
    163  27146				   -	       jsr	plotcharacters
    164  27146				   -	       endif		; HSGAMENAMELEN
    165  27146				   -
    166  27146				   -			;plot "difficulty"...
    167  27146				   -	       ldy	gamedifficulty
    168  27146				   -	       ifnconst	HSNOLEVELNAMES
    169  27146				   -	       lda	highscoredifficultytextlo,y
    170  27146				   -	       sta	temp1
    171  27146				   -	       lda	highscoredifficultytexthi,y
    172  27146				   -	       sta	temp2
    173  27146				   -	       sec
    174  27146				   -	       lda	#32
    175  27146				   -	       sbc	highscoredifficultytextlen,y
    176  27146				   -	       sta	temp3	; palette/width
    177  27146				   -	       sec
    178  27146				   -	       lda	#40
    179  27146				   -	       sbc	highscoredifficultytextlen,y
    180  27146				   -	       asl
    181  27146				   -	       sta	temp4	; X
    182  27146				   -	       else
    183  27146				   -	       lda	#<HSHIGHSCOREStext
    184  27146				   -	       sta	temp1	; charmaplo
    185  27146				   -	       lda	#>HSHIGHSCOREStext
    186  27146				   -	       sta	temp2	; charmaphi
    187  27146				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    188  27146				   -	       sta	temp3	; palette/width
    189  27146				   -	       lda	#(80-(11*2))
    190  27146				   -	       sta	temp4	; X
    191  27146				   -	       endif		; HSNOLEVELNAMES
    192  27146				   -
    193  27146				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    194  27146				   -	       sta	temp5	; Y
    195  27146				   -	       jsr	plotcharacters
    196  27146				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    197  27146				   -	       bne	carronwithscoreevaluation
    198  27146				   -	       jmp	donoscoreevaluation
    199  27146				   -carronwithscoreevaluation
    200  27146				   -	       dey
    201  27146				   -	       lda	highscorelabeltextlo,y
    202  27146				   -	       sta	temp1
    203  27146				   -	       lda	highscorelabeltexthi,y
    204  27146				   -	       sta	temp2
    205  27146				   -	       sec
    206  27146				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    207  27146				   -	       sta	temp3	; palette/width
    208  27146				   -	       lda	highscorelabeladjust1,y
    209  27146				   -	       sta	temp4	; X
    210  27146				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    211  27146				   -	       sta	temp5	; Y
    212  27146				   -	       jsr	plotcharacters
    213  27146				   -
    214  27146				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    215  27146				   -	       dey
    216  27146				   -			;plot the current player score...
    217  27146				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    218  27146				   -	       sta	temp3	; palette/width
    219  27146				   -	       lda	highscorelabeladjust2,y
    220  27146				   -	       sta	temp4	; X
    221  27146				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    222  27146				   -	       sta	temp5	; Y
    223  27146				   -
    224  27146				   -	       lda	scorevarlo,y
    225  27146				   -	       sta	temp7	; score variable lo
    226  27146				   -	       lda	scorevarhi,y
    227  27146				   -	       sta	temp8	; score variable hi
    228  27146				   -
    229  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    230  27146				   -	       sta	temp9
    231  27146				   -
    232  27146				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    233  27146				   -	       sta	temp1	; charmaplo
    234  27146				   -	       lda	#>(hiscorefont+33)
    235  27146				   -	       sta	temp2	; charmaphi
    236  27146				   -	       lda	#SCORESIZE
    237  27146				   -	       sta	temp6
    238  27146				   -	       ifnconst	DOUBLEWIDE
    239  27146				   -	       jsr	plotvalue
    240  27146				   -	       else
    241  27146				   -	       jsr	plotvaluedw
    242  27146				   -	       endif
    243  27146				   -
    244  27146				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    245  27146				   -
    246  27146				   -	       ifconst	HSGAMERANKS
    247  27146				   -
    248  27146				   -	       ldx	#$ff	; start at 0 after the inx...
    249  27146				   -comparescore2rankloop
    250  27146				   -	       inx
    251  27146				   -	       ldy	#0
    252  27146				   -	       lda	rankvalue_0,x
    253  27146				   -	       cmp	(temp7),y
    254  27146				   -	       bcc	score2rankloopdone
    255  27146				   -	       bne	comparescore2rankloop
    256  27146				   -	       iny
    257  27146				   -	       lda	rankvalue_1,x
    258  27146				   -	       cmp	(temp7),y
    259  27146				   -	       bcc	score2rankloopdone
    260  27146				   -	       bne	comparescore2rankloop
    261  27146				   -	       iny
    262  27146				   -	       lda	(temp7),y
    263  27146				   -	       cmp	rankvalue_2,x
    264  27146				   -	       bcs	score2rankloopdone
    265  27146				   -	       jmp	comparescore2rankloop
    266  27146				   -score2rankloopdone
    267  27146				   -	       stx	hsnewscorerank
    268  27146				   -
    269  27146				   -	       lda	ranklabello,x
    270  27146				   -	       sta	temp1
    271  27146				   -	       lda	ranklabelhi,x
    272  27146				   -	       sta	temp2
    273  27146				   -	       sec
    274  27146				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    275  27146				   -	       sbc	ranklabellengths,x
    276  27146				   -	       sta	temp3	; palette/width
    277  27146				   -	       sec
    278  27146				   -	       lda	#(40+6)
    279  27146				   -	       sbc	ranklabellengths,x
    280  27146				   -	       asl
    281  27146				   -	       sta	temp4	; X
    282  27146				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    283  27146				   -	       sta	temp5	; Y
    284  27146				   -	       jsr	plotcharacters
    285  27146				   -
    286  27146				   -	       ldx	hsnewscorerank
    287  27146				   -
    288  27146				   -	       lda	#<highscoreranklabel
    289  27146				   -	       sta	temp1
    290  27146				   -	       lda	#>highscoreranklabel
    291  27146				   -	       sta	temp2
    292  27146				   -
    293  27146				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    294  27146				   -	       sta	temp3	; palette/width
    295  27146				   -	       lda	#(40-6)
    296  27146				   -	       sec
    297  27146				   -	       sbc	ranklabellengths,x
    298  27146				   -	       asl
    299  27146				   -	       sta	temp4	; X
    300  27146				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    301  27146				   -	       sta	temp5	; Y
    302  27146				   -	       jsr	plotcharacters
    303  27146				   -	       endif
    304  27146				   -
    305  27146				   -
    306  27146				   -			; ** which line did this player beat?
    307  27146				   -	       lda	#$ff
    308  27146				   -	       sta	hsnewscoreline
    309  27146				   -	       ldx	#$fd
    310  27146				   -comparescoreadd2x
    311  27146				   -	       inx
    312  27146				   -comparescoreadd1x
    313  27146				   -	       inx
    314  27146				   -comparescore2lineloop
    315  27146				   -	       inc	hsnewscoreline
    316  27146				   -	       inx		; initialrun, x=0
    317  27146				   -	       cpx	#15
    318  27146				   -	       beq	nohighscoreforyou
    319  27146				   -	       ldy	#0
    320  27146				   -	       lda	HSRAMScores,x
    321  27146				   -	       cmp	(temp7),y	; first score digit
    322  27146				   -	       bcc	score2lineloopdonedel1x
    323  27146				   -	       bne	comparescoreadd2x
    324  27146				   -	       iny
    325  27146				   -	       inx
    326  27146				   -	       lda	HSRAMScores,x
    327  27146				   -	       cmp	(temp7),y
    328  27146				   -	       bcc	score2lineloopdonedel2x
    329  27146				   -	       bne	comparescoreadd1x
    330  27146				   -	       iny
    331  27146				   -	       inx
    332  27146				   -	       lda	(temp7),y
    333  27146				   -	       cmp	HSRAMScores,x
    334  27146				   -	       bcs	score2lineloopdonedel3x
    335  27146				   -	       jmp	comparescore2lineloop
    336  27146				   -nohighscoreforyou
    337  27146				   -	       lda	#$ff
    338  27146				   -	       sta	hsnewscoreline
    339  27146				   -	       sta	countdownseconds
    340  27146				   -	       jmp	donoscoreevaluation
    341  27146				   -score2lineloopdonedel3x
    342  27146				   -	       dex
    343  27146				   -score2lineloopdonedel2x
    344  27146				   -	       dex
    345  27146				   -score2lineloopdonedel1x
    346  27146				   -	       dex
    347  27146				   -
    348  27146				   -			; 0 1 2
    349  27146				   -			; 3 4 5
    350  27146				   -			; 6 7 8
    351  27146				   -			; 9 0 1
    352  27146				   -			; 2 3 4
    353  27146				   -
    354  27146				   -	       stx	temp9
    355  27146				   -	       cpx	#11
    356  27146				   -	       beq	postsortscoresuploop
    357  27146				   -	       ldx	#11
    358  27146				   -sortscoresuploop
    359  27146				   -	       lda	HSRAMScores,x
    360  27146				   -	       sta	HSRAMScores+3,x
    361  27146				   -	       lda	HSRAMInitials,x
    362  27146				   -	       sta	HSRAMInitials+3,x
    363  27146				   -	       dex
    364  27146				   -	       cpx	temp9
    365  27146				   -	       bne	sortscoresuploop
    366  27146				   -postsortscoresuploop
    367  27146				   -
    368  27146				   -			;stick the score and cleared initials in the slot...
    369  27146				   -	       inx
    370  27146				   -	       ldy	#0
    371  27146				   -	       sty	hsinitialhold
    372  27146				   -	       lda	(temp7),y
    373  27146				   -	       sta	HSRAMScores,x
    374  27146				   -	       iny
    375  27146				   -	       lda	(temp7),y
    376  27146				   -	       sta	HSRAMScores+1,x
    377  27146				   -	       iny
    378  27146				   -	       lda	(temp7),y
    379  27146				   -	       sta	HSRAMScores+2,x
    380  27146				   -	       lda	#0
    381  27146				   -	       sta	HSRAMInitials,x
    382  27146				   -	       lda	#29
    383  27146				   -	       sta	HSRAMInitials+1,x
    384  27146				   -	       sta	HSRAMInitials+2,x
    385  27146				   -
    386  27146				   -	       stx	hsinitialpos
    387  27146				   -
    388  27146				   -	       ifconst	vox_highscore
    389  27146				   -	       lda	<#vox_highscore
    390  27146				   -	       sta	speech_addr
    391  27146				   -	       lda	>#vox_highscore
    392  27146				   -	       sta	speech_addr+1
    393  27146				   -	       endif
    394  27146				   -	       ifconst	sfx_highscore
    395  27146				   -	       lda	<#sfx_highscore
    396  27146				   -	       sta	temp1
    397  27146				   -	       lda	>#sfx_highscore
    398  27146				   -	       sta	temp2
    399  27146				   -	       lda	#0
    400  27146				   -	       sta	temp3
    401  27146				   -	       jsr	schedulesfx
    402  27146				   -	       endif
    403  27146				   -	       ifconst	songdatastart_song_highscore
    404  27146				   -	       lda	#<songchanneltable_song_highscore
    405  27146				   -	       sta	songpointerlo
    406  27146				   -	       lda	#>songchanneltable_song_highscore
    407  27146				   -	       sta	songpointerhi
    408  27146				   -	       lda	#73
    409  27146				   -	       sta	songtempo
    410  27146				   -	       jsr	setsongchannels
    411  27146				   -	       endif
    412  27146				   -
    413  27146				   -
    414  27146				   -donoscoreevaluation
    415  27146				   -
    416  27146				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    417  27146				   -	       sta	temp3	; palette/width
    418  27146				   -	       lda	#(72+(4*(6-SCORESIZE)))
    419  27146				   -	       sta	temp4	; X
    420  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    421  27146				   -	       sta	temp5	; Y
    422  27146				   -	       lda	#<HSRAMScores
    423  27146				   -	       sta	temp7	; score variable lo
    424  27146				   -	       lda	#>HSRAMScores
    425  27146				   -	       sta	temp8	; score variable hi
    426  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    427  27146				   -	       sta	temp9
    428  27146				   -plothsscoresloop
    429  27146				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    430  27146				   -	       sta	temp1	; charmaplo
    431  27146				   -	       lda	#>(hiscorefont+33)
    432  27146				   -	       sta	temp2	; charmaphi
    433  27146				   -	       lda	#6
    434  27146				   -	       sta	temp6
    435  27146				   -	       ifnconst	DOUBLEWIDE
    436  27146				   -	       jsr	plotvalue
    437  27146				   -	       else
    438  27146				   -	       jsr	plotvaluedw
    439  27146				   -	       endif
    440  27146				   -	       clc
    441  27146				   -	       lda	temp3
    442  27146				   -	       adc	#32
    443  27146				   -	       sta	temp3
    444  27146				   -	       inc	temp5
    445  27146				   -	       if	WZONEHEIGHT = 8
    446  27146				   -	       inc	temp5
    447  27146				   -	       endif
    448  27146				   -	       clc
    449  27146				   -	       lda	#3
    450  27146				   -	       adc	temp7
    451  27146				   -	       sta	temp7
    452  27146				   -	       cmp	#(<(HSRAMScores+15))
    453  27146				   -	       bcc	plothsscoresloop
    454  27146				   -plothsindex
    455  27146				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    456  27146				   -	       sta	temp3	; palette/width
    457  27146				   -	       lda	#44
    458  27146				   -	       sta	temp4	; X
    459  27146				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    460  27146				   -	       sta	temp5	; Y
    461  27146				   -	       lda	#<hsgameslotnumbers
    462  27146				   -	       sta	temp7	; score variable lo
    463  27146				   -	       lda	#>hsgameslotnumbers
    464  27146				   -	       sta	temp8	; score variable hi
    465  27146				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    466  27146				   -	       sta	temp9
    467  27146				   -plothsindexloop
    468  27146				   -	       lda	#<(hiscorefont+33)
    469  27146				   -	       sta	temp1	; charmaplo
    470  27146				   -	       lda	#>(hiscorefont+33)
    471  27146				   -	       sta	temp2	; charmaphi
    472  27146				   -	       lda	#1
    473  27146				   -	       sta	temp6	; number of characters
    474  27146				   -	       ifnconst	DOUBLEWIDE
    475  27146				   -	       jsr	plotvalue
    476  27146				   -	       else
    477  27146				   -	       jsr	plotvaluedw
    478  27146				   -	       endif
    479  27146				   -	       clc
    480  27146				   -	       lda	temp3
    481  27146				   -	       adc	#32
    482  27146				   -	       sta	temp3
    483  27146				   -	       inc	temp5
    484  27146				   -	       if	WZONEHEIGHT = 8
    485  27146				   -	       inc	temp5
    486  27146				   -	       endif
    487  27146				   -	       inc	temp7
    488  27146				   -	       lda	temp7
    489  27146				   -	       cmp	#(<(hsgameslotnumbers+5))
    490  27146				   -	       bcc	plothsindexloop
    491  27146				   -
    492  27146				   -	       jsr	savescreen
    493  27146				   -	       ifnconst	HSSECONDS
    494  27146				   -	       lda	#6
    495  27146				   -	       else
    496  27146				   -	       lda	#HSSECONDS
    497  27146				   -	       endif
    498  27146				   -
    499  27146				   -	       sta	countdownseconds
    500  27146				   -
    501  27146				   -keepdisplayinghs
    502  27146				   -	       jsr	restorescreen
    503  27146				   -
    504  27146				   -	       jsr	setuphsinpt1
    505  27146				   -
    506  27146				   -	       lda	hsnewscoreline
    507  27146				   -	       bpl	carryonkeepdisplayinghs
    508  27146				   -	       jmp	skipenterscorecontrol
    509  27146				   -carryonkeepdisplayinghs
    510  27146				   -
    511  27146				   -
    512  27146				   -	       ifnconst	HSSECONDS
    513  27146				   -	       lda	#6
    514  27146				   -	       else
    515  27146				   -	       lda	#HSSECONDS
    516  27146				   -	       endif
    517  27146				   -
    518  27146				   -	       sta	countdownseconds
    519  27146				   -
    520  27146				   -			;plot the "cursor" initial sprite...
    521  27146				   -	       lda	hsinitialhold
    522  27146				   -
    523  27146				   -	       sta	temp1
    524  27146				   -	       lda	#>(hiscorefont+32)
    525  27146				   -	       sta	temp2
    526  27146				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    527  27146				   -	       sta	temp3	; palette/width
    528  27146				   -	       lda	hscursorx
    529  27146				   -	       asl
    530  27146				   -	       asl
    531  27146				   -	       clc
    532  27146				   -	       adc	#104
    533  27146				   -	       sta	temp4	; X
    534  27146				   -	       lda	hsnewscoreline
    535  27146				   -	       asl
    536  27146				   -	       asl
    537  27146				   -	       asl
    538  27146				   -	       asl
    539  27146				   -	       adc	#((3*16)+HSCURSORY)
    540  27146				   -	       sta	temp5	; Y
    541  27146				   -	       lda	#%01000000
    542  27146				   -	       sta	temp6
    543  27146				   -	       jsr	plotsprite
    544  27146				   -
    545  27146				   -	       ldx	hscursorx
    546  27146				   -	       ldy	hsdisplaymode
    547  27146				   -	       lda	SWCHA
    548  27146				   -	       cpy	#3
    549  27146				   -	       bne	hsskipadjustjoystick1
    550  27146				   -	       asl
    551  27146				   -	       asl
    552  27146				   -	       asl
    553  27146				   -	       asl
    554  27146				   -hsskipadjustjoystick1
    555  27146				   -	       sta	hsswcha
    556  27146				   -	       lda	SWCHB
    557  27146				   -	       and	#%00000010
    558  27146				   -	       bne	hsskipselectswitch
    559  27146				   -	       lda	#%00010000
    560  27146				   -	       sta	hsswcha
    561  27146				   -	       bne	hsdodebouncecheck
    562  27146				   -hsskipselectswitch
    563  27146				   -	       lda	hsswcha
    564  27146				   -	       and	#%00110000
    565  27146				   -	       cmp	#%00110000
    566  27146				   -	       beq	hsjoystickskipped
    567  27146				   -hsdodebouncecheck
    568  27146				   -	       lda	hsjoydebounce
    569  27146				   -	       beq	hsdontdebounce
    570  27146				   -	       jmp	hspostjoystick
    571  27146				   -hsdontdebounce
    572  27146				   -	       ldx	#1	; small tick sound
    573  27146				   -	       jsr	playhssfx
    574  27146				   -	       lda	hsswcha
    575  27146				   -	       and	#%00110000
    576  27146				   -	       ldx	hscursorx
    577  27146				   -	       cmp	#%00100000	; check down
    578  27146				   -	       bne	hsjoycheckup
    579  27146				   -	       ldy	hsinitialhold
    580  27146				   -	       cpx	#0
    581  27146				   -	       bne	skipavoid31_1
    582  27146				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    583  27146				   -	       bne	skipavoid31_1
    584  27146				   -	       dey
    585  27146				   -skipavoid31_1
    586  27146				   -	       dey
    587  27146				   -	       jmp	hssetdebounce
    588  27146				   -hsjoycheckup
    589  27146				   -	       cmp	#%00010000	; check up
    590  27146				   -	       bne	hsjoystickskipped
    591  27146				   -	       ldy	hsinitialhold
    592  27146				   -	       cpx	#0
    593  27146				   -	       bne	skipavoid31_2
    594  27146				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    595  27146				   -	       bne	skipavoid31_2
    596  27146				   -	       iny
    597  27146				   -skipavoid31_2
    598  27146				   -	       iny
    599  27146				   -hssetdebounce
    600  27146				   -	       tya
    601  27146				   -	       and	#31
    602  27146				   -	       sta	hsinitialhold
    603  27146				   -	       lda	#15
    604  27146				   -	       sta	hsjoydebounce
    605  27146				   -	       bne	hspostjoystick
    606  27146				   -hsjoystickskipped
    607  27146				   -			; check the fire button only when the stick isn't engaged
    608  27146				   -	       lda	hsinpt1
    609  27146				   -	       bpl	hsbuttonskipped
    610  27146				   -	       lda	hsjoydebounce
    611  27146				   -	       beq	hsfiredontdebounce
    612  27146				   -	       bne	hspostjoystick
    613  27146				   -hsfiredontdebounce
    614  27146				   -	       lda	hsinitialhold
    615  27146				   -	       cmp	#31
    616  27146				   -	       beq	hsmovecursorback
    617  27146				   -	       inc	hscursorx
    618  27146				   -	       inc	hsinitialpos
    619  27146				   -	       lda	hscursorx
    620  27146				   -	       cmp	#3
    621  27146				   -	       bne	skiphsentryisdone
    622  27146				   -	       lda	#0
    623  27146				   -	       sta	framecounter
    624  27146				   -	       lda	#$ff
    625  27146				   -	       sta	hsnewscoreline
    626  27146				   -	       dec	hsinitialpos
    627  27146				   -	       bne	skiphsentryisdone
    628  27146				   -hsmovecursorback
    629  27146				   -	       lda	hscursorx
    630  27146				   -	       beq	skiphsmovecursorback
    631  27146				   -	       lda	#29
    632  27146				   -	       ldx	hsinitialpos
    633  27146				   -	       sta	HSRAMInitials,x
    634  27146				   -	       dec	hsinitialpos
    635  27146				   -	       dec	hscursorx
    636  27146				   -	       dex
    637  27146				   -	       lda	HSRAMInitials,x
    638  27146				   -	       sta	hsinitialhold
    639  27146				   -skiphsmovecursorback
    640  27146				   -skiphsentryisdone
    641  27146				   -	       ldx	#0
    642  27146				   -	       jsr	playhssfx
    643  27146				   -	       lda	#20
    644  27146				   -	       sta	hsjoydebounce
    645  27146				   -	       bne	hspostjoystick
    646  27146				   -
    647  27146				   -hsbuttonskipped
    648  27146				   -	       lda	#0
    649  27146				   -	       sta	hsjoydebounce
    650  27146				   -hspostjoystick
    651  27146				   -
    652  27146				   -	       ldx	hsinitialpos
    653  27146				   -	       lda	hsinitialhold
    654  27146				   -	       sta	HSRAMInitials,x
    655  27146				   -
    656  27146				   -	       jmp	skiphschasecolors
    657  27146				   -
    658  27146				   -skipenterscorecontrol
    659  27146				   -	       jsr	hschasecolors
    660  27146				   -	       jsr	setuphsinpt1
    661  27146				   -	       lda	hsjoydebounce
    662  27146				   -	       bne	skiphschasecolors
    663  27146				   -	       lda	hsinpt1
    664  27146				   -	       bmi	returnfromhs
    665  27146				   -skiphschasecolors
    666  27146				   -
    667  27146				   -	       jsr	drawscreen
    668  27146				   -
    669  27146				   -	       lda	countdownseconds
    670  27146				   -	       beq	returnfromhs
    671  27146				   -	       jmp	keepdisplayinghs
    672  27146				   -returnfromhs
    673  27146				   -
    674  27146				   -	       ifconst	songdatastart_song_highscore
    675  27146				   -	       lda	hsdisplaymode
    676  27146				   -	       beq	skipclearHSCsong
    677  27146				   -	       lda	#0
    678  27146				   -	       sta	songtempo
    679  27146				   -skipclearHSCsong
    680  27146				   -	       endif
    681  27146				   -	       jsr	drawwait
    682  27146				   -	       jsr	clearscreen
    683  27146				   -	       lda	#0
    684  27146				   -	       ldy	#7
    685  27146				   -	       jsr	blacken320colors
    686  27146				   -	       lda	ssCTRL
    687  27146				   -	       sta	sCTRL
    688  27146				   -	       lda	ssCHARBASE
    689  27146				   -	       sta	sCHARBASE
    690  27146				   -	       rts
    691  27146				   -
    692  27146				   -setuphsinpt1
    693  27146				   -	       lda	#$ff
    694  27146				   -	       sta	hsinpt1
    695  27146				   -	       lda	hsjoydebounce
    696  27146				   -	       beq	skipdebounceadjust
    697  27146				   -	       dec	hsjoydebounce
    698  27146				   -	       bne	skipstorefirebuttonstatus
    699  27146				   -skipdebounceadjust
    700  27146				   -	       lda	SWCHB
    701  27146				   -	       and	#%00000001
    702  27146				   -	       bne	hscheckresetover
    703  27146				   -	       lda	#$ff
    704  27146				   -	       sta	hsinpt1
    705  27146				   -	       rts
    706  27146				   -hscheckresetover
    707  27146				   -	       ldx	hsdisplaymode
    708  27146				   -	       cpx	#3
    709  27146				   -	       bne	hsskipadjustjoyfire1
    710  27146				   -	       lda	sINPT3
    711  27146				   -	       jmp	hsskipadjustjoyfire1done
    712  27146				   -hsskipadjustjoyfire1
    713  27146				   -	       lda	sINPT1
    714  27146				   -hsskipadjustjoyfire1done
    715  27146				   -	       sta	hsinpt1
    716  27146				   -skipstorefirebuttonstatus
    717  27146				   -	       rts
    718  27146				   -
    719  27146				   -blacken320colors
    720  27146				   -	       ldy	#7
    721  27146				   -blacken320colorsloop
    722  27146				   -	       sta	P0C2,y
    723  27146				   -	       dey
    724  27146				   -	       bpl	blacken320colorsloop
    725  27146				   -	       rts
    726  27146				   -
    727  27146				   -hschasecolors
    728  27146				   -	       lda	framecounter
    729  27146				   -	       and	#3
    730  27146				   -	       bne	hschasecolorsreturn
    731  27146				   -	       inc	hscolorchaseindex
    732  27146				   -	       lda	hscolorchaseindex
    733  27146				   -
    734  27146				   -	       sta	P5C2
    735  27146				   -	       sbc	#$02
    736  27146				   -	       sta	P4C2
    737  27146				   -	       sbc	#$02
    738  27146				   -	       sta	P3C2
    739  27146				   -	       sbc	#$02
    740  27146				   -	       sta	P2C2
    741  27146				   -	       sbc	#$02
    742  27146				   -	       sta	P1C2
    743  27146				   -hschasecolorsreturn
    744  27146				   -	       rts
    745  27146				   -
    746  27146				   -playhssfx
    747  27146				   -	       lda	hssfx_lo,x
    748  27146				   -	       sta	temp1
    749  27146				   -	       lda	hssfx_hi,x
    750  27146				   -	       sta	temp2
    751  27146				   -	       lda	#0
    752  27146				   -	       sta	temp3
    753  27146				   -	       jmp	schedulesfx
    754  27146				   -
    755  27146				   -hssfx_lo
    756  27146				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    757  27146				   -hssfx_hi
    758  27146				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    759  27146				   -
    760  27146				   -sfx_hsletterpositionchange
    761  27146				   -	       .byte	$10,$18,$00
    762  27146				   -	       .byte	$02,$06,$08
    763  27146				   -	       .byte	$02,$06,$04
    764  27146				   -	       .byte	$00,$00,$00
    765  27146				   -sfx_hslettertick
    766  27146				   -	       .byte	$10,$18,$00
    767  27146				   -	       .byte	$00,$00,$0a
    768  27146				   -	       .byte	$00,$00,$00
    769  27146				   -
    770  27146				   -highscorelabeladjust1
    771  27146				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    772  27146				   -highscorelabeladjust2
    773  27146				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    774  27146				   -
    775  27146				   -scorevarlo
    776  27146				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    777  27146				   -scorevarhi
    778  27146				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    779  27146				   -
    780  27146				   -	       ifnconst	HSNOLEVELNAMES
    781  27146				   -highscoredifficultytextlo
    782  27146				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    783  27146				   -highscoredifficultytexthi
    784  27146				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    785  27146				   -	       ifnconst	HSCUSTOMLEVELNAMES
    786  27146				   -highscoredifficultytextlen
    787  27146				   -	       .byte	22, 30, 26, 24
    788  27146				   -
    789  27146				   -easylevelname
    790  27146				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    791  27146				   -mediumlevelname
    792  27146				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    793  27146				   -hardlevelname
    794  27146				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    795  27146				   -expertlevelname
    796  27146				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    797  27146				   -	       else
    798  27146				   -	       include	"7800hsgamediffnames.asm"
    799  27146				   -	       endif		; HSCUSTOMLEVELNAMES
    800  27146				   -	       else
    801  27146				   -HSHIGHSCOREStext
    802  27146				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    803  27146				   -	       endif		; HSNOLEVELNAMES
    804  27146				   -
    805  27146				   -highscorelabeltextlo
    806  27146				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    807  27146				   -highscorelabeltexthi
    808  27146				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    809  27146				   -
    810  27146				   -player0label
    811  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    812  27146				   -
    813  27146				   -player1label
    814  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    815  27146				   -
    816  27146				   -player2label
    817  27146				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    818  27146				   -
    819  27146				   -
    820  27146				   -	       ifconst	HSGAMENAMELEN
    821  27146				   -HSGAMENAMEtable
    822  27146				   -	       include	"7800hsgamename.asm"
    823  27146				   -	       endif
    824  27146				   -	       ifconst	HSGAMERANKS
    825  27146				   -	       include	"7800hsgameranks.asm"
    826  27146				   -highscoreranklabel
    827  27146				   -	       .byte	$11,$00,$0d,$0a,$1a
    828  27146				   -	       endif
    829  27146				   -
    830  27146				   -			;ensure our table doesn't wrap a page...
    831  27146				   -	       if	((<*)>251)
    832  27146				   -	       align	256
    833  27146				   -	       endif
    834  27146				   -hsgameslotnumbers
    835  27146				   -	       .byte	33,34,35,36,37
    836  27146				   -	       endif
    837  27146				   -
    838  27146				   -loaddifficultytable
    839  27146				   -	       lda	gamedifficulty
    840  27146				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    841  27146				   -	       sta	gamedifficulty
    842  27146				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    843  27146				   -	       bne	loaddifficultytablecontinue1
    844  27146				   -	       rts		; this high score difficulty table is already loaded
    845  27146				   -loaddifficultytablecontinue1
    846  27146				   -	       lda	gamedifficulty
    847  27146				   -	       sta	hsdifficulty
    848  27146				   -			;we need to check the device for the table
    849  27146				   -	       lda	hsdevice
    850  27146				   -	       bne	loaddifficultytablecontinue2
    851  27146				   -			; there's no save device. clear out this table.
    852  27146				   -	       jmp	cleardifficultytablemem
    853  27146				   -loaddifficultytablecontinue2
    854  27146				   -	       lda	hsdevice
    855  27146				   -	       and	#1
    856  27146				   -	       beq	memdeviceisntHSC
    857  27146				   -	       jmp	loaddifficultytableHSC
    858  27146				   -memdeviceisntHSC
    859  27146				   -	       jmp	loaddifficultytableAVOX
    860  27146				   -
    861  27146				   -savedifficultytable
    862  27146				   -			;*** we need to check wich device we should use...
    863  27146				   -	       lda	hsdevice
    864  27146				   -	       bne	savedifficultytablerealdevice
    865  27146				   -	       rts		; its a ram device
    866  27146				   -savedifficultytablerealdevice
    867  27146				   -	       and	#1
    868  27146				   -	       beq	savememdeviceisntHSC
    869  27146				   -	       jmp	savedifficultytableHSC
    870  27146				   -savememdeviceisntHSC
    871  27146				   -	       jmp	savedifficultytableAVOX
    872  27146				   -
    873  27146				   -savedifficultytableAVOX
    874  27146				   -			; the load call already setup the memory structure and atarivox memory location
    875  27146				   -	       jsr	savealoadedHSCtablecontinue
    876  27146				   -savedifficultytableAVOXskipconvert
    877  27146				   -	       lda	#HSIDHI
    878  27146				   -	       sta	eeprombuffer
    879  27146				   -	       lda	#HSIDLO
    880  27146				   -	       sta	eeprombuffer+1
    881  27146				   -	       lda	hsdifficulty
    882  27146				   -	       sta	eeprombuffer+2
    883  27146				   -	       lda	#32
    884  27146				   -	       jsr	AVoxWriteBytes
    885  27146				   -	       rts
    886  27146				   -
    887  27146				   -savedifficultytableHSC
    888  27146				   -			;we always load a table before reaching here, so the
    889  27146				   -			;memory structures from the load should be intact...
    890  27146				   -	       ldy	hsgameslot
    891  27146				   -	       bpl	savealoadedHSCtable
    892  27146				   -	       rts
    893  27146				   -savealoadedHSCtable
    894  27146				   -	       lda	HSCGameDifficulty,y
    895  27146				   -	       cmp	#$7F
    896  27146				   -	       bne	savealoadedHSCtablecontinue
    897  27146				   -	       jsr	initializeHSCtableentry
    898  27146				   -savealoadedHSCtablecontinue
    899  27146				   -			;convert our RAM table to HSC format and write it out...
    900  27146				   -	       ldy	#0
    901  27146				   -	       ldx	#0
    902  27146				   -savedifficultytableScores
    903  27146				   -
    904  27146				   -	       lda	HSRAMInitials,x
    905  27146				   -	       sta	temp3
    906  27146				   -	       lda	HSRAMInitials+1,x
    907  27146				   -	       sta	temp4
    908  27146				   -	       lda	HSRAMInitials+2,x
    909  27146				   -	       sta	temp5
    910  27146				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    911  27146				   -
    912  27146				   -	       lda	temp1
    913  27146				   -	       sta	(HSGameTableLo),y
    914  27146				   -	       iny
    915  27146				   -	       lda	temp2
    916  27146				   -	       sta	(HSGameTableLo),y
    917  27146				   -	       iny
    918  27146				   -
    919  27146				   -	       lda	HSRAMScores,x
    920  27146				   -	       sta	(HSGameTableLo),y
    921  27146				   -	       iny
    922  27146				   -	       lda	HSRAMScores+1,x
    923  27146				   -	       sta	(HSGameTableLo),y
    924  27146				   -	       iny
    925  27146				   -	       lda	HSRAMScores+2,x
    926  27146				   -	       sta	(HSGameTableLo),y
    927  27146				   -	       iny
    928  27146				   -	       inx
    929  27146				   -	       inx
    930  27146				   -	       inx		; +3
    931  27146				   -	       cpx	#15
    932  27146				   -	       bne	savedifficultytableScores
    933  27146				   -	       rts
    934  27146				   -
    935  27146				   -loaddifficultytableHSC
    936  27146				   -			; routine responsible for loading the difficulty table from HSC
    937  27146				   -	       jsr	findindexHSC
    938  27146				   -	       ldy	hsgameslot
    939  27146				   -	       lda	HSCGameDifficulty,y
    940  27146				   -	       cmp	#$7F
    941  27146				   -	       bne	loaddifficultytableHSCcontinue
    942  27146				   -			;there was an error. use a new RAM table instead...
    943  27146				   -	       jsr	initializeHSCtableentry
    944  27146				   -	       jmp	cleardifficultytablemem
    945  27146				   -loaddifficultytableHSCcontinue
    946  27146				   -			; parse the data into the HS memory...
    947  27146				   -	       ldy	#0
    948  27146				   -	       ldx	#0
    949  27146				   -loaddifficultytableScores
    950  27146				   -	       lda	(HSGameTableLo),y
    951  27146				   -	       sta	temp1
    952  27146				   -	       iny
    953  27146				   -	       lda	(HSGameTableLo),y
    954  27146				   -	       sta	temp2
    955  27146				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    956  27146				   -	       iny
    957  27146				   -	       lda	(HSGameTableLo),y
    958  27146				   -	       sta	HSRAMScores,x
    959  27146				   -	       lda	temp3
    960  27146				   -	       sta	HSRAMInitials,x
    961  27146				   -	       inx
    962  27146				   -	       iny
    963  27146				   -	       lda	(HSGameTableLo),y
    964  27146				   -	       sta	HSRAMScores,x
    965  27146				   -	       lda	temp4
    966  27146				   -	       sta	HSRAMInitials,x
    967  27146				   -	       inx
    968  27146				   -	       iny
    969  27146				   -	       lda	(HSGameTableLo),y
    970  27146				   -	       sta	HSRAMScores,x
    971  27146				   -	       lda	temp5
    972  27146				   -	       sta	HSRAMInitials,x
    973  27146				   -	       inx
    974  27146				   -	       iny
    975  27146				   -	       cpx	#15
    976  27146				   -	       bne	loaddifficultytableScores
    977  27146				   -	       rts
    978  27146				   -
    979  27146				   -decodeHSCInitials
    980  27146				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
    981  27146				   -			; 2 bytes are packed in the form: 22211111 22_33333
    982  27146				   -	       lda	#0
    983  27146				   -	       sta	temp4
    984  27146				   -	       lda	temp1
    985  27146				   -	       and	#%00011111
    986  27146				   -	       sta	temp3
    987  27146				   -
    988  27146				   -	       lda	temp2
    989  27146				   -	       and	#%00011111
    990  27146				   -	       sta	temp5
    991  27146				   -
    992  27146				   -	       lda	temp1
    993  27146				   -	       asl
    994  27146				   -	       rol	temp4
    995  27146				   -	       asl
    996  27146				   -	       rol	temp4
    997  27146				   -	       asl
    998  27146				   -	       rol	temp4
    999  27146				   -	       lda	temp2
   1000  27146				   -	       asl
   1001  27146				   -	       rol	temp4
   1002  27146				   -	       asl
   1003  27146				   -	       rol	temp4
   1004  27146				   -	       rts
   1005  27146				   -encodeHSCInitials
   1006  27146				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1007  27146				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1008  27146				   -			; start with packing temp1...
   1009  27146				   -	       lda	temp4
   1010  27146				   -	       and	#%00011100
   1011  27146				   -	       sta	temp1
   1012  27146				   -	       asl	temp1
   1013  27146				   -	       asl	temp1
   1014  27146				   -	       asl	temp1
   1015  27146				   -	       lda	temp3
   1016  27146				   -	       and	#%00011111
   1017  27146				   -	       ora	temp1
   1018  27146				   -	       sta	temp1
   1019  27146				   -			; ...temp1 is now packed, on to temp2...
   1020  27146				   -	       lda	temp5
   1021  27146				   -	       asl
   1022  27146				   -	       asl
   1023  27146				   -	       ror	temp4
   1024  27146				   -	       ror
   1025  27146				   -	       ror	temp4
   1026  27146				   -	       ror
   1027  27146				   -	       sta	temp2
   1028  27146				   -	       rts
   1029  27146				   -
   1030  27146				   -findindexHSCerror
   1031  27146				   -			;the HSC is stuffed. return the bad slot flag
   1032  27146				   -	       ldy	#$ff
   1033  27146				   -	       sty	hsgameslot
   1034  27146				   -	       rts
   1035  27146				   -
   1036  27146				   -findindexHSC
   1037  27146				   -HSCGameID1 =	$1029
   1038  27146				   -HSCGameID2 =	$106E
   1039  27146				   -HSCGameDifficulty =	$10B3
   1040  27146				   -HSCGameIndex =	$10F8
   1041  27146				   -			; routine responsible for finding the game index from HSC
   1042  27146				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1043  27146				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1044  27146				   -	       ldy	#69	; start +1 to account for the dey
   1045  27146				   -findindexHSCloop
   1046  27146				   -	       dey
   1047  27146				   -	       bmi	findindexHSCerror
   1048  27146				   -	       lda	HSCGameDifficulty,y
   1049  27146				   -	       cmp	#$7F
   1050  27146				   -	       beq	findourindexHSC
   1051  27146				   -	       cmp	gamedifficulty
   1052  27146				   -	       bne	findindexHSCloop
   1053  27146				   -	       lda	HSCGameID1,y
   1054  27146				   -	       cmp	#HSIDHI
   1055  27146				   -	       bne	findindexHSCloop
   1056  27146				   -	       lda	HSCGameID2,y
   1057  27146				   -	       cmp	#HSIDLO
   1058  27146				   -	       bne	findindexHSCloop
   1059  27146				   -findourindexHSC
   1060  27146				   -			; if we're here we found our index in the table
   1061  27146				   -			; or we found the first empty one
   1062  27146				   -	       sty	hsgameslot
   1063  27146				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1064  27146				   -	       rts
   1065  27146				   -
   1066  27146				   -
   1067  27146				   -initializeHSCtableentry
   1068  27146				   -	       ldy	hsgameslot
   1069  27146				   -			; we need to make a new entry...
   1070  27146				   -	       lda	#HSIDHI
   1071  27146				   -	       sta	HSCGameID1,y
   1072  27146				   -	       lda	#HSIDLO
   1073  27146				   -	       sta	HSCGameID2,y
   1074  27146				   -	       lda	gamedifficulty
   1075  27146				   -	       sta	HSCGameDifficulty,y
   1076  27146				   -	       ldx	#0
   1077  27146				   -fixHSDGameDifficultylistLoop
   1078  27146				   -	       inx
   1079  27146				   -	       txa
   1080  27146				   -	       sta	HSCGameIndex,y
   1081  27146				   -	       iny
   1082  27146				   -	       cpy	#69
   1083  27146				   -	       bne	fixHSDGameDifficultylistLoop
   1084  27146				   -	       rts
   1085  27146				   -
   1086  27146				   -setupHSCGamepointer
   1087  27146				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1088  27146				   -	       lda	#$17
   1089  27146				   -	       sta	HSGameTableHi
   1090  27146				   -	       lda	#$FA
   1091  27146				   -	       sta	HSGameTableLo
   1092  27146				   -setupHSCGamepointerLoop
   1093  27146				   -	       lda	HSGameTableLo
   1094  27146				   -	       sec
   1095  27146				   -	       sbc	#25
   1096  27146				   -	       sta	HSGameTableLo
   1097  27146				   -	       lda	HSGameTableHi
   1098  27146				   -	       sbc	#0
   1099  27146				   -	       sta	HSGameTableHi
   1100  27146				   -	       iny
   1101  27146				   -	       cpy	#69
   1102  27146				   -	       bne	setupHSCGamepointerLoop
   1103  27146				   -	       rts
   1104  27146				   -
   1105  27146				   -loaddifficultytableAVOX
   1106  27146				   -			; routine responsible for loading the difficulty table from Avox
   1107  27146				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1108  27146				   -	       lda	#>(eeprombuffer+3)
   1109  27146				   -	       sta	HSGameTableHi
   1110  27146				   -	       lda	#<(eeprombuffer+3)
   1111  27146				   -	       sta	HSGameTableLo
   1112  27146				   -
   1113  27146				   -			; the start location in EEPROM, subtract 32...
   1114  27146				   -	       lda	#$5F
   1115  27146				   -	       sta	HSVoxHi
   1116  27146				   -	       lda	#$E0
   1117  27146				   -	       sta	HSVoxLo
   1118  27146				   -	       lda	#0
   1119  27146				   -	       sta	temp1
   1120  27146				   -loaddifficultytableAVOXloop
   1121  27146				   -	       inc	temp1
   1122  27146				   -	       beq	loaddifficultytableAVOXfull
   1123  27146				   -	       clc
   1124  27146				   -	       lda	HSVoxLo
   1125  27146				   -	       adc	#32
   1126  27146				   -	       sta	HSVoxLo
   1127  27146				   -	       lda	HSVoxHi
   1128  27146				   -	       adc	#0
   1129  27146				   -	       sta	HSVoxHi
   1130  27146				   -	       lda	#3
   1131  27146				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1132  27146				   -	       lda	eeprombuffer
   1133  27146				   -	       cmp	#$FF
   1134  27146				   -	       beq	loaddifficultytableAVOXempty
   1135  27146				   -	       cmp	#HSIDHI
   1136  27146				   -	       bne	loaddifficultytableAVOXloop
   1137  27146				   -	       lda	eeprombuffer+1
   1138  27146				   -	       cmp	#HSIDLO
   1139  27146				   -	       bne	loaddifficultytableAVOXloop
   1140  27146				   -	       lda	eeprombuffer+2
   1141  27146				   -	       cmp	gamedifficulty
   1142  27146				   -	       bne	loaddifficultytableAVOXloop
   1143  27146				   -loaddifficultytableAVOXdone
   1144  27146				   -	       lda	#32
   1145  27146				   -	       jsr	AVoxReadBytes
   1146  27146				   -	       jsr	loaddifficultytableHSCcontinue
   1147  27146				   -	       rts
   1148  27146				   -loaddifficultytableAVOXfull
   1149  27146				   -	       lda	#0
   1150  27146				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1151  27146				   -loaddifficultytableAVOXempty
   1152  27146				   -	       jmp	cleardifficultytablemem
   1153  27146				   -	       rts
   1154  27146				   -
   1155  27146				   -cleardifficultytablemem
   1156  27146				   -	       ldy	#29
   1157  27146				   -	       lda	#0
   1158  27146				   -cleardifficultytablememloop
   1159  27146				   -	       sta	HSRAMTable,y
   1160  27146				   -	       dey
   1161  27146				   -	       bpl	cleardifficultytablememloop
   1162  27146				   -	       rts
   1163  27146				   -hiscoremoduleend
   1164  27146				   -
   1165  27146				   -	       echo	"  hiscore assembly: ",[(hiscoremoduleend-hiscoremodulestart)]d," bytes"
   1166  27146				   -
   1167  27146				   -	       ifconst	DOUBLEWIDE
   1168  27146				   -plotvaluedw
   1169  27146				   -plotdigitcount =	temp6
   1170  27146				   -	       lda	#0
   1171  27146				   -	       tay
   1172  27146				   -	       ldx	valbufend
   1173  27146				   -
   1174  27146				   -	       lda	plotdigitcount
   1175  27146				   -	       and	#1
   1176  27146				   -	       beq	pvnibble2chardw
   1177  27146				   -	       lda	#0
   1178  27146				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1179  27146				   -	       beq	pvnibble2char_skipnibbledw
   1180  27146				   -
   1181  27146				   -pvnibble2chardw
   1182  27146				   -			; high nibble...
   1183  27146				   -	       lda	(temp7),y
   1184  27146				   -	       and	#$f0
   1185  27146				   -	       lsr
   1186  27146				   -	       lsr
   1187  27146				   -	       lsr
   1188  27146				   -	       lsr
   1189  27146				   -
   1190  27146				   -	       clc
   1191  27146				   -	       adc	temp1	; add the offset to character graphics to our value
   1192  27146				   -	       sta	VALBUFFER,x
   1193  27146				   -	       inx
   1194  27146				   -	       dec	plotdigitcount
   1195  27146				   -pvnibble2char_skipnibbledw
   1196  27146				   -			; low nibble...
   1197  27146				   -	       lda	(temp7),y
   1198  27146				   -	       and	#$0f
   1199  27146				   -	       clc
   1200  27146				   -	       adc	temp1	; add the offset to character graphics to our value
   1201  27146				   -	       sta	VALBUFFER,x
   1202  27146				   -	       inx
   1203  27146				   -	       iny
   1204  27146				   -
   1205  27146				   -	       dec	plotdigitcount
   1206  27146				   -	       bne	pvnibble2chardw
   1207  27146				   -			;point to the start of our valuebuffer
   1208  27146				   -	       clc
   1209  27146				   -	       lda	#<VALBUFFER
   1210  27146				   -	       adc	valbufend
   1211  27146				   -	       sta	temp1
   1212  27146				   -	       lda	#>VALBUFFER
   1213  27146				   -	       adc	#0
   1214  27146				   -	       sta	temp2
   1215  27146				   -
   1216  27146				   -			;advance valbufend to the end of our value buffer
   1217  27146				   -	       stx	valbufend
   1218  27146				   -
   1219  27146				   -	       ifnconst	plotvalueonscreen
   1220  27146				   -	       jmp	plotcharacters
   1221  27146				   -	       else
   1222  27146				   -	       jmp	plotcharacterslive
   1223  27146				   -	       endif
   1224  27146				   -	       endif		; DOUBLEWIDE
   1225  27146				   -
   1226  27146					       endif		; HSSUPPORT
   1227  27146
------- FILE c:\Users\steve\OneDrive\Desktop\2018dev\7800\7800basic\projects\pokeyplayer\pokeyplayer2.bas.asm
   3493  27146					       endif
   3494  27146							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3495  27146
   3496  27146							;standard routimes needed for pretty much all games
   3497  27146
   3498  27146							; some definitions used with "set debug color"
   3499  27146			00 91	    DEBUGCALC  =	$91
   3500  27146			00 41	    DEBUGWASTE =	$41
   3501  27146			00 c1	    DEBUGDRAW  =	$C1
   3502  27146
   3503  27146							;NMI and IRQ handlers
   3504  27146				    NMI
   3505  27146							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   3506  27146			48		       pha		; save A
   3507  27147			d8		       cld
   3508  27148			a5 4d		       lda	visibleover
   3509  2714a			49 ff		       eor	#255
   3510  2714c			85 4d		       sta	visibleover
   3511  2714e				   -	       ifconst	DEBUGINTERRUPT
   3512  2714e				   -	       and	#$93
   3513  2714e				   -	       sta	BACKGRND
   3514  2714e					       endif
   3515  2714e			8a		       txa		; save X
   3516  2714f			48		       pha
   3517  27150			98		       tya		; save Y
   3518  27151			48		       pha
   3519  27152			ce b2 01	       dec	interruptindex
   3520  27155			d0 03		       bne	skipreallyoffvisible
   3521  27157			4c b1 f1	       jmp	reallyoffvisible
   3522  2715a				    skipreallyoffvisible
   3523  2715a			a5 4d		       lda	visibleover
   3524  2715c			d0 03		       bne	carryontopscreenroutine
   3525  2715e				   -	       ifconst	.bottomscreenroutine
   3526  2715e				   -	       lda	interrupthold
   3527  2715e				   -	       beq	skipbottomroutine
   3528  2715e				   -	       jsr	.bottomscreenroutine
   3529  2715e				   -skipbottomroutine
   3530  2715e					       endif
   3531  2715e			4c bf f1	       jmp	NMIexit
   3532  27161				    carryontopscreenroutine
   3533  27161				   -	       ifconst	.topscreenroutine
   3534  27161				   -	       lda	interrupthold
   3535  27161				   -	       beq	skiptoproutine
   3536  27161				   -	       jsr	.topscreenroutine
   3537  27161				   -skiptoproutine
   3538  27161					       endif
   3539  27161					       ifnconst	CANARYOFF
   3540  27161			ad d1 01	       lda	canary
   3541  27164			f0 07		       beq	skipcanarytriggered
   3542  27166			a9 45		       lda	#$45
   3543  27168			85 20		       sta	BACKGRND
   3544  2716a			4c a9 f1	       jmp	skipbrkolorset	; common crash dump routine, if available
   3545  2716d				    skipcanarytriggered
   3546  2716d					       endif
   3547  2716d
   3548  2716d			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   3549  27170
   3550  27170							; ** Other important routines that need to regularly run, and can run onscreen.
   3551  27170							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   3552  27170
   3553  27170				   -	       ifconst	LONGCONTROLLERREAD
   3554  27170				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   3555  27170				   -	       ldy	port1control
   3556  27170				   -	       lda	longreadtype,y
   3557  27170				   -	       beq	LLRET1
   3558  27170				   -	       tay
   3559  27170				   -	       lda	longreadroutinehiP1,y
   3560  27170				   -	       sta	inttemp4
   3561  27170				   -	       lda	longreadroutineloP1,y
   3562  27170				   -	       sta	inttemp3
   3563  27170				   -	       jmp	(inttemp3)
   3564  27170				   -LLRET1
   3565  27170				   -	       ldy	port0control
   3566  27170				   -	       lda	longreadtype,y
   3567  27170				   -	       beq	LLRET0
   3568  27170				   -	       tay
   3569  27170				   -	       lda	longreadroutinehiP0,y
   3570  27170				   -	       sta	inttemp4
   3571  27170				   -	       lda	longreadroutineloP0,y
   3572  27170				   -	       sta	inttemp3
   3573  27170				   -	       jmp	(inttemp3)
   3574  27170				   -LLRET0
   3575  27170				   -
   3576  27170				   -
   3577  27170				   -	       ifconst	PADDLERANGE
   3578  27170				   -TIMEVAL    =	PADDLERANGE
   3579  27170				   -	       else
   3580  27170				   -TIMEVAL    =	160
   3581  27170				   -	       endif
   3582  27170				   -TIMEOFFSET =	10
   3583  27170				   -
   3584  27170					       endif		; LONGCONTROLLERREAD
   3585  27170
   3586  27170
   3587  27170			20 2c f3	       jsr	servicesfxchannels
   3588  27173				   -	       ifconst	MUSICTRACKER
   3589  27173				   -	       jsr	servicesong
   3590  27173					       endif		; MUSICTRACKER
   3591  27173
   3592  27173			ee a4 01	       inc	framecounter
   3593  27176			ad a4 01	       lda	framecounter
   3594  27179			29 3f		       and	#63
   3595  2717b			d0 08		       bne	skipcountdownseconds
   3596  2717d			ad a5 01	       lda	countdownseconds
   3597  27180			f0 03		       beq	skipcountdownseconds
   3598  27182			ce a5 01	       dec	countdownseconds
   3599  27185				    skipcountdownseconds
   3600  27185
   3601  27185			a2 01		       ldx	#1
   3602  27187				    buttonreadloop
   3603  27187			8a		       txa
   3604  27188			48		       pha
   3605  27189			bc b7 01	       ldy	port0control,x
   3606  2718c			b9 08 f3	       lda	buttonhandlerlo,y
   3607  2718f			85 da		       sta	inttemp3
   3608  27191			b9 fd f2	       lda	buttonhandlerhi,y
   3609  27194			85 db		       sta	inttemp4
   3610  27196			05 da		       ora	inttemp3
   3611  27198			f0 03		       beq	buttonreadloopreturn
   3612  2719a			6c da 00	       jmp	(inttemp3)
   3613  2719d				    buttonreadloopreturn
   3614  2719d			68		       pla
   3615  2719e			aa		       tax
   3616  2719f			ca		       dex
   3617  271a0			10 e5		       bpl	buttonreadloop
   3618  271a2
   3619  271a2				   -	       ifconst	KEYPADSUPPORT
   3620  271a2				   -	       jsr	keypadrowselect
   3621  271a2					       endif		; KEYPADSUPPORT
   3622  271a2
   3623  271a2
   3624  271a2				   -	       ifconst	DOUBLEBUFFER
   3625  271a2				   -	       lda	doublebufferminimumframeindex
   3626  271a2				   -	       beq	skipdoublebufferminimumframeindexadjust
   3627  271a2				   -	       dec	doublebufferminimumframeindex
   3628  271a2				   -skipdoublebufferminimumframeindexadjust
   3629  271a2					       endif
   3630  271a2
   3631  271a2			4c bf f1	       jmp	NMIexit
   3632  271a5
   3633  271a5				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   3634  271a5					       ifnconst	BREAKPROTECTOFF
   3635  271a5			a9 1a		       lda	#$1A
   3636  271a7			85 20		       sta	BACKGRND
   3637  271a9				    skipbrkolorset
   3638  271a9				    skipbrkdetected
   3639  271a9			a9 60		       lda	#$60
   3640  271ab			8d 07 21	       sta	sCTRL
   3641  271ae			85 3c		       sta	CTRL
   3642  271b0					       ifnconst	hiscorefont
   3643  271b0			02		       .byte.b	$02	; KIL/JAM
   3644  271b1				   -	       else		; hiscorefont is present
   3645  271b1				   -	       ifconst	CRASHDUMP
   3646  271b1				   -	       bit	MSTAT
   3647  271b1				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   3648  271b1				   -
   3649  271b1				   -	       ifconst	dumpbankswitch
   3650  271b1				   -	       lda	dumpbankswitch
   3651  271b1				   -	       pha
   3652  271b1				   -	       endif
   3653  271b1				   -
   3654  271b1				   -			; bankswitch if needed, to get to the hiscore font
   3655  271b1				   -	       ifconst	bankswitchmode
   3656  271b1				   -	       ifconst	included.hiscore.asm.bank
   3657  271b1				   -	       ifconst	MCPDEVCART
   3658  271b1				   -	       lda	#($18 | included.hiscore.asm.bank)
   3659  271b1				   -	       sta	$3000
   3660  271b1				   -	       else
   3661  271b1				   -	       lda	#(included.hiscore.asm.bank)
   3662  271b1				   -	       sta	$8000
   3663  271b1				   -	       endif
   3664  271b1				   -	       endif		; included.hiscore.asm.bank
   3665  271b1				   -	       endif		; bankswitchmode
   3666  271b1				   -
   3667  271b1				   -	       ifconst	DOUBLEBUFFER
   3668  271b1				   -			;turn off double-buffering, if on...
   3669  271b1				   -	       lda	#>DLLMEM
   3670  271b1				   -	       sta	DPPH
   3671  271b1				   -	       lda	#<DLLMEM
   3672  271b1				   -	       sta	DPPL
   3673  271b1				   -	       endif
   3674  271b1				   -
   3675  271b1				   -	       lda	#$00
   3676  271b1				   -	       sta	P0C2
   3677  271b1				   -
   3678  271b1				   -			;update the second-from-top DL...
   3679  271b1				   -	       ldy	#8
   3680  271b1				   -NMIupdatetopDL
   3681  271b1				   -	       lda	show2700,y
   3682  271b1				   -	       sta	ZONE1ADDRESS,y
   3683  271b1				   -	       dey
   3684  271b1				   -	       bpl	NMIupdatetopDL
   3685  271b1				   -
   3686  271b1				   -			; the hiscore font is present, so we try to output the stack
   3687  271b1				   -	       ldy	#0
   3688  271b1				   -copystackloop
   3689  271b1				   -	       pla
   3690  271b1				   -	       pha
   3691  271b1				   -	       lsr
   3692  271b1				   -	       lsr
   3693  271b1				   -	       lsr
   3694  271b1				   -	       lsr
   3695  271b1				   -	       tax
   3696  271b1				   -	       lda	hiscorehexlut,x
   3697  271b1				   -	       sta	$2700,y
   3698  271b1				   -	       iny
   3699  271b1				   -
   3700  271b1				   -	       pla
   3701  271b1				   -	       and	#$0F
   3702  271b1				   -	       tax
   3703  271b1				   -	       lda	hiscorehexlut,x
   3704  271b1				   -	       sta	$2700,y
   3705  271b1				   -	       iny
   3706  271b1				   -
   3707  271b1				   -	       lda	#27	; period
   3708  271b1				   -	       sta	$2700,y
   3709  271b1				   -	       iny
   3710  271b1				   -
   3711  271b1				   -	       cpy	#30
   3712  271b1				   -	       bne	copystackloop
   3713  271b1				   -
   3714  271b1				   -	       lda	#>hiscorefont
   3715  271b1				   -	       sta	CHARBASE
   3716  271b1				   -	       sta	sCHARBASE
   3717  271b1				   -	       lda	#%01000011	;Enable DMA, mode=320A
   3718  271b1				   -	       sta	CTRL
   3719  271b1				   -	       sta	sCTRL
   3720  271b1				   -	       .byte	$02	; KIL/JAM
   3721  271b1				   -hiscorehexlut
   3722  271b1				   -			;	  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   3723  271b1				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   3724  271b1				   -show2700
   3725  271b1				   -			;	 lo   mode	   hi	width=29  x   EODL
   3726  271b1				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   3727  271b1				   -	       else		; CRASHDUMP
   3728  271b1				   -	       .byte	$02	; KIL/JAM
   3729  271b1				   -	       endif		; crashdump
   3730  271b1					       endif		; hiscorefont
   3731  271b1				   -	       else
   3732  271b1				   -	       RTI
   3733  271b1					       endif
   3734  271b1
   3735  271b1				   -	       ifconst	LONGCONTROLLERREAD
   3736  271b1				   -
   3737  271b1				   -longreadtype
   3738  271b1				   -	       .byte	0, 0, 0, 1	; NONE     PROLINE   LIGHTGUN	PADDLE
   3739  271b1				   -	       .byte	2, 0, 3, 0	; TRKBALL  VCSSTICK  DRIVING	KEYPAD
   3740  271b1				   -	       .byte	3, 3, 0	; STMOUSE  AMOUSE    ATARIVOX
   3741  271b1				   -
   3742  271b1				   -longreadroutineloP0
   3743  271b1				   -	       .byte	<LLRET0	;  0 = no routine
   3744  271b1				   -	       .byte	<paddleport0update	;  1 = paddle
   3745  271b1				   -	       .byte	<trakball0update	;  2 = trakball
   3746  271b1				   -	       .byte	<mouse0update	;  3 = mouse
   3747  271b1				   -
   3748  271b1				   -longreadroutinehiP0
   3749  271b1				   -	       .byte	>LLRET0	;  0 = no routine
   3750  271b1				   -	       .byte	>paddleport0update	;  1 = paddle
   3751  271b1				   -	       .byte	>trakball0update	;  2 = trackball
   3752  271b1				   -	       .byte	>mouse0update	;  3 = mouse
   3753  271b1				   -
   3754  271b1				   -longreadroutineloP1
   3755  271b1				   -	       .byte	<LLRET1	;  0 = no routine
   3756  271b1				   -	       .byte	<paddleport1update	;  1 = paddle
   3757  271b1				   -	       .byte	<trakball1update	;  2 = trakball
   3758  271b1				   -	       .byte	<mouse1update	;  3 = mouse
   3759  271b1				   -
   3760  271b1				   -longreadroutinehiP1
   3761  271b1				   -	       .byte	>LLRET1	;  0 = no routine
   3762  271b1				   -	       .byte	>paddleport1update	;  1 = paddle
   3763  271b1				   -	       .byte	>trakball1update	;  2 = trackball
   3764  271b1				   -	       .byte	>mouse1update	;  3 = mouse
   3765  271b1				   -
   3766  271b1				   -
   3767  271b1				   -SETTIM64T
   3768  271b1				   -	       bne	skipdefaulttime
   3769  271b1				   -	       ifnconst	PADDLESMOOTHINGOFF
   3770  271b1				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   3771  271b1				   -	       else
   3772  271b1				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   3773  271b1				   -	       endif
   3774  271b1				   -skipdefaulttime
   3775  271b1				   -	       tay
   3776  271b1				   -	       dey
   3777  271b1				   -.setTIM64Tloop
   3778  271b1				   -	       sta	TIM64T
   3779  271b1				   -	       cpy	INTIM
   3780  271b1				   -	       bne	.setTIM64Tloop
   3781  271b1				   -	       rts
   3782  271b1					       endif		; LONGCONTROLLERREAD
   3783  271b1
   3784  271b1				    reallyoffvisible
   3785  271b1			85 24		       sta	WSYNC
   3786  271b3
   3787  271b3			a9 00		       lda	#0
   3788  271b5			85 4d		       sta	visibleover
   3789  271b7				   -	       ifconst	DEBUGINTERRUPT
   3790  271b7				   -	       sta	BACKGRND
   3791  271b7					       endif
   3792  271b7
   3793  271b7			a9 03		       lda	#3
   3794  271b9			8d b2 01	       sta	interruptindex
   3795  271bc
   3796  271bc			20 9f f2	       jsr	uninterruptableroutines
   3797  271bf
   3798  271bf				   -	       ifconst	.userinterrupt
   3799  271bf				   -	       lda	interrupthold
   3800  271bf				   -	       beq	skipuserintroutine
   3801  271bf				   -	       jsr	.userinterrupt
   3802  271bf				   -skipuserintroutine
   3803  271bf					       endif
   3804  271bf
   3805  271bf				   -	       ifconst	KEYPADSUPPORT
   3806  271bf				   -	       jsr	keypadcolumnread
   3807  271bf					       endif
   3808  271bf
   3809  271bf				    NMIexit
   3810  271bf			68		       pla
   3811  271c0			a8		       tay
   3812  271c1			68		       pla
   3813  271c2			aa		       tax
   3814  271c3			68		       pla
   3815  271c4			40		       RTI
   3816  271c5
   3817  271c5				    clearscreen
   3818  271c5			a2 0b		       ldx	#(WZONECOUNT-1)
   3819  271c7			a9 00		       lda	#0
   3820  271c9				    clearscreenloop
   3821  271c9			95 65		       sta	dlend,x
   3822  271cb			ca		       dex
   3823  271cc			10 fb		       bpl	clearscreenloop
   3824  271ce			a9 00		       lda	#0
   3825  271d0			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   3826  271d3			8d ae 01	       sta	valbufendsave
   3827  271d6			60		       rts
   3828  271d7
   3829  271d7				    restorescreen
   3830  271d7			a2 0b		       ldx	#(WZONECOUNT-1)
   3831  271d9			a9 00		       lda	#0
   3832  271db				    restorescreenloop
   3833  271db			b5 82		       lda	dlendsave,x
   3834  271dd			95 65		       sta	dlend,x
   3835  271df			ca		       dex
   3836  271e0			10 f9		       bpl	restorescreenloop
   3837  271e2			ad ae 01	       lda	valbufendsave
   3838  271e5			8d ad 01	       sta	valbufend
   3839  271e8			60		       rts
   3840  271e9
   3841  271e9				    savescreen
   3842  271e9			a2 0b		       ldx	#(WZONECOUNT-1)
   3843  271eb				    savescreenloop
   3844  271eb			b5 65		       lda	dlend,x
   3845  271ed			95 82		       sta	dlendsave,x
   3846  271ef			ca		       dex
   3847  271f0			10 f9		       bpl	savescreenloop
   3848  271f2			ad ad 01	       lda	valbufend
   3849  271f5			8d ae 01	       sta	valbufendsave
   3850  271f8				   -	       ifconst	DOUBLEBUFFER
   3851  271f8				   -	       lda	doublebufferstate
   3852  271f8				   -	       beq	savescreenrts
   3853  271f8				   -	       lda	#1
   3854  271f8				   -	       sta	doublebufferbufferdirty
   3855  271f8				   -savescreenrts
   3856  271f8					       endif		; DOUBLEBUFFER
   3857  271f8			60		       rts
   3858  271f9
   3859  271f9				    drawscreen
   3860  271f9
   3861  271f9				   -	       ifconst	interrupthold
   3862  271f9				   -	       lda	#$FF
   3863  271f9				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   3864  271f9					       endif
   3865  271f9
   3866  271f9			a9 00		       lda	#0
   3867  271fb			85 42		       sta	temp1	; not B&W if we're here...
   3868  271fd
   3869  271fd				    drawscreenwait
   3870  271fd			a5 4d		       lda	visibleover
   3871  271ff			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   3872  27201
   3873  27201							;restore some registers in case the game changed them mid-screen...
   3874  27201			ad 07 21	       lda	sCTRL
   3875  27204			05 42		       ora	temp1
   3876  27206			85 3c		       sta	CTRL
   3877  27208			ad 0b 21	       lda	sCHARBASE
   3878  2720b			85 34		       sta	CHARBASE
   3879  2720d
   3880  2720d							;ensure all of the display list is terminated...
   3881  2720d			20 85 f2	       jsr	terminatedisplaylist
   3882  27210
   3883  27210					       ifnconst	pauseroutineoff
   3884  27210			20 1b f2	       jsr	pauseroutine
   3885  27213					       endif		; pauseroutineoff
   3886  27213
   3887  27213							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   3888  27213							; delaying a full frame, but still allowing time for basic calculations.
   3889  27213				    visiblescreenstartedwait
   3890  27213			a5 4d		       lda	visibleover
   3891  27215			f0 fc		       beq	visiblescreenstartedwait
   3892  27217				    visiblescreenstartedwaitdone
   3893  27217			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   3894  2721a			60		       rts
   3895  2721b
   3896  2721b					       ifnconst	pauseroutineoff
   3897  2721b							; check to see if pause was pressed and released
   3898  2721b				    pauseroutine
   3899  2721b			ad b3 01	       lda	pausedisable
   3900  2721e			d0 55		       bne	leavepauseroutine
   3901  27220			a9 08		       lda	#8
   3902  27222			2c 82 02	       bit	SWCHB
   3903  27225			f0 29		       beq	pausepressed
   3904  27227
   3905  27227					       ifnconst	SOFTRESETASPAUSEOFF
   3906  27227					       ifnconst	MOUSESUPPORT
   3907  27227					       ifnconst	TRAKBALLSUPPORT
   3908  27227			ad 80 02	       lda	SWCHA	; then check the soft "RESET" joysick code...
   3909  2722a			29 70		       and	#%01110000	; _LDU
   3910  2722c			f0 22		       beq	pausepressed
   3911  2722e					       endif
   3912  2722e					       endif
   3913  2722e					       endif
   3914  2722e
   3915  2722e							;pause isn't pressed
   3916  2722e			a9 00		       lda	#0
   3917  27230			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   3918  27233
   3919  27233							;check if we're in an already paused state
   3920  27233			ad 00 21	       lda	pausestate
   3921  27236			f0 3d		       beq	leavepauseroutine	; nope, leave
   3922  27238
   3923  27238			c9 01		       cmp	#1	; last frame was the start of pausing
   3924  2723a			f0 32		       beq	enterpausestate2	; move from state 1 to 2
   3925  2723c
   3926  2723c			c9 02		       cmp	#2
   3927  2723e			f0 3b		       beq	carryonpausing
   3928  27240
   3929  27240							;pausestate must be >2, which means we're ending an unpause 
   3930  27240			a9 00		       lda	#0
   3931  27242			8d ac 01	       sta	pausebuttonflag
   3932  27245			8d 00 21	       sta	pausestate
   3933  27248			ad 07 21	       lda	sCTRL
   3934  2724b			85 3c		       sta	CTRL
   3935  2724d			4c 75 f2	       jmp	leavepauseroutine
   3936  27250
   3937  27250				    pausepressed
   3938  27250							;pause is pressed
   3939  27250			ad ac 01	       lda	pausebuttonflag
   3940  27253			c9 ff		       cmp	#$ff
   3941  27255			f0 24		       beq	carryonpausing
   3942  27257
   3943  27257							;its a new press, increment the state
   3944  27257			ee 00 21	       inc	pausestate
   3945  2725a
   3946  2725a							;silence volume at the start and end of pausing
   3947  2725a			a9 00		       lda	#0
   3948  2725c			85 19		       sta	AUDV0
   3949  2725e			85 1a		       sta	AUDV1
   3950  27260
   3951  27260					       ifconst	pokeysupport
   3952  27260			a0 07		       ldy	#7
   3953  27262				    pausesilencepokeyaudioloop
   3954  27262			91 4b		       sta	(pokeybase),y
   3955  27264			88		       dey
   3956  27265			10 fb		       bpl	pausesilencepokeyaudioloop
   3957  27267					       endif		; pokeysupport
   3958  27267
   3959  27267			a9 ff		       lda	#$ff
   3960  27269			8d ac 01	       sta	pausebuttonflag
   3961  2726c			d0 0d		       bne	carryonpausing
   3962  2726e
   3963  2726e				    enterpausestate2
   3964  2726e			a9 02		       lda	#2
   3965  27270			8d 00 21	       sta	pausestate
   3966  27273			d0 06		       bne	carryonpausing
   3967  27275				    leavepauseroutine
   3968  27275			ad 07 21	       lda	sCTRL
   3969  27278			85 3c		       sta	CTRL
   3970  2727a			60		       rts
   3971  2727b				    carryonpausing
   3972  2727b				   -	       ifconst	.pause
   3973  2727b				   -	       jsr	.pause
   3974  2727b					       endif		; .pause
   3975  2727b			ad 07 21	       lda	sCTRL
   3976  2727e			09 80		       ora	#%10000000	; turn off colorburst during pause...
   3977  27280			85 3c		       sta	CTRL
   3978  27282			4c 1b f2	       jmp	pauseroutine
   3979  27285					       endif		; pauseroutineoff
   3980  27285
   3981  27285
   3982  27285				   -	       ifconst	DOUBLEBUFFER
   3983  27285				   -skipterminatedisplaylistreturn
   3984  27285				   -	       rts
   3985  27285					       endif		; DOUBLEBUFFER
   3986  27285				    terminatedisplaylist
   3987  27285				   -	       ifconst	DOUBLEBUFFER
   3988  27285				   -	       lda	doublebufferstate
   3989  27285				   -	       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   3990  27285					       endif		; DOUBLEBUFFER
   3991  27285				    terminatedisplaybuffer
   3992  27285							;add DL end entry on each DL
   3993  27285			a2 0b		       ldx	#(WZONECOUNT-1)
   3994  27287				    dlendloop
   3995  27287			bd ac f7	       lda	DLPOINTL,x
   3996  2728a				   -	       ifconst	DOUBLEBUFFER
   3997  2728a				   -	       clc
   3998  2728a				   -	       adc	doublebufferdloffset
   3999  2728a					       endif		; DOUBLEBUFFER
   4000  2728a			85 63		       sta	dlpnt
   4001  2728c			bd a0 f7	       lda	DLPOINTH,x
   4002  2728f				   -	       ifconst	DOUBLEBUFFER
   4003  2728f				   -	       adc	#0
   4004  2728f					       endif		; DOUBLEBUFFER
   4005  2728f			85 64		       sta	dlpnt+1
   4006  27291			b4 65		       ldy	dlend,x
   4007  27293			a9 00		       lda	#$00
   4008  27295				    dlendmoreloops
   4009  27295			c8		       iny
   4010  27296			91 63		       sta	(dlpnt),y
   4011  27298				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   4012  27298				   -	       cpy	#DLLASTOBJ+1
   4013  27298				   -	       beq	dlendthiszonedone
   4014  27298				   -	       iny
   4015  27298				   -	       iny
   4016  27298				   -	       iny
   4017  27298				   -	       iny
   4018  27298				   -	       iny
   4019  27298				   -	       sta	(dlpnt),y
   4020  27298				   -dlendthiszonedone
   4021  27298					       endif	FRAMESKIPGLITCHFIXWEAK
   4022  27298				   -	       ifconst	FRAMESKIPGLITCHFIX
   4023  27298				   -	       iny
   4024  27298				   -	       iny
   4025  27298				   -	       iny
   4026  27298				   -	       iny
   4027  27298				   -	       cpy	#DLLASTOBJ-1
   4028  27298				   -	       bcc	dlendmoreloops
   4029  27298					       endif		; FRAMESKIPGLITCHFIX
   4030  27298			ca		       dex
   4031  27299			10 ec		       bpl	dlendloop
   4032  2729b
   4033  2729b					       ifnconst	pauseroutineoff
   4034  2729b			20 1b f2	       jsr	pauseroutine
   4035  2729e					       endif		; pauseroutineoff
   4036  2729e			60		       rts
   4037  2729f
   4038  2729f				    uninterruptableroutines
   4039  2729f							; this is for routines that must happen off the visible screen, each frame.
   4040  2729f
   4041  2729f				   -	       ifconst	AVOXVOICE
   4042  2729f				   -	       jsr	serviceatarivoxqueue
   4043  2729f					       endif
   4044  2729f
   4045  2729f			a9 00		       lda	#0
   4046  272a1			8d b6 01	       sta	palfastframe
   4047  272a4			ad 09 21	       lda	paldetected
   4048  272a7			f0 10		       beq	skippalframeadjusting
   4049  272a9							; ** PAL console is detected. we increment palframes to accurately count 5 frames,
   4050  272a9			ae b5 01	       ldx	palframes
   4051  272ac			e8		       inx
   4052  272ad			e0 05		       cpx	#5
   4053  272af			d0 05		       bne	palframeskipdone
   4054  272b1			ee b6 01	       inc	palfastframe
   4055  272b4			a2 00		       ldx	#0
   4056  272b6				    palframeskipdone
   4057  272b6			8e b5 01	       stx	palframes
   4058  272b9				    skippalframeadjusting
   4059  272b9
   4060  272b9				   -	       ifconst	MUSICTRACKER
   4061  272b9				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   4062  272b9				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   4063  272b9				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   4064  272b9				   -			; problem twice, and if we do, we just drop a musical note or two.
   4065  272b9				   -	       lda	sfxschedulemissed
   4066  272b9				   -	       beq	servicesongwasnotmissed
   4067  272b9				   -	       jsr	servicesong
   4068  272b9				   -servicesongwasnotmissed
   4069  272b9					       endif		; MUSICTRACKER
   4070  272b9
   4071  272b9			60		       rts
   4072  272ba
   4073  272ba				    serviceatarivoxqueue
   4074  272ba				   -	       ifconst	AVOXVOICE
   4075  272ba				   -	       lda	voxlock
   4076  272ba				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   4077  272ba				   -skipvoxqueuesizedec
   4078  272ba				   -	       jmp	processavoxvoice
   4079  272ba				   -skipvoxprocessing
   4080  272ba				   -	       rts
   4081  272ba				   -
   4082  272ba				   -processavoxvoice
   4083  272ba				   -	       lda	avoxenable
   4084  272ba				   -	       bne	avoxfixport
   4085  272ba				   -	       SPKOUT	tempavox
   4086  272ba				   -	       rts
   4087  272ba				   -avoxfixport
   4088  272ba				   -	       lda	#0	; restore the port to all bits as inputs...
   4089  272ba				   -	       sta	CTLSWA
   4090  272ba				   -	       rts
   4091  272ba				   -silenceavoxvoice
   4092  272ba				   -	       SPEAK	avoxsilentdata
   4093  272ba				   -	       rts
   4094  272ba				   -avoxsilentdata
   4095  272ba				   -	       .byte	31,255
   4096  272ba					       else
   4097  272ba			60		       rts
   4098  272bb					       endif		; AVOXVOICE
   4099  272bb
   4100  272bb				    joybuttonhandler
   4101  272bb			8a		       txa
   4102  272bc			0a		       asl
   4103  272bd			a8		       tay
   4104  272be			b9 08 00	       lda	INPT0,y
   4105  272c1			4a		       lsr
   4106  272c2			9d 02 21	       sta	sINPT1,x
   4107  272c5			b9 09 00	       lda	INPT1,y
   4108  272c8			29 80		       and	#%10000000
   4109  272ca			1d 02 21	       ora	sINPT1,x
   4110  272cd			9d 02 21	       sta	sINPT1,x
   4111  272d0
   4112  272d0			b5 0c		       lda	INPT4,x
   4113  272d2			30 19		       bmi	.skip1bjoyfirecheck
   4114  272d4							;one button joystick is down
   4115  272d4			49 80		       eor	#%10000000
   4116  272d6			9d 02 21	       sta	sINPT1,x
   4117  272d9
   4118  272d9			ad b1 01	       lda	joybuttonmode
   4119  272dc			3d f0 f2	       and	twobuttonmask,x
   4120  272df			f0 0c		       beq	.skip1bjoyfirecheck
   4121  272e1			ad b1 01	       lda	joybuttonmode
   4122  272e4			1d f0 f2	       ora	twobuttonmask,x
   4123  272e7			8d b1 01	       sta	joybuttonmode
   4124  272ea			8d 82 02	       sta	SWCHB
   4125  272ed				    .skip1bjoyfirecheck
   4126  272ed			4c 9d f1	       jmp	buttonreadloopreturn
   4127  272f0
   4128  272f0				    twobuttonmask
   4129  272f0			04 10		       .byte.b	%00000100,%00010000
   4130  272f2
   4131  272f2				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   4132  272f2				   -	       ifconst	LIGHTGUNSUPPORT
   4133  272f2				   -	       cpx	#0
   4134  272f2				   -	       bne	secondportgunhandler
   4135  272f2				   -firstportgunhandler
   4136  272f2				   -	       lda	SWCHA
   4137  272f2				   -	       asl
   4138  272f2				   -	       asl
   4139  272f2				   -	       asl		; shift D4 to D7
   4140  272f2				   -	       and	#%10000000
   4141  272f2				   -	       eor	#%10000000
   4142  272f2				   -	       sta	sINPT1
   4143  272f2				   -	       jmp	buttonreadloopreturn
   4144  272f2				   -secondportgunhandler
   4145  272f2				   -	       lda	SWCHA
   4146  272f2				   -	       lsr		; shift D0 into carry
   4147  272f2				   -	       lsr		; shift carry into D7
   4148  272f2				   -	       and	#%10000000
   4149  272f2				   -	       eor	#%10000000
   4150  272f2				   -	       sta	sINPT3
   4151  272f2				   -	       jmp	buttonreadloopreturn
   4152  272f2					       endif		; LIGHTGUNSUPPORT
   4153  272f2
   4154  272f2				    controlsusing2buttoncode
   4155  272f2			00		       .byte.b	0	; 00=no controller plugged in
   4156  272f3			01		       .byte.b	1	; 01=proline joystick
   4157  272f4			00		       .byte.b	0	; 02=lightgun
   4158  272f5			00		       .byte.b	0	; 03=paddle
   4159  272f6			01		       .byte.b	1	; 04=trakball
   4160  272f7			01		       .byte.b	1	; 05=vcs joystick
   4161  272f8			01		       .byte.b	1	; 06=driving control
   4162  272f9			00		       .byte.b	0	; 07=keypad control
   4163  272fa			00		       .byte.b	0	; 08=st mouse/cx80
   4164  272fb			00		       .byte.b	0	; 09=amiga mouse
   4165  272fc			01		       .byte.b	1	; 10=atarivox
   4166  272fd
   4167  272fd				    buttonhandlerhi
   4168  272fd			00		       .byte.b	0	; 00=no controller plugged in
   4169  272fe			f2		       .byte.b	>joybuttonhandler	; 01=proline joystick
   4170  272ff			f2		       .byte.b	>gunbuttonhandler	; 02=lightgun
   4171  27300			f6		       .byte.b	>paddlebuttonhandler	; 03=paddle
   4172  27301			f2		       .byte.b	>joybuttonhandler	; 04=trakball
   4173  27302			f2		       .byte.b	>joybuttonhandler	; 05=vcs joystick
   4174  27303			f2		       .byte.b	>joybuttonhandler	; 06=driving control
   4175  27304			00		       .byte.b	0	; 07=keypad
   4176  27305			f6		       .byte.b	>mousebuttonhandler	; 08=st mouse
   4177  27306			f6		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   4178  27307			f2		       .byte.b	>joybuttonhandler	; 10=atarivox
   4179  27308				    buttonhandlerlo
   4180  27308			00		       .byte.b	0	; 00=no controller plugged in
   4181  27309			bb		       .byte.b	<joybuttonhandler	; 01=proline joystick
   4182  2730a			f2		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   4183  2730b			b3		       .byte.b	<paddlebuttonhandler	; 03=paddle
   4184  2730c			bb		       .byte.b	<joybuttonhandler	; 04=trakball
   4185  2730d			bb		       .byte.b	<joybuttonhandler	; 05=vcs joystick
   4186  2730e			bb		       .byte.b	<joybuttonhandler	; 06=driving control
   4187  2730f			00		       .byte.b	0	; 07=keypad
   4188  27310			b3		       .byte.b	<mousebuttonhandler	; 08=st mouse
   4189  27311			b3		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   4190  27312			bb		       .byte.b	<joybuttonhandler	; 10=atarivox
   4191  27313
   4192  27313				    drawwait
   4193  27313			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4194  27315			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   4195  27317			60		       rts
   4196  27318
   4197  27318				    drawoverwait
   4198  27318			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4199  2731a			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   4200  2731c			60		       rts
   4201  2731d
   4202  2731d
   4203  2731d				    mutetia
   4204  2731d			a9 00		       lda	#0
   4205  2731f			a2 03		       ldx	#3
   4206  27321				    mutetialoop
   4207  27321			95 4e		       sta	sfx1pointlo,x
   4208  27323			95 17		       sta	AUDF0,x
   4209  27325			ca		       dex
   4210  27326			10 f9		       bpl	mutetialoop
   4211  27328			60		       rts
   4212  27329
   4213  27329				    servicesfxchannelsdone
   4214  27329				   -	       ifnconst	pokeysupport
   4215  27329				   -	       rts
   4216  27329					       else
   4217  27329			4c 0d f0	       jmp	checkpokeyplaying
   4218  2732c					       endif
   4219  2732c				    servicesfxchannels
   4220  2732c			a2 ff		       ldx	#255
   4221  2732e				    servicesfxchannelsloop
   4222  2732e			e8		       inx
   4223  2732f					       ifnconst	TIASFXMONO
   4224  2732f			e0 02		       cpx	#2
   4225  27331				   -	       else
   4226  27331				   -	       cpx	#1
   4227  27331					       endif
   4228  27331			f0 f6		       beq	servicesfxchannelsdone
   4229  27333
   4230  27333			a5 de		       lda	sfxschedulelock	; =1 if locked
   4231  27335			d0 f2		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   4232  27337
   4233  27337			b5 4e		       lda	sfx1pointlo,x
   4234  27339			85 dc		       sta	inttemp5
   4235  2733b			15 50		       ora	sfx1pointhi,x
   4236  2733d			f0 ef		       beq	servicesfxchannelsloop
   4237  2733f			b5 50		       lda	sfx1pointhi,x
   4238  27341			85 dd		       sta	inttemp6
   4239  27343
   4240  27343			b5 58		       lda	sfx1tick,x
   4241  27345			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   4242  27347			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   4243  27349			4c 2e f3	       jmp	servicesfxchannelsloop
   4244  2734c				    servicesfx_cont1
   4245  2734c
   4246  2734c			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   4247  2734e			b1 dc		       lda	(inttemp5),y
   4248  27350			c9 10		       cmp	#$10
   4249  27352			d0 1b		       bne	servicesfx_cont1a
   4250  27354			a0 02		       ldy	#2
   4251  27356			b1 dc		       lda	(inttemp5),y
   4252  27358			95 56		       sta	sfx1frames,x	; change the frame countdown
   4253  2735a			a9 00		       lda	#0
   4254  2735c			95 58		       sta	sfx1tick,x
   4255  2735e							; advance the sound pointer by 3...
   4256  2735e			b5 4e		       lda	sfx1pointlo,x
   4257  27360			18		       clc
   4258  27361			69 03		       adc	#3
   4259  27363			95 4e		       sta	sfx1pointlo,x
   4260  27365			b5 50		       lda	sfx1pointhi,x
   4261  27367			69 00		       adc	#0
   4262  27369			95 50		       sta	sfx1pointhi,x
   4263  2736b							; and then fetch another sample for this channel...
   4264  2736b			ca		       dex
   4265  2736c			4c 2e f3	       jmp	servicesfxchannelsloop
   4266  2736f				    servicesfx_cont1a
   4267  2736f
   4268  2736f			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   4269  27371			95 58		       sta	sfx1tick,x
   4270  27373
   4271  27373			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   4272  27375			f0 02		       beq	servicesfx_cont2
   4273  27377			d6 52		       dec	sfx1priority,x
   4274  27379				    servicesfx_cont2
   4275  27379
   4276  27379			a0 00		       ldy	#0	; play the sound
   4277  2737b			b1 dc		       lda	(inttemp5),y
   4278  2737d			85 d8		       sta	inttemp1
   4279  2737f
   4280  2737f				   -	       ifconst	MUSICTRACKER
   4281  2737f				   -	       lda	sfx1notedata,x
   4282  2737f				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   4283  2737f				   -	       ldy	#0
   4284  2737f				   -	       sty	inttemp2
   4285  2737f				   -	       clc
   4286  2737f				   -	       adc	(inttemp5),y
   4287  2737f				   -	       asl		; x2
   4288  2737f				   -	       tay
   4289  2737f				   -	       lda	tiatrackeroctavenotes,y
   4290  2737f				   -	       sta	AUDC0,x
   4291  2737f				   -	       iny
   4292  2737f				   -	       lda	tiatrackeroctavenotes,y
   4293  2737f				   -	       sta	AUDF0,x
   4294  2737f				   -	       ldy	#1
   4295  2737f				   -	       jmp	sfxvolumeentrypt
   4296  2737f				   -exitmusictracker
   4297  2737f				   -	       lda	inttemp1
   4298  2737f					       endif		; MUSICTRACKER
   4299  2737f
   4300  2737f			18		       clc
   4301  27380			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   4302  27382			95 17		       sta	AUDF0,x
   4303  27384			c8		       iny
   4304  27385			b1 dc		       lda	(inttemp5),y
   4305  27387			95 15		       sta	AUDC0,x
   4306  27389			85 d9		       sta	inttemp2
   4307  2738b			c8		       iny
   4308  2738c				    sfxvolumeentrypt
   4309  2738c			b1 dc		       lda	(inttemp5),y
   4310  2738e			95 19		       sta	AUDV0,x
   4311  27390			c9 10		       cmp	#$10
   4312  27392			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   4313  27394
   4314  27394			05 d9		       ora	inttemp2
   4315  27396			05 d8		       ora	inttemp1	; check if F|C|V=0
   4316  27398			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   4317  2739a
   4318  2739a				    advancesfxpointer
   4319  2739a							; advance the pointer to the next sound chunk
   4320  2739a			c8		       iny
   4321  2739b			84 da		       sty	inttemp3
   4322  2739d			18		       clc
   4323  2739e			b5 4e		       lda	sfx1pointlo,x
   4324  273a0			65 da		       adc	inttemp3
   4325  273a2			95 4e		       sta	sfx1pointlo,x
   4326  273a4			b5 50		       lda	sfx1pointhi,x
   4327  273a6			69 00		       adc	#0
   4328  273a8			95 50		       sta	sfx1pointhi,x
   4329  273aa			4c 2e f3	       jmp	servicesfxchannelsloop
   4330  273ad
   4331  273ad				    sfxsoundloop
   4332  273ad			48		       pha
   4333  273ae			b5 52		       lda	sfx1priority,x
   4334  273b0			d0 04		       bne	sfxsoundloop_carryon
   4335  273b2			68		       pla		; fix the stack before we go
   4336  273b3			4c 9a f3	       jmp	advancesfxpointer
   4337  273b6				    sfxsoundloop_carryon
   4338  273b6			68		       pla
   4339  273b7			29 f0		       and	#$F0
   4340  273b9			4a		       lsr
   4341  273ba			4a		       lsr
   4342  273bb			4a		       lsr
   4343  273bc			4a		       lsr
   4344  273bd
   4345  273bd				    zerosfx
   4346  273bd			95 4e		       sta	sfx1pointlo,x
   4347  273bf			95 50		       sta	sfx1pointhi,x
   4348  273c1			95 52		       sta	sfx1priority,x
   4349  273c3			4c 2e f3	       jmp	servicesfxchannelsloop
   4350  273c6
   4351  273c6
   4352  273c6				    schedulesfx
   4353  273c6							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   4354  273c6			a0 00		       ldy	#0
   4355  273c8			b1 e0		       lda	(sfxinstrumentlo),y
   4356  273ca					       ifconst	pokeysupport
   4357  273ca			c9 20		       cmp	#$20	; POKEY?
   4358  273cc			d0 03		       bne	scheduletiasfx
   4359  273ce			4c 70 f0	       jmp	schedulepokeysfx
   4360  273d1					       endif
   4361  273d1				    scheduletiasfx
   4362  273d1							;cmp #$10 ; TIA?
   4363  273d1							;beq continuescheduletiasfx
   4364  273d1							; rts ; unhandled!!! 
   4365  273d1				    continuescheduletiasfx
   4366  273d1					       ifnconst	TIASFXMONO
   4367  273d1			a5 4e		       lda	sfx1pointlo
   4368  273d3			05 50		       ora	sfx1pointhi
   4369  273d5			f0 13		       beq	schedulesfx1	;if channel 1 is idle, use it
   4370  273d7			a5 4f		       lda	sfx2pointlo
   4371  273d9			05 51		       ora	sfx2pointhi
   4372  273db			f0 11		       beq	schedulesfx2	;if channel 2 is idle, use it
   4373  273dd							; Both channels are scheduled. 
   4374  273dd			a0 01		       ldy	#1
   4375  273df			b1 e0		       lda	(sfxinstrumentlo),y
   4376  273e1			d0 01		       bne	interruptsfx
   4377  273e3			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   4378  273e4				    interruptsfx
   4379  273e4							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   4380  273e4			a5 52		       lda	sfx1priority
   4381  273e6			c5 53		       cmp	sfx2priority
   4382  273e8			b0 04		       bcs	schedulesfx2
   4383  273ea					       endif		; !TIASFXMONO
   4384  273ea
   4385  273ea				    schedulesfx1
   4386  273ea			a2 00		       ldx	#0	; channel 1
   4387  273ec					       ifnconst	TIASFXMONO
   4388  273ec			f0 02		       beq	skipschedulesfx2
   4389  273ee				    schedulesfx2
   4390  273ee			a2 01		       ldx	#1	; channel 2
   4391  273f0				    skipschedulesfx2
   4392  273f0					       endif		; !TIASFXMONO
   4393  273f0
   4394  273f0				   -	       ifconst	MUSICTRACKER
   4395  273f0				   -	       lda	sfxnoteindex
   4396  273f0				   -	       bpl	skipdrumkitoverride
   4397  273f0				   -	       and	#$7F	; subtract 128
   4398  273f0				   -	       sec
   4399  273f0				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   4400  273f0				   -	       asl
   4401  273f0				   -	       tay
   4402  273f0				   -	       lda	tiadrumkitdefinition,y
   4403  273f0				   -	       sta	sfxinstrumentlo
   4404  273f0				   -	       iny
   4405  273f0				   -	       lda	tiadrumkitdefinition,y
   4406  273f0				   -	       sta	sfxinstrumenthi
   4407  273f0				   -	       lda	#0
   4408  273f0				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   4409  273f0				   -skipdrumkitoverride
   4410  273f0					       endif		; MUSICTRACKER
   4411  273f0			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   4412  273f2			b1 e0		       lda	(sfxinstrumentlo),y
   4413  273f4			95 52		       sta	sfx1priority,x
   4414  273f6			c8		       iny
   4415  273f7			b1 e0		       lda	(sfxinstrumentlo),y
   4416  273f9			95 56		       sta	sfx1frames,x
   4417  273fb			a5 e0		       lda	sfxinstrumentlo
   4418  273fd			18		       clc
   4419  273fe			69 03		       adc	#3
   4420  27400			95 4e		       sta	sfx1pointlo,x
   4421  27402			a5 e1		       lda	sfxinstrumenthi
   4422  27404			69 00		       adc	#0
   4423  27406			95 50		       sta	sfx1pointhi,x
   4424  27408			a5 e2		       lda	sfxpitchoffset
   4425  2740a			95 54		       sta	sfx1poffset,x
   4426  2740c			a9 00		       lda	#0
   4427  2740e			95 58		       sta	sfx1tick,x
   4428  27410			a5 e3		       lda	sfxnoteindex
   4429  27412			95 cd		       sta	sfx1notedata,x
   4430  27414			60		       rts
   4431  27415
   4432  27415				    plotsprite
   4433  27415					       ifnconst	NODRAWWAIT
   4434  27415				   -	       ifconst	DOUBLEBUFFER
   4435  27415				   -	       lda	doublebufferstate
   4436  27415				   -	       bne	skipplotspritewait
   4437  27415					       endif		; DOUBLEBUFFER
   4438  27415				   -	       ifconst	DEBUGWAITCOLOR
   4439  27415				   -	       lda	#$41
   4440  27415				   -	       sta	BACKGRND
   4441  27415					       endif
   4442  27415				    plotspritewait
   4443  27415			a5 4d		       lda	visibleover
   4444  27417			d0 fc		       bne	plotspritewait
   4445  27419				    skipplotspritewait
   4446  27419				   -	       ifconst	DEBUGWAITCOLOR
   4447  27419				   -	       lda	#$0
   4448  27419				   -	       sta	BACKGRND
   4449  27419					       endif
   4450  27419					       endif
   4451  27419
   4452  27419							;arguments: 
   4453  27419							; temp1=lo graphicdata 
   4454  27419							; temp2=hi graphicdata 
   4455  27419							; temp3=palette | width byte
   4456  27419							; temp4=x
   4457  27419							; temp5=y
   4458  27419							; temp6=mode
   4459  27419			a5 46		       lda	temp5	;Y position
   4460  2741b			4a		       lsr		; 2 - Divide by 8 or 16
   4461  2741c			4a		       lsr		; 2
   4462  2741d			4a		       lsr		; 2
   4463  2741e					       if	WZONEHEIGHT = 16
   4464  2741e			4a		       lsr		; 2
   4465  2741f					       endif
   4466  2741f
   4467  2741f			aa		       tax
   4468  27420
   4469  27420					       ifnconst	NOLIMITCHECKING
   4470  27420
   4471  27420							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   4472  27420
   4473  27420			c9 0c		       cmp	#WZONECOUNT
   4474  27422
   4475  27422			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   4476  27424							; otherwise, check to see if the bottom half is in zone 0...
   4477  27424
   4478  27424					       if	WZONEHEIGHT = 16
   4479  27424			c9 0f		       cmp	#15
   4480  27426				   -	       else
   4481  27426				   -	       cmp	#31
   4482  27426					       endif
   4483  27426
   4484  27426			d0 05		       bne	exitplotsprite1
   4485  27428			a2 00		       ldx	#0
   4486  2742a			4c 63 f4	       jmp	continueplotsprite2
   4487  2742d				    exitplotsprite1
   4488  2742d			60		       rts
   4489  2742e
   4490  2742e				    continueplotsprite1
   4491  2742e					       endif
   4492  2742e
   4493  2742e			bd ac f7	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   4494  27431				   -	       ifconst	DOUBLEBUFFER
   4495  27431				   -	       clc
   4496  27431				   -	       adc	doublebufferdloffset
   4497  27431					       endif		; DOUBLEBUFFER
   4498  27431			85 63		       sta	dlpnt
   4499  27433			bd a0 f7	       lda	DLPOINTH,x
   4500  27436				   -	       ifconst	DOUBLEBUFFER
   4501  27436				   -	       adc	#0
   4502  27436					       endif		; DOUBLEBUFFER
   4503  27436			85 64		       sta	dlpnt+1
   4504  27438
   4505  27438							;Create DL entry for upper part of sprite
   4506  27438
   4507  27438			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   4508  2743a
   4509  2743a				   -	       ifconst	CHECKOVERWRITE
   4510  2743a				   -	       cpy	#DLLASTOBJ
   4511  2743a				   -	       beq	checkcontinueplotsprite2
   4512  2743a				   -continueplotsprite1a
   4513  2743a					       endif
   4514  2743a
   4515  2743a			a5 42		       lda	temp1	; graphic data, lo byte
   4516  2743c			91 63		       sta	(dlpnt),y	;Low byte of data address
   4517  2743e
   4518  2743e					       ifnconst	ATOMICSPRITEUPDATE
   4519  2743e			c8		       iny
   4520  2743f			a5 47		       lda	temp6
   4521  27441			91 63		       sta	(dlpnt),y
   4522  27443				   -	       else
   4523  27443				   -	       iny
   4524  27443				   -	       sty	temp8
   4525  27443					       endif
   4526  27443
   4527  27443			c8		       iny
   4528  27444
   4529  27444			a5 46		       lda	temp5	;Y position
   4530  27446			29 0f		       and	#(WZONEHEIGHT - 1)
   4531  27448			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   4532  2744a			05 43		       ora	temp2	; graphic data, hi byte
   4533  2744c			91 63		       sta	(dlpnt),y
   4534  2744e
   4535  2744e
   4536  2744e			c8		       iny
   4537  2744f			a5 44		       lda	temp3	;palette|width
   4538  27451			91 63		       sta	(dlpnt),y
   4539  27453
   4540  27453			c8		       iny
   4541  27454			a5 45		       lda	temp4	;Horizontal position
   4542  27456			91 63		       sta	(dlpnt),y
   4543  27458
   4544  27458			c8		       iny
   4545  27459			94 65		       sty	dlend,x
   4546  2745b
   4547  2745b				   -	       ifconst	ALWAYSTERMINATE
   4548  2745b				   -	       iny
   4549  2745b				   -	       lda	#0
   4550  2745b				   -	       sta	(dlpnt),y
   4551  2745b					       endif
   4552  2745b
   4553  2745b				   -	       ifconst	ATOMICSPRITEUPDATE
   4554  2745b				   -	       ldy	temp8
   4555  2745b				   -	       lda	temp6
   4556  2745b				   -	       sta	(dlpnt),y
   4557  2745b					       endif
   4558  2745b
   4559  2745b				    checkcontinueplotsprite2
   4560  2745b
   4561  2745b			90 33		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   4562  2745d
   4563  2745d							;Create DL entry for lower part of sprite
   4564  2745d
   4565  2745d			e8		       inx		;Next region
   4566  2745e
   4567  2745e					       ifnconst	NOLIMITCHECKING
   4568  2745e			e0 0c		       cpx	#WZONECOUNT
   4569  27460
   4570  27460			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   4571  27462			60		       rts
   4572  27463				    continueplotsprite2
   4573  27463					       endif
   4574  27463
   4575  27463			bd ac f7	       lda	DLPOINTL,x	;Get pointer to next DL
   4576  27466				   -	       ifconst	DOUBLEBUFFER
   4577  27466				   -	       clc
   4578  27466				   -	       adc	doublebufferdloffset
   4579  27466					       endif		; DOUBLEBUFFER
   4580  27466			85 63		       sta	dlpnt
   4581  27468			bd a0 f7	       lda	DLPOINTH,x
   4582  2746b				   -	       ifconst	DOUBLEBUFFER
   4583  2746b				   -	       adc	#0
   4584  2746b					       endif		; DOUBLEBUFFER
   4585  2746b			85 64		       sta	dlpnt+1
   4586  2746d			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   4587  2746f
   4588  2746f				   -	       ifconst	CHECKOVERWRITE
   4589  2746f				   -	       cpy	#DLLASTOBJ
   4590  2746f				   -	       bne	continueplotsprite2a
   4591  2746f				   -	       rts
   4592  2746f				   -continueplotsprite2a
   4593  2746f					       endif
   4594  2746f
   4595  2746f			a5 42		       lda	temp1	; graphic data, lo byte
   4596  27471			91 63		       sta	(dlpnt),y
   4597  27473
   4598  27473					       ifnconst	ATOMICSPRITEUPDATE
   4599  27473			c8		       iny
   4600  27474			a5 47		       lda	temp6
   4601  27476			91 63		       sta	(dlpnt),y
   4602  27478				   -	       else
   4603  27478				   -	       iny
   4604  27478				   -	       sty	temp8
   4605  27478					       endif
   4606  27478
   4607  27478			c8		       iny
   4608  27479
   4609  27479			a5 46		       lda	temp5	;Y position
   4610  2747b			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   4611  2747d			05 43		       ora	temp2	; graphic data, hi byte
   4612  2747f			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   4613  27481			91 63		       sta	(dlpnt),y
   4614  27483
   4615  27483			c8		       iny
   4616  27484
   4617  27484			a5 44		       lda	temp3	;palette|width
   4618  27486			91 63		       sta	(dlpnt),y
   4619  27488
   4620  27488			c8		       iny
   4621  27489
   4622  27489			a5 45		       lda	temp4	;Horizontal position
   4623  2748b			91 63		       sta	(dlpnt),y
   4624  2748d
   4625  2748d			c8		       iny
   4626  2748e			94 65		       sty	dlend,x
   4627  27490
   4628  27490				   -	       ifconst	ALWAYSTERMINATE
   4629  27490				   -	       iny
   4630  27490				   -	       lda	#0
   4631  27490				   -	       sta	(dlpnt),y
   4632  27490					       endif
   4633  27490
   4634  27490				   -	       ifconst	ATOMICSPRITEUPDATE
   4635  27490				   -	       ldy	temp8
   4636  27490				   -	       lda	temp6
   4637  27490				   -	       sta	(dlpnt),y
   4638  27490					       endif
   4639  27490
   4640  27490				    doneSPDL
   4641  27490			60		       rts
   4642  27491
   4643  27491
   4644  27491				    lockzonex
   4645  27491				   -	       ifconst	ZONELOCKS
   4646  27491				   -	       ldy	dlend,x
   4647  27491				   -	       cpy	#DLLASTOBJ
   4648  27491				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   4649  27491				   -	       lda	DLPOINTL,x
   4650  27491				   -	       ifconst	DOUBLEBUFFER
   4651  27491				   -	       clc
   4652  27491				   -	       adc	doublebufferdloffset
   4653  27491				   -	       endif		; DOUBLEBUFFER
   4654  27491				   -	       sta	dlpnt
   4655  27491				   -	       lda	DLPOINTH,x
   4656  27491				   -	       ifconst	DOUBLEBUFFER
   4657  27491				   -	       adc	#0
   4658  27491				   -	       endif		; DOUBLEBUFFER
   4659  27491				   -	       sta	dlpnt+1
   4660  27491				   -	       iny
   4661  27491				   -	       lda	#0
   4662  27491				   -	       sta	(dlpnt),y
   4663  27491				   -	       dey
   4664  27491				   -	       tya
   4665  27491				   -	       ldy	#(DLLASTOBJ-1)
   4666  27491				   -	       sta	(dlpnt),y
   4667  27491				   -	       iny
   4668  27491				   -	       sty	dlend,x
   4669  27491				   -lockzonexreturn
   4670  27491				   -	       rts
   4671  27491					       endif		; ZONELOCKS
   4672  27491				    unlockzonex
   4673  27491				   -	       ifconst	ZONELOCKS
   4674  27491				   -	       ldy	dlend,x
   4675  27491				   -	       cpy	#DLLASTOBJ
   4676  27491				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   4677  27491				   -	       lda	DLPOINTL,x
   4678  27491				   -	       ifconst	DOUBLEBUFFER
   4679  27491				   -	       clc
   4680  27491				   -	       adc	doublebufferdloffset
   4681  27491				   -	       endif		; DOUBLEBUFFER
   4682  27491				   -	       sta	dlpnt
   4683  27491				   -	       lda	DLPOINTH,x
   4684  27491				   -	       ifconst	DOUBLEBUFFER
   4685  27491				   -	       adc	#0
   4686  27491				   -	       endif		; DOUBLEBUFFER
   4687  27491				   -	       sta	dlpnt+1
   4688  27491				   -	       dey
   4689  27491				   -			;ldy #(DLLASTOBJ-1)
   4690  27491				   -	       lda	(dlpnt),y
   4691  27491				   -	       tay
   4692  27491				   -	       sty	dlend,x
   4693  27491				   -unlockzonexreturn
   4694  27491					       endif		; ZONELOCKS
   4695  27491			60		       rts
   4696  27492
   4697  27492				    plotcharloop
   4698  27492							; ** read from a data indirectly pointed to from temp8,temp9
   4699  27492							; ** format is: lo_data, hi_data, palette|width, x, y
   4700  27492							; ** format ends with lo_data | hi_data = 0
   4701  27492
   4702  27492				   -	       ifconst	DOUBLEBUFFER
   4703  27492				   -	       lda	doublebufferstate
   4704  27492				   -	       bne	skipplotcharloopwait
   4705  27492					       endif		; DOUBLEBUFFER
   4706  27492				   -	       ifconst	DEBUGWAITCOLOR
   4707  27492				   -	       lda	#$61
   4708  27492				   -	       sta	BACKGRND
   4709  27492					       endif
   4710  27492				    plotcharloopwait
   4711  27492			a5 4d		       lda	visibleover
   4712  27494			d0 fc		       bne	plotcharloopwait
   4713  27496				   -	       ifconst	DEBUGWAITCOLOR
   4714  27496				   -	       lda	#0
   4715  27496				   -	       sta	BACKGRND
   4716  27496					       endif
   4717  27496				    skipplotcharloopwait
   4718  27496				    plotcharlooploop
   4719  27496			a0 00		       ldy	#0
   4720  27498			b1 49		       lda	(temp8),y
   4721  2749a			85 42		       sta	temp1
   4722  2749c			c8		       iny
   4723  2749d			b1 49		       lda	(temp8),y
   4724  2749f			85 43		       sta	temp2
   4725  274a1			05 42		       ora	temp1
   4726  274a3			d0 01		       bne	plotcharloopcontinue
   4727  274a5							;the pointer=0, so return
   4728  274a5			60		       rts
   4729  274a6				    plotcharloopcontinue
   4730  274a6			c8		       iny
   4731  274a7			b1 49		       lda	(temp8),y
   4732  274a9			85 44		       sta	temp3
   4733  274ab			c8		       iny
   4734  274ac			b1 49		       lda	(temp8),y
   4735  274ae			85 45		       sta	temp4
   4736  274b0			c8		       iny
   4737  274b1			b1 49		       lda	(temp8),y
   4738  274b3							;sta temp5 ; not needed with our late entry.
   4739  274b3			20 cc f4	       jsr	plotcharactersskipentry
   4740  274b6			a5 49		       lda	temp8
   4741  274b8			18		       clc
   4742  274b9			69 05		       adc	#5
   4743  274bb			85 49		       sta	temp8
   4744  274bd			a5 4a		       lda	temp9
   4745  274bf			69 00		       adc	#0
   4746  274c1			85 4a		       sta	temp9
   4747  274c3			4c 96 f4	       jmp	plotcharlooploop
   4748  274c6
   4749  274c6				    plotcharacters
   4750  274c6				   -	       ifconst	DOUBLEBUFFER
   4751  274c6				   -	       lda	doublebufferstate
   4752  274c6				   -	       bne	skipplotcharacterswait
   4753  274c6					       endif		; DOUBLEBUFFER
   4754  274c6				   -	       ifconst	DEBUGWAITCOLOR
   4755  274c6				   -	       lda	#$41
   4756  274c6				   -	       sta	BACKGRND
   4757  274c6					       endif
   4758  274c6				    plotcharacterswait
   4759  274c6			a5 4d		       lda	visibleover
   4760  274c8			d0 fc		       bne	plotcharacterswait
   4761  274ca				   -	       ifconst	DEBUGWAITCOLOR
   4762  274ca				   -	       sta	BACKGRND
   4763  274ca					       endif
   4764  274ca				    skipplotcharacterswait
   4765  274ca							;arguments: 
   4766  274ca							; temp1=lo charactermap
   4767  274ca							; temp2=hi charactermap
   4768  274ca							; temp3=palette | width byte
   4769  274ca							; temp4=x
   4770  274ca							; temp5=y
   4771  274ca
   4772  274ca			a5 46		       lda	temp5	;Y position
   4773  274cc
   4774  274cc				    plotcharactersskipentry
   4775  274cc
   4776  274cc							;ifconst ZONEHEIGHT
   4777  274cc							; if ZONEHEIGHT = 16
   4778  274cc							; and #$0F
   4779  274cc							; endif
   4780  274cc							; if ZONEHEIGHT = 8
   4781  274cc							; and #$1F
   4782  274cc							; endif
   4783  274cc							;else
   4784  274cc							; and #$0F
   4785  274cc							;endif
   4786  274cc
   4787  274cc			aa		       tax
   4788  274cd			bd ac f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4789  274d0				   -	       ifconst	DOUBLEBUFFER
   4790  274d0				   -	       clc
   4791  274d0				   -	       adc	doublebufferdloffset
   4792  274d0					       endif		; DOUBLEBUFFER
   4793  274d0			85 63		       sta	dlpnt
   4794  274d2			bd a0 f7	       lda	DLPOINTH,x
   4795  274d5				   -	       ifconst	DOUBLEBUFFER
   4796  274d5				   -	       adc	#0
   4797  274d5					       endif		; DOUBLEBUFFER
   4798  274d5			85 64		       sta	dlpnt+1
   4799  274d7
   4800  274d7							;Create DL entry for the characters
   4801  274d7
   4802  274d7			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   4803  274d9
   4804  274d9				   -	       ifconst	CHECKOVERWRITE
   4805  274d9				   -	       cpy	#DLLASTOBJ
   4806  274d9				   -	       bne	continueplotcharacters
   4807  274d9				   -	       rts
   4808  274d9				   -continueplotcharacters
   4809  274d9					       endif
   4810  274d9
   4811  274d9			a5 42		       lda	temp1	; character map data, lo byte
   4812  274db			91 63		       sta	(dlpnt),y	;(1) store low address
   4813  274dd
   4814  274dd			c8		       iny
   4815  274de			ad 06 21	       lda	charactermode
   4816  274e1			91 63		       sta	(dlpnt),y	;(2) store mode
   4817  274e3
   4818  274e3			c8		       iny
   4819  274e4			a5 43		       lda	temp2	; character map, hi byte
   4820  274e6			91 63		       sta	(dlpnt),y	;(3) store high address
   4821  274e8
   4822  274e8			c8		       iny
   4823  274e9			a5 44		       lda	temp3	;palette|width
   4824  274eb			91 63		       sta	(dlpnt),y	;(4) store palette|width
   4825  274ed
   4826  274ed			c8		       iny
   4827  274ee			a5 45		       lda	temp4	;Horizontal position
   4828  274f0			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   4829  274f2
   4830  274f2			c8		       iny
   4831  274f3			94 65		       sty	dlend,x	; save display list end byte
   4832  274f5			60		       rts
   4833  274f6
   4834  274f6
   4835  274f6					       ifconst	plotvalueonscreen
   4836  274f6				    plotcharacterslive
   4837  274f6							; a version of plotcharacters that draws live and minimally disrupts the screen...
   4838  274f6
   4839  274f6							;arguments: 
   4840  274f6							; temp1=lo charactermap
   4841  274f6							; temp2=hi charactermap
   4842  274f6							; temp3=palette | width byte
   4843  274f6							; temp4=x
   4844  274f6							; temp5=y
   4845  274f6
   4846  274f6			a5 46		       lda	temp5	;Y position
   4847  274f8
   4848  274f8			aa		       tax
   4849  274f9			bd ac f7	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4850  274fc				   -	       ifconst	DOUBLEBUFFER
   4851  274fc				   -	       clc
   4852  274fc				   -	       adc	doublebufferdloffset
   4853  274fc					       endif		; DOUBLEBUFFER
   4854  274fc			85 63		       sta	dlpnt
   4855  274fe			bd a0 f7	       lda	DLPOINTH,x
   4856  27501				   -	       ifconst	DOUBLEBUFFER
   4857  27501				   -	       adc	#0
   4858  27501					       endif		; DOUBLEBUFFER
   4859  27501			85 64		       sta	dlpnt+1
   4860  27503
   4861  27503							;Create DL entry for the characters
   4862  27503
   4863  27503			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   4864  27505
   4865  27505				   -	       ifconst	CHECKOVERWRITE
   4866  27505				   -	       cpy	#DLLASTOBJ
   4867  27505				   -	       bne	continueplotcharacterslive
   4868  27505				   -	       rts
   4869  27505				   -continueplotcharacterslive
   4870  27505					       endif
   4871  27505
   4872  27505			a5 42		       lda	temp1	; character map data, lo byte
   4873  27507			91 63		       sta	(dlpnt),y	;(1) store low address
   4874  27509
   4875  27509			c8		       iny
   4876  2750a							; we don't add the second byte yet, since the charmap could briefly
   4877  2750a							; render without a proper character map address, width, or position.
   4878  2750a			ad 06 21	       lda	charactermode
   4879  2750d			91 63		       sta	(dlpnt),y	;(2) store mode
   4880  2750f
   4881  2750f			c8		       iny
   4882  27510			a5 43		       lda	temp2	; character map, hi byte
   4883  27512			91 63		       sta	(dlpnt),y	;(3) store high address
   4884  27514
   4885  27514			c8		       iny
   4886  27515			a5 44		       lda	temp3	;palette|width
   4887  27517			91 63		       sta	(dlpnt),y	;(4) store palette|width
   4888  27519
   4889  27519			c8		       iny
   4890  2751a			a5 45		       lda	temp4	;Horizontal position
   4891  2751c			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   4892  2751e
   4893  2751e			c8		       iny
   4894  2751f			94 65		       sty	dlend,x	; save display list end byte
   4895  27521
   4896  27521			60		       rts
   4897  27522					       endif		;plotcharacterslive
   4898  27522
   4899  27522					       ifconst	USED_PLOTVALUE
   4900  27522				    plotvalue
   4901  27522							; calling 7800basic command:
   4902  27522							; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4903  27522							; ...displays the variable as BCD digits
   4904  27522							;
   4905  27522							; asm sub arguments: 
   4906  27522							; temp1=lo charactermap
   4907  27522							; temp2=hi charactermap
   4908  27522							; temp3=palette | width byte
   4909  27522							; temp4=x
   4910  27522							; temp5=y
   4911  27522							; temp6=number of digits
   4912  27522							; temp7=lo variable
   4913  27522							; temp8=hi variable
   4914  27522							; temp9=character mode
   4915  27522
   4916  27522			00 47	    plotdigitcount =	temp6
   4917  27522
   4918  27522				   -	       ifconst	ZONELOCKS
   4919  27522				   -	       ldx	temp5
   4920  27522				   -	       ldy	dlend,x
   4921  27522				   -	       cpy	#DLLASTOBJ
   4922  27522				   -	       bne	carryonplotvalue
   4923  27522				   -	       rts
   4924  27522				   -carryonplotvalue
   4925  27522					       endif
   4926  27522
   4927  27522			a9 00		       lda	#0
   4928  27524			a8		       tay
   4929  27525			ae ad 01	       ldx	valbufend
   4930  27528
   4931  27528			a5 47		       lda	plotdigitcount
   4932  2752a			29 01		       and	#1
   4933  2752c			f0 07		       beq	pvnibble2char
   4934  2752e			a9 00		       lda	#0
   4935  27530			9d 00 20	       sta	VALBUFFER,x	; just in case we skip this digit
   4936  27533			f0 11		       beq	pvnibble2char_skipnibble
   4937  27535
   4938  27535				    pvnibble2char
   4939  27535							; high nibble...
   4940  27535			b1 48		       lda	(temp7),y
   4941  27537			29 f0		       and	#$f0
   4942  27539			4a		       lsr
   4943  2753a			4a		       lsr
   4944  2753b			4a		       lsr
   4945  2753c					       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4946  2753c			4a		       lsr
   4947  2753d					       endif
   4948  2753d
   4949  2753d			18		       clc
   4950  2753e			65 42		       adc	temp1	; add the offset to character graphics to our value
   4951  27540			9d 00 20	       sta	VALBUFFER,x
   4952  27543			e8		       inx
   4953  27544			c6 47		       dec	plotdigitcount
   4954  27546
   4955  27546				    pvnibble2char_skipnibble
   4956  27546							; low nibble...
   4957  27546			b1 48		       lda	(temp7),y
   4958  27548			29 0f		       and	#$0f
   4959  2754a				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4960  2754a				   -	       asl
   4961  2754a					       endif
   4962  2754a			18		       clc
   4963  2754b			65 42		       adc	temp1	; add the offset to character graphics to our value
   4964  2754d			9d 00 20	       sta	VALBUFFER,x
   4965  27550			e8		       inx
   4966  27551			c8		       iny
   4967  27552
   4968  27552			c6 47		       dec	plotdigitcount
   4969  27554			d0 df		       bne	pvnibble2char
   4970  27556
   4971  27556							;point to the start of our valuebuffer
   4972  27556			18		       clc
   4973  27557			a9 00		       lda	#<VALBUFFER
   4974  27559			6d ad 01	       adc	valbufend
   4975  2755c			85 42		       sta	temp1
   4976  2755e			a9 20		       lda	#>VALBUFFER
   4977  27560			69 00		       adc	#0
   4978  27562			85 43		       sta	temp2
   4979  27564
   4980  27564							;advance valbufend to the end of our value buffer
   4981  27564			8e ad 01	       stx	valbufend
   4982  27567
   4983  27567				   -	       ifnconst	plotvalueonscreen
   4984  27567				   -	       jmp	plotcharacters
   4985  27567					       else
   4986  27567			4c f6 f4	       jmp	plotcharacterslive
   4987  2756a					       endif
   4988  2756a
   4989  2756a					       endif		; USED_PLOTVALUE
   4990  2756a
   4991  2756a
   4992  2756a				   -	       ifconst	USED_PLOTVALUEEXTRA
   4993  2756a				   -plotdigitcount =	temp6
   4994  2756a				   -plotvalueextra
   4995  2756a				   -			; calling 7800basic command:
   4996  2756a				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4997  2756a				   -			; ...displays the variable as BCD digits
   4998  2756a				   -			;
   4999  2756a				   -			; asm sub arguments: 
   5000  2756a				   -			; temp1=lo charactermap
   5001  2756a				   -			; temp2=hi charactermap
   5002  2756a				   -			; temp3=palette | width byte
   5003  2756a				   -			; temp4=x
   5004  2756a				   -			; temp5=y
   5005  2756a				   -			; temp6=number of digits
   5006  2756a				   -			; temp7=lo variable
   5007  2756a				   -			; temp8=hi variable
   5008  2756a				   -
   5009  2756a				   -	       lda	#0
   5010  2756a				   -	       tay
   5011  2756a				   -	       ldx	valbufend
   5012  2756a				   -	       ifnconst	plotvalueonscreen
   5013  2756a				   -	       sta	VALBUFFER,x
   5014  2756a				   -	       endif
   5015  2756a				   -
   5016  2756a				   -	       lda	plotdigitcount
   5017  2756a				   -	       and	#1
   5018  2756a				   -
   5019  2756a				   -	       bne	pvnibble2char_skipnibbleextra
   5020  2756a				   -
   5021  2756a				   -pvnibble2charextra
   5022  2756a				   -			; high nibble...
   5023  2756a				   -	       lda	(temp7),y
   5024  2756a				   -	       and	#$f0
   5025  2756a				   -	       lsr
   5026  2756a				   -	       lsr
   5027  2756a				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5028  2756a				   -	       lsr
   5029  2756a				   -	       endif
   5030  2756a				   -	       clc
   5031  2756a				   -	       adc	temp1	; add the offset to character graphics to our value
   5032  2756a				   -	       sta	VALBUFFER,x
   5033  2756a				   -	       inx
   5034  2756a				   -
   5035  2756a				   -			; second half of the digit
   5036  2756a				   -	       clc
   5037  2756a				   -	       adc	#1
   5038  2756a				   -	       sta	VALBUFFER,x
   5039  2756a				   -	       inx
   5040  2756a				   -
   5041  2756a				   -pvnibble2char_skipnibbleextra
   5042  2756a				   -			; low nibble...
   5043  2756a				   -	       lda	(temp7),y
   5044  2756a				   -	       and	#$0f
   5045  2756a				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5046  2756a				   -	       asl
   5047  2756a				   -	       endif
   5048  2756a				   -	       asl
   5049  2756a				   -
   5050  2756a				   -	       clc
   5051  2756a				   -	       adc	temp1	; add the offset to character graphics to our value
   5052  2756a				   -	       sta	VALBUFFER,x
   5053  2756a				   -	       inx
   5054  2756a				   -
   5055  2756a				   -	       clc
   5056  2756a				   -	       adc	#1
   5057  2756a				   -	       sta	VALBUFFER,x
   5058  2756a				   -	       inx
   5059  2756a				   -	       iny
   5060  2756a				   -
   5061  2756a				   -	       dec	plotdigitcount
   5062  2756a				   -	       bne	pvnibble2charextra
   5063  2756a				   -
   5064  2756a				   -			;point to the start of our valuebuffer
   5065  2756a				   -	       clc
   5066  2756a				   -	       lda	#<VALBUFFER
   5067  2756a				   -	       adc	valbufend
   5068  2756a				   -	       sta	temp1
   5069  2756a				   -	       lda	#>VALBUFFER
   5070  2756a				   -	       adc	#0
   5071  2756a				   -	       sta	temp2
   5072  2756a				   -
   5073  2756a				   -			;advance valbufend to the end of our value buffer
   5074  2756a				   -	       stx	valbufend
   5075  2756a				   -
   5076  2756a				   -	       ifnconst	plotvalueonscreen
   5077  2756a				   -	       jmp	plotcharacters
   5078  2756a				   -	       else
   5079  2756a				   -	       jmp	plotcharacterslive
   5080  2756a				   -	       endif
   5081  2756a					       endif		; USED_PLOTVALUEEXTRA
   5082  2756a
   5083  2756a				    boxcollision
   5084  2756a				   -	       ifconst	BOXCOLLISION
   5085  2756a				   -			; the worst case cycle-time for the code below is 43 cycles.
   5086  2756a				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   5087  2756a				   -
   5088  2756a				   -			;__boxx1 = accumulator
   5089  2756a				   -			;__boxy1 = y
   5090  2756a				   -__boxw1    =	temp3
   5091  2756a				   -__boxh1    =	temp4
   5092  2756a				   -
   5093  2756a				   -__boxx2    =	temp5
   5094  2756a				   -__boxy2    =	temp6
   5095  2756a				   -__boxw2    =	temp7
   5096  2756a				   -__boxh2    =	temp8
   5097  2756a				   -
   5098  2756a				   -DoXCollisionCheck
   5099  2756a				   -			;lda __boxx1 ; skipped. already in the accumulator
   5100  2756a				   -	       cmp	__boxx2	;3
   5101  2756a				   -	       bcs	X1isbiggerthanX2	;2/3
   5102  2756a				   -X2isbiggerthanX1
   5103  2756a				   -			; carry is clear
   5104  2756a				   -	       adc	__boxw1	;3
   5105  2756a				   -	       cmp	__boxx2	;3
   5106  2756a				   -	       bcs	DoYCollisionCheck	;3/2
   5107  2756a				   -	       rts		;6 - carry clear, no collision
   5108  2756a				   -X1isbiggerthanX2
   5109  2756a				   -	       clc		;2
   5110  2756a				   -	       sbc	__boxw2	;3
   5111  2756a				   -	       cmp	__boxx2	;3
   5112  2756a				   -	       bcs	noboxcollision	;3/2
   5113  2756a				   -DoYCollisionCheck
   5114  2756a				   -	       tya		; 2 ; use to be "lda __boxy1"
   5115  2756a				   -	       cmp	__boxy2	;3
   5116  2756a				   -	       bcs	Y1isbiggerthanY2	;3/2
   5117  2756a				   -Y2isbiggerthanY1
   5118  2756a				   -			; carry is clear
   5119  2756a				   -	       adc	__boxh1	;3
   5120  2756a				   -	       cmp	__boxy2	;3
   5121  2756a				   -	       rts		;6 
   5122  2756a				   -Y1isbiggerthanY2
   5123  2756a				   -	       clc		;2
   5124  2756a				   -	       sbc	__boxh2	;3
   5125  2756a				   -	       cmp	__boxy2	;3
   5126  2756a				   -	       bcs	noboxcollision	;3/2
   5127  2756a				   -yesboxcollision
   5128  2756a				   -	       sec		;2
   5129  2756a				   -	       rts		;6
   5130  2756a				   -noboxcollision
   5131  2756a				   -	       clc		;2
   5132  2756a				   -	       rts		;6
   5133  2756a					       endif		; BOXCOLLISION
   5134  2756a
   5135  2756a				    randomize
   5136  2756a			a5 40		       lda	rand
   5137  2756c			4a		       lsr
   5138  2756d			26 41		       rol	rand16
   5139  2756f			90 02		       bcc	noeor
   5140  27571			49 b4		       eor	#$B4
   5141  27573				    noeor
   5142  27573			85 40		       sta	rand
   5143  27575			45 41		       eor	rand16
   5144  27577			60		       rts
   5145  27578
   5146  27578							; *** bcd conversion routine courtesy Omegamatrix
   5147  27578							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   5148  27578				    converttobcd
   5149  27578							;value to convert is in the accumulator
   5150  27578			85 42		       sta	temp1
   5151  2757a			4a		       lsr
   5152  2757b			65 42		       adc	temp1
   5153  2757d			6a		       ror
   5154  2757e			4a		       lsr
   5155  2757f			4a		       lsr
   5156  27580			65 42		       adc	temp1
   5157  27582			6a		       ror
   5158  27583			65 42		       adc	temp1
   5159  27585			6a		       ror
   5160  27586			4a		       lsr
   5161  27587			29 3c		       and	#$3C
   5162  27589			85 43		       sta	temp2
   5163  2758b			4a		       lsr
   5164  2758c			65 43		       adc	temp2
   5165  2758e			65 42		       adc	temp1
   5166  27590			60		       rts		; return the result in the accumulator
   5167  27591
   5168  27591							; Y and A contain multiplicands, result in A
   5169  27591				    mul8
   5170  27591			84 42		       sty	temp1
   5171  27593			85 43		       sta	temp2
   5172  27595			a9 00		       lda	#0
   5173  27597				    reptmul8
   5174  27597			46 43		       lsr	temp2
   5175  27599			90 03		       bcc	skipmul8
   5176  2759b			18		       clc
   5177  2759c			65 42		       adc	temp1
   5178  2759e							;bcs donemul8 might save cycles?
   5179  2759e				    skipmul8
   5180  2759e							;beq donemul8 might save cycles?
   5181  2759e			06 42		       asl	temp1
   5182  275a0			d0 f5		       bne	reptmul8
   5183  275a2				    donemul8
   5184  275a2			60		       rts
   5185  275a3
   5186  275a3				    div8
   5187  275a3							; A=numerator Y=denominator, result in A
   5188  275a3			c0 02		       cpy	#2
   5189  275a5			90 0a		       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   5190  275a7			84 42		       sty	temp1
   5191  275a9			a0 ff		       ldy	#$ff
   5192  275ab				    div8loop
   5193  275ab			e5 42		       sbc	temp1
   5194  275ad			c8		       iny
   5195  275ae			b0 fb		       bcs	div8loop
   5196  275b0				    div8end
   5197  275b0			98		       tya
   5198  275b1							; result in A
   5199  275b1			60		       rts
   5200  275b2
   5201  275b2							; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   5202  275b2				    mul16
   5203  275b2			84 42		       sty	temp1
   5204  275b4			85 43		       sta	temp2
   5205  275b6
   5206  275b6			a9 00		       lda	#0
   5207  275b8			a2 08		       ldx	#8
   5208  275ba			46 42		       lsr	temp1
   5209  275bc				    mul16_1
   5210  275bc			90 03		       bcc	mul16_2
   5211  275be			18		       clc
   5212  275bf			65 43		       adc	temp2
   5213  275c1				    mul16_2
   5214  275c1			6a		       ror
   5215  275c2			66 42		       ror	temp1
   5216  275c4			ca		       dex
   5217  275c5			d0 f5		       bne	mul16_1
   5218  275c7			85 43		       sta	temp2
   5219  275c9			60		       rts
   5220  275ca
   5221  275ca							; div int/int
   5222  275ca							; numerator in A, denom in temp1
   5223  275ca							; returns with quotient in A, remainder in temp1
   5224  275ca				    div16
   5225  275ca			85 43		       sta	temp2
   5226  275cc			84 42		       sty	temp1
   5227  275ce			a9 00		       lda	#0
   5228  275d0			a2 08		       ldx	#8
   5229  275d2			06 43		       asl	temp2
   5230  275d4				    div16_1
   5231  275d4			2a		       rol
   5232  275d5			c5 42		       cmp	temp1
   5233  275d7			90 02		       bcc	div16_2
   5234  275d9			e5 42		       sbc	temp1
   5235  275db				    div16_2
   5236  275db			26 43		       rol	temp2
   5237  275dd			ca		       dex
   5238  275de			d0 f4		       bne	div16_1
   5239  275e0			85 42		       sta	temp1
   5240  275e2			a5 43		       lda	temp2
   5241  275e4			60		       rts
   5242  275e5
   5243  275e5					       ifconst	bankswitchmode
   5244  275e5				    BS_jsr
   5245  275e5				   -	       ifconst	dumpbankswitch
   5246  275e5				   -	       sta	dumpbankswitch
   5247  275e5					       endif
   5248  275e5				   -	       ifconst	MCPDEVCART
   5249  275e5				   -	       ora	#$18
   5250  275e5				   -	       sta	$3000
   5251  275e5					       else
   5252  275e5			8d 00 80	       sta	$8000
   5253  275e8					       endif
   5254  275e8			68		       pla
   5255  275e9			aa		       tax
   5256  275ea			68		       pla
   5257  275eb			60		       rts
   5258  275ec
   5259  275ec				    BS_return
   5260  275ec			68		       pla		; bankswitch bank
   5261  275ed				   -	       ifconst	dumpbankswitch
   5262  275ed				   -	       sta	dumpbankswitch
   5263  275ed					       endif
   5264  275ed				   -	       ifconst	BANKRAM
   5265  275ed				   -	       sta	currentbank
   5266  275ed				   -	       ora	currentrambank
   5267  275ed					       endif
   5268  275ed				   -	       ifconst	MCPDEVCART
   5269  275ed				   -	       ora	#$18
   5270  275ed				   -	       sta	$3000
   5271  275ed					       else
   5272  275ed			8d 00 80	       sta	$8000
   5273  275f0					       endif
   5274  275f0			68		       pla		; bankswitch $0 flag
   5275  275f1			60		       rts
   5276  275f2					       endif
   5277  275f2
   5278  275f2				    checkselectswitch
   5279  275f2			ad 82 02	       lda	SWCHB	; first check the real select switch...
   5280  275f5			29 02		       and	#%00000010
   5281  275f7					       ifnconst	MOUSESUPPORT
   5282  275f7					       ifnconst	TRAKBALLSUPPORT
   5283  275f7			f0 05		       beq	checkselectswitchreturn	; switch is pressed
   5284  275f9			ad 80 02	       lda	SWCHA	; then check the soft "select" joysick code...
   5285  275fc			29 b0		       and	#%10110000	; R_DU
   5286  275fe					       endif		; TRAKBALLSUPPORT
   5287  275fe					       endif		; MOUSESUPPORT
   5288  275fe				    checkselectswitchreturn
   5289  275fe			60		       rts
   5290  275ff
   5291  275ff				    checkresetswitch
   5292  275ff			ad 82 02	       lda	SWCHB	; first check the real reset switch...
   5293  27602			29 01		       and	#%00000001
   5294  27604					       ifnconst	MOUSESUPPORT
   5295  27604					       ifnconst	TRAKBALLSUPPORT
   5296  27604			f0 05		       beq	checkresetswitchreturn	; switch is pressed
   5297  27606			ad 80 02	       lda	SWCHA	; then check the soft "reset" joysick code...
   5298  27609			29 70		       and	#%01110000	; _LDU
   5299  2760b					       endif		; TRAKBALLSUPPORT
   5300  2760b					       endif		; MOUSESUPPORT
   5301  2760b				    checkresetswitchreturn
   5302  2760b			60		       rts
   5303  2760c
   5304  2760c				   -	       ifconst	FINESCROLLENABLED
   5305  2760c				   -finescrolldlls
   5306  2760c				   -	       ldx	temp1	; first DLL index x3
   5307  2760c				   -	       lda	DLLMEM,x
   5308  2760c				   -	       and	#%11110000
   5309  2760c				   -	       ora	finescrolly
   5310  2760c				   -	       sta	DLLMEM,x
   5311  2760c				   -
   5312  2760c				   -	       ldx	temp2	; last DLL index x3
   5313  2760c				   -	       lda	DLLMEM,x
   5314  2760c				   -	       and	#%11110000
   5315  2760c				   -	       ora	finescrolly
   5316  2760c				   -	       eor	#(WZONEHEIGHT-1)
   5317  2760c				   -	       sta	DLLMEM,x
   5318  2760c				   -	       rts
   5319  2760c					       endif		; FINESCROLLENABLED
   5320  2760c
   5321  2760c				   -	       ifconst	USED_ADJUSTVISIBLE
   5322  2760c				   -adjustvisible
   5323  2760c				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   5324  2760c				   -	       jsr	waitforvblankstart	; ensure vblank just started
   5325  2760c				   -	       ldx	visibleDLLstart
   5326  2760c				   -findfirstinterrupt
   5327  2760c				   -	       lda	DLLMEM,x
   5328  2760c				   -	       bmi	foundfirstinterrupt
   5329  2760c				   -	       inx
   5330  2760c				   -	       inx
   5331  2760c				   -	       inx
   5332  2760c				   -	       bne	findfirstinterrupt
   5333  2760c				   -foundfirstinterrupt
   5334  2760c				   -	       and	#%01111111	; clear the interrupt bit
   5335  2760c				   -	       sta	DLLMEM,x
   5336  2760c				   -	       ifconst	DOUBLEBUFFER
   5337  2760c				   -	       sta	DLLMEM+DBOFFSET,x
   5338  2760c				   -	       endif		; DOUBLEBUFFER
   5339  2760c				   -	       ldx	overscanDLLstart
   5340  2760c				   -findlastinterrupt
   5341  2760c				   -	       lda	DLLMEM,x
   5342  2760c				   -	       bmi	foundlastinterrupt
   5343  2760c				   -	       dex
   5344  2760c				   -	       dex
   5345  2760c				   -	       dex
   5346  2760c				   -	       bne	findlastinterrupt
   5347  2760c				   -foundlastinterrupt
   5348  2760c				   -	       and	#%01111111	; clear the interrupt bit
   5349  2760c				   -	       sta	DLLMEM,x
   5350  2760c				   -	       ifconst	DOUBLEBUFFER
   5351  2760c				   -	       sta	DLLMEM+DBOFFSET,x
   5352  2760c				   -	       endif		; DOUBLEBUFFER
   5353  2760c				   -			;now we need to set the new interrupts
   5354  2760c				   -	       clc
   5355  2760c				   -	       lda	temp1
   5356  2760c				   -	       adc	visibleDLLstart
   5357  2760c				   -	       tax
   5358  2760c				   -	       lda	DLLMEM,x
   5359  2760c				   -	       ora	#%10000000
   5360  2760c				   -	       sta	DLLMEM,x
   5361  2760c				   -	       ifconst	DOUBLEBUFFER
   5362  2760c				   -	       sta	DLLMEM+DBOFFSET,x
   5363  2760c				   -	       endif		; DOUBLEBUFFER
   5364  2760c				   -	       clc
   5365  2760c				   -	       lda	temp2
   5366  2760c				   -	       adc	visibleDLLstart
   5367  2760c				   -	       tax
   5368  2760c				   -	       lda	DLLMEM,x
   5369  2760c				   -	       ora	#%10000000
   5370  2760c				   -	       sta	DLLMEM,x
   5371  2760c				   -	       ifconst	DOUBLEBUFFER
   5372  2760c				   -	       sta	DLLMEM+DBOFFSET,x
   5373  2760c				   -	       endif		; DOUBLEBUFFER
   5374  2760c				   -	       jsr	vblankresync
   5375  2760c				   -	       rts
   5376  2760c					       endif		; USED_ADJUSTVISIBLE
   5377  2760c
   5378  2760c				    vblankresync
   5379  2760c			20 aa f6	       jsr	waitforvblankstart	; ensure vblank just started
   5380  2760f			a9 00		       lda	#0
   5381  27611			85 4d		       sta	visibleover
   5382  27613			a9 03		       lda	#3
   5383  27615			8d b2 01	       sta	interruptindex
   5384  27618			60		       rts
   5385  27619
   5386  27619				    createallgamedlls
   5387  27619			a2 00		       ldx	#0
   5388  2761b			a9 19		       lda	#NVLINES
   5389  2761d			ac 09 21	       ldy	paldetected
   5390  27620			f0 03		       beq	skipcreatePALpadding
   5391  27622			18		       clc
   5392  27623			69 15		       adc	#21
   5393  27625				    skipcreatePALpadding
   5394  27625			20 5a f6	       jsr	createnonvisibledlls
   5395  27628			8e 3c 21	       stx	visibleDLLstart
   5396  2762b			20 8b f6	       jsr	createvisiblezones
   5397  2762e			8e 3d 21	       stx	overscanDLLstart
   5398  27631				    createallgamedllscontinue
   5399  27631			a9 50		       lda	#(NVLINES+55)	; extras for PAL
   5400  27633			20 5a f6	       jsr	createnonvisibledlls
   5401  27636
   5402  27636			ae 3c 21	       ldx	visibleDLLstart
   5403  27639			bd 00 18	       lda	DLLMEM,x
   5404  2763c			09 80		       ora	#%10000000	; NMI 1 - start of visible screen
   5405  2763e			9d 00 18	       sta	DLLMEM,x
   5406  27641				   -	       ifconst	DOUBLEBUFFER
   5407  27641				   -	       sta	DLLMEM+DBOFFSET,x
   5408  27641					       endif		; DOUBLEBUFFER
   5409  27641
   5410  27641			ae 3d 21	       ldx	overscanDLLstart
   5411  27644			bd 00 18	       lda	DLLMEM,x
   5412  27647			09 83		       ora	#%10000011	; NMI 2 - end of visible screen
   5413  27649			29 f3		       and	#%11110011	; change this to a 1-line DLL, so there's time enough for the "deeper overscan" DLL
   5414  2764b			9d 00 18	       sta	DLLMEM,x
   5415  2764e				   -	       ifconst	DOUBLEBUFFER
   5416  2764e				   -	       sta	DLLMEM+DBOFFSET,x
   5417  2764e					       endif		; DOUBLEBUFFER
   5418  2764e
   5419  2764e			e8		       inx
   5420  2764f			e8		       inx
   5421  27650			e8		       inx
   5422  27651
   5423  27651			bd 00 18	       lda	DLLMEM,x
   5424  27654			09 80		       ora	#%10000000	; NMI 3 - deeper overscan
   5425  27656			9d 00 18	       sta	DLLMEM,x
   5426  27659				   -	       ifconst	DOUBLEBUFFER
   5427  27659				   -	       sta	DLLMEM+DBOFFSET,x
   5428  27659					       endif		; DOUBLEBUFFER
   5429  27659
   5430  27659			60		       rts
   5431  2765a
   5432  2765a				    createnonvisibledlls
   5433  2765a			85 42		       sta	temp1
   5434  2765c			4a		       lsr
   5435  2765d			4a		       lsr
   5436  2765e			4a		       lsr
   5437  2765f			4a		       lsr		; /16
   5438  27660			f0 09		       beq	skipcreatenonvisibledlls1loop
   5439  27662			a8		       tay
   5440  27663				    createnonvisibledlls1loop
   5441  27663			a9 4f		       lda	#%01001111	;low nibble=16 lines, high nibble=Holey DMA
   5442  27665			20 7a f6	       jsr	createblankdllentry
   5443  27668			88		       dey
   5444  27669			d0 f8		       bne	createnonvisibledlls1loop
   5445  2766b				    skipcreatenonvisibledlls1loop
   5446  2766b			a5 42		       lda	temp1
   5447  2766d			29 0f		       and	#%00001111
   5448  2766f			f0 08		       beq	createnonvisibledllsreturn
   5449  27671			38		       sec
   5450  27672			e9 01		       sbc	#1
   5451  27674			09 40		       ora	#%01000000
   5452  27676			20 7a f6	       jsr	createblankdllentry
   5453  27679				    createnonvisibledllsreturn
   5454  27679			60		       rts
   5455  2767a
   5456  2767a				    createblankdllentry
   5457  2767a			9d 00 18	       sta	DLLMEM,x
   5458  2767d				   -	       ifconst	DOUBLEBUFFER
   5459  2767d				   -	       sta	DLLMEM+DBOFFSET,x
   5460  2767d					       endif		; DOUBLEBUFFER
   5461  2767d			e8		       inx
   5462  2767e			a9 21		       lda	#$21	; blank
   5463  27680			9d 00 18	       sta	DLLMEM,x
   5464  27683				   -	       ifconst	DOUBLEBUFFER
   5465  27683				   -	       sta	DLLMEM+DBOFFSET,x
   5466  27683					       endif		; DOUBLEBUFFER
   5467  27683			e8		       inx
   5468  27684			a9 00		       lda	#$00
   5469  27686			9d 00 18	       sta	DLLMEM,x
   5470  27689				   -	       ifconst	DOUBLEBUFFER
   5471  27689				   -	       sta	DLLMEM+DBOFFSET,x
   5472  27689					       endif		; DOUBLEBUFFER
   5473  27689			e8		       inx
   5474  2768a			60		       rts
   5475  2768b
   5476  2768b				    createvisiblezones
   5477  2768b			a0 00		       ldy	#0
   5478  2768d				    createvisiblezonesloop
   5479  2768d			b9 b8 f7	       lda.w	DLHEIGHT,y
   5480  27690			09 40		       ora	#(WZONEHEIGHT * 4)	; set Holey DMA for 8 or 16 tall zones
   5481  27692			9d 00 18	       sta	DLLMEM,x
   5482  27695				   -	       ifconst	DOUBLEBUFFER
   5483  27695				   -	       sta	DLLMEM+DBOFFSET,x
   5484  27695					       endif		; DOUBLEBUFFER
   5485  27695			e8		       inx
   5486  27696			b9 a0 f7	       lda	DLPOINTH,y
   5487  27699			9d 00 18	       sta	DLLMEM,x
   5488  2769c				   -	       ifconst	DOUBLEBUFFER
   5489  2769c				   -	       sta	DLLMEM+DBOFFSET,x
   5490  2769c					       endif		; DOUBLEBUFFER
   5491  2769c			e8		       inx
   5492  2769d			b9 ac f7	       lda	DLPOINTL,y
   5493  276a0			9d 00 18	       sta	DLLMEM,x
   5494  276a3				   -	       ifconst	DOUBLEBUFFER
   5495  276a3				   -	       clc
   5496  276a3				   -	       adc	#DOUBLEBUFFEROFFSET
   5497  276a3				   -	       sta	DLLMEM+DBOFFSET,x
   5498  276a3				   -	       bcc	skiphidoublebufferadjust	; dlls are big endian, so we need to fix the hi byte after-the-fact...
   5499  276a3				   -	       inc	DLLMEM+DBOFFSET-1,x
   5500  276a3				   -skiphidoublebufferadjust
   5501  276a3					       endif		; DOUBLEBUFFER
   5502  276a3			e8		       inx
   5503  276a4			c8		       iny
   5504  276a5			c0 0c		       cpy	#WZONECOUNT
   5505  276a7			d0 e4		       bne	createvisiblezonesloop
   5506  276a9			60		       rts
   5507  276aa
   5508  276aa				    waitforvblankstart
   5509  276aa				    vblankendwait
   5510  276aa			24 28		       BIT	MSTAT
   5511  276ac			30 fc		       bmi	vblankendwait
   5512  276ae				    vblankstartwait
   5513  276ae			24 28		       BIT	MSTAT
   5514  276b0			10 fc		       bpl	vblankstartwait
   5515  276b2			60		       rts
   5516  276b3
   5517  276b3				   -	       ifconst	DOUBLEBUFFER
   5518  276b3				   -flipdisplaybufferreturn
   5519  276b3				   -	       rts
   5520  276b3				   -flipdisplaybuffer
   5521  276b3				   -	       ifconst	interrupthold
   5522  276b3				   -	       lda	#$FF
   5523  276b3				   -	       sta	interrupthold
   5524  276b3				   -	       endif
   5525  276b3				   -	       lda	doublebufferstate
   5526  276b3				   -	       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   5527  276b3				   -
   5528  276b3				   -	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   5529  276b3				   -
   5530  276b3				   -	       lda	doublebufferstate
   5531  276b3				   -	       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   5532  276b3				   -	       tax
   5533  276b3				   -
   5534  276b3				   -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   5535  276b3				   -
   5536  276b3				   -flipdisplaybufferwait1
   5537  276b3				   -	       lda	visibleover
   5538  276b3				   -	       beq	flipdisplaybufferwait1
   5539  276b3				   -
   5540  276b3				   -flipdisplaybufferwait
   5541  276b3				   -	       lda	visibleover
   5542  276b3				   -	       bne	flipdisplaybufferwait
   5543  276b3				   -
   5544  276b3				   -	       lda	doublebufferminimumframetarget
   5545  276b3				   -	       beq	skipminimumframecode
   5546  276b3				   -	       lda	doublebufferminimumframeindex
   5547  276b3				   -	       bne	flipdisplaybufferwait1
   5548  276b3				   -	       lda	doublebufferminimumframetarget
   5549  276b3				   -	       sta	doublebufferminimumframeindex
   5550  276b3				   -skipminimumframecode
   5551  276b3				   -
   5552  276b3				   -	       lda	DLLMEMLutHi,x
   5553  276b3				   -	       sta	DPPH
   5554  276b3				   -	       lda	DLLMEMLutLo,x
   5555  276b3				   -	       sta	DPPL
   5556  276b3				   -
   5557  276b3				   -	       lda	NewPageflipstate,x
   5558  276b3				   -	       sta	doublebufferstate
   5559  276b3				   -	       lda	NewPageflipoffset,x
   5560  276b3				   -	       sta	doublebufferdloffset
   5561  276b3				   -
   5562  276b3				   -	       lda	doublebufferbufferdirty
   5563  276b3				   -	       beq	flipdisplaybufferreturn
   5564  276b3				   -
   5565  276b3				   -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   5566  276b3				   -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   5567  276b3				   -			; from the displayed buffer to the working buffer...
   5568  276b3				   -
   5569  276b3				   -	       lda	doublebufferdloffset
   5570  276b3				   -	       eor	#DOUBLEBUFFEROFFSET
   5571  276b3				   -	       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   5572  276b3				   -
   5573  276b3				   -	       ldx	#(WZONECOUNT-1)
   5574  276b3				   -copybufferzoneloop
   5575  276b3				   -
   5576  276b3				   -	       lda	DLPOINTL,x
   5577  276b3				   -	       clc
   5578  276b3				   -	       adc	doublebufferdloffset
   5579  276b3				   -	       sta	temp1
   5580  276b3				   -	       lda	DLPOINTH,x
   5581  276b3				   -	       adc	#0
   5582  276b3				   -	       sta	temp2
   5583  276b3				   -
   5584  276b3				   -	       lda	DLPOINTL,x
   5585  276b3				   -	       clc
   5586  276b3				   -	       adc	temp6
   5587  276b3				   -	       sta	temp3
   5588  276b3				   -	       lda	DLPOINTH,x
   5589  276b3				   -	       adc	#0
   5590  276b3				   -	       sta	temp4
   5591  276b3				   -
   5592  276b3				   -	       lda	dlendsave,x
   5593  276b3				   -	       tay
   5594  276b3				   -copybuffercharsloop
   5595  276b3				   -	       lda	(temp3),y
   5596  276b3				   -	       sta	(temp1),y
   5597  276b3				   -	       dey
   5598  276b3				   -	       bpl	copybuffercharsloop
   5599  276b3				   -	       dex
   5600  276b3				   -	       bpl	copybufferzoneloop
   5601  276b3				   -	       lda	#0
   5602  276b3				   -	       sta	doublebufferbufferdirty
   5603  276b3				   -	       rts
   5604  276b3				   -
   5605  276b3				   -doublebufferoff
   5606  276b3				   -	       lda	#1
   5607  276b3				   -	       sta	doublebufferstate
   5608  276b3				   -	       jsr	flipdisplaybuffer
   5609  276b3				   -	       lda	#0
   5610  276b3				   -	       sta	doublebufferstate
   5611  276b3				   -	       sta	doublebufferdloffset
   5612  276b3				   -	       rts
   5613  276b3				   -
   5614  276b3				   -DLLMEMLutLo
   5615  276b3				   -	       .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   5616  276b3				   -DLLMEMLutHi
   5617  276b3				   -	       .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   5618  276b3				   -NewPageflipstate
   5619  276b3				   -	       .byte	3,1
   5620  276b3				   -NewPageflipoffset
   5621  276b3				   -	       .byte	DOUBLEBUFFEROFFSET,0
   5622  276b3				   -
   5623  276b3					       endif		; DOUBLEBUFFER
   5624  276b3
   5625  276b3				   -	       ifconst	MOUSESUPPORT
   5626  276b3				   -
   5627  276b3				   -rotationalcompare
   5628  276b3				   -			; old =   00	  01	  10	 11
   5629  276b3				   -	       .byte	$00, $01, $ff, $00	; new=00
   5630  276b3				   -	       .byte	$ff, $00, $00, $01	; new=01
   5631  276b3				   -	       .byte	$01, $00, $00, $ff	; new=10
   5632  276b3				   -	       .byte	$00, $ff, $01, $00	; new=11
   5633  276b3				   -
   5634  276b3				   -			;  0000YyXx st mouse
   5635  276b3				   -
   5636  276b3				   -			;  0000xyXY amiga mouse
   5637  276b3				   -
   5638  276b3				   -	       ifconst	MOUSEXONLY
   5639  276b3				   -amigatoataribits		; swap bits 1 and 4...
   5640  276b3				   -	       .byte	%0000, %0000, %0010, %0010
   5641  276b3				   -	       .byte	%0000, %0000, %0010, %0010
   5642  276b3				   -	       .byte	%0001, %0001, %0011, %0011
   5643  276b3				   -	       .byte	%0001, %0001, %0011, %0011
   5644  276b3				   -
   5645  276b3				   -			; null change bits
   5646  276b3				   -	       .byte	%0000, %0001, %0010, %0011
   5647  276b3				   -	       .byte	%0000, %0001, %0010, %0011
   5648  276b3				   -	       .byte	%0000, %0001, %0010, %0011
   5649  276b3				   -	       .byte	%0000, %0001, %0010, %0011
   5650  276b3				   -
   5651  276b3				   -	       else		; !MOUSEXONLY
   5652  276b3				   -
   5653  276b3				   -amigatoataribits		; swap bits 1 and 4...
   5654  276b3				   -	       .byte	%0000, %1000, %0010, %1010
   5655  276b3				   -	       .byte	%0100, %1100, %0110, %1110
   5656  276b3				   -	       .byte	%0001, %1001, %0011, %1011
   5657  276b3				   -	       .byte	%0101, %1101, %0111, %1111
   5658  276b3				   -			; null change bits
   5659  276b3				   -	       .byte	%0000, %0001, %0010, %0011
   5660  276b3				   -	       .byte	%0100, %0101, %0110, %0111
   5661  276b3				   -	       .byte	%1000, %1001, %1010, %1011
   5662  276b3				   -	       .byte	%1100, %1101, %1110, %1111
   5663  276b3				   -	       endif		; !MOUSEXONLY
   5664  276b3				   -
   5665  276b3					       endif		; MOUSESUPPORT
   5666  276b3
   5667  276b3				    mouse0update
   5668  276b3				   -	       ifconst	MOUSE0SUPPORT
   5669  276b3				   -
   5670  276b3				   -mousetableselect =	inttemp2
   5671  276b3				   -mousexdelta =	inttemp3
   5672  276b3				   -mouseydelta =	inttemp4
   5673  276b3				   -lastSWCHA  =	inttemp6
   5674  276b3				   -
   5675  276b3				   -			;  0000YyXx st mouse
   5676  276b3				   -			;  0000xyXY amiga mouse
   5677  276b3				   -
   5678  276b3				   -	       lda	#$ff
   5679  276b3				   -	       sta	lastSWCHA
   5680  276b3				   -
   5681  276b3				   -	       ldy	port0control
   5682  276b3				   -
   5683  276b3				   -	       lda	#%00010000
   5684  276b3				   -	       cpy	#9	; AMIGA?
   5685  276b3				   -	       bne	skipamigabitsfix0
   5686  276b3				   -	       lda	#0
   5687  276b3				   -skipamigabitsfix0
   5688  276b3				   -	       sta	mousetableselect
   5689  276b3				   -	       ifconst	DRIVINGBOOST
   5690  276b3				   -	       cpy	#6	; DRIVING?
   5691  276b3				   -	       bne	skipdriving0setup
   5692  276b3				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   5693  276b3				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   5694  276b3				   -			; the actual position. This actual position is stored in mousey0 
   5695  276b3				   -			; after the driver has run.
   5696  276b3				   -	       ldx	mousex0
   5697  276b3				   -	       lda	mousey0
   5698  276b3				   -	       stx	mousey0
   5699  276b3				   -	       sta	mousex0
   5700  276b3				   -skipdriving0setup
   5701  276b3				   -	       endif		; DRIVINGBOOST
   5702  276b3				   -
   5703  276b3				   -	       lda	#0
   5704  276b3				   -	       sta	mousexdelta
   5705  276b3				   -	       sta	mouseydelta
   5706  276b3				   -
   5707  276b3				   -	       ifnconst	MOUSETIME
   5708  276b3				   -	       ifnconst	MOUSEXONLY
   5709  276b3				   -	       lda	#180	; minimum for x+y
   5710  276b3				   -	       else
   5711  276b3				   -	       lda	#100	; minimum for just x
   5712  276b3				   -	       endif
   5713  276b3				   -	       else
   5714  276b3				   -	       lda	#MOUSETIME
   5715  276b3				   -	       endif
   5716  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   5717  276b3				   -
   5718  276b3				   -mouse0updateloop
   5719  276b3				   -	       lda	SWCHA
   5720  276b3				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   5721  276b3				   -	       cmp	lastSWCHA
   5722  276b3				   -	       beq	mouse0loopcondition
   5723  276b3				   -	       sta	lastSWCHA
   5724  276b3				   -	       lsr
   5725  276b3				   -	       lsr
   5726  276b3				   -	       lsr
   5727  276b3				   -
   5728  276b3				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   5729  276b3				   -
   5730  276b3				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   5731  276b3				   -			;  0000YyXx st mouse
   5732  276b3				   -			;  0000xyXY amiga mouse
   5733  276b3				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   5734  276b3				   -	       tay
   5735  276b3				   -	       lax	amigatoataribits,y
   5736  276b3				   -
   5737  276b3				   -	       ifnconst	MOUSEXONLY
   5738  276b3				   -			; first the Y...
   5739  276b3				   -	       and	#%00001100
   5740  276b3				   -	       ora	mousecodey0
   5741  276b3				   -	       tay
   5742  276b3				   -	       lda	rotationalcompare,y
   5743  276b3				   -	       clc
   5744  276b3				   -	       adc	mouseydelta
   5745  276b3				   -	       sta	mouseydelta
   5746  276b3				   -	       tya
   5747  276b3				   -	       lsr
   5748  276b3				   -	       lsr
   5749  276b3				   -	       sta	mousecodey0
   5750  276b3				   -	       txa
   5751  276b3				   -			; ...then the X...
   5752  276b3				   -	       and	#%00000011
   5753  276b3				   -	       tax
   5754  276b3				   -	       endif		; !MOUSEXONLY
   5755  276b3				   -
   5756  276b3				   -	       asl
   5757  276b3				   -	       asl
   5758  276b3				   -	       ora	mousecodex0
   5759  276b3				   -	       tay
   5760  276b3				   -	       lda	rotationalcompare,y
   5761  276b3				   -	       adc	mousexdelta	; carry was clear by previous ASL
   5762  276b3				   -	       sta	mousexdelta
   5763  276b3				   -	       stx	mousecodex0
   5764  276b3				   -mouse0loopcondition
   5765  276b3				   -	       lda	TIMINT
   5766  276b3				   -	       bpl	mouse0updateloop
   5767  276b3				   -
   5768  276b3				   -			; *** adapt to selected device resolution. 
   5769  276b3				   -	       ldx	port0control
   5770  276b3				   -
   5771  276b3				   -	       ifconst	PRECISIONMOUSING
   5772  276b3				   -	       ldy	port0resolution
   5773  276b3				   -	       bne	mouse0halveddone
   5774  276b3				   -	       cpx	#6	; half-resolution is no good for driving wheels
   5775  276b3				   -	       beq	mouse0halveddone
   5776  276b3				   -			; resolution=0 is half mouse resolution, necessary for precision 
   5777  276b3				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   5778  276b3				   -
   5779  276b3				   -	       lda	mousexdelta
   5780  276b3				   -	       cmp	#$80
   5781  276b3				   -	       ror		; do a signed divide by 2.
   5782  276b3				   -	       clc
   5783  276b3				   -	       adc	mousex0
   5784  276b3				   -	       sta	mousex0
   5785  276b3				   -	       ifnconst	MOUSEXONLY
   5786  276b3				   -	       lda	mouseydelta
   5787  276b3				   -	       clc
   5788  276b3				   -	       adc	mousey0
   5789  276b3				   -	       sta	mousey0
   5790  276b3				   -	       endif
   5791  276b3				   -			; at half resolution we just exit after updating x and y
   5792  276b3				   -	       jmp	LLRET0
   5793  276b3				   -mouse0halveddone
   5794  276b3				   -	       endif		; PRECISIONMOUSING
   5795  276b3				   -
   5796  276b3				   -	       ifnconst	MOUSEXONLY
   5797  276b3				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   5798  276b3				   -	       ldy	port0resolution
   5799  276b3				   -	       dey
   5800  276b3				   -	       lda	#0
   5801  276b3				   -mousey0resolutionfix
   5802  276b3				   -	       clc
   5803  276b3				   -	       adc	mouseydelta
   5804  276b3				   -	       dey
   5805  276b3				   -	       bpl	mousey0resolutionfix
   5806  276b3				   -	       clc
   5807  276b3				   -	       adc	mousey0
   5808  276b3				   -	       sta	mousey0
   5809  276b3				   -	       endif		; MOUSEXONLY
   5810  276b3				   -
   5811  276b3				   -	       ldy	port0resolution
   5812  276b3				   -	       dey
   5813  276b3				   -	       lda	#0
   5814  276b3				   -mousex0resolutionfix
   5815  276b3				   -	       clc
   5816  276b3				   -	       adc	mousexdelta
   5817  276b3				   -	       dey
   5818  276b3				   -	       bpl	mousex0resolutionfix
   5819  276b3				   -	       ifnconst	DRIVINGBOOST
   5820  276b3				   -	       clc
   5821  276b3				   -	       adc	mousex0
   5822  276b3				   -	       sta	mousex0
   5823  276b3				   -	       else
   5824  276b3				   -	       cpx	#6
   5825  276b3				   -	       beq	carryonmouse0boost
   5826  276b3				   -	       clc
   5827  276b3				   -	       adc	mousex0
   5828  276b3				   -	       sta	mousex0
   5829  276b3				   -	       jmp	LLRET0
   5830  276b3				   -carryonmouse0boost
   5831  276b3				   -	       sta	mousexdelta
   5832  276b3				   -	       clc
   5833  276b3				   -	       adc	mousecodey0
   5834  276b3				   -	       sta	mousecodey0
   5835  276b3				   -	       clc
   5836  276b3				   -	       adc	mousex0
   5837  276b3				   -	       tay		; save the target X
   5838  276b3				   -	       adc	mousey0	; average in the smoothly-trailing X
   5839  276b3				   -	       ror
   5840  276b3				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   5841  276b3				   -	       sty	mousey0	; and mousey0 has the the target X
   5842  276b3				   -
   5843  276b3				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   5844  276b3				   -			; A has mousex0, the smoothly trailing X
   5845  276b3				   -	       sbc	mousey0	; less the target X
   5846  276b3				   -	       bpl	skipabsolutedrive0
   5847  276b3				   -	       eor	#$ff
   5848  276b3				   -skipabsolutedrive0
   5849  276b3				   -	       cmp	#64	; just an unreasonably large change
   5850  276b3				   -	       bcc	skipdrivewrapfix0
   5851  276b3				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   5852  276b3				   -skipdrivewrapfix0
   5853  276b3				   -
   5854  276b3				   -			; get rid of the tweening if the distance travelled was very small
   5855  276b3				   -	       lda	mousexdelta
   5856  276b3				   -	       cmp	port0resolution
   5857  276b3				   -	       bcs	skipbetweenfix0
   5858  276b3				   -	       lda	mousex0
   5859  276b3				   -	       sta	mousey0
   5860  276b3				   -skipbetweenfix0
   5861  276b3				   -
   5862  276b3				   -drivingboostreductioncheck0
   5863  276b3				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   5864  276b3				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   5865  276b3				   -			; negated again because truncation during BCD math results in 
   5866  276b3				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   5867  276b3				   -driving0fix
   5868  276b3				   -	       lax	mousecodey0
   5869  276b3				   -	       cmp	#$80
   5870  276b3				   -	       bcs	driving0skipnegate1
   5871  276b3				   -	       eor	#$FF
   5872  276b3				   -	       adc	#1
   5873  276b3				   -	       sta	mousecodey0
   5874  276b3				   -driving0skipnegate1
   5875  276b3				   -	       cmp	#$80
   5876  276b3				   -	       ror
   5877  276b3				   -	       cmp	#$80
   5878  276b3				   -	       ror
   5879  276b3				   -	       cmp	#$80
   5880  276b3				   -	       ror
   5881  276b3				   -	       sta	inttemp1
   5882  276b3				   -	       lda	mousecodey0
   5883  276b3				   -	       sec
   5884  276b3				   -	       sbc	inttemp1
   5885  276b3				   -	       cpx	#$80
   5886  276b3				   -	       bcs	driving0skipnegate2
   5887  276b3				   -	       eor	#$FF
   5888  276b3				   -	       adc	#1
   5889  276b3				   -driving0skipnegate2
   5890  276b3				   -	       sta	mousecodey0
   5891  276b3				   -drivingboostdone0
   5892  276b3				   -	       endif		; DRIVINGBOOST
   5893  276b3				   -
   5894  276b3				   -	       jmp	LLRET0
   5895  276b3				   -
   5896  276b3					       endif		; MOUSE0SUPPORT
   5897  276b3
   5898  276b3				    mouse1update
   5899  276b3				   -	       ifconst	MOUSE1SUPPORT
   5900  276b3				   -
   5901  276b3				   -mousetableselect =	inttemp2
   5902  276b3				   -mousexdelta =	inttemp3
   5903  276b3				   -mouseydelta =	inttemp4
   5904  276b3				   -lastSWCHA  =	inttemp6
   5905  276b3				   -
   5906  276b3				   -			;  0000YyXx st mouse
   5907  276b3				   -			;  0000xyXY amiga mouse
   5908  276b3				   -
   5909  276b3				   -	       lda	#$ff
   5910  276b3				   -	       sta	lastSWCHA
   5911  276b3				   -
   5912  276b3				   -	       ldy	port1control
   5913  276b3				   -
   5914  276b3				   -	       lda	#%00010000
   5915  276b3				   -	       cpy	#9	; AMIGA?
   5916  276b3				   -	       bne	skipamigabitsfix1
   5917  276b3				   -	       lda	#0
   5918  276b3				   -skipamigabitsfix1
   5919  276b3				   -	       sta	mousetableselect
   5920  276b3				   -	       ifconst	DRIVINGBOOST
   5921  276b3				   -	       cpy	#6	; DRIVING?
   5922  276b3				   -	       bne	skipdriving1setup
   5923  276b3				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   5924  276b3				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   5925  276b3				   -			; the actual position. This actual position is stored in mousey1 
   5926  276b3				   -			; after the driver has run.
   5927  276b3				   -	       ldx	mousex1
   5928  276b3				   -	       lda	mousey1
   5929  276b3				   -	       stx	mousey1
   5930  276b3				   -	       sta	mousex1
   5931  276b3				   -skipdriving1setup
   5932  276b3				   -	       endif		; DRIVINGBOOST
   5933  276b3				   -
   5934  276b3				   -	       lda	#0
   5935  276b3				   -	       sta	mousexdelta
   5936  276b3				   -	       sta	mouseydelta
   5937  276b3				   -
   5938  276b3				   -	       ifnconst	MOUSETIME
   5939  276b3				   -	       ifnconst	MOUSEXONLY
   5940  276b3				   -	       lda	#180	; minimum for x+y
   5941  276b3				   -	       else
   5942  276b3				   -	       lda	#100	; minimum for just x
   5943  276b3				   -	       endif
   5944  276b3				   -	       else
   5945  276b3				   -	       lda	#MOUSETIME
   5946  276b3				   -	       endif
   5947  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   5948  276b3				   -
   5949  276b3				   -mouse1updateloop
   5950  276b3				   -	       lda	SWCHA
   5951  276b3				   -	       and	#%00001111
   5952  276b3				   -	       cmp	lastSWCHA
   5953  276b3				   -	       beq	mouse1loopcondition
   5954  276b3				   -	       sta	lastSWCHA
   5955  276b3				   -
   5956  276b3				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   5957  276b3				   -
   5958  276b3				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   5959  276b3				   -			;  0000YyXx st mouse
   5960  276b3				   -			;  0000xyXY amiga mouse
   5961  276b3				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   5962  276b3				   -	       tay
   5963  276b3				   -	       lax	amigatoataribits,y
   5964  276b3				   -
   5965  276b3				   -	       ifnconst	MOUSEXONLY
   5966  276b3				   -			; first the Y...
   5967  276b3				   -	       and	#%00001100
   5968  276b3				   -	       ora	mousecodey1
   5969  276b3				   -	       tay
   5970  276b3				   -	       lda	rotationalcompare,y
   5971  276b3				   -	       clc
   5972  276b3				   -	       adc	mouseydelta
   5973  276b3				   -	       sta	mouseydelta
   5974  276b3				   -	       tya
   5975  276b3				   -	       lsr
   5976  276b3				   -	       lsr
   5977  276b3				   -	       sta	mousecodey1
   5978  276b3				   -	       txa
   5979  276b3				   -			; ...then the X...
   5980  276b3				   -	       and	#%00000011
   5981  276b3				   -	       tax
   5982  276b3				   -	       endif		; !MOUSEXONLY
   5983  276b3				   -
   5984  276b3				   -	       asl
   5985  276b3				   -	       asl
   5986  276b3				   -	       ora	mousecodex1
   5987  276b3				   -	       tay
   5988  276b3				   -	       lda	rotationalcompare,y
   5989  276b3				   -	       adc	mousexdelta	; carry was clear by previous ASL
   5990  276b3				   -	       sta	mousexdelta
   5991  276b3				   -	       stx	mousecodex1
   5992  276b3				   -mouse1loopcondition
   5993  276b3				   -	       lda	TIMINT
   5994  276b3				   -	       bpl	mouse1updateloop
   5995  276b3				   -
   5996  276b3				   -			; *** adapt to selected device resolution. 
   5997  276b3				   -	       ldx	port1control
   5998  276b3				   -
   5999  276b3				   -	       ifconst	PRECISIONMOUSING
   6000  276b3				   -	       ldy	port1resolution
   6001  276b3				   -	       bne	mouse1halveddone
   6002  276b3				   -	       cpx	#6	; half-resolution is no good for driving wheels
   6003  276b3				   -	       beq	mouse1halveddone
   6004  276b3				   -			; resolution=0 is half mouse resolution, necessary for precision 
   6005  276b3				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   6006  276b3				   -
   6007  276b3				   -	       lda	mousexdelta
   6008  276b3				   -	       cmp	#$80
   6009  276b3				   -	       ror		; do a signed divide by 2.
   6010  276b3				   -	       clc
   6011  276b3				   -	       adc	mousex1
   6012  276b3				   -	       sta	mousex1
   6013  276b3				   -	       ifnconst	MOUSEXONLY
   6014  276b3				   -	       lda	mouseydelta
   6015  276b3				   -	       clc
   6016  276b3				   -	       adc	mousey1
   6017  276b3				   -	       sta	mousey1
   6018  276b3				   -	       endif
   6019  276b3				   -			; at half resolution we just exit after updating x and y
   6020  276b3				   -	       jmp	LLRET1
   6021  276b3				   -mouse1halveddone
   6022  276b3				   -	       endif		; PRECISIONMOUSING
   6023  276b3				   -
   6024  276b3				   -	       ifnconst	MOUSEXONLY
   6025  276b3				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   6026  276b3				   -	       ldy	port1resolution
   6027  276b3				   -	       dey
   6028  276b3				   -	       lda	#0
   6029  276b3				   -mousey1resolutionfix
   6030  276b3				   -	       clc
   6031  276b3				   -	       adc	mouseydelta
   6032  276b3				   -	       dey
   6033  276b3				   -	       bpl	mousey1resolutionfix
   6034  276b3				   -	       clc
   6035  276b3				   -	       adc	mousey1
   6036  276b3				   -	       sta	mousey1
   6037  276b3				   -	       endif		; MOUSEXONLY
   6038  276b3				   -
   6039  276b3				   -	       ldy	port1resolution
   6040  276b3				   -	       dey
   6041  276b3				   -	       lda	#0
   6042  276b3				   -mousex1resolutionfix
   6043  276b3				   -	       clc
   6044  276b3				   -	       adc	mousexdelta
   6045  276b3				   -	       dey
   6046  276b3				   -	       bpl	mousex1resolutionfix
   6047  276b3				   -	       ifnconst	DRIVINGBOOST
   6048  276b3				   -	       clc
   6049  276b3				   -	       adc	mousex1
   6050  276b3				   -	       sta	mousex1
   6051  276b3				   -	       else
   6052  276b3				   -	       cpx	#6
   6053  276b3				   -	       beq	carryonmouse1boost
   6054  276b3				   -	       clc
   6055  276b3				   -	       adc	mousex1
   6056  276b3				   -	       sta	mousex1
   6057  276b3				   -	       jmp	LLRET1
   6058  276b3				   -carryonmouse1boost
   6059  276b3				   -	       sta	mousexdelta
   6060  276b3				   -	       clc
   6061  276b3				   -	       adc	mousecodey1
   6062  276b3				   -	       sta	mousecodey1
   6063  276b3				   -	       clc
   6064  276b3				   -	       adc	mousex1
   6065  276b3				   -	       tay		; save the target X
   6066  276b3				   -	       adc	mousey1	; average in the smoothly-trailing X
   6067  276b3				   -	       ror
   6068  276b3				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   6069  276b3				   -	       sty	mousey1	; and mousey0 has the the target X
   6070  276b3				   -
   6071  276b3				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   6072  276b3				   -			; A has mousex1, the smoothly trailing X
   6073  276b3				   -	       sbc	mousey1	; less the target X
   6074  276b3				   -	       bpl	skipabsolutedrive1
   6075  276b3				   -	       eor	#$ff
   6076  276b3				   -skipabsolutedrive1
   6077  276b3				   -	       cmp	#64	; just an unreasonably large change
   6078  276b3				   -	       bcc	skipdrivewrapfix1
   6079  276b3				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   6080  276b3				   -skipdrivewrapfix1
   6081  276b3				   -
   6082  276b3				   -			; get rid of the tweening if the distance travelled was very small
   6083  276b3				   -	       lda	mousexdelta
   6084  276b3				   -	       cmp	port1resolution
   6085  276b3				   -	       bcs	skipbetweenfix1
   6086  276b3				   -	       lda	mousex1
   6087  276b3				   -	       sta	mousey1
   6088  276b3				   -skipbetweenfix1
   6089  276b3				   -
   6090  276b3				   -drivingboostreductioncheck1
   6091  276b3				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   6092  276b3				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   6093  276b3				   -			; negated again because truncation during BCD math results in 
   6094  276b3				   -			; differing magnitudes, depending if the value is  +ve or -ve.
   6095  276b3				   -driving1fix
   6096  276b3				   -	       lax	mousecodey1
   6097  276b3				   -	       cmp	#$80
   6098  276b3				   -	       bcs	driving0skipnegate1
   6099  276b3				   -	       eor	#$FF
   6100  276b3				   -	       adc	#1
   6101  276b3				   -	       sta	mousecodey1
   6102  276b3				   -driving0skipnegate1
   6103  276b3				   -	       cmp	#$80
   6104  276b3				   -	       ror
   6105  276b3				   -	       cmp	#$80
   6106  276b3				   -	       ror
   6107  276b3				   -	       cmp	#$80
   6108  276b3				   -	       ror
   6109  276b3				   -	       sta	inttemp1
   6110  276b3				   -	       lda	mousecodey1
   6111  276b3				   -	       sec
   6112  276b3				   -	       sbc	inttemp1
   6113  276b3				   -	       cpx	#$80
   6114  276b3				   -	       bcs	driving1skipnegate2
   6115  276b3				   -	       eor	#$FF
   6116  276b3				   -	       adc	#1
   6117  276b3				   -driving1skipnegate2
   6118  276b3				   -	       sta	mousecodey1
   6119  276b3				   -drivingboostdone1
   6120  276b3				   -	       endif		; DRIVINGBOOST
   6121  276b3				   -
   6122  276b3				   -	       jmp	LLRET1
   6123  276b3				   -
   6124  276b3					       endif		; MOUSE1SUPPORT
   6125  276b3
   6126  276b3
   6127  276b3				    trakball0update
   6128  276b3				   -	       ifconst	TRAKBALL0SUPPORT
   6129  276b3				   -	       ifnconst	TRAKTIME
   6130  276b3				   -	       ifnconst	TRAKXONLY
   6131  276b3				   -	       lda	#180	; minimum for x+y
   6132  276b3				   -	       else		;  !TRAKXONLY
   6133  276b3				   -	       lda	#100	; minimum for just x
   6134  276b3				   -	       endif		; !TRAKXONLY
   6135  276b3				   -	       else		; !TRAKTIME
   6136  276b3				   -	       lda	#TRAKTIME
   6137  276b3				   -	       endif		; !TRAKTIME
   6138  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   6139  276b3				   -	       ldx	#0
   6140  276b3				   -	       ifnconst	TRAKXONLY
   6141  276b3				   -	       ldy	#0
   6142  276b3				   -	       endif		;  TRAKXONLY
   6143  276b3				   -trakball0updateloop
   6144  276b3				   -	       lda	SWCHA
   6145  276b3				   -	       and	#%00110000
   6146  276b3				   -	       cmp	trakballcodex0
   6147  276b3				   -	       sta	trakballcodex0
   6148  276b3				   -	       beq	trakball0movementXdone
   6149  276b3				   -	       and	#%00010000
   6150  276b3				   -	       beq	trakball0negativeX
   6151  276b3				   -trakball0positiveX
   6152  276b3				   -			;(2 from beq)
   6153  276b3				   -	       inx		; 2
   6154  276b3				   -	       jmp	trakball0movementXdone	; 3
   6155  276b3				   -trakball0negativeX
   6156  276b3				   -			;(3 from beq)
   6157  276b3				   -	       dex		; 2
   6158  276b3				   -	       nop		; 2
   6159  276b3				   -trakball0movementXdone
   6160  276b3				   -
   6161  276b3				   -	       ifnconst	TRAKXONLY
   6162  276b3				   -	       lda	SWCHA
   6163  276b3				   -	       and	#%11000000
   6164  276b3				   -	       cmp	trakballcodey0
   6165  276b3				   -	       sta	trakballcodey0
   6166  276b3				   -	       beq	trakball0movementYdone
   6167  276b3				   -	       and	#%01000000
   6168  276b3				   -	       beq	trakball0negativeY
   6169  276b3				   -trakball0positiveY
   6170  276b3				   -			;(2 from beq)
   6171  276b3				   -	       iny		; 2
   6172  276b3				   -	       jmp	trakball0movementYdone	; 3
   6173  276b3				   -trakball0negativeY
   6174  276b3				   -			;(3 from beq)
   6175  276b3				   -	       dey		; 2
   6176  276b3				   -	       nop		; 2
   6177  276b3				   -trakball0movementYdone
   6178  276b3				   -	       endif		; !TRAKXONLY
   6179  276b3				   -
   6180  276b3				   -	       lda	TIMINT
   6181  276b3				   -	       bpl	trakball0updateloop
   6182  276b3				   -	       lda	#0
   6183  276b3				   -	       cpx	#0
   6184  276b3				   -	       beq	trakball0skipXadjust
   6185  276b3				   -	       clc
   6186  276b3				   -trakball0Xloop
   6187  276b3				   -	       adc	port0resolution
   6188  276b3				   -	       dex
   6189  276b3				   -	       bne	trakball0Xloop
   6190  276b3				   -	       clc
   6191  276b3				   -	       adc	trakballx0
   6192  276b3				   -	       sta	trakballx0
   6193  276b3				   -trakball0skipXadjust
   6194  276b3				   -	       ifnconst	TRAKXONLY
   6195  276b3				   -	       lda	#0
   6196  276b3				   -	       cpy	#0
   6197  276b3				   -	       beq	trakball0skipYadjust
   6198  276b3				   -	       clc
   6199  276b3				   -trakball0yloop
   6200  276b3				   -	       adc	port0resolution
   6201  276b3				   -	       dey
   6202  276b3				   -	       bne	trakball0yloop
   6203  276b3				   -	       clc
   6204  276b3				   -	       adc	trakbally0
   6205  276b3				   -	       sta	trakbally0
   6206  276b3				   -trakball0skipYadjust
   6207  276b3				   -	       endif		; !TRAKXONLY
   6208  276b3				   -
   6209  276b3				   -	       jmp	LLRET0
   6210  276b3					       endif
   6211  276b3
   6212  276b3
   6213  276b3
   6214  276b3				    trakball1update
   6215  276b3				   -	       ifconst	TRAKBALL1SUPPORT
   6216  276b3				   -	       ifnconst	TRAKTIME
   6217  276b3				   -	       ifnconst	TRAKXONLY
   6218  276b3				   -	       lda	#180	; minimum for x+y
   6219  276b3				   -	       else		;  !TRAKXONLY
   6220  276b3				   -	       lda	#100	; minimum for just x
   6221  276b3				   -	       endif		; !TRAKXONLY
   6222  276b3				   -	       else		; !TRAKTIME
   6223  276b3				   -	       lda	#TRAKTIME
   6224  276b3				   -	       endif		; !TRAKTIME
   6225  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   6226  276b3				   -	       ldx	#0
   6227  276b3				   -	       ifnconst	TRAKXONLY
   6228  276b3				   -	       ldy	#0
   6229  276b3				   -	       endif		;  TRAKXONLY
   6230  276b3				   -trakball1updateloop
   6231  276b3				   -	       lda	SWCHA
   6232  276b3				   -	       and	#%00000011
   6233  276b3				   -	       cmp	trakballcodex1
   6234  276b3				   -	       sta	trakballcodex1
   6235  276b3				   -	       beq	trakball1movementXdone
   6236  276b3				   -	       and	#%00000001
   6237  276b3				   -	       beq	trakball1negativeX
   6238  276b3				   -trakball1positiveX
   6239  276b3				   -			;(2 from beq)
   6240  276b3				   -	       inx		; 2
   6241  276b3				   -	       jmp	trakball1movementXdone	; 3
   6242  276b3				   -trakball1negativeX
   6243  276b3				   -			;(3 from beq)
   6244  276b3				   -	       dex		; 2
   6245  276b3				   -	       nop		; 2
   6246  276b3				   -trakball1movementXdone
   6247  276b3				   -
   6248  276b3				   -	       ifnconst	TRAKXONLY
   6249  276b3				   -	       lda	SWCHA
   6250  276b3				   -	       and	#%00001100
   6251  276b3				   -	       cmp	trakballcodey1
   6252  276b3				   -	       sta	trakballcodey1
   6253  276b3				   -	       beq	trakball1movementYdone
   6254  276b3				   -	       and	#%00000100
   6255  276b3				   -	       beq	trakball1negativeY
   6256  276b3				   -trakball1positiveY
   6257  276b3				   -			;(2 from beq)
   6258  276b3				   -	       iny		; 2
   6259  276b3				   -	       jmp	trakball1movementYdone	; 3
   6260  276b3				   -trakball1negativeY
   6261  276b3				   -			;(3 from beq)
   6262  276b3				   -	       dey		; 2
   6263  276b3				   -	       nop		; 2
   6264  276b3				   -trakball1movementYdone
   6265  276b3				   -	       endif		; !TRAKXONLY
   6266  276b3				   -
   6267  276b3				   -	       lda	TIMINT
   6268  276b3				   -	       bpl	trakball1updateloop
   6269  276b3				   -	       lda	#0
   6270  276b3				   -	       cpx	#0
   6271  276b3				   -	       beq	trakball1skipXadjust
   6272  276b3				   -	       clc
   6273  276b3				   -trakball1Xloop
   6274  276b3				   -	       adc	port1resolution
   6275  276b3				   -	       dex
   6276  276b3				   -	       bne	trakball1Xloop
   6277  276b3				   -	       clc
   6278  276b3				   -	       adc	trakballx1
   6279  276b3				   -	       sta	trakballx1
   6280  276b3				   -trakball1skipXadjust
   6281  276b3				   -	       ifnconst	TRAKXONLY
   6282  276b3				   -	       lda	#0
   6283  276b3				   -	       cpy	#0
   6284  276b3				   -	       beq	trakball1skipYadjust
   6285  276b3				   -	       clc
   6286  276b3				   -trakball1yloop
   6287  276b3				   -	       adc	port1resolution
   6288  276b3				   -	       dey
   6289  276b3				   -	       bne	trakball1yloop
   6290  276b3				   -	       clc
   6291  276b3				   -	       adc	trakbally1
   6292  276b3				   -	       sta	trakbally1
   6293  276b3				   -trakball1skipYadjust
   6294  276b3				   -	       endif		; !TRAKXONLY
   6295  276b3				   -
   6296  276b3				   -	       jmp	LLRET1
   6297  276b3					       endif
   6298  276b3
   6299  276b3
   6300  276b3				    paddleport0update
   6301  276b3				   -	       ifconst	PADDLE0SUPPORT
   6302  276b3				   -	       lda	#6
   6303  276b3				   -	       sta	VBLANK	; start charging the paddle caps
   6304  276b3				   -	       lda	#0	; use PADDLE timing
   6305  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   6306  276b3				   -
   6307  276b3				   -paddleport0updateloop
   6308  276b3				   -	       lda	INPT0
   6309  276b3				   -	       bmi	skippaddle0setposition
   6310  276b3				   -	       sty	paddleposition0
   6311  276b3				   -skippaddle0setposition
   6312  276b3				   -	       ifconst	TWOPADDLESUPPORT
   6313  276b3				   -	       lda	INPT1
   6314  276b3				   -	       bmi	skippaddle1setposition
   6315  276b3				   -	       sty	paddleposition1
   6316  276b3				   -skippaddle1setposition
   6317  276b3				   -	       endif
   6318  276b3				   -	       ldy	INTIM
   6319  276b3				   -	       cpy	#TIMEOFFSET
   6320  276b3				   -	       bcs	paddleport0updateloop
   6321  276b3				   -
   6322  276b3				   -	       lda	#%10000110
   6323  276b3				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6324  276b3				   -	       sec
   6325  276b3				   -	       lda	paddleposition0
   6326  276b3				   -	       sbc	#TIMEOFFSET
   6327  276b3				   -	       ifconst	PADDLESCALEX2
   6328  276b3				   -	       asl
   6329  276b3				   -	       endif
   6330  276b3				   -
   6331  276b3				   -	       ifnconst	PADDLESMOOTHINGOFF
   6332  276b3				   -	       clc
   6333  276b3				   -	       adc	paddleprevious0
   6334  276b3				   -	       ror
   6335  276b3				   -	       sta	paddleprevious0
   6336  276b3				   -	       endif
   6337  276b3				   -
   6338  276b3				   -	       sta	paddleposition0
   6339  276b3				   -
   6340  276b3				   -	       ifconst	TWOPADDLESUPPORT
   6341  276b3				   -	       sec
   6342  276b3				   -	       lda	paddleposition1
   6343  276b3				   -	       sbc	#TIMEOFFSET
   6344  276b3				   -	       ifconst	PADDLESCALEX2
   6345  276b3				   -	       asl
   6346  276b3				   -	       endif
   6347  276b3				   -
   6348  276b3				   -	       ifnconst	PADDLESMOOTHINGOFF
   6349  276b3				   -	       clc
   6350  276b3				   -	       adc	paddleprevious1
   6351  276b3				   -	       ror
   6352  276b3				   -	       sta	paddleprevious1
   6353  276b3				   -	       endif
   6354  276b3				   -	       sta	paddleposition1
   6355  276b3				   -	       endif		; TWOPADDLESUPPORT
   6356  276b3				   -
   6357  276b3				   -	       jmp	LLRET0
   6358  276b3					       endif
   6359  276b3
   6360  276b3				    paddleport1update
   6361  276b3				   -	       ifconst	PADDLE1SUPPORT
   6362  276b3				   -	       lda	#6
   6363  276b3				   -	       sta	VBLANK	; start charging the paddle caps
   6364  276b3				   -
   6365  276b3				   -	       lda	#0	; use PADDLE timing
   6366  276b3				   -	       jsr	SETTIM64T	; INTIM is in Y
   6367  276b3				   -
   6368  276b3				   -paddleport1updateloop
   6369  276b3				   -	       lda	INPT2
   6370  276b3				   -	       bmi	skippaddle2setposition
   6371  276b3				   -	       sty	paddleposition2
   6372  276b3				   -skippaddle2setposition
   6373  276b3				   -	       ifconst	TWOPADDLESUPPORT
   6374  276b3				   -	       lda	INPT3
   6375  276b3				   -	       bmi	skippaddle3setposition
   6376  276b3				   -	       sty	paddleposition3
   6377  276b3				   -skippaddle3setposition
   6378  276b3				   -	       endif
   6379  276b3				   -	       ldy	INTIM
   6380  276b3				   -	       cpy	#TIMEOFFSET
   6381  276b3				   -	       bcs	paddleport1updateloop
   6382  276b3				   -
   6383  276b3				   -	       lda	#%10000110
   6384  276b3				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6385  276b3				   -	       sec
   6386  276b3				   -	       lda	paddleposition2
   6387  276b3				   -	       sbc	#TIMEOFFSET
   6388  276b3				   -	       ifconst	PADDLESCALEX2
   6389  276b3				   -	       asl
   6390  276b3				   -	       endif
   6391  276b3				   -
   6392  276b3				   -	       ifnconst	PADDLESMOOTHINGOFF
   6393  276b3				   -	       clc
   6394  276b3				   -	       adc	paddleprevious2
   6395  276b3				   -	       ror
   6396  276b3				   -	       sta	paddleprevious2
   6397  276b3				   -	       endif
   6398  276b3				   -
   6399  276b3				   -	       sta	paddleposition2
   6400  276b3				   -
   6401  276b3				   -	       ifconst	TWOPADDLESUPPORT
   6402  276b3				   -	       sec
   6403  276b3				   -	       lda	paddleposition3
   6404  276b3				   -	       sbc	#TIMEOFFSET
   6405  276b3				   -	       ifconst	PADDLESCALEX2
   6406  276b3				   -	       asl
   6407  276b3				   -	       endif
   6408  276b3				   -
   6409  276b3				   -	       ifnconst	PADDLESMOOTHINGOFF
   6410  276b3				   -	       clc
   6411  276b3				   -	       adc	paddleprevious3
   6412  276b3				   -	       ror
   6413  276b3				   -	       sta	paddleprevious3
   6414  276b3				   -	       endif
   6415  276b3				   -	       sta	paddleposition3
   6416  276b3				   -	       endif		; TWOPADDLESUPPORT
   6417  276b3				   -
   6418  276b3				   -	       jmp	LLRET1
   6419  276b3					       endif
   6420  276b3
   6421  276b3
   6422  276b3				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   6423  276b3				   -	       ifconst	PADDLESUPPORT
   6424  276b3				   -			; x=0|1 for port, rather than paddle #. 
   6425  276b3				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   6426  276b3				   -			; game wants to support 2 paddles, up to the game to instead test the 
   6427  276b3				   -			; joystick right+left directions instead.
   6428  276b3				   -	       lda	SWCHA	; top of nibble is first paddle button
   6429  276b3				   -	       cpx	#0	; port 0?
   6430  276b3				   -	       beq	skippaddleport2shift
   6431  276b3				   -	       asl		; shift second port to upper nibble
   6432  276b3				   -	       asl
   6433  276b3				   -	       asl
   6434  276b3				   -	       asl
   6435  276b3				   -skippaddleport2shift
   6436  276b3				   -	       and	#%10000000
   6437  276b3				   -	       eor	#%10000000	; invert
   6438  276b3				   -	       sta	sINPT1,x
   6439  276b3				   -	       jmp	buttonreadloopreturn
   6440  276b3					       endif		; PADDLESUPPORT
   6441  276b3
   6442  276b3				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   6443  276b3				   -	       ifconst	MOUSESUPPORT
   6444  276b3				   -			; stick the mouse buttons in the correct shadow register...
   6445  276b3				   -	       txa
   6446  276b3				   -	       asl
   6447  276b3				   -	       tay		; y=x*2
   6448  276b3				   -	       lda	INPT4,x
   6449  276b3				   -	       eor	#%10000000
   6450  276b3				   -	       lsr
   6451  276b3				   -	       sta	sINPT1,x
   6452  276b3				   -
   6453  276b3				   -	       lda	INPT1,y
   6454  276b3				   -	       and	#%10000000
   6455  276b3				   -	       eor	#%10000000
   6456  276b3				   -	       ora	sINPT1,x
   6457  276b3				   -	       sta	sINPT1,x
   6458  276b3				   -	       jmp	buttonreadloopreturn
   6459  276b3					       endif		; MOUSESUPPORT
   6460  276b3
   6461  276b3				   -	       ifconst	KEYPADSUPPORT
   6462  276b3				   -			; ** select keypad rows 0 to 3 over 4 frames...
   6463  276b3				   -keypadrowselect
   6464  276b3				   -	       ldy	#0
   6465  276b3				   -	       lda	port0control
   6466  276b3				   -	       cmp	#7
   6467  276b3				   -	       bne	skipport0val
   6468  276b3				   -	       iny		; y=y+1
   6469  276b3				   -skipport0val
   6470  276b3				   -	       lda	port1control
   6471  276b3				   -	       cmp	#7
   6472  276b3				   -	       bne	skipport1val
   6473  276b3				   -	       iny
   6474  276b3				   -	       iny		; y=y+2
   6475  276b3				   -skipport1val
   6476  276b3				   -	       lda	keyrowdirectionmask,y
   6477  276b3				   -	       sta	CTLSWA
   6478  276b3				   -	       tya
   6479  276b3				   -	       asl
   6480  276b3				   -	       asl
   6481  276b3				   -	       sta	inttemp1
   6482  276b3				   -	       lda	framecounter
   6483  276b3				   -	       and	#3
   6484  276b3				   -	       ora	inttemp1
   6485  276b3				   -	       tax
   6486  276b3				   -	       lda	keyrowselectvalue,x
   6487  276b3				   -	       sta	SWCHA
   6488  276b3				   -	       rts
   6489  276b3				   -
   6490  276b3				   -keyrowdirectionmask
   6491  276b3				   -	       .byte	#%00000000	; 0 : port0=input  port1=input
   6492  276b3				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   6493  276b3				   -	       .byte	#%00001111	; 2 : port0=input  port1=output
   6494  276b3				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   6495  276b3				   -
   6496  276b3				   -keyrowselectvalue
   6497  276b3				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   6498  276b3				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   6499  276b3				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   6500  276b3				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   6501  276b3					       endif		;  KEYPADSUPPORT
   6502  276b3
   6503  276b3				   -	       ifconst	KEYPADSUPPORT
   6504  276b3				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   6505  276b3				   -keypadcolumnread
   6506  276b3				   -	       lda	port0control
   6507  276b3				   -	       cmp	#7
   6508  276b3				   -	       bne	skipkeypadcolumnread0
   6509  276b3				   -	       lda	framecounter
   6510  276b3				   -	       and	#3
   6511  276b3				   -	       asl		; x2 because keypad variables are interleaved
   6512  276b3				   -	       tax
   6513  276b3				   -	       lda	#0
   6514  276b3				   -	       sta	keypadmatrix0a,x
   6515  276b3				   -	       lda	INPT0
   6516  276b3				   -	       cmp	#$80
   6517  276b3				   -	       rol	keypadmatrix0a,x
   6518  276b3				   -	       lda	INPT1
   6519  276b3				   -	       cmp	#$80
   6520  276b3				   -	       rol	keypadmatrix0a,x
   6521  276b3				   -	       lda	INPT4
   6522  276b3				   -	       cmp	#$80
   6523  276b3				   -	       rol	keypadmatrix0a,x
   6524  276b3				   -	       lda	keypadmatrix0a,x
   6525  276b3				   -	       eor	#%00000111
   6526  276b3				   -	       sta	keypadmatrix0a,x
   6527  276b3				   -skipkeypadcolumnread0
   6528  276b3				   -
   6529  276b3				   -	       lda	port1control
   6530  276b3				   -	       cmp	#7
   6531  276b3				   -	       bne	skipkeypadcolumnread1
   6532  276b3				   -	       lda	framecounter
   6533  276b3				   -	       and	#3
   6534  276b3				   -	       asl		; x2 because keypad variables are interleaved
   6535  276b3				   -	       tax
   6536  276b3				   -	       lda	#0
   6537  276b3				   -	       sta	keypadmatrix1a,x
   6538  276b3				   -	       rol	keypadmatrix1a,x
   6539  276b3				   -	       lda	INPT2
   6540  276b3				   -	       cmp	#$80
   6541  276b3				   -	       rol	keypadmatrix1a,x
   6542  276b3				   -	       lda	INPT3
   6543  276b3				   -	       cmp	#$80
   6544  276b3				   -	       rol	keypadmatrix1a,x
   6545  276b3				   -	       lda	INPT5
   6546  276b3				   -	       cmp	#$80
   6547  276b3				   -	       rol	keypadmatrix1a,x
   6548  276b3				   -	       lda	keypadmatrix1a,x
   6549  276b3				   -	       eor	#%00000111
   6550  276b3				   -	       sta	keypadmatrix1a,x
   6551  276b3				   -skipkeypadcolumnread1
   6552  276b3				   -	       rts
   6553  276b3					       endif		; KEYPADSUPPORT
   6554  276b3
   6555  276b3				    setportforinput
   6556  276b3			a5 e4		       lda	CTLSWAs
   6557  276b5			3d be f6	       and	allpinsinputlut,x
   6558  276b8			85 e4		       sta	CTLSWAs
   6559  276ba			8d 81 02	       sta	CTLSWA
   6560  276bd			60		       rts
   6561  276be
   6562  276be				    allpinsinputlut
   6563  276be			0f f0		       .byte.b	$0F, $F0
   6564  276c0
   6565  276c0				    setonebuttonmode
   6566  276c0			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   6567  276c2			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   6568  276c4			a9 14		       lda	#$14
   6569  276c6			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   6570  276c9			a5 e5		       lda	CTLSWBs
   6571  276cb			1d d4 f6	       ora	thisjoy2buttonbit,x
   6572  276ce			85 e5		       sta	CTLSWBs
   6573  276d0			8d 82 02	       sta	SWCHB	; turn off the 2-button disable bits
   6574  276d3			60		       rts
   6575  276d4
   6576  276d4				    thisjoy2buttonbit
   6577  276d4			04 10		       .byte.b	$04, $10
   6578  276d6
   6579  276d6				    settwobuttonmode
   6580  276d6			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   6581  276d8			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   6582  276da			a9 14		       lda	#$14
   6583  276dc			8d 83 02	       sta	CTLSWB	; set both 2-button disable bits to writable
   6584  276df			a5 e5		       lda	CTLSWBs
   6585  276e1			3d ea f6	       and	thisjoy2buttonmask,x
   6586  276e4			85 e5		       sta	CTLSWBs
   6587  276e6			8d 82 02	       sta	SWCHB
   6588  276e9			60		       rts
   6589  276ea
   6590  276ea				    thisjoy2buttonmask
   6591  276ea			fb ef		       .byte.b	$fb, $ef
   6592  276ec
   6593  276ec							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6594  276ec
   6595  276ec				    START
   6596  276ec				    start
   6597  276ec
   6598  276ec							;******** more or less the Atari recommended startup procedure
   6599  276ec
   6600  276ec			78		       sei
   6601  276ed			d8		       cld
   6602  276ee
   6603  276ee					       ifnconst	NOTIALOCK
   6604  276ee			a9 07		       lda	#$07
   6605  276f0				   -	       else
   6606  276f0				   -	       lda	#$06
   6607  276f0					       endif
   6608  276f0			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   6609  276f2			a9 7f		       lda	#$7F
   6610  276f4			85 3c		       sta	CTRL	;disable DMA
   6611  276f6			a9 00		       lda	#$00
   6612  276f8			85 38		       sta	OFFSET
   6613  276fa					       ifnconst	NOTIALOCK
   6614  276fa			85 01		       sta	INPTCTRL
   6615  276fc			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   6616  276fe					       endif
   6617  276fe			a2 ff		       ldx	#$FF
   6618  27700			9a		       txs
   6619  27701
   6620  27701							;************** Clear Memory
   6621  27701
   6622  27701							; ** Clear 1800-27FF, pg0+pg1 memory.
   6623  27701				    ClearMemPages
   6624  27701			a9 00		       lda	#0
   6625  27703			a8		       tay		; y=0
   6626  27704			85 80		       sta	$80
   6627  27706			a2 18		       ldx	#$18
   6628  27708				    ClearMemPagesLoop
   6629  27708			86 81		       stx	$81	; needed for when we step on ZP memory
   6630  2770a			91 80		       sta	($80),y	;Store data
   6631  2770c			c8		       iny		;Next byte
   6632  2770d			d0 f9		       bne	ClearMemPagesLoop
   6633  2770f			e8		       inx
   6634  27710			e0 28		       cpx	#$28
   6635  27712			d0 f4		       bne	ClearMemPagesLoop
   6636  27714			85 81		       sta	$81
   6637  27716
   6638  27716							;seed random number with hopefully-random timer value
   6639  27716			a9 01		       lda	#1
   6640  27718			0d 84 02	       ora	INTIM
   6641  2771b			85 40		       sta	rand
   6642  2771d
   6643  2771d							; detect the console type...
   6644  2771d				    pndetectvblankstart
   6645  2771d			a5 28		       lda	MSTAT
   6646  2771f			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   6647  27721				    pndetectvblankover
   6648  27721			a5 28		       lda	MSTAT
   6649  27723			30 fc		       bmi	pndetectvblankover	;  then wait for it to be over
   6650  27725			a0 00		       ldy	#$00
   6651  27727			a2 00		       ldx	#$00
   6652  27729				    pndetectvblankhappening
   6653  27729			a5 28		       lda	MSTAT
   6654  2772b			30 07		       bmi	pndetectinvblank	;  if VBLANK starts, exit our counting loop 
   6655  2772d			85 24		       sta	WSYNC
   6656  2772f			85 24		       sta	WSYNC
   6657  27731			e8		       inx
   6658  27732			d0 f5		       bne	pndetectvblankhappening
   6659  27734				    pndetectinvblank
   6660  27734			e0 7d		       cpx	#125
   6661  27736			90 02		       bcc	pndetecispal
   6662  27738			a0 01		       ldy	#$01
   6663  2773a				    pndetecispal
   6664  2773a			8c 09 21	       sty	paldetected
   6665  2773d
   6666  2773d			20 19 f6	       jsr	createallgamedlls
   6667  27740
   6668  27740			a9 18		       lda	#>DLLMEM
   6669  27742			85 2c		       sta	DPPH
   6670  27744			a9 00		       lda	#<DLLMEM
   6671  27746			85 30		       sta	DPPL
   6672  27748
   6673  27748			a9 04		       lda	#%00000100	; leave cartridge plugged in for any testing
   6674  2774a			8d b4 01	       sta	XCTRL1s
   6675  2774d
   6676  2774d					       ifconst	pokeysupport
   6677  2774d							; pokey support is compiled in, so try to detect it...
   6678  2774d			20 c7 f0	       jsr	detectpokeylocation
   6679  27750					       endif
   6680  27750
   6681  27750			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   6682  27752			8d b7 01	       sta	port0control
   6683  27755			8d b8 01	       sta	port1control
   6684  27758
   6685  27758							;Setup port A to read mode
   6686  27758							;lda #$00
   6687  27758							;sta SWCHA
   6688  27758							;sta CTLSWA
   6689  27758
   6690  27758				   -	       ifconst	HSSUPPORT
   6691  27758				   -	       ifconst	bankswitchmode
   6692  27758				   -	       ifconst	included.hiscore.asm.bank
   6693  27758				   -	       ifconst	MCPDEVCART
   6694  27758				   -	       lda	#($18 | included.hiscore.asm.bank)
   6695  27758				   -	       ifconst	dumpbankswitch
   6696  27758				   -	       sta	dumpbankswitch
   6697  27758				   -	       endif
   6698  27758				   -	       sta	$3000
   6699  27758				   -	       else
   6700  27758				   -	       lda	#(included.hiscore.asm.bank)
   6701  27758				   -	       ifconst	dumpbankswitch
   6702  27758				   -	       sta	dumpbankswitch
   6703  27758				   -	       endif
   6704  27758				   -	       sta	$8000
   6705  27758				   -	       endif
   6706  27758				   -	       endif		; included.hiscore.asm.bank
   6707  27758				   -	       endif		; bankswitchmode
   6708  27758				   -			; try to detect HSC
   6709  27758				   -	       jsr	detecthsc
   6710  27758				   -	       and	#1
   6711  27758				   -	       sta	hsdevice
   6712  27758				   -skipHSCdetect
   6713  27758				   -			; try to detect AtariVox eeprom
   6714  27758				   -	       jsr	detectatarivoxeeprom
   6715  27758				   -	       and	#2
   6716  27758				   -	       ora	hsdevice
   6717  27758				   -	       cmp	#3
   6718  27758				   -	       bne	storeAinhsdevice
   6719  27758				   -			; For now, we tie break by giving HSC priority over AtariVox.
   6720  27758				   -			; Later we should check each device's priority byte if set, instead, 
   6721  27758				   -	       lda	#2
   6722  27758				   -storeAinhsdevice
   6723  27758				   -	       sta	hsdevice
   6724  27758				   -	       lda	#$ff
   6725  27758				   -	       sta	hsdifficulty
   6726  27758				   -	       sta	hsgameslot
   6727  27758				   -	       sta	hsnewscoreline
   6728  27758					       endif		; HSSUPPORT
   6729  27758
   6730  27758				   -	       ifconst	AVOXVOICE
   6731  27758				   -	       jsr	silenceavoxvoice
   6732  27758					       endif
   6733  27758
   6734  27758					       ifconst	SGRAM
   6735  27758							; check if we actually have SGRAM. If not, probe XM for it...
   6736  27758			a0 ea		       ldy	#$EA
   6737  2775a			8c 00 40	       sty	$4000
   6738  2775d			ac 00 40	       ldy	$4000
   6739  27760			c0 ea		       cpy	#$EA
   6740  27762			f0 1d		       beq	skipSGRAMcheck
   6741  27764			ad b4 01	       lda	XCTRL1s
   6742  27767			09 64		       ora	#%01100100
   6743  27769			8d 70 04	       sta	XCTRL1
   6744  2776c			8c 00 40	       sty	$4000
   6745  2776f			ac 00 40	       ldy	$4000
   6746  27772			c0 ea		       cpy	#$EA
   6747  27774			d0 0b		       bne	skipSGRAMcheck
   6748  27776							;if we're here, XM memory satisfied our RAM requirement
   6749  27776			8d b4 01	       sta	XCTRL1s	; save it
   6750  27779			a9 10		       lda	#$10
   6751  2777b			8d 78 04	       sta	XCTRL2
   6752  2777e			8d 7c 04	       sta	XCTRL3
   6753  27781				    skipSGRAMcheck
   6754  27781					       endif
   6755  27781
   6756  27781					       ifconst	bankswitchmode
   6757  27781							; we need to switch to the first bank as a default. this needs to
   6758  27781							; happen before DMA, in case there's a topscreenroutine in bank 0
   6759  27781				   -	       ifconst	MCPDEVCART
   6760  27781				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   6761  27781				   -	       ifconst	dumpbankswitch
   6762  27781				   -	       sta	dumpbankswitch
   6763  27781				   -	       endif
   6764  27781				   -	       sta	$3000
   6765  27781					       else
   6766  27781			a9 00		       lda	#0
   6767  27783				   -	       ifconst	dumpbankswitch
   6768  27783				   -	       sta	dumpbankswitch
   6769  27783					       endif
   6770  27783			8d 00 80	       sta	$8000
   6771  27786					       endif
   6772  27786					       endif
   6773  27786
   6774  27786							; CTRL 76543210
   6775  27786							; 7 colorburst kill
   6776  27786							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   6777  27786							; 4 character width 1=2 byte chars, 0=1 byte chars
   6778  27786							; 3 border control 0=background color border, 1=black border
   6779  27786							; 2 kangaroo mode 0=transparancy, 1=kangaroo
   6780  27786							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   6781  27786
   6782  27786				   -	       ifconst	DOUBLEWIDE
   6783  27786				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   6784  27786					       else
   6785  27786			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   6786  27788					       endif
   6787  27788
   6788  27788			20 aa f6	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   6789  2778b
   6790  2778b			85 3c		       sta	CTRL
   6791  2778d			8d 07 21	       sta	sCTRL
   6792  27790
   6793  27790			20 0c f6	       jsr	vblankresync
   6794  27793
   6795  27793			a2 01		       ldx	#1
   6796  27795			20 d6 f6	       jsr	settwobuttonmode
   6797  27798			a2 00		       ldx	#0
   6798  2779a			20 d6 f6	       jsr	settwobuttonmode
   6799  2779d
   6800  2779d					       ifnconst	.altgamestart
   6801  2779d			4c 00 80	       jmp	game
   6802  277a0				   -	       else
   6803  277a0				   -	       jmp	.altgamestart
   6804  277a0					       endif
   6805  277a0
   6806  277a0							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6807  277a0
   6808  277a0							;************** Setup DLL entries
   6809  277a0
   6810  277a0							; setup some working definitions, to avoid ifnconst mess elsewhere...
   6811  277a0					       ifnconst	SCREENHEIGHT
   6812  277a0			00 c0	    WSCREENHEIGHT =	192
   6813  277a0				   -	       else
   6814  277a0				   -WSCREENHEIGHT =	SCREENHEIGHT
   6815  277a0					       endif
   6816  277a0
   6817  277a0				   -	       ifnconst	ZONEHEIGHT
   6818  277a0				   -WZONEHEIGHT =	16
   6819  277a0					       else
   6820  277a0			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   6821  277a0					       endif
   6822  277a0
   6823  277a0					       ifnconst	ZONECOUNT
   6824  277a0			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   6825  277a0				   -	       else
   6826  277a0				   -WZONECOUNT =	ZONECOUNT
   6827  277a0					       endif
   6828  277a0
   6829  277a0							; top of the frame, non-visible lines. this is based on NTSC,
   6830  277a0							; but we add in extra NV lines at the end of the display to ensure
   6831  277a0							; our PAL friends can play the game without it crashing.
   6832  277a0			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   6833  277a0
   6834  277a0				   -	       ifnconst	DLMEMSTART
   6835  277a0				   -	       ifnconst	DOUBLEBUFFER
   6836  277a0				   -WDLMEMSTART =	$1880
   6837  277a0				   -	       else
   6838  277a0				   -WDLMEMSTART =	$18E0
   6839  277a0				   -	       endif		; DOUBLEBUFFER
   6840  277a0					       else
   6841  277a0			40 00	    WDLMEMSTART =	DLMEMSTART
   6842  277a0					       endif
   6843  277a0
   6844  277a0				   -	       ifnconst	DLMEMEND
   6845  277a0				   -	       ifconst	EXTRADLMEMORY
   6846  277a0				   -WDLMEMEND  =	$23FF
   6847  277a0				   -	       else
   6848  277a0				   -WDLMEMEND  =	$1FFF
   6849  277a0				   -	       endif
   6850  277a0					       else
   6851  277a0			7f ff	    WDLMEMEND  =	DLMEMEND
   6852  277a0					       endif
   6853  277a0
   6854  277a0
   6855  277a0			40 00	    WMEMSIZE   =	(WDLMEMEND-WDLMEMSTART+1)
   6856  277a0
   6857  277a0					       ifnconst	DOUBLEBUFFER
   6858  277a0			05 50	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   6859  277a0				   -	       else
   6860  277a0				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   6861  277a0					       endif
   6862  277a0
   6863  277a0			05 52	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   6864  277a0					       if	TDOUBLEBUFFEROFFSET > 255
   6865  277a0			00 ff	    DOUBLEBUFFEROFFSET =	255
   6866  277a0				   -	       else
   6867  277a0				   -DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   6868  277a0					       endif
   6869  277a0
   6870  277a0				   -	       ifconst	EXTRADLMEMORY
   6871  277a0				   -SECONDDLHALFSTART SET	$2300
   6872  277a0					       endif
   6873  277a0
   6874  277a0				    DLPOINTH
   6875  277a0				    DLINDEX    SET	0
   6876  277a0					       REPEAT	WZONECOUNT
   6877  277a0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a0				   -	       ifconst	EXTRADLMEMORY
   6879  277a0				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a0				   -	       else
   6882  277a0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a0				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a0				   -	       endif
   6886  277a0				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a0					       endif		; EXTRADLMEMORY
   6888  277a0							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a0			40		       .byte.b	>TMPMEMADDRESS
   6890  277a0				    DLINDEX    SET	DLINDEX + 1
   6876  277a0					       REPEND
   6877  277a0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a1				   -	       ifconst	EXTRADLMEMORY
   6879  277a1				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a1				   -	       else
   6882  277a1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a1				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a1				   -	       endif
   6886  277a1				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a1					       endif		; EXTRADLMEMORY
   6888  277a1							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a1			45		       .byte.b	>TMPMEMADDRESS
   6890  277a1				    DLINDEX    SET	DLINDEX + 1
   6876  277a1					       REPEND
   6877  277a1				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a2				   -	       ifconst	EXTRADLMEMORY
   6879  277a2				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a2				   -	       else
   6882  277a2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a2				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a2				   -	       endif
   6886  277a2				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a2					       endif		; EXTRADLMEMORY
   6888  277a2							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a2			4a		       .byte.b	>TMPMEMADDRESS
   6890  277a2				    DLINDEX    SET	DLINDEX + 1
   6876  277a2					       REPEND
   6877  277a2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a3				   -	       ifconst	EXTRADLMEMORY
   6879  277a3				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a3				   -	       else
   6882  277a3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a3				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a3				   -	       endif
   6886  277a3				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a3					       endif		; EXTRADLMEMORY
   6888  277a3							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a3			50		       .byte.b	>TMPMEMADDRESS
   6890  277a3				    DLINDEX    SET	DLINDEX + 1
   6876  277a3					       REPEND
   6877  277a3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a4				   -	       ifconst	EXTRADLMEMORY
   6879  277a4				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a4				   -	       else
   6882  277a4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a4				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a4				   -	       endif
   6886  277a4				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a4					       endif		; EXTRADLMEMORY
   6888  277a4							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a4			55		       .byte.b	>TMPMEMADDRESS
   6890  277a4				    DLINDEX    SET	DLINDEX + 1
   6876  277a4					       REPEND
   6877  277a4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a5				   -	       ifconst	EXTRADLMEMORY
   6879  277a5				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a5				   -	       else
   6882  277a5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a5				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a5				   -	       endif
   6886  277a5				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a5					       endif		; EXTRADLMEMORY
   6888  277a5							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a5			5a		       .byte.b	>TMPMEMADDRESS
   6890  277a5				    DLINDEX    SET	DLINDEX + 1
   6876  277a5					       REPEND
   6877  277a5				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a6				   -	       ifconst	EXTRADLMEMORY
   6879  277a6				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a6				   -	       else
   6882  277a6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a6				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a6				   -	       endif
   6886  277a6				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a6					       endif		; EXTRADLMEMORY
   6888  277a6							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a6			60		       .byte.b	>TMPMEMADDRESS
   6890  277a6				    DLINDEX    SET	DLINDEX + 1
   6876  277a6					       REPEND
   6877  277a6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a7				   -	       ifconst	EXTRADLMEMORY
   6879  277a7				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a7				   -	       else
   6882  277a7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a7				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a7				   -	       endif
   6886  277a7				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a7					       endif		; EXTRADLMEMORY
   6888  277a7							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a7			65		       .byte.b	>TMPMEMADDRESS
   6890  277a7				    DLINDEX    SET	DLINDEX + 1
   6876  277a7					       REPEND
   6877  277a7				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a8				   -	       ifconst	EXTRADLMEMORY
   6879  277a8				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a8				   -	       else
   6882  277a8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a8				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a8				   -	       endif
   6886  277a8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a8					       endif		; EXTRADLMEMORY
   6888  277a8							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a8			6a		       .byte.b	>TMPMEMADDRESS
   6890  277a8				    DLINDEX    SET	DLINDEX + 1
   6876  277a8					       REPEND
   6877  277a8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277a9				   -	       ifconst	EXTRADLMEMORY
   6879  277a9				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277a9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277a9				   -	       else
   6882  277a9				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277a9				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277a9				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277a9				   -	       endif
   6886  277a9				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277a9					       endif		; EXTRADLMEMORY
   6888  277a9							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277a9			70		       .byte.b	>TMPMEMADDRESS
   6890  277a9				    DLINDEX    SET	DLINDEX + 1
   6876  277a9					       REPEND
   6877  277a9				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277aa				   -	       ifconst	EXTRADLMEMORY
   6879  277aa				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277aa				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277aa				   -	       else
   6882  277aa				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277aa				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277aa				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277aa				   -	       endif
   6886  277aa				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277aa					       endif		; EXTRADLMEMORY
   6888  277aa							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277aa			75		       .byte.b	>TMPMEMADDRESS
   6890  277aa				    DLINDEX    SET	DLINDEX + 1
   6876  277aa					       REPEND
   6877  277aa				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6878  277ab				   -	       ifconst	EXTRADLMEMORY
   6879  277ab				   -	       if	TMPMEMADDRESS > $1FFF
   6880  277ab				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6881  277ab				   -	       else
   6882  277ab				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6883  277ab				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6884  277ab				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6885  277ab				   -	       endif
   6886  277ab				   -	       endif		; TMPMEMADDRESS > $1FFF
   6887  277ab					       endif		; EXTRADLMEMORY
   6888  277ab							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6889  277ab			7a		       .byte.b	>TMPMEMADDRESS
   6890  277ab				    DLINDEX    SET	DLINDEX + 1
   6891  277ac					       REPEND
   6892  277ac
   6893  277ac				   -	       ifconst	EXTRADLMEMORY
   6894  277ac				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   6895  277ac					       endif
   6896  277ac
   6897  277ac
   6898  277ac				    DLPOINTL
   6899  277ac				    DLINDEX    SET	0
   6900  277ac					       REPEAT	WZONECOUNT
   6901  277ac				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277ac				   -	       ifconst	EXTRADLMEMORY
   6903  277ac				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277ac				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277ac				   -	       else
   6906  277ac				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277ac				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277ac				   -	       endif
   6909  277ac				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277ac					       endif		; EXTRADLMEMORY
   6911  277ac			00		       .byte.b	<TMPMEMADDRESS
   6912  277ac				    DLINDEX    SET	DLINDEX + 1
   6900  277ac					       REPEND
   6901  277ac				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277ad				   -	       ifconst	EXTRADLMEMORY
   6903  277ad				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277ad				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277ad				   -	       else
   6906  277ad				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277ad				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277ad				   -	       endif
   6909  277ad				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277ad					       endif		; EXTRADLMEMORY
   6911  277ad			55		       .byte.b	<TMPMEMADDRESS
   6912  277ad				    DLINDEX    SET	DLINDEX + 1
   6900  277ad					       REPEND
   6901  277ad				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277ae				   -	       ifconst	EXTRADLMEMORY
   6903  277ae				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277ae				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277ae				   -	       else
   6906  277ae				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277ae				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277ae				   -	       endif
   6909  277ae				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277ae					       endif		; EXTRADLMEMORY
   6911  277ae			aa		       .byte.b	<TMPMEMADDRESS
   6912  277ae				    DLINDEX    SET	DLINDEX + 1
   6900  277ae					       REPEND
   6901  277ae				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277af				   -	       ifconst	EXTRADLMEMORY
   6903  277af				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277af				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277af				   -	       else
   6906  277af				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277af				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277af				   -	       endif
   6909  277af				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277af					       endif		; EXTRADLMEMORY
   6911  277af			00		       .byte.b	<TMPMEMADDRESS
   6912  277af				    DLINDEX    SET	DLINDEX + 1
   6900  277af					       REPEND
   6901  277af				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b0				   -	       ifconst	EXTRADLMEMORY
   6903  277b0				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b0				   -	       else
   6906  277b0				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b0				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b0				   -	       endif
   6909  277b0				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b0					       endif		; EXTRADLMEMORY
   6911  277b0			55		       .byte.b	<TMPMEMADDRESS
   6912  277b0				    DLINDEX    SET	DLINDEX + 1
   6900  277b0					       REPEND
   6901  277b0				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b1				   -	       ifconst	EXTRADLMEMORY
   6903  277b1				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b1				   -	       else
   6906  277b1				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b1				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b1				   -	       endif
   6909  277b1				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b1					       endif		; EXTRADLMEMORY
   6911  277b1			aa		       .byte.b	<TMPMEMADDRESS
   6912  277b1				    DLINDEX    SET	DLINDEX + 1
   6900  277b1					       REPEND
   6901  277b1				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b2				   -	       ifconst	EXTRADLMEMORY
   6903  277b2				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b2				   -	       else
   6906  277b2				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b2				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b2				   -	       endif
   6909  277b2				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b2					       endif		; EXTRADLMEMORY
   6911  277b2			00		       .byte.b	<TMPMEMADDRESS
   6912  277b2				    DLINDEX    SET	DLINDEX + 1
   6900  277b2					       REPEND
   6901  277b2				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b3				   -	       ifconst	EXTRADLMEMORY
   6903  277b3				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b3				   -	       else
   6906  277b3				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b3				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b3				   -	       endif
   6909  277b3				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b3					       endif		; EXTRADLMEMORY
   6911  277b3			55		       .byte.b	<TMPMEMADDRESS
   6912  277b3				    DLINDEX    SET	DLINDEX + 1
   6900  277b3					       REPEND
   6901  277b3				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b4				   -	       ifconst	EXTRADLMEMORY
   6903  277b4				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b4				   -	       else
   6906  277b4				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b4				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b4				   -	       endif
   6909  277b4				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b4					       endif		; EXTRADLMEMORY
   6911  277b4			aa		       .byte.b	<TMPMEMADDRESS
   6912  277b4				    DLINDEX    SET	DLINDEX + 1
   6900  277b4					       REPEND
   6901  277b4				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b5				   -	       ifconst	EXTRADLMEMORY
   6903  277b5				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b5				   -	       else
   6906  277b5				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b5				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b5				   -	       endif
   6909  277b5				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b5					       endif		; EXTRADLMEMORY
   6911  277b5			00		       .byte.b	<TMPMEMADDRESS
   6912  277b5				    DLINDEX    SET	DLINDEX + 1
   6900  277b5					       REPEND
   6901  277b5				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b6				   -	       ifconst	EXTRADLMEMORY
   6903  277b6				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b6				   -	       else
   6906  277b6				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b6				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b6				   -	       endif
   6909  277b6				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b6					       endif		; EXTRADLMEMORY
   6911  277b6			55		       .byte.b	<TMPMEMADDRESS
   6912  277b6				    DLINDEX    SET	DLINDEX + 1
   6900  277b6					       REPEND
   6901  277b6				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6902  277b7				   -	       ifconst	EXTRADLMEMORY
   6903  277b7				   -	       if	TMPMEMADDRESS > $1FFF
   6904  277b7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6905  277b7				   -	       else
   6906  277b7				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6907  277b7				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6908  277b7				   -	       endif
   6909  277b7				   -	       endif		; TMPMEMADDRESS > $1FFF
   6910  277b7					       endif		; EXTRADLMEMORY
   6911  277b7			aa		       .byte.b	<TMPMEMADDRESS
   6912  277b7				    DLINDEX    SET	DLINDEX + 1
   6913  277b8					       REPEND
   6914  277b8
   6915  277b8
   6916  277b8				    DLINDEX    SET	0
   6917  277b8					       REPEAT	WZONECOUNT
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			40 00	    ZONE0ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			45 55	    ZONE1ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			4a aa	    ZONE2ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			50 00	    ZONE3ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			55 55	    ZONE4ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			5a aa	    ZONE5ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			60 00	    ZONE6ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			65 55	    ZONE7ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			6a aa	    ZONE8ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			70 00	    ZONE9ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			75 55	    ZONE10ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6917  277b8					       REPEND
   6918  277b8				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6919  277b8				   -	       ifconst	EXTRADLMEMORY
   6920  277b8				   -	       if	TMPMEMADDRESS > $1FFF
   6921  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6922  277b8				   -	       else
   6923  277b8				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6924  277b8				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6925  277b8				   -	       endif
   6926  277b8				   -	       endif		; TMPMEMADDRESS > $1FFF
   6927  277b8					       endif		; EXTRADLMEMORY
   6928  277b8
   6929  277b8			7a aa	    ZONE11ADDRESS =	TMPMEMADDRESS
   6930  277b8
   6931  277b8				    DLINDEX    SET	DLINDEX + 1
   6932  277b8					       REPEND
   6933  277b8
   6934  277b8
     $4000 to $7fff used as zone memory, allowing 272 display objects per zone.
   6935  277b8					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   6936  277b8
   6937  277b8				    DLHEIGHT
   6938  277b8					       REPEAT	WZONECOUNT
   6939  277b8			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277b8					       REPEND
   6939  277b9			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277b9					       REPEND
   6939  277ba			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277ba					       REPEND
   6939  277bb			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277bb					       REPEND
   6939  277bc			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277bc					       REPEND
   6939  277bd			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277bd					       REPEND
   6939  277be			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277be					       REPEND
   6939  277bf			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277bf					       REPEND
   6939  277c0			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277c0					       REPEND
   6939  277c1			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277c1					       REPEND
   6939  277c2			0f		       .byte.b	(WZONEHEIGHT-1)
   6938  277c2					       REPEND
   6939  277c3			0f		       .byte.b	(WZONEHEIGHT-1)
   6940  277c4					       REPEND
   6941  277c4
   6942  277c4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6943  277c4
   6944  277c4							; a simple guard, than ensures the 7800basic code hasn't
   6945  277c4							; spilled into the encryption area...
     1978 bytes left in the 7800basic reserved area.
   6946  277c4					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   6947  277c4				   -	       if	(*>$FF7D)
   6948  277c4				   -	       ERR		; abort the assembly
   6949  277c4					       endif
   6950  277c4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6951  277c4
   6952  277c4				   -	       ifconst	DEV
   6953  277c4				   -	       ifnconst	ZONEHEIGHT
   6954  277c4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6955  277c4				   -	       else
   6956  277c4				   -	       if	ZONEHEIGHT = 8
   6957  277c4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6958  277c4				   -	       else
   6959  277c4				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6960  277c4				   -	       endif
   6961  277c4				   -	       endif
   6962  277c4					       endif
   6963  277c4
   6964  277c4							; FF7E/FF7F contains the 7800basic crc checksum word
   6965  277c4
   6966  277c4							; FF80 - FFF7 contains the 7800 encryption key 
   6967  277c4
   6968  277c4				   -	       ifnconst	bankswitchmode
   6969  277c4				   -	       ORG	$FFF8
   6970  277c4					       else
   6971  277c4					       ifconst	ROM128K
   6972  27ff8					       ORG	$27FF8
   6973  27ff8					       RORG	$FFF8
   6974  27ff8					       endif
   6975  27ff8				   -	       ifconst	ROM144K
   6976  27ff8				   -	       ORG	$27FF8
   6977  27ff8				   -	       RORG	$FFF8
   6978  27ff8					       endif
   6979  27ff8				   -	       ifconst	ROM256K
   6980  27ff8				   -	       ORG	$47FF8
   6981  27ff8				   -	       RORG	$FFF8
   6982  27ff8					       endif
   6983  27ff8				   -	       ifconst	ROM272K
   6984  27ff8				   -	       ORG	$47FF8
   6985  27ff8				   -	       RORG	$FFF8
   6986  27ff8					       endif
   6987  27ff8				   -	       ifconst	ROM512K
   6988  27ff8				   -	       ORG	$87FF8
   6989  27ff8				   -	       RORG	$FFF8
   6990  27ff8					       endif
   6991  27ff8				   -	       ifconst	ROM528K
   6992  27ff8				   -	       ORG	$87FF8
   6993  27ff8				   -	       RORG	$FFF8
   6994  27ff8					       endif
   6995  27ff8					       endif
   6996  27ff8
   6997  27ff8
   6998  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   6999  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   7000  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   7001  27ffa
   7002  27ffa							;Vectors
   7003  27ffa			46 f1		       .word.w	NMI
   7004  27ffc			ec f6		       .word.w	START
   7005  27ffe			a5 f1		       .word.w	IRQ
   7006  28000
